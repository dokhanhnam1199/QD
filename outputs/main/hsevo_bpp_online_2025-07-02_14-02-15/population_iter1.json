[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give high priority to bins where item fits reasonably well\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]  # Remaining capacity ratio after fit. Prefer bins where there is little wastage\n    priorities[fit_mask] = 1 - priorities[fit_mask] # The smaller the waste, the higher the priority\n    # For bins that cannot fit the item, assign a very low priority (negative) to discourage placement\n    non_fit_mask = ~fit_mask\n    priorities[non_fit_mask] = -1.0  # Discourage adding to bins where item doesn't fit\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function considers several factors:\n    1. Space utilization: How much space will be occupied in the bin after adding the item.\n    2. Waste minimization: Penalizes bins where adding the item will lead to a small remaining capacity.\n    3. First Fit improvement: Prioritizes bins that can fit the item snugly.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item.\n    remaining_after_add = bins_remain_cap - item\n\n    # Assign a large negative priority to bins that can't fit the item\n    priorities[remaining_after_add < 0] = -np.inf\n\n    # Calculate a score based on space utilization (higher utilization is better)\n    utilization_score = (bins_remain_cap - remaining_after_add) / bins_remain_cap\n    utilization_score[remaining_after_add < 0] = 0 # Ignore those that cannot fit\n    priorities[remaining_after_add >= 0] += utilization_score[remaining_after_add >= 0]\n\n\n    # Penalize bins that will have very little remaining capacity (waste minimization)\n    waste_penalty = np.exp(-10 * remaining_after_add)  # Higher penalty for smaller remainders\n    waste_penalty[remaining_after_add < 0] = 0\n    priorities -= waste_penalty # Subtraction represents penalty.\n\n    # Reward bins that fit the item snugly\n    snug_fit_reward = np.exp(-5 * np.abs(remaining_after_add - (item * 0.1)))  # Peaks around 10% of item size\n\n    snug_fit_reward[remaining_after_add < 0] = 0 # cannot fit.\n    priorities += snug_fit_reward\n\n    # Bins with exactly equal remaining capacity, the smaller the better to fill.\n    priorities[remaining_after_add == 0] += 2 # extra rewards.\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.108496210610296,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Initialize priorities to a low default value.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf\n\n    # Identify bins that can actually hold the item.\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        #If no bins can fit the item, return the array of -inf priority values\n        return priorities\n\n    # Calculate the waste if the item is placed in each valid bin.\n    waste = bins_remain_cap[valid_bins] - item\n\n    # Prioritize bins based on minimizing waste (smaller waste is better).  Avoid zero division error using np.where.\n    priorities[valid_bins] = np.where(waste > 0, 1.0 / (waste + 0.00000001), 100000000)  # Use inverse of waste\n\n    # Add a bonus for bins that are already relatively full to encourage completing them.\n    fill_ratios = (1 - bins_remain_cap[valid_bins] / bins_remain_cap[valid_bins].max())\n    priorities[valid_bins] += fill_ratios  # adding a small fill ratio helps filling bins faster.\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can fit the item snugly, minimizing wasted space.\n    It also penalizes bins that cannot fit the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    \n    # Give high priority to bins that can fit the item with minimal wasted space\n    # and negative priority if the bin cannot fit\n    for i in range(len(bins_remain_cap)):\n        if wasted_space[i] >= 0:\n            # Prioritize bins where wasted space is small\n            priorities[i] = 1.0 / (1e-9 + wasted_space[i])  # Add a small value to avoid division by zero. Inverse relationship\n        else:\n            # Give a very low (negative) priority to bins that cannot fit the item\n            priorities[i] = -1000.0 # Or -np.inf\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.9999878200033 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    My ingenious method, inspired by alternating currents, prioritizes near-perfect fits and discourages significant capacity wastage, while also pushing bins closer to full when near their maximum capacity, a subtle dance of balance and efficiency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item to each bin\n    new_remain_cap = bins_remain_cap - item\n\n    # Initialize priorities\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give very negative priority to bins where the item doesn't fit\n    priorities[new_remain_cap < 0] = -np.inf\n\n    # Higher priority to bins with smaller remaining capacity after adding item, prioritizing near-perfect fits\n    valid_bins_idx = new_remain_cap >= 0\n    if np.any(valid_bins_idx):\n        priorities[valid_bins_idx] += -np.abs(new_remain_cap[valid_bins_idx])  # Avoid tiny differences by negating\n    # Penalize larger waste.\n\n    # Apply a boost when bins have smaller remaining capacity, incentivizing filling bins. The smaller the remaining the higher the boost.\n    bin_fullness_ratio = (1 - bins_remain_cap / bins_remain_cap.max())\n    priorities = priorities + bin_fullness_ratio * 10  # amplify boost a bit.\n\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Employs a more nuanced approach inspired by celestial mechanics - favoring near-perfect fits but discouraging near-misses, with a healthy dose of exploration to avoid local minima.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority for bins that can fit the item\n    fit_indices = bins_remain_cap >= item\n    priorities[fit_indices] = 1.0  # Base priority for fitting\n\n    # Refine priority based on how well the item fills the bin\n    remaining_space = bins_remain_cap[fit_indices] - item\n    fill_ratios = item / bins_remain_cap[fit_indices]\n    \n    # Reward near-perfect fits (avoiding tiny slivers of wasted space - akin to avoiding epicycles!)\n    perfect_fit_bonus = np.exp(-10 * remaining_space[remaining_space >= 0]) #sharply penalizes very small space remaining\n    priorities[fit_indices] += perfect_fit_bonus\n\n    # Discourage near-misses - prevent fragmentation. (A slight gravitational perturbation!)\n    near_miss_indices = (bins_remain_cap > 0) & (bins_remain_cap < item) # bins that can almost fit the item\n    priorities[near_miss_indices] = -np.inf # completely disincentivize\n\n    # Exploration factor to prevent premature convergence (akin to stellar drift!) - particularly at start.\n    exploration_bonus = np.random.rand(len(bins_remain_cap)) * 0.01\n\n    priorities += exploration_bonus # Ensure there is a nonzero amount of exploration\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 35.650179497407265,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers several factors:\n    1.  Remaining capacity of the bin after adding the item (avoiding overfilling).\n    2.  Waste introduced by placing the item in the bin.  We want to minimize waste.\n    3.  A slight preference for bins that are already somewhat filled (a \"first fit decreasing\" flavour).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if item <= remaining_capacity:\n            # Calculate remaining capacity *after* adding the item\n            new_remaining_capacity = remaining_capacity - item\n\n            # Waste: Smaller is better (higher priority).  Use reciprocal to convert to priority. Add small constant to avoid division by zero.\n            waste_priority = 1 / (new_remaining_capacity + 0.001)  # Small waste --> High Priority\n\n            # Bin Fill Level Preference: Encourage filling bins more completely\n            fill_level_priority = (1 - (new_remaining_capacity / 1.0)) ** 2 # assuming bin capacity = 1. Higher the fill level higher priority.\n\n            # Combine priorities:  Weighting can be tuned\n            priorities[i] = waste_priority + fill_level_priority\n        else:\n            priorities[i] = -np.inf  # Impossible to fit, make it the lowest priority\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 140.99521340247307,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins based on a combination of factors,\n    inspired by quantum mechanics principles like probability and energy levels.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Suitability based on remaining capacity (Inverse Energy, larger is better)\n    suitability = bins_remain_cap - item\n    suitability[suitability < 0] = -np.inf  # Invalid bins get very low priority\n    # scale such that if bins_remain_cap == item, we get 0\n    suitability = np.exp(suitability/item) if item > 0 else np.exp(suitability)\n    #2. Fill percentage relative to item size. Analogous to \"wave collapse\".\n    # We either fit well or we don't, and this term provides a sharp preference\n    # when we are near a perfect fit. (but never above capacity)\n    fit_ratio = item / bins_remain_cap\n    fit_term = np.exp(-np.abs(fit_ratio - 1) * 5) #Higher sharpness term.\n\n    #3. Avoidance of near-full bins, acting as an exclusion principle,\n    # preventing \"overcrowding\".\n    near_full = (bins_remain_cap < 1.1 * item) & (bins_remain_cap > item)\n    near_full_penalty = -5*near_full # Apply negative penalty.\n    #if item > 0:\n    #    near_full_penalty = -2*near_full/(item+0.0001)\n    # else:\n    #    near_full_penalty = -2*near_full\n\n    priorities = suitability + 0.8 * fit_term + near_full_penalty #Combining with weights.\n    #Prioritize larger bins. Prevents fragmenting the search space too much.\n    priorities = priorities + (bins_remain_cap/np.max(bins_remain_cap)) *0.2\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 142.33147187873953,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit-Decreasing inspired component\n    # Prioritize bins that can fit the item without too much waste.\n\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1.0 / (bins_remain_cap[fit_mask] - item + 0.0001)  # Avoid division by zero. Smaller waste, higher priority\n\n    # Next-Fit inspired component - incentivize bins close to full to finish them\n    priorities += bins_remain_cap / np.sum(bins_remain_cap + 0.0001) #Added small value to prevent zero division.\n    # Penalize bins with small amount of capacity for a small item - try to use bins with plenty of space first.\n    small_cap_penalty = np.where(bins_remain_cap < item, -np.inf, 0)\n    priorities += small_cap_penalty\n    #Large item high reward - filling up space and avoiding future placement issues.\n    large_cap_reward = np.where(bins_remain_cap > item*2,1,0) #incentivise large bins if enough capacity exists.\n    priorities += large_cap_reward\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 2.4032708416434123,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Aims to balance bin utilization and avoid fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins that can fit the item well without excessive space left.\n    fit_indices = bins_remain_cap >= item\n    if np.any(fit_indices):\n        remaining_space = bins_remain_cap[fit_indices] - item\n        # Prioritize bins where the remaining space is small, but not too small\n        priorities[fit_indices] = np.exp(-np.abs(remaining_space - np.mean(remaining_space)) / (np.std(remaining_space) + 1e-6)) # exp decaying based on closeness to mean remain\n\n        # A different heuristic: prioritize bins where the item fills a substantial portion of the bin\n        # fill_ratios = item / bins_remain_cap[fit_indices]\n        # priorities[fit_indices] = fill_ratios # linear\n        # another approach: penalize if remaining space is very small\n        small_space_indices = remaining_space < 0.1\n        priorities[fit_indices][small_space_indices] = 0.0 # significantly demote bins with very small space left after packing\n        large_space_indices = remaining_space > 0.5 # adjust 0.5 threshold\n        priorities[fit_indices][large_space_indices] *= 0.5 # slightly demote bins with significant empty space remaining\n\n    else:\n        # if item can't fit in any bin give negative prioity based on how much over capacity they are to indicate inability to fit\n        priorities = - (item - bins_remain_cap) # lower means less negative\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 60.62026326286399,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Big enough to fit, prioritize bins with smallest remaining capacity but still big enough\n    valid_bins = bins_remain_cap >= item\n    \n    if np.any(valid_bins):\n        priorities[valid_bins] = 1 / bins_remain_cap[valid_bins]  # Smaller remain cap gets higher priority\n        \n        # Further boost bins that fit almost perfectly (avoid fragmentation)\n        capacity_diff = bins_remain_cap[valid_bins] - item\n        perfect_fit_bonus = np.exp(-10 * capacity_diff) # Exponential decay from 0. Diff around 0 gets highest reward\n        \n        priorities[valid_bins] += perfect_fit_bonus\n\n    else:\n        # If no bin can fit, penalize the fuller bins less severely (hope next item is smaller). In production code, this\n\t    # could/should never happen assuming proper constraints or a provision to open a new bin when all others are full.\n\t    # Here we return a very negative value to signal that no bins can take the item for testing completeness\n        priorities = np.full_like(bins_remain_cap, -1e9) # Extremely low prio\n\n    return priorities",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by the concept of spacetime curvature in General Relativity,\n    we consider both the remaining capacity and the relative size of the item\n    to the remaining capacity, but with a non-linear, gravity-inspired approach.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero by adding a small epsilon\n    epsilon = 1e-9\n    \n    # Calculate the \"gravitational potential\" based on remaining capacity.\n    # Larger capacity means weaker \"gravity\", thus lower potential.\n    potential = -bins_remain_cap\n\n    # Calculate the \"gravitational force\" exerted by the item on each bin.\n    # A larger item exerts a stronger \"force\", especially on smaller bins.\n    # Using the inverse square law (approximated) with exponential scaling\n    # to create a highly non-linear relationship and emphasize bins\n    # that are a slightly better fit. We scale by the bin capacity to give a smaller\n    # penalty to large bins.\n    \n    force = (item / (bins_remain_cap + epsilon)**2) * np.exp(-(item-bins_remain_cap)/item)\n\n    # Combine potential and force to get the priority. Bins with a\n    # higher combined potential (lower absolute negative value) and a stronger force\n    # (item fits well) are prioritized. Subtract force from the potential.\n    # Clipping to avoid any numerical issues due to small remaining cap.\n    bins_remain_cap_clipped = np.clip(bins_remain_cap, a_min=epsilon, a_max=None)\n    \n    \n    priority = (bins_remain_cap_clipped - item)* np.exp(-np.abs(bins_remain_cap_clipped-item)/(item+epsilon)) \n    #We try prioritizing the bins, where residual_cap is closer to the item size\n    # and the remaining capacity is close to the item size. This encourages bins to not have\n    # extremely small or extremely large residual capacities.\n    #Another term to slightly discourage bins that don't fit.\n    #force = force - (item - bins_remain_cap)*(item > bins_remain_cap)\n\n    return priority",
    "response_id": 11,
    "tryHS": false,
    "obj": 40.01794974072597,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic favors bins that are nearly full after placing the item,\n    while also discouraging bins that would be overfilled. A penalty is applied\n    for bins that cannot accommodate the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin.\n    new_remain_cap = bins_remain_cap - item\n\n    # Initialize priorities with a small value.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item (remaining capacity >= 0).\n    valid_bins = new_remain_cap >= 0\n\n    # For valid bins, calculate a score based on the inverse of the new remaining capacity.\n    # This encourages filling bins as much as possible.  Add a small epsilon\n    # to avoid division by zero if the item perfectly fills the bin.\n    epsilon = 1e-9\n    priorities[valid_bins] = 1.0 / (new_remain_cap[valid_bins] + epsilon)\n\n    # Further refine by considering how close the item's size is to perfect filling.\n    # Prioritize bins where adding the item brings capacity closer to zero.\n    # Larger negative values of new_remain_cap indicate bins nearly perfectly filled.\n\n    # Add a small bonus to valid bins with large items\n    item_size_normalized = item #no normalization because item is the only parameter here\n    priorities[valid_bins] = priorities[valid_bins] + item_size_normalized\n\n    return priorities",
    "response_id": 12,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item with minimal wasted space\n    while also discouraging placements that would leave a very small amount of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Identify bins that can accommodate the item\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n        # If no bin can accommodate the item, prioritize the fullest bin based on remaining capacity,\n        # to potentially trigger creating new bins quickly instead of fragmentation.\n        priorities = bins_remain_cap\n        return priorities\n\n    # Calculate wasted space if the item were added to each bin\n    wasted_space = bins_remain_cap - item\n\n    # Reward bins with smaller wasted space (larger negative value after transformation)\n    # Only consider eligible bins\n    priorities[eligible_bins] = -wasted_space[eligible_bins]\n\n    # Discourage placements that leave very little space\n    # If remaining space is less than 10% of bin capacity, penalize it more. Empirically chosen 10%.\n    small_space_penalty = (wasted_space[eligible_bins] < 0.1 * np.max(bins_remain_cap))\n    priorities[eligible_bins][small_space_penalty] -= 10 # A relatively large penalty.\n\n\n    # If there are still ties or all priorities are negative,\n    # favor bins with larger remaining capacity (modified original heuristic, but adapted)\n    if np.all(priorities <= 0) or np.all(priorities[eligible_bins] == priorities[eligible_bins][0]):\n\n      priorities[eligible_bins] += bins_remain_cap[eligible_bins] * 0.0001 # tiny nudge based on capacity. Prevents edge cases.\n\n\n    return priorities",
    "response_id": 13,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 44, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Utilizes a combination of best-fit, almost-full, and avoid-waste strategies.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Best-fit component: Higher priority for bins with just enough space\n    space_diff = bins_remain_cap - item\n    best_fit_priority = np.where(space_diff >= 0, 1 / (space_diff + 0.001), -np.inf) # Adding a small constant to avoid division by zero and prioritize feasible bins\n    priorities += 0.6 * best_fit_priority # Weight best-fit more strongly\n\n    # Almost-full component: Give high priority to almost-full bins to finish them off.\n    almost_full_threshold = 0.1  # Define \"almost full\" (remaining capacity is less than this fraction of the bin size, assuming bin size is normalized to 1)\n    almost_full_priority = np.where(bins_remain_cap <= almost_full_threshold, 2.0, 0.0)  #High priority for almost full bins\n    priorities += 0.3 * almost_full_priority\n\n    # Avoid-waste component: Penalize bins that would leave significant unused space\n    waste_threshold = 0.3  # Define what constitutes significant waste\n    waste_penalty = np.where((space_diff > waste_threshold) & (space_diff >= 0), -0.5, 0.0)  # negative priority to penalized bins\n    priorities += 0.1 * waste_penalty\n    return priorities",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the dance of the planets and the striving for balance,\n    this function prioritizes bins that are neither too full nor too empty\n    after the item is added. A delicate equilibrium is sought, favoring\n    bins where the remaining capacity is a moderate fraction of the total.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    remaining_after_fit = bins_remain_cap - item\n    valid_bins = remaining_after_fit >= 0\n\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Assign a base priority based on how well the item fits,\n    # relative to the bin's initial capacity. A value close to 0.5 is ideal.\n    fit_ratios = (bins_remain_cap - item) / bins_remain_cap\n    priorities[valid_bins] = np.exp(-((fit_ratios[valid_bins] - 0.5) ** 2) / 0.08)  # Gaussian-like function\n\n    # Penalize near-empty bins strongly.\n    near_empty = remaining_after_fit < 0.1 * bins_remain_cap.max()\n    priorities[near_empty & valid_bins] *= 0.5  # Reduce priority, but don't eliminate\n\n    # Bins that cannot fit at all get zero priority, of course.\n    priorities[~valid_bins] = 0\n\n    return priorities",
    "response_id": 15,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 31, in priority_v2\n    near_full = (bins_remain_cap[feasible_bins] - item) < 0.1\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'multiply' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Avoid division by zero and prioritize feasible bins\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        # If no bin can accommodate the item, assign uniform low priority\n        return priorities - 1e9 # Assign lowest priority to all bins\n\n    # Prioritize bins that can fit the item, others gets lowest score.\n    priorities[~feasible_bins] = -1e9  # Very low priority for infeasible bins\n    \n    # Heuristic: Prioritize bins with remaining capacity closest to item size (First Fit Decreasing principle).\n    # Avoids creating extremely fragmented bins while still efficiently packing.\n\n    capacity_difference = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -np.abs(capacity_difference) # Negative absolute difference, so smaller difference yields higher priority\n\n    #Boost score to encourage near full packing and prevent under packing.\n    near_full = (bins_remain_cap[feasible_bins] - item) < 0.1\n    priorities[feasible_bins][near_full] += 10 #Significant boost.\n\n    # Apply a slight penalty for bins with very large remaining capacity. Helps to avoid over-allocating to already large bins if other options are good.\n    large_bins = bins_remain_cap[feasible_bins] > 0.75\n    priorities[feasible_bins][large_bins] -= 0.5\n    \n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Utilizes a heuristic inspired by potential energy wells, favoring bins\n    that can almost perfectly fit the item while also penalizing near misses\n    that would lead to significant wasted space.  Also includes a 'quantum tunneling'\n    element - a small probability of placing an item in a nearly-full bin,\n    to encourage exploration and escape local optima.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Near Fit (Potential Well): Prioritize bins where the remaining capacity\n    # is slightly larger than the item.  The closer the fit, the higher the priority.\n    fit_difference = bins_remain_cap - item\n    near_fit_mask = fit_difference >= 0\n    priorities[near_fit_mask] = np.exp(-np.abs(fit_difference[near_fit_mask]) / (item + 1e-6)) # Add small epsilon to avoid division by zero. exp handles negative values.\n\n    # 2. Penalize Large Waste: Discourage placements that leave a significant\n    # portion of the bin unused.  This prevents premature filling and improves\n    # overall bin utilization.\n\n    waste_penalty = np.where(fit_difference > 0, np.exp(-(fit_difference / np.max(bins_remain_cap))), 0)  #penalty related to relative waste size\n\n    priorities = priorities - waste_penalty # Subtract the penalty. Avoid negative scores using the correct scale.\n\n\n    # 3. \"Quantum Tunneling\":  Occasionally place an item in a bin that is *almost*\n    # full. This adds a stochastic element to help the algorithm escape local optima.\n    # The chance of \"tunneling\" should decrease as the total available space increases.\n    tunneling_potential = np.exp( - (bins_remain_cap / (item + 1e-6))**2 ) # Avoid division by zero\n    priorities = priorities + 0.01 * tunneling_potential * np.random.rand(len(bins_remain_cap))\n    # The random component ensures different results even if the tunneling potential is the same across bins.\n\n    return priorities",
    "response_id": 17,
    "tryHS": false,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First priority: Can the item even fit? If not, lowest priority\n    fit_mask = bins_remain_cap >= item\n    priorities[~fit_mask] = -np.inf  # Ensures bins that can't fit have minimal priority\n\n    # Second priority: How full will the bin be if we add the item? Prefer to fill bins\n    remaining_after_fit = bins_remain_cap[fit_mask] - item\n    fill_ratio = 1 - (remaining_after_fit / bins_remain_cap[fit_mask])  # Ratio of bin filled\n\n    # Third priority: Penalize fragmentation - higher priority to bins with smaller remaining capacity after placement\n    fragmentation_penalty = -remaining_after_fit\n    \n    #Combine the above to create an informed heuristic\n    priorities[fit_mask] = fill_ratio + 0.5 * fragmentation_penalty\n\n    return priorities",
    "response_id": 18,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 17, in priority_v2\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\nOverflowError: cannot convert float infinity to integer\n"
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Aims to balance bin usage, prioritizing bins that can fit the item\n    with minimal wasted space, but also penalizing bins that are almost full\n    to avoid creating too many nearly-full bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            # Base priority: how much of the bin the item will fill\n            fill_ratio = item / capacity\n            priorities[i] = fill_ratio\n\n            # Reward bins with less wasted space AFTER packing the item. Higher wasted_space_ratio -> lower priority.\n            wasted_space_ratio = (capacity - item) / capacity\n            priorities[i] += (1 - wasted_space_ratio) * 0.5\n\n            # Slight penalty to almost full bins to avoid excessive fragmentation\n            if wasted_space_ratio < 0.1:\n               priorities[i] -= 0.2  # Penalize heavily if only a little wasted space is left to discourage \"nearly full\" bins\n            elif wasted_space_ratio < 0.3:\n               priorities[i] -= 0.1\n    \n        else:\n            priorities[i] = -np.inf  # Cannot fit, so lowest priority\n\n    return priorities",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.108496210610296,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Reward bins where the item fits.  Favor tighter fits,\n            # and bins that are already somewhat full.\n            slack = cap - item\n            priorities[i] = 1.0 / (slack + 0.0001) + (1 - cap)  # Avoid div by zero and encourages partially full bins\n            # If there is an exact fit prioritize more, if the cap equals item\n            if abs(item - cap) < 1e-6:  # Use a small tolerance for float comparison\n                priorities[i] += 10  # Very high priority for an exact match\n\n        else:\n            # Assign a negative priority if it doesn't fit\n            priorities[i] = -1000  # Extremely low priority\n\n    return priorities",
    "response_id": 20,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with sufficient capacity and a closer fit to the item size,\n    while also penalizing bins that are too full or would become nearly full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that have sufficient remaining capacity.\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n        # If no bin has sufficient capacity, return lowest priority.\n        return priorities\n\n    # Calculate wasted space if the item were added to each bin.\n    wasted_space = bins_remain_cap - item\n\n    # Priority 1: Prefer bins with minimal wasted space *relative* to the item size.\n    # A small amount of wasted space for a large item is better than the same\n    # amount of wasted space for a small item.\n    priorities[eligible_bins] += 1.0 / (1e-9 + wasted_space[eligible_bins] / item)\n\n    # Priority 2: Bins that are almost full after placing the item are undesirable (stability penalty)\n    almost_full = (wasted_space < 0.1 * item) & eligible_bins # adjust 0.1\n    priorities[almost_full] -= 0.5 # Significant penalty to deter nearly-full bins\n\n    # Priority 3: Heavily Penalize already full/nearly-full bins\n    small_bins = (bins_remain_cap < item*1.1)\n    priorities[small_bins] -= 10\n\n    return priorities",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.15835660151576,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by gravitational force and potential energy principles. Bins with remaining capacity closer to item size will have higher priority,\n    but we also penalize bins that are too small. We also add a small bonus for bins which are closer to half the size of the incoming object.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Ensure we're working with a numpy array to leverage vectorization\n    bins_remain_cap = np.array(bins_remain_cap)\n\n    # Initialize priorities to a base level (e.g., 0)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Penalize bins that are smaller than the item\n    too_small_mask = bins_remain_cap < item\n    priorities[too_small_mask] = -np.inf  # Strongly discourage placement\n\n    # Calculate the \"gravitational force\" component:  closer the sizes, higher the force.  In this context\n    # 'force' means higher priority. Apply only where the item can fit.\n    can_fit_mask = ~too_small_mask\n    size_diff = np.abs(bins_remain_cap[can_fit_mask] - item)  # Difference in remaining capacity\n    priorities[can_fit_mask] = np.exp(-size_diff)  # Exponential decay, giving higher priority to closer sizes\n\n    #Bonus for capacity nearing 2*item\n    half_item = 2 * item\n    close_to_half_item_mask = np.logical_and(bins_remain_cap > item, bins_remain_cap < half_item)\n    close_diff = np.abs(bins_remain_cap[close_to_half_item_mask] - half_item/2)\n    priorities[close_to_half_item_mask] += 0.5 * np.exp(-close_diff)\n    return priorities",
    "response_id": 22,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins where the item fits (remaining capacity >= item size).\n    Among those bins, it prefers bins with remaining capacity closest to the item size (best fit).\n    Bins where the item does not fit are given a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins where the item fits\n    feasible_bins = bins_remain_cap >= item\n    \n    if np.any(feasible_bins):\n        # Calculate the waste (remaining capacity after adding the item) for feasible bins\n        waste = bins_remain_cap[feasible_bins] - item\n        \n        # Assign priorities based on the inverse of the waste (smaller waste -> higher priority)\n        # We use 1 / (waste + small_constant) to avoid division by zero and to ensure smaller waste gets higher priority\n        small_constant = 0.0001  # Small constant to avoid division by zero\n        priorities[feasible_bins] = 1 / (waste + small_constant)\n\n    #Give zero priority if no bin fits the item\n    \n    return priorities",
    "response_id": 23,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Electrify the selection!\n    # Heuristic 1: Fill nearly full bins first (but avoid overflowing).\n    # Heuristic 2: Prioritize bins that can accommodate the item perfectly,\n    #             to minimize fragmentation. If there's a perfect fit, it dominates.\n    # Heuristic 3: If no perfect fit, prefer bins that can fit the item, giving higher\n    #             priority to those with smaller remaining space *after* the item is placed.\n    # Heuristic 4: Heavily penalize bins that cannot accommodate the item.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the remaining capacity after placing the item\n    remaining_after_placement = bins_remain_cap - item\n\n    # Penalize bins that cannot accommodate the item\n    infeasible = remaining_after_placement < 0\n    priorities[infeasible] = -np.inf  # A cosmic force repels the impossible!\n\n    # Perfect fit: Infinite priority!\n    perfect_fit = np.isclose(remaining_after_placement, 0)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = np.inf # The hum of resonance compels selection!\n        return priorities # The perfect match dominates.\n\n    # Bins that can fit, prioritize by how full they become *after* the item is placed\n    # Higher is better: closer to full, lower fragmentation. We want to minimize waste.\n    feasible = remaining_after_placement >= 0\n\n    if np.any(feasible):\n      priorities[feasible] = 1.0 / (remaining_after_placement[feasible] + 1e-9) # Avoid division by zero. Make the bin most full\n      priorities[feasible] = priorities[feasible]  + (bins_remain_cap[feasible]/ np.sum(bins_remain_cap[feasible])) #Prioritize lower index bin\n      #Normalize\n      priorities[feasible] = priorities[feasible]/np.max(priorities[feasible])\n    return priorities",
    "response_id": 24,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    A new perspective! Bins closer in capacity to the item are favored, but with\n    a penalty for near-overflow. Larger remaining capacities are also favored to\n    ensure we don't fill all bins with small items prematurely.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero. Assign a very low priority in this case.\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the difference between remaining capacity and item size.\n    capacity_diff = bins_remain_cap - item\n\n    # Favor bins where the item fits well. Penalize negative differences severely.\n    fit_score = np.exp(-np.abs(capacity_diff) / item)\n    fit_score[capacity_diff < 0] = -np.inf # Item does not fit\n\n    # Favor bins that are not too full.  Apply a moderate remaining capacity score.\n    capacity_score = bins_remain_cap / np.sum(bins_remain_cap) if np.sum(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap) # Normalize for consistent impact. Avoid division by zero when all bins are empty\n\n    #Combine to create total Priority\n    priorities = fit_score + capacity_score\n\n    # Mask bins with remaining capacity equal to 0 with -inf\n    priorities[bins_remain_cap <= 0] = -np.inf\n\n    return priorities",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.058635819704831,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates several heuristics to improve bin packing:\n    1.  Avoids bins that are too full or too empty for the current item.\n    2.  Favors bins where the item fits relatively snugly (minimize wasted space).\n    3.  Introduces a small amount of randomness to avoid getting stuck in local optima.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Penalize bins that are too small or too large\n    small_threshold = 0.1  # Avoid bins with capacity < 10% more than the item\n    large_threshold = 0.9  # Avoid bins with capacity > 90% more than the item. This prevents large items blocking too much space.\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap < item:\n            priorities[i] = -np.inf  # Cannot fit\n        elif cap < item * (1 + small_threshold):\n            priorities[i] -= 1000  # Somewhat Penalize almost full bins, but still potentially allow\n\n        if cap > item * (1 + large_threshold):\n             priorities[i] -= 50  # Penalize bins with significantly more capacity, avoid spreading the items too thinly.\n\n        # Calculate wasted space if item is placed in the bin\n        wasted_space = cap - item\n\n        # Give a higher priority to bins that minimize wasted space. An exponential penalty\n        # creates a higher pressure to fill nearly full bins.\n        priorities[i] += np.exp(-wasted_space)\n\n\n    # Add small random number to break ties and escape local minima\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.01\n\n    return priorities",
    "response_id": 26,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99998938999488 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # 1. Feasibility check: Disqualify bins that are too small.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Strongly discourage infeasible bins\n\n    # Consider only feasible bins now.\n\n    # 2. First Fit Decreasing (FFD) inspired:\n    # Prefer bins that are filled more (less remaining capacity) amongst feasible ones.\n    # But give it a boost if it almost perfectly fits, or discourage if wastes too much.\n    feasible_mask = ~infeasible_mask\n    if np.any(feasible_mask):\n        remaining_capacity_feasible = bins_remain_cap[feasible_mask]\n        \n        # Encourage near perfect fits\n        near_perfect_fit = np.exp(-np.abs(remaining_capacity_feasible - item) / (0.1 * item + 1e-6)) # gaussian around item\n\n        #Discourage bins that has item+0.2* item less capacity.\n        waste_penalty = -np.exp( (remaining_capacity_feasible-item)/(0.2 * item + 1e-6))\n\n        # base priority on the inverse capacity * near perfect fit ( or waste)\n        priorities[feasible_mask] = (near_perfect_fit + waste_penalty)/ remaining_capacity_feasible\n       # Scale priorities to avoid large numbers which may cause errors\n        priorities[feasible_mask] = priorities[feasible_mask] / (np.max(np.abs(priorities[feasible_mask])) + 1e-6)\n    \n    return priorities",
    "response_id": 27,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 17, in priority_v2\n    \nOverflowError: cannot convert float infinity to integer\n"
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap) - np.inf  # No valid bins\n\n    ratios = np.where(valid_bins, item / bins_remain_cap, np.inf)\n    \n    # Prioritize bins that can fit the item well, but not too perfectly. Avoid fragmentation.\n    # Use a Gaussian-like function centered around the \"ideal\" fill ratio (e.g., 0.8).\n\n    ideal_ratio = 0.8\n    scale = 0.2  # Adjust the sensitivity of the Gaussian\n\n    gaussian_priorities = np.exp(-((ratios - ideal_ratio)**2) / (2 * scale**2))\n\n    # Add a small bonus to bins that are already somewhat full\n    occupancy_ratio = 1 - bins_remain_cap / np.max(bins_remain_cap) #normalize by max capacity of all bins, could also normalise by fixed bin capacity\n    fullness_bonus = occupancy_ratio * 0.1\n\n    #Give the best bin that can fit item high priority\n    can_fit = (bins_remain_cap >= item)\n\n    fit_priority = np.where(can_fit,1,0)\n    \n\n    #Combine Gaussian priority, bonus, and large fit penalty\n    priorities = gaussian_priorities + fullness_bonus+fit_priority*10\n\n    #if a bin cannot fit the item, its priority should be very small (effectively should not be chosen if possible)\n    priorities = np.where(can_fit, priorities, -np.inf)\n    \n\n    return priorities",
    "response_id": 28,
    "tryHS": false,
    "obj": 6.601515755883532,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Higher value means higher priority.\n\n    This version prioritizes bins that can accommodate the item\n    with minimal remaining space, but also penalizes bins that are\n    too full (close to full capacity after placing the item) as well\n    as nearly empty bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Filter out bins that cannot accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    if not np.any(valid_bins):\n        # If no bin can accommodate the item, assign a small, negative priority\n        # to all bins to represent that none of them are suitable. This forces the creation\n        # of a new bin by a higher level strategy\n        return np.full_like(bins_remain_cap, -1.0)\n\n    # Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap - item\n\n    # Calculate utilization after placing the item (relative to original capacity, assumed to be 1)\n    utilization = 1 - remaining_space\n    \n    # Calculate score for the valid bins. \n    # A higher score suggests a better fit\n\n    # Score based on how tightly the item fits. Bins with low remaining space get a boost.\n    tightness_score = np.exp(-5 * remaining_space) #Exponentially favors small remaining spaces\n    #Avoid division by zero. When remaining_space is zero it becomes Inf so clip the max.\n    tightness_score = np.clip(tightness_score, a_min = 0, a_max = 1e5)\n        \n    # Score based on the utilization. Slightly prefer not filling the bin too much.\n    utilization_score = np.exp(-2 * (utilization - 0.75)**2) # prefer near 0.75 fill\n\n    #Combine both scores\n    priorities[valid_bins] = tightness_score[valid_bins] * utilization_score[valid_bins]\n    \n    return priorities",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.0885520542481055,
    "exec_success": true
  }
]