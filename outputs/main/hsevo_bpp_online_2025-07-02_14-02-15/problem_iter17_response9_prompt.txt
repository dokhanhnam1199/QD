{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes best-fit with adaptive stochasticity and dynamic sweet spot.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if np.any(feasible_bins):\n        waste = bins_remain_cap[feasible_bins] - item\n\n        # Best-fit prioritization.\n        priorities[feasible_bins] = 1 / (waste + 0.00001)\n\n        # Adaptive stochasticity: smaller items, more exploration.\n        exploration_factor = max(0, 0.1 - (item * 0.05))\n        num_feasible = np.sum(feasible_bins)\n        priorities[feasible_bins] += np.random.rand(num_feasible) * exploration_factor\n\n        # Sweet Spot Incentive\n        sweet_spot_lower = 0.7 - (item * 0.1)\n        sweet_spot_upper = 0.9 - (item * 0.05)\n        utilization = (bins_remain_cap[feasible_bins] - waste) / 1.0\n        sweet_spot = (utilization > sweet_spot_lower) & (utilization < sweet_spot_upper)\n        priorities[feasible_bins][sweet_spot] += 0.4\n        \n        # Fragmentation penalty: Apply a moderate penalty for small waste, only if other bins exist\n        small_waste = (waste < 0.1)\n        if np.sum(feasible_bins) > 1:\n            priorities[feasible_bins][small_waste] *= 0.5 #reduce priority\n\n    else:\n        priorities[:] = -np.inf\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes best-fit with adaptive penalties and dynamic exploration,\n    with improvements on fragmentation handling and bin selection based on item size.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if np.any(feasible_bins):\n        waste = bins_remain_cap[feasible_bins] - item\n        \n        # Core: Prioritize best fit (minimize waste). Adding a small constant to avoid division by zero\n        priorities[feasible_bins] = 1 / (waste + 0.00001)\n\n        # Adaptive Stochasticity: Exploration based on number of feasible bins and item size.\n        num_feasible = np.sum(feasible_bins)\n        exploration_factor = min(0.3, 0.05 * num_feasible * (1 - item))  # Scale exploration by item size\n        priorities[feasible_bins] += np.random.rand(num_feasible) * exploration_factor\n\n        # Fragmentation Penalty: More aggressive penalty for bins nearing full capacity.\n        wasted_space_ratio = waste / bins_remain_cap[feasible_bins]\n        almost_full = wasted_space_ratio < 0.1 #Slightly relaxed to encourage use.\n        priorities[feasible_bins][almost_full] *= 0.3  # Increased penalty to discourage further fragmentation.\n\n        # Rewarding larger bins for smaller items\n        small_item_large_bin_reward = np.where(bins_remain_cap[feasible_bins] > 1.2 * item + 0.2, 0.5, 0) #Adjusted condition to favor larger bins even more.\n        priorities[feasible_bins] += small_item_large_bin_reward\n\n        # Dynamic \"Sweet Spot\" Incentive: Adapt the range based on item size.\n        sweet_spot_lower = 0.6 - (item * 0.3)  #Adjusted parameters for larger impact of item size\n        sweet_spot_upper = 0.9 - (item * 0.2)  #Also adjusted to accommodate possible waste.\n\n        utilization = (bins_remain_cap[feasible_bins] - waste) / 1.0  # Assuming bin size is 1\n        sweet_spot = (utilization > sweet_spot_lower) & (utilization < sweet_spot_upper)\n        priorities[feasible_bins][sweet_spot] += 0.6 #Increased incentive to maximize utilization of bins.\n\n        # Bonus for filling a bin completely (or near-completely)\n        almost_full_bin = waste < 0.05\n        priorities[feasible_bins][almost_full_bin] += 0.8  #Major reward for filling a bin.\n\n    else:\n        priorities[:] = -np.inf  # No feasible bins\n\n    return priorities\n\n### Analyze & experience\n- *   **Comparing (1st) vs (20th):** The first heuristic employs a more sophisticated and configurable approach, utilizing numerous tunable parameters to fine-tune the bin selection process. It incorporates a bin usage history penalty (if available) and defines sweet spots with parameters. The 20th heuristic lacks the bin usage history and has simpler sweet spot definitions.\n\n*   **Comparing (2nd) vs (19th):** The 2nd heuristic is similar to the 19th, but has less aggressive bonuses and penalties.\n\n*   **Comparing (1st) vs (2nd):** The first heuristic introduces configurable parameters, bin usage history, refined exploration with `exploration_base`, `max_exploration`, `sweet_spot_lower_base`, `sweet_spot_lower_item_scale`, `sweet_spot_upper_base`, `sweet_spot_upper_item_scale`, `sweet_spot_reward`, `usage_penalty_factor` and `tiny_constant`. The second heuristic has simpler parameters.\n\n*   **Comparing (3rd) vs (4th):** The fourth heuristic incorporates bin diversity (capacity standard deviation) into the exploration factor and sweet spot definition, as well as penalizing bins that will have very little space left after adding the item. The third heuristic lacks these features.\n\n*   **Comparing (19th) vs (20th):** Both are virtually identical.\n\n*   **Comparing (17th) vs (18th):** Both are virtually identical.\n\n*   **Comparing (15th) vs (16th):** All are virtually identical.\n\n*   **Comparing (second worst) vs (worst):** They have very similar logic but the best-fit epsilon variable.\n\n*   **Overall:** Better heuristics incorporate more adaptive and nuanced mechanisms such as:\n\n    *   **Configurable Parameters:** Allow for fine-tuning of various aspects of the heuristic, like exploration rate, fragmentation penalties, and sweet spot definitions.\n    *   **Bin Usage History:** Penalizing recently used bins can promote a more balanced utilization of available bins.\n    *   **Dynamic Sweet Spots:** Adjusting the \"sweet spot\" range based on item size helps to optimize bin utilization.\n    *   **Bin Diversity:** Consider the standard deviation of bin capacities to influence exploration.\n    *   **Item-Aware Penalties/Rewards:** Scaling penalties and rewards based on item size can improve overall performance.\n- \nOkay, let's refine \"Current self-reflection\" for better heuristic design, steering clear of the pitfalls outlined in \"Ineffective self-reflection.\"\n\nHere's a breakdown to guide improvements:\n\n*   **Keywords:** Adaptive, iterative, empirical, balance, problem-aware.\n\n*   **Advice:** Begin with a simple, demonstrably effective heuristic core. Incrementally add complexity only when justified by empirical results. Prioritize problem-aware adaptations over excessive parameters.\n\n*   **Avoid:** Over-engineering, non-linear complexity without justification, fixed stochasticity, and premature optimization. Avoid adding features without understanding their isolated effects.\n\n*   **Explanation:** Focus on *why* an adaptation helps, not just *that* it does. Small, problem-aware adjustments are better than large, untuned ones. Build incrementally, validating each addition.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}