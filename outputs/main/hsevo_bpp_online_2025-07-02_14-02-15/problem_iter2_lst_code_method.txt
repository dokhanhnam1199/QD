{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Utilizes a heuristic inspired by potential energy wells, favoring bins\n    that can almost perfectly fit the item while also penalizing near misses\n    that would lead to significant wasted space.  Also includes a 'quantum tunneling'\n    element - a small probability of placing an item in a nearly-full bin,\n    to encourage exploration and escape local optima.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Near Fit (Potential Well): Prioritize bins where the remaining capacity\n    # is slightly larger than the item.  The closer the fit, the higher the priority.\n    fit_difference = bins_remain_cap - item\n    near_fit_mask = fit_difference >= 0\n    priorities[near_fit_mask] = np.exp(-np.abs(fit_difference[near_fit_mask]) / (item + 1e-6)) # Add small epsilon to avoid division by zero. exp handles negative values.\n\n    # 2. Penalize Large Waste: Discourage placements that leave a significant\n    # portion of the bin unused.  This prevents premature filling and improves\n    # overall bin utilization.\n\n    waste_penalty = np.where(fit_difference > 0, np.exp(-(fit_difference / np.max(bins_remain_cap))), 0)  #penalty related to relative waste size\n\n    priorities = priorities - waste_penalty # Subtract the penalty. Avoid negative scores using the correct scale.\n\n\n    # 3. \"Quantum Tunneling\":  Occasionally place an item in a bin that is *almost*\n    # full. This adds a stochastic element to help the algorithm escape local optima.\n    # The chance of \"tunneling\" should decrease as the total available space increases.\n    tunneling_potential = np.exp( - (bins_remain_cap / (item + 1e-6))**2 ) # Avoid division by zero\n    priorities = priorities + 0.01 * tunneling_potential * np.random.rand(len(bins_remain_cap))\n    # The random component ensures different results even if the tunneling potential is the same across bins.\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    My ingenious method, inspired by alternating currents, prioritizes near-perfect fits and discourages significant capacity wastage, while also pushing bins closer to full when near their maximum capacity, a subtle dance of balance and efficiency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item to each bin\n    new_remain_cap = bins_remain_cap - item\n\n    # Initialize priorities\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give very negative priority to bins where the item doesn't fit\n    priorities[new_remain_cap < 0] = -np.inf\n\n    # Higher priority to bins with smaller remaining capacity after adding item, prioritizing near-perfect fits\n    valid_bins_idx = new_remain_cap >= 0\n    if np.any(valid_bins_idx):\n        priorities[valid_bins_idx] += -np.abs(new_remain_cap[valid_bins_idx])  # Avoid tiny differences by negating\n    # Penalize larger waste.\n\n    # Apply a boost when bins have smaller remaining capacity, incentivizing filling bins. The smaller the remaining the higher the boost.\n    bin_fullness_ratio = (1 - bins_remain_cap / bins_remain_cap.max())\n    priorities = priorities + bin_fullness_ratio * 10  # amplify boost a bit.\n\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Initialize priorities to a low default value.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf\n\n    # Identify bins that can actually hold the item.\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        #If no bins can fit the item, return the array of -inf priority values\n        return priorities\n\n    # Calculate the waste if the item is placed in each valid bin.\n    waste = bins_remain_cap[valid_bins] - item\n\n    # Prioritize bins based on minimizing waste (smaller waste is better).  Avoid zero division error using np.where.\n    priorities[valid_bins] = np.where(waste > 0, 1.0 / (waste + 0.00000001), 100000000)  # Use inverse of waste\n\n    # Add a bonus for bins that are already relatively full to encourage completing them.\n    fill_ratios = (1 - bins_remain_cap[valid_bins] / bins_remain_cap[valid_bins].max())\n    priorities[valid_bins] += fill_ratios  # adding a small fill ratio helps filling bins faster.\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins where the item fits (remaining capacity >= item size).\n    Among those bins, it prefers bins with remaining capacity closest to the item size (best fit).\n    Bins where the item does not fit are given a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins where the item fits\n    feasible_bins = bins_remain_cap >= item\n    \n    if np.any(feasible_bins):\n        # Calculate the waste (remaining capacity after adding the item) for feasible bins\n        waste = bins_remain_cap[feasible_bins] - item\n        \n        # Assign priorities based on the inverse of the waste (smaller waste -> higher priority)\n        # We use 1 / (waste + small_constant) to avoid division by zero and to ensure smaller waste gets higher priority\n        small_constant = 0.0001  # Small constant to avoid division by zero\n        priorities[feasible_bins] = 1 / (waste + small_constant)\n\n    #Give zero priority if no bin fits the item\n    \n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Big enough to fit, prioritize bins with smallest remaining capacity but still big enough\n    valid_bins = bins_remain_cap >= item\n    \n    if np.any(valid_bins):\n        priorities[valid_bins] = 1 / bins_remain_cap[valid_bins]  # Smaller remain cap gets higher priority\n        \n        # Further boost bins that fit almost perfectly (avoid fragmentation)\n        capacity_diff = bins_remain_cap[valid_bins] - item\n        perfect_fit_bonus = np.exp(-10 * capacity_diff) # Exponential decay from 0. Diff around 0 gets highest reward\n        \n        priorities[valid_bins] += perfect_fit_bonus\n\n    else:\n        # If no bin can fit, penalize the fuller bins less severely (hope next item is smaller). In production code, this\n\t    # could/should never happen assuming proper constraints or a provision to open a new bin when all others are full.\n\t    # Here we return a very negative value to signal that no bins can take the item for testing completeness\n        priorities = np.full_like(bins_remain_cap, -1e9) # Extremely low prio\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Reward bins where the item fits.  Favor tighter fits,\n            # and bins that are already somewhat full.\n            slack = cap - item\n            priorities[i] = 1.0 / (slack + 0.0001) + (1 - cap)  # Avoid div by zero and encourages partially full bins\n            # If there is an exact fit prioritize more, if the cap equals item\n            if abs(item - cap) < 1e-6:  # Use a small tolerance for float comparison\n                priorities[i] += 10  # Very high priority for an exact match\n\n        else:\n            # Assign a negative priority if it doesn't fit\n            priorities[i] = -1000  # Extremely low priority\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Reward bins where the item fits.  Favor tighter fits,\n            # and bins that are already somewhat full.\n            slack = cap - item\n            priorities[i] = 1.0 / (slack + 0.0001) + (1 - cap)  # Avoid div by zero and encourages partially full bins\n            # If there is an exact fit prioritize more, if the cap equals item\n            if abs(item - cap) < 1e-6:  # Use a small tolerance for float comparison\n                priorities[i] += 10  # Very high priority for an exact match\n\n        else:\n            # Assign a negative priority if it doesn't fit\n            priorities[i] = -1000  # Extremely low priority\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Higher value means higher priority.\n\n    This version prioritizes bins that can accommodate the item\n    with minimal remaining space, but also penalizes bins that are\n    too full (close to full capacity after placing the item) as well\n    as nearly empty bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Filter out bins that cannot accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    if not np.any(valid_bins):\n        # If no bin can accommodate the item, assign a small, negative priority\n        # to all bins to represent that none of them are suitable. This forces the creation\n        # of a new bin by a higher level strategy\n        return np.full_like(bins_remain_cap, -1.0)\n\n    # Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap - item\n\n    # Calculate utilization after placing the item (relative to original capacity, assumed to be 1)\n    utilization = 1 - remaining_space\n    \n    # Calculate score for the valid bins. \n    # A higher score suggests a better fit\n\n    # Score based on how tightly the item fits. Bins with low remaining space get a boost.\n    tightness_score = np.exp(-5 * remaining_space) #Exponentially favors small remaining spaces\n    #Avoid division by zero. When remaining_space is zero it becomes Inf so clip the max.\n    tightness_score = np.clip(tightness_score, a_min = 0, a_max = 1e5)\n        \n    # Score based on the utilization. Slightly prefer not filling the bin too much.\n    utilization_score = np.exp(-2 * (utilization - 0.75)**2) # prefer near 0.75 fill\n\n    #Combine both scores\n    priorities[valid_bins] = tightness_score[valid_bins] * utilization_score[valid_bins]\n    \n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Aims to balance bin usage, prioritizing bins that can fit the item\n    with minimal wasted space, but also penalizing bins that are almost full\n    to avoid creating too many nearly-full bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            # Base priority: how much of the bin the item will fill\n            fill_ratio = item / capacity\n            priorities[i] = fill_ratio\n\n            # Reward bins with less wasted space AFTER packing the item. Higher wasted_space_ratio -> lower priority.\n            wasted_space_ratio = (capacity - item) / capacity\n            priorities[i] += (1 - wasted_space_ratio) * 0.5\n\n            # Slight penalty to almost full bins to avoid excessive fragmentation\n            if wasted_space_ratio < 0.1:\n               priorities[i] -= 0.2  # Penalize heavily if only a little wasted space is left to discourage \"nearly full\" bins\n            elif wasted_space_ratio < 0.3:\n               priorities[i] -= 0.1\n    \n        else:\n            priorities[i] = -np.inf  # Cannot fit, so lowest priority\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Aims to balance bin usage, prioritizing bins that can fit the item\n    with minimal wasted space, but also penalizing bins that are almost full\n    to avoid creating too many nearly-full bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            # Base priority: how much of the bin the item will fill\n            fill_ratio = item / capacity\n            priorities[i] = fill_ratio\n\n            # Reward bins with less wasted space AFTER packing the item. Higher wasted_space_ratio -> lower priority.\n            wasted_space_ratio = (capacity - item) / capacity\n            priorities[i] += (1 - wasted_space_ratio) * 0.5\n\n            # Slight penalty to almost full bins to avoid excessive fragmentation\n            if wasted_space_ratio < 0.1:\n               priorities[i] -= 0.2  # Penalize heavily if only a little wasted space is left to discourage \"nearly full\" bins\n            elif wasted_space_ratio < 0.3:\n               priorities[i] -= 0.1\n    \n        else:\n            priorities[i] = -np.inf  # Cannot fit, so lowest priority\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Aims to balance bin usage, prioritizing bins that can fit the item\n    with minimal wasted space, but also penalizing bins that are almost full\n    to avoid creating too many nearly-full bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            # Base priority: how much of the bin the item will fill\n            fill_ratio = item / capacity\n            priorities[i] = fill_ratio\n\n            # Reward bins with less wasted space AFTER packing the item. Higher wasted_space_ratio -> lower priority.\n            wasted_space_ratio = (capacity - item) / capacity\n            priorities[i] += (1 - wasted_space_ratio) * 0.5\n\n            # Slight penalty to almost full bins to avoid excessive fragmentation\n            if wasted_space_ratio < 0.1:\n               priorities[i] -= 0.2  # Penalize heavily if only a little wasted space is left to discourage \"nearly full\" bins\n            elif wasted_space_ratio < 0.3:\n               priorities[i] -= 0.1\n    \n        else:\n            priorities[i] = -np.inf  # Cannot fit, so lowest priority\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function considers several factors:\n    1. Space utilization: How much space will be occupied in the bin after adding the item.\n    2. Waste minimization: Penalizes bins where adding the item will lead to a small remaining capacity.\n    3. First Fit improvement: Prioritizes bins that can fit the item snugly.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item.\n    remaining_after_add = bins_remain_cap - item\n\n    # Assign a large negative priority to bins that can't fit the item\n    priorities[remaining_after_add < 0] = -np.inf\n\n    # Calculate a score based on space utilization (higher utilization is better)\n    utilization_score = (bins_remain_cap - remaining_after_add) / bins_remain_cap\n    utilization_score[remaining_after_add < 0] = 0 # Ignore those that cannot fit\n    priorities[remaining_after_add >= 0] += utilization_score[remaining_after_add >= 0]\n\n\n    # Penalize bins that will have very little remaining capacity (waste minimization)\n    waste_penalty = np.exp(-10 * remaining_after_add)  # Higher penalty for smaller remainders\n    waste_penalty[remaining_after_add < 0] = 0\n    priorities -= waste_penalty # Subtraction represents penalty.\n\n    # Reward bins that fit the item snugly\n    snug_fit_reward = np.exp(-5 * np.abs(remaining_after_add - (item * 0.1)))  # Peaks around 10% of item size\n\n    snug_fit_reward[remaining_after_add < 0] = 0 # cannot fit.\n    priorities += snug_fit_reward\n\n    # Bins with exactly equal remaining capacity, the smaller the better to fill.\n    priorities[remaining_after_add == 0] += 2 # extra rewards.\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with sufficient capacity and a closer fit to the item size,\n    while also penalizing bins that are too full or would become nearly full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that have sufficient remaining capacity.\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n        # If no bin has sufficient capacity, return lowest priority.\n        return priorities\n\n    # Calculate wasted space if the item were added to each bin.\n    wasted_space = bins_remain_cap - item\n\n    # Priority 1: Prefer bins with minimal wasted space *relative* to the item size.\n    # A small amount of wasted space for a large item is better than the same\n    # amount of wasted space for a small item.\n    priorities[eligible_bins] += 1.0 / (1e-9 + wasted_space[eligible_bins] / item)\n\n    # Priority 2: Bins that are almost full after placing the item are undesirable (stability penalty)\n    almost_full = (wasted_space < 0.1 * item) & eligible_bins # adjust 0.1\n    priorities[almost_full] -= 0.5 # Significant penalty to deter nearly-full bins\n\n    # Priority 3: Heavily Penalize already full/nearly-full bins\n    small_bins = (bins_remain_cap < item*1.1)\n    priorities[small_bins] -= 10\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with sufficient capacity and a closer fit to the item size,\n    while also penalizing bins that are too full or would become nearly full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that have sufficient remaining capacity.\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n        # If no bin has sufficient capacity, return lowest priority.\n        return priorities\n\n    # Calculate wasted space if the item were added to each bin.\n    wasted_space = bins_remain_cap - item\n\n    # Priority 1: Prefer bins with minimal wasted space *relative* to the item size.\n    # A small amount of wasted space for a large item is better than the same\n    # amount of wasted space for a small item.\n    priorities[eligible_bins] += 1.0 / (1e-9 + wasted_space[eligible_bins] / item)\n\n    # Priority 2: Bins that are almost full after placing the item are undesirable (stability penalty)\n    almost_full = (wasted_space < 0.1 * item) & eligible_bins # adjust 0.1\n    priorities[almost_full] -= 0.5 # Significant penalty to deter nearly-full bins\n\n    # Priority 3: Heavily Penalize already full/nearly-full bins\n    small_bins = (bins_remain_cap < item*1.1)\n    priorities[small_bins] -= 10\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with sufficient capacity and a closer fit to the item size,\n    while also penalizing bins that are too full or would become nearly full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that have sufficient remaining capacity.\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n        # If no bin has sufficient capacity, return lowest priority.\n        return priorities\n\n    # Calculate wasted space if the item were added to each bin.\n    wasted_space = bins_remain_cap - item\n\n    # Priority 1: Prefer bins with minimal wasted space *relative* to the item size.\n    # A small amount of wasted space for a large item is better than the same\n    # amount of wasted space for a small item.\n    priorities[eligible_bins] += 1.0 / (1e-9 + wasted_space[eligible_bins] / item)\n\n    # Priority 2: Bins that are almost full after placing the item are undesirable (stability penalty)\n    almost_full = (wasted_space < 0.1 * item) & eligible_bins # adjust 0.1\n    priorities[almost_full] -= 0.5 # Significant penalty to deter nearly-full bins\n\n    # Priority 3: Heavily Penalize already full/nearly-full bins\n    small_bins = (bins_remain_cap < item*1.1)\n    priorities[small_bins] -= 10\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap) - np.inf  # No valid bins\n\n    ratios = np.where(valid_bins, item / bins_remain_cap, np.inf)\n    \n    # Prioritize bins that can fit the item well, but not too perfectly. Avoid fragmentation.\n    # Use a Gaussian-like function centered around the \"ideal\" fill ratio (e.g., 0.8).\n\n    ideal_ratio = 0.8\n    scale = 0.2  # Adjust the sensitivity of the Gaussian\n\n    gaussian_priorities = np.exp(-((ratios - ideal_ratio)**2) / (2 * scale**2))\n\n    # Add a small bonus to bins that are already somewhat full\n    occupancy_ratio = 1 - bins_remain_cap / np.max(bins_remain_cap) #normalize by max capacity of all bins, could also normalise by fixed bin capacity\n    fullness_bonus = occupancy_ratio * 0.1\n\n    #Give the best bin that can fit item high priority\n    can_fit = (bins_remain_cap >= item)\n\n    fit_priority = np.where(can_fit,1,0)\n    \n\n    #Combine Gaussian priority, bonus, and large fit penalty\n    priorities = gaussian_priorities + fullness_bonus+fit_priority*10\n\n    #if a bin cannot fit the item, its priority should be very small (effectively should not be chosen if possible)\n    priorities = np.where(can_fit, priorities, -np.inf)\n    \n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Employs a more nuanced approach inspired by celestial mechanics - favoring near-perfect fits but discouraging near-misses, with a healthy dose of exploration to avoid local minima.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority for bins that can fit the item\n    fit_indices = bins_remain_cap >= item\n    priorities[fit_indices] = 1.0  # Base priority for fitting\n\n    # Refine priority based on how well the item fills the bin\n    remaining_space = bins_remain_cap[fit_indices] - item\n    fill_ratios = item / bins_remain_cap[fit_indices]\n    \n    # Reward near-perfect fits (avoiding tiny slivers of wasted space - akin to avoiding epicycles!)\n    perfect_fit_bonus = np.exp(-10 * remaining_space[remaining_space >= 0]) #sharply penalizes very small space remaining\n    priorities[fit_indices] += perfect_fit_bonus\n\n    # Discourage near-misses - prevent fragmentation. (A slight gravitational perturbation!)\n    near_miss_indices = (bins_remain_cap > 0) & (bins_remain_cap < item) # bins that can almost fit the item\n    priorities[near_miss_indices] = -np.inf # completely disincentivize\n\n    # Exploration factor to prevent premature convergence (akin to stellar drift!) - particularly at start.\n    exploration_bonus = np.random.rand(len(bins_remain_cap)) * 0.01\n\n    priorities += exploration_bonus # Ensure there is a nonzero amount of exploration\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by the concept of spacetime curvature in General Relativity,\n    we consider both the remaining capacity and the relative size of the item\n    to the remaining capacity, but with a non-linear, gravity-inspired approach.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero by adding a small epsilon\n    epsilon = 1e-9\n    \n    # Calculate the \"gravitational potential\" based on remaining capacity.\n    # Larger capacity means weaker \"gravity\", thus lower potential.\n    potential = -bins_remain_cap\n\n    # Calculate the \"gravitational force\" exerted by the item on each bin.\n    # A larger item exerts a stronger \"force\", especially on smaller bins.\n    # Using the inverse square law (approximated) with exponential scaling\n    # to create a highly non-linear relationship and emphasize bins\n    # that are a slightly better fit. We scale by the bin capacity to give a smaller\n    # penalty to large bins.\n    \n    force = (item / (bins_remain_cap + epsilon)**2) * np.exp(-(item-bins_remain_cap)/item)\n\n    # Combine potential and force to get the priority. Bins with a\n    # higher combined potential (lower absolute negative value) and a stronger force\n    # (item fits well) are prioritized. Subtract force from the potential.\n    # Clipping to avoid any numerical issues due to small remaining cap.\n    bins_remain_cap_clipped = np.clip(bins_remain_cap, a_min=epsilon, a_max=None)\n    \n    \n    priority = (bins_remain_cap_clipped - item)* np.exp(-np.abs(bins_remain_cap_clipped-item)/(item+epsilon)) \n    #We try prioritizing the bins, where residual_cap is closer to the item size\n    # and the remaining capacity is close to the item size. This encourages bins to not have\n    # extremely small or extremely large residual capacities.\n    #Another term to slightly discourage bins that don't fit.\n    #force = force - (item - bins_remain_cap)*(item > bins_remain_cap)\n\n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Aims to balance bin utilization and avoid fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins that can fit the item well without excessive space left.\n    fit_indices = bins_remain_cap >= item\n    if np.any(fit_indices):\n        remaining_space = bins_remain_cap[fit_indices] - item\n        # Prioritize bins where the remaining space is small, but not too small\n        priorities[fit_indices] = np.exp(-np.abs(remaining_space - np.mean(remaining_space)) / (np.std(remaining_space) + 1e-6)) # exp decaying based on closeness to mean remain\n\n        # A different heuristic: prioritize bins where the item fills a substantial portion of the bin\n        # fill_ratios = item / bins_remain_cap[fit_indices]\n        # priorities[fit_indices] = fill_ratios # linear\n        # another approach: penalize if remaining space is very small\n        small_space_indices = remaining_space < 0.1\n        priorities[fit_indices][small_space_indices] = 0.0 # significantly demote bins with very small space left after packing\n        large_space_indices = remaining_space > 0.5 # adjust 0.5 threshold\n        priorities[fit_indices][large_space_indices] *= 0.5 # slightly demote bins with significant empty space remaining\n\n    else:\n        # if item can't fit in any bin give negative prioity based on how much over capacity they are to indicate inability to fit\n        priorities = - (item - bins_remain_cap) # lower means less negative\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers several factors:\n    1.  Remaining capacity of the bin after adding the item (avoiding overfilling).\n    2.  Waste introduced by placing the item in the bin.  We want to minimize waste.\n    3.  A slight preference for bins that are already somewhat filled (a \"first fit decreasing\" flavour).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if item <= remaining_capacity:\n            # Calculate remaining capacity *after* adding the item\n            new_remaining_capacity = remaining_capacity - item\n\n            # Waste: Smaller is better (higher priority).  Use reciprocal to convert to priority. Add small constant to avoid division by zero.\n            waste_priority = 1 / (new_remaining_capacity + 0.001)  # Small waste --> High Priority\n\n            # Bin Fill Level Preference: Encourage filling bins more completely\n            fill_level_priority = (1 - (new_remaining_capacity / 1.0)) ** 2 # assuming bin capacity = 1. Higher the fill level higher priority.\n\n            # Combine priorities:  Weighting can be tuned\n            priorities[i] = waste_priority + fill_level_priority\n        else:\n            priorities[i] = -np.inf  # Impossible to fit, make it the lowest priority\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}