{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes best-fit, adds stochasticity, and penalizes fragmentation.\n       Also, considers bin fill ratio and dynamically adjusts stochasticity.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if np.any(feasible_bins):\n        waste = bins_remain_cap[feasible_bins] - item\n        \n        # Prioritize based on inverse waste (best fit)\n        priorities[feasible_bins] = 1 / (waste + 0.0001)\n        \n        # Dynamically adjust stochasticity based on the number of feasible bins\n        num_feasible = np.sum(feasible_bins)\n        stochasticity_factor = 0.1 / (num_feasible + 1e-6)  # Reduce stochasticity when many bins are feasible\n        priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * stochasticity_factor\n        \n\n        # Penalize almost full bins to prevent fragmentation (more aggressive)\n        wasted_space_ratio = waste / bins_remain_cap[feasible_bins]\n        almost_full = wasted_space_ratio < 0.05  # More sensitive to almost full\n        priorities[feasible_bins][almost_full] *= 0.3  # Reduce priority more aggressively\n\n        # Reward bins that are already significantly filled\n        fill_ratio = (bins_remain_cap[feasible_bins] - waste) / bins_remain_cap[feasible_bins]\n        significantly_filled = fill_ratio > 0.5 # Adjust threshold as needed\n        priorities[feasible_bins][significantly_filled] += 0.2  # Add a small reward for filled bins\n\n        #Large item high reward - filling up space and avoiding future placement issues.\n        large_cap_reward = np.where(bins_remain_cap[feasible_bins] > item*2,0.25,0) #incentivise large bins if enough capacity exists.\n        priorities[feasible_bins] += large_cap_reward\n\n    else:\n        priorities[:] = -np.inf\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes best-fit, adds stochasticity, penalizes fragmentation, and considers bin fill ratio.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if np.any(feasible_bins):\n        waste = bins_remain_cap[feasible_bins] - item\n        \n        # Prioritize based on inverse waste (best fit) - stronger best-fit\n        priorities[feasible_bins] = 10 / (waste + 0.0001)  # Increased impact of best-fit\n\n        # Add stochasticity (exploration) - reduced stochasticity\n        priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.05  # Reduced stochasticity\n\n        # Penalize fragmentation - more aggressive penalty\n        wasted_space_ratio = waste / bins_remain_cap[feasible_bins]\n        almost_full = wasted_space_ratio < 0.1\n        priorities[feasible_bins][almost_full] *= 0.3  # Stronger penalty for almost full bins\n\n        # Reward filling bins well\n        fill_ratio = item / bins_remain_cap[feasible_bins]\n        good_fill = (fill_ratio > 0.7) & (fill_ratio <= 1.0)\n        priorities[feasible_bins][good_fill] += 0.5  # Reward bins filled well\n\n        # Large item high reward - filling up space and avoiding future placement issues, only when bin large enough\n        large_cap_reward = np.where(bins_remain_cap[feasible_bins] > item*1.25,0.25,0) #incentivise large bins if enough capacity exists. Less restriction on bin size for the reward.\n        priorities[feasible_bins] += large_cap_reward\n\n        #Moderate penalty if item fills bin above a certain threshold.\n        overfill_penalty = np.where(fill_ratio>1, -1,0)\n        priorities[feasible_bins]+= overfill_penalty\n\n    else:\n        priorities[:] = -np.inf\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic `priority_v2` incorporates \"best-fit\" prioritization, stochasticity for exploration, fragmentation penalty, utilization sweet spot, and large item reward. The worst only considers fit score (exponential decay on relative waste), stochasticity, and fragmentation penalty.  (2nd best) vs (2nd worst) the code is similar. Comparing (1st) vs (2nd), we see the function are similar, therefore small adjustments to parameters can significantly impact performance. (3rd) vs (4th), we see that the 4th heuristic dynamically adjusts stochasticity and rewards significantly filled bins, while the 3rd one is simpler. Comparing (second worst) vs (worst), we see the codes are similar. Overall: the best heuristics incorporate more factors and adaptive parameters, while simpler heuristics focusing only on basic factors like waste tend to perform worse. The weighting of different factors, such as the strength of the fragmentation penalty or the magnitude of stochasticity, significantly impacts heuristic performance. Sweet spot and dynamic scaling of parameters are useful.\n- \nOkay, let's refine \"Current self-reflection\" to make it more actionable for designing better heuristics, avoiding the pitfalls of \"Ineffective self-reflection.\"\n\nHere's a revised approach:\n\n*   **Keywords:** Iterative refinement, empirical tuning, dynamic adaptation, balanced factors.\n*   **Advice:** Start simple, measure impact of added complexity, adjust based on problem state, and focus on performance metrics.\n*   **Avoid:** Unjustified complexity, pre-mature stochasticity, and complex non-linear functions without clear justification.\n*   **Explanation:** Build heuristics incrementally, focusing on demonstrable performance gains at each step. Prioritize clear, tunable parameters, and adaptive responses to problem characteristics.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}