{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit-Decreasing inspired component\n    # Prioritize bins that can fit the item without too much waste.\n\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1.0 / (bins_remain_cap[fit_mask] - item + 0.0001)  # Avoid division by zero. Smaller waste, higher priority\n\n    # Next-Fit inspired component - incentivize bins close to full to finish them\n    priorities += bins_remain_cap / np.sum(bins_remain_cap + 0.0001) #Added small value to prevent zero division.\n    # Penalize bins with small amount of capacity for a small item - try to use bins with plenty of space first.\n    small_cap_penalty = np.where(bins_remain_cap < item, -np.inf, 0)\n    priorities += small_cap_penalty\n    #Large item high reward - filling up space and avoiding future placement issues.\n    large_cap_reward = np.where(bins_remain_cap > item*2,1,0) #incentivise large bins if enough capacity exists.\n    priorities += large_cap_reward\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit-Decreasing inspired component\n    # Prioritize bins that can fit the item without too much waste.\n\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1.0 / (bins_remain_cap[fit_mask] - item + 0.0001)  # Avoid division by zero. Smaller waste, higher priority\n\n    # Next-Fit inspired component - incentivize bins close to full to finish them\n    priorities += bins_remain_cap / np.sum(bins_remain_cap + 0.0001) #Added small value to prevent zero division.\n    # Penalize bins with small amount of capacity for a small item - try to use bins with plenty of space first.\n    small_cap_penalty = np.where(bins_remain_cap < item, -np.inf, 0)\n    priorities += small_cap_penalty\n    #Large item high reward - filling up space and avoiding future placement issues.\n    large_cap_reward = np.where(bins_remain_cap > item*2,1,0) #incentivise large bins if enough capacity exists.\n    priorities += large_cap_reward\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit-Decreasing inspired component\n    # Prioritize bins that can fit the item without too much waste.\n\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1.0 / (bins_remain_cap[fit_mask] - item + 0.0001)  # Avoid division by zero. Smaller waste, higher priority\n\n    # Next-Fit inspired component - incentivize bins close to full to finish them\n    priorities += bins_remain_cap / np.sum(bins_remain_cap + 0.0001) #Added small value to prevent zero division.\n    # Penalize bins with small amount of capacity for a small item - try to use bins with plenty of space first.\n    small_cap_penalty = np.where(bins_remain_cap < item, -np.inf, 0)\n    priorities += small_cap_penalty\n    #Large item high reward - filling up space and avoiding future placement issues.\n    large_cap_reward = np.where(bins_remain_cap > item*2,1,0) #incentivise large bins if enough capacity exists.\n    priorities += large_cap_reward\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit-Decreasing inspired component\n    # Prioritize bins that can fit the item without too much waste.\n\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1.0 / (bins_remain_cap[fit_mask] - item + 0.0001)  # Avoid division by zero. Smaller waste, higher priority\n\n    # Next-Fit inspired component - incentivize bins close to full to finish them\n    priorities += bins_remain_cap / np.sum(bins_remain_cap + 0.0001) #Added small value to prevent zero division.\n    # Penalize bins with small amount of capacity for a small item - try to use bins with plenty of space first.\n    small_cap_penalty = np.where(bins_remain_cap < item, -np.inf, 0)\n    priorities += small_cap_penalty\n    #Large item high reward - filling up space and avoiding future placement issues.\n    large_cap_reward = np.where(bins_remain_cap > item*2,1,0) #incentivise large bins if enough capacity exists.\n    priorities += large_cap_reward\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit-Decreasing inspired component\n    # Prioritize bins that can fit the item without too much waste.\n\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1.0 / (bins_remain_cap[fit_mask] - item + 0.0001)  # Avoid division by zero. Smaller waste, higher priority\n\n    # Next-Fit inspired component - incentivize bins close to full to finish them\n    priorities += bins_remain_cap / np.sum(bins_remain_cap + 0.0001) #Added small value to prevent zero division.\n    # Penalize bins with small amount of capacity for a small item - try to use bins with plenty of space first.\n    small_cap_penalty = np.where(bins_remain_cap < item, -np.inf, 0)\n    priorities += small_cap_penalty\n    #Large item high reward - filling up space and avoiding future placement issues.\n    large_cap_reward = np.where(bins_remain_cap > item*2,1,0) #incentivise large bins if enough capacity exists.\n    priorities += large_cap_reward\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins, balancing waste, fill level, and stochasticity.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = np.where(waste > 0, 1.0 / (waste + 1e-8), 1e8)\n\n    fill_ratios = (1 - bins_remain_cap[valid_bins] / bins_remain_cap[valid_bins].max())\n    priorities[valid_bins] += fill_ratios\n\n    #Stochastic Exploration: adds a scaled random number to valid bins.\n    priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * 0.1\n\n    # Fragmentation Penalty: Reduce priority if bin is nearly full.\n    wasted_space_ratio = waste / bins_remain_cap[valid_bins]\n    nearly_full = wasted_space_ratio < 0.1\n    priorities[valid_bins][nearly_full] -= 0.5  # Penalize nearly full bins\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines perfect fit bonus, relative waste, and exploration.\n    Penalizes infeasible bins.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # Compute remaining space for feasible bins\n    feasible_bins = bins_remain_cap >= item\n    remaining_space = bins_remain_cap[feasible_bins] - item\n\n    # Perfect fit bonus using exponential function\n    perfect_fit_bonus = np.exp(-10 * remaining_space) if remaining_space.size > 0 else np.array([])\n    priorities[feasible_bins] += perfect_fit_bonus\n\n    # Relative waste penalty\n    if feasible_bins.any():\n        waste_ratio = remaining_space / bins_remain_cap[feasible_bins]\n        priorities[feasible_bins] -= waste_ratio\n\n    # Exploration bonus\n    exploration_bonus = np.random.rand(len(bins_remain_cap)) * 0.01\n    priorities += exploration_bonus\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic: potential well + relative waste + stochasticity.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n        return priorities\n\n    # Potential well around near-perfect fits.\n    fit_difference = bins_remain_cap - item\n    near_fit_mask = fit_difference >= 0\n    priorities[near_fit_mask] = np.exp(-np.abs(fit_difference[near_fit_mask]) / (item + 1e-6))\n\n    # Relative wasted space penalty.\n    wasted_space = bins_remain_cap - item\n    priorities[eligible_bins] -= 0.5 * (wasted_space[eligible_bins] / (bins_remain_cap[eligible_bins] + 1e-6))\n\n    # Stochastic exploration: favor fuller bins with small probability.\n    fill_level = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    priorities += 0.01 * np.random.rand(len(bins_remain_cap)) * fill_level**2\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic: potential well + relative waste + stochasticity.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n        return priorities\n\n    # Potential well around near-perfect fits.\n    fit_difference = bins_remain_cap - item\n    near_fit_mask = fit_difference >= 0\n    priorities[near_fit_mask] = np.exp(-np.abs(fit_difference[near_fit_mask]) / (item + 1e-6))\n\n    # Relative wasted space penalty.\n    wasted_space = bins_remain_cap - item\n    priorities[eligible_bins] -= 0.5 * (wasted_space[eligible_bins] / (bins_remain_cap[eligible_bins] + 1e-6))\n\n    # Stochastic exploration: favor fuller bins with small probability.\n    fill_level = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    priorities += 0.01 * np.random.rand(len(bins_remain_cap)) * fill_level**2\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes near-perfect fits, adds stochasticity, and penalizes fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if np.any(feasible_bins):\n        waste = bins_remain_cap[feasible_bins] - item\n        \n        # Prioritize based on inverse waste (best fit)\n        priorities[feasible_bins] = 1 / (waste + 0.0001)\n        \n        # Add stochasticity (exploration)\n        priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.1\n\n        #Penalize almost full bins to prevent fragmentation\n        wasted_space_ratio = waste / bins_remain_cap[feasible_bins]\n        almost_full = wasted_space_ratio < 0.1\n        priorities[feasible_bins][almost_full] *= 0.5 # Reduce priority of almost full bins\n        \n\n    else:\n        priorities[:] = -np.inf\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes near-perfect fits, adds stochasticity, and penalizes fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if np.any(feasible_bins):\n        waste = bins_remain_cap[feasible_bins] - item\n        \n        # Prioritize based on inverse waste (best fit)\n        priorities[feasible_bins] = 1 / (waste + 0.0001)\n        \n        # Add stochasticity (exploration)\n        priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.1\n\n        #Penalize almost full bins to prevent fragmentation\n        wasted_space_ratio = waste / bins_remain_cap[feasible_bins]\n        almost_full = wasted_space_ratio < 0.1\n        priorities[feasible_bins][almost_full] *= 0.5 # Reduce priority of almost full bins\n        \n\n    else:\n        priorities[:] = -np.inf\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes near-perfect fits, adds stochasticity, and penalizes fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if np.any(feasible_bins):\n        waste = bins_remain_cap[feasible_bins] - item\n        \n        # Prioritize based on inverse waste (best fit)\n        priorities[feasible_bins] = 1 / (waste + 0.0001)\n        \n        # Add stochasticity (exploration)\n        priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.1\n\n        #Penalize almost full bins to prevent fragmentation\n        wasted_space_ratio = waste / bins_remain_cap[feasible_bins]\n        almost_full = wasted_space_ratio < 0.1\n        priorities[feasible_bins][almost_full] *= 0.5 # Reduce priority of almost full bins\n        \n\n    else:\n        priorities[:] = -np.inf\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates non-linearity, stochasticity, fragmentation penalty,\n    relative waste, and array operations to enhance performance.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Fit Assessment & Relative Waste (Non-linear)\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):  # only apply calculation if some bins can fit\n        waste = bins_remain_cap[fit_mask] - item\n        relative_waste = waste / item #waste relative to the item size\n        priorities[fit_mask] += np.exp(-5 * relative_waste)  # Exponentially decaying priority based on waste\n\n    # 2. Fragmentation Penalty (Non-linear)\n    # Penalize bins that will have remaining capacity within a specific range,\n    # as this leads to fragmentation.\n    fragment_threshold_low = 0.1\n    fragment_threshold_high = 0.25\n    fragment_mask = (bins_remain_cap - item > fragment_threshold_low) & (bins_remain_cap - item < fragment_threshold_high)\n\n    priorities[fragment_mask] -= 0.5  # Apply a penalty for fragmentation\n\n    # 3. Stochastic Exploration (Stochasticity)\n    # Add a small random value to each bin's priority to encourage exploration.\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.01\n\n    # 4. Bin Utilization Encouragement\n    # Incentivize bins that are already partially full.  Use a sigmoid function\n    # to provide a non-linear increase in priority as the bin fills up.\n    utilization = (1 - bins_remain_cap / np.max(bins_remain_cap)) #utilization relative to the biggest bin capacity.\n    priorities += 1.0 / (1 + np.exp(-10 * (utilization - 0.5))) #sigmod function that incentivizes partially filled bins.\n\n    # 5. Small Capacity Penalty (As before, but refined)\n    small_cap_penalty = np.where(bins_remain_cap < item, -np.inf, 0)\n    priorities += small_cap_penalty\n\n    # 6. Large Capacity Reward (As before)\n    large_cap_reward = np.where(bins_remain_cap > item * 2, 0.2, 0) #reduced reward amount\n    priorities += large_cap_reward\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates non-linearity, stochasticity, fragmentation penalty,\n    relative waste, and array operations to enhance performance.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Fit Assessment & Relative Waste (Non-linear)\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):  # only apply calculation if some bins can fit\n        waste = bins_remain_cap[fit_mask] - item\n        relative_waste = waste / item #waste relative to the item size\n        priorities[fit_mask] += np.exp(-5 * relative_waste)  # Exponentially decaying priority based on waste\n\n    # 2. Fragmentation Penalty (Non-linear)\n    # Penalize bins that will have remaining capacity within a specific range,\n    # as this leads to fragmentation.\n    fragment_threshold_low = 0.1\n    fragment_threshold_high = 0.25\n    fragment_mask = (bins_remain_cap - item > fragment_threshold_low) & (bins_remain_cap - item < fragment_threshold_high)\n\n    priorities[fragment_mask] -= 0.5  # Apply a penalty for fragmentation\n\n    # 3. Stochastic Exploration (Stochasticity)\n    # Add a small random value to each bin's priority to encourage exploration.\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.01\n\n    # 4. Bin Utilization Encouragement\n    # Incentivize bins that are already partially full.  Use a sigmoid function\n    # to provide a non-linear increase in priority as the bin fills up.\n    utilization = (1 - bins_remain_cap / np.max(bins_remain_cap)) #utilization relative to the biggest bin capacity.\n    priorities += 1.0 / (1 + np.exp(-10 * (utilization - 0.5))) #sigmod function that incentivizes partially filled bins.\n\n    # 5. Small Capacity Penalty (As before, but refined)\n    small_cap_penalty = np.where(bins_remain_cap < item, -np.inf, 0)\n    priorities += small_cap_penalty\n\n    # 6. Large Capacity Reward (As before)\n    large_cap_reward = np.where(bins_remain_cap > item * 2, 0.2, 0) #reduced reward amount\n    priorities += large_cap_reward\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates non-linearity, stochasticity, fragmentation penalty,\n    relative waste, and array operations to enhance performance.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Fit Assessment & Relative Waste (Non-linear)\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):  # only apply calculation if some bins can fit\n        waste = bins_remain_cap[fit_mask] - item\n        relative_waste = waste / item #waste relative to the item size\n        priorities[fit_mask] += np.exp(-5 * relative_waste)  # Exponentially decaying priority based on waste\n\n    # 2. Fragmentation Penalty (Non-linear)\n    # Penalize bins that will have remaining capacity within a specific range,\n    # as this leads to fragmentation.\n    fragment_threshold_low = 0.1\n    fragment_threshold_high = 0.25\n    fragment_mask = (bins_remain_cap - item > fragment_threshold_low) & (bins_remain_cap - item < fragment_threshold_high)\n\n    priorities[fragment_mask] -= 0.5  # Apply a penalty for fragmentation\n\n    # 3. Stochastic Exploration (Stochasticity)\n    # Add a small random value to each bin's priority to encourage exploration.\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.01\n\n    # 4. Bin Utilization Encouragement\n    # Incentivize bins that are already partially full.  Use a sigmoid function\n    # to provide a non-linear increase in priority as the bin fills up.\n    utilization = (1 - bins_remain_cap / np.max(bins_remain_cap)) #utilization relative to the biggest bin capacity.\n    priorities += 1.0 / (1 + np.exp(-10 * (utilization - 0.5))) #sigmod function that incentivizes partially filled bins.\n\n    # 5. Small Capacity Penalty (As before, but refined)\n    small_cap_penalty = np.where(bins_remain_cap < item, -np.inf, 0)\n    priorities += small_cap_penalty\n\n    # 6. Large Capacity Reward (As before)\n    large_cap_reward = np.where(bins_remain_cap > item * 2, 0.2, 0) #reduced reward amount\n    priorities += large_cap_reward\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Fit Score: Prioritize bins that can fit the item. Non-linear scaling.\n    fit_mask = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    relative_waste = waste / item\n    priorities[fit_mask] += np.exp(-relative_waste[fit_mask])  # Exponential decay of priority as waste increases\n\n    # Capacity Utilization: Encourage filling bins close to full.\n    utilization = (bins_remain_cap - item) / bins_remain_cap\n    utilization = np.clip(utilization, 0, 1)  # Ensure utilization is between 0 and 1\n    priorities[fit_mask] += (1-utilization[fit_mask])**2\n\n    # Fragmentation Penalty: Discourage leaving small gaps.  Larger gaps penalized more.\n    fragmentation_threshold = item * 0.2 #Define threshold relative to item size\n    fragmentation_penalty = np.where((waste > 0) & (waste < fragmentation_threshold), -0.5, 0)\n    priorities += fragmentation_penalty\n\n    # Stochastic Element: Introduce randomness for exploration.\n    exploration_factor = 0.01  # Low value to limit randomness\n    priorities += np.random.rand(len(bins_remain_cap)) * exploration_factor\n\n\n    # Large item Reward\n    large_cap_reward = np.where(bins_remain_cap > item * 1.5, np.tanh(bins_remain_cap / item), 0)  # tanh to bound reward\n    priorities += large_cap_reward\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid priority: Gaussian fit + waste, penalize near-full.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n    \n    # Gaussian-like fit priority\n    ideal_ratio = 0.8\n    scale = 0.2\n    ratios = np.where(can_fit, item / bins_remain_cap, 0)\n    gaussian_priorities = np.exp(-((ratios - ideal_ratio)**2) / (2 * scale**2))\n    priorities = np.where(can_fit, gaussian_priorities, -np.inf)\n    \n    # Waste penalty and near-full penalty\n    wasted_space_ratio = (bins_remain_cap - item) / bins_remain_cap\n    priorities = np.where(can_fit, priorities - wasted_space_ratio * 0.3, priorities)\n\n    near_full = (wasted_space_ratio > 0) & (wasted_space_ratio < 0.1)\n    priorities = np.where(near_full & can_fit, priorities - 0.5, priorities) #stronger penalty than v0\n    \n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    n_bins = len(bins_remain_cap)\n\n    # 1. First-Fit-Decreasing inspired (Relative Waste)\n    fit_mask = bins_remain_cap >= item\n    waste = bins_remain_cap[fit_mask] - item\n    relative_waste = waste / (item + 0.0001)  # Relative to item size\n    priorities[fit_mask] += np.exp(-5 * relative_waste)  # Exponential decay of priority as waste increases\n\n    # 2. Next-Fit inspired (Bin fullness - Non-linear)\n    bin_fullness = bins_remain_cap / (np.max(bins_remain_cap) + 0.0001)  # Normalize\n    priorities += np.power(1 - bin_fullness, 3) # Prioritize fuller bins, cubic function\n\n    # 3. Fragmentation Penalty (Aggressive)\n    fragmentation_penalty = np.where(bins_remain_cap < item, -1000, 0) #Extreme penalty for bins that cannot fit the item\n    priorities += fragmentation_penalty\n    \n    # 4. Stochastic element (exploration)\n    # Add some noise to the priorities to encourage exploration of different bins\n    noise = np.random.normal(0, 0.1, size=n_bins)\n    priorities += noise\n\n    # 5. Large item incentive (fill space)\n    large_space = np.where(bins_remain_cap > item * 1.5, np.tanh(bins_remain_cap - item), 0) #If there is sufficient space fill it up.\n    priorities += large_space\n\n    #6. Number of available bins penalty if there are lots of bins, use the fullest.\n    if n_bins > 10:\n        priorities += (1-bin_fullness)*0.1\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    n_bins = len(bins_remain_cap)\n\n    # 1. First-Fit-Decreasing inspired (Relative Waste)\n    fit_mask = bins_remain_cap >= item\n    waste = bins_remain_cap[fit_mask] - item\n    relative_waste = waste / (item + 0.0001)  # Relative to item size\n    priorities[fit_mask] += np.exp(-5 * relative_waste)  # Exponential decay of priority as waste increases\n\n    # 2. Next-Fit inspired (Bin fullness - Non-linear)\n    bin_fullness = bins_remain_cap / (np.max(bins_remain_cap) + 0.0001)  # Normalize\n    priorities += np.power(1 - bin_fullness, 3) # Prioritize fuller bins, cubic function\n\n    # 3. Fragmentation Penalty (Aggressive)\n    fragmentation_penalty = np.where(bins_remain_cap < item, -1000, 0) #Extreme penalty for bins that cannot fit the item\n    priorities += fragmentation_penalty\n    \n    # 4. Stochastic element (exploration)\n    # Add some noise to the priorities to encourage exploration of different bins\n    noise = np.random.normal(0, 0.1, size=n_bins)\n    priorities += noise\n\n    # 5. Large item incentive (fill space)\n    large_space = np.where(bins_remain_cap > item * 1.5, np.tanh(bins_remain_cap - item), 0) #If there is sufficient space fill it up.\n    priorities += large_space\n\n    #6. Number of available bins penalty if there are lots of bins, use the fullest.\n    if n_bins > 10:\n        priorities += (1-bin_fullness)*0.1\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    n_bins = len(bins_remain_cap)\n\n    # 1. First-Fit-Decreasing inspired (Relative Waste)\n    fit_mask = bins_remain_cap >= item\n    waste = bins_remain_cap[fit_mask] - item\n    relative_waste = waste / (item + 0.0001)  # Relative to item size\n    priorities[fit_mask] += np.exp(-5 * relative_waste)  # Exponential decay of priority as waste increases\n\n    # 2. Next-Fit inspired (Bin fullness - Non-linear)\n    bin_fullness = bins_remain_cap / (np.max(bins_remain_cap) + 0.0001)  # Normalize\n    priorities += np.power(1 - bin_fullness, 3) # Prioritize fuller bins, cubic function\n\n    # 3. Fragmentation Penalty (Aggressive)\n    fragmentation_penalty = np.where(bins_remain_cap < item, -1000, 0) #Extreme penalty for bins that cannot fit the item\n    priorities += fragmentation_penalty\n    \n    # 4. Stochastic element (exploration)\n    # Add some noise to the priorities to encourage exploration of different bins\n    noise = np.random.normal(0, 0.1, size=n_bins)\n    priorities += noise\n\n    # 5. Large item incentive (fill space)\n    large_space = np.where(bins_remain_cap > item * 1.5, np.tanh(bins_remain_cap - item), 0) #If there is sufficient space fill it up.\n    priorities += large_space\n\n    #6. Number of available bins penalty if there are lots of bins, use the fullest.\n    if n_bins > 10:\n        priorities += (1-bin_fullness)*0.1\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}