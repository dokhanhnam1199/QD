[
     {
          "algorithm": "This algorithm generates multiple random routes satisfying capacity constraints, and aggregates edge frequencies to produce a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm generates multiple random routes satisfying capacity constraints, and aggregates edge frequencies to produce a heuristic matrix.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 100\n\n    for _ in range(num_samples):\n        unvisited = set(range(1, n))\n        routes = []\n        current_route = [0]\n        current_capacity = capacity\n\n        while unvisited:\n            next_node = None\n            best_score = float('inf')\n            \n            possible_nodes = list(unvisited)\n            np.random.shuffle(possible_nodes) # Randomize search\n            \n            for node in possible_nodes:\n                if demands[node] <= current_capacity:\n                    score = distance_matrix[current_route[-1]][node] \n                    if score < best_score:\n                        best_score = score\n                        next_node = node\n\n            if next_node is not None:\n                current_route.append(next_node)\n                current_capacity -= demands[next_node]\n                unvisited.remove(next_node)\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0]\n                current_capacity = capacity\n\n        if current_route != [0]:\n             current_route.append(0)\n             routes.append(current_route)\n            \n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1][node2] += 1\n                heuristics_matrix[node2][node1] += 1\n\n    return heuristics_matrix",
          "objective": 15.79641,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge importance by sampling random feasible routes and counting edge occurrences, favoring shorter edges and penalizing edges that lead to capacity violations.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Initialize\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            # Probabilistically select the next node\n            probabilities = {}\n            for node in remaining_nodes:\n                # Heuristic: distance and demand\n                distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)  # Avoid division by zero\n                demand_heuristic = (current_capacity - demands[node]) / capacity if current_capacity >= demands[node] else 0\n                \n                probabilities[node] = distance_heuristic * (demand_heuristic + 0.1) # add a small value to demand_heuristic to guarantee there is always a small probability to select a node\n\n            if not probabilities:\n                break  # No feasible nodes left\n            \n            # Normalize probabilities to form a distribution\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge importance by sampling random feasible routes and counting edge occurrences, favoring shorter edges and penalizing edges that lead to capacity violations.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Initialize\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            # Probabilistically select the next node\n            probabilities = {}\n            for node in remaining_nodes:\n                # Heuristic: distance and demand\n                distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)  # Avoid division by zero\n                demand_heuristic = (current_capacity - demands[node]) / capacity if current_capacity >= demands[node] else 0\n                \n                probabilities[node] = distance_heuristic * (demand_heuristic + 0.1) # add a small value to demand_heuristic to guarantee there is always a small probability to select a node\n\n            if not probabilities:\n                break  # No feasible nodes left\n            \n            # Normalize probabilities to form a distribution\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}\n                \n                # Select the next node based on the distribution\n                next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))\n\n            # Check capacity constraint\n            if current_capacity >= demands[next_node]:\n                route.append(next_node)\n                current_capacity -= demands[next_node]\n                remaining_nodes.remove(next_node)\n                heuristics_matrix[current_node, next_node] += 1\n                heuristics_matrix[next_node, current_node] += 1\n                current_node = next_node\n            else:\n                # Return to depot\n                route.append(0)\n                heuristics_matrix[current_node, 0] += 1\n                heuristics_matrix[0, current_node] += 1\n                current_node = 0\n                current_capacity = capacity\n        \n        if current_node != 0:\n            heuristics_matrix[current_node, 0] += 1\n            heuristics_matrix[0, current_node] += 1\n\n\n    # Normalize by distance\n    for i in range(n):\n        for j in range(n):\n             if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= (distance_matrix[i, j] + 1e-6)\n    \n    return heuristics_matrix",
          "objective": 18.58104,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples random routes, evaluates their feasibility and cost, and then uses the edge frequencies in feasible and low-cost routes to construct a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples random routes, evaluates their feasibility and cost, and then uses the edge frequencies in feasible and low-cost routes to construct a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    feasible_edge_counts = np.zeros_like(distance_matrix)\n    total_edge_counts = np.zeros_like(distance_matrix)\n    \n    best_cost = float('inf')\n\n    for _ in range(num_samples):\n        \n        # Sample a random permutation of customers (excluding the depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        # Construct routes\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_load = 0\n\n        for customer in customer_indices:\n            if current_load + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route from depot\n                current_load = demands[customer]\n\n        current_route.append(0) #Return to depot\n        routes.append(current_route)\n\n        # Calculate the cost of the routes\n        total_cost = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_cost += distance_matrix[route[i]][route[i+1]]\n        \n        # Update the edge counts in the matrix\n        for route in routes:\n            for i in range(len(route) - 1):\n                u, v = route[i], route[i+1]\n                total_edge_counts[u][v] +=1\n                total_edge_counts[v][u] +=1 #Symmetry\n\n        # Only update feasiable edge counts in routes that are feasiable\n        if total_cost < float('inf'):\n            for route in routes:\n                for i in range(len(route) - 1):\n                    u, v = route[i], route[i+1]\n                    feasible_edge_counts[u][v] +=1\n                    feasible_edge_counts[v][u] +=1 #Symmetry\n        \n    # Calculate the heuristic values based on edge frequencies\n    for i in range(n):\n        for j in range(n):\n            if total_edge_counts[i][j] > 0:\n                heuristics_matrix[i][j] = feasible_edge_counts[i][j] / total_edge_counts[i][j]\n            else:\n                heuristics_matrix[i][j] = 0\n                \n    return heuristics_matrix",
          "objective": 26.29386,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples a large number of random routes, evaluates their feasibility and cost, and then generates a heuristic matrix based on the frequency each edge appears in the feasible and low-cost routes.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a large number of random routes, evaluates their feasibility and cost, and then generates a heuristic matrix based on the frequency each edge appears in the feasible and low-cost routes.}\n    \"\"\"\n    n = len(demands)\n    num_samples = 1000\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    for _ in range(num_samples):\n        route = list(range(1, n))\n        np.random.shuffle(route)\n        \n        routes = []\n        current_route = [0]\n        current_load = 0\n        \n        for node in route:\n            if current_load + demands[node] <= capacity:\n                current_route.append(node)\n                current_load += demands[node]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, node]\n                current_load = demands[node]\n                \n        current_route.append(0)\n        routes.append(current_route)\n        \n        total_distance = 0\n        is_feasible = True\n        for r in routes:\n            load = 0\n            for i in range(len(r) - 1):\n                total_distance += distance_matrix[r[i]][r[i+1]]\n                if r[i] != 0:\n                    load += demands[r[i]]\n\n            if load > capacity:\n                is_feasible = False\n                break\n\n        if is_feasible:\n            for r in routes:\n                for i in range(len(r) - 1):\n                    heuristics_matrix[r[i]][r[i+1]] += 1\n                    heuristics_matrix[r[i+1]][r[i]] += 1  # Assuming symmetric distance matrix\n                    \n    return heuristics_matrix",
          "objective": 29.38474,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge inclusion probabilities by repeatedly constructing random routes satisfying capacity constraints and updating a heuristic matrix based on edge usage frequency.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge inclusion probabilities by repeatedly constructing random routes satisfying capacity constraints and updating a heuristic matrix based on edge usage frequency.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000  # Number of random routes to generate\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_capacity = 0\n\n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route at depot\n                current_capacity = demands[customer]\n\n        current_route.append(0)\n        routes.append(current_route)\n\n        # Update heuristics matrix based on edge usage\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i + 1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1  # Symmetric\n\n    # Normalize the heuristics matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 29.61513,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples a large number of random routes, evaluates their feasibility with respect to capacity constraints, and then uses the frequency with which each edge appears in feasible routes to construct a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm samples a large number of random routes, evaluates their feasibility with respect to capacity constraints, and then uses the frequency with which each edge appears in feasible routes to construct a heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding depot)\n        permutation = np.random.permutation(range(1, n))\n        \n        # Build routes based on capacity\n        routes = []\n        current_route = [0]\n        current_demand = 0\n        \n        for customer in permutation:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_demand = demands[customer]\n        \n        current_route.append(0)\n        routes.append(current_route)\n        \n\n        # Update heuristics matrix based on edges in the routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1  # Assuming symmetric distance matrix\n\n    # Normalize the matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 29.61538,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples a set of random routes, evaluates their feasibility based on capacity constraints, and updates a heuristic matrix by incrementing the value of edges present in feasible routes.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm samples a set of random routes, evaluates their feasibility based on capacity constraints, and updates a heuristic matrix by incrementing the value of edges present in feasible routes.}\"\"\"\n\n    n = len(demands)\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = list(range(1, n))\n        random.shuffle(route)\n\n        current_route = [0]\n        current_demand = 0\n        feasible = True\n\n        for node in route:\n            if current_demand + demands[node] <= capacity:\n                current_route.append(node)\n                current_demand += demands[node]\n            else:\n                current_route.append(0)\n                current_demand = demands[node]\n                if current_demand > capacity:\n                    feasible = False\n                    break\n                current_route.append(node)\n                \n        current_route.append(0)\n\n        if feasible:\n            for i in range(len(current_route) - 1):\n                node1 = current_route[i]\n                node2 = current_route[i+1]\n                heuristics_matrix[node1, node2] += 1\n\n    return heuristics_matrix",
          "objective": 29.62228,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples a large number of random routes, evaluates their feasibility and cost, and uses the frequency of edge appearance in feasible routes weighted by route cost to construct a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a large number of random routes, evaluates their feasibility and cost, and uses the frequency of edge appearance in feasible routes weighted by route cost to construct a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        permutation = np.random.permutation(range(1, n))\n        \n        # Construct routes\n        routes = []\n        current_route = [0]\n        current_capacity = 0\n        \n        for customer in permutation:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_capacity = demands[customer]\n\n        current_route.append(0)\n        routes.append(current_route)\n        \n        # Calculate route cost and check feasibility\n        total_cost = 0\n        is_feasible = True\n        for route in routes:\n            if len(route) > 1:\n                route_demand = sum([demands[i] for i in route if i !=0 ])\n                if route_demand > capacity:\n                   is_feasible = False\n                   break \n                for i in range(len(route) - 1):\n                    total_cost += distance_matrix[route[i], route[i+1]]\n        \n        # Update heuristics matrix if feasible\n        if is_feasible and total_cost > 0:\n            for route in routes:\n                for i in range(len(route) - 1):\n                    u = route[i]\n                    v = route[i+1]\n                    heuristics_matrix[u, v] += 1.0 / total_cost\n                    heuristics_matrix[v, u] += 1.0 / total_cost  # Ensure symmetry\n\n    return heuristics_matrix",
          "objective": 29.62401,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge inclusion probabilities by generating multiple random feasible routes and counting edge occurrences.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge inclusion probabilities by generating multiple random feasible routes and counting edge occurrences.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100  # Number of random feasible solutions to generate\n    \n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n        \n        # Construct routes based on capacity constraints\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_capacity = 0\n        \n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route from depot\n                current_capacity = demands[customer]\n                \n        current_route.append(0)  # Return to depot after last customer\n        routes.append(current_route)\n        \n        # Update edge counts in the heuristics matrix\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1  # Since the graph is undirected\n    \n    # Normalize the edge counts to obtain probabilities\n    heuristics_matrix /= num_samples\n    \n    return heuristics_matrix",
          "objective": 29.66127,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates a set of random routes respecting capacity constraints,\n    then calculates a heuristic matrix based on the frequency of each edge appearing in the generated routes.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm generates a set of random routes respecting capacity constraints,\n    then calculates a heuristic matrix based on the frequency of each edge appearing in the generated routes.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        unvisited = set(range(1, n))\n        routes = []\n        current_route = [0]\n        current_capacity = capacity\n\n        while unvisited:\n            next_node = random.choice(list(unvisited))\n            if demands[next_node] <= current_capacity:\n                current_route.append(next_node)\n                current_capacity -= demands[next_node]\n                unvisited.remove(next_node)\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0]\n                current_capacity = capacity\n\n        current_route.append(0)\n        routes.append(current_route)\n\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n\n    return heuristics_matrix",
          "objective": 29.70246,
          "other_inf": null
     }
]