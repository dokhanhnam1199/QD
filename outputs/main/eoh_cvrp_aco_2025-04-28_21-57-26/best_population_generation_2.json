{
     "algorithm": "This algorithm employs a sweep-based clustering approach, assigning nodes to clusters based on their angular position relative to the depot, followed by route optimization within each cluster using a savings heuristic.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    \n    # 1. Sweep Clustering\n    angles = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n    nodes_with_angles = sorted(zip(range(1, n), angles), key=lambda x: x[1])\n    num_clusters = int(np.sqrt(n))\n    clusters = [[] for _ in range(num_clusters)]\n    \n    cluster_index = 0\n    current_cluster_demand = 0\n    \n    for node_index, angle in nodes_with_angles:\n        if current_cluster_demand + demands[node_index] <= capacity:\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand += demands[node_index]\n        else:\n            cluster_index = (cluster_index + 1) % num_clusters\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand = demands[node_index]\n    \n    # 2. Route Generation (Savings Heuristic)\n    cluster_routes = []\n    for cluster in clusters:\n        if not cluster:\n            cluster_routes.append([0,0])\n            continue\n\n        edges = []\n        for node in cluster:\n            edges.append((0, node))\n            edges.append((node, 0))\n\n        savings = []\n        for i in range(len(cluster)):\n            for j in range(i + 1, len(cluster)):\n                node1 = cluster[i]\n                node2 = cluster[j]\n                savings.append((node1, node2, distance_matrix[node1, 0] + distance_matrix[0, node2] - distance_matrix[node1, node2]))\n\n        savings.sort(key=lambda x: x[2], reverse=True)\n\n        route_segments = {node: [node] for node in cluster",
     "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm employs a sweep-based clustering approach, assigning nodes to clusters based on their angular position relative to the depot, followed by route optimization within each cluster using a savings heuristic.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    \n    # 1. Sweep Clustering\n    angles = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n    nodes_with_angles = sorted(zip(range(1, n), angles), key=lambda x: x[1])\n    num_clusters = int(np.sqrt(n))\n    clusters = [[] for _ in range(num_clusters)]\n    \n    cluster_index = 0\n    current_cluster_demand = 0\n    \n    for node_index, angle in nodes_with_angles:\n        if current_cluster_demand + demands[node_index] <= capacity:\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand += demands[node_index]\n        else:\n            cluster_index = (cluster_index + 1) % num_clusters\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand = demands[node_index]\n    \n    # 2. Route Generation (Savings Heuristic)\n    cluster_routes = []\n    for cluster in clusters:\n        if not cluster:\n            cluster_routes.append([0,0])\n            continue\n\n        edges = []\n        for node in cluster:\n            edges.append((0, node))\n            edges.append((node, 0))\n\n        savings = []\n        for i in range(len(cluster)):\n            for j in range(i + 1, len(cluster)):\n                node1 = cluster[i]\n                node2 = cluster[j]\n                savings.append((node1, node2, distance_matrix[node1, 0] + distance_matrix[0, node2] - distance_matrix[node1, node2]))\n\n        savings.sort(key=lambda x: x[2], reverse=True)\n\n        route_segments = {node: [node] for node in cluster}\n\n        def merge_routes(node1, node2):\n            route1 = route_segments[node1]\n            route2 = route_segments[node2]\n            \n            new_route = route1 + route2\n            for node in new_route:\n                route_segments[node] = new_route\n\n        current_route = [0]\n        route_nodes = set()\n\n        for node1, node2, saving in savings:\n            if route_segments[node1] != route_segments[node2]:\n                current_route.append(node1)\n                current_route.append(node2)\n                merge_routes(node1, node2)\n                route_nodes.add(node1)\n                route_nodes.add(node2)\n\n        unvisited = list(set(cluster) - route_nodes)\n\n        for node in unvisited:\n          current_route.append(node)\n        \n        if not unvisited and len(route_nodes) == 0 and len(cluster) > 0:\n          current_route = [0] + cluster\n        \n        current_route = [0]\n        current_node = 0\n        remaining_nodes = set(cluster)\n        final_route = [0]\n\n        while remaining_nodes:\n            nearest_node = None\n            min_dist = float('inf')\n\n            for node in remaining_nodes:\n                dist = distance_matrix[current_node, node]\n                if dist < min_dist:\n                    min_dist = dist\n                    nearest_node = node\n            final_route.append(nearest_node)\n            remaining_nodes.remove(nearest_node)\n            current_node = nearest_node\n\n        final_route.append(0)\n\n        cluster_routes.append(final_route)\n    \n\n    # 3. Combine Routes and Construct Heuristic Matrix\n    for route in cluster_routes:\n        for i in range(len(route) - 1):\n            node1 = route[i]\n            node2 = route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n    \n    # Normalize heuristic matrix by distance\n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j]\n    \n    return heuristics_matrix",
     "objective": 10.51625,
     "other_inf": null
}