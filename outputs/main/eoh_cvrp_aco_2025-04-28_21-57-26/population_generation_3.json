[
     {
          "algorithm": "This algorithm uses a sweep-based clustering approach followed by an improvement heuristic for routing within each cluster and combines the routes, incorporating a penalty for capacity violations during cluster construction.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm uses a sweep-based clustering approach followed by an improvement heuristic for routing within each cluster and combines the routes, incorporating a penalty for capacity violations during cluster construction.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    \n    # 1. Sweep-based Clustering\n    angles = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n    nodes_by_angle = sorted(range(1, n), key=lambda i: angles[i-1])\n    \n    clusters = []\n    current_cluster = []\n    current_demand = 0\n    \n    for node in nodes_by_angle:\n        if current_demand + demands[node] <= capacity:\n            current_cluster.append(node)\n            current_demand += demands[node]\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n            current_demand = demands[node]\n    clusters.append(current_cluster)\n    \n    # 2. Route Generation within Clusters (Nearest Neighbor + 2-opt Improvement)\n    cluster_routes = []\n    for cluster in clusters:\n        if not cluster:\n            cluster_routes.append([0,0])\n            continue\n            \n        # Nearest Neighbor Initial Route\n        current_node = 0\n        current_route = [0]\n        remaining_nodes = set(cluster)\n        \n        while remaining_nodes:\n            nearest_node = None\n            min_dist = float('inf')\n            \n            for node in remaining_nodes:\n                dist = distance_matrix[current_node, node]\n                if dist < min_dist:\n                    min_dist = dist\n                    nearest_node = node\n            \n            current_route.append(nearest_node)\n            current_node = nearest_node\n            remaining_nodes.remove(nearest_node)\n        \n        current_route.append(0)\n        \n        # 2-opt Improvement\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, len(current_route) - 2):\n                for k in range(i + 1, len(current_route) - 1):\n                    node_i = current_route[i]\n                    node_ip1 = current_route[i+1]\n                    node_k = current_route[k]\n                    node_kp1 = current_route[k+1]\n                    \n                    if distance_matrix[node_i, node_ip1] + distance_matrix[node_k, node_kp1] > distance_matrix[node_i, node_k] + distance_matrix[node_ip1, node_kp1]:\n                        current_route[i+1:k+1] = reversed(current_route[i+1:k+1])\n                        improved = True\n        \n        cluster_routes.append(current_route)\n    \n    # 3. Combine Routes and Construct Heuristic Matrix\n    for route in cluster_routes:\n        for i in range(len(route) - 1):\n            node1 = route[i]\n            node2 = route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n    \n    # Normalize heuristic matrix by distance\n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j]\n    \n    return heuristics_matrix",
          "objective": 10.31232,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm employs a sweep-based clustering approach, assigning nodes to clusters based on their angular position relative to the depot, followed by route optimization within each cluster using a savings heuristic.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    \n    # 1. Sweep Clustering\n    angles = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n    nodes_with_angles = sorted(zip(range(1, n), angles), key=lambda x: x[1])\n    num_clusters = int(np.sqrt(n))\n    clusters = [[] for _ in range(num_clusters)]\n    \n    cluster_index = 0\n    current_cluster_demand = 0\n    \n    for node_index, angle in nodes_with_angles:\n        if current_cluster_demand + demands[node_index] <= capacity:\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand += demands[node_index]\n        else:\n            cluster_index = (cluster_index + 1) % num_clusters\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand = demands[node_index]\n    \n    # 2. Route Generation (Savings Heuristic)\n    cluster_routes = []\n    for cluster in clusters:\n        if not cluster:\n            cluster_routes.append([0,0])\n            continue\n\n        edges = []\n        for node in cluster:\n            edges.append((0, node))\n            edges.append((node, 0))\n\n        savings = []\n        for i in range(len(cluster)):\n            for j in range(i + 1, len(cluster)):\n                node1 = cluster[i]\n                node2 = cluster[j]\n                savings.append((node1, node2, distance_matrix[node1, 0] + distance_matrix[0, node2] - distance_matrix[node1, node2]))\n\n        savings.sort(key=lambda x: x[2], reverse=True)\n\n        route_segments = {node: [node] for node in cluster",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm employs a sweep-based clustering approach, assigning nodes to clusters based on their angular position relative to the depot, followed by route optimization within each cluster using a savings heuristic.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    \n    # 1. Sweep Clustering\n    angles = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n    nodes_with_angles = sorted(zip(range(1, n), angles), key=lambda x: x[1])\n    num_clusters = int(np.sqrt(n))\n    clusters = [[] for _ in range(num_clusters)]\n    \n    cluster_index = 0\n    current_cluster_demand = 0\n    \n    for node_index, angle in nodes_with_angles:\n        if current_cluster_demand + demands[node_index] <= capacity:\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand += demands[node_index]\n        else:\n            cluster_index = (cluster_index + 1) % num_clusters\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand = demands[node_index]\n    \n    # 2. Route Generation (Savings Heuristic)\n    cluster_routes = []\n    for cluster in clusters:\n        if not cluster:\n            cluster_routes.append([0,0])\n            continue\n\n        edges = []\n        for node in cluster:\n            edges.append((0, node))\n            edges.append((node, 0))\n\n        savings = []\n        for i in range(len(cluster)):\n            for j in range(i + 1, len(cluster)):\n                node1 = cluster[i]\n                node2 = cluster[j]\n                savings.append((node1, node2, distance_matrix[node1, 0] + distance_matrix[0, node2] - distance_matrix[node1, node2]))\n\n        savings.sort(key=lambda x: x[2], reverse=True)\n\n        route_segments = {node: [node] for node in cluster}\n\n        def merge_routes(node1, node2):\n            route1 = route_segments[node1]\n            route2 = route_segments[node2]\n            \n            new_route = route1 + route2\n            for node in new_route:\n                route_segments[node] = new_route\n\n        current_route = [0]\n        route_nodes = set()\n\n        for node1, node2, saving in savings:\n            if route_segments[node1] != route_segments[node2]:\n                current_route.append(node1)\n                current_route.append(node2)\n                merge_routes(node1, node2)\n                route_nodes.add(node1)\n                route_nodes.add(node2)\n\n        unvisited = list(set(cluster) - route_nodes)\n\n        for node in unvisited:\n          current_route.append(node)\n        \n        if not unvisited and len(route_nodes) == 0 and len(cluster) > 0:\n          current_route = [0] + cluster\n        \n        current_route = [0]\n        current_node = 0\n        remaining_nodes = set(cluster)\n        final_route = [0]\n\n        while remaining_nodes:\n            nearest_node = None\n            min_dist = float('inf')\n\n            for node in remaining_nodes:\n                dist = distance_matrix[current_node, node]\n                if dist < min_dist:\n                    min_dist = dist\n                    nearest_node = node\n            final_route.append(nearest_node)\n            remaining_nodes.remove(nearest_node)\n            current_node = nearest_node\n\n        final_route.append(0)\n\n        cluster_routes.append(final_route)\n    \n\n    # 3. Combine Routes and Construct Heuristic Matrix\n    for route in cluster_routes:\n        for i in range(len(route) - 1):\n            node1 = route[i]\n            node2 = route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n    \n    # Normalize heuristic matrix by distance\n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j]\n    \n    return heuristics_matrix",
          "objective": 10.51625,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm refines route construction by incorporating a probabilistic element in the savings heuristic, favoring edges with higher savings but allowing for exploration of less obvious connections, while still employing sweep-based clustering.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    \n    # 1. Sweep Clustering\n    angles = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n    nodes_with_angles = sorted(zip(range(1, n), angles), key=lambda x: x[1])\n    num_clusters = int(np.sqrt(n))\n    clusters = [[] for _ in range(num_clusters)]\n    \n    cluster_index = 0\n    current_cluster_demand = 0\n    \n    for node_index, angle in nodes_with_angles:\n        if current_cluster_demand + demands[node_index] <= capacity:\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand += demands[node_index]\n        else:\n            cluster_index = (cluster_index + 1) % num_clusters\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand = demands[node_index]\n    \n    # 2. Route Generation (Probabilistic Savings Heuristic)\n    cluster_routes = []\n    for cluster in clusters:\n        if not cluster:\n            cluster_routes.append([0,0])\n            continue\n\n        edges = []\n        for node in cluster:\n            edges.append((0, node))\n            edges.append((node, 0))\n\n        savings = []\n        for i in range(len(cluster)):\n            for j in range(i + 1, len(cluster)):\n                node1 = cluster[i]\n                node2 = cluster[j]\n                savings.append((node1, node2, distance_matrix[node1, 0] + distance_matrix[0, node2] - distance_matrix[node1, node2]))\n\n        savings.sort(key=lambda x: x[2], reverse=True)\n\n        route_segments = {node: [node] for node in cluster",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm refines route construction by incorporating a probabilistic element in the savings heuristic, favoring edges with higher savings but allowing for exploration of less obvious connections, while still employing sweep-based clustering.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    \n    # 1. Sweep Clustering\n    angles = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n    nodes_with_angles = sorted(zip(range(1, n), angles), key=lambda x: x[1])\n    num_clusters = int(np.sqrt(n))\n    clusters = [[] for _ in range(num_clusters)]\n    \n    cluster_index = 0\n    current_cluster_demand = 0\n    \n    for node_index, angle in nodes_with_angles:\n        if current_cluster_demand + demands[node_index] <= capacity:\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand += demands[node_index]\n        else:\n            cluster_index = (cluster_index + 1) % num_clusters\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand = demands[node_index]\n    \n    # 2. Route Generation (Probabilistic Savings Heuristic)\n    cluster_routes = []\n    for cluster in clusters:\n        if not cluster:\n            cluster_routes.append([0,0])\n            continue\n\n        edges = []\n        for node in cluster:\n            edges.append((0, node))\n            edges.append((node, 0))\n\n        savings = []\n        for i in range(len(cluster)):\n            for j in range(i + 1, len(cluster)):\n                node1 = cluster[i]\n                node2 = cluster[j]\n                savings.append((node1, node2, distance_matrix[node1, 0] + distance_matrix[0, node2] - distance_matrix[node1, node2]))\n\n        savings.sort(key=lambda x: x[2], reverse=True)\n\n        route_segments = {node: [node] for node in cluster}\n\n        def merge_routes(node1, node2):\n            route1 = route_segments[node1]\n            route2 = route_segments[node2]\n            \n            new_route = route1 + route2\n            for node in new_route:\n                route_segments[node] = new_route\n\n        current_route = [0]\n        route_nodes = set()\n\n        for node1, node2, saving in savings:\n            probability = min(1.0, saving / savings[0][2] if savings[0][2] > 0 else 1.0)\n            if route_segments[node1] != route_segments[node2] and random.random() < probability:\n                current_route.append(node1)\n                current_route.append(node2)\n                merge_routes(node1, node2)\n                route_nodes.add(node1)\n                route_nodes.add(node2)\n\n        unvisited = list(set(cluster) - route_nodes)\n\n        for node in unvisited:\n          current_route.append(node)\n        \n        if not unvisited and len(route_nodes) == 0 and len(cluster) > 0:\n          current_route = [0] + cluster\n        \n        current_route = [0]\n        current_node = 0\n        remaining_nodes = set(cluster)\n        final_route = [0]\n\n        while remaining_nodes:\n            nearest_node = None\n            min_dist = float('inf')\n\n            for node in remaining_nodes:\n                dist = distance_matrix[current_node, node]\n                if dist < min_dist:\n                    min_dist = dist\n                    nearest_node = node\n            final_route.append(nearest_node)\n            remaining_nodes.remove(nearest_node)\n            current_node = nearest_node\n\n        final_route.append(0)\n\n        cluster_routes.append(final_route)\n    \n\n    # 3. Combine Routes and Construct Heuristic Matrix\n    for route in cluster_routes:\n        for i in range(len(route) - 1):\n            node1 = route[i]\n            node2 = route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n    \n    # Normalize heuristic matrix by distance\n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j]\n    \n    return heuristics_matrix",
          "objective": 10.63281,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes routes based on demand consideration and penalizes longer distances, constructing routes iteratively by selecting the edge that maximizes a score function combining demand and distance penalty, then constructing prior indicators.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm prioritizes routes based on demand consideration and penalizes longer distances, constructing routes iteratively by selecting the edge that maximizes a score function combining demand and distance penalty, then constructing prior indicators.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    \n    # Initialize the current route with the depot\n    current_route = [0]\n    remaining_nodes = set(range(1, n))\n    current_capacity = capacity\n    \n    while remaining_nodes:\n        best_node = None\n        best_score = -1\n        \n        for node in remaining_nodes:\n            if demands[node] <= current_capacity:\n                # Calculate a score based on distance and remaining capacity\n                distance = distance_matrix[current_route[-1], node]\n                demand_ratio = demands[node] / capacity\n                \n                # Penalize longer distances more heavily\n                score = (1 / (distance**2)) * (1 - demand_ratio)\n                \n                if score > best_score:\n                    best_score = score\n                    best_node = node\n        \n        if best_node is not None:\n            current_route.append(best_node)\n            current_capacity -= demands[best_node]\n            remaining_nodes.remove(best_node)\n        else:\n            # Return to depot if no feasible node is found\n            current_route.append(0)\n            current_capacity = capacity\n            current_route.append(current_route[-2])  # Repeat last node to not disconnect previous edges\n    current_route.append(0)\n    # Populate the heuristic matrix based on the constructed route\n    for i in range(len(current_route) - 1):\n        node1 = current_route[i]\n        node2 = current_route[i+1]\n        heuristics_matrix[node1, node2] = 1\n        heuristics_matrix[node2, node1] = 1\n    \n    # Normalize\n    for i in range(n):\n        for j in range(n):\n             if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j]\n    \n    return heuristics_matrix",
          "objective": 11.55986,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes routes based on minimizing distance and rewarding remaining capacity, constructing routes iteratively by selecting the edge that minimizes a score function combining distance and remaining capacity, then constructing prior indicators.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm prioritizes routes based on minimizing distance and rewarding remaining capacity, constructing routes iteratively by selecting the edge that minimizes a score function combining distance and remaining capacity, then constructing prior indicators.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    \n    # Initialize the current route with the depot\n    current_route = [0]\n    remaining_nodes = set(range(1, n))\n    current_capacity = capacity\n    \n    while remaining_nodes:\n        best_node = None\n        best_score = float('inf')  # Initialize with a large value for minimization\n        \n        for node in remaining_nodes:\n            if demands[node] <= current_capacity:\n                # Calculate a score based on distance and remaining capacity\n                distance = distance_matrix[current_route[-1], node]\n                remaining_cap_ratio = 1- (demands[node]/current_capacity)\n                score = distance / (1 + remaining_cap_ratio) # Penalize longer distances and reward higher remaining capacity\n                \n                if score < best_score:\n                    best_score = score\n                    best_node = node\n        \n        if best_node is not None:\n            current_route.append(best_node)\n            current_capacity -= demands[best_node]\n            remaining_nodes.remove(best_node)\n        else:\n            # Return to depot if no feasible node is found\n            current_route.append(0)\n            current_capacity = capacity\n            current_route.append(current_route[-2])  # Repeat last node to not disconnect previous edges\n    current_route.append(0)\n    # Populate the heuristic matrix based on the constructed route\n    for i in range(len(current_route) - 1):\n        node1 = current_route[i]\n        node2 = current_route[i+1]\n        heuristics_matrix[node1, node2] = 1\n        heuristics_matrix[node2, node1] = 1\n    \n    # Normalize\n    for i in range(n):\n        for j in range(n):\n             if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j]\n    \n    return heuristics_matrix",
          "objective": 12.18917,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a clustering-first, routing-second approach, where nodes are clustered based on their proximity and demand, followed by generating routes within each cluster and then combining them.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm uses a clustering-first, routing-second approach, where nodes are clustered based on their proximity and demand, followed by generating routes within each cluster and then combining them.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_clusters = int(np.sqrt(n)) # Adjust number of clusters as needed\n    \n    # 1. Clustering (K-Means variant based on location and demand)\n    clusters = [[] for _ in range(num_clusters)]\n    cluster_centers = []\n\n    # Initialize cluster centers randomly from nodes, weighted by demand\n    probabilities = [demands[i] / sum(demands) if i > 0 else 0 for i in range(n)]\n    initial_centers = random.choices(range(1, n), weights=probabilities[1:], k=num_clusters)\n    cluster_centers = [coordinates[i] for i in initial_centers]\n    \n    #Assign nodes to closest cluster\n    for node in range(1, n):\n        min_dist = float('inf')\n        closest_cluster = -1\n        for i in range(num_clusters):\n            dist = np.linalg.norm(coordinates[node] - cluster_centers[i])\n            if dist < min_dist:\n                min_dist = dist\n                closest_cluster = i\n        clusters[closest_cluster].append(node)\n\n    # 2. Route Generation within Clusters (Simple Nearest Neighbor with Capacity Check)\n    cluster_routes = []\n    for cluster in clusters:\n        if not cluster: #Empty cluster, just to avoid errors\n            cluster_routes.append([0,0])\n            continue\n\n        current_node = 0  # Start at depot\n        current_route = [0]\n        current_capacity = capacity\n        remaining_nodes = set(cluster)\n        \n        while remaining_nodes:\n            nearest_node = None\n            min_dist = float('inf')\n            \n            for node in remaining_nodes:\n                if demands[node] <= current_capacity:\n                    dist = distance_matrix[current_node, node]\n                    if dist < min_dist:\n                        min_dist = dist\n                        nearest_node = node\n            \n            if nearest_node is None: #No feasible node\n                current_route.append(0)\n                current_capacity = capacity\n                current_node = 0\n            else:\n                current_route.append(nearest_node)\n                current_capacity -= demands[nearest_node]\n                current_node = nearest_node\n                remaining_nodes.remove(nearest_node)\n        \n        current_route.append(0)\n        cluster_routes.append(current_route)\n\n    # 3. Combine Routes and Construct Heuristic Matrix\n    for route in cluster_routes:\n        for i in range(len(route) - 1):\n            node1 = route[i]\n            node2 = route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n    \n    # Normalize heuristic matrix by distance\n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j]\n    \n    return heuristics_matrix",
          "objective": 12.26842,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively constructs routes by adding the closest feasible node to the current route until the vehicle's capacity is reached, then returns to the depot and repeats until all nodes are visited.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm iteratively constructs routes by adding the closest feasible node to the current route until the vehicle's capacity is reached, then returns to the depot and repeats until all nodes are visited.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    \n    unvisited_nodes = set(range(1, n))\n    routes = []\n    \n    while unvisited_nodes:\n        current_route = [0]\n        current_capacity = capacity\n        current_node = 0\n        \n        while True:\n            nearest_node = None\n            min_dist = float('inf')\n            \n            for node in unvisited_nodes:\n                if demands[node] <= current_capacity:\n                    dist = distance_matrix[current_node, node]\n                    if dist < min_dist:\n                        min_dist = dist\n                        nearest_node = node\n            \n            if nearest_node is None:\n                current_route.append(0)\n                routes.append(current_route)\n                break\n            else:\n                current_route.append(nearest_node)\n                current_capacity -= demands[nearest_node]\n                current_node = nearest_node\n                unvisited_nodes.remove(nearest_node)\n                \n    for route in routes:\n        for i in range(len(route) - 1):\n            node1 = route[i]\n            node2 = route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n    \n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j]\n    \n    return heuristics_matrix",
          "objective": 12.3048,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively constructs routes by adding the nearest feasible node to the current route until capacity is reached, then starts a new route.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm iteratively constructs routes by adding the nearest feasible node to the current route until capacity is reached, then starts a new route.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    unvisited_nodes = set(range(1, n))\n    routes = []\n    current_route = [0]\n    current_demand = 0\n\n    while unvisited_nodes:\n        nearest_node = None\n        min_distance = float('inf')\n\n        for node in unvisited_nodes:\n            if current_demand + demands[node] <= capacity:\n                distance = distance_matrix[current_route[-1], node]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_node = node\n\n        if nearest_node is not None:\n            current_route.append(nearest_node)\n            current_demand += demands[nearest_node]\n            unvisited_nodes.remove(nearest_node)\n        else:\n            current_route.append(0)\n            routes.append(current_route)\n            current_route = [0]\n            current_demand = 0\n\n    if current_route != [0]:\n        current_route.append(0)\n        routes.append(current_route)\n    \n    for route in routes:\n        for i in range(len(route) - 1):\n            node1 = route[i]\n            node2 = route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n    \n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j]\n\n    return heuristics_matrix",
          "objective": 12.30879,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively constructs routes by adding the nearest unvisited node to the current route until capacity is reached, then returns to the depot and repeats.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm iteratively constructs routes by adding the nearest unvisited node to the current route until capacity is reached, then returns to the depot and repeats.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    unvisited_nodes = set(range(1, n))\n    routes = []\n\n    while unvisited_nodes:\n        current_route = [0]\n        current_capacity = 0\n        current_node = 0\n\n        while True:\n            nearest_node = None\n            min_distance = float('inf')\n\n            for neighbor in unvisited_nodes:\n                if demands[neighbor] + current_capacity <= capacity:\n                    distance = distance_matrix[current_node, neighbor]\n                    if distance < min_distance:\n                        min_distance = distance\n                        nearest_node = neighbor\n\n            if nearest_node is None:\n                break\n\n            current_route.append(nearest_node)\n            current_capacity += demands[nearest_node]\n            unvisited_nodes.remove(nearest_node)\n            current_node = nearest_node\n\n        current_route.append(0)\n        routes.append(current_route)\n\n    for route in routes:\n        for i in range(len(route) - 1):\n            node1 = route[i]\n            node2 = route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j]\n\n    return heuristics_matrix",
          "objective": 12.32715,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively constructs solutions by probabilistically selecting edges based on distance, demand, and a dynamic pheromone-like value, while also incorporating a local search component to refine solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    pheromone_matrix = np.ones_like(distance_matrix)\n    alpha = 1.0\n    beta = 2.0\n    rho = 0.1\n    q0 = 0.9\n\n    num_iterations = 500\n\n    for iteration in range(num_iterations):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n        total_distance = 0\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    eta = 1 / distance_matrix[current_node, node]\n                    tau = pheromone_matrix[current_node, node]\n                    probabilities[node] = (tau**alpha) * (eta**beta)\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = random.choice(list(remaining_nodes))\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm iteratively constructs solutions by probabilistically selecting edges based on distance, demand, and a dynamic pheromone-like value, while also incorporating a local search component to refine solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    pheromone_matrix = np.ones_like(distance_matrix)\n    alpha = 1.0\n    beta = 2.0\n    rho = 0.1\n    q0 = 0.9\n\n    num_iterations = 500\n\n    for iteration in range(num_iterations):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n        total_distance = 0\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    eta = 1 / distance_matrix[current_node, node]\n                    tau = pheromone_matrix[current_node, node]\n                    probabilities[node] = (tau**alpha) * (eta**beta)\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = random.choice(list(remaining_nodes))\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}\n                if random.random() < q0:\n                    next_node = max(normalized_probabilities, key=normalized_probabilities.get)\n                else:\n                    next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))\n            \n            if current_capacity >= demands[next_node]:\n                route.append(next_node)\n                current_capacity -= demands[next_node]\n                total_distance += distance_matrix[current_node, next_node]\n                remaining_nodes.remove(next_node)\n                current_node = next_node\n            else:\n                route.append(0)\n                total_distance += distance_matrix[current_node, 0]\n                current_capacity = capacity\n                current_node = 0\n\n        total_distance += distance_matrix[current_node, 0]\n        route.append(0)\n\n        # Local Search (2-opt) - Simplified for brevity\n        for i in range(1, len(route) - 2):\n            for j in range(i + 1, len(route) - 1):\n                if j - i == 1: continue\n                \n                delta_distance = -distance_matrix[route[i-1], route[i]] - distance_matrix[route[j], route[j+1]] + distance_matrix[route[i-1], route[j]] + distance_matrix[route[i], route[j+1]]\n                if delta_distance < 0:\n                    route[i:j+1] = list(reversed(route[i:j+1]))\n                    total_distance += delta_distance\n\n        # Pheromone Update\n        for i in range(len(route) - 1):\n            pheromone_matrix[route[i], route[i+1]] = (1 - rho) * pheromone_matrix[route[i], route[i+1]] + rho / total_distance\n            pheromone_matrix[route[i+1], route[i]] = pheromone_matrix[route[i], route[i+1]]\n            heuristics_matrix[route[i], route[i+1]] += 1\n            heuristics_matrix[route[i+1], route[i]] += 1\n    \n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n               heuristics_matrix[i, j] /= distance_matrix[i, j]\n            \n    return heuristics_matrix",
          "objective": 12.44237,
          "other_inf": null
     }
]