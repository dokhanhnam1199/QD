import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm combines an adaptive large neighborhood search (ALNS) framework with route construction heuristics and simulated annealing to explore a diverse set of solutions and refine them iteratively.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 500
    temp_start = 100
    temp_end = 1
    cooling_rate = (temp_end / temp_start)**(1 / num_iterations)
    current_solution = list(range(n))
    random.shuffle(current_solution)
    current_solution = [0] + current_solution[1:] + [0]
    best_solution = current_solution[:]
    best_distance = calculate_route_distance(current_solution, distance_matrix)
    current_distance = best_distance
    temperature = temp_start

    for iteration in range(num_iterations):
        new_solution = current_solution[:]
        destroy_and_recreate(new_solution, distance_matrix, demands, capacity)
        new_distance = calculate_route_distance(new_solution, distance_matrix)

        if new_distance < current_distance:
            current_solution = new_solution[:]
            current_distance = new_distance
            if new_distance < best_distance:
                best_solution = new_solution[:]
                best_distance = new_distance
        else:
            acceptance_probability = np.exp((current_distance - new_distance) / temperature)
            if random.random() < acceptance_probability:
                current_solution = new_solution[:]
                current_distance = new_distance
        temperature *= cooling_rate
    
    for i in range(len(best_solution) - 1):
        heuristics_matrix[best_solution[i], best_solution[i+1]] += 1
        heuristics_matrix[best_solution[i+1], best_solution[i]] += 1

    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
               heuristics_matrix[i, j] /= distance_matrix[i, j]

    return heuristics_matrix

def calculate_route_distance(route, distance_matrix):
    total_distance = 0
    for i in range(len(route) - 1):
        total_distance += distance_matrix[route[i], route[i+1]]
    return total_distance

def destroy_and_recreate(route, distance_matrix, demands, capacity):
    destroy_percentage = 0.2
    num_destroy = max(1, int(len(route) * destroy_percentage))

    destroyed_nodes = random.sample(range(1, len(route) - 1), num_destroy)
    destroyed_nodes.sort(reverse=True)
    removed_nodes = []
    for i in destroyed_nodes:
        removed_nodes.append(route.pop(i))

    current_capacity = capacity
    current_node = 0
    while removed_nodes:
        best_node = -1
        best_insertion_index = -1
        best_cost = float('inf')

        for node_to_insert in removed_nodes:
            for i in range(1, len(route)):
                temp_route = route[:]
                temp_route.insert(i, node_to_insert)
                if check_capacity(temp_route, demands, capacity):

                    cost = distance_matrix[temp_route[i-1], temp_route[i]] + distance_matrix[temp_route[i], temp_route[i+1]] - distance_matrix[route[i-1], route[i]]
                    
                    if cost < best_cost:
                        best_cost = cost
                        best_node = node_to_insert
                        best_insertion_index = i

        if best_node != -1:
            route.insert(best_insertion_index, best_node)
            removed_nodes.remove(best_node)
        else:
            route.insert(1,0)
            route.insert(len(route)-1,0)
            break


def check_capacity(route, demands, capacity):
  current_capacity = capacity
  current_route_load = 0
  for i in range(1, len(route)-1):
    current_route_load += demands[route[i]]
  return heuristics_matrix
