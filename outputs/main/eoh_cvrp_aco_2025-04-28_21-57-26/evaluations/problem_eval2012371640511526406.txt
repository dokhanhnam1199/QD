import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm combines the stochastic sampling of routes with a biased random key generation for route construction, iteratively improving edge selection based on route fitness.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_routes = 100
    num_iterations = 50

    for _ in range(num_iterations):
        routes = []
        for _ in range(num_routes):
            route = []
            current_node = 0
            current_capacity = capacity
            remaining_nodes = set(range(1, n))
            current_route = [0]

            while remaining_nodes:
                feasible_nodes = [node for node in remaining_nodes if demands[node] <= current_capacity]
                if not feasible_nodes:
                    current_route.append(0)
                    current_capacity = capacity
                    current_node = 0
                    continue

                random_keys = np.random.rand(len(feasible_nodes))
                node_probabilities = random_keys / np.sum(random_keys)
                next_node = np.random.choice(feasible_nodes, p=node_probabilities)

                current_route.append(next_node)
                current_capacity -= demands[next_node]
                current_node = next_node
                remaining_nodes.remove(next_node)

            current_route.append(0)
            routes.append(current_route)

        route_lengths = [sum(distance_matrix[routes[i][j], routes[i][j+1]] for j in range(len(routes[i])-1)) for i in range(len(routes))]
        best_route_index = np.argmin(route_lengths)
        best_route = routes[best_route_index]

        for i in range(len(best_route) - 1):
            heuristics_matrix[best_route[i], best_route[i+1]] += 1
            heuristics_matrix[best_route[i+1], best_route[i]] += 1

    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= (distance_matrix[i, j] + 1e-6)

    return heuristics_matrix
