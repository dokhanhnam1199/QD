import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm builds upon the concept of iteratively constructing routes while considering both distance and capacity, but instead of savings or random sampling, it employs a reinforcement learning approach to learn edge importance through simulated annealing.}"""

    n = len(demands)
    heuristics_matrix = np.zeros((n, n))
    temperature = 100.0
    cooling_rate = 0.995
    num_iterations = 1000

    # Initialize a random route
    nodes = list(range(1, n))
    
    for _ in range(num_iterations):
        
        # Construct a route greedily based on heuristic values
        current_node = 0
        route = [0]
        remaining_nodes = nodes[:]
        current_capacity = capacity

        while remaining_nodes:
            
            # Select the next node based on heuristic information and capacity
            feasible_nodes = [node for node in remaining_nodes if demands[node] <= current_capacity]
            
            if not feasible_nodes:
                # If no feasible nodes, return to depot
                route.append(0)
                heuristics_matrix[current_node, 0] += 0.01
                heuristics_matrix[0, current_node] += 0.01
                current_node = 0
                current_capacity = capacity
                continue
            
            probabilities = {}
            for node in feasible_nodes:
                probabilities[node] = heuristics_matrix[current_node, node] + 1e-6 # Ensure no zero probability
            
            total_prob = sum(probabilities.values())
            if total_prob == 0:
                next_node = random.choice(feasible_nodes)
            else:
                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}
                next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))
            
            route.append(next_node)
            current_capacity -= demands[next_node]
            remaining_nodes.remove(next_node)
            heuristics_matrix[current_node, next_node] += 0.1
            heuristics_matrix[next_node, current_node] += 0.1
            current_node = next_node
            
        route.append(0)
        heuristics_matrix[current_node, 0] += 0.1
        heuristics_matrix[0, current_node] += 0.1
        
        # Evaluate route length
        route_length = 0
        for i in range(len(route) - 1):
            route_length += distance_matrix[route[i], route[i+1]]
            
        #Perturb route and evaluate
        
        new_nodes = nodes[:]
        random.shuffle(new_nodes)
        
        current_node = 0
        new_route = [0]
        remaining_nodes = new_nodes[:]
        current_capacity = capacity
        
        while remaining_nodes:
            
            # Select the next node based on heuristic information and capacity
            feasible_nodes = [node for node in remaining_nodes if demands[node] <= current_capacity]
            
            if not feasible_nodes:
                # If no feasible nodes, return to depot
                new_route.append(0)
                current_node = 0
                current_capacity = capacity
                continue
            
            probabilities = {}
            for node in feasible_nodes:
                probabilities[node] = heuristics_matrix[current_node, node] + 1e-6 # Ensure no zero probability
            
            total_prob = sum(probabilities.values())
            if total_prob == 0:
                next_node = random.choice(feasible_nodes)
            else:
                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}
                next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))
            
            new_route.append(next_node)
            current_capacity -= demands[next_node]
            remaining_nodes.remove(next_node)
            current_node = next_node
        
        new_route.append(0)
        
        new_route_length = 0
        for i in range(len(new_route) - 1):
            new_route_length += distance_matrix[new_route[i], new_route[i+1]]
            
        # Simulated annealing acceptance probability
        delta = new_route_length - route_length
        if delta < 0 or random.random() < np.exp(-delta / temperature):
            route = new_route
            #Update heuristics matrix
            for i in range(len(route) - 1):
                heuristics_matrix[route[i], route[i+1]] += 0.1
                heuristics_matrix[route[i+1], route[i]] += 0.1
        else:
            for i in range(len(route) - 1):
                heuristics_matrix[route[i], route[i+1]] -= 0.01
                heuristics_matrix[route[i+1], route[i]] -= 0.01


        #Cool down the temperature
        temperature *= cooling_rate
        
        
    return heuristics_matrix
