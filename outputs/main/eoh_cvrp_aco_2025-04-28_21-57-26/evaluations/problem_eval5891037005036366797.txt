import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively constructs solutions by greedily adding nodes to routes based on distance and capacity constraints, then refines them by randomly re-assigning nodes to different routes to explore diverse solutions and update edge inclusion frequencies.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 1000

    for _ in range(num_iterations):
        # Initialize routes greedily
        routes = []
        unassigned_customers = list(range(1, n))
        while unassigned_customers:
            route = []
            current_capacity = 0
            last_node = 0  # Start from depot
            while unassigned_customers:
                # Find nearest unassigned customer
                nearest_customer = None
                min_distance = float('inf')
                for customer in unassigned_customers:
                    if current_capacity + demands[customer] <= capacity and distance_matrix[last_node, customer] < min_distance:
                        nearest_customer = customer
                        min_distance = distance_matrix[last_node, customer]

                if nearest_customer is not None:
                    route.append(nearest_customer)
                    current_capacity += demands[nearest_customer]
                    unassigned_customers.remove(nearest_customer)
                    last_node = nearest_customer
                else:
                    break
            routes.append(route)

        # Refine routes by random re-assignment
        all_customers = []
        for route in routes:
            all_customers.extend(route)

        # Randomly shuffle customers
        random.shuffle(all_customers)

        new_routes = []
        while all_customers:
            route = []
            current_capacity = 0
            while all_customers:
                customer = all_customers.pop(0)
                if current_capacity + demands[customer] <= capacity:
                    route.append(customer)
                    current_capacity += demands[customer]
                else:
                    all_customers.insert(0, customer) # Put the customer back
                    break
            new_routes.append(route)
        
        routes = new_routes

        # Update heuristics matrix
        for route in routes:
            for i in range(len(route)):
                for j in range(i+1, len(route)):
                    heuristics_matrix[route[i], route[j]] += 1
                    heuristics_matrix[route[j], route[i]] += 1

    return heuristics_matrix
