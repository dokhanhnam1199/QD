import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses a clustering approach based on node proximity to seed routes and then iteratively refines the routes using a combination of node swapping and insertion, evaluating feasibility and cost to update a heuristic matrix.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_clusters = int(np.sqrt(n)) # Heuristic for determining the number of clusters
    num_iterations = 500

    # 1. Clustering (k-means inspired, but simplified for initialization)
    cluster_centers = random.sample(range(1, n), num_clusters)  # Randomly select initial cluster centers
    clusters = [[] for _ in range(num_clusters)]
    for i in range(1, n):
        closest_center = min(cluster_centers, key=lambda x: distance_matrix[i, x])
        cluster_index = cluster_centers.index(closest_center)
        clusters[cluster_index].append(i)

    # 2. Initial Route Construction (depot added)
    routes = [[0] + cluster + [0] for cluster in clusters]
    
    # 3. Iterative Improvement
    best_routes = routes[:]
    best_cost = float('inf')
    
    for _ in range(num_iterations):
        
        #a. Perturbation: Randomly choose a route and perform either a swap or insertion
        route_index = random.randint(0, len(routes) - 1)
        route = routes[route_index][1:-1] # Exclude depot
        
        if len(route) > 1 and random.random() < 0.5: #Swap
            i, j = random.sample(range(len(route)), 2)
            route[i], route[j] = route[j], route[i]
            
        elif len(route) > 0: #Insertion
            node_to_insert = random.choice(route)
            route.remove(node_to_insert)
            insert_position = random.randint(0, len(route))
            route.insert(insert_position, node_to_insert)

        new_routes = routes[:route_index] + [[0] + route + [0]] + routes[route_index+1:]
        
        #b. Feasibility Check and Cost Calculation
        feasible = True
        total_cost = 0
        for current_route in new_routes:
            current_load = 0
            for i in range(1, len(current_route)-1):
                current_load += demands[current_route[i]]
            if current_load > capacity:
                feasible = False
                break
            for i in range(len(current_route) - 1):
                total_cost += distance_matrix[current_route[i]][current_route[i+1]]
        
        #c. Update routes with greedy approach
        if feasible and total_cost < best_cost:
            best_cost = total_cost
            best_routes = new_routes[:] # Important to copy the content, not the reference
        
    #4. Construct Heuristic Matrix based on the best routes
    for route in best_routes:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] = 1
            heuristics_matrix[node2, node1] = 1

    return heuristics_matrix
