import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a greedy approach with route consolidation based on a cost-saving metric, iteratively merging routes to reduce the total distance while respecting capacity constraints.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    
    # Initialize each node as a separate route
    routes = [[i] for i in range(1, n)]
    current_capacities = [capacity - demands[i] for i in range(1, n)]
    
    depot = [0]

    # Iteratively merge routes based on cost savings
    while len(routes) > 1:
        best_merge = None
        best_savings = -np.inf

        for i in range(len(routes)):
            for j in range(i + 1, len(routes)):
                # Check capacity constraints
                if sum(demands[node] for node in routes[i]) + sum(demands[node] for node in routes[j]) <= capacity:
                    # Calculate savings from merging routes
                    savings = (
                        distance_matrix[routes[i][0], routes[j][-1]] + distance_matrix[routes[j][0], routes[i][-1]]-
                        distance_matrix[routes[i][0], routes[i][-1]] - distance_matrix[routes[j][0], routes[j][-1]]
                    )
                    
                    if savings > best_savings:
                        best_savings = savings
                        best_merge = (i, j)

        if best_merge:
            i, j = best_merge
            # Merge the routes
            routes[i].extend(routes[j])
            current_capacities[i] -= sum(demands[node] for node in routes[j])
            del routes[j]
            del current_capacities[j]
        else:
            break
    
    # Construct the final route
    final_route = [0]
    current_capacity = capacity
    
    if len(routes) == 1:
        final_route.extend(routes[0])
        final_route.append(0)
    else:
        for route in routes:
          final_route.extend(route)
          final_route.append(0)
    

    # Populate the heuristic matrix
    for i in range(len(final_route) - 1):
        node1 = final_route[i]
        node2 = final_route[i+1]
        heuristics_matrix[node1, node2] = 1
        heuristics_matrix[node2, node1] = 1

    # Normalize
    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]

    return heuristics_matrix
