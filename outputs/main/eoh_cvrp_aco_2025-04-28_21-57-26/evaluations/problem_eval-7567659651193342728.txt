import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses an Ant Colony Optimization (ACO) approach to build routes and update a pheromone matrix based on route quality.}"""
    n = len(demands)
    pheromone_matrix = np.ones_like(distance_matrix)
    heuristic_matrix = np.zeros_like(distance_matrix)
    alpha = 1
    beta = 2
    rho = 0.5
    num_ants = 10
    num_iterations = 100

    for _ in range(num_iterations):
        all_routes = []
        for ant in range(num_ants):
            unvisited = set(range(1, n))
            current_node = 0
            current_route = [0]
            current_load = 0
            routes = []
            
            while unvisited:
                probabilities = []
                for node in unvisited:
                    pheromone = pheromone_matrix[current_node][node] ** alpha
                    heuristic = (1 / distance_matrix[current_node][node]) ** beta if distance_matrix[current_node][node] > 0 else 0
                    probabilities.append((node, pheromone * heuristic))
                    
                total_prob = sum(p for _, p in probabilities)
                if total_prob == 0:
                    next_node = random.choice(list(unvisited))
                else:
                    probabilities = [(node, p / total_prob) for node, p in probabilities]
                    next_node = random.choices([node for node, _ in probabilities], weights=[p for _, p in probabilities], k=1)[0]
                

                if current_load + demands[next_node] <= capacity:
                    current_route.append(next_node)
                    current_load += demands[next_node]
                    unvisited.remove(next_node)
                    current_node = next_node
                else:
                    current_route.append(0)
                    routes.append(current_route)
                    current_route = [0]
                    current_load = 0
                    current_node = 0
            
            current_route.append(0)
            routes.append(current_route)
            all_routes.append(routes)

        # Evaluate routes (feasibility and distance)
        best_route = None
        best_distance = float('inf')
        
        for routes in all_routes:
            total_distance = 0
            is_feasible = True
            total_load = 0
            for route in routes:
                load = 0
                for i in range(len(route) - 1):
                    total_distance += distance_matrix[route[i]][route[i+1]]
                    if route[i] != 0:
                        load += demands[route[i]]
                        total_load += demands[route[i]]

                if load > capacity:
                    is_feasible = False
                    break

            if is_feasible and total_distance < best_distance:
                best_distance = total_distance
                best_route = routes
                

        # Update pheromone matrix
        if best_route:
            for route in best_route:
                for i in range(len(route) - 1):
                    pheromone_matrix[route[i]][route[i+1]] = (1 - rho) * pheromone_matrix[route[i]][route[i+1]] + rho * (1 / best_distance)
                    pheromone_matrix[route[i+1]][route[i]] = pheromone_matrix[route[i]][route[i+1]]

            #update heuristic matrix based on the best route
            for route in best_route:
                for i in range(len(route) - 1):
                    heuristic_matrix[route[i]][route[i+1]] += 1
                    heuristic_matrix[route[i+1]][route[i]] += 1

        else:
            #If no route is feasible, reduce the pheromone on all edges.
             pheromone_matrix = pheromone_matrix * (1 - rho)

    return heuristics_matrix
