import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines routes by probabilistically swapping nodes between routes based on a combination of distance reduction and demand feasibility, guided by a reinforcement learning-inspired reward matrix.}"""
    n = len(demands)
    heuristics_matrix = np.zeros((n, n))
    num_vehicles = max(1, int(sum(demands) / capacity) + 1)
    
    # 1. Initialize routes randomly
    routes = [[] for _ in range(num_vehicles)]
    unassigned_nodes = list(range(1, n))
    
    for i in range(1, n):
        vehicle_index = random.randint(0, num_vehicles - 1)
        routes[vehicle_index].append(i)
    
    # 2. Iterative refinement
    num_iterations = 1000

    reward_matrix = np.zeros((n, n))

    for _ in range(num_iterations):
        # Select two routes randomly
        route_index1 = random.randint(0, num_vehicles - 1)
        route_index2 = random.randint(0, num_vehicles - 1)
        
        if len(routes[route_index1]) == 0 or len(routes[route_index2]) == 0 or route_index1 == route_index2:
            continue
        
        # Select a node from each route
        node1 = random.choice(routes[route_index1])
        node2 = random.choice(routes[route_index2])
        
        # Calculate the potential cost reduction
        old_distance = distance_matrix[node1, 0] + distance_matrix[node2, 0]
        new_distance = distance_matrix[node1, node2] + distance_matrix[0, 0]
        delta_distance = old_distance - new_distance

        # Check capacity constraints
        route1_demand = sum([demands[node] for node in routes[route_index1]])
        route2_demand = sum([demands[node] for node in routes[route_index2]])
        
        new_route1_demand = route1_demand - demands[node1] + demands[node2]
        new_route2_demand = route2_demand - demands[node2] + demands[node1]
        
        if new_route1_demand <= capacity and new_route2_demand <= capacity:
            # Calculate acceptance probability based on distance reduction and reward
            probability = 1 / (1 + np.exp(-delta_distance + reward_matrix[node1, node2]))
            
            if random.random() < probability:
                # Swap the nodes
                routes[route_index1].remove(node1)
                routes[route_index2].remove(node2)
                routes[route_index1].append(node2)
                routes[route_index2].append(node1)
                
                #Update reward matrix
                reward_matrix[node1,node2] += 0.1
                reward_matrix[node2,node1] += 0.1
            else:
                reward_matrix[node1, node2] -=0.05
                reward_matrix[node2, node1] -=0.05


    # 3. Construct Heuristic Matrix
    for route in routes:
        for i in range(len(route)):
            for j in range(i + 1, len(route)):
                node1 = route[i]
                node2 = route[j]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1

    # Normalize by distance
    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]

    return heuristics_matrix
