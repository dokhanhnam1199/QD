import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines edge importance by probabilistically selecting edges based on a combination of distance, demand, and a dynamic edge score, simulating a population of routes that evolve towards better solutions.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    edge_scores = np.ones_like(distance_matrix)  # Initialize edge scores

    num_iterations = 100
    population_size = 50
    mutation_rate = 0.1
    alpha = 1.0
    beta = 1.0

    for iteration in range(num_iterations):
        routes = []
        route_distances = []

        for _ in range(population_size):
            current_node = 0
            route = [0]
            remaining_nodes = set(range(1, n))
            current_capacity = capacity
            total_distance = 0

            while remaining_nodes:
                probabilities = {}
                for node in remaining_nodes:
                    if current_capacity >= demands[node]:
                        distance_heuristic = np.exp(-alpha * distance_matrix[current_node, node])
                        demand_heuristic = np.exp(-beta * (demands[node] / current_capacity))
                        probabilities[node] = distance_heuristic * demand_heuristic * edge_scores[current_node, node]

                if not probabilities:
                    break

                total_prob = sum(probabilities.values())
                if total_prob == 0:
                    next_node = random.choice(list(remaining_nodes))
                else:
                    normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}
                    next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))

                if current_capacity >= demands[next_node]:
                    route.append(next_node)
                    total_distance += distance_matrix[current_node, next_node]
                    current_capacity -= demands[next_node]
                    remaining_nodes.remove(next_node)
                    current_node = next_node
                else:
                    route.append(0)
                    total_distance += distance_matrix[current_node, 0]
                    current_node = 0
                    current_capacity = capacity

            if current_node != 0:
                total_distance += distance_matrix[current_node, 0]
                route.append(0)

            routes.append(route)
            route_distances.append(total_distance)

        # Update edge scores based on best routes in the population
        best_route_index = np.argmin(route_distances)
        best_route = routes[best_route_index]

        for i in range(len(best_route) - 1):
            node1 = best_route[i]
            node2 = best_route[i+1]
            edge_scores[node1, node2] *= (1 + mutation_rate)
            edge_scores[node2, node1] *= (1 + mutation_rate)

        # Apply mutation: decrease scores of random edges
        for i in range(n):
            for j in range(n):
                if random.random() < mutation_rate:
                    edge_scores[i, j] *= (1 - mutation_rate)

    # Populate heuristics matrix based on final edge scores
    for i in range(n):
        for j in range(n):
            heuristics_matrix[i, j] = edge_scores[i, j]

    return heuristics_matrix
