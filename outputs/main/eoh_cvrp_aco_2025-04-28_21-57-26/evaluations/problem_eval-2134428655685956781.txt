import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm employs a savings-based approach, iteratively merging routes based on their savings value while respecting capacity constraints, and constructs a heuristic matrix reflecting edge usage frequency.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    # 1. Initialize routes with each customer as a separate route
    routes = [[0, i, 0] for i in range(1, n)]
    
    # 2. Calculate Savings
    savings = {}
    for i in range(1, n):
        for j in range(i + 1, n):
            savings[(i, j)] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]

    # Sort savings in descending order
    sorted_savings = sorted(savings.items(), key=lambda item: item[1], reverse=True)

    # 3. Merge routes based on savings
    route_dict = {i: [0, i, 0] for i in range(1, n)}
    while sorted_savings:
        (i, j), saving_value = sorted_savings.pop(0)
        
        route_i = route_dict.get(i, None)
        route_j = route_dict.get(j, None)

        if route_i is None or route_j is None or route_i == route_j:
            continue

        # Check if i is the last node of route_i and j is the first node of route_j (excluding depot)
        if route_i[-2] == i and route_j[1] == j:
            #Check capacity constraint
            total_demand = sum(demands[node] for node in route_i[1:-1]) + sum(demands[node] for node in route_j[1:-1])
            if total_demand <= capacity:
                new_route = route_i[:-1] + route_j[1:]
                
                # Update route_dict
                for node in new_route[1:-1]:
                    route_dict[node] = new_route
                routes.remove(route_i)
                routes.remove(route_j)
                routes.append(new_route)
    
    # 4. Construct Heuristic Matrix
    for route in routes:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1
    
    # Normalize heuristic matrix by distance
    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]

    return heuristics_matrix
