import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs solutions by iteratively improving an initial solution using a combination of local search and stochastic acceptance based on simulated annealing principles, using the initial pheromone matrix as an indicator of edge desirability.}"""
    n = len(demands)
    pheromone_matrix = 1 / (distance_matrix + np.eye(n))
    heuristics_matrix = np.zeros_like(distance_matrix)
    T = 1.0
    T_min = 0.00001
    alpha = 0.9
    num_iterations = 100

    def calculate_cost(routes):
        total_cost = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_cost += distance_matrix[route[i]][route[i+1]]
        return total_cost

    def generate_initial_solution():
        routes = []
        unvisited = set(range(1, n))
        current_route = [0]
        current_load = 0

        while unvisited:
            best_node = None
            best_pheromone = -1
            for node in unvisited:
                if current_load + demands[node] <= capacity:
                    pheromone = pheromone_matrix[current_route[-1], node]
                    if pheromone > best_pheromone:
                        best_pheromone = pheromone
                        best_node = node

            if best_node is None:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0]
                current_load = 0
            else:
                current_route.append(best_node)
                current_load += demands[best_node]
                unvisited.remove(best_node)

        if current_route[-1] != 0:
            current_route.append(0)
        routes.append(current_route)
        return routes
    
    best_solution = generate_initial_solution()
    best_cost = calculate_cost(best_solution)

    while T > T_min:
        for i in range(num_iterations):
            # Generate neighbor solution by randomly swapping two nodes in a route or moving a node to another route
            neighbor_solution = [route[:] for route in best_solution] #Deep copy
            
            #Randomly select a route
            route_index = random.randint(0, len(neighbor_solution)-1)
            if len(neighbor_solution[route_index])<=2:
                continue

            #Randomly select an index in the selected route
            index_to_swap = random.randint(1, len(neighbor_solution[route_index])-2)
            
            #Randomly select another route
            another_route_index = random.randint(0, len(neighbor_solution)-1)
            if len(neighbor_solution[another_route_index])<=2:
                continue

            #Randomly select another index in another selected route
            another_index_to_swap = random.randint(1, len(neighbor_solution[another_route_index])-2)
            
            neighbor_solution[route_index][index_to_swap], neighbor_solution[another_route_index][another_index_to_swap] = neighbor_solution[another_route_index][another_index_to_swap], neighbor_solution[route_index][index_to_swap]
            
            neighbor_cost = calculate_cost(neighbor_solution)

            # Acceptance criterion based on simulated annealing
            delta = neighbor_cost - best_cost
            if delta < 0 or random.random() < np.exp(-delta / T):
                best_solution = neighbor_solution
                best_cost = neighbor_cost

        T = T * alpha
    
    #Construct the heuristic matrix based on best solution
    for route in best_solution:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] = 1
            heuristics_matrix[route[i+1], route[i]] = 1
    
    return heuristics_matrix
