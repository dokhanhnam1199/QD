import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines edge weights based on the feasibility and cost-effectiveness of including edges in candidate routes generated using a randomized construction approach.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    edge_weights = np.ones_like(distance_matrix)

    num_iterations = 500
    alpha = 0.1  # Learning rate for edge weights
    beta = 0.9  # Influence of distance on edge selection

    for _ in range(num_iterations):
        current_node = 0
        route = [0]
        remaining_nodes = set(range(1, n))
        current_capacity = capacity

        while remaining_nodes:
            probabilities = {}
            for node in remaining_nodes:
                if current_capacity >= demands[node]:
                    distance_heuristic = np.exp(-beta * distance_matrix[current_node, node])
                    probabilities[node] = distance_heuristic * edge_weights[current_node, node]

            if not probabilities:
                break

            total_prob = sum(probabilities.values())
            if total_prob == 0:
                next_node = random.choice(list(remaining_nodes))
            else:
                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}
                next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))

            if current_capacity >= demands[next_node]:
                route.append(next_node)
                current_capacity -= demands[next_node]
                remaining_nodes.remove(next_node)
                heuristics_matrix[current_node, next_node] += 1
                heuristics_matrix[next_node, current_node] += 1

                edge_weights[current_node, next_node] *= (1 + alpha)
                edge_weights[next_node, current_node] *= (1 + alpha)

                current_node = next_node
            else:
                route.append(0)
                heuristics_matrix[current_node, 0] += 1
                heuristics_matrix[0, current_node] += 1

                edge_weights[current_node, 0] *= (1 - alpha)
                edge_weights[0, current_node] *= (1 - alpha)

                current_node = 0
                current_capacity = capacity

        if current_node != 0:
            heuristics_matrix[current_node, 0] += 1
            heuristics_matrix[0, current_node] += 1

    return heuristics_matrix
