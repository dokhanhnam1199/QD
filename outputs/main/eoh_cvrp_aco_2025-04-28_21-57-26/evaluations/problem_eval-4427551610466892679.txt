import numpy as np
import random
from collections import defaultdict

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs a heuristic matrix by iteratively building routes using a modified regret-based insertion heuristic, incorporating a weighted regret score and distance factor to prioritize nodes based on both insertion cost and proximity.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 500
    regret_weight = 0.7
    distance_weight = 0.3

    for _ in range(num_iterations):
        # Initialize a route with the depot
        unvisited_nodes = list(range(1, n))
        current_route = [0]
        current_load = 0
        
        while unvisited_nodes:
            # Calculate insertion cost for each unvisited node
            insertion_costs = {}
            for node in unvisited_nodes:
                best_insertion_cost = float('inf')
                best_insertion_position = -1
                
                for i in range(1, len(current_route)):
                    temp_route = current_route[:]
                    temp_route.insert(i, node)
                    temp_load = current_load + demands[node]
                    
                    if temp_load <= capacity:
                        cost = distance_matrix[temp_route[i-1]][temp_route[i]] + distance_matrix[temp_route[i]][temp_route[i+1]] - distance_matrix[temp_route[i-1]][temp_route[i+1]]
                        if cost < best_insertion_cost:
                            best_insertion_cost = cost
                            best_insertion_position = i
                
                #Cost to return to depot if this is the last node to be inserted
                temp_route = current_route[:]
                temp_route.append(node)
                temp_load = current_load + demands[node]
                if temp_load <= capacity:
                    cost = distance_matrix[temp_route[-2]][temp_route[-1]] + distance_matrix[temp_route[-1]][0]
                    if cost < best_insertion_cost:
                        best_insertion_cost = cost
                        best_insertion_position = len(current_route)
                    
                if best_insertion_cost != float('inf'):
                    insertion_costs[node] = (best_insertion_cost, best_insertion_position)
            
            if not insertion_costs: #No possible insertion due to capacity
                current_route.append(0)
                current_load = 0
                if len(current_route) > 1:
                    for i in range(len(current_route) - 1):
                        node1 = current_route[i]
                        node2 = current_route[i+1]
                        heuristics_matrix[node1, node2] = 1
                        heuristics_matrix[node2, node1] = 1
                current_route = [0]
                continue # Start a new route
            
            # Regret-based selection with distance consideration
            if len(insertion_costs) > 1:
                sorted_costs = sorted(insertion_costs.items(), key=lambda item: item[1][0])
                best_node, (best_cost, best_position) = sorted_costs[0]
                second_best_cost = sorted_costs[1][1][0]
                regret = second_best_cost - best_cost
                
                # Incorporate distance factor
                distance_to_best = distance_matrix[current_route[-1]][best_node] if len(current_route) > 1 else distance_matrix[0][best_node]
                
                # Weighted score
                weighted_score = regret_weight * regret - distance_weight * distance_to_best
                
                # Select node with lowest cost adjusted by weighted score
                selected_node = best_node                
                best_insertion_cost, best_insertion_position = insertion_costs[selected_node]
            else:
                selected_node, (best_insertion_cost, best_insertion_position) = list(insertion_costs.items())[0]
                
            # Insert the selected node
            if best_insertion_position == len(current_route):
                current_route.append(selected_node)
                current_load += demands[selected_node]
            else:
                current_route.insert(best_insertion_position, selected_node)
                current_load += demands[selected_node]
            unvisited_nodes.remove(selected_node)
            
        # Close the route
        current_route.append(0)
        
        # Update heuristic matrix
        for i in range(len(current_route) - 1):
            node1 = current_route[i]
            node2 = current_route[i+1]
            heuristics_matrix[node1, node2] = 1
            heuristics_matrix[node2, node1] = 1

    return heuristics_matrix
