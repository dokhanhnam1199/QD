import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses an ant colony optimization approach with modified pheromone update and heuristic calculation to probabilistically build routes, favoring shorter distances and lower capacity utilization, while also discouraging revisits to recently visited nodes and updating pheromone trails on edges used in feasible routes with an increased pheromone evaporation rate.}"""
    n = distance_matrix.shape[0]
    pheromone_matrix = np.ones_like(distance_matrix)
    heuristics_matrix = np.zeros_like(distance_matrix)
    alpha = 0.5
    beta = 1.5
    rho = 0.5
    num_ants = 15
    num_iterations = 75
    memory_factor = 0.75

    for iteration in range(num_iterations):
        all_routes = []
        for ant in range(num_ants):
            current_node = 0
            route = [0]
            remaining_nodes = set(range(1, n))
            current_capacity = capacity
            visited_recently = set()
            
            while remaining_nodes:
                probabilities = {}
                for node in remaining_nodes:
                    if node in visited_recently:
                        continue

                    pheromone = pheromone_matrix[current_node, node]
                    heuristic = (1 / (distance_matrix[current_node, node] + 1e-6)) ** beta
                    capacity_factor = max(0, (current_capacity - demands[node]) / capacity) ** alpha
                    probabilities[node] = pheromone * heuristic * (capacity_factor + 0.01)

                if not probabilities:
                    break

                total_prob = sum(probabilities.values())
                if total_prob == 0:
                    next_node = random.choice(list(remaining_nodes))
                else:
                    normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}
                    next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))
                
                if current_capacity >= demands[next_node]:
                    route.append(next_node)
                    current_capacity -= demands[next_node]
                    remaining_nodes.remove(next_node)
                    visited_recently.add(next_node)
                    if len(visited_recently) > 5:
                        visited_recently.pop()
                    current_node = next_node
                else:
                    route.append(0)
                    current_node = 0
                    current_capacity = capacity
                    visited_recently.clear()

            route.append(0)
            all_routes.append(route)

        # Update pheromones
        delta_pheromone = np.zeros_like(distance_matrix)
        for route in all_routes:
            total_demand = 0
            feasible = True
            current_load = 0
            for i in range(1, len(route)):
                if route[i] == 0:
                   current_load = 0
                else:
                    if current_load + demands[route[i]] > capacity:
                        feasible = False
                        break
                    current_load += demands[route[i]]
            
            if feasible:
                route_distance = 0
                for i in range(len(route) - 1):
                    route_distance += distance_matrix[route[i], route[i+1]]
                
                if route_distance > 0:
                    pheromone_deposit = 1 / route_distance
                else:
                    pheromone_deposit = 0

                for i in range(len(route) - 1):
                    delta_pheromone[route[i], route[i+1]] += pheromone_deposit
                    delta_pheromone[route[i+1], route[i]] += pheromone_deposit

        pheromone_matrix = (1 - rho) * pheromone_matrix + delta_pheromone
    
    heuristics_matrix = pheromone_matrix
    
    return heuristics_matrix
