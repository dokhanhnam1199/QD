import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs routes by iteratively improving them through local search, guided by a weighted combination of distance and a penalty term for exceeding capacity.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    
    # Initialize routes randomly
    num_routes = 3 # Adjust as needed
    routes = []
    unassigned_nodes = set(range(1, n))
    
    for _ in range(num_routes):
        route = [0]
        current_capacity = capacity
        
        available_nodes = list(unassigned_nodes)
        while available_nodes:
            node = random.choice(available_nodes)
            if demands[node] <= current_capacity:
                route.append(node)
                current_capacity -= demands[node]
                unassigned_nodes.remove(node)
                available_nodes.remove(node)
            else:
                available_nodes.remove(node)
        route.append(0)
        routes.append(route)

    if unassigned_nodes:
      route = [0]
      for node in unassigned_nodes:
        route.append(node)
      route.append(0)
      routes.append(route)
        
    # Iterative Improvement (Local Search)
    num_iterations = 100 # Adjust as needed
    for _ in range(num_iterations):
        for route_index in range(len(routes)):
            route = routes[route_index]
            if len(route) <= 3:
                continue

            # Choose two random nodes (excluding the depot)
            i = random.randint(1, len(route) - 2)
            j = random.randint(1, len(route) - 2)
            if i == j:
                continue
            
            # Swap the nodes
            new_route = route[:]
            new_route[i], new_route[j] = new_route[j], new_route[i]
            
            # Capacity check
            current_capacity = capacity
            total_demand = 0
            valid = True
            for k in range(1, len(new_route)-1):
                total_demand += demands[new_route[k]]

            num_returns = int(total_demand // capacity)

            new_route_valid = True

            total_demand = 0
            cur_capacity = capacity
            for k in range(1, len(new_route)-1):
              if demands[new_route[k]] <= cur_capacity:
                cur_capacity -= demands[new_route[k]]
              else:
                new_route_valid = False
                break
            
            if not new_route_valid:
              continue
            
            routes[route_index] = new_route
           
    # Construct Heuristic Matrix
    for route in routes:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1
            
    # Normalize by distance
    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]
                
    return heuristics_matrix
