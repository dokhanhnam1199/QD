import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a Monte Carlo Tree Search (MCTS) approach to explore the solution space, prioritizing edges based on their frequency in promising routes discovered during the search.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_simulations = 500
    C = 2  # Exploration constant

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost
    
    def is_feasible(route):
      current_demand = 0
      for i in range(len(route) - 1):
        if route[i] == 0 and route[i+1] != 0:
          current_demand = demands[route[i+1]]
        elif route[i] != 0 and route[i+1] == 0:
          continue
        else:
          current_demand += demands[route[i+1]] if route[i+1] != 0 else 0
        if current_demand > capacity:
          return False
      return True

    def simulate(current_route, unvisited_nodes, current_demand):
      if not unvisited_nodes:
        return current_route + [0]

      best_node = None
      best_ucb = -1

      for node in unvisited_nodes:
        ucb = heuristics_matrix[current_route[-1], node] + C * np.sqrt(np.log(num_simulations) / (1 + 1e-9))
        if ucb > best_ucb:
          best_ucb = ucb
          best_node = node
      
      if current_demand + demands[best_node] <= capacity:
          next_route = current_route + [best_node]
          next_unvisited = unvisited_nodes[:]
          next_unvisited.remove(best_node)
          return simulate(next_route, next_unvisited, current_demand + demands[best_node])
      else:
          next_route = current_route + [0, best_node]
          next_unvisited = unvisited_nodes[:]
          next_unvisited.remove(best_node)
          return simulate(next_route, next_unvisited, demands[best_node])

    for _ in range(num_simulations):
      unvisited = list(range(1, n))
      route = simulate([0], unvisited, 0)

      if is_feasible(route):
        for i in range(len(route) - 1):
          node1 = route[i]
          node2 = route[i+1]
          heuristics_matrix[node1, node2] += 1

    return heuristics_matrix
