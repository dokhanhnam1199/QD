import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs solutions using a guided random walk based on a pheromone matrix, updating pheromones based on solution quality.}"""
    n = distance_matrix.shape[0]
    pheromone_matrix = np.ones_like(distance_matrix)
    heuristics_matrix = np.zeros_like(distance_matrix)
    
    num_iterations = 500
    alpha = 1.0  # Pheromone influence
    beta = 2.0   # Distance influence
    rho = 0.5    # Evaporation rate
    Q = 100.0   # Pheromone deposit constant

    for iteration in range(num_iterations):
        all_routes = []
        
        for ant in range(10): # Number of ants
            current_node = 0
            route = [0]
            remaining_nodes = set(range(1, n))
            current_capacity = capacity

            while remaining_nodes:
                probabilities = {}
                for node in remaining_nodes:
                    if current_capacity >= demands[node]:
                        pheromone = pheromone_matrix[current_node, node]
                        distance = distance_matrix[current_node, node]
                        probabilities[node] = (pheromone**alpha) * ((1.0 / (distance + 1e-6))**beta)

                if not probabilities:
                    break # Break the loop, no valid node found
                    
                total_prob = sum(probabilities.values())
                if total_prob == 0:
                    next_node = random.choice(list(remaining_nodes))
                else:
                    normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}
                    next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))

                if current_capacity >= demands[next_node]:
                    route.append(next_node)
                    current_capacity -= demands[next_node]
                    remaining_nodes.remove(next_node)
                    current_node = next_node
                else:
                    route.append(0)
                    current_node = 0
                    current_capacity = capacity
                    
            if route[-1] != 0:
                route.append(0)

            all_routes.append(route)
            
        # Calculate route lengths
        route_lengths = []
        for route in all_routes:
            length = 0
            for i in range(len(route)-1):
                length += distance_matrix[route[i], route[i+1]]
            route_lengths.append(length)
        
        best_route_index = np.argmin(route_lengths)
        best_route = all_routes[best_route_index]
        best_route_length = route_lengths[best_route_index]
        
        # Update pheromones
        pheromone_matrix *= (1 - rho)  # Evaporation

        for i in range(len(best_route) - 1):
            node1 = best_route[i]
            node2 = best_route[i+1]
            pheromone_matrix[node1, node2] += Q / best_route_length
            pheromone_matrix[node2, node1] += Q / best_route_length
    
    for i in range(n):
        for j in range(n):
            heuristics_matrix[i,j] = pheromone_matrix[i,j]

    return heuristics_matrix
