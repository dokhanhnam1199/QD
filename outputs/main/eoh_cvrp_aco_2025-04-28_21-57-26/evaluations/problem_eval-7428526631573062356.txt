import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs routes by iteratively inserting the most cost-effective node into an existing route, considering both distance and capacity constraints, and returns a matrix indicating edge usage frequency across multiple route constructions.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 10  # Number of route construction iterations

    for _ in range(num_iterations):
        unvisited_nodes = set(range(1, n))
        routes = [[0]]  # Start with depot in each route
        remaining_capacities = [capacity]

        while unvisited_nodes:
            best_node_to_insert = None
            best_route_index = None
            best_insertion_cost = float('inf')
            best_insertion_index = None

            for route_index, route in enumerate(routes):
                current_capacity = remaining_capacities[route_index]

                for node in unvisited_nodes:
                    if demands[node] <= current_capacity:
                        # Try inserting the node at every possible position in the route
                        for i in range(1, len(route)):  # Do not insert before the depot
                            insertion_cost = (
                                distance_matrix[route[i-1], node] +
                                distance_matrix[node, route[i]] -
                                distance_matrix[route[i-1], route[i]]
                            )
                            if insertion_cost < best_insertion_cost:
                                best_insertion_cost = insertion_cost
                                best_node_to_insert = node
                                best_route_index = route_index
                                best_insertion_index = i

            if best_node_to_insert is not None:
                routes[best_route_index].insert(best_insertion_index, best_node_to_insert)
                remaining_capacities[best_route_index] -= demands[best_node_to_insert]
                unvisited_nodes.remove(best_node_to_insert)
            else:
                # Start a new route if no feasible insertion is found
                routes.append([0])
                remaining_capacities.append(capacity)

        # Complete the routes by returning to the depot
        for route in routes:
            route.append(0)

        # Update the heuristic matrix
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1
    
    #Normalize
    for i in range(n):
        for j in range(n):
             if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]

    return heuristics_matrix
