import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines edge probabilities by sampling feasible routes, adjusting probabilities based on edge usage and route feasibility, and encouraging diversification by occasionally selecting edges with low probabilities.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones((n, n)) * 0.5  # Initialize probabilities
    num_iterations = 1000
    alpha = 0.1  # Learning rate
    beta = 0.05 # Diversification factor

    for _ in range(num_iterations):
        # Construct a route using probabilities
        route = [0]
        current_node = 0
        current_capacity = 0
        visited = {0}

        while True:
            # Select the next node based on probabilities, prefer unvisited
            eligible_nodes = [node for node in range(1, n) if node not in visited]
            if not eligible_nodes:
                break

            probabilities = np.array([heuristics_matrix[current_node, node] for node in eligible_nodes])
            probabilities /= np.sum(probabilities)

            next_node = np.random.choice(eligible_nodes, p=probabilities)

            # Check capacity
            if current_capacity + demands[next_node] <= capacity:
                route.append(next_node)
                current_capacity += demands[next_node]
                visited.add(next_node)
                current_node = next_node
            else:
                route.append(0)
                current_capacity = 0
                current_node = 0
                visited.add(0) #Ensure depot is not revisted in the same route segment
        route.append(0)

        # Evaluate feasibility
        is_feasible = True
        total_capacity = 0
        for i in range(len(route) - 1):
          u = route[i]
          v = route[i+1]
          if u != 0:
            total_capacity += demands[u]

          if v == 0:
            if total_capacity > capacity:
              is_feasible = False
              break
            total_capacity = 0
            
        if total_capacity > 0 and total_capacity > capacity:
          is_feasible = False

        # Update heuristics based on feasibility
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]

            if is_feasible:
                heuristics_matrix[u, v] += alpha * (1 - heuristics_matrix[u, v])  # Reward
                heuristics_matrix[v, u] = heuristics_matrix[u,v]
            else:
                heuristics_matrix[u, v] -= alpha * heuristics_matrix[u, v] # Punish
                heuristics_matrix[v, u] = heuristics_matrix[u,v]


        #Diversification: Encourage exploring less promising edges
        if random.random() < beta:
          i = random.randint(0,n-1)
          j = random.randint(0,n-1)
          heuristics_matrix[i,j] += alpha #Small probability boost.
          heuristics_matrix[j,i] = heuristics_matrix[i,j]

    return heuristics_matrix
