import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a savings-based approach with route merging, where initial routes are formed for each node, and then iteratively merged based on savings until capacity constraints are violated or no further merges are beneficial.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    # 1. Initialize routes: Each node has its own route from depot
    routes = [[0, i, 0] for i in range(1, n)]

    # 2. Calculate savings
    savings = {}
    for i in range(1, n):
        for j in range(i + 1, n):
            savings[(i, j)] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]

    # Sort savings in descending order
    sorted_savings = sorted(savings.items(), key=lambda item: item[1], reverse=True)

    # 3. Merge routes based on savings and capacity
    route_dict = {i: [0, i, 0] for i in range(1, n)}  # Dictionary to quickly access routes

    for (i, j), saving in sorted_savings:
        route_i = route_dict.get(i)
        route_j = route_dict.get(j)

        if route_i is None or route_j is None or route_i == route_j:
            continue

        #Check if i and j are at the ends of their respective routes.
        if route_i[-2] != i or route_j[1] != j:
            continue
        
        # Calculate total demand of merged route
        total_demand = sum(demands[node] for node in route_i[1:-1] + route_j[1:-1])
        
        if total_demand <= capacity:
            # Merge routes
            merged_route = route_i[:-1] + route_j[1:]
            
            # Update route dictionary
            for node in route_i[1:-1] + route_j[1:-1]:
                route_dict[node] = merged_route
            
            routes = [r for r in routes if r != route_i and r != route_j]
            routes.append(merged_route)


    # 4. Construct Heuristic Matrix
    for route in routes:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    # Normalize heuristic matrix by distance
    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]
                
    return heuristics_matrix
