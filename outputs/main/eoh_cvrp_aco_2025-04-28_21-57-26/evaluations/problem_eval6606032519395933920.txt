import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm combines stochastic sampling with a modified simulated annealing acceptance probability based on both edge distance and pheromone levels, while also incorporating a dynamic pheromone update strategy that favors shorter routes and penalizes longer ones.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    pheromone_matrix = np.ones_like(distance_matrix)
    temperature = 1.0
    cooling_rate = 0.995
    num_samples = 500
    alpha = 1.0
    beta = 2.0

    for _ in range(num_samples):
        current_node = 0
        route = [0]
        remaining_nodes = set(range(1, n))
        current_capacity = capacity
        route_distance = 0

        while remaining_nodes:
            probabilities = {}
            for node in remaining_nodes:
                if current_capacity >= demands[node]:
                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)
                    demand_heuristic = (current_capacity - demands[node]) / capacity
                    probabilities[node] = (distance_heuristic**alpha) * (demand_heuristic + 0.1) * (pheromone_matrix[current_node, node]**beta)

            if not probabilities:
                break

            total_prob = sum(probabilities.values())
            if total_prob == 0:
                next_node = remaining_nodes.pop()
            else:
                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}
                next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))
                
            if current_capacity >= demands[next_node]:
                delta_distance = distance_matrix[current_node, next_node]
                acceptance_probability = np.exp((-delta_distance / temperature) + pheromone_matrix[current_node, next_node])

                if random.random() < acceptance_probability:
                    route.append(next_node)
                    heuristics_matrix[current_node, next_node] += 1
                    heuristics_matrix[next_node, current_node] += 1
                    current_capacity -= demands[next_node]
                    remaining_nodes.remove(next_node)
                    route_distance += distance_matrix[current_node, next_node]
                    current_node = next_node
                else:
                    remaining_nodes.remove(next_node)

            else:
                delta_distance = distance_matrix[current_node, 0]
                acceptance_probability = np.exp((-delta_distance / temperature) + pheromone_matrix[current_node, 0])
                if random.random() < acceptance_probability:
                    route.append(0)
                    heuristics_matrix[current_node, 0] += 1
                    heuristics_matrix[0, current_node] += 1
                    route_distance += distance_matrix[current_node, 0]
                    current_node = 0
                    current_capacity = capacity
                else:
                    break
                    

        if current_node != 0:
            delta_distance = distance_matrix[current_node, 0]
            acceptance_probability = np.exp((-delta_distance / temperature) + pheromone_matrix[current_node, 0])
            if random.random() < acceptance_probability:
                heuristics_matrix[current_node, 0] += 1
                heuristics_matrix[0, current_node] += 1
            route_distance += distance_matrix[current_node, 0]

        # Pheromone update
        if route_distance > 0:
            pheromone_delta = 1.0 / route_distance
        else:
            pheromone_delta = 0.0

        for i in range(len(route) - 1):
            pheromone_matrix[route[i], route[i+1]] += pheromone_delta
            pheromone_matrix[route[i+1], route[i]] += pheromone_delta


        temperature *= cooling_rate

    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
               heuristics_matrix[i, j] /= (distance_matrix[i, j] + 1e-6)

    return heuristics_matrix
