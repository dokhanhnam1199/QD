import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a simulated annealing approach, guided by a cost function considering distance, capacity, and a penalty for exceeding capacity, to iteratively refine routes and estimate edge importance.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    
    def calculate_cost(route):
        total_distance = 0
        current_capacity = capacity
        cost = 0
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            total_distance += distance_matrix[node1, node2]

            if node2 != 0:
                current_capacity -= demands[node2]
            if current_capacity < 0:
                cost += abs(current_capacity) * 10 # Large penalty for exceeding capacity
                current_capacity = capacity  # Reset capacity

        cost += total_distance
        return cost

    def generate_neighbor(route):
        # Swap two random nodes in the route (excluding the depot)
        route_copy = route[:]
        indices = range(1, len(route_copy) - 1)
        if len(indices) < 2:
            return route_copy

        i, j = random.sample(indices, 2)
        route_copy[i], route_copy[j] = route_copy[j], route_copy[i]
        return route_copy
    
    # Initial Solution (Nearest Neighbor)
    initial_route = [0]
    remaining_nodes = set(range(1, n))
    current_node = 0
    current_capacity = capacity
    
    while remaining_nodes:
        nearest_node = None
        min_dist = float('inf')
        for node in remaining_nodes:
            if demands[node] <= current_capacity:
                dist = distance_matrix[current_node, node]
                if dist < min_dist:
                    min_dist = dist
                    nearest_node = node
        if nearest_node is None:
            initial_route.append(0)
            current_capacity = capacity
            current_node = 0
        else:
            initial_route.append(nearest_node)
            current_capacity -= demands[nearest_node]
            current_node = nearest_node
            remaining_nodes.remove(nearest_node)
    initial_route.append(0)
    
    current_route = initial_route
    current_cost = calculate_cost(current_route)
    
    # Simulated Annealing Parameters
    temperature = 1000
    cooling_rate = 0.995
    
    for _ in range(10000): # Number of iterations
        neighbor_route = generate_neighbor(current_route)
        neighbor_cost = calculate_cost(neighbor_route)

        # Acceptance Probability
        if neighbor_cost < current_cost:
            acceptance_prob = 1.0
        else:
            acceptance_prob = np.exp((current_cost - neighbor_cost) / temperature)

        # Accept or Reject
        if random.random() < acceptance_prob:
            current_route = neighbor_route
            current_cost = neighbor_cost

        temperature *= cooling_rate
    
    # Update Heuristics Matrix based on the best route found
    for i in range(len(current_route) - 1):
        node1 = current_route[i]
        node2 = current_route[i+1]
        heuristics_matrix[node1, node2] += 1
        heuristics_matrix[node2, node1] += 1

    # Normalize by Distance
    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]

    return heuristics_matrix
