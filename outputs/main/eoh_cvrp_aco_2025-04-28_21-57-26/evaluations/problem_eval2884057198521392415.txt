import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs solutions by iteratively merging the two closest routes based on depot insertion cost until a single route is formed, then decomposes it into feasible vehicle routes and evaluates edge frequency.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    nodes = list(range(1, n))
    routes = [[i] for i in nodes]
    
    while len(routes) > 1:
        best_i, best_j, best_cost = -1, -1, float('inf')
        
        for i in range(len(routes)):
            for j in range(i + 1, len(routes)):
                cost = distance_matrix[routes[i][-1], 0] + distance_matrix[0, routes[j][0]]
                if cost < best_cost:
                    best_cost = cost
                    best_i, best_j = i, j

        routes[best_i].extend(routes[best_j])
        del routes[best_j]
    
    full_route = routes[0]
    
    vehicle_routes = []
    current_route = [0]
    current_capacity = capacity
    
    for node in full_route:
        if demands[node] <= current_capacity:
            current_route.append(node)
            current_capacity -= demands[node]
        else:
            current_route.append(0)
            vehicle_routes.append(current_route)
            current_route = [0, node]
            current_capacity = capacity - demands[node]
    
    current_route.append(0)
    vehicle_routes.append(current_route)
    
    for route in vehicle_routes:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]

    return heuristics_matrix
