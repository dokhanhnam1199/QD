import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a combination of shortest-distance-first and capacity-aware random sampling to build routes, adjusting edge importance based on route length and capacity utilization.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 500

    for _ in range(num_samples):
        current_node = 0
        route = [0]
        remaining_nodes = set(range(1, n))
        current_capacity = capacity
        total_distance = 0

        while remaining_nodes:
            # Prioritize closer nodes if capacity allows, otherwise choose randomly
            eligible_nodes = [node for node in remaining_nodes if demands[node] <= current_capacity]

            if eligible_nodes:
                # Shortest distance first with stochastic noise
                distances = {node: distance_matrix[current_node, node] for node in eligible_nodes}
                min_dist = min(distances.values())
                best_nodes = [node for node, dist in distances.items() if dist <= (min_dist * 1.2)] #Allow some deviation from optimal
                next_node = random.choice(best_nodes) # Break ties randomly
            else:
                # Return to depot if no nodes can be visited
                next_node = 0

            if next_node != 0:
                route.append(next_node)
                total_distance += distance_matrix[current_node, next_node]
                current_capacity -= demands[next_node]
                remaining_nodes.remove(next_node)

            else:
                route.append(0)
                total_distance += distance_matrix[current_node, 0]
                current_capacity = capacity #Reset capacity

            current_node = next_node
        
        # Complete the final route back to the depot if necessary
        if current_node != 0:
            route.append(0)
            total_distance += distance_matrix[current_node, 0]

        # Update edge weights based on route length and capacity
        route_length_factor = 1 / (total_distance + 1e-6) #Favor shorter routes
        capacity_utilization = sum(demands[node] for node in route if node != 0) / (len(route) * capacity + 1e-6)  # Normalize to penalize overused capacity routes

        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += (route_length_factor + capacity_utilization)
            heuristics_matrix[node2, node1] += (route_length_factor + capacity_utilization)
    
    return heuristics_matrix
