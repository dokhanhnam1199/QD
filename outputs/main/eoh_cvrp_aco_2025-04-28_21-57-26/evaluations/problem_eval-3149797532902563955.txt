import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm prioritizes routes based on saving calculation and demand consideration, constructing routes iteratively by selecting the edge that maximizes a score function combining distance and remaining capacity, then constructing prior indicators.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    
    # Initialize the current route with the depot
    current_route = [0]
    remaining_nodes = set(range(1, n))
    current_capacity = capacity
    
    while remaining_nodes:
        best_node = None
        best_score = -1
        
        for node in remaining_nodes:
            if demands[node] <= current_capacity:
                # Calculate a score based on distance and remaining capacity
                distance = distance_matrix[current_route[-1], node]
                remaining_cap_ratio = demands[node]/current_capacity
                score = (1 / distance) * (1 - remaining_cap_ratio) # Favor shorter distances and smaller demands related to the current remaining capacity
                
                if score > best_score:
                    best_score = score
                    best_node = node
        
        if best_node is not None:
            current_route.append(best_node)
            current_capacity -= demands[best_node]
            remaining_nodes.remove(best_node)
        else:
            # Return to depot if no feasible node is found
            current_route.append(0)
            current_capacity = capacity
            current_route.append(current_route[-2])  # Repeat last node to not disconnect previous edges
    current_route.append(0)
    # Populate the heuristic matrix based on the constructed route
    for i in range(len(current_route) - 1):
        node1 = current_route[i]
        node2 = current_route[i+1]
        heuristics_matrix[node1, node2] = 1
        heuristics_matrix[node2, node1] = 1
    
    # Normalize
    for i in range(n):
        for j in range(n):
             if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]
    
    return heuristics_matrix
