import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines routes by probabilistically accepting or rejecting edge swaps based on a combination of distance reduction and capacity feasibility, building a heuristic matrix from edge frequencies across iterations.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 1000
    temperature = 100.0
    cooling_rate = 0.995

    # Initialize a random solution (routes)
    unvisited = set(range(1, n))
    routes = []
    current_route = [0]
    current_capacity = capacity

    while unvisited:
        next_node = random.choice(list(unvisited))
        if demands[next_node] <= current_capacity:
            current_route.append(next_node)
            current_capacity -= demands[next_node]
            unvisited.remove(next_node)
        else:
            current_route.append(0)
            routes.append(current_route)
            current_route = [0]
            current_capacity = capacity

    if current_route != [0]:
        current_route.append(0)
        routes.append(current_route)

    def calculate_route_distance(route):
        total_distance = 0
        for i in range(len(route) - 1):
            total_distance += distance_matrix[route[i]][route[i+1]]
        return total_distance

    def calculate_solution_distance(routes):
        total_distance = 0
        for route in routes:
            total_distance += calculate_route_distance(route)
        return total_distance

    best_routes = routes[:]
    best_distance = calculate_solution_distance(routes)

    for iteration in range(num_iterations):
        # Choose two random routes
        if len(routes) <= 1:
            continue
        route_index1 = random.randint(0, len(routes) - 1)
        route_index2 = random.randint(0, len(routes) - 1)
        if route_index1 == route_index2:
            continue

        route1 = routes[route_index1]
        route2 = routes[route_index2]
        if len(route1) <= 2 or len(route2) <= 2:
            continue

        # Choose two random edges
        edge_index1 = random.randint(1, len(route1) - 2)
        edge_index2 = random.randint(1, len(route2) - 2)

        # Swap edges
        new_route1 = route1[:edge_index1] + route2[edge_index2:len(route2)-1:-1] + route1[edge_index1+1:]
        new_route2 = route2[:edge_index2] + route1[edge_index1:len(route1)-1:-1] + route2[edge_index2+1:]

        # Check capacity feasibility
        demand1 = sum([demands[node] for node in new_route1 if node != 0])
        demand2 = sum([demands[node] for node in new_route2 if node != 0])

        if demand1 <= capacity and demand2 <= capacity:
            # Calculate the change in distance
            old_distance = calculate_route_distance(route1) + calculate_route_distance(route2)
            new_distance = calculate_route_distance(new_route1) + calculate_route_distance(new_route2)
            delta = new_distance - old_distance

            # Accept the change based on simulated annealing
            if delta < 0 or random.random() < np.exp(-delta / temperature):
                # Update heuristics matrix
                for i in range(len(route1) - 1):
                    heuristics_matrix[route1[i]][route1[i+1]] -=1
                    heuristics_matrix[route1[i+1]][route1[i]] -=1
                for i in range(len(route2) - 1):
                    heuristics_matrix[route2[i]][route2[i+1]] -=1
                    heuristics_matrix[route2[i+1]][route2[i]] -=1
                routes[route_index1] = new_route1
                routes[route_index2] = new_route2
                for i in range(len(new_route1) - 1):
                    heuristics_matrix[new_route1[i]][new_route1[i+1]] +=1
                    heuristics_matrix[new_route1[i+1]][new_route1[i]] +=1
                for i in range(len(new_route2) - 1):
                    heuristics_matrix[new_route2[i]][new_route2[i+1]] +=1
                    heuristics_matrix[new_route2[i+1]][new_route2[i]] +=1
            

        # Cooling
        temperature *= cooling_rate

    for route in routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i]][route[i+1]] += 1
            heuristics_matrix[route[i+1]][route[i]] += 1

    return heuristics_matrix
