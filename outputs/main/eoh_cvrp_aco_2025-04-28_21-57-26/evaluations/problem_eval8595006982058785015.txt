import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs routes using a nearest neighbor approach, iteratively adding the nearest feasible node to the current route, and penalizes edges that violate capacity constraints by reducing their heuristic values.}"""

    n = len(demands)
    heuristics_matrix = np.zeros((n, n))
    
    unvisited_nodes = set(range(1, n))
    routes = []
    
    while unvisited_nodes:
        current_node = random.choice(list(unvisited_nodes))
        route = [current_node]
        current_demand = demands[current_node]
        unvisited_nodes.remove(current_node)
        
        while True:
            nearest_node = -1
            min_distance = float('inf')
            
            for neighbor in unvisited_nodes:
                if distance_matrix[route[-1], neighbor] < min_distance:
                    if current_demand + demands[neighbor] <= capacity:
                        min_distance = distance_matrix[route[-1], neighbor]
                        nearest_node = neighbor
            
            if nearest_node != -1:
                
                for node1 in route:
                  heuristics_matrix[node1, nearest_node] +=1
                  heuristics_matrix[nearest_node, node1] +=1
                
                route.append(nearest_node)
                current_demand += demands[nearest_node]
                unvisited_nodes.remove(nearest_node)
            else:
                break
        
        routes.append(route)

    return heuristics_matrix
