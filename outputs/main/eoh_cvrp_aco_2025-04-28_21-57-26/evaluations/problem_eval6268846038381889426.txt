import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a constructionist approach guided by regret insertion heuristics, iteratively building routes by inserting customers based on a regret criterion that considers the cost of not inserting them optimally.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 50
    
    for _ in range(num_iterations):
        routes = []
        unvisited = set(range(1, n))

        while unvisited:
            best_route = None
            best_regret = -np.inf

            for start_node in list(unvisited):
                current_route = [0, start_node, 0]
                current_capacity = capacity - demands[start_node]
                remaining_unvisited = unvisited - {start_node}
                
                while remaining_unvisited and current_capacity >= min(demands[node] for node in remaining_unvisited):
                    best_insertion_node = None
                    best_insertion_cost = np.inf
                    best_insertion_index = -1
                    
                    for node_to_insert in remaining_unvisited:
                        if demands[node_to_insert] <= current_capacity:
                            for i in range(1, len(current_route)):
                                insertion_cost = distance_matrix[current_route[i-1], node_to_insert] + distance_matrix[node_to_insert, current_route[i]] - distance_matrix[current_route[i-1], current_route[i]]
                                if insertion_cost < best_insertion_cost:
                                    best_insertion_cost = insertion_cost
                                    best_insertion_node = node_to_insert
                                    best_insertion_index = i
                    
                    if best_insertion_node is not None:
                        current_route.insert(best_insertion_index, best_insertion_node)
                        current_capacity -= demands[best_insertion_node]
                        remaining_unvisited.remove(best_insertion_node)
                    else:
                        break
                
                
                route_cost = 0
                for i in range(len(current_route) - 1):
                    route_cost += distance_matrix[current_route[i], current_route[i+1]]

                
                second_best_insertion_cost = np.inf
                for node_to_insert in unvisited:
                    if node_to_insert == start_node:
                        continue
                    temp_best_insertion_cost = np.inf
                    for i in range(1, len(current_route)):
                        insertion_cost = distance_matrix[current_route[i-1], node_to_insert] + distance_matrix[node_to_insert, current_route[i]] - distance_matrix[current_route[i-1], current_route[i]]
                        temp_best_insertion_cost = min(temp_best_insertion_cost, insertion_cost)
                    second_best_insertion_cost = min(second_best_insertion_cost,temp_best_insertion_cost)

                
                regret = second_best_insertion_cost - route_cost

                if regret > best_regret:
                    best_regret = regret
                    best_route = current_route
            
            if best_route is not None:
                routes.append(best_route)
                for node in best_route:
                    if node != 0:
                        unvisited.discard(node)
            else:
                break
        
        for route in routes:
            for i in range(len(route) - 1):
                heuristics_matrix[route[i], route[i+1]] += 1
                heuristics_matrix[route[i+1], route[i]] += 1

    return heuristics_matrix
