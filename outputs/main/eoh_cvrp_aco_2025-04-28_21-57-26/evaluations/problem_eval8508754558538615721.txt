import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs multiple routes by probabilistically selecting the next node based on a combined score of distance and demand, weighted by a temperature parameter that decreases over time, encouraging exploration initially and exploitation later.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_routes = 5  # Number of routes to generate

    for _ in range(num_routes):
        current_route = [0]
        remaining_nodes = set(range(1, n))
        current_capacity = capacity
        temperature = 1.0  # Initial temperature

        while remaining_nodes:
            scores = {}
            for node in remaining_nodes:
                if demands[node] <= current_capacity:
                    distance = distance_matrix[current_route[-1], node]
                    demand_ratio = demands[node] / capacity
                    score = np.exp(((1 / distance) * (1 - demand_ratio)) / temperature)  # Boltzmann distribution
                    scores[node] = score

            if not scores:
                current_route.append(0)
                current_capacity = capacity
                temperature *= 0.95 # Cool down
                continue

            # Probabilistic node selection
            probabilities = [scores[node] for node in scores]
            probabilities /= np.sum(probabilities)
            chosen_node = random.choices(list(scores.keys()), weights=probabilities, k=1)[0]

            current_route.append(chosen_node)
            current_capacity -= demands[chosen_node]
            remaining_nodes.remove(chosen_node)
            temperature *= 0.95 # Cool down

        current_route.append(0)

        for i in range(len(current_route) - 1):
            node1 = current_route[i]
            node2 = current_route[i + 1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    # Normalize and adjust based on distance
    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]

    return heuristics_matrix
