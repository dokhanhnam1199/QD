import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a greedy randomized construction followed by a local search, guided by a cost function considering distance, capacity, and a penalty for exceeding capacity, to iteratively refine routes and estimate edge importance.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)

    def calculate_cost(route):
        total_distance = 0
        current_capacity = capacity
        cost = 0
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            total_distance += distance_matrix[node1, node2]

            if node2 != 0:
                current_capacity -= demands[node2]
            if current_capacity < 0:
                cost += abs(current_capacity) * 10  # Large penalty for exceeding capacity
                current_capacity = capacity  # Reset capacity

        cost += total_distance
        return cost

    def generate_neighbor(route):
        # Swap two random nodes in the route (excluding the depot)
        route_copy = route[:]
        indices = range(1, len(route_copy) - 1)
        if len(indices) < 2:
            return route_copy

        i, j = random.sample(indices, 2)
        route_copy[i], route_copy[j] = route_copy[j], route_copy[i]
        return route_copy

    # Randomized Greedy Construction
    def construct_initial_route():
        initial_route = [0]
        remaining_nodes = set(range(1, n))
        current_node = 0
        current_capacity = capacity

        while remaining_nodes:
            eligible_nodes = [node for node in remaining_nodes if demands[node] <= current_capacity]

            if not eligible_nodes:
                initial_route.append(0)
                current_capacity = capacity
                current_node = 0
                continue
            
            # Randomized selection from eligible nodes
            probabilities = [1 / distance_matrix[current_node, node] for node in eligible_nodes]
            probabilities /= np.sum(probabilities) # Normalize

            nearest_node = random.choices(eligible_nodes, probabilities)[0]

            initial_route.append(nearest_node)
            current_capacity -= demands[nearest_node]
            current_node = nearest_node
            remaining_nodes.remove(nearest_node)
        initial_route.append(0)
        return initial_route

    # Local Search (swap)
    def local_search(route):
        best_route = route[:]
        best_cost = calculate_cost(best_route)
        improved = True

        while improved:
            improved = False
            for i in range(1, len(best_route) - 1):
                for j in range(i + 1, len(best_route) - 1):
                    neighbor = best_route[:]
                    neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
                    neighbor_cost = calculate_cost(neighbor)

                    if neighbor_cost < best_cost:
                        best_route = neighbor
                        best_cost = neighbor_cost
                        improved = True
        return best_route

    # Iterations and Heuristic Matrix Update
    num_iterations = 100
    for _ in range(num_iterations):
        initial_route = construct_initial_route()
        refined_route = local_search(initial_route)

        for i in range(len(refined_route) - 1):
            node1 = refined_route[i]
            node2 = refined_route[i + 1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    # Normalize by Distance
    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]

    return heuristics_matrix
