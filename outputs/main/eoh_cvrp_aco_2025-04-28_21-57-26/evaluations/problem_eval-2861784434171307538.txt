import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines edge importance by simulating route construction with probabilistic node selection based on distance, demand, and global route feasibility, updating edge scores based on route success.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    alpha = 0.7  # Weight for previous heuristic value
    beta = 0.3   # Weight for new route's contribution
    num_iterations = 50
    num_routes_per_iteration = 20

    for iteration in range(num_iterations):
        for _ in range(num_routes_per_iteration):
            current_node = 0
            route = [0]
            remaining_nodes = set(range(1, n))
            current_capacity = capacity
            route_length = 0
            
            while remaining_nodes:
                probabilities = {}
                for node in remaining_nodes:
                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)
                    demand_heuristic = (current_capacity - demands[node]) / capacity if current_capacity >= demands[node] else 0
                    feasibility_heuristic = 1.0  #Initially assume it is feasible to complete route

                    temp_capacity = current_capacity - demands[node]
                    temp_remaining_nodes = remaining_nodes.copy()
                    temp_remaining_nodes.remove(node)
                    
                    remaining_demand = sum([demands[i] for i in temp_remaining_nodes])
                    if remaining_demand > capacity: #Check if remaining demands can be fulfilled by a single vehicle
                      feasibility_heuristic = 0.1 # penalize
                    
                    probabilities[node] = distance_heuristic * (demand_heuristic + 0.05) * feasibility_heuristic

                if not probabilities:
                    break

                total_prob = sum(probabilities.values())
                if total_prob == 0:
                    next_node = remaining_nodes.pop()
                else:
                    normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}
                    next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))

                if current_capacity >= demands[next_node]:
                    route.append(next_node)
                    route_length += distance_matrix[current_node, next_node]
                    current_capacity -= demands[next_node]
                    remaining_nodes.remove(next_node)
                    current_node = next_node
                else:
                    route.append(0)
                    route_length += distance_matrix[current_node,0]
                    current_node = 0
                    current_capacity = capacity
            
            if current_node != 0:
                route.append(0)
                route_length += distance_matrix[current_node,0]

            # Update heuristic matrix based on the route
            if len(route) > 1:
              route_reward = 1 / (route_length + 1e-6)
              for i in range(len(route) - 1):
                  node1 = route[i]
                  node2 = route[i+1]
                  heuristics_matrix[node1, node2] = alpha * heuristics_matrix[node1, node2] + beta * route_reward
                  heuristics_matrix[node2, node1] = alpha * heuristics_matrix[node2, node1] + beta * route_reward

    return heuristics_matrix
