import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm initializes routes with nearest neighbors, merges routes based on savings, and penalizes edges based on capacity violations, accumulating edge usage counts in a heuristic matrix.}"""

    n = len(demands)
    heuristics_matrix = np.zeros((n, n))

    # Initialize routes with nearest neighbors
    routes = []
    unvisited = list(range(1, n))
    while unvisited:
        start_node = random.choice(unvisited)
        current_route = [start_node]
        current_demand = demands[start_node]
        unvisited.remove(start_node)

        while True:
            nearest_neighbor = -1
            min_distance = np.inf
            for neighbor in unvisited:
                if distance_matrix[current_route[-1], neighbor] < min_distance and current_demand + demands[neighbor] <= capacity:
                    min_distance = distance_matrix[current_route[-1], neighbor]
                    nearest_neighbor = neighbor

            if nearest_neighbor != -1:
                current_route.append(nearest_neighbor)
                current_demand += demands[nearest_neighbor]
                unvisited.remove(nearest_neighbor)
            else:
                break
        routes.append(current_route)
    
    # Savings-based route merging
    savings = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i+1, n):
            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings[j, i] = savings[i, j]
    
    num_iterations = 1000
    for _ in range(num_iterations):
        best_savings = -1
        best_i = -1
        best_j = -1
        best_route_i = -1
        best_route_j = -1
        
        for i in range(1, n):
            for j in range(i + 1, n):
                if savings[i, j] > best_savings:
                    route_i_idx = -1
                    route_j_idx = -1
                    for r_idx, route in enumerate(routes):
                        if route and route[0] == i:
                            route_i_idx = r_idx
                        if route and route[-1] == j:
                            route_j_idx = r_idx
                    
                    if route_i_idx != -1 and route_j_idx != -1 and route_i_idx != route_j_idx:
                        best_savings = savings[i, j]
                        best_i = i
                        best_j = j
                        best_route_i = route_i_idx
                        best_route_j = route_j_idx
                        
        if best_savings > 0:
            route_i = routes[best_route_i]
            route_j = routes[best_route_j]
            
            total_demand = sum([demands[node] for node in route_i + route_j])
            
            if total_demand <= capacity:
                for node1 in route_i:
                  for node2 in route_j:
                    heuristics_matrix[node1, node2] +=1
                    heuristics_matrix[node2, node1] +=1
                
                routes[best_route_i] = route_i + route_j
                routes[best_route_j] = []  # Mark route as empty instead of deleting
    return heuristics_matrix
