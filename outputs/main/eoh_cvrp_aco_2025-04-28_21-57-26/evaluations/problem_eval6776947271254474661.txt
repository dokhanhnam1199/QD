import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs multiple solutions using a randomized insertion heuristic guided by a modified Clarke-Wright savings score and aggregates edge usage frequencies.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 100 #Number of iterations to run the heuristic
    
    for _ in range(num_iterations):
        #1. Initialize solution
        unvisited_nodes = set(range(1,n))
        routes = []
        
        #2. Build routes until all nodes are visited
        while unvisited_nodes:
            current_route = [0] #Start from depot
            current_capacity = capacity
            last_node = 0 #Start from depot

            #3. Route Construction
            while True:
                #Calculate Savings for unvisited nodes
                savings = {}
                for node in unvisited_nodes:
                    if demands[node] <= current_capacity:
                         #Modified Clarke-Wright savings formula: incorporate distance and demand
                         savings[node] = distance_matrix[0, node] + distance_matrix[last_node, 0] - distance_matrix[last_node, node] - (demands[node] / capacity) * distance_matrix[0, node]
                
                #Choose next node probabilistically based on savings
                if savings:
                    nodes = list(savings.keys())
                    weights = [savings[node] for node in nodes]
                    # Apply softmax to convert savings to probabilities
                    weights = np.exp(weights - np.max(weights)) / np.sum(np.exp(weights - np.max(weights)))
                    
                    next_node = random.choices(nodes, weights=weights, k=1)[0]
                    
                    #Add selected node to route
                    current_route.append(next_node)
                    current_capacity -= demands[next_node]
                    unvisited_nodes.remove(next_node)
                    last_node = next_node
                else:
                    break #No feasible node can be added
            
            current_route.append(0) #Return to depot
            routes.append(current_route)

        #4. Update Heuristic Matrix based on route edges
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] +=1
                heuristics_matrix[node2, node1] +=1
                
    #5. Normalize heuristic matrix by number of iterations and distance
    for i in range(n):
        for j in range(n):
            heuristics_matrix[i,j] /= (num_iterations * distance_matrix[i, j] if distance_matrix[i, j] > 0 else 1)
                
    return heuristics_matrix
