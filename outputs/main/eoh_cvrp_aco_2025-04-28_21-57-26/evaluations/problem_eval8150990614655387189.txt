import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm employs a savings-based approach, iteratively merging routes until capacity constraints are violated, incorporating a pheromone matrix that guides the merging process and is updated based on solution quality, finally returning a heuristic matrix reflecting the pheromone distribution.}"""
    n = len(demands)
    pheromone_matrix = np.ones_like(distance_matrix)  # Initialize pheromone matrix with ones
    rho = 0.5  # Evaporation rate
    alpha = 1 # Pheromone influence
    beta = 1 # Savings influence
    num_iterations = 100
    
    best_solution = None
    best_cost = float('inf')
    
    for iteration in range(num_iterations):
        # Initialize routes: each customer has its own route to depot
        routes = [[i, 0] for i in range(1, n)]
        available_nodes = set(range(1, n))
        
        
        # Iteratively merge routes based on savings and pheromones
        while len(routes) > 1:
            best_merge = None
            best_savings = -float('inf')
            
            for i in range(len(routes)):
                for j in range(i + 1, len(routes)):
                    
                    route1 = routes[i]
                    route2 = routes[j]
                    
                    #Check capacity constraints
                    total_demand = sum(demands[node] for node in route1[:-1]) + sum(demands[node] for node in route2[:-1])
                    if total_demand > capacity:
                        continue
                    
                    #Calculate savings and pheromone influence for merging
                    savings = distance_matrix[route1[-2], 0] + distance_matrix[route2[-2],0] - distance_matrix[route1[-2], route2[0]]
                    pheromone = pheromone_matrix[route1[-2], route2[0]]
                    
                    #Combine savings and pheromone
                    merge_value = (pheromone**alpha) * (savings**beta)
                    
                    if merge_value > best_savings:
                        best_savings = merge_value
                        best_merge = (i, j)
                        
            #Merge best routes
            if best_merge:
                i, j = best_merge
                new_route = routes[i][:-1] + routes[j] #Combined route without depot at end
                routes[i] = new_route
                del routes[j]
            else:
                break  #No more feasible merges
        
        #Cost calculation
        current_solution = routes[0] if len(routes) == 1 else []
        
        total_cost = 0
        for i in range(len(current_solution) -1 ):
             total_cost += distance_matrix[current_solution[i]][current_solution[i+1]]
        #Compare with the best solution
        if total_cost < best_cost:
            best_cost = total_cost
            best_solution = current_solution
        
        #Pheromone update
        pheromone_matrix *= (1 - rho)
        
        if best_solution:
            for i in range(len(best_solution) - 1):
                pheromone_matrix[best_solution[i], best_solution[i+1]] += 1 / best_cost
                pheromone_matrix[best_solution[i+1], best_solution[i]] += 1 / best_cost
            
    heuristics_matrix = pheromone_matrix
            
    return heuristics_matrix
