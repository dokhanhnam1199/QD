import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a savings-based approach combined with a randomized route construction, prioritizing edges that lead to higher savings while respecting capacity constraints.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    # 1. Calculate Savings
    savings = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings[j, i] = savings[i, j]

    # 2. Randomized Route Construction
    num_routes = 5  # Number of routes to generate
    for _ in range(num_routes):
        current_route = [0]
        current_capacity = capacity
        remaining_nodes = set(range(1, n))

        while remaining_nodes:
            # Select the next node based on savings, with a bias towards higher savings
            eligible_nodes = [node for node in remaining_nodes if demands[node] <= current_capacity]
            
            if not eligible_nodes:
                current_route.append(0)
                current_capacity = capacity
                current_route.append(0) # Return to depot
                current_node = 0
                remaining_nodes = set(range(1, n))
                current_route = [0]
                break
            
            probabilities = [savings[current_route[-1], node] for node in eligible_nodes]

            # Normalize probabilities (add a small constant to avoid zero division)
            sum_probabilities = sum(probabilities)
            if sum_probabilities == 0:
              probabilities = [1/len(eligible_nodes)] * len(eligible_nodes)
            else:
              probabilities = [p / sum_probabilities for p in probabilities]
            

            try:
              next_node = random.choices(eligible_nodes, weights=probabilities, k=1)[0]
            except:
              next_node = random.choice(eligible_nodes)

            current_route.append(next_node)
            current_capacity -= demands[next_node]
            remaining_nodes.remove(next_node)
        
        current_route.append(0)

        # 3. Update Heuristic Matrix
        for i in range(len(current_route) - 1):
            node1 = current_route[i]
            node2 = current_route[i + 1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    # 4. Normalize by distance
    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]

    return heuristics_matrix
