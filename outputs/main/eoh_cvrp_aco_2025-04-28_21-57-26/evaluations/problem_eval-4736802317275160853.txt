import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses an iterative improvement approach based on simulated annealing, probabilistically accepting worse solutions to escape local optima and explore a wider solution space.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    
    # 1. Initialization (Random Solution)
    nodes = list(range(1, n))
    random.shuffle(nodes)
    
    # Create initial solution (routes) respecting capacity
    routes = []
    current_route = [0]
    current_capacity = capacity
    for node in nodes:
        if demands[node] <= current_capacity:
            current_route.append(node)
            current_capacity -= demands[node]
        else:
            current_route.append(0)
            routes.append(current_route)
            current_route = [0, node]
            current_capacity = capacity - demands[node]
    current_route.append(0)
    routes.append(current_route)
    
    # 2. Simulated Annealing
    temperature = 100.0
    cooling_rate = 0.99
    
    def calculate_cost(routes):
        cost = 0
        for route in routes:
            for i in range(len(route) - 1):
                cost += distance_matrix[route[i], route[i+1]]
        return cost
    
    best_routes = routes[:]
    best_cost = calculate_cost(routes)
    
    for _ in range(1000):  # Iteration count
        # Create a neighbor solution by swapping two random nodes in different routes
        new_routes = [route[:] for route in routes] # Deep copy

        #Select two non-depot nodes randomly, one from each different route
        route_indices = list(range(len(new_routes)))
        if len(route_indices) < 2:
             continue # Not enough routes to swap between

        route_index_1, route_index_2 = random.sample(route_indices, 2)
       
        # Ensure at least one non-depot node is in each route
        route1 = [node for node in new_routes[route_index_1] if node != 0]
        route2 = [node for node in new_routes[route_index_2] if node != 0]

        if not route1 or not route2:
            continue #Skip if no non-depot nodes exist in selected routes
        
        node1 = random.choice(route1)
        node2 = random.choice(route2)
            
        #Find the positions of the selected nodes in the routes
        pos1 = new_routes[route_index_1].index(node1)
        pos2 = new_routes[route_index_2].index(node2)

        #Swap the nodes
        new_routes[route_index_1][pos1] = node2
        new_routes[route_index_2][pos2] = node1

        # Check Capacity Constraint and Fix (basic fix - reinsert violations after depot)
        valid = True
        for route in new_routes:
            current_cap = 0
            for node in route:
                if node != 0:
                    current_cap += demands[node]
            if current_cap > capacity:
                valid = False
                break # Invalid solution.

        if not valid:
            continue # Skip if the new route is invalid
        
        new_cost = calculate_cost(new_routes)

        # Acceptance probability
        if new_cost < calculate_cost(routes):
            routes = [route[:] for route in new_routes]
            if new_cost < best_cost:
                best_cost = new_cost
                best_routes = [route[:] for route in new_routes]
        else:
            acceptance_probability = np.exp((calculate_cost(routes) - new_cost) / temperature)
            if random.random() < acceptance_probability:
                routes = [route[:] for route in new_routes]
        
        temperature *= cooling_rate
    
    # 3. Construct Heuristic Matrix based on best solution found
    for route in best_routes:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1
    
    # Normalize heuristic matrix by distance
    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]

    return heuristics_matrix
