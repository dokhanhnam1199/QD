import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines routes using a greedy insertion heuristic guided by pheromone trails and a capacity-aware cost function, periodically updating pheromone levels based on the best-found route.}"""
    n = distance_matrix.shape[0]
    pheromone_matrix = np.ones_like(distance_matrix)
    heuristics_matrix = np.zeros_like(distance_matrix)
    alpha = 1
    beta = 2
    rho = 0.1
    num_iterations = 100
    best_route = None
    best_route_cost = float('inf')

    for iteration in range(num_iterations):
        routes = []
        unvisited_nodes = set(range(1, n))
        while unvisited_nodes:
            current_route = [0]
            current_capacity = capacity
            current_node = 0
            while True:
                best_node = None
                best_cost = float('inf')

                for node in unvisited_nodes:
                    if demands[node] <= current_capacity:
                        pheromone = pheromone_matrix[current_node, node]
                        heuristic = (1 / (distance_matrix[current_node, node] + 1e-6)) ** beta
                        cost = distance_matrix[current_node, node] - (alpha * pheromone * heuristic)

                        if cost < best_cost:
                            best_cost = cost
                            best_node = node

                if best_node is None:
                    current_route.append(0)
                    routes.append(current_route)
                    break

                current_route.append(best_node)
                unvisited_nodes.remove(best_node)
                current_capacity -= demands[best_node]
                current_node = best_node

                if not unvisited_nodes:
                  current_route.append(0)
                  routes.append(current_route)
                  break

        total_distance = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i], route[i+1]]
        
        if total_distance < best_route_cost:
            best_route_cost = total_distance
            best_route = routes

        # Pheromone update based on best route
        delta_pheromone = np.zeros_like(distance_matrix)
        if best_route is not None:
            for route in best_route:
                for i in range(len(route) - 1):
                    delta_pheromone[route[i], route[i+1]] += 1 / best_route_cost
                    delta_pheromone[route[i+1], route[i]] += 1 / best_route_cost

        pheromone_matrix = (1 - rho) * pheromone_matrix + delta_pheromone
    
    heuristics_matrix = pheromone_matrix
    return heuristics_matrix
