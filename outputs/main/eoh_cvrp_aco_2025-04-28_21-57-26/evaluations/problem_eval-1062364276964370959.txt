import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm combines aspects of stochastic sampling and pheromone-based learning by iteratively constructing routes, probabilistically selecting edges based on distance and a learned edge score, and updating the edge score based on the quality and frequency of edge usage in complete feasible routes.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    edge_scores = np.ones_like(distance_matrix)  # Initialize edge scores
    num_iterations = 200
    alpha = 0.1  # Learning rate
    beta = 2 # Distance Influence
    gamma = 0.5 # Demand Influence

    for _ in range(num_iterations):
        routes = []
        unvisited = set(range(1, n))
        current_route = [0]
        current_capacity = capacity
        
        while unvisited:
            probabilities = {}
            current_node = current_route[-1]

            for node in unvisited:
                if current_capacity >= demands[node]:
                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)
                    demand_heuristic = (current_capacity - demands[node]) / capacity if capacity > 0 else 0
                    probabilities[node] = edge_scores[current_node, node] * (distance_heuristic**beta) * (gamma * demand_heuristic + (1-gamma) * 0.1)
                else:
                    probabilities[node] = 0  # Make infeasible nodes impossible to choose
            
            if not any(probabilities.values()):
                current_route.append(0)
                routes.append(current_route)
                current_route = [0]
                current_capacity = capacity
                continue

            total_prob = sum(probabilities.values())
            normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}
            next_node = random.choices(list(normalized_probabilities.keys()), weights=list(normalized_probabilities.values()), k=1)[0]

            current_route.append(next_node)
            current_capacity -= demands[next_node]
            unvisited.remove(next_node)

            if not unvisited and current_route[-1]!=0:
                current_route.append(0)
        routes.append(current_route)
        
        route_length = 0
        for route in routes:
            for i in range(len(route) - 1):
                route_length += distance_matrix[route[i], route[i+1]]

        # Update edge scores based on route
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                edge_scores[node1, node2] += alpha * (1/route_length)  # Reward edges in good routes
                edge_scores[node2, node1] = edge_scores[node1, node2] #Symmetric

    # Construct heuristic matrix based on learned edge scores
    heuristics_matrix = edge_scores

    return heuristics_matrix
