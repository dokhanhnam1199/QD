import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a savings-based approach with a stochastic acceptance criterion to build routes iteratively.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    
    # Calculate savings for all node pairs
    savings = {}
    for i in range(1, n):
        for j in range(i + 1, n):
            savings[(i, j)] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]

    # Sort savings in descending order
    sorted_savings = sorted(savings.items(), key=lambda item: item[1], reverse=True)

    # Initialize routes
    routes = []
    node_route = {i: None for i in range(1, n)}  # Maps each node to its route

    # Iterate through sorted savings and merge routes if feasible
    for (i, j), saving in sorted_savings:
        route_i = node_route.get(i)
        route_j = node_route.get(j)

        # Case 1: Both nodes are unrouted
        if route_i is None and route_j is None:
            if demands[i] + demands[j] <= capacity:
                new_route = [0, i, j, 0]
                routes.append(new_route)
                node_route[i] = new_route
                node_route[j] = new_route
                
        # Case 2: Only node i is unrouted
        elif route_i is None and route_j is not None:
            if route_j[1] == j and sum(demands[node] for node in route_j[1:-1]) + demands[i] <= capacity:
                if random.random() < 0.5: #Stochastic Acceptance
                    route_j.insert(1, i)
                    node_route[i] = route_j
            elif route_j[-2] == j and sum(demands[node] for node in route_j[1:-1]) + demands[i] <= capacity:
                if random.random() < 0.5: #Stochastic Acceptance
                    route_j.insert(-1, i)
                    node_route[i] = route_j

        # Case 3: Only node j is unrouted
        elif route_i is not None and route_j is None:
             if route_i[1] == i and sum(demands[node] for node in route_i[1:-1]) + demands[j] <= capacity:
                if random.random() < 0.5: #Stochastic Acceptance
                    route_i.insert(1, j)
                    node_route[j] = route_i
             elif route_i[-2] == i and sum(demands[node] for node in route_i[1:-1]) + demands[j] <= capacity:
                if random.random() < 0.5: #Stochastic Acceptance
                    route_i.insert(-1, j)
                    node_route[j] = route_i

        # Case 4: Both nodes are in different routes
        elif route_i is not None and route_j is not None and route_i != route_j:
            if route_i[-2] == i and route_j[1] == j and sum(demands[node] for node in route_i[1:-1]) + sum(demands[node] for node in route_j[1:-1]) <= capacity:
                if random.random() < 0.5: #Stochastic Acceptance
                    route_i.pop()
                    route_j.pop(0)
                    merged_route = route_i + route_j
                    routes.remove(route_i)
                    routes.remove(route_j)
                    routes.append(merged_route)
                    for node in merged_route[1:-1]:
                        node_route[node] = merged_route
            elif route_i[1] == i and route_j[-2] == j and sum(demands[node] for node in route_i[1:-1]) + sum(demands[node] for node in route_j[1:-1]) <= capacity:
                if random.random() < 0.5: #Stochastic Acceptance
                    route_i.pop()
                    route_j.pop(0)
                    route_j.reverse()
                    merged_route = route_i + route_j
                    routes.remove(route_i)
                    routes.remove(route_j)
                    routes.append(merged_route)
                    for node in merged_route[1:-1]:
                        node_route[node] = merged_route

    # Create routes for unrouted nodes
    for node, route in node_route.items():
        if route is None:
            routes.append([0, node, 0])

    # Build heuristic matrix
    for route in routes:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1
            
    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]
                
    return heuristics_matrix
