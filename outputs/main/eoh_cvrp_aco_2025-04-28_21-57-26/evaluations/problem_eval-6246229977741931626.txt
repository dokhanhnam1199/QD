import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm combines stochastic sampling with ant colony optimization principles, using pheromone trails and heuristic information to guide route construction and update pheromone levels based on solution quality.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    pheromone_matrix = np.ones_like(distance_matrix)  # Initialize pheromone trails

    num_ants = 100
    alpha = 1  # Pheromone influence
    beta = 2  # Heuristic influence
    rho = 0.1  # Evaporation rate
    Q = 100  # Pheromone deposit constant

    for _ in range(num_ants):
        ant_routes = []
        ant_route = [0]
        remaining_nodes = set(range(1, n))
        current_node = 0
        current_capacity = capacity

        while remaining_nodes:
            probabilities = {}
            for node in remaining_nodes:
                if current_capacity >= demands[node]:
                    eta = 1 / (distance_matrix[current_node, node] + 1e-6)  # Heuristic information
                    tau = pheromone_matrix[current_node, node]  # Pheromone trail
                    probabilities[node] = (tau**alpha) * (eta**beta)

            if not probabilities:
                break

            total_prob = sum(probabilities.values())
            if total_prob == 0:
                next_node = remaining_nodes.pop()
            else:
                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}
                next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))
                
            if current_capacity >= demands[next_node]:
                ant_route.append(next_node)
                current_capacity -= demands[next_node]
                remaining_nodes.remove(next_node)
                heuristics_matrix[current_node, next_node] += 1
                heuristics_matrix[next_node, current_node] += 1
                current_node = next_node
            else:
                ant_route.append(0)
                ant_routes.append(ant_route)
                heuristics_matrix[current_node, 0] += 1
                heuristics_matrix[0, current_node] += 1
                current_node = 0
                current_capacity = capacity
                ant_route = [0]

        if current_node != 0:
            ant_route.append(0)
            ant_routes.append(ant_route)
            heuristics_matrix[current_node, 0] += 1
            heuristics_matrix[0, current_node] += 1

        # Calculate route length (fitness) for pheromone update
        total_distance = 0
        full_route = [node for route in ant_routes for node in route]
        for i in range(len(full_route) - 1):
          total_distance += distance_matrix[full_route[i], full_route[i+1]]

        # Pheromone update (evaporation and deposit)
        for i in range(n):
            for j in range(n):
                pheromone_matrix[i, j] *= (1 - rho) #Evaporation

        for route in ant_routes:
          for i in range(len(route) - 1):
            pheromone_matrix[route[i], route[i+1]] += Q / (total_distance + 1e-6)
            pheromone_matrix[route[i+1], route[i]] += Q / (total_distance + 1e-6)

    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
               heuristics_matrix[i, j] /= (distance_matrix[i, j] + 1e-6)

    return heuristics_matrix
