import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively constructs routes by selecting the nearest feasible node, incorporating a probabilistic element favoring nodes with lower demands relative to remaining capacity, and updates a prior matrix based on these constructed routes.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    
    # Initialize
    remaining_nodes = set(range(1, n))
    
    # Construct routes iteratively
    while remaining_nodes:
        current_route = [0]
        current_capacity = capacity
        current_node = 0

        while True:
            feasible_nodes = [node for node in remaining_nodes if demands[node] <= current_capacity]
            
            if not feasible_nodes:
                break
            
            # Probabilistic node selection based on distance and demand
            probabilities = []
            for node in feasible_nodes:
                distance = distance_matrix[current_node, node]
                demand_ratio = demands[node] / current_capacity
                # Favor closer nodes and smaller demands
                probability = (1 / distance) * (1 - demand_ratio) 
                probabilities.append(probability)
            
            # Normalize probabilities to sum to 1
            total_probability = sum(probabilities)
            if total_probability > 0:  # Ensure that the sum is not zero
                probabilities = [p / total_probability for p in probabilities]
                # Choose a node based on the probabilities
                next_node = random.choices(feasible_nodes, weights=probabilities, k=1)[0]
            else:
                #If all the probabilities are zero, pick a random one
                next_node = random.choice(feasible_nodes)
                
            current_route.append(next_node)
            current_capacity -= demands[next_node]
            remaining_nodes.remove(next_node)
            current_node = next_node

        current_route.append(0)

        # Update heuristic matrix based on the constructed route
        for i in range(len(current_route) - 1):
            node1 = current_route[i]
            node2 = current_route[i+1]
            heuristics_matrix[node1, node2] = 1
            heuristics_matrix[node2, node1] = 1

    # Normalize
    for i in range(n):
        for j in range(n):
             if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]
    
    return heuristics_matrix
