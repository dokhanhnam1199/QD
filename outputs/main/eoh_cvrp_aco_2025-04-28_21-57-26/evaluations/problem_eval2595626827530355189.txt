import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge importance by sampling random routes, evaluating their feasibility and length, and then assigning higher weights to edges that frequently appear in short, feasible routes.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 1000

    for _ in range(num_samples):
        # Generate a random permutation of customers (excluding the depot)
        customer_indices = np.arange(1, n)
        np.random.shuffle(customer_indices)

        # Construct a route based on the permutation
        current_route = [0]  # Start at the depot
        current_load = 0

        for customer in customer_indices:
            if current_load + demands[customer] <= capacity:
                current_route.append(customer)
                current_load += demands[customer]
            else:
                current_route.append(0)  # Return to depot
                current_load = demands[customer]
                current_route.append(customer)
                
                
        current_route.append(0)  # Return to depot

        # Check feasibility (optional, but good practice)
        route_demand = 0
        current_load = 0
        is_feasible = True
        for i in range(len(current_route) - 1):
            if current_route[i] == 0 and current_load > 0:
                if current_load > capacity:
                   is_feasible = False
                   break
                current_load = 0
            customer = current_route[i]
            if customer != 0:
                current_load += demands[customer]

        if current_load > 0 and current_load > capacity:
           is_feasible = False

        if is_feasible:
           route_length = 0
           for i in range(len(current_route)-1):
             route_length += distance_matrix[current_route[i], current_route[i+1]]

           # Update heuristics_matrix based on route length
           #Short routes get more weight
           weight = 1.0 / (route_length + 1e-6) 
           for i in range(len(current_route)-1):
             u = current_route[i]
             v = current_route[i+1]
             heuristics_matrix[u, v] += weight
             heuristics_matrix[v, u] += weight #Symmetry

    return heuristics_matrix
