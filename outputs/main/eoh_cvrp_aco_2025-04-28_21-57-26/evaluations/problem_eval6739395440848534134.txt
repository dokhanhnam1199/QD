import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a pheromone-inspired approach with local search to iteratively refine edge probabilities based on solution quality.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    pheromone_matrix = np.ones_like(distance_matrix)  # Initialize pheromone levels

    num_iterations = 100
    num_ants = 10
    alpha = 1  # Pheromone influence
    beta = 2  # Heuristic influence
    rho = 0.5  # Evaporation rate
    Q = 100  # Pheromone deposit constant

    for iteration in range(num_iterations):
        all_routes = []
        all_route_lengths = []

        for ant in range(num_ants):
            current_node = 0
            route = [0]
            remaining_nodes = set(range(1, n))
            current_capacity = capacity

            while remaining_nodes:
                probabilities = {}
                for node in remaining_nodes:
                    if current_capacity >= demands[node]:
                        distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)
                        probabilities[node] = (pheromone_matrix[current_node, node]**alpha) * (distance_heuristic**beta)

                if not probabilities:
                    break

                total_prob = sum(probabilities.values())
                if total_prob == 0:
                    next_node = remaining_nodes.pop()
                else:
                    normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}
                    next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))

                if current_capacity >= demands[next_node]:
                    route.append(next_node)
                    current_capacity -= demands[next_node]
                    remaining_nodes.remove(next_node)
                    current_node = next_node
                else:
                    route.append(0)
                    current_node = 0
                    current_capacity = capacity

            if current_node != 0:
                route.append(0)
            
            route_length = 0
            for i in range(len(route) - 1):
                route_length += distance_matrix[route[i], route[i+1]]

            all_routes.append(route)
            all_route_lengths.append(route_length)
            
        best_route_index = np.argmin(all_route_lengths)
        best_route = all_routes[best_route_index]
        best_route_length = all_route_lengths[best_route_index]

        # Pheromone update
        pheromone_matrix *= (1 - rho)  # Evaporation

        for i in range(len(best_route) - 1):
            pheromone_matrix[best_route[i], best_route[i+1]] += Q / best_route_length
            pheromone_matrix[best_route[i+1], best_route[i]] += Q / best_route_length
            heuristics_matrix[best_route[i], best_route[i+1]] += 1
            heuristics_matrix[best_route[i+1], best_route[i]] += 1

    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
               heuristics_matrix[i, j] /= (distance_matrix[i, j] + 1e-6)
    return heuristics_matrix
