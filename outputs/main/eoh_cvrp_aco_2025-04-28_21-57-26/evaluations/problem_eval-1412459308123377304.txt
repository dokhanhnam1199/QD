import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm combines stochastic sampling with edge-frequency estimation and a clustering-based edge selection bias to prioritize edges connecting nodes within similar demand clusters.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    edge_frequencies = np.zeros_like(distance_matrix)
    
    num_samples = 500
    num_clusters = 3

    # Cluster nodes based on demand
    from sklearn.cluster import KMeans
    kmeans = KMeans(n_clusters=num_clusters, random_state=0, n_init = 'auto')
    node_clusters = kmeans.fit_predict(demands.reshape(-1, 1))

    for _ in range(num_samples):
        current_node = 0
        route = [0]
        remaining_nodes = set(range(1, n))
        current_capacity = capacity

        while remaining_nodes:
            probabilities = {}
            for node in remaining_nodes:
                if current_capacity >= demands[node]:
                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)
                    
                    # Bias towards edges within the same cluster
                    if node_clusters[current_node] == node_clusters[node]:
                        cluster_bias = 2.0  # Increase probability if nodes are in the same cluster
                    else:
                        cluster_bias = 0.5 # reduce probabilty if nodes are in the diff cluster
                    
                    probabilities[node] = distance_heuristic * cluster_bias

            if not probabilities:
                break

            total_prob = sum(probabilities.values())
            if total_prob == 0:
                next_node = remaining_nodes.pop()
            else:
                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}
                next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))

            if current_capacity >= demands[next_node]:
                route.append(next_node)
                current_capacity -= demands[next_node]
                remaining_nodes.remove(next_node)
                edge_frequencies[current_node, next_node] += 1
                edge_frequencies[next_node, current_node] += 1
                current_node = next_node
            else:
                route.append(0)
                edge_frequencies[current_node, 0] += 1
                edge_frequencies[0, current_node] += 1
                current_node = 0
                current_capacity = capacity
        
        if current_node != 0:
            edge_frequencies[current_node, 0] += 1
            edge_frequencies[0, current_node] += 1

    # Normalize edge frequencies by distance
    for i in range(n):
        for j in range(n):
            if edge_frequencies[i, j] > 0:
                heuristics_matrix[i, j] = edge_frequencies[i, j] / (distance_matrix[i, j] + 1e-6)

    return heuristics_matrix
