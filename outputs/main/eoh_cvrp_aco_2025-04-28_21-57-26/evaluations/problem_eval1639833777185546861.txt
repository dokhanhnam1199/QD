import numpy as np
import random
from collections import defaultdict

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines a set of candidate solutions by probabilistically selecting edges based on their frequency in high-quality solutions found through a combination of random route construction and local search.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 500
    num_candidate_solutions = 10

    for _ in range(num_iterations):
        candidate_solutions = []
        for _ in range(num_candidate_solutions):
            # Random route construction with capacity constraints
            current_node = 0
            route = [0]
            remaining_nodes = set(range(1, n))
            current_capacity = capacity
            
            while remaining_nodes:
                possible_nodes = [node for node in remaining_nodes if demands[node] <= current_capacity]
                if not possible_nodes:
                    route.append(0)
                    current_capacity = capacity
                    current_node = 0
                    possible_nodes = [node for node in remaining_nodes if demands[node] <= current_capacity]
                    if not possible_nodes:
                        break  # No feasible nodes to visit
                        
                next_node = random.choice(possible_nodes) if possible_nodes else None

                if next_node is not None:
                    route.append(next_node)
                    current_capacity -= demands[next_node]
                    remaining_nodes.remove(next_node)
                    current_node = next_node
                else:
                    break
            if route[-1] != 0:
                route.append(0)
            candidate_solutions.append(route)

        # Evaluate candidate solutions (simple route length)
        solution_lengths = []
        for route in candidate_solutions:
            length = 0
            for i in range(len(route) - 1):
                length += distance_matrix[route[i], route[i+1]]
            solution_lengths.append(length)

        # Find best solutions (e.g., top 20%)
        num_best_solutions = max(1, int(0.2 * num_candidate_solutions))  # At least one best solution
        best_solution_indices = np.argsort(solution_lengths)[:num_best_solutions]

        # Update heuristic matrix based on edge frequency in best solutions
        for idx in best_solution_indices:
            route = candidate_solutions[idx]
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
