import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs routes using a randomized greedy approach, biasing towards closer nodes and those that better utilize remaining vehicle capacity, iteratively building solutions and updating edge scores based on their frequency in successful routes.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    edge_counts = np.zeros((n, n))
    num_iterations = 500

    for _ in range(num_iterations):
        current_node = 0
        current_route = [0]
        remaining_nodes = set(range(1, n))
        current_capacity = capacity

        while remaining_nodes:
            possible_nodes = [node for node in remaining_nodes if demands[node] <= current_capacity]
            if not possible_nodes:
                current_route.append(0)
                current_capacity = capacity
                current_node = 0
                possible_nodes = [node for node in remaining_nodes if demands[node] <= current_capacity]
                if not possible_nodes:
                    break  # No feasible nodes, route is stuck

            probabilities = []
            for node in possible_nodes:
                distance_score = 1 / (distance_matrix[current_node, node] + 1e-6)
                capacity_score = (current_capacity - demands[node]) / capacity
                probabilities.append(distance_score * capacity_score)

            if sum(probabilities) == 0:
                next_node = random.choice(list(possible_nodes))
            else:
                probabilities = [p / sum(probabilities) for p in probabilities]
                next_node = random.choices(possible_nodes, probabilities)[0]

            current_route.append(next_node)
            edge_counts[current_node, next_node] += 1
            edge_counts[next_node, current_node] += 1
            current_capacity -= demands[next_node]
            remaining_nodes.remove(next_node)
            current_node = next_node
        if current_node != 0:
            edge_counts[current_node, 0] += 1
            edge_counts[0, current_node] += 1
    
    for i in range(n):
        for j in range(n):
            if edge_counts[i, j] > 0:
                heuristics_matrix[i, j] = edge_counts[i, j] / (distance_matrix[i, j] + 1e-6)

    return heuristics_matrix
