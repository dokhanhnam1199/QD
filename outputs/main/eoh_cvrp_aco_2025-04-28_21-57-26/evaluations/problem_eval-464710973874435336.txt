import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines a heuristic matrix by prioritizing edges that connect nodes with similar demand-to-distance ratios, favoring connections within capacity constraints.}"""
    n = len(demands)
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 50

    # Calculate demand-to-distance ratios for each node (excluding depot)
    demand_distance_ratios = {}
    for i in range(1, n):
        distances_to_node = distance_matrix[i, 1:]
        demand_distance_ratios[i] = demands[i] / np.mean(distances_to_node)

    for _ in range(num_iterations):
        for i in range(n):
            for j in range(n):
                if i == j:
                    continue

                # Prioritize connections between nodes with similar ratios
                ratio_similarity = 1 - abs(demand_distance_ratios.get(i, 0) - demand_distance_ratios.get(j, 0)) / max(demand_distance_ratios.values()) if i !=0 and j!=0 else 0
                
                # Encourage connections with shorter distances and within capacity
                distance_factor = 1 / (distance_matrix[i, j] + 1e-6)

                #Capacity check: penalize edges that would overload the route
                capacity_penalty = 0
                if i!=0 and j!=0:
                  if demands[i] + demands[j] > capacity:
                      capacity_penalty = -1

                heuristics_matrix[i, j] += (ratio_similarity + distance_factor + capacity_penalty)
                
    return heuristics_matrix
