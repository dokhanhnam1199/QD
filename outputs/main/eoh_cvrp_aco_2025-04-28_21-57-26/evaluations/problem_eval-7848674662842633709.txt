import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines a solution by stochastically swapping nodes between routes based on a weighted cost function that considers distance and capacity constraints, favoring swaps that reduce total distance and balance route loads.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 1000

    # Initialize routes randomly
    routes = []
    unassigned_customers = list(range(1, n))
    while unassigned_customers:
        route = []
        current_capacity = 0
        while unassigned_customers:
            customer = random.choice(unassigned_customers)
            if current_capacity + demands[customer] <= capacity:
                route.append(customer)
                current_capacity += demands[customer]
                unassigned_customers.remove(customer)
            else:
                break
        routes.append(route)

    for _ in range(num_iterations):
        # Choose two routes randomly
        if len(routes) < 2:
            continue
        route1_idx, route2_idx = random.sample(range(len(routes)), 2)
        route1 = routes[route1_idx]
        route2 = routes[route2_idx]

        # Choose two nodes randomly from the routes
        if not route1 or not route2:
            continue
        node1_idx = random.randint(0, len(route1) - 1)
        node2_idx = random.randint(0, len(route2) - 1)
        node1 = route1[node1_idx]
        node2 = route2[node2_idx]

        # Calculate the change in cost and capacity if the nodes are swapped
        route1_demand = sum([demands[c] for c in route1])
        route2_demand = sum([demands[c] for c in route2])
        
        new_route1_demand = route1_demand - demands[node1] + demands[node2]
        new_route2_demand = route2_demand - demands[node2] + demands[node1]

        delta_capacity = 0
        if new_route1_demand > capacity or new_route2_demand > capacity:
            delta_capacity = float('inf')
        else:
            delta_capacity = 0

        # Calculate the change in distance
        delta_distance = distance_matrix[0,node2] + distance_matrix[0,node1]

        
        #Accept or reject the swap based on cost change
        if delta_capacity==0:

            # Update the routes and heuristics matrix
            route1[node1_idx] = node2
            route2[node2_idx] = node1
            routes[route1_idx] = route1
            routes[route2_idx] = route2
            
            for i in range(len(route1)):
                for j in range(i+1, len(route1)):
                  heuristics_matrix[route1[i], route1[j]] += 1
                  heuristics_matrix[route1[j], route1[i]] += 1
            
            for i in range(len(route2)):
                for j in range(i+1, len(route2)):
                  heuristics_matrix[route2[i], route2[j]] += 1
                  heuristics_matrix[route2[j], route2[i]] += 1


    return heuristics_matrix
