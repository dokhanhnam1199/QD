import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm refines route construction by incorporating a probabilistic element in the savings heuristic, favoring edges with higher savings but allowing for exploration of less obvious connections, while still employing sweep-based clustering.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    
    # 1. Sweep Clustering
    angles = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])
    nodes_with_angles = sorted(zip(range(1, n), angles), key=lambda x: x[1])
    num_clusters = int(np.sqrt(n))
    clusters = [[] for _ in range(num_clusters)]
    
    cluster_index = 0
    current_cluster_demand = 0
    
    for node_index, angle in nodes_with_angles:
        if current_cluster_demand + demands[node_index] <= capacity:
            clusters[cluster_index].append(node_index)
            current_cluster_demand += demands[node_index]
        else:
            cluster_index = (cluster_index + 1) % num_clusters
            clusters[cluster_index].append(node_index)
            current_cluster_demand = demands[node_index]
    
    # 2. Route Generation (Probabilistic Savings Heuristic)
    cluster_routes = []
    for cluster in clusters:
        if not cluster:
            cluster_routes.append([0,0])
            continue

        edges = []
        for node in cluster:
            edges.append((0, node))
            edges.append((node, 0))

        savings = []
        for i in range(len(cluster)):
            for j in range(i + 1, len(cluster)):
                node1 = cluster[i]
                node2 = cluster[j]
                savings.append((node1, node2, distance_matrix[node1, 0] + distance_matrix[0, node2] - distance_matrix[node1, node2]))

        savings.sort(key=lambda x: x[2], reverse=True)

        route_segments = {node: [node] for node in cluster}

        def merge_routes(node1, node2):
            route1 = route_segments[node1]
            route2 = route_segments[node2]
            
            new_route = route1 + route2
            for node in new_route:
                route_segments[node] = new_route

        current_route = [0]
        route_nodes = set()

        for node1, node2, saving in savings:
            probability = min(1.0, saving / savings[0][2] if savings[0][2] > 0 else 1.0)
            if route_segments[node1] != route_segments[node2] and random.random() < probability:
                current_route.append(node1)
                current_route.append(node2)
                merge_routes(node1, node2)
                route_nodes.add(node1)
                route_nodes.add(node2)

        unvisited = list(set(cluster) - route_nodes)

        for node in unvisited:
          current_route.append(node)
        
        if not unvisited and len(route_nodes) == 0 and len(cluster) > 0:
          current_route = [0] + cluster
        
        current_route = [0]
        current_node = 0
        remaining_nodes = set(cluster)
        final_route = [0]

        while remaining_nodes:
            nearest_node = None
            min_dist = float('inf')

            for node in remaining_nodes:
                dist = distance_matrix[current_node, node]
                if dist < min_dist:
                    min_dist = dist
                    nearest_node = node
            final_route.append(nearest_node)
            remaining_nodes.remove(nearest_node)
            current_node = nearest_node

        final_route.append(0)

        cluster_routes.append(final_route)
    

    # 3. Combine Routes and Construct Heuristic Matrix
    for route in cluster_routes:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1
    
    # Normalize heuristic matrix by distance
    for i in range(n):
        for j in range(n):
            if heuristics_matrix[i, j] > 0:
                heuristics_matrix[i, j] /= distance_matrix[i, j]
    
    return heuristics_matrix
