[
     {
          "algorithm": "This algorithm combines stochastic sampling with adaptive pheromone-inspired edge selection and reinforcement learning to estimate edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    pheromone_matrix = np.ones_like(distance_matrix)  # Initialize pheromone trails\n\n    num_samples = 500\n    learning_rate = 0.1\n    discount_factor = 0.9\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n        total_distance = 0\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)\n                    demand_heuristic = (current_capacity - demands[node]) / capacity\n                    probabilities[node] = distance_heuristic * (demand_heuristic + 0.1) * pheromone_matrix[current_node, node]\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm combines stochastic sampling with adaptive pheromone-inspired edge selection and reinforcement learning to estimate edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    pheromone_matrix = np.ones_like(distance_matrix)  # Initialize pheromone trails\n\n    num_samples = 500\n    learning_rate = 0.1\n    discount_factor = 0.9\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n        total_distance = 0\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)\n                    demand_heuristic = (current_capacity - demands[node]) / capacity\n                    probabilities[node] = distance_heuristic * (demand_heuristic + 0.1) * pheromone_matrix[current_node, node]\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}\n                next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))\n                \n            if current_capacity >= demands[next_node]:\n                route.append(next_node)\n                total_distance += distance_matrix[current_node, next_node]\n                current_capacity -= demands[next_node]\n                remaining_nodes.remove(next_node)\n                heuristics_matrix[current_node, next_node] += 1\n                heuristics_matrix[next_node, current_node] += 1\n                \n                # Update pheromone trail (reinforcement learning)\n                pheromone_matrix[current_node, next_node] = (1 - learning_rate) * pheromone_matrix[current_node, next_node] + learning_rate * (1 / (distance_matrix[current_node, next_node] + 1e-6))\n                pheromone_matrix[next_node, current_node] = (1 - learning_rate) * pheromone_matrix[next_node, current_node] + learning_rate * (1 / (distance_matrix[next_node, current_node] + 1e-6))\n                \n                current_node = next_node\n            else:\n                route.append(0)\n                total_distance += distance_matrix[current_node, 0]\n                heuristics_matrix[current_node, 0] += 1\n                heuristics_matrix[0, current_node] += 1\n\n                # Update pheromone trail (negative reward for returning to depot)\n                pheromone_matrix[current_node, 0] = (1 - learning_rate) * pheromone_matrix[current_node, 0]\n                pheromone_matrix[0, current_node] = (1 - learning_rate) * pheromone_matrix[0, current_node]\n                \n                current_node = 0\n                current_capacity = capacity\n        \n        if current_node != 0:\n            total_distance += distance_matrix[current_node, 0]\n            heuristics_matrix[current_node, 0] += 1\n            heuristics_matrix[0, current_node] += 1\n\n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n               heuristics_matrix[i, j] /= (distance_matrix[i, j] + 1e-6)\n            \n    return heuristics_matrix",
          "objective": 14.36769,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines stochastic sampling with adaptive weight adjustment and a modified score function based on edge usage and solution quality to estimate edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    edge_weights = np.ones_like(distance_matrix)  # Initialize edge weights\n\n    num_samples = 500\n    alpha = 0.7  # Weight decay factor\n    beta = 0.3  # Reward increment factor\n    gamma = 0.5 # Demand weight factor\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)\n                    demand_heuristic = (current_capacity - demands[node]) / capacity\n                    # Modified Score function\n                    probabilities[node] = distance_heuristic * (gamma * demand_heuristic + (1-gamma) * 0.1) * edge_weights[current_node, node] #Consider weight\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm combines stochastic sampling with adaptive weight adjustment and a modified score function based on edge usage and solution quality to estimate edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    edge_weights = np.ones_like(distance_matrix)  # Initialize edge weights\n\n    num_samples = 500\n    alpha = 0.7  # Weight decay factor\n    beta = 0.3  # Reward increment factor\n    gamma = 0.5 # Demand weight factor\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)\n                    demand_heuristic = (current_capacity - demands[node]) / capacity\n                    # Modified Score function\n                    probabilities[node] = distance_heuristic * (gamma * demand_heuristic + (1-gamma) * 0.1) * edge_weights[current_node, node] #Consider weight\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}\n                next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))\n                \n            if current_capacity >= demands[next_node]:\n                route.append(next_node)\n                current_capacity -= demands[next_node]\n                remaining_nodes.remove(next_node)\n                heuristics_matrix[current_node, next_node] += 1\n                heuristics_matrix[next_node, current_node] += 1\n                \n                # Reward the selected edge\n                edge_weights[current_node, next_node] += beta\n                edge_weights[next_node, current_node] += beta\n                \n                current_node = next_node\n            else:\n                route.append(0)\n                heuristics_matrix[current_node, 0] += 1\n                heuristics_matrix[0, current_node] += 1\n\n                # Penalize returning to depot\n                edge_weights[current_node, 0] *= alpha\n                edge_weights[0, current_node] *= alpha\n                \n                current_node = 0\n                current_capacity = capacity\n                \n        if current_node != 0:\n            heuristics_matrix[current_node, 0] += 1\n            heuristics_matrix[0, current_node] += 1\n    \n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n               heuristics_matrix[i, j] /= (distance_matrix[i, j] + 1e-6)\n            \n    return heuristics_matrix",
          "objective": 14.56597,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines stochastic sampling with adaptive weight adjustment based on edge usage and solution quality to estimate edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    edge_weights = np.ones_like(distance_matrix)  # Initialize edge weights\n\n    num_samples = 500\n    alpha = 0.8  # Weight decay factor\n    beta = 0.2  # Reward increment factor\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)\n                    demand_heuristic = (current_capacity - demands[node]) / capacity\n                    probabilities[node] = distance_heuristic * (demand_heuristic + 0.1) * edge_weights[current_node, node] #Consider weight\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm combines stochastic sampling with adaptive weight adjustment based on edge usage and solution quality to estimate edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    edge_weights = np.ones_like(distance_matrix)  # Initialize edge weights\n\n    num_samples = 500\n    alpha = 0.8  # Weight decay factor\n    beta = 0.2  # Reward increment factor\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)\n                    demand_heuristic = (current_capacity - demands[node]) / capacity\n                    probabilities[node] = distance_heuristic * (demand_heuristic + 0.1) * edge_weights[current_node, node] #Consider weight\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}\n                next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))\n                \n            if current_capacity >= demands[next_node]:\n                route.append(next_node)\n                current_capacity -= demands[next_node]\n                remaining_nodes.remove(next_node)\n                heuristics_matrix[current_node, next_node] += 1\n                heuristics_matrix[next_node, current_node] += 1\n                \n                # Reward the selected edge\n                edge_weights[current_node, next_node] += beta\n                edge_weights[next_node, current_node] += beta\n                \n                current_node = next_node\n            else:\n                route.append(0)\n                heuristics_matrix[current_node, 0] += 1\n                heuristics_matrix[0, current_node] += 1\n\n                # Penalize returning to depot\n                edge_weights[current_node, 0] *= alpha\n                edge_weights[0, current_node] *= alpha\n                \n                current_node = 0\n                current_capacity = capacity\n                \n        if current_node != 0:\n            heuristics_matrix[current_node, 0] += 1\n            heuristics_matrix[0, current_node] += 1\n    \n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n               heuristics_matrix[i, j] /= (distance_matrix[i, j] + 1e-6)\n            \n    return heuristics_matrix",
          "objective": 15.23521,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively constructs solutions by greedily adding the best edge based on a pheromone matrix (initialized with inverse distances) and demand feasibility, then updates the pheromone matrix based on the best solution found so far.}\"\"\"\n    n = len(demands)\n    pheromone_matrix = 1 / (distance_matrix + np.eye(n)) # Initialize pheromone with inverse distances\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    alpha = 1  # Pheromone influence\n    beta = 2   # Distance influence\n    rho = 0.5   # Evaporation rate\n    num_iterations = 100\n\n    best_solution = None\n    best_cost = float('inf')\n\n    for iteration in range(num_iterations):\n        routes = []\n        unvisited = set(range(1, n))\n        current_route = [0]\n        current_load = 0\n\n        while unvisited:\n            # Choose the next node based on pheromone, distance, and capacity\n            probabilities = {}\n            for node in unvisited:\n                if current_load + demands[node] <= capacity:\n                    pheromone = pheromone_matrix[current_route[-1], node]\n                    distance = distance_matrix[current_route[-1], node]\n                    probabilities[node] = (pheromone**alpha) / (distance**beta)\n                else:\n                    probabilities[node] = 0 #Make infeasible nodes impossible to choose\n\n            if not any(probabilities.values()): #no feasible node\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0]\n                current_load = 0\n                continue\n\n            total_prob = sum(probabilities.values())\n            normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm iteratively constructs solutions by greedily adding the best edge based on a pheromone matrix (initialized with inverse distances) and demand feasibility, then updates the pheromone matrix based on the best solution found so far.}\"\"\"\n    n = len(demands)\n    pheromone_matrix = 1 / (distance_matrix + np.eye(n)) # Initialize pheromone with inverse distances\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    alpha = 1  # Pheromone influence\n    beta = 2   # Distance influence\n    rho = 0.5   # Evaporation rate\n    num_iterations = 100\n\n    best_solution = None\n    best_cost = float('inf')\n\n    for iteration in range(num_iterations):\n        routes = []\n        unvisited = set(range(1, n))\n        current_route = [0]\n        current_load = 0\n\n        while unvisited:\n            # Choose the next node based on pheromone, distance, and capacity\n            probabilities = {}\n            for node in unvisited:\n                if current_load + demands[node] <= capacity:\n                    pheromone = pheromone_matrix[current_route[-1], node]\n                    distance = distance_matrix[current_route[-1], node]\n                    probabilities[node] = (pheromone**alpha) / (distance**beta)\n                else:\n                    probabilities[node] = 0 #Make infeasible nodes impossible to choose\n\n            if not any(probabilities.values()): #no feasible node\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0]\n                current_load = 0\n                continue\n\n            total_prob = sum(probabilities.values())\n            normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}\n            next_node = random.choices(list(normalized_probabilities.keys()), weights=list(normalized_probabilities.values()), k=1)[0]\n\n            current_route.append(next_node)\n            current_load += demands[next_node]\n            unvisited.remove(next_node)\n\n            if not unvisited and current_route[-1]!=0:\n                current_route.append(0) #Return to depot\n\n        routes.append(current_route)\n\n        # Calculate cost of current solution\n        total_cost = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_cost += distance_matrix[route[i]][route[i+1]]\n        \n        # Update best solution\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_solution = routes\n\n        # Update pheromone matrix\n        pheromone_matrix *= (1 - rho)  # Evaporation\n\n        # Deposit pheromone on best solution\n        if best_solution:\n            for route in best_solution:\n                for i in range(len(route) - 1):\n                    pheromone_matrix[route[i], route[i+1]] += (1 / best_cost)\n                    pheromone_matrix[route[i+1], route[i]] += (1 / best_cost)\n                    \n    # Construct the heuristic matrix based on final pheromone values\n    heuristics_matrix = pheromone_matrix\n    \n    return heuristics_matrix",
          "objective": 15.54254,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines stochastic sampling with adaptive weight adjustment based on edge usage and solution quality to estimate edge importance using a modified score function that prioritizes edges connecting nodes with similar demand levels.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    edge_weights = np.ones_like(distance_matrix)  # Initialize edge weights\n\n    num_samples = 500\n    alpha = 0.8  # Weight decay factor\n    beta = 0.2  # Reward increment factor\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)\n                    demand_similarity = 1 - abs(demands[current_node] - demands[node]) / capacity  #Prioritize edges connecting nodes with similar demand\n                    probabilities[node] = distance_heuristic * (demand_similarity + 0.1) * edge_weights[current_node, node] #Consider weight\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm combines stochastic sampling with adaptive weight adjustment based on edge usage and solution quality to estimate edge importance using a modified score function that prioritizes edges connecting nodes with similar demand levels.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    edge_weights = np.ones_like(distance_matrix)  # Initialize edge weights\n\n    num_samples = 500\n    alpha = 0.8  # Weight decay factor\n    beta = 0.2  # Reward increment factor\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)\n                    demand_similarity = 1 - abs(demands[current_node] - demands[node]) / capacity  #Prioritize edges connecting nodes with similar demand\n                    probabilities[node] = distance_heuristic * (demand_similarity + 0.1) * edge_weights[current_node, node] #Consider weight\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}\n                next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))\n                \n            if current_capacity >= demands[next_node]:\n                route.append(next_node)\n                current_capacity -= demands[next_node]\n                remaining_nodes.remove(next_node)\n                heuristics_matrix[current_node, next_node] += 1\n                heuristics_matrix[next_node, current_node] += 1\n                \n                # Reward the selected edge\n                edge_weights[current_node, next_node] += beta\n                edge_weights[next_node, current_node] += beta\n                \n                current_node = next_node\n            else:\n                route.append(0)\n                heuristics_matrix[current_node, 0] += 1\n                heuristics_matrix[0, current_node] += 1\n\n                # Penalize returning to depot\n                edge_weights[current_node, 0] *= alpha\n                edge_weights[0, current_node] *= alpha\n                \n                current_node = 0\n                current_capacity = capacity\n                \n        if current_node != 0:\n            heuristics_matrix[current_node, 0] += 1\n            heuristics_matrix[0, current_node] += 1\n    \n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n               heuristics_matrix[i, j] /= (distance_matrix[i, j] + 1e-6)\n            \n    return heuristics_matrix",
          "objective": 15.63514,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs routes using a savings-based approach, iteratively merging routes based on the savings gained by connecting their end nodes, and penalizes edges that violate capacity constraints by reducing their heuristic values.}\"\"\"\n\n    n = len(demands)\n    heuristics_matrix = np.zeros((n, n))\n    \n    # Initialize savings matrix\n    savings = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i+1, n):\n            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings[j, i] = savings[i, j]  # Savings are symmetric\n\n    # Initialize individual routes for each customer\n    routes = [[i] for i in range(1, n)]\n    route_demands = {i: demands[i] for i in range(1, n)",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm constructs routes using a savings-based approach, iteratively merging routes based on the savings gained by connecting their end nodes, and penalizes edges that violate capacity constraints by reducing their heuristic values.}\"\"\"\n\n    n = len(demands)\n    heuristics_matrix = np.zeros((n, n))\n    \n    # Initialize savings matrix\n    savings = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i+1, n):\n            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings[j, i] = savings[i, j]  # Savings are symmetric\n\n    # Initialize individual routes for each customer\n    routes = [[i] for i in range(1, n)]\n    route_demands = {i: demands[i] for i in range(1, n)}\n    \n    num_iterations = 1000\n    for _ in range(num_iterations):\n        # Find the best savings\n        best_savings = -1\n        best_i = -1\n        best_j = -1\n\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                if savings[i, j] > best_savings:\n                    # Check if i and j are end nodes of different routes\n                    route_i = None\n                    route_j = None\n                    for r_idx, route in enumerate(routes):\n                        if route[0] == i:\n                            route_i = r_idx\n                        if route[-1] == j:\n                            route_j = r_idx\n                    \n                    if route_i is not None and route_j is not None and route_i != route_j:\n                        best_savings = savings[i, j]\n                        best_i = i\n                        best_j = j\n                        best_route_i = route_i\n                        best_route_j = route_j\n        # Merge routes if beneficial and feasible\n        if best_savings > 0:\n            \n            route_i = routes[best_route_i]\n            route_j = routes[best_route_j]\n            \n            total_demand = sum([demands[node] for node in route_i + route_j])\n            \n            if total_demand <= capacity:\n                \n                \n                for node1 in route_i:\n                  for node2 in route_j:\n                    heuristics_matrix[node1, node2] +=1\n                    heuristics_matrix[node2, node1] +=1\n                # Merge the routes\n                routes[best_route_i] = route_i + route_j\n                del routes[best_route_j]\n\n    return heuristics_matrix",
          "objective": 15.64753,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random routes satisfying capacity constraints, and aggregates edge frequencies to produce a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm generates multiple random routes satisfying capacity constraints, and aggregates edge frequencies to produce a heuristic matrix.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 100\n\n    for _ in range(num_samples):\n        unvisited = set(range(1, n))\n        routes = []\n        current_route = [0]\n        current_capacity = capacity\n\n        while unvisited:\n            next_node = None\n            best_score = float('inf')\n            \n            possible_nodes = list(unvisited)\n            np.random.shuffle(possible_nodes) # Randomize search\n            \n            for node in possible_nodes:\n                if demands[node] <= current_capacity:\n                    score = distance_matrix[current_route[-1]][node] \n                    if score < best_score:\n                        best_score = score\n                        next_node = node\n\n            if next_node is not None:\n                current_route.append(next_node)\n                current_capacity -= demands[next_node]\n                unvisited.remove(next_node)\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0]\n                current_capacity = capacity\n\n        if current_route != [0]:\n             current_route.append(0)\n             routes.append(current_route)\n            \n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1][node2] += 1\n                heuristics_matrix[node2][node1] += 1\n\n    return heuristics_matrix",
          "objective": 15.79641,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by iteratively building routes using a regret-based insertion heuristic, favoring edges that lead to lower overall route costs and penalizing edges that result in high-cost insertions.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_iterations = 500\n    \n    for _ in range(num_iterations):\n        # Initialize a route with the depot\n        unvisited_nodes = list(range(1, n))\n        current_route = [0]\n        current_load = 0\n        \n        while unvisited_nodes:\n            # Calculate insertion cost for each unvisited node\n            insertion_costs = {",
          "code": "import numpy as np\nimport random\nfrom collections import defaultdict\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs a heuristic matrix by iteratively building routes using a regret-based insertion heuristic, favoring edges that lead to lower overall route costs and penalizing edges that result in high-cost insertions.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_iterations = 500\n    \n    for _ in range(num_iterations):\n        # Initialize a route with the depot\n        unvisited_nodes = list(range(1, n))\n        current_route = [0]\n        current_load = 0\n        \n        while unvisited_nodes:\n            # Calculate insertion cost for each unvisited node\n            insertion_costs = {}\n            for node in unvisited_nodes:\n                best_insertion_cost = float('inf')\n                best_insertion_position = -1\n                \n                for i in range(1, len(current_route)):\n                    temp_route = current_route[:]\n                    temp_route.insert(i, node)\n                    temp_load = current_load + demands[node]\n                    \n                    if temp_load <= capacity:\n                        cost = distance_matrix[temp_route[i-1]][temp_route[i]] + distance_matrix[temp_route[i]][temp_route[i+1]] - distance_matrix[temp_route[i-1]][temp_route[i+1]]\n                        if cost < best_insertion_cost:\n                            best_insertion_cost = cost\n                            best_insertion_position = i\n                \n                #Cost to return to depot if this is the last node to be inserted\n                temp_route = current_route[:]\n                temp_route.append(node)\n                temp_load = current_load + demands[node]\n                if temp_load <= capacity:\n                    cost = distance_matrix[temp_route[-2]][temp_route[-1]] + distance_matrix[temp_route[-1]][0]\n                    if cost < best_insertion_cost:\n                        best_insertion_cost = cost\n                        best_insertion_position = len(current_route)\n                    \n                if best_insertion_cost != float('inf'):\n                    insertion_costs[node] = (best_insertion_cost, best_insertion_position)\n            \n            if not insertion_costs: #No possible insertion due to capacity\n                current_route.append(0)\n                current_load = 0\n                if len(current_route) > 1:\n                    for i in range(len(current_route) - 1):\n                        node1 = current_route[i]\n                        node2 = current_route[i+1]\n                        heuristics_matrix[node1, node2] = 1\n                        heuristics_matrix[node2, node1] = 1\n                current_route = [0]\n                continue # Start a new route\n            \n            # Regret-based selection\n            if len(insertion_costs) > 1:\n                sorted_costs = sorted(insertion_costs.items(), key=lambda item: item[1][0])\n                best_node, (best_cost, best_position) = sorted_costs[0]\n                second_best_cost = sorted_costs[1][1][0]\n                regret = second_best_cost - best_cost\n                \n                #Favoring edges that lead to lower overall route costs and penalizing edges that result in high-cost insertions.\n                \n                \n                # Select node with lowest cost adjusted by regret\n                selected_node = best_node                \n                best_insertion_cost, best_insertion_position = insertion_costs[selected_node]\n            else:\n                selected_node, (best_insertion_cost, best_insertion_position) = list(insertion_costs.items())[0]\n                \n            # Insert the selected node\n            if best_insertion_position == len(current_route):\n                current_route.append(selected_node)\n                current_load += demands[selected_node]\n            else:\n                current_route.insert(best_insertion_position, selected_node)\n                current_load += demands[selected_node]\n            unvisited_nodes.remove(selected_node)\n            \n        # Close the route\n        current_route.append(0)\n        \n        # Update heuristic matrix\n        for i in range(len(current_route) - 1):\n            node1 = current_route[i]\n            node2 = current_route[i+1]\n            heuristics_matrix[node1, node2] = 1\n            heuristics_matrix[node2, node1] = 1\n\n    return heuristics_matrix",
          "objective": 15.94559,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random routes satisfying capacity constraints, and aggregates edge frequencies using a score function that combines distance and demand.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm generates multiple random routes satisfying capacity constraints, and aggregates edge frequencies using a score function that combines distance and demand.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 100\n\n    for _ in range(num_samples):\n        unvisited = set(range(1, n))\n        routes = []\n        current_route = [0]\n        current_capacity = capacity\n\n        while unvisited:\n            next_node = None\n            best_score = float('inf')\n            \n            possible_nodes = list(unvisited)\n            np.random.shuffle(possible_nodes) # Randomize search\n            \n            for node in possible_nodes:\n                if demands[node] <= current_capacity:\n                    score = distance_matrix[current_route[-1]][node] + demands[node]/capacity #combining distance and demand\n                    if score < best_score:\n                        best_score = score\n                        next_node = node\n\n            if next_node is not None:\n                current_route.append(next_node)\n                current_capacity -= demands[next_node]\n                unvisited.remove(next_node)\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0]\n                current_capacity = capacity\n\n        if current_route != [0]:\n             current_route.append(0)\n             routes.append(current_route)\n            \n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1][node2] += 1\n                heuristics_matrix[node2][node1] += 1\n\n    return heuristics_matrix",
          "objective": 15.95317,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively refines routes using a greedy insertion heuristic guided by pheromone trails and a capacity-aware cost function, periodically updating pheromone levels based on the best-found route.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm iteratively refines routes using a greedy insertion heuristic guided by pheromone trails and a capacity-aware cost function, periodically updating pheromone levels based on the best-found route.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    alpha = 1\n    beta = 2\n    rho = 0.1\n    num_iterations = 100\n    best_route = None\n    best_route_cost = float('inf')\n\n    for iteration in range(num_iterations):\n        routes = []\n        unvisited_nodes = set(range(1, n))\n        while unvisited_nodes:\n            current_route = [0]\n            current_capacity = capacity\n            current_node = 0\n            while True:\n                best_node = None\n                best_cost = float('inf')\n\n                for node in unvisited_nodes:\n                    if demands[node] <= current_capacity:\n                        pheromone = pheromone_matrix[current_node, node]\n                        heuristic = (1 / (distance_matrix[current_node, node] + 1e-6)) ** beta\n                        cost = distance_matrix[current_node, node] - (alpha * pheromone * heuristic)\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_node = node\n\n                if best_node is None:\n                    current_route.append(0)\n                    routes.append(current_route)\n                    break\n\n                current_route.append(best_node)\n                unvisited_nodes.remove(best_node)\n                current_capacity -= demands[best_node]\n                current_node = best_node\n\n                if not unvisited_nodes:\n                  current_route.append(0)\n                  routes.append(current_route)\n                  break\n\n        total_distance = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_distance += distance_matrix[route[i], route[i+1]]\n        \n        if total_distance < best_route_cost:\n            best_route_cost = total_distance\n            best_route = routes\n\n        # Pheromone update based on best route\n        delta_pheromone = np.zeros_like(distance_matrix)\n        if best_route is not None:\n            for route in best_route:\n                for i in range(len(route) - 1):\n                    delta_pheromone[route[i], route[i+1]] += 1 / best_route_cost\n                    delta_pheromone[route[i+1], route[i]] += 1 / best_route_cost\n\n        pheromone_matrix = (1 - rho) * pheromone_matrix + delta_pheromone\n    \n    heuristics_matrix = pheromone_matrix\n    return heuristics_matrix",
          "objective": 15.96855,
          "other_inf": null
     }
]