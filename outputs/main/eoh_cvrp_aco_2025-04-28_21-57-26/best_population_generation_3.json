{
     "algorithm": "This algorithm uses a sweep-based clustering approach followed by an improvement heuristic for routing within each cluster and combines the routes, incorporating a penalty for capacity violations during cluster construction.",
     "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm uses a sweep-based clustering approach followed by an improvement heuristic for routing within each cluster and combines the routes, incorporating a penalty for capacity violations during cluster construction.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    \n    # 1. Sweep-based Clustering\n    angles = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n    nodes_by_angle = sorted(range(1, n), key=lambda i: angles[i-1])\n    \n    clusters = []\n    current_cluster = []\n    current_demand = 0\n    \n    for node in nodes_by_angle:\n        if current_demand + demands[node] <= capacity:\n            current_cluster.append(node)\n            current_demand += demands[node]\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n            current_demand = demands[node]\n    clusters.append(current_cluster)\n    \n    # 2. Route Generation within Clusters (Nearest Neighbor + 2-opt Improvement)\n    cluster_routes = []\n    for cluster in clusters:\n        if not cluster:\n            cluster_routes.append([0,0])\n            continue\n            \n        # Nearest Neighbor Initial Route\n        current_node = 0\n        current_route = [0]\n        remaining_nodes = set(cluster)\n        \n        while remaining_nodes:\n            nearest_node = None\n            min_dist = float('inf')\n            \n            for node in remaining_nodes:\n                dist = distance_matrix[current_node, node]\n                if dist < min_dist:\n                    min_dist = dist\n                    nearest_node = node\n            \n            current_route.append(nearest_node)\n            current_node = nearest_node\n            remaining_nodes.remove(nearest_node)\n        \n        current_route.append(0)\n        \n        # 2-opt Improvement\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, len(current_route) - 2):\n                for k in range(i + 1, len(current_route) - 1):\n                    node_i = current_route[i]\n                    node_ip1 = current_route[i+1]\n                    node_k = current_route[k]\n                    node_kp1 = current_route[k+1]\n                    \n                    if distance_matrix[node_i, node_ip1] + distance_matrix[node_k, node_kp1] > distance_matrix[node_i, node_k] + distance_matrix[node_ip1, node_kp1]:\n                        current_route[i+1:k+1] = reversed(current_route[i+1:k+1])\n                        improved = True\n        \n        cluster_routes.append(current_route)\n    \n    # 3. Combine Routes and Construct Heuristic Matrix\n    for route in cluster_routes:\n        for i in range(len(route) - 1):\n            node1 = route[i]\n            node2 = route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n    \n    # Normalize heuristic matrix by distance\n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j]\n    \n    return heuristics_matrix",
     "objective": 10.31232,
     "other_inf": null
}