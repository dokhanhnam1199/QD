[
     {
          "algorithm": "This algorithm employs a sweep-based clustering approach, assigning nodes to clusters based on their angular position relative to the depot, followed by route optimization within each cluster using a savings heuristic.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    \n    # 1. Sweep Clustering\n    angles = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n    nodes_with_angles = sorted(zip(range(1, n), angles), key=lambda x: x[1])\n    num_clusters = int(np.sqrt(n))\n    clusters = [[] for _ in range(num_clusters)]\n    \n    cluster_index = 0\n    current_cluster_demand = 0\n    \n    for node_index, angle in nodes_with_angles:\n        if current_cluster_demand + demands[node_index] <= capacity:\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand += demands[node_index]\n        else:\n            cluster_index = (cluster_index + 1) % num_clusters\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand = demands[node_index]\n    \n    # 2. Route Generation (Savings Heuristic)\n    cluster_routes = []\n    for cluster in clusters:\n        if not cluster:\n            cluster_routes.append([0,0])\n            continue\n\n        edges = []\n        for node in cluster:\n            edges.append((0, node))\n            edges.append((node, 0))\n\n        savings = []\n        for i in range(len(cluster)):\n            for j in range(i + 1, len(cluster)):\n                node1 = cluster[i]\n                node2 = cluster[j]\n                savings.append((node1, node2, distance_matrix[node1, 0] + distance_matrix[0, node2] - distance_matrix[node1, node2]))\n\n        savings.sort(key=lambda x: x[2], reverse=True)\n\n        route_segments = {node: [node] for node in cluster",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm employs a sweep-based clustering approach, assigning nodes to clusters based on their angular position relative to the depot, followed by route optimization within each cluster using a savings heuristic.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    \n    # 1. Sweep Clustering\n    angles = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n    nodes_with_angles = sorted(zip(range(1, n), angles), key=lambda x: x[1])\n    num_clusters = int(np.sqrt(n))\n    clusters = [[] for _ in range(num_clusters)]\n    \n    cluster_index = 0\n    current_cluster_demand = 0\n    \n    for node_index, angle in nodes_with_angles:\n        if current_cluster_demand + demands[node_index] <= capacity:\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand += demands[node_index]\n        else:\n            cluster_index = (cluster_index + 1) % num_clusters\n            clusters[cluster_index].append(node_index)\n            current_cluster_demand = demands[node_index]\n    \n    # 2. Route Generation (Savings Heuristic)\n    cluster_routes = []\n    for cluster in clusters:\n        if not cluster:\n            cluster_routes.append([0,0])\n            continue\n\n        edges = []\n        for node in cluster:\n            edges.append((0, node))\n            edges.append((node, 0))\n\n        savings = []\n        for i in range(len(cluster)):\n            for j in range(i + 1, len(cluster)):\n                node1 = cluster[i]\n                node2 = cluster[j]\n                savings.append((node1, node2, distance_matrix[node1, 0] + distance_matrix[0, node2] - distance_matrix[node1, node2]))\n\n        savings.sort(key=lambda x: x[2], reverse=True)\n\n        route_segments = {node: [node] for node in cluster}\n\n        def merge_routes(node1, node2):\n            route1 = route_segments[node1]\n            route2 = route_segments[node2]\n            \n            new_route = route1 + route2\n            for node in new_route:\n                route_segments[node] = new_route\n\n        current_route = [0]\n        route_nodes = set()\n\n        for node1, node2, saving in savings:\n            if route_segments[node1] != route_segments[node2]:\n                current_route.append(node1)\n                current_route.append(node2)\n                merge_routes(node1, node2)\n                route_nodes.add(node1)\n                route_nodes.add(node2)\n\n        unvisited = list(set(cluster) - route_nodes)\n\n        for node in unvisited:\n          current_route.append(node)\n        \n        if not unvisited and len(route_nodes) == 0 and len(cluster) > 0:\n          current_route = [0] + cluster\n        \n        current_route = [0]\n        current_node = 0\n        remaining_nodes = set(cluster)\n        final_route = [0]\n\n        while remaining_nodes:\n            nearest_node = None\n            min_dist = float('inf')\n\n            for node in remaining_nodes:\n                dist = distance_matrix[current_node, node]\n                if dist < min_dist:\n                    min_dist = dist\n                    nearest_node = node\n            final_route.append(nearest_node)\n            remaining_nodes.remove(nearest_node)\n            current_node = nearest_node\n\n        final_route.append(0)\n\n        cluster_routes.append(final_route)\n    \n\n    # 3. Combine Routes and Construct Heuristic Matrix\n    for route in cluster_routes:\n        for i in range(len(route) - 1):\n            node1 = route[i]\n            node2 = route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n    \n    # Normalize heuristic matrix by distance\n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j]\n    \n    return heuristics_matrix",
          "objective": 10.51625,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a clustering-first, routing-second approach, where nodes are clustered based on their proximity and demand, followed by generating routes within each cluster and then combining them.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm uses a clustering-first, routing-second approach, where nodes are clustered based on their proximity and demand, followed by generating routes within each cluster and then combining them.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_clusters = int(np.sqrt(n)) # Adjust number of clusters as needed\n    \n    # 1. Clustering (K-Means variant based on location and demand)\n    clusters = [[] for _ in range(num_clusters)]\n    cluster_centers = []\n\n    # Initialize cluster centers randomly from nodes, weighted by demand\n    probabilities = [demands[i] / sum(demands) if i > 0 else 0 for i in range(n)]\n    initial_centers = random.choices(range(1, n), weights=probabilities[1:], k=num_clusters)\n    cluster_centers = [coordinates[i] for i in initial_centers]\n    \n    #Assign nodes to closest cluster\n    for node in range(1, n):\n        min_dist = float('inf')\n        closest_cluster = -1\n        for i in range(num_clusters):\n            dist = np.linalg.norm(coordinates[node] - cluster_centers[i])\n            if dist < min_dist:\n                min_dist = dist\n                closest_cluster = i\n        clusters[closest_cluster].append(node)\n\n    # 2. Route Generation within Clusters (Simple Nearest Neighbor with Capacity Check)\n    cluster_routes = []\n    for cluster in clusters:\n        if not cluster: #Empty cluster, just to avoid errors\n            cluster_routes.append([0,0])\n            continue\n\n        current_node = 0  # Start at depot\n        current_route = [0]\n        current_capacity = capacity\n        remaining_nodes = set(cluster)\n        \n        while remaining_nodes:\n            nearest_node = None\n            min_dist = float('inf')\n            \n            for node in remaining_nodes:\n                if demands[node] <= current_capacity:\n                    dist = distance_matrix[current_node, node]\n                    if dist < min_dist:\n                        min_dist = dist\n                        nearest_node = node\n            \n            if nearest_node is None: #No feasible node\n                current_route.append(0)\n                current_capacity = capacity\n                current_node = 0\n            else:\n                current_route.append(nearest_node)\n                current_capacity -= demands[nearest_node]\n                current_node = nearest_node\n                remaining_nodes.remove(nearest_node)\n        \n        current_route.append(0)\n        cluster_routes.append(current_route)\n\n    # 3. Combine Routes and Construct Heuristic Matrix\n    for route in cluster_routes:\n        for i in range(len(route) - 1):\n            node1 = route[i]\n            node2 = route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n    \n    # Normalize heuristic matrix by distance\n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j]\n    \n    return heuristics_matrix",
          "objective": 12.26842,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively constructs routes by adding the closest feasible node to the current route until the vehicle's capacity is reached, then returns to the depot and repeats until all nodes are visited.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm iteratively constructs routes by adding the closest feasible node to the current route until the vehicle's capacity is reached, then returns to the depot and repeats until all nodes are visited.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    \n    unvisited_nodes = set(range(1, n))\n    routes = []\n    \n    while unvisited_nodes:\n        current_route = [0]\n        current_capacity = capacity\n        current_node = 0\n        \n        while True:\n            nearest_node = None\n            min_dist = float('inf')\n            \n            for node in unvisited_nodes:\n                if demands[node] <= current_capacity:\n                    dist = distance_matrix[current_node, node]\n                    if dist < min_dist:\n                        min_dist = dist\n                        nearest_node = node\n            \n            if nearest_node is None:\n                current_route.append(0)\n                routes.append(current_route)\n                break\n            else:\n                current_route.append(nearest_node)\n                current_capacity -= demands[nearest_node]\n                current_node = nearest_node\n                unvisited_nodes.remove(nearest_node)\n                \n    for route in routes:\n        for i in range(len(route) - 1):\n            node1 = route[i]\n            node2 = route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n    \n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j]\n    \n    return heuristics_matrix",
          "objective": 12.3048,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively constructs solutions by probabilistically selecting edges based on distance, demand, and a dynamic pheromone-like value, while also incorporating a local search component to refine solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    pheromone_matrix = np.ones_like(distance_matrix)\n    alpha = 1.0\n    beta = 2.0\n    rho = 0.1\n    q0 = 0.9\n\n    num_iterations = 500\n\n    for iteration in range(num_iterations):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n        total_distance = 0\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    eta = 1 / distance_matrix[current_node, node]\n                    tau = pheromone_matrix[current_node, node]\n                    probabilities[node] = (tau**alpha) * (eta**beta)\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = random.choice(list(remaining_nodes))\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm iteratively constructs solutions by probabilistically selecting edges based on distance, demand, and a dynamic pheromone-like value, while also incorporating a local search component to refine solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    pheromone_matrix = np.ones_like(distance_matrix)\n    alpha = 1.0\n    beta = 2.0\n    rho = 0.1\n    q0 = 0.9\n\n    num_iterations = 500\n\n    for iteration in range(num_iterations):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n        total_distance = 0\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    eta = 1 / distance_matrix[current_node, node]\n                    tau = pheromone_matrix[current_node, node]\n                    probabilities[node] = (tau**alpha) * (eta**beta)\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = random.choice(list(remaining_nodes))\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}\n                if random.random() < q0:\n                    next_node = max(normalized_probabilities, key=normalized_probabilities.get)\n                else:\n                    next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))\n            \n            if current_capacity >= demands[next_node]:\n                route.append(next_node)\n                current_capacity -= demands[next_node]\n                total_distance += distance_matrix[current_node, next_node]\n                remaining_nodes.remove(next_node)\n                current_node = next_node\n            else:\n                route.append(0)\n                total_distance += distance_matrix[current_node, 0]\n                current_capacity = capacity\n                current_node = 0\n\n        total_distance += distance_matrix[current_node, 0]\n        route.append(0)\n\n        # Local Search (2-opt) - Simplified for brevity\n        for i in range(1, len(route) - 2):\n            for j in range(i + 1, len(route) - 1):\n                if j - i == 1: continue\n                \n                delta_distance = -distance_matrix[route[i-1], route[i]] - distance_matrix[route[j], route[j+1]] + distance_matrix[route[i-1], route[j]] + distance_matrix[route[i], route[j+1]]\n                if delta_distance < 0:\n                    route[i:j+1] = list(reversed(route[i:j+1]))\n                    total_distance += delta_distance\n\n        # Pheromone Update\n        for i in range(len(route) - 1):\n            pheromone_matrix[route[i], route[i+1]] = (1 - rho) * pheromone_matrix[route[i], route[i+1]] + rho / total_distance\n            pheromone_matrix[route[i+1], route[i]] = pheromone_matrix[route[i], route[i+1]]\n            heuristics_matrix[route[i], route[i+1]] += 1\n            heuristics_matrix[route[i+1], route[i]] += 1\n    \n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n               heuristics_matrix[i, j] /= distance_matrix[i, j]\n            \n    return heuristics_matrix",
          "objective": 12.44237,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm initializes routes with single customers, iteratively merges them based on savings, and uses a pheromone-like matrix to encourage exploration, penalizing merges that violate capacity constraints.}\"\"\"\n\n    n = len(demands)\n    heuristics_matrix = np.zeros((n, n))\n    pheromone_matrix = np.ones((n, n))  # Initialize pheromone matrix\n\n    # Initialize savings matrix\n    savings = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i+1, n):\n            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings[j, i] = savings[i, j]  # Savings are symmetric\n\n    # Initialize individual routes for each customer\n    routes = [[i] for i in range(1, n)]\n    route_demands = {i: demands[i] for i in range(1, n)",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm initializes routes with single customers, iteratively merges them based on savings, and uses a pheromone-like matrix to encourage exploration, penalizing merges that violate capacity constraints.}\"\"\"\n\n    n = len(demands)\n    heuristics_matrix = np.zeros((n, n))\n    pheromone_matrix = np.ones((n, n))  # Initialize pheromone matrix\n\n    # Initialize savings matrix\n    savings = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i+1, n):\n            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings[j, i] = savings[i, j]  # Savings are symmetric\n\n    # Initialize individual routes for each customer\n    routes = [[i] for i in range(1, n)]\n    route_demands = {i: demands[i] for i in range(1, n)}\n    \n    num_iterations = 1000\n    for _ in range(num_iterations):\n        # Find the best savings considering pheromones\n        best_savings = -1\n        best_i = -1\n        best_j = -1\n\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                # Check if i and j are end nodes of different routes\n                route_i = None\n                route_j = None\n                for r_idx, route in enumerate(routes):\n                    if route[0] == i:\n                        route_i = r_idx\n                    if route[-1] == j:\n                        route_j = r_idx\n                \n                if route_i is not None and route_j is not None and route_i != route_j:\n                    current_savings = savings[i, j] * pheromone_matrix[i, j]\n                    if current_savings > best_savings:\n                        best_savings = current_savings\n                        best_i = i\n                        best_j = j\n                        best_route_i = route_i\n                        best_route_j = route_j\n\n        # Merge routes if beneficial and feasible\n        if best_savings > 0:\n            \n            route_i = routes[best_route_i]\n            route_j = routes[best_route_j]\n            \n            total_demand = sum([demands[node] for node in route_i + route_j])\n            \n            if total_demand <= capacity:\n                # Update pheromone matrix - reward\n                for node1 in route_i:\n                  for node2 in route_j:\n                    heuristics_matrix[node1, node2] +=1\n                    heuristics_matrix[node2, node1] +=1\n                    pheromone_matrix[node1, node2] *= 1.1  # Increase pheromone\n                    pheromone_matrix[node2, node1] *= 1.1\n                # Merge the routes\n                routes[best_route_i] = route_i + route_j\n                del routes[best_route_j]\n            else:\n                # Penalize the edge in pheromone matrix\n                pheromone_matrix[best_i, best_j] *= 0.9  # Decrease pheromone\n                pheromone_matrix[best_j, best_i] *= 0.9\n\n\n    return heuristics_matrix",
          "objective": 12.50501,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes routes based on saving calculation and demand consideration, constructing routes iteratively by selecting the edge that maximizes a score function combining distance and remaining capacity, then constructing prior indicators.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm prioritizes routes based on saving calculation and demand consideration, constructing routes iteratively by selecting the edge that maximizes a score function combining distance and remaining capacity, then constructing prior indicators.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    \n    # Initialize the current route with the depot\n    current_route = [0]\n    remaining_nodes = set(range(1, n))\n    current_capacity = capacity\n    \n    while remaining_nodes:\n        best_node = None\n        best_score = -1\n        \n        for node in remaining_nodes:\n            if demands[node] <= current_capacity:\n                # Calculate a score based on distance and remaining capacity\n                distance = distance_matrix[current_route[-1], node]\n                remaining_cap_ratio = demands[node]/current_capacity\n                score = (1 / distance) * (1 - remaining_cap_ratio) # Favor shorter distances and smaller demands related to the current remaining capacity\n                \n                if score > best_score:\n                    best_score = score\n                    best_node = node\n        \n        if best_node is not None:\n            current_route.append(best_node)\n            current_capacity -= demands[best_node]\n            remaining_nodes.remove(best_node)\n        else:\n            # Return to depot if no feasible node is found\n            current_route.append(0)\n            current_capacity = capacity\n            current_route.append(current_route[-2])  # Repeat last node to not disconnect previous edges\n    current_route.append(0)\n    # Populate the heuristic matrix based on the constructed route\n    for i in range(len(current_route) - 1):\n        node1 = current_route[i]\n        node2 = current_route[i+1]\n        heuristics_matrix[node1, node2] = 1\n        heuristics_matrix[node2, node1] = 1\n    \n    # Normalize\n    for i in range(n):\n        for j in range(n):\n             if heuristics_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j]\n    \n    return heuristics_matrix",
          "objective": 13.23046,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines stochastic sampling with simulated annealing-inspired acceptance probability based on edge distance and pheromone levels to estimate edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    pheromone_matrix = np.ones_like(distance_matrix)\n    temperature = 1.0\n    cooling_rate = 0.995\n    num_samples = 500\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)\n                    demand_heuristic = (current_capacity - demands[node]) / capacity\n                    probabilities[node] = distance_heuristic * (demand_heuristic + 0.1) * pheromone_matrix[current_node, node]\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm combines stochastic sampling with simulated annealing-inspired acceptance probability based on edge distance and pheromone levels to estimate edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    pheromone_matrix = np.ones_like(distance_matrix)\n    temperature = 1.0\n    cooling_rate = 0.995\n    num_samples = 500\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)\n                    demand_heuristic = (current_capacity - demands[node]) / capacity\n                    probabilities[node] = distance_heuristic * (demand_heuristic + 0.1) * pheromone_matrix[current_node, node]\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}\n                next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))\n                \n            if current_capacity >= demands[next_node]:\n                delta_distance = distance_matrix[current_node, next_node]\n                acceptance_probability = np.exp(-delta_distance / temperature)\n                \n                if random.random() < acceptance_probability:\n                    route.append(next_node)\n                    heuristics_matrix[current_node, next_node] += 1\n                    heuristics_matrix[next_node, current_node] += 1\n                    current_capacity -= demands[next_node]\n                    remaining_nodes.remove(next_node)\n                    current_node = next_node\n                else:\n                    remaining_nodes.remove(next_node)\n            else:\n                delta_distance = distance_matrix[current_node, 0]\n                acceptance_probability = np.exp(-delta_distance / temperature)\n                if random.random() < acceptance_probability:\n                   route.append(0)\n                   heuristics_matrix[current_node, 0] += 1\n                   heuristics_matrix[0, current_node] += 1\n                   current_node = 0\n                   current_capacity = capacity\n                else:\n                    break\n                    \n\n        if current_node != 0:\n            delta_distance = distance_matrix[current_node, 0]\n            acceptance_probability = np.exp(-delta_distance / temperature)\n            if random.random() < acceptance_probability:\n                heuristics_matrix[current_node, 0] += 1\n                heuristics_matrix[0, current_node] += 1\n\n        temperature *= cooling_rate\n\n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n               heuristics_matrix[i, j] /= (distance_matrix[i, j] + 1e-6)\n\n    return heuristics_matrix",
          "objective": 14.04683,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a combination of shortest distance and demand satisfaction with stochastic route construction and pheromone updating to create the heuristics matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    pheromone_matrix = np.ones_like(distance_matrix)\n    \n    num_samples = 500\n    alpha = 0.1  # Pheromone influence\n    beta = 2.0  # Distance influence\n    rho = 0.1   # Evaporation rate\n    Q = 100.0   # Pheromone deposit constant\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n        route_distance = 0\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    eta = 1.0 / (distance_matrix[current_node, node] + 1e-6)\n                    tau = pheromone_matrix[current_node, node]\n                    probabilities[node] = (tau**alpha) * (eta**beta)\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm uses a combination of shortest distance and demand satisfaction with stochastic route construction and pheromone updating to create the heuristics matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    pheromone_matrix = np.ones_like(distance_matrix)\n    \n    num_samples = 500\n    alpha = 0.1  # Pheromone influence\n    beta = 2.0  # Distance influence\n    rho = 0.1   # Evaporation rate\n    Q = 100.0   # Pheromone deposit constant\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n        route_distance = 0\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    eta = 1.0 / (distance_matrix[current_node, node] + 1e-6)\n                    tau = pheromone_matrix[current_node, node]\n                    probabilities[node] = (tau**alpha) * (eta**beta)\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}\n                next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))\n                \n            if current_capacity >= demands[next_node]:\n                route.append(next_node)\n                route_distance += distance_matrix[current_node, next_node]\n                current_capacity -= demands[next_node]\n                remaining_nodes.remove(next_node)\n                heuristics_matrix[current_node, next_node] += 1\n                heuristics_matrix[next_node, current_node] += 1\n                current_node = next_node\n            else:\n                route.append(0)\n                route_distance += distance_matrix[current_node, 0]\n                heuristics_matrix[current_node, 0] += 1\n                heuristics_matrix[0, current_node] += 1\n                current_node = 0\n                current_capacity = capacity\n        \n        if current_node != 0:\n            route_distance += distance_matrix[current_node, 0]\n            heuristics_matrix[current_node, 0] += 1\n            heuristics_matrix[0, current_node] += 1\n        \n        # Pheromone update\n        for i in range(len(route) - 1):\n            pheromone_matrix[route[i], route[i+1]] = (1-rho) * pheromone_matrix[route[i], route[i+1]] + rho * (Q / route_distance)\n            pheromone_matrix[route[i+1], route[i]] = pheromone_matrix[route[i], route[i+1]]\n\n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n               heuristics_matrix[i, j] /= (distance_matrix[i, j] + 1e-6)\n\n    return heuristics_matrix",
          "objective": 14.16009,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines stochastic sampling with adaptive pheromone-inspired edge selection and reinforcement learning to estimate edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    pheromone_matrix = np.ones_like(distance_matrix)  # Initialize pheromone trails\n\n    num_samples = 500\n    learning_rate = 0.1\n    discount_factor = 0.9\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n        total_distance = 0\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)\n                    demand_heuristic = (current_capacity - demands[node]) / capacity\n                    probabilities[node] = distance_heuristic * (demand_heuristic + 0.1) * pheromone_matrix[current_node, node]\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm combines stochastic sampling with adaptive pheromone-inspired edge selection and reinforcement learning to estimate edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    pheromone_matrix = np.ones_like(distance_matrix)  # Initialize pheromone trails\n\n    num_samples = 500\n    learning_rate = 0.1\n    discount_factor = 0.9\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n        total_distance = 0\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)\n                    demand_heuristic = (current_capacity - demands[node]) / capacity\n                    probabilities[node] = distance_heuristic * (demand_heuristic + 0.1) * pheromone_matrix[current_node, node]\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}\n                next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))\n                \n            if current_capacity >= demands[next_node]:\n                route.append(next_node)\n                total_distance += distance_matrix[current_node, next_node]\n                current_capacity -= demands[next_node]\n                remaining_nodes.remove(next_node)\n                heuristics_matrix[current_node, next_node] += 1\n                heuristics_matrix[next_node, current_node] += 1\n                \n                # Update pheromone trail (reinforcement learning)\n                pheromone_matrix[current_node, next_node] = (1 - learning_rate) * pheromone_matrix[current_node, next_node] + learning_rate * (1 / (distance_matrix[current_node, next_node] + 1e-6))\n                pheromone_matrix[next_node, current_node] = (1 - learning_rate) * pheromone_matrix[next_node, current_node] + learning_rate * (1 / (distance_matrix[next_node, current_node] + 1e-6))\n                \n                current_node = next_node\n            else:\n                route.append(0)\n                total_distance += distance_matrix[current_node, 0]\n                heuristics_matrix[current_node, 0] += 1\n                heuristics_matrix[0, current_node] += 1\n\n                # Update pheromone trail (negative reward for returning to depot)\n                pheromone_matrix[current_node, 0] = (1 - learning_rate) * pheromone_matrix[current_node, 0]\n                pheromone_matrix[0, current_node] = (1 - learning_rate) * pheromone_matrix[0, current_node]\n                \n                current_node = 0\n                current_capacity = capacity\n        \n        if current_node != 0:\n            total_distance += distance_matrix[current_node, 0]\n            heuristics_matrix[current_node, 0] += 1\n            heuristics_matrix[0, current_node] += 1\n\n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n               heuristics_matrix[i, j] /= (distance_matrix[i, j] + 1e-6)\n            \n    return heuristics_matrix",
          "objective": 14.36769,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines stochastic sampling with adaptive weight adjustment and a modified score function based on edge usage and solution quality to estimate edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    edge_weights = np.ones_like(distance_matrix)  # Initialize edge weights\n\n    num_samples = 500\n    alpha = 0.7  # Weight decay factor\n    beta = 0.3  # Reward increment factor\n    gamma = 0.5 # Demand weight factor\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)\n                    demand_heuristic = (current_capacity - demands[node]) / capacity\n                    # Modified Score function\n                    probabilities[node] = distance_heuristic * (gamma * demand_heuristic + (1-gamma) * 0.1) * edge_weights[current_node, node] #Consider weight\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm combines stochastic sampling with adaptive weight adjustment and a modified score function based on edge usage and solution quality to estimate edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    edge_weights = np.ones_like(distance_matrix)  # Initialize edge weights\n\n    num_samples = 500\n    alpha = 0.7  # Weight decay factor\n    beta = 0.3  # Reward increment factor\n    gamma = 0.5 # Demand weight factor\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = set(range(1, n))\n        current_capacity = capacity\n\n        while remaining_nodes:\n            probabilities = {}\n            for node in remaining_nodes:\n                if current_capacity >= demands[node]:\n                    distance_heuristic = 1 / (distance_matrix[current_node, node] + 1e-6)\n                    demand_heuristic = (current_capacity - demands[node]) / capacity\n                    # Modified Score function\n                    probabilities[node] = distance_heuristic * (gamma * demand_heuristic + (1-gamma) * 0.1) * edge_weights[current_node, node] #Consider weight\n\n            if not probabilities:\n                break\n\n            total_prob = sum(probabilities.values())\n            if total_prob == 0:\n                next_node = remaining_nodes.pop()\n            else:\n                normalized_probabilities = {node: prob / total_prob for node, prob in probabilities.items()}\n                next_node = np.random.choice(list(normalized_probabilities.keys()), p=list(normalized_probabilities.values()))\n                \n            if current_capacity >= demands[next_node]:\n                route.append(next_node)\n                current_capacity -= demands[next_node]\n                remaining_nodes.remove(next_node)\n                heuristics_matrix[current_node, next_node] += 1\n                heuristics_matrix[next_node, current_node] += 1\n                \n                # Reward the selected edge\n                edge_weights[current_node, next_node] += beta\n                edge_weights[next_node, current_node] += beta\n                \n                current_node = next_node\n            else:\n                route.append(0)\n                heuristics_matrix[current_node, 0] += 1\n                heuristics_matrix[0, current_node] += 1\n\n                # Penalize returning to depot\n                edge_weights[current_node, 0] *= alpha\n                edge_weights[0, current_node] *= alpha\n                \n                current_node = 0\n                current_capacity = capacity\n                \n        if current_node != 0:\n            heuristics_matrix[current_node, 0] += 1\n            heuristics_matrix[0, current_node] += 1\n    \n    for i in range(n):\n        for j in range(n):\n            if heuristics_matrix[i, j] > 0:\n               heuristics_matrix[i, j] /= (distance_matrix[i, j] + 1e-6)\n            \n    return heuristics_matrix",
          "objective": 14.56597,
          "other_inf": null
     }
]