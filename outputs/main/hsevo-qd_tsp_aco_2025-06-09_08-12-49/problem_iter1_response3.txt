```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics function for TSP via stochastic solution sampling.

    This version combines inverse distance, node degree penalty,
    and a random element to encourage exploration.

    Args:
        distance_matrix: A NumPy array representing the distance matrix.

    Returns:
        A NumPy array of the same shape as the distance matrix,
        representing the prior indicators of how promising it is to
        include each edge in a solution.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Inverse distance: Shorter distances are more promising.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # Node degree penalty: Penalize edges connecting to high-degree nodes
    # (to discourage forming cycles early and leaving nodes isolated).
    degree_centrality = np.sum(inverse_distance, axis=0) # Sum inverse distance along each node
    degree_penalty = np.outer(degree_centrality, degree_centrality)
    degree_penalty = 1/ (degree_penalty + 1e-9)

    # Random exploration: Add a small random value to encourage exploration.
    random_factor = 0.01 * np.random.rand(n, n) # Small random number

    # Combine heuristics
    heuristics = inverse_distance * degree_penalty + random_factor

    return heuristics
```
