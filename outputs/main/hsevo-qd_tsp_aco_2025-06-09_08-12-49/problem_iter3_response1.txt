```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines several factors to determine how promising it is to select an edge for TSP,
    including pheromone inspired intensification, inverse distance, and sparsification.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    epsilon = 1e-9
    safe_distance_matrix = distance_matrix + epsilon

    # 1. Inverse Distance
    inverse_distance = 1 / safe_distance_matrix

    # 2. Pheromone-inspired Intensification (simulated pheromone)
    # High degree nodes might be good to visit early (but not always!)
    degree_centrality = np.sum(inverse_distance, axis=1)
    pheromone = np.outer(degree_centrality, degree_centrality)

    # 3. Node potential:  Nodes close to the "center" may be more desirable
    center = np.mean(np.arange(n))  # center node index

    # A version that tries to bias towards connections towards the center
    node_potential = np.exp(-np.abs(np.arange(n) - center) / (n / 3))  # Gaussian falloff from center
    potential_matrix = np.outer(node_potential, node_potential)


    # 4. Combination with weights. Tuned for better balance.
    heuristics = (0.5 * inverse_distance +
                  0.3 * pheromone +
                  0.2 * potential_matrix)  # Weights adjusted



    # 5. Sparsification (Optional, but potentially effective)
    # Zero out edges that are "too long" relative to the average distance
    average_distance = np.mean(distance_matrix)
    sparsification_threshold = 2.5 * average_distance # A tuning parameter

    heuristics[distance_matrix > sparsification_threshold] = 0  # Crucial sparsification step!

    # Avoid self-loops
    np.fill_diagonal(heuristics, 0)

    # 6. Normalization
    min_heuristic = np.min(heuristics)
    max_heuristic = np.max(heuristics)

    if max_heuristic - min_heuristic > 1e-9:  # Avoid division by zero
        heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)
    else:
        heuristics = np.ones_like(heuristics) * 0.5  # if all values are equal, set to 0.5
        heuristics = heuristics * (1 - np.eye(n))

    return heuristics
```
