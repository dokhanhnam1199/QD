```python
import numpy as np

epsilon = 1e-6  # Small constant to avoid division by zero
attraction_weight = 0.5
inverse_distance_weight = 0.5


def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines Newtonian attraction with inverse distance and sparsification for TSP edge prioritization.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    safe_distance_matrix = distance_matrix + epsilon

    # Newtonian attraction component
    attraction = 1 / (safe_distance_matrix**2)
    mass = np.sum(1 / safe_distance_matrix, axis=1)
    M = np.outer(mass, mass)
    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)
    newtonian = (attraction * M) / potential_energy

    # Inverse distance component
    inverse_distance = 1 / safe_distance_matrix

    # Angle Priority
    angle_priority = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                angles = []
                for k in range(n):
                    if k != i and k != j:
                        vec1 = safe_distance_matrix[i,j]
                        vec2 = safe_distance_matrix[i,k]
                        angles.append(np.arccos((vec1**2 + vec2**2 - safe_distance_matrix[j,k]**2) / (2 * vec1 * vec2 + epsilon)))

                angle_priority[i,j] = np.sum(angles)

    angle_priority = angle_priority / np.max(angle_priority)

    # Combine the components
    heuristics = (
        attraction_weight * newtonian
        + inverse_distance_weight * inverse_distance
        + 0.2 * angle_priority
    )

    # Normalize
    min_heuristic = np.min(heuristics)
    max_heuristic = np.max(heuristics)
    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)

    # Sparsify: Zero out less promising edges (e.g., keep only top 50%)
    threshold = np.percentile(heuristics, 50)  # Keep top 50%
    heuristics[heuristics < threshold] = 0

    return heuristics
```
