```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """Combines Newtonian attraction, inverse distance, and node degree for TSP."""
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    epsilon = 1e-9
    safe_distance_matrix = distance_matrix + epsilon

    # Newtonian attraction component
    attraction = 1 / (safe_distance_matrix**2)
    mass = np.sum(1 / safe_distance_matrix, axis=1)
    M = np.outer(mass, mass)
    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)
    newtonian = (attraction * M) / potential_energy

    # Inverse distance component
    inverse_distance = 1 / safe_distance_matrix

    # Node degree component (penalize high-degree nodes)
    degree = np.sum(distance_matrix > 0, axis=1) # Count neighbors (edges > 0)
    degree_matrix = np.outer(degree, degree)
    degree_penalty = degree_matrix / (np.mean(degree) + epsilon)  # Normalize by mean degree
    degree_component = 1 / (1 + degree_penalty) # Invert to prioritize low-degree

    # Combine components with adjusted weights
    attraction_weight = 0.6
    inverse_distance_weight = 0.3
    degree_weight = 0.1

    heuristics = (attraction_weight * newtonian +
                  inverse_distance_weight * inverse_distance +
                  degree_weight * degree_component)

    # Normalize
    min_heuristic = np.min(heuristics)
    max_heuristic = np.max(heuristics)
    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)

    # Sparsify (optional: remove edges with low heuristic value)
    threshold = np.quantile(heuristics, 0.2)  # Keep top 80%
    heuristics[heuristics < threshold] = 0

    return heuristics
```
