```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Enhanced heuristics for TSP edge prioritization, combining Newtonian attraction,
    inverse distance, and sparsification based on a cost-benefit ratio.
    """

    n = distance_matrix.shape[0]
    epsilon = 1e-9  # for numerical stability
    heuristics = np.zeros_like(distance_matrix)
    safe_distance_matrix = distance_matrix + epsilon
    attraction_weight = 0.6
    inverse_distance_weight = 0.4
    sparsification_threshold = 0.2 # Adjust this based on problem scale/density

    # Newtonian attraction component
    attraction = 1 / (safe_distance_matrix**2)
    mass = np.sum(1 / safe_distance_matrix, axis=1)
    M = np.outer(mass, mass)
    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)
    newtonian = (attraction * M) / potential_energy

    # Inverse distance component
    inverse_distance = 1 / safe_distance_matrix

    # Combine the two components
    heuristics = attraction_weight * newtonian + inverse_distance_weight * inverse_distance

    # Normalize
    min_heuristic = np.min(heuristics)
    max_heuristic = np.max(heuristics)
    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)

    # Sparsification: Zero out less promising edges based on cost-benefit ratio.
    # Cost: Distance between nodes.
    # Benefit: Heuristic value (prioritization).
    cost_benefit_ratio = safe_distance_matrix / (heuristics + epsilon) # Avoid division by zero.
    threshold = np.percentile(cost_benefit_ratio, 100 * sparsification_threshold) # dynamically determine cut-off
    heuristics[cost_benefit_ratio > threshold] = 0 # remove low-promise edges

    return heuristics
```
