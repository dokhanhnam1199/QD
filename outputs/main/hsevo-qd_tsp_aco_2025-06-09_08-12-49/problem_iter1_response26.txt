```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Stephen Hawking here. My mind, like a black hole, bends the light of optimization.
    This function crafts heuristics for the Traveling Salesman Problem,
    guided by principles of gravitational attraction and a dash of quantum randomness.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Inverse distance (gravitational attraction - shorter is better)
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Avoid division by zero

    # Node degree desirability (balance visiting nodes)
    degree_desirability = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Consider the average distance to other nodes
                avg_distance_i = np.mean(distance_matrix[i, :])
                avg_distance_j = np.mean(distance_matrix[j, :])
                degree_desirability[i, j] = (avg_distance_i + avg_distance_j) / 2  # Favor edges connecting to nodes with large average distances (less visited)

    # Global shortest edge influence (local exploitation)
    min_distance = np.min(distance_matrix[distance_matrix > 0]) #exclude 0's on diagonal
    shortest_edge_influence = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
              shortest_edge_influence[i, j] = np.exp(-distance_matrix[i,j]/min_distance) #higher chance near min dist.

    # Quantum random noise (exploration)
    random_noise = np.random.rand(n, n) * 0.1

    # Combine the factors
    heuristics = (0.6 * inverse_distance +
                  0.2 * degree_desirability +
                  0.1 * shortest_edge_influence +
                  0.1 * random_noise)

    return heuristics
```
