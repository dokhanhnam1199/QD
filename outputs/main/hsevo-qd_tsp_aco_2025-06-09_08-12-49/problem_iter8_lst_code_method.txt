{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, attraction_weight: float = 0.590689937421805, inverse_distance_weight: float = 0.2795416896063997, epsilon: float = 1.512501949559389e-09) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction with inverse distance for TSP edge prioritization.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # Newtonian attraction component\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # Inverse distance component\n    inverse_distance = 1 / safe_distance_matrix\n\n    # Combine the two components\n    heuristics = attraction_weight * newtonian + inverse_distance_weight * inverse_distance\n\n    # Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    return heuristics\n\n[Heuristics 2nd]\nimport numpy as np\n\nepsilon = 1e-6\nattraction_weight = 0.6\ninverse_distance_weight = 0.4\n\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, and node degree for TSP edge prioritization,\n    with sparsification.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # Newtonian attraction component\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # Inverse distance component\n    inverse_distance = 1 / safe_distance_matrix\n\n    # Node degree component (prioritize edges connecting low-degree nodes)\n    degree = np.sum(distance_matrix > 0, axis=1)  # Count neighbors (excluding self-loops which should be zero or inf)\n    degree_matrix = np.outer(degree, degree)\n    degree_heuristic = 1 / (degree_matrix + epsilon)\n\n    # Combine the components\n    heuristics = (attraction_weight * newtonian +\n                  inverse_distance_weight * inverse_distance +\n                  0.1 * degree_heuristic)  # Reduced weight for degree\n\n    # Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # Sparsification: zero out edges with low heuristic values to reduce search space\n    threshold = np.quantile(heuristics, 0.2)  # Keep top 80% of edges\n    heuristics[heuristics < threshold] = 0.0\n\n    return heuristics\n\n[Heuristics 3rd]\nimport numpy as np\n\nepsilon = 1e-6\nattraction_weight = 0.6\ninverse_distance_weight = 0.4\n\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, and node degree for TSP edge prioritization,\n    with sparsification.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # Newtonian attraction component\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # Inverse distance component\n    inverse_distance = 1 / safe_distance_matrix\n\n    # Node degree component (prioritize edges connecting low-degree nodes)\n    degree = np.sum(distance_matrix > 0, axis=1)  # Count neighbors (excluding self-loops which should be zero or inf)\n    degree_matrix = np.outer(degree, degree)\n    degree_heuristic = 1 / (degree_matrix + epsilon)\n\n    # Combine the components\n    heuristics = (attraction_weight * newtonian +\n                  inverse_distance_weight * inverse_distance +\n                  0.1 * degree_heuristic)  # Reduced weight for degree\n\n    # Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # Sparsification: zero out edges with low heuristic values to reduce search space\n    threshold = np.quantile(heuristics, 0.2)  # Keep top 80% of edges\n    heuristics[heuristics < threshold] = 0.0\n\n    return heuristics\n\n[Heuristics 4th]\nimport numpy as np\n\nepsilon = 1e-6\nattraction_weight = 0.6\ninverse_distance_weight = 0.4\n\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, and node degree for TSP edge prioritization,\n    with sparsification.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # Newtonian attraction component\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # Inverse distance component\n    inverse_distance = 1 / safe_distance_matrix\n\n    # Node degree component (prioritize edges connecting low-degree nodes)\n    degree = np.sum(distance_matrix > 0, axis=1)  # Count neighbors (excluding self-loops which should be zero or inf)\n    degree_matrix = np.outer(degree, degree)\n    degree_heuristic = 1 / (degree_matrix + epsilon)\n\n    # Combine the components\n    heuristics = (attraction_weight * newtonian +\n                  inverse_distance_weight * inverse_distance +\n                  0.1 * degree_heuristic)  # Reduced weight for degree\n\n    # Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # Sparsification: zero out edges with low heuristic values to reduce search space\n    threshold = np.quantile(heuristics, 0.2)  # Keep top 80% of edges\n    heuristics[heuristics < threshold] = 0.0\n\n    return heuristics\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, node degree, and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    epsilon = 1e-9\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # 1. Newtonian Attraction\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # 2. Inverse Distance\n    inverse_distance = 1 / safe_distance_matrix\n\n    # 3. Node Degree: Favor edges connecting to nodes with fewer connections\n    degree = np.sum(distance_matrix < np.mean(distance_matrix), axis=1)\n    degree_matrix = np.outer(degree, degree)\n    degree_factor = 1 / (degree_matrix + epsilon)\n\n    # 4. Combine Components\n    heuristics = 0.5 * newtonian + 0.3 * inverse_distance + 0.2 * degree_factor\n\n    # 5. Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # 6. Sparsification: Dynamic threshold\n    threshold = np.percentile(heuristics, 20)\n    heuristics[heuristics < threshold] = 0\n\n    # Ensure diagonal is zero.\n    np.fill_diagonal(heuristics, 0)\n\n    return heuristics\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, node degree, and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    epsilon = 1e-9\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # 1. Newtonian Attraction\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # 2. Inverse Distance\n    inverse_distance = 1 / safe_distance_matrix\n\n    # 3. Node Degree: Favor edges connecting to nodes with fewer connections\n    degree = np.sum(distance_matrix < np.mean(distance_matrix), axis=1)\n    degree_matrix = np.outer(degree, degree)\n    degree_factor = 1 / (degree_matrix + epsilon)\n\n    # 4. Combine Components\n    heuristics = 0.5 * newtonian + 0.3 * inverse_distance + 0.2 * degree_factor\n\n    # 5. Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # 6. Sparsification: Dynamic threshold\n    threshold = np.percentile(heuristics, 20)\n    heuristics[heuristics < threshold] = 0\n\n    # Ensure diagonal is zero.\n    np.fill_diagonal(heuristics, 0)\n\n    return heuristics\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, node degree, and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    epsilon = 1e-9\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # 1. Newtonian Attraction\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # 2. Inverse Distance\n    inverse_distance = 1 / safe_distance_matrix\n\n    # 3. Node Degree: Favor edges connecting to nodes with fewer connections\n    degree = np.sum(distance_matrix < np.mean(distance_matrix), axis=1)\n    degree_matrix = np.outer(degree, degree)\n    degree_factor = 1 / (degree_matrix + epsilon)\n\n    # 4. Combine Components\n    heuristics = 0.5 * newtonian + 0.3 * inverse_distance + 0.2 * degree_factor\n\n    # 5. Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # 6. Sparsification: Dynamic threshold\n    threshold = np.percentile(heuristics, 20)\n    heuristics[heuristics < threshold] = 0\n\n    # Ensure diagonal is zero.\n    np.fill_diagonal(heuristics, 0)\n\n    return heuristics\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, node degree, and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    epsilon = 1e-9\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # 1. Newtonian Attraction\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # 2. Inverse Distance\n    inverse_distance = 1 / safe_distance_matrix\n\n    # 3. Node Degree: Favor edges connecting to nodes with fewer connections\n    degree = np.sum(distance_matrix < np.mean(distance_matrix), axis=1)\n    degree_matrix = np.outer(degree, degree)\n    degree_factor = 1 / (degree_matrix + epsilon)\n\n    # 4. Combine Components\n    heuristics = 0.5 * newtonian + 0.3 * inverse_distance + 0.2 * degree_factor\n\n    # 5. Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # 6. Sparsification: Dynamic threshold\n    threshold = np.percentile(heuristics, 20)\n    heuristics[heuristics < threshold] = 0\n\n    # Ensure diagonal is zero.\n    np.fill_diagonal(heuristics, 0)\n\n    return heuristics\n\n[Heuristics 9th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, newtonian_weight: float = 0.05733624735160625, inverse_distance_weight: float = 0.7780862255376683,\n                  degree_factor_weight: float = 0.35960339383159123, sparsification_percentile: float = 39.00219557601301,\n                  epsilon: float = 5.434469300548452e-08) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, node degree, and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # 1. Newtonian Attraction\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # 2. Inverse Distance\n    inverse_distance = 1 / safe_distance_matrix\n\n    # 3. Node Degree: Favor edges connecting to nodes with fewer connections\n    degree = np.sum(distance_matrix < np.mean(distance_matrix), axis=1)\n    degree_matrix = np.outer(degree, degree)\n    degree_factor = 1 / (degree_matrix + epsilon)\n\n    # 4. Combine Components\n    heuristics = newtonian_weight * newtonian + inverse_distance_weight * inverse_distance + degree_factor_weight * degree_factor\n\n    # 5. Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # 6. Sparsification: Dynamic threshold\n    threshold = np.percentile(heuristics, sparsification_percentile)\n    heuristics[heuristics < threshold] = 0\n\n    # Ensure diagonal is zero.\n    np.fill_diagonal(heuristics, 0)\n\n    return heuristics\n\n[Heuristics 10th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, newtonian_weight: float = 0.05733624735160625, inverse_distance_weight: float = 0.7780862255376683,\n                  degree_factor_weight: float = 0.35960339383159123, sparsification_percentile: float = 39.00219557601301,\n                  epsilon: float = 5.434469300548452e-08) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, node degree, and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # 1. Newtonian Attraction\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # 2. Inverse Distance\n    inverse_distance = 1 / safe_distance_matrix\n\n    # 3. Node Degree: Favor edges connecting to nodes with fewer connections\n    degree = np.sum(distance_matrix < np.mean(distance_matrix), axis=1)\n    degree_matrix = np.outer(degree, degree)\n    degree_factor = 1 / (degree_matrix + epsilon)\n\n    # 4. Combine Components\n    heuristics = newtonian_weight * newtonian + inverse_distance_weight * inverse_distance + degree_factor_weight * degree_factor\n\n    # 5. Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # 6. Sparsification: Dynamic threshold\n    threshold = np.percentile(heuristics, sparsification_percentile)\n    heuristics[heuristics < threshold] = 0\n\n    # Ensure diagonal is zero.\n    np.fill_diagonal(heuristics, 0)\n\n    return heuristics\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, newtonian_weight: float = 0.05733624735160625, inverse_distance_weight: float = 0.7780862255376683,\n                  degree_factor_weight: float = 0.35960339383159123, sparsification_percentile: float = 39.00219557601301,\n                  epsilon: float = 5.434469300548452e-08) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, node degree, and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # 1. Newtonian Attraction\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # 2. Inverse Distance\n    inverse_distance = 1 / safe_distance_matrix\n\n    # 3. Node Degree: Favor edges connecting to nodes with fewer connections\n    degree = np.sum(distance_matrix < np.mean(distance_matrix), axis=1)\n    degree_matrix = np.outer(degree, degree)\n    degree_factor = 1 / (degree_matrix + epsilon)\n\n    # 4. Combine Components\n    heuristics = newtonian_weight * newtonian + inverse_distance_weight * inverse_distance + degree_factor_weight * degree_factor\n\n    # 5. Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # 6. Sparsification: Dynamic threshold\n    threshold = np.percentile(heuristics, sparsification_percentile)\n    heuristics[heuristics < threshold] = 0\n\n    # Ensure diagonal is zero.\n    np.fill_diagonal(heuristics, 0)\n\n    return heuristics\n\n[Heuristics 12th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, newtonian_weight: float = 0.05733624735160625, inverse_distance_weight: float = 0.7780862255376683,\n                  degree_factor_weight: float = 0.35960339383159123, sparsification_percentile: float = 39.00219557601301,\n                  epsilon: float = 5.434469300548452e-08) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, node degree, and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # 1. Newtonian Attraction\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # 2. Inverse Distance\n    inverse_distance = 1 / safe_distance_matrix\n\n    # 3. Node Degree: Favor edges connecting to nodes with fewer connections\n    degree = np.sum(distance_matrix < np.mean(distance_matrix), axis=1)\n    degree_matrix = np.outer(degree, degree)\n    degree_factor = 1 / (degree_matrix + epsilon)\n\n    # 4. Combine Components\n    heuristics = newtonian_weight * newtonian + inverse_distance_weight * inverse_distance + degree_factor_weight * degree_factor\n\n    # 5. Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # 6. Sparsification: Dynamic threshold\n    threshold = np.percentile(heuristics, sparsification_percentile)\n    heuristics[heuristics < threshold] = 0\n\n    # Ensure diagonal is zero.\n    np.fill_diagonal(heuristics, 0)\n\n    return heuristics\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Newtonian Heuristic for TSP Edge Prioritization.\n\n    This heuristic combines elements inspired by gravitational attraction and\n    energy minimization to guide TSP solution sampling.  Edges connecting nodes\n    that are \"attracted\" to each other more strongly (closer distance, higher\n    pseudo-mass) are favored. A term discouraging long edges (high potential\n    energy) is also included.\n\n    Args:\n        distance_matrix (np.ndarray): A symmetric numpy array representing the\n            pairwise distances between cities. distance_matrix[i, j] is the\n            distance between city i and city j.\n\n    Returns:\n        np.ndarray: A matrix of the same shape as distance_matrix, representing\n            the heuristic \"promise\" of each edge. Higher values indicate\n            more promising edges.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Avoid division by zero by adding a small epsilon to distances.\n    epsilon = 1e-9\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # Gravitational attraction component (inverse square law): cities closer together are more attracted\n    attraction = 1 / (safe_distance_matrix**2)\n\n    # Node \"mass\" proxy: how \"central\" is a city. We assign mass using degree centrality:\n    # sum the inverse distance to all other cities. A city close to many others is more important.\n\n    mass = np.sum(1 / safe_distance_matrix, axis=1) #mass of the city\n\n    # Create a matrix M[i][j] = mass[i]*mass[j]\n    M = np.outer(mass, mass)\n\n    # Potential energy penalty: long edges are less desirable. Scale to be compatible with the 'gravitational' term\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix) # normalized distance\n\n\n    heuristics = (attraction * M) / potential_energy\n\n    # Normalize to range [0, 1] for numerical stability and interpretability, and to bound effect during search\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n\n\n    return heuristics\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, node degree consideration,\n    and sparsification for TSP edge prioritization.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    epsilon = 1e-9\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # 1. Newtonian Attraction Component\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # 2. Inverse Distance Component\n    inverse_distance = 1 / safe_distance_matrix\n\n    # 3. Node Degree Consideration: Favor edges connecting to nodes with fewer connections\n    degree = np.sum(distance_matrix < np.mean(distance_matrix), axis=1) # Rough degree estimate. Lower is better\n    degree_matrix = np.outer(degree, degree)\n    degree_factor = 1 / (degree_matrix + epsilon)\n    # degree_factor = (degree_factor - np.min(degree_factor)) / (np.max(degree_factor) - np.min(degree_factor)) # Normalize\n\n    # 4. Combine Components (Experiment with weights)\n    heuristics = 0.5 * newtonian + 0.3 * inverse_distance + 0.2 * degree_factor\n\n    # 5. Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # 6. Sparsification: Set less promising edges to zero (Dynamic threshold)\n    threshold = np.percentile(heuristics, 20)  # Keep top 80% of edges, experiment with values. Could be parameter.\n    heuristics[heuristics < threshold] = 0\n\n    # Ensure diagonal is zero.\n    np.fill_diagonal(heuristics, 0)\n\n    return heuristics\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, node degree consideration,\n    and sparsification for TSP edge prioritization.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    epsilon = 1e-9\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # 1. Newtonian Attraction Component\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # 2. Inverse Distance Component\n    inverse_distance = 1 / safe_distance_matrix\n\n    # 3. Node Degree Consideration: Favor edges connecting to nodes with fewer connections\n    degree = np.sum(distance_matrix < np.mean(distance_matrix), axis=1) # Rough degree estimate. Lower is better\n    degree_matrix = np.outer(degree, degree)\n    degree_factor = 1 / (degree_matrix + epsilon)\n    # degree_factor = (degree_factor - np.min(degree_factor)) / (np.max(degree_factor) - np.min(degree_factor)) # Normalize\n\n    # 4. Combine Components (Experiment with weights)\n    heuristics = 0.5 * newtonian + 0.3 * inverse_distance + 0.2 * degree_factor\n\n    # 5. Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # 6. Sparsification: Set less promising edges to zero (Dynamic threshold)\n    threshold = np.percentile(heuristics, 20)  # Keep top 80% of edges, experiment with values. Could be parameter.\n    heuristics[heuristics < threshold] = 0\n\n    # Ensure diagonal is zero.\n    np.fill_diagonal(heuristics, 0)\n\n    return heuristics\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, node degree consideration,\n    and sparsification for TSP edge prioritization.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    epsilon = 1e-9\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # 1. Newtonian Attraction Component\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # 2. Inverse Distance Component\n    inverse_distance = 1 / safe_distance_matrix\n\n    # 3. Node Degree Consideration: Favor edges connecting to nodes with fewer connections\n    degree = np.sum(distance_matrix < np.mean(distance_matrix), axis=1) # Rough degree estimate. Lower is better\n    degree_matrix = np.outer(degree, degree)\n    degree_factor = 1 / (degree_matrix + epsilon)\n    # degree_factor = (degree_factor - np.min(degree_factor)) / (np.max(degree_factor) - np.min(degree_factor)) # Normalize\n\n    # 4. Combine Components (Experiment with weights)\n    heuristics = 0.5 * newtonian + 0.3 * inverse_distance + 0.2 * degree_factor\n\n    # 5. Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # 6. Sparsification: Set less promising edges to zero (Dynamic threshold)\n    threshold = np.percentile(heuristics, 20)  # Keep top 80% of edges, experiment with values. Could be parameter.\n    heuristics[heuristics < threshold] = 0\n\n    # Ensure diagonal is zero.\n    np.fill_diagonal(heuristics, 0)\n\n    return heuristics\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, node degree consideration,\n    and sparsification for TSP edge prioritization.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    epsilon = 1e-9\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # 1. Newtonian Attraction Component\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # 2. Inverse Distance Component\n    inverse_distance = 1 / safe_distance_matrix\n\n    # 3. Node Degree Consideration: Favor edges connecting to nodes with fewer connections\n    degree = np.sum(distance_matrix < np.mean(distance_matrix), axis=1) # Rough degree estimate. Lower is better\n    degree_matrix = np.outer(degree, degree)\n    degree_factor = 1 / (degree_matrix + epsilon)\n    # degree_factor = (degree_factor - np.min(degree_factor)) / (np.max(degree_factor) - np.min(degree_factor)) # Normalize\n\n    # 4. Combine Components (Experiment with weights)\n    heuristics = 0.5 * newtonian + 0.3 * inverse_distance + 0.2 * degree_factor\n\n    # 5. Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # 6. Sparsification: Set less promising edges to zero (Dynamic threshold)\n    threshold = np.percentile(heuristics, 20)  # Keep top 80% of edges, experiment with values. Could be parameter.\n    heuristics[heuristics < threshold] = 0\n\n    # Ensure diagonal is zero.\n    np.fill_diagonal(heuristics, 0)\n\n    return heuristics\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Newtonian attraction, inverse distance, node degree consideration,\n    and sparsification for TSP edge prioritization.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    epsilon = 1e-9\n    safe_distance_matrix = distance_matrix + epsilon\n\n    # 1. Newtonian Attraction Component\n    attraction = 1 / (safe_distance_matrix**2)\n    mass = np.sum(1 / safe_distance_matrix, axis=1)\n    M = np.outer(mass, mass)\n    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)\n    newtonian = (attraction * M) / potential_energy\n\n    # 2. Inverse Distance Component\n    inverse_distance = 1 / safe_distance_matrix\n\n    # 3. Node Degree Consideration: Favor edges connecting to nodes with fewer connections\n    degree = np.sum(distance_matrix < np.mean(distance_matrix), axis=1) # Rough degree estimate. Lower is better\n    degree_matrix = np.outer(degree, degree)\n    degree_factor = 1 / (degree_matrix + epsilon)\n    # degree_factor = (degree_factor - np.min(degree_factor)) / (np.max(degree_factor) - np.min(degree_factor)) # Normalize\n\n    # 4. Combine Components (Experiment with weights)\n    heuristics = 0.5 * newtonian + 0.3 * inverse_distance + 0.2 * degree_factor\n\n    # 5. Normalize\n    min_heuristic = np.min(heuristics)\n    max_heuristic = np.max(heuristics)\n    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)\n\n    # 6. Sparsification: Set less promising edges to zero (Dynamic threshold)\n    threshold = np.percentile(heuristics, 20)  # Keep top 80% of edges, experiment with values. Could be parameter.\n    heuristics[heuristics < threshold] = 0\n\n    # Ensure diagonal is zero.\n    np.fill_diagonal(heuristics, 0)\n\n    return heuristics\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    return 1 / distance_matrix\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    return 1 / distance_matrix\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}