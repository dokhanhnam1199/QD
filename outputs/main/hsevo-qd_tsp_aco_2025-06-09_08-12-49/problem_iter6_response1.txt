```python
import numpy as np

epsilon = 1e-6
attraction_weight = 0.5
inverse_distance_weight = 0.5


def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines Newtonian attraction, inverse distance, and node degree for TSP edge prioritization.
    Sparsifies the matrix by setting unpromising elements to zero based on distance.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    safe_distance_matrix = distance_matrix + epsilon

    # Newtonian attraction component
    attraction = 1 / (safe_distance_matrix**2)
    mass = np.sum(1 / safe_distance_matrix, axis=1)
    M = np.outer(mass, mass)
    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)
    newtonian = (attraction * M) / potential_energy

    # Inverse distance component
    inverse_distance = 1 / safe_distance_matrix

    # Node degree component (prioritize edges connecting low-degree nodes)
    degree = np.sum(distance_matrix > 0, axis=1)  # Count neighbors, consider 0 distance as neighbor
    degree_matrix = np.outer(1 / (degree + epsilon), 1 / (degree + epsilon)) #Use epsilon to avoid zero division

    # Combine the components
    heuristics = (
        0.4 * newtonian
        + 0.4 * inverse_distance
        + 0.2 * degree_matrix
    )  # Adjusted weights

    # Sparsify the matrix: zero out edges with distances significantly above average
    mean_distance = np.mean(distance_matrix)
    sparsification_threshold = 2 * mean_distance  #Adjust the threshold
    heuristics[distance_matrix > sparsification_threshold] = 0

    # Normalize the heuristics to [0, 1]
    min_heuristic = np.min(heuristics)
    max_heuristic = np.max(heuristics)
    if max_heuristic - min_heuristic > 1e-9:  # Avoid division by (near) zero
        heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)
    else:
        heuristics = np.ones_like(heuristics) * 0.5 #Assign all edges equal probability

    return heuristics
```
