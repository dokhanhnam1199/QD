```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for the Traveling Salesman Problem (TSP). This version considers
    the distance, a measure of "clustering" by finding the average distance
    to k-nearest neighbors, and randomness.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance
                                        matrix between cities. distance_matrix[i][j]
                                        is the distance between city i and city j.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix,
                    where each element represents the heuristic value for
                    including the corresponding edge in the TSP tour. Higher
                    values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)
    k = min(5, n - 1)  # Consider at most 5 nearest neighbors or n-1 if n < 6

    for i in range(n):
        distances = distance_matrix[i, :]
        nearest_neighbors_indices = np.argsort(distances)[1:k+1]  # Exclude itself (distance 0)
        avg_nearest_neighbor_distance = np.mean(distances[nearest_neighbors_indices])

        for j in range(n):
            if i != j:
                # Heuristic combines:
                # 1. Inverse distance: Shorter distances are more desirable
                # 2. Clustering: Cities clustered together are more likely to be in the tour
                # 3. Randomness: Helps escape local optima
                heuristic_matrix[i, j] = (1 / distance_matrix[i, j]) + \
                                         (1 / avg_nearest_neighbor_distance) + \
                                         np.random.uniform(0, 0.1)  # Add a small random value

    return heuristic_matrix
```
