```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Enhanced heuristics combining Newtonian attraction, pheromone trails,
    and edge proximity with sparsification for TSP edge prioritization.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    epsilon = 1e-6  # For numerical stability
    safe_distance_matrix = distance_matrix + epsilon

    # 1. Newtonian Attraction (as in v1)
    attraction = 1 / (safe_distance_matrix**2)
    mass = np.sum(1 / safe_distance_matrix, axis=1)
    M = np.outer(mass, mass)
    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)
    newtonian = (attraction * M) / potential_energy

    # 2. Pheromone Trail Analogy (inspired by Ant Colony Optimization)
    #    Simulate pheromone trails based on short paths.  Edges on
    #    multiple short paths get higher pheromone values.  We approximate
    #    this by considering paths of length 2.
    pheromone = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Find the shortest path from i to j via any intermediate node k
                shortest_path_ij = np.inf
                for k in range(n):
                    if i != k and j != k:
                        path_length = safe_distance_matrix[i, k] + safe_distance_matrix[k, j]
                        shortest_path_ij = min(shortest_path_ij, path_length)
                pheromone[i, j] = 1 / (shortest_path_ij + epsilon)  # Inverse path length as pheromone

    # 3. Edge Proximity: Favor edges connecting to geographically close nodes.
    #    Nodes with many close neighbors are more likely to be part of a dense,
    #    important cluster.
    proximity = np.zeros_like(distance_matrix)
    neighbor_threshold = np.mean(distance_matrix)  # Define "close" relative to mean distance
    for i in range(n):
        num_close_neighbors_i = np.sum(distance_matrix[i, :] < neighbor_threshold)
        for j in range(n):
            num_close_neighbors_j = np.sum(distance_matrix[j, :] < neighbor_threshold)
            proximity[i, j] = num_close_neighbors_i + num_close_neighbors_j

    # 4. Combine Components with Weights
    attraction_weight = 0.4
    pheromone_weight = 0.3
    proximity_weight = 0.3
    heuristics = (
        attraction_weight * newtonian
        + pheromone_weight * pheromone
        + proximity_weight * proximity
    )

    # 5. Sparsification: Zero out unpromising edges
    sparsification_threshold = np.percentile(heuristics, 20)  # Keep top 80%
    heuristics[heuristics < sparsification_threshold] = 0

    # 6. Normalize
    min_heuristic = np.min(heuristics)
    max_heuristic = np.max(heuristics)
    if max_heuristic > min_heuristic:  # Avoid division by zero
        heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)
    else:
        heuristics = np.ones_like(heuristics)  # all values are the same

    return heuristics
```
