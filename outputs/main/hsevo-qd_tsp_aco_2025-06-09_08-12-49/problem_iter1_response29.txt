```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Implements a heuristic for the Traveling Salesman Problem (TSP)
    based on a combination of distance, node degree (connectivity),
    and randomness to encourage exploration.
    """

    n = distance_matrix.shape[0]

    # Initialize the heuristic matrix with the inverse of the distances.
    # Small distances are considered more promising. Add a small epsilon
    # to prevent division by zero.
    heuristic_matrix = 1 / (distance_matrix + 1e-9)

    # Node Degree Consideration:
    # Nodes that are connected to many other nodes (high degree) might be
    # good hubs, so prioritize edges connected to them. Approximate node
    # degree by summing inverse distances (higher sum indicates higher connectivity)
    node_degrees = np.sum(heuristic_matrix, axis=1, keepdims=True) + np.sum(heuristic_matrix, axis=0, keepdims=True)

    heuristic_matrix = heuristic_matrix * np.sqrt(node_degrees * node_degrees.T)


    # Introduce randomness to encourage exploration and prevent premature convergence.
    # The level of randomness is adjusted based on the problem size, larger problem, more randomness
    randomness_factor = 0.1 + min(0.9,n / 100.0)
    random_matrix = np.random.rand(n, n) * randomness_factor
    heuristic_matrix = heuristic_matrix + random_matrix

    # Penalize going back to the same node directly. This helps break short cycles.
    np.fill_diagonal(heuristic_matrix, 0)

    # Normalize the heuristic matrix to be between 0 and 1 (approximately).
    heuristic_matrix = heuristic_matrix / np.max(heuristic_matrix)

    return heuristic_matrix
```
