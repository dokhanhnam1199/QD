```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Newtonian Heuristic for TSP Edge Prioritization.

    This heuristic combines elements inspired by gravitational attraction and
    energy minimization to guide TSP solution sampling.  Edges connecting nodes
    that are "attracted" to each other more strongly (closer distance, higher
    pseudo-mass) are favored. A term discouraging long edges (high potential
    energy) is also included.

    Args:
        distance_matrix (np.ndarray): A symmetric numpy array representing the
            pairwise distances between cities. distance_matrix[i, j] is the
            distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing
            the heuristic "promise" of each edge. Higher values indicate
            more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Avoid division by zero by adding a small epsilon to distances.
    epsilon = 1e-9
    safe_distance_matrix = distance_matrix + epsilon

    # Gravitational attraction component (inverse square law): cities closer together are more attracted
    attraction = 1 / (safe_distance_matrix**2)

    # Node "mass" proxy: how "central" is a city. We assign mass using degree centrality:
    # sum the inverse distance to all other cities. A city close to many others is more important.

    mass = np.sum(1 / safe_distance_matrix, axis=1) #mass of the city

    # Create a matrix M[i][j] = mass[i]*mass[j]
    M = np.outer(mass, mass)

    # Potential energy penalty: long edges are less desirable. Scale to be compatible with the 'gravitational' term
    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix) # normalized distance


    heuristics = (attraction * M) / potential_energy

    # Normalize to range [0, 1] for numerical stability and interpretability, and to bound effect during search
    min_heuristic = np.min(heuristics)
    max_heuristic = np.max(heuristics)
    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)



    return heuristics
```
