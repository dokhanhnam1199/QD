```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A heuristic function for the Traveling Salesman Problem (TSP) that estimates the
    promise of including each edge in the optimal solution.  This version incorporates
    ideas of nearest neighbor and avoids very long edges.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i][j]
            represents the distance between city i and city j.  Diagonal elements
            (distance from a city to itself) are ignored or assumed to be 0.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each
            element [i][j] indicates the heuristic value (promise) of including
            the edge between city i and city j in the solution.  Higher values
            indicate greater promise.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Calculate nearest neighbor distances for each city.  The shorter distances are better
    nearest_neighbor_distances = np.zeros(n)
    for i in range(n):
        # Exclude the distance from the city to itself when finding the nearest neighbor
        distances = distance_matrix[i, :]
        distances_without_self = np.copy(distances)
        distances_without_self[i] = np.inf  # Set distance to self to infinity to exclude it
        nearest_neighbor_distances[i] = np.min(distances_without_self)

    # Normalize nearest neighbor distance, smaller value indicates better heuristic.
    nearest_neighbor_distances_normalized = 1.0 / (nearest_neighbor_distances + 1e-9) # Adding a small epsilon to avoid division by zero

    # Heuristic based on combining (inverse) distance and nearest neighbor information.
    # Incorporate nearest neighbor concept:
    # For each pair of cities, if both are relatively close to their nearest neighbor,
    # increase the promise of connecting them. This prioritizes edges between dense locations
    # or smaller distances
    for i in range(n):
        for j in range(n):
            if i != j:  # Exclude edges from a city to itself

                # Higher if the edge is shorter, and higher if *both* cities are near their nearest neighbors
                # Prioritize shorter distance in the result.
                heuristics[i, j] = (1.0 / (distance_matrix[i, j] + 1e-9)) * np.sqrt(nearest_neighbor_distances_normalized[i] * nearest_neighbor_distances_normalized[j])

                # Avoid very long edges. Even a nearby neighbor may be better than very long edge.
                # If distance significantly larger than the average distances, penalize. This helps prevent extremely long
                # edges to enter the calculation.
                average_distance = np.mean(distance_matrix) # can replace with median to deal with outliers
                if distance_matrix[i, j] > 2 * average_distance:
                    heuristics[i, j] *= 0.1  # Significantly reduce promise

    return heuristics
```
