```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improved heuristics for the Traveling Salesman Problem (TSP).
    Combines several ideas to provide more informative edge priors.

    Args:
        distance_matrix: A numpy array representing the pairwise distances
                         between cities. distance_matrix[i, j] is the distance
                         from city i to city j.

    Returns:
        A numpy array of the same shape as distance_matrix, where each
        element represents a heuristic score indicating the desirability
        of including the corresponding edge in a TSP tour. Higher scores
        indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance (like v1, but handle zeros)
    safe_distance_matrix = distance_matrix.copy()
    safe_distance_matrix[safe_distance_matrix == 0] = np.inf  # Avoid division by zero
    heuristics = 1.0 / safe_distance_matrix

    # 2. Nearest neighbor bonus:
    #    Favor edges connecting a city to its nearest neighbors.
    for i in range(n):
        # Find the indices of the k nearest neighbors of city i
        k = min(5, n - 1)  # consider at most the 5 nearest, and at most n-1 neighbours.
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k+1]  # Exclude itself (index i)
        for j in nearest_neighbors:
            heuristics[i, j] += 0.5  # Add a bonus for nearest neighbors
            heuristics[j, i] += 0.5  # Ensure symmetry

    # 3. Avoid long edges penalty: Amplification
    max_dist = np.max(distance_matrix[distance_matrix != np.inf])
    heuristics = heuristics * np.exp(-distance_matrix / (max_dist / 3))

    # 4. Normalize (optional, but can be helpful)
    heuristics = (heuristics - np.min(heuristics)) / (np.max(heuristics) - np.min(heuristics))

    return heuristics
```
