```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Enhanced heuristics for TSP edge prioritization, combining Newtonian attraction,
    inverse distance, and a node connectivity bias. Includes sparsification.
    """
    epsilon = 1e-6  # Small constant to avoid division by zero

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    safe_distance_matrix = distance_matrix + epsilon

    # Newtonian attraction component (modified)
    attraction = 1 / (safe_distance_matrix**2)
    mass = np.sum(1 / safe_distance_matrix, axis=1)
    M = np.outer(mass, mass)
    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)
    newtonian = (attraction * M) / (potential_energy + epsilon)  # Added epsilon to potential_energy

    # Inverse distance component
    inverse_distance = 1 / safe_distance_matrix

    # Node connectivity bias: prioritize edges connecting poorly connected nodes
    node_degrees = np.sum(1 / safe_distance_matrix, axis=0)  # Number of close neighbors
    degree_matrix = np.outer(1 / (node_degrees + epsilon), 1 / (node_degrees + epsilon)) # Prioritize edges between low degree nodes
    connectivity_bias = degree_matrix

    attraction_weight = 0.4
    inverse_distance_weight = 0.3
    connectivity_weight = 0.3

    # Combine the components
    heuristics = (attraction_weight * newtonian +
                  inverse_distance_weight * inverse_distance +
                  connectivity_weight * connectivity_bias)

    # Normalize
    min_heuristic = np.min(heuristics)
    max_heuristic = np.max(heuristics)
    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic + epsilon)

    # Sparsify: set low-priority edges to zero
    threshold = np.mean(heuristics) * 0.2  # Only keep edges above a fraction of the mean. Experiment with this value
    heuristics[heuristics < threshold] = 0

    return heuristics
```
