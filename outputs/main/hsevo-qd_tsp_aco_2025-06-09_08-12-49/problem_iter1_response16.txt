```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Stephen Hawking's heuristics for Traveling Salesman Problem.

    Inspired by the concept of gravitational lensing near black holes and stochastic processes
    governed by quantum fluctuations, this heuristic prioritizes shorter distances but also
    introduces a probabilistic element to encourage exploration of potentially longer but
    less-traveled edges, mirroring the unpredictable paths of particles near a singularity.

    It combines the inverse of distance with a random fluctuation modulated by the overall
    "compactness" of the distance matrix.  A more compact (smaller distances overall) network
    gets stronger random fluctuations to encourage novel solutions, as a stronger 'gravitational'
    field permits more extreme lensing and hence 'shortcuts' in the solution space.

    Args:
        distance_matrix (np.ndarray): Distance matrix representing the distances between nodes.

    Returns:
        np.ndarray: Heuristic matrix indicating the desirability of including each edge.
    """

    # Avoid division by zero and inf values (although not strictly necessary given TSP context).
    distance_matrix = np.where(distance_matrix == 0, 1e-9, distance_matrix)

    # Base heuristic: inverse distance
    heuristic_matrix = 1 / distance_matrix

    # Calculate a "compactness" factor representing the average distance.
    compactness_factor = np.mean(distance_matrix)

    # Introduce random fluctuations, scaled by the compactness factor.
    # A smaller compactness_factor (denser graph) means more randomness
    # is injected, enabling "quantum tunneling" or exploring non-obvious routes.

    random_fluctuations = np.random.rand(*distance_matrix.shape) / (1 + compactness_factor)

    # Combine the inverse distance with the random fluctuations.
    # The relative weighting favors shorter distances while still permitting
    # exploration driven by randomness, as a form of simulated quantum annealing
    heuristic_matrix = heuristic_matrix + random_fluctuations

    #Ensure no nans
    heuristic_matrix = np.nan_to_num(heuristic_matrix, nan = 0.0, posinf = 0.0, neginf=0.0)


    return heuristic_matrix
```
