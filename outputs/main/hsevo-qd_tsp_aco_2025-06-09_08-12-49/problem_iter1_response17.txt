```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for Traveling Salesman Problem using a combination of inverse distance and a "gravitational" attraction.
    Edges connecting to nodes that are "far" from the centroid of all nodes are penalized, simulating a bias towards a central cluster.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i, j] is the distance between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing prior indicators. Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to prevent division by zero

    # Node coordinates (assuming distance represents a similarity or reverse distance, generate virtual locations)
    coords = np.random.rand(n, 2)  # Random coordinates, a more robust fallback

    # Calculate centroid
    centroid = np.mean(coords, axis=0)

    # Calculate distances from each node to the centroid
    node_centroid_distances = np.linalg.norm(coords - centroid, axis=1)

    # Scale node-centroid distances to be between 0 and 1, with the largest distance mapped to 1
    max_node_centroid_distance = np.max(node_centroid_distances)
    normalized_node_centroid_distances = node_centroid_distances / (max_node_centroid_distance + 1e-9)


    # Gravitational attraction factor.  Nodes farther from centroid are penalized
    attraction_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            attraction_matrix[i, j] = 1 - (normalized_node_centroid_distances[i] + normalized_node_centroid_distances[j]) / 2  # Penalize long-range edges between distant nodes


    # Combine inverse distance with "gravitational" attraction
    heuristics = inverse_distance * attraction_matrix
    return heuristics
```
