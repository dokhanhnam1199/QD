```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improved heuristics for TSP based on a combination of factors.
    This version attempts to balance distance, connectivity,
    and the potential for a penalty if a node becomes too "isolated".

    Args:
        distance_matrix (np.ndarray): A square matrix where element [i, j]
                                     represents the distance between node i and node j.
                                     Should not contain zero values on non-diagonal elements.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element
                     represents the heuristic value (higher is better) for including
                     the corresponding edge in a TSP tour.  Diagonals are set to zero.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance (like v1, but handle potential zeros gracefully).
    #    We add a small constant to avoid division by zero *and* dampen extreme distances.
    #    This helps avoid getting "stuck" on one or two very short edges early.
    epsilon = 1e-6  # A very small constant
    heuristics = 1.0 / (distance_matrix + epsilon)

    # 2. Node Connectivity Bonus
    #    Nodes with fewer close neighbors should be encouraged to connect to *any* neighbor
    #    to ensure they are part of the tour.  This adds a "desperation" factor for poorly
    #    connected nodes.  Calculated based on average distance to neighbors.
    neighbor_distances = np.sum(distance_matrix, axis=1) / (n - 1)  # Average distance to other nodes
    for i in range(n):
        for j in range(n):
            if i != j:
                 heuristics[i, j] *= (1.0 + 0.1 * (np.mean(neighbor_distances) / neighbor_distances[i])) #Scale by average dist

    # 3. Encourage inclusion of edges that bridge between far away components
    #    If nodes i and j are far from all *other* nodes, they are more likely to connect directly.
    #    Penalize edges where BOTH endpoints already have very close neighbors -- these probably
    #    create short loops.  This tries to build a full tour rather than little local loops.
    for i in range(n):
        for j in range(n):
            if i != j:
                # Calculate how "isolated" node i and node j are
                isolation_i = np.mean(distance_matrix[i, :])  # Avg distance from node i to all others
                isolation_j = np.mean(distance_matrix[j, :])  # Avg distance from node j to all others

                #Adjust heuristic according to isolation -- larger adjustment if BOTH are relatively isolated.
                heuristics[i, j] += 0.05 * (isolation_i + isolation_j) / np.mean(neighbor_distances)

    #4 Set diagonals to zero
    for i in range(n):
        heuristics[i, i] = 0

    #Normalize and return
    heuristics = heuristics / np.max(heuristics) #Ensures values are 0-1

    return heuristics
```
