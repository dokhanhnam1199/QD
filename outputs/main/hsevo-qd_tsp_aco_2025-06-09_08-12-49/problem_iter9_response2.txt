```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines Newtonian attraction with inverse distance and a sparsification strategy for TSP edge prioritization.
    """
    epsilon = 1e-9  # Small constant to prevent division by zero

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    safe_distance_matrix = distance_matrix + epsilon

    # Newtonian attraction component
    attraction = 1 / (safe_distance_matrix**2)
    mass = np.sum(1 / safe_distance_matrix, axis=1)
    M = np.outer(mass, mass)
    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)
    newtonian = (attraction * M) / potential_energy

    # Inverse distance component
    inverse_distance = 1 / safe_distance_matrix

    # Combined score with weights, refined
    attraction_weight = 0.6
    inverse_distance_weight = 0.4
    combined_score = attraction_weight * newtonian + inverse_distance_weight * inverse_distance

    # Sparsification strategy based on percentile.
    percentile_threshold = 75  # Keep top percentile edges
    threshold = np.percentile(combined_score[np.triu_indices_from(combined_score, k=1)], percentile_threshold) #ignore diagonal
    sparsified_matrix = np.where(combined_score >= threshold, combined_score, 0)

    # Normalize
    min_heuristic = np.min(sparsified_matrix[np.triu_indices_from(sparsified_matrix, k=1)]) #only min of upper triangle
    max_heuristic = np.max(sparsified_matrix[np.triu_indices_from(sparsified_matrix, k=1)]) #only max of upper triangle
    if max_heuristic > min_heuristic: #Avoid division by zero
        heuristics = (sparsified_matrix - min_heuristic) / (max_heuristic - min_heuristic)
    else:
        heuristics = sparsified_matrix #if all values are the same, keep them.

    return heuristics
```
