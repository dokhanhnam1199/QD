```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines Newtonian attraction, inverse distance, and pheromone influence with sparsification for TSP edge prioritization.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    epsilon = 1e-9  # Small constant to avoid division by zero
    safe_distance_matrix = distance_matrix + epsilon

    # Newtonian attraction component
    attraction = 1 / (safe_distance_matrix**2)
    mass = np.sum(1 / safe_distance_matrix, axis=1)
    M = np.outer(mass, mass)
    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)
    newtonian = (attraction * M) / potential_energy

    # Inverse distance component
    inverse_distance = 1 / safe_distance_matrix

    # Pheromone influence (simulated) - favor edges connected to high-degree nodes
    degree = np.sum(1 / safe_distance_matrix, axis=1)
    pheromone = np.outer(degree, degree)

    # Combine the components with adjusted weights
    attraction_weight = 0.4
    inverse_distance_weight = 0.3
    pheromone_weight = 0.3
    heuristics = (
        attraction_weight * newtonian
        + inverse_distance_weight * inverse_distance
        + pheromone_weight * pheromone
    )

    # Sparsification: Zero out less promising edges based on a dynamic threshold
    threshold_factor = 0.5 # Adjust to control sparseness (higher = less sparse)
    threshold = threshold_factor * np.mean(heuristics)
    heuristics[heuristics < threshold] = 0

    # Normalize non-zero heuristics
    non_zero_indices = heuristics > 0
    if np.any(non_zero_indices):  # Check if there are any non-zero elements
        min_heuristic = np.min(heuristics[non_zero_indices])
        max_heuristic = np.max(heuristics[non_zero_indices])
        heuristics[non_zero_indices] = (heuristics[non_zero_indices] - min_heuristic) / (max_heuristic - min_heuristic)


    return heuristics
```
