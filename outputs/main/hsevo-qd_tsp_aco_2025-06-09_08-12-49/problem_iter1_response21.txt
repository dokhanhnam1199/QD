```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Generates heuristics for the Traveling Salesman Problem based on distance.

    This function combines several heuristics to provide a more informed
    estimate of edge desirability than a simple inverse distance.  It considers:

    1.  Inverse distance: Shorter edges are generally more desirable.
    2.  Node degree desirability: Nodes connected to many other nodes via short
        distances should be considered carefully to avoid early commitments
        to suboptimal paths. A node with only one short edge is highly constrained,
        meaning that edge is highly preferred.
    3.  Distance to nearest neighbor: Edges leading to the nearest neighbors
        are likely to be part of a good solution.

    Args:
        distance_matrix (np.ndarray): A square matrix where
            distance_matrix[i, j] is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where
            each element represents a heuristic value for the corresponding edge.
            Higher values indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # 1. Inverse distance
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero
    heuristics += inverse_distance

    # 2. Node degree desirability (penalize connections to highly connected nodes)
    neighbor_strength = np.sum(inverse_distance, axis=1, keepdims=True) + np.sum(inverse_distance, axis=0, keepdims=True)
    heuristics /= (neighbor_strength + 1e-9)  # Avoid division by zero

    # 3. Distance to nearest neighbor
    for i in range(n):
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:4]  # Exclude self and take top 3
        for j in range(n):
            if j in nearest_neighbors:
                heuristics[i, j] *= 1.2  # Boost edges to nearest neighbors.

    # Make the heurisitics be within range [0,1]
    heuristics = (heuristics - np.min(heuristics)) / (np.max(heuristics) - np.min(heuristics) + 1e-9)

    return heuristics
```
