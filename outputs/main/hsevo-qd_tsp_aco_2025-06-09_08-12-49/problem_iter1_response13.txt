```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Generates heuristics for the Traveling Salesman Problem (TSP) based on a combination of inverse distance and node degree consideration.
    Edges connected to nodes with fewer overall close neighbors are prioritized.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                     distance_matrix[i, j] is the distance from city i to city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, containing heuristic values for each edge.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Calculate node attractiveness based on inverse distance and neighborhood density
    for i in range(n):
        for j in range(n):
            if i != j:
                # Basic heuristic: Inverse distance
                heuristics[i, j] = 1 / distance_matrix[i, j]

                # Adjust based on node "degree" within a certain radius (number of nearby cities)
                radius = np.mean(distance_matrix[i, :])  # Dynamic radius: mean distance from the city
                nearby_cities = np.sum(distance_matrix[i, :] <= radius) -1 # -1 to exclude itself

                # Nodes with fewer nearby cities are potentially more "isolated" and should be prioritized for connection,
                # because if it is included in final path, the path tend to be shorter.
                # Added smoothing term to avoid division by zero, as well as the inverse to be more proper prior of probability
                heuristics[i, j] *= 1 / (nearby_cities + 1e-6) # Adding 1e-6 for numerical stability

    return heuristics
```
