```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics function for the Traveling Salesman Problem (TSP) based on distance,
    degree, and triangle inequality approximation.  Inspired by the celestial orbits,
    where closer bodies exert greater influence, and stable configurations (triangles)
    are favored.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                       distance_matrix[i][j] is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element represents
                    a heuristic value indicating the desirability of including the corresponding edge
                    in the TSP tour. Higher values indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Initialize with inverse distance, as shorter distances are generally better.
    heuristic_matrix = 1 / (distance_matrix + 1e-9) # Added a small constant to avoid division by zero.

    # Degree adjustment:  Cities connected to very few others are more likely to be crucial.
    # Penalize high-degree nodes and favor low-degree nodes based on inverse distance to neighbors.
    degree_penalty = np.zeros(n)
    for i in range(n):
        neighbor_distances = distance_matrix[i, :]
        neighbor_distances[i] = np.inf  # Exclude self
        degree_penalty[i] = np.sum(1 / (neighbor_distances + 1e-9)) # Smaller inverse distance to more cities increases penalty.

    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] /= (degree_penalty[i] + degree_penalty[j] + 1e-9)**0.5  # Penalize connections where both nodes have a high degree, mildly

    # Triangle Inequality Heuristic:
    # If using edge (i, j) makes it hard to find other shorter paths, penalize it.
    # For each possible third city k, if distance(i,k) + distance(k,j) is significantly
    # greater than distance(i,j), then the edge (i,j) is more "useful" in the grand scheme.
    # We encourage selecting "useful" connections.  I seek to minimize such additions
    for i in range(n):
        for j in range(n):
            if i != j:
                triangle_advantage = 0
                for k in range(n):
                    if k != i and k != j:
                        triangle_advantage += (distance_matrix[i, k] + distance_matrix[k, j] - distance_matrix[i, j])
                heuristic_matrix[i, j] *= (triangle_advantage + 1)**0.1 # Scaling this for limited influence.  Ensure advantage is positive.

    return heuristic_matrix
```
