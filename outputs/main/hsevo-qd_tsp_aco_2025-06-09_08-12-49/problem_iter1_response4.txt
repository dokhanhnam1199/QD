```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Nikola Tesla's Edge Evaluation Heuristic for TSP (Version 2).

    This heuristic assesses the desirability of including each edge in a TSP solution.
    It considers a combination of inverse distance, the average distance to other nodes
    from each endpoint of the edge, and a 'gravitational' pull between nearby nodes.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between nodes.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, with values indicating
                     the desirability (higher is better) of including each edge.  Diagonal
                     elements are set to zero to prevent self-loops.  Zero distances also result in
                     zero indicator.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Average distance from each node to all other nodes
    avg_distances = np.mean(distance_matrix, axis=1)

    for i in range(n):
        for j in range(n):
            if i == j or distance_matrix[i, j] == 0:
                heuristic_matrix[i, j] = 0  # No self-loops, and zero distances disallowed
            else:
                # Inverse distance: Shorter is better
                inverse_distance = 1 / distance_matrix[i, j]

                # Penalize edges connected to nodes far from the rest of the graph
                node_proximity_penalty = 1 / (avg_distances[i] * avg_distances[j])**0.5

                # 'Gravitational' pull: nodes closer together attract each other more strongly
                # This enhances the preference for short edges between nodes in dense regions.
                gravitational_factor = np.exp(-distance_matrix[i, j] / (avg_distances[i] + avg_distances[j]))


                heuristic_matrix[i, j] = inverse_distance * node_proximity_penalty * gravitational_factor
    return heuristic_matrix
```
