```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Tesla's Enhanced Heuristic for Traveling Salesman Problem.

    This heuristic combines several strategies to estimate the desirability
    of including each edge in the final TSP solution.  It considers:

    1.  **Inverse Distance:** Shorter distances are generally more desirable.
    2.  **Node Centrality (Degree Approximation):**  Nodes with high degree
        (connected to many other nodes closely) may be good connectors. We use inverse distance
        sum as a proxy for node importance.
    3.  **Variance Dampening:** Dampens high-variance distances.
    4.  **Proximity Amplification:** Gives a boost to distances that link
        nodes "close" to many others.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances
                                      between cities.  distance_matrix[i, j] is the
                                      distance from city i to city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each
                    element represents the desirability (heuristic value) of
                    including the corresponding edge in the TSP tour. Higher
                    values indicate a more promising edge.
    """

    # Add a small constant to avoid division by zero
    epsilon = 1e-9
    distance_matrix = distance_matrix + epsilon

    # 1. Inverse Distance (Basic desirability based on distance)
    inverse_distance = 1 / distance_matrix

    # 2. Node Centrality (Degree Approximation)
    node_importance = np.sum(inverse_distance, axis=0, keepdims=True) + np.sum(inverse_distance, axis=1, keepdims=True) # Sum of inverse distances for each node

    # Normalize node_importance to [0, 1]
    node_importance_normalized = (node_importance - np.min(node_importance)) / (np.max(node_importance) - np.min(node_importance) + epsilon)

    # Combine node importances; consider both source and dest importance for each edge.
    edge_importance = node_importance_normalized + node_importance_normalized.T
    # 3. Variance Dampening
    std_dev = np.std(distance_matrix)
    variance_factor = np.exp(-distance_matrix / std_dev)


    # 4. Proximity Amplification: Give a boost to edges connecting nodes near each other.
    proximity = np.zeros_like(distance_matrix)
    for i in range(distance_matrix.shape[0]):
        for j in range(distance_matrix.shape[1]):
          # sum all row distances + column distances, remove i and j for the consideration.
            row_sum = np.sum(distance_matrix[i,:]) - distance_matrix[i,i]
            col_sum = np.sum(distance_matrix[:,j]) - distance_matrix[j,j]
            proximity[i, j] = np.exp(-(row_sum + col_sum)/np.sum(distance_matrix))  # Nodes which are overall near other node. We want them connected.

    # Combine all heuristics using weighted sum
    heuristic_matrix = (
        0.4 * inverse_distance +
        0.3 * edge_importance +
        0.1 * variance_factor +
        0.2 * proximity

    )
    # Make sure no NaN value by clipping very small or large values.
    heuristic_matrix = np.nan_to_num(heuristic_matrix, nan=0.0)
    heuristic_matrix = np.clip(heuristic_matrix, a_min=0.0, a_max=1e10)

    return heuristic_matrix
```
