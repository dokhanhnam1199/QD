```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines Newtonian attraction with inverse distance and adds a sparsity component based on shortest paths.
    """
    epsilon = 1e-6  # Add a small constant to avoid division by zero

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    safe_distance_matrix = distance_matrix + epsilon

    # Newtonian attraction component
    attraction = 1 / (safe_distance_matrix**2)
    mass = np.sum(1 / safe_distance_matrix, axis=1)
    M = np.outer(mass, mass)
    potential_energy = safe_distance_matrix / np.mean(safe_distance_matrix)
    newtonian = (attraction * M) / potential_energy

    # Inverse distance component
    inverse_distance = 1 / safe_distance_matrix

    attraction_weight = 0.6
    inverse_distance_weight = 0.4

    # Combine the two components
    heuristics = attraction_weight * newtonian + inverse_distance_weight * inverse_distance

    # Shortest path component (Sparsity)
    shortest_path_matrix = np.zeros_like(distance_matrix)
    for i in range(n):
        distances = distance_matrix[i].copy()
        distances[i] = np.inf  # Exclude self-loops

        # Get the indices of the k-nearest neighbors for each node
        k = min(5, n - 1)  # Consider up to 5 nearest neighbors, but adjust if n < 5
        nearest_neighbor_indices = np.argsort(distances)[:k]

        # Set shortest_path_matrix to 1 for the edges to these neighbors.
        for j in nearest_neighbor_indices:
             shortest_path_matrix[i, j] = 1
             shortest_path_matrix[j, i] = 1 # Ensure Symmetry


    # Combine with shortest path information to sparsify
    heuristics = heuristics * shortest_path_matrix

    # Normalize
    min_heuristic = np.min(heuristics)
    max_heuristic = np.max(heuristics)
    if max_heuristic - min_heuristic > 0:
        heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)
    else:
        heuristics = np.zeros_like(heuristics)  # Handle the case where all values are the same.

    return heuristics
```
