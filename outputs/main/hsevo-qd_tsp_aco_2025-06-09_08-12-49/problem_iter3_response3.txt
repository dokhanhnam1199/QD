```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines several factors to determine how promising it is to select an edge for TSP,
    including inverse distance, node degree, and a sparsification strategy.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    epsilon = 1e-9
    safe_distance_matrix = distance_matrix + epsilon

    # 1. Inverse Distance: More promising for shorter distances
    inverse_distance = 1 / safe_distance_matrix

    # 2. Node Degree: Penalize high-degree nodes early on to avoid local optima.
    #    Nodes with low degree should be prioritized.
    node_degree_preference = np.zeros_like(distance_matrix)
    for i in range(n):
        # Sum of inverse distances connected to node i (higher = more connections)
        node_connections = inverse_distance[i, :].sum() + inverse_distance[:, i].sum()
        for j in range(n):
            if i != j:
                node_degree_preference[i, j] = 1 / (node_connections + epsilon)  # low degree -> high preference

    # 3. Combination of factors with weights
    heuristics = 0.6 * inverse_distance + 0.4 * node_degree_preference

    # 4. Sparsification: Set less promising edges to zero to guide the search.
    #    Keep only the top k edges for each node, where k is a parameter.
    k = int(np.sqrt(n))  # Adjust k dynamically based on problem size
    for i in range(n):
        row = heuristics[i, :]
        # Find the indices of the k largest values in the row
        indices = np.argpartition(row, -k)[-k:]
        # Set all other values in the row to zero
        mask = np.ones(n, dtype=bool)
        mask[indices] = False
        heuristics[i, mask] = 0.0

    # 5. Normalization
    min_heuristic = np.min(heuristics)
    max_heuristic = np.max(heuristics)
    if max_heuristic - min_heuristic > 1e-9:  # Avoid division by zero
        heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)

    return heuristics
```
