```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines several factors, including pheromone trails, visibility (inverse distance),
    node degree preference, and a sparsification technique, for TSP edge prioritization.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    epsilon = 1e-9
    safe_distance_matrix = distance_matrix + epsilon

    # 1. Pheromone Trails (simulated - initially uniform)
    pheromone = np.ones_like(distance_matrix)  # Initialize pheromone trails

    # 2. Visibility (Inverse Distance)
    visibility = 1 / safe_distance_matrix

    # 3. Node Degree Preference
    degree_preference = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Encourage connections to nodes with lower average distance to others
                avg_dist_i = np.mean(safe_distance_matrix[i, :])
                avg_dist_j = np.mean(safe_distance_matrix[j, :])

                degree_preference[i, j] = 1 / (avg_dist_i + avg_dist_j + epsilon) # prefer connections with lower average dist
                #degree_preference[i, j] = np.exp(-distance_matrix[i,j]/np.mean(distance_matrix))

    # 4. Combine Factors (weighted)
    alpha = 1.0  # Pheromone weight
    beta = 2.0   # Visibility weight
    gamma = 0.5  # Degree preference weight

    heuristics = (pheromone**alpha) * (visibility**beta) * (degree_preference**gamma)

    # 5. Sparsification (remove unpromising edges)
    threshold = np.percentile(heuristics[heuristics > 0], 40)  # Keep top 60% of edges
    heuristics[heuristics < threshold] = 0.0

    # Normalize
    min_heuristic = np.min(heuristics[heuristics > 0]) if np.any(heuristics > 0) else 0.0
    max_heuristic = np.max(heuristics)
    if max_heuristic > min_heuristic:
        heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)
    else:
        heuristics = np.zeros_like(heuristics)  # Handle the case where all values are the same

    return heuristics
```
