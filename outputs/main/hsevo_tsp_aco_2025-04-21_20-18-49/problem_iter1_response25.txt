```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Galileo's TSP Heuristics v2: An improved approach considering distance and node degree.

    This heuristic prioritizes edges based on a combination of factors:
    1. Inverse distance: Shorter edges are initially favored (similar to v1).
    2. Node degree equalization:  A penalty is applied to edges connecting to nodes 
       that already have many short connections.  This encourages the exploration of less-connected regions, 
       preventing premature convergence to local optima where only a subset of nodes is well-connected.  
       It mimics the observation that the solar system requires careful balance and placement to avoid collisions and maintain stable orbits; a planet cannot be arbitrarily close to too many other planets.
    3. Random perturbation: Introduce slight random noise for better exploration.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix 
                                       where distance_matrix[i][j] is the distance between node i and node j.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix, 
                    representing the heuristic values (prior indicators) for each edge.  
                    Higher values indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance (as a base heuristic)
    heuristic_matrix = 1.0 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # 2. Node degree equalization penalty.  A node with many short connections should be penalized.
    # Compute the 'degree' of each node based on the inverse distance
    node_degrees = np.sum(heuristic_matrix, axis=0)  # Sum of inverse distances for each node.
    # Adjust heuristics based on the degrees of the nodes connected by an edge
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] /= (node_degrees[i] * node_degrees[j])**0.25 #Penalize edges connected to high degree nodes
                #We'll also penalize edges connecting two high degree nodes.
                #sqrt to avoid over-penalizing. Experiment with powers to tune behavior.


    # 3. Add random noise to prevent getting stuck in local optima
    noise = np.random.normal(0, 0.01, size=(n, n))
    heuristic_matrix += noise
    
    #Normalize the heuristic to be between zero and one (optional, but sometimes beneficial)
    max_val = np.max(heuristic_matrix)
    min_val = np.min(heuristic_matrix)
    heuristic_matrix = (heuristic_matrix - min_val) / (max_val - min_val) if (max_val > min_val) else np.ones_like(heuristic_matrix) #Avoid division by zero


    return heuristic_matrix
```
