```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for the Traveling Salesman Problem, designed with inspiration
    from black hole physics and stochastic sampling.  The approach considers
    the distance as an inverse measure of 'gravitational' attraction,
    and introduces a stochastic element to diversify the search space.

    Args:
        distance_matrix: A numpy array representing the distance matrix between cities.

    Returns:
        A numpy array of the same shape as distance_matrix, representing the
        heuristic values (probabilities) for each edge being included in the solution.
    """

    n = distance_matrix.shape[0]

    # 1. Inverse Distance: Shorter distances are more attractive, akin to stronger gravity.
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))  # Adding identity to avoid division by zero on diagonal

    # 2. Node Degree Prior: Nodes with overall shorter distances to others are preferred.
    node_attractiveness = np.sum(inverse_distance, axis=1)  # Total 'gravity' from each node

    # 3. Edge Reinforcement:  Amplify the attraction between highly attractive nodes.
    edge_reinforcement = np.outer(node_attractiveness, node_attractiveness)

    # 4. Stochastic Perturbation: Introduce noise to explore alternative routes.
    # A small random perturbation helps escape local optima.  Magnitude is inversely proportional
    # to node degree centrality, favoring exploration of edges connected to less central nodes
    # since these edges are more often neglected by greedy algorithms.
    perturbation_magnitude = 0.1 / (node_attractiveness.mean() + node_attractiveness)
    stochastic_noise = np.random.normal(0, perturbation_magnitude, size=(n, n))
    stochastic_noise = (stochastic_noise + stochastic_noise.T)/2 #Symmetrize noise.

    # 5. Combine factors: Integrate distance, node attractivenss, and stochasticity.
    heuristic_matrix = inverse_distance * edge_reinforcement + stochastic_noise

    # 6. Normalize: Convert to probabilities, ensuring all values are between 0 and 1.
    min_val = np.min(heuristic_matrix)
    max_val = np.max(heuristic_matrix)

    heuristic_matrix = (heuristic_matrix - min_val) / (max_val - min_val)


    return heuristic_matrix
```
