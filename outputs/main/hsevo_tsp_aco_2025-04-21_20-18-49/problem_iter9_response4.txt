```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray,
                  distance_importance: float = 1.0,
                  centrality_importance: float = 0.5,
                  clustering_importance: float = 0.2,
                  sparsification_factor: float = 3.0,
                  temperature_factor: float = 0.1) -> np.ndarray:
    """Enhanced heuristics using distance, centrality, clustering, and adaptive sparsification."""
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Distance component
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))
    normalized_distance = inverse_distance / np.max(inverse_distance) if np.max(inverse_distance) > 0 else np.zeros_like(inverse_distance)

    # 2. Centrality component (degree centrality approximation)
    node_centrality = np.sum(inverse_distance, axis=0)
    normalized_centrality = node_centrality / np.max(node_centrality) if np.max(node_centrality) > 0 else np.zeros_like(node_centrality)

    # 3. Clustering component (Local density approximation - higher is better)
    clustering_coefficients = np.zeros(n)
    for i in range(n):
        neighbors = np.where(inverse_distance[i] > 0)[0]
        k = len(neighbors)
        if k > 1:
            edges_between_neighbors = 0
            for u in range(k):
                for v in range(u + 1, k):
                    if inverse_distance[neighbors[u], neighbors[v]] > 0:
                        edges_between_neighbors += 1
            clustering_coefficients[i] = 2.0 * edges_between_neighbors / (k * (k - 1))
        else:
            clustering_coefficients[i] = 0.0  # Isolated node

    normalized_clustering = clustering_coefficients / np.max(clustering_coefficients) if np.max(clustering_coefficients) > 0 else np.zeros_like(clustering_coefficients)

    # Temperature based on median or mean
    temperature = np.median(distance_matrix) * temperature_factor

    # Combine components with weights and temperature
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics[i, j] = (normalized_distance[i, j]**distance_importance) * \
                                   ((normalized_centrality[i] * normalized_centrality[j])**centrality_importance) * \
                                   ((normalized_clustering[i] * normalized_clustering[j])**clustering_importance) * \
                                   np.exp(-distance_matrix[i, j] / temperature)

    # Adaptive sparsification (dynamic threshold)
    threshold = np.mean(heuristics) / sparsification_factor
    heuristics[heuristics < threshold] = 0

    return heuristics
```
