```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Generates heuristics for the Traveling Salesman Problem based on a combination of distance
    and nearest neighbor considerations. A pinch of stochasticity is added, as favored by the gods.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i, j] is the distance
                                      between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element represents
                    a heuristic value (higher value indicates a more promising edge). Diagonal elements are set to 0.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # 1. Inverse Distance (as a base)
    inverse_distance = 1.0 / (distance_matrix + 1e-6)  # Avoid division by zero

    # 2. Nearest Neighbor Heuristic
    nearest_neighbors = np.argsort(distance_matrix, axis=1)

    for i in range(n):
        # Encourage edges to the nearest neighbors
        for j_index in range(1, min(4, n)):  # consider the closest 3 neighbors besides self
            j = nearest_neighbors[i, j_index]
            heuristics[i, j] += 0.5 # Enhance the probability

    # 3. Distance Factor: Dampen long edges
    distance_factor = np.exp(-distance_matrix / np.mean(distance_matrix))

    # 4. Combine heuristics, favoring short edges connected to neighbors
    heuristics = inverse_distance * (1 + heuristics) * distance_factor

    # Set diagonal elements to zero
    for i in range(n):
        heuristics[i, i] = 0.0

    return heuristics
```
