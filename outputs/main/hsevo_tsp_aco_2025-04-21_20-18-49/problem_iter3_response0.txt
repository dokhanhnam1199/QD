```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A heuristics function for the Traveling Salesman Problem (TSP), building upon v1.

    This version incorporates the ideas from v1, plus adds a sparsity component
    and refines the node attractiveness calculation and temperature scaling.

    It aims to balance exploration with exploitation and incorporates a mechanism
    to sparsify the search space by zeroing out low-probability edges.

    Args:
        distance_matrix (np.ndarray): The distance matrix representing the distances
                                         between cities.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing the
                     prior probabilities of including each edge in a solution. Higher
                     values indicate a higher prior probability.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)
    temperature = np.mean(distance_matrix) / 4  # More aggressive temperature

    # Inverse distance, avoid division by zero
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))

    # Node degree desirability (attractiveness) - Refined calculation
    node_attractiveness = np.sum(inverse_distance, axis=0)
    node_attractiveness = 1.0 / (node_attractiveness / np.mean(node_attractiveness)) #Inverse normalized attractiveness

    #Edge attractiveness calculation.  Using node attractivness as a 'pull' force.
    edge_attractiveness = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                edge_attractiveness[i, j] = (node_attractiveness[i] * node_attractiveness[j])

    #Combine Inverse Distance and Edge Attractiveness and apply temp scaling.
    heuristics = (inverse_distance**2) * edge_attractiveness * np.exp(-distance_matrix / temperature)
    # Sparsify the matrix: zero out edges with low probabilities
    threshold = np.mean(heuristics) / 5  #Dynamic Threshold
    heuristics[heuristics < threshold] = 0.0


    return heuristics
```
