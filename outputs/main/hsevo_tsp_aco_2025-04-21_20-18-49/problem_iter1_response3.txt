```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improved heuristics for TSP edge selection based on a combination of
    distance, nearest neighbors, and global connectivity.  It encourages
    the selection of edges connecting nearby nodes, especially those with
    few connections to other nodes in the graph. It addresses the problem of
    `heuristics_v1` by also considering node degree.  Higher score signifies a more
    promising edge.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance component
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Adding small constant to avoid division by zero
    heuristics += inverse_distance

    # 2. Nearest Neighbor Component: Prioritize Edges to nearest neighbors
    for i in range(n):
        # Find the 'n_neighbors' nearest neighbors for node i, excluding itself.
        n_neighbors = min(5, n - 1)  # Consider a limited number of neighbors (up to 5, but no more than total number of nodes minus 1)

        neighbors = np.argsort(distance_matrix[i, :])[1:n_neighbors + 1] # indices of nearest neighbor, skip the first one as its the index itself.
        for j in neighbors:
            heuristics[i, j] += 1.0 # Increase weight for edges connecting node i with its neighbors
            heuristics[j, i] += 1.0 # Ensuring the value is reciprocal.

    # 3. Connectivity Component: Favor edges to nodes with low degree/ connectivity
    degree = np.sum(inverse_distance > 0, axis=0) # consider all entries as connected
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics[i, j] += (1.0 / (degree[i] + degree[j] + 1e-9)) # adding a degree penalty to higher degree nodes

    # 4. Normalize the heuristics
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics /= max_val  # Scale to [0, 1]

    return heuristics
```
