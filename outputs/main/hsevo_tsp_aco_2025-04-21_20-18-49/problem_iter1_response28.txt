```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A heuristic function for the Traveling Salesman Problem (TSP).

    This heuristic combines several strategies to estimate the "promise" of each edge
    in the distance matrix.  It prioritizes shorter distances, edges connecting to
    nodes with high average distance (encouraging exploration), and applies a
    stochastic element for diversity.

    Args:
        distance_matrix: A NumPy array representing the pairwise distances between nodes.
            distance_matrix[i, j] is the distance between node i and node j.

    Returns:
        A NumPy array of the same shape as distance_matrix, where each element
        indicates the "promise" of including the corresponding edge in a TSP solution.
        Higher values indicate a more promising edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Invert distances (shorter distances are more promising)
    inverted_distances = 1.0 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # Calculate average distance for each node
    avg_distances = np.mean(distance_matrix, axis=0)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Heuristic component 1: Inverted distance
                h1 = inverted_distances[i, j]

                # Heuristic component 2: "Importance" of connecting to nodes with higher average distance
                # (Encourages exploration)
                h2 = (avg_distances[i] + avg_distances[j])

                # Combine heuristics and add stochastic noise
                heuristic_matrix[i, j] = h1 + h2 #+ np.random.normal(0, 0.1)

    # Normalize heuristic values to be between 0 and 1 (optional, but good practice)
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0: # avoid division by 0
        heuristic_matrix = heuristic_matrix / max_heuristic
    else:
        heuristic_matrix = np.ones_like(distance_matrix)  #handle degenerate case

    return heuristic_matrix
```
