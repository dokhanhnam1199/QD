```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP based on a combination of inverse distance and node degree.
    Prioritizes shorter distances and edges connecting to nodes with lower degrees
    (nodes visited less frequently in optimal/good solutions).  Also adds random noise
    to encourage exploration.

    Args:
        distance_matrix: A numpy ndarray representing the distance matrix.

    Returns:
        A numpy ndarray of the same shape as distance_matrix,
        representing the heuristic scores for each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance: shorter distances are more promising
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add a small value to avoid division by zero
    heuristic_matrix = inverse_distance


    # Node degree: prioritize connecting to less visited nodes
    # (initially assume all nodes are equally important)

    # Initial node priorities -- consider how far from the mean each city is,
    # and favor nodes with far higher or lower than avg distances.  This may or may not help,
    # but let's try it as something 'physical'.

    node_priority = np.zeros(n)
    for i in range(n):
      node_priority[i] = np.sum(distance_matrix[i,:])  #total distance from a node


    # normalize them so it helps steer us away from
    # going back and forth from nodes repeatedly due to short hop distances:
    node_priority = (node_priority - np.mean(node_priority)) / (np.std(node_priority) + 1e-9)

    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] += 0.1 * (node_priority[i] + node_priority[j]) #* inverse_distance[i,j]

    # Add random noise for exploration
    noise = np.random.rand(n, n) * 0.01 # Scale noise
    heuristic_matrix += noise

    # Mask out diagonal elements, important!
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
