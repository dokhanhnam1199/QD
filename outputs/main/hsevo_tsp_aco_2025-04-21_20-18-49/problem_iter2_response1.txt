```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """TSP heuristic combining inverse distance, degree desirability, & decay."""

    n = distance_matrix.shape[0]
    epsilon = 1e-9

    # Inverse distance
    inverse_distance = 1.0 / (distance_matrix + epsilon)

    # Node degree desirability (attractiveness of less-connected nodes)
    node_degrees = np.sum(inverse_distance, axis=0)
    degree_heuristic = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            degree_heuristic[i, j] = 1.0 / (node_degrees[i] + node_degrees[j] + epsilon)

    # Combine inverse distance and degree desirability
    combined_heuristic = inverse_distance * degree_heuristic

    # Simulate "radioactive decay" to favor shorter edges probabilistically
    half_life = np.median(distance_matrix) # Use median distance as a reference for decay
    decay_factor = np.log(2) / half_life
    edge_probabilities = combined_heuristic * np.exp(-decay_factor * distance_matrix)

    # Rank-based normalization
    ranks = np.argsort(edge_probabilities, axis=None)
    ranks = np.unravel_index(ranks, edge_probabilities.shape)
    normalized_heuristic = np.zeros_like(distance_matrix, dtype=float)
    normalized_heuristic[ranks] = np.linspace(0, 1, n * n)

    return normalized_heuristic
```
