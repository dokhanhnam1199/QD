```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    An enhanced heuristics function for the Traveling Salesman Problem (TSP).

    This version builds upon heuristics_v1 by incorporating additional strategies
    to refine edge prioritization and promote efficient exploration of the solution space.

    Key improvements include:
    1.  Adaptive Temperature: The temperature parameter adjusts based on the specific
        distance distribution of the input, allowing the heuristic to adapt to varying
        problem scales.
    2.  Neighborhood Consideration: The algorithm considers the distances to the *k* nearest
        neighbors of each node when evaluating edge desirability. This encourages
        connections within local clusters.
    3.  Sparsification: Edges deemed unlikely to be part of an optimal solution (based on
        a threshold derived from the mean distance) are set to zero, reducing the search
        space and focusing sampling on more promising regions. This sparsification
        improves efficiency and prevents being trapped in local optima too early.
    4. Distance Rank: Instead of pure distance, the rank of distances is used.
    5. Revisit penalty: Add a penalty to edges that create two-cycles.

    Args:
        distance_matrix (np.ndarray): The distance matrix representing the distances
                                         between cities.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing the
                     prior probabilities of including each edge in a solution. Higher
                     values indicate a higher prior probability.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Adaptive temperature based on distance distribution
    mean_distance = np.mean(distance_matrix)
    std_distance = np.std(distance_matrix)
    temperature = mean_distance + std_distance / 2 # Adjust temperature adaptively

    # Sparsification threshold
    sparsification_threshold = 2 * mean_distance

    # k-Nearest Neighbors (k=5)
    k = min(5, n - 1)  # Ensure k is within bounds
    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:k+1] # Exclude self

    # Distance Rank
    distance_ranks = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        temp = distance_matrix[i,:].argsort()
        ranks = np.empty_like(temp)
        ranks[temp] = np.arange(len(distance_matrix[i,:]))
        distance_ranks[i,:] = ranks

    # Heuristic computation
    for i in range(n):
        for j in range(n):
            if i != j:
                # Prioritize shorter edges
                edge_priority = np.exp(-distance_matrix[i, j] / temperature)

                # Neighborhood consideration: are i and j close to each other's neighbors?
                neighbor_factor = 0.0
                if j in nearest_neighbors[i, :]:
                    neighbor_factor += 0.5
                if i in nearest_neighbors[j, :]:
                    neighbor_factor += 0.5
                edge_priority += neighbor_factor

                # Distance rank
                edge_priority /= (distance_ranks[i,j] + 1)

                # Two-cycle penalty
                two_cycle_penalty = 0.0
                #heuristics[i,j] should not equal heuristics[j,i] so it does not cause issues
                if distance_matrix[i,j] > 1.5*distance_matrix[j,i]:
                    two_cycle_penalty = -0.2

                edge_priority += two_cycle_penalty

                heuristics[i, j] = edge_priority

    # Sparsification
    heuristics[distance_matrix > sparsification_threshold] = 0.0
    np.fill_diagonal(heuristics, 0) #Ensure no self loops

    return heuristics
```
