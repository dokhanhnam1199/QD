```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines inverse distance, nearest neighbor, and exploration.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance
    heuristics = 1.0 / (distance_matrix + 1e-9)

    # 2. Nearest Neighbor Influence
    for i in range(n):
        temp_distances = distance_matrix[i].copy()
        temp_distances[i] = np.inf
        nearest_neighbor = np.argmin(temp_distances)
        heuristics[i, nearest_neighbor] *= 1.75
        heuristics[nearest_neighbor, i] *= 1.75

    # 3. Node Degree Preference with exploration
    node_degree_preference = np.zeros_like(distance_matrix)
    inverse_distance = 1 / (distance_matrix + 1e-9)

    for i in range(n):
        for j in range(n):
            if i != j:
                node_degree_preference[i, j] = (np.sum(inverse_distance[i, :]) + np.sum(inverse_distance[j, :]))/2

    stochastic_perturbation = np.random.normal(0, 0.05, size=(n, n))
    heuristics = (0.8 * heuristics +
                         0.2 * (1/node_degree_preference) +
                         0.1 * stochastic_perturbation)
    heuristics[np.isinf(heuristics)] = 0

    return heuristics
```
