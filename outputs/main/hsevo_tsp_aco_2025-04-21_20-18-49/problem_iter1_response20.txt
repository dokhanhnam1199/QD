```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for TSP based on a combination of distance, node degree,
    and a stochastic component to encourage exploration.

    Args:
        distance_matrix: A numpy array representing the distance matrix between cities.

    Returns:
        A numpy array of the same shape as distance_matrix, representing the
        heuristic values for each edge. Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]

    # Avoid division by zero and self-loops by setting diagonal to infinity
    temp_matrix = distance_matrix.copy()
    np.fill_diagonal(temp_matrix, np.inf)

    # 1. Inverse Distance:  Shorter distances are generally better.
    inverse_distance = 1 / temp_matrix

    # 2. Node Degree Preference: Prefer edges connected to nodes with fewer connections
    #    already selected (simulating a form of constraint satisfaction).
    #    This is approximated using the sum of inverse distances from each node.
    node_degree_preference = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:  # Avoid self-loops
                node_degree_preference[i, j] = (np.sum(inverse_distance[i, :]) + np.sum(inverse_distance[j, :]))/2

    # 3. Stochastic Perturbation: Add a small amount of random noise to encourage exploration
    #    and prevent getting stuck in local optima.  The magnitude of the noise is scaled
    #    by the mean inverse distance to avoid dominating the signal.
    mean_inverse_distance = np.mean(inverse_distance[np.isfinite(inverse_distance)])
    stochastic_perturbation = np.random.normal(0, 0.1 * mean_inverse_distance, size=(n, n))


    # 4. Combine the heuristics.  Experiment with weights to adjust the influence of each component.
    heuristic_matrix = (0.7 * inverse_distance +
                         0.2 * (1/node_degree_preference) + #inverse as higher node degree indicates less preference
                         0.1 * stochastic_perturbation)
    # Set diagonal to zero to avoid self-loops
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
