```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Generates heuristics for the Traveling Salesman Problem based on distance.

    This version combines several heuristics:
    1. Inverse distance: Shorter distances are generally more desirable.
    2. Node degree normalization: Encourages edges connected to nodes with fewer connections.
    3. Random perturbation: Introduces exploration by adding random noise.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance heuristic
    inverse_distance = 1 / (distance_matrix + 1e-6)  # Add a small constant to avoid division by zero

    # 2. Node degree normalization heuristic
    degree = np.sum(inverse_distance > 0, axis=0)  # approximate node degree based on inverse distance
    node_factor = np.outer(1 / (degree + 1e-6), 1 / (degree + 1e-6)) # favor nodes with smaller degree and prefer balanced edges
    node_factor = np.sqrt(node_factor)

    # 3. Random perturbation heuristic
    random_perturbation = np.random.rand(n, n) * 0.1 # random values between 0 and 0.1

    heuristic_matrix = inverse_distance * node_factor + random_perturbation
    return heuristic_matrix
```
