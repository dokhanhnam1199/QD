```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Generates heuristics for the Traveling Salesman Problem (TSP) based on stochastic solution sampling principles.
    This version incorporates several ideas inspired by physics and observations.

    Args:
        distance_matrix: A numpy array representing the distance between cities.
                         distance_matrix[i, j] is the distance from city i to city j.

    Returns:
        A numpy array of the same shape as distance_matrix, representing the desirability of including each edge in the solution.
        Higher values indicate more desirable edges.
    """
    n = distance_matrix.shape[0]  # Number of cities

    # 1. Inverse Distance (Gravitational Analogy): Closer cities are more likely to be connected.
    heuristic_matrix = 1.0 / (distance_matrix + 1e-9)  # Adding a small value to prevent division by zero

    # 2. City Centrality (Hubs): Cities that are "central" (e.g., have short average distances to other cities) are more likely to be hubs.
    city_centrality = np.sum(distance_matrix, axis=0)  # Sum of distances from each city to all other cities (lower is better)
    city_centrality = 1.0 / (city_centrality + 1e-9)
    # Strengthen connections to/from central cities
    for i in range(n):
        heuristic_matrix[i, :] *= city_centrality[i]
        heuristic_matrix[:, i] *= city_centrality[i]

    # 3. Random Perturbation (Thermodynamic Fluctuations): Introduce some randomness to allow exploration of suboptimal solutions, similar to simulated annealing
    random_noise = np.random.rand(n, n) * 0.1  # Small random values
    heuristic_matrix += random_noise

    # 4. "Momentum" (Short-term memory): If an edge is good, keep it good. This is a very crude attempt to keep useful components after perturbation
    # Not implemented this time for complexity and focus on other ideas

    # 5. Normalize the values: Scales all the heuristics to the range [0, 1] for better stability.
    heuristic_matrix = (heuristic_matrix - np.min(heuristic_matrix)) / (np.max(heuristic_matrix) - np.min(heuristic_matrix) + 1e-9)

    return heuristic_matrix
```
