```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A heuristic function for the Traveling Salesman Problem (TSP) based on a combination of
    inverse distance, node degree estimation, and simulated annealing inspired smoothing.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix
                                       between nodes.  distance_matrix[i, j] gives the
                                       distance between node i and node j.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix, where each
                      element represents a prior indicator of how promising it is to
                      include the corresponding edge in a solution. Higher values
                      indicate more promising edges.
    """
    n = distance_matrix.shape[0]

    # 1. Inverse Distance: Closer nodes are generally preferred.
    inverse_distance = 1.0 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero.

    # 2. Node Degree Estimation:  Prefer edges that connect to nodes with lower "connectivity".
    #    This encourages exploration and avoids prematurely focusing on a small subset of nodes.
    node_connectivity = np.sum(inverse_distance, axis=0)
    edge_desirability = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                edge_desirability[i, j] = (node_connectivity[i] + node_connectivity[j])  # Sum the inverse distances from i and j.

    # Normalize edge desirability to [0, 1]. Invert to make lower values more desirable
    edge_desirability = (edge_desirability - np.min(edge_desirability)) / (np.max(edge_desirability) - np.min(edge_desirability) + 1e-9)  # Avoid division by zero
    edge_desirability = 1 - edge_desirability


    # 3. Simulated Annealing-Inspired Smoothing:
    #    Blur the desirability scores a bit. This encourages the algorithm to
    #    occasionally explore edges that are not the absolute best locally,
    #    which can help escape local optima.

    temperature = 0.1  # Higher temperature leads to more smoothing
    smoothed_desirability = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
             # Weight the average by temperature
            smoothed_desirability[i,j] = (inverse_distance[i, j] * (1-temperature) +  temperature * np.mean(inverse_distance[i,:])) # Blend edge's desirablity with node i's mean

    # 4. Combine the heuristics:  Balance exploration and exploitation.
    heuristic_matrix = inverse_distance * (1-temperature) + temperature * (1 / (distance_matrix + 1e-6) * edge_desirability)

    return heuristic_matrix
```
