```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improved heuristics for TSP based on a combination of inverse distance,
    nearest neighbor considerations, and randomness.

    This version attempts to capture:
    1. Shorter edges are more likely to be good (inverse distance).
    2. Edges that connect a node to one of its nearest neighbors are good.
    3. Introduce a small element of randomness to encourage exploration
       and avoid getting stuck in local optima.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Inverse distance component, with a small constant to avoid division by zero
    heuristics = 1 / (distance_matrix + 1e-9)

    # Nearest neighbor component
    for i in range(n):
        # Find the nearest neighbors for node i
        neighbors = np.argsort(distance_matrix[i, :])
        # Exclude itself.  The first element will always be i.
        neighbors = neighbors[1:]
        # Consider only the 'k' nearest neighbors for simplicity and speed
        k = min(3, n - 1)  # Consider at most 3 nearest neighbors.
        for j in neighbors[:k]:  # Iterate through nearest neighbors.
            heuristics[i, j] += 0.5  # Boost heuristic for connections to near neighbors
            heuristics[j, i] += 0.5 # Ensure symmetry

    # Introduce randomness
    randomness = np.random.rand(n, n) * 0.1 # small random number between 0 and 0.1.
    heuristics += randomness

    # Normalize heuristics.
    max_val = np.max(heuristics)
    heuristics = heuristics / max_val

    return heuristics
```
