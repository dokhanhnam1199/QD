```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A heuristic function for the Traveling Salesman Problem (TSP) that leverages
    a combination of inverse distance, a measure of centrality (degree),
    and a randomized perturbation to encourage exploration.  Inspired by the
    physics of black holes:  gravity (inverse distance) combined with some
    quantum fluctuations (random noise) around the event horizon.

    Args:
        distance_matrix: A numpy ndarray representing the distance matrix between cities.

    Returns:
        A numpy ndarray of the same shape as distance_matrix, representing the
        heuristic values for each edge. Higher values indicate a more promising edge.
    """

    # 1. Inverse distance:  Edges with shorter distances are more attractive.
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add small constant to avoid division by zero.

    # 2. Node degree:  Preferentially connect to nodes with a high "degree" in terms of nearness.
    # This approximates a "gravitational pull" towards more connected areas.  We consider
    # all other nodes' inverse distances to a given node as its "degree".
    node_degrees = np.sum(inverse_distance, axis=0) # Sum columns to get degree of each node
    degree_matrix_a = np.tile(node_degrees, (distance_matrix.shape[0], 1)) # Row repeats node degrees
    degree_matrix_b = np.tile(node_degrees.reshape(-1, 1), (1, distance_matrix.shape[1])) # Col repeats node degrees
    degree_influence = degree_matrix_a * degree_matrix_b # interaction of two degrees on the connection strength

    # 3. Random perturbation: Introduce stochasticity to escape local optima.
    # This simulates quantum fluctuations around a black hole's event horizon,
    # allowing for exploration of less-obvious paths.  We scale the randomness
    # based on the inverse distance to balance exploration and exploitation.
    random_perturbation = np.random.rand(*distance_matrix.shape) * inverse_distance * 0.1

    # Combine the heuristics.
    heuristic_matrix = inverse_distance + degree_influence + random_perturbation

    return heuristic_matrix
```
