import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, attractiveness_exponent: float = 2.4789623255165383,
                  sparsification_factor: float = 9.88445783431673) -> np.ndarray:
    """
    A more sophisticated heuristics function for the Traveling Salesman Problem (TSP).

    This version builds upon heuristics_v1 by incorporating several enhancements:

    1.  Adaptive Temperature: The temperature parameter is adjusted dynamically based on
        the distribution of distances in the matrix. This allows the heuristic to adapt
        to different problem scales and structures.

    2.  Node Centrality Penalty: Nodes with high centrality (i.e., nodes that are close to
        many other nodes) are penalized. This encourages the algorithm to explore paths that
        don't necessarily pass through the most central locations, potentially leading to
        more efficient routes.

    3.  Sparsification: Edges with very low desirability are set to zero, effectively
        sparsifying the heuristics matrix. This can help to focus the search on a smaller
        set of promising edges and improve computational efficiency.

    4. Edge-Betweenness Prior: Edges that bridge disparate clusters are favored.

    Args:
        distance_matrix (np.ndarray): The distance matrix representing the distances
                                         between cities.
        attractiveness_exponent (float): Exponent for inverse distance. Default is 2.0.
        sparsification_factor (float): Divisor for the mean heuristic value to determine the threshold for sparsification. Default is 5.0.


    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing the
                     prior probabilities of including each edge in a solution. Higher
                     values indicate a higher prior probability.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Adaptive Temperature
    temperature = np.median(distance_matrix)  # Use median for robustness to outliers

    # Inverse distance, avoid division by zero
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))

    # Node Attractiveness (Desirability) - as in v1
    node_attractiveness = np.sum(inverse_distance, axis=0)
    node_attractiveness = 1.0 / (node_attractiveness / np.mean(node_attractiveness))

    # Node Centrality Penalty
    node_centrality = np.sum(inverse_distance, axis=1)  # Sum of inverse distances from each node
    node_centrality = node_centrality / np.mean(node_centrality) # normalized
    node_centrality_penalty = 1.0 / node_centrality  # Penalize high centrality

    # Edge Betweenness (approximation)
    edge_betweenness = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                #This is a simplified approximation. Ideally, calculate shortest paths.
                edge_betweenness[i,j] = node_attractiveness[i] + node_attractiveness[j]

    # Combine factors
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics[i, j] = (inverse_distance[i, j]**attractiveness_exponent) * \
                                   (node_attractiveness[i] * node_attractiveness[j]) * \
                                   (node_centrality_penalty[i] * node_centrality_penalty[j]) * \
                                   np.exp(-distance_matrix[i, j] / temperature) + edge_betweenness[i,j]
    # Sparsification - remove low probability edges
    threshold = np.mean(heuristics) / sparsification_factor # Dynamic threshold
    heuristics[heuristics < threshold] = 0

    return heuristics
