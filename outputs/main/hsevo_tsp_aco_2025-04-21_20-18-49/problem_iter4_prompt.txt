{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    A more sophisticated heuristics function for the Traveling Salesman Problem (TSP).\n\n    This version builds upon heuristics_v1 by incorporating several enhancements:\n\n    1.  Adaptive Temperature: The temperature parameter is adjusted dynamically based on\n        the distribution of distances in the matrix. This allows the heuristic to adapt\n        to different problem scales and structures.\n\n    2.  Node Centrality Penalty: Nodes with high centrality (i.e., nodes that are close to\n        many other nodes) are penalized. This encourages the algorithm to explore paths that\n        don't necessarily pass through the most central locations, potentially leading to\n        more efficient routes.\n\n    3.  Sparsification: Edges with very low desirability are set to zero, effectively\n        sparsifying the heuristics matrix. This can help to focus the search on a smaller\n        set of promising edges and improve computational efficiency.\n\n    4. Edge-Betweenness Prior: Edges that bridge disparate clusters are favored.\n\n    Args:\n        distance_matrix (np.ndarray): The distance matrix representing the distances\n                                         between cities.\n\n    Returns:\n        np.ndarray: A matrix of the same shape as distance_matrix, representing the\n                     prior probabilities of including each edge in a solution. Higher\n                     values indicate a higher prior probability.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix, dtype=float)\n\n    # Adaptive Temperature\n    temperature = np.median(distance_matrix)  # Use median for robustness to outliers\n\n    # Inverse distance, avoid division by zero\n    inverse_distance = 1.0 / (distance_matrix + np.eye(n))\n\n    # Node Attractiveness (Desirability) - as in v1\n    node_attractiveness = np.sum(inverse_distance, axis=0)\n    node_attractiveness = 1.0 / (node_attractiveness / np.mean(node_attractiveness))\n\n    # Node Centrality Penalty\n    node_centrality = np.sum(inverse_distance, axis=1)  # Sum of inverse distances from each node\n    node_centrality = node_centrality / np.mean(node_centrality) # normalized\n    node_centrality_penalty = 1.0 / node_centrality  # Penalize high centrality\n\n    # Edge Betweenness (approximation)\n    edge_betweenness = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                #This is a simplified approximation. Ideally, calculate shortest paths.\n                edge_betweenness[i,j] = node_attractiveness[i] + node_attractiveness[j]\n\n    # Combine factors\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristics[i, j] = (inverse_distance[i, j]**2) * \\\n                                   (node_attractiveness[i] * node_attractiveness[j]) * \\\n                                   (node_centrality_penalty[i] * node_centrality_penalty[j]) * \\\n                                   np.exp(-distance_matrix[i, j] / temperature) + edge_betweenness[i,j]\n    # Sparsification - remove low probability edges\n    threshold = np.mean(heuristics) / 5 # Dynamic threshold\n    heuristics[heuristics < threshold] = 0\n\n    return heuristics\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}