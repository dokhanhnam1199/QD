```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Tesla's Electrifying Heuristic for the Traveling Salesman!

    This heuristic combines several ingenious insights:

    1.  Inverse Distance:  Nodes closer together are naturally more promising.

    2.  Gravity-Inspired Attraction:  Nodes exert a "gravitational" pull
        proportional to the inverse square of their distance, enhancing
        the attraction of closer nodes.  We use inverse-square for the "attractive force", but avoid 0 division.

    3.  Global Connectivity Boost:  A small constant is added to ensure
        all edges have a non-zero probability, encouraging global
        exploration and preventing premature convergence.

    4.  Local Optimization Influence: A factor based on the row and column means is applied to give edges connected to nodes with higher average proximity a slight preference.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i, j]
                                       represents the distance between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each
                    element represents the heuristic score for including that edge
                    in the TSP tour.  Higher values indicate a more promising edge.
    """
    n = distance_matrix.shape[0]
    epsilon = 1e-9  # A small constant to avoid division by zero

    # 1. Inverse Distance
    inverse_distance = 1 / (distance_matrix + epsilon)

    # 2. Gravity-Inspired Attraction
    gravitational_attraction = 1 / ((distance_matrix**2) + epsilon)

    # 3. Global Connectivity Boost
    boost_factor = 0.1
    global_connectivity = np.ones((n, n)) * boost_factor

    # 4. Local Optimization Influence
    row_means = np.mean(inverse_distance, axis=1, keepdims=True)
    col_means = np.mean(inverse_distance, axis=0, keepdims=True)
    local_influence = np.sqrt(row_means * col_means) # Geometric mean

    # Combine the heuristics with carefully chosen weights
    heuristic_matrix = (
        0.6 * inverse_distance +
        0.3 * gravitational_attraction +
        0.05 * global_connectivity +
        0.05 * local_influence
    )

    return heuristic_matrix
```
