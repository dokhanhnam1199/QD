```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A more sophisticated heuristic for the Traveling Salesman Problem (TSP).

    This heuristic combines inverse distance with a simulated pheromone trail
    inspired by Ant Colony Optimization.  The pheromone trail encourages the
    selection of edges that have been previously included in good (short) tours.

    Args:
        distance_matrix (np.ndarray): A square matrix where element (i, j)
                                      represents the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix,
                    representing the desirability of including each edge in the tour.
                    Higher values indicate more desirable edges.
    """
    n = distance_matrix.shape[0]
    pheromone = np.ones((n, n))  # Initialize pheromone trails.  Could use a small random value.
    np.fill_diagonal(pheromone, 0)  # No self-loops

    # Parameters for pheromone update and influence. These would ideally be tuned based on the problem.
    evaporation_rate = 0.1  # How quickly pheromone evaporates
    q = 100.0  # Pheromone deposit constant
    alpha = 1.0 #relative importance of pheromone
    beta = 2.0  #relative importance of distance

    # Perform a few iterations of simulated ant colony behavior to build up pheromone trails.
    num_iterations = 5 #tune me
    num_ants = n      #tune me

    for _ in range(num_iterations):
        for _ in range(num_ants): # Simulate each "ant"
            #Construct a solution stochastically
            current_city = np.random.randint(0, n)  # Start at a random city
            unvisited_cities = set(range(n))
            unvisited_cities.remove(current_city)
            tour = [current_city]
            tour_length = 0.0

            while unvisited_cities:
                probabilities = np.zeros(n)
                for city in unvisited_cities:
                    probabilities[city] = (pheromone[current_city, city]**alpha) / (distance_matrix[current_city, city]**beta)
                probabilities /= np.sum(probabilities)

                next_city = np.random.choice(n, p=probabilities) #Select the next city probabilistically
                if next_city not in unvisited_cities:
                  possible_cities = list(unvisited_cities)
                  next_city = possible_cities[0]
                  for c in possible_cities[1:]:
                    if probabilities[c] > probabilities[next_city]:
                      next_city = c

                tour.append(next_city)
                tour_length += distance_matrix[current_city, next_city]
                unvisited_cities.remove(next_city)
                current_city = next_city

            tour.append(tour[0]) #Return to starting city
            tour_length += distance_matrix[current_city, tour[0]]

            #Update pheromones (only for the "best" ants in each iteration - can skip for simplicity)
            for i in range(n):
                pheromone[tour[i], tour[i+1]] += q / tour_length # Deposit pheromone based on tour length


        pheromone *= (1 - evaporation_rate) # Pheromone evaporation

    # Combine pheromone with inverse distance
    heuristic = (pheromone**alpha) / (distance_matrix**beta)  # Apply both to the heuristic
    return heuristic
```
