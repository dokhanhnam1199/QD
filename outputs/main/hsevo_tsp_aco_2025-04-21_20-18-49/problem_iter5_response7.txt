```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines inverse distance, degree, pheromone, and adaptive exploration.
    """
    n = distance_matrix.shape[0]
    epsilon = 1e-9

    # Inverse distance component
    inverse_distance = 1.0 / (distance_matrix + epsilon)

    # Node degree desirability (attractiveness of less-connected nodes)
    node_degrees = np.sum(inverse_distance, axis=0)
    degree_heuristic = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            degree_heuristic[i, j] = 1.0 / (node_degrees[i] + node_degrees[j] + epsilon)

    # Pheromone component (initially uniform)
    pheromone_level = np.ones_like(distance_matrix)

    # Adaptive temperature for exploration
    temperature = np.mean(distance_matrix) / 2

    # Sparse connectivity bias (favoring some degree of connectivity)
    connectivity_bias = np.random.rand(n, n) * temperature
    
    heuristic_matrix = inverse_distance * degree_heuristic * pheromone_level + connectivity_bias
    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2
    heuristic_matrix = np.nan_to_num(heuristic_matrix, nan=0.0)
    
    # Normalize to [0, 1] range
    min_val = np.min(heuristic_matrix)
    max_val = np.max(heuristic_matrix)
    heuristic_matrix = (heuristic_matrix - min_val) / (max_val - min_val + epsilon)

    return heuristic_matrix
```
