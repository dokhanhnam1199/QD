{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\nCurrent heuristics:\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n                  attractiveness_exponent: float = 2.0,\n                  sparsification_factor: float = 4.733362140013519) -> np.ndarray:\n    \"\"\"Enhanced heuristics using inverse distance, centrality, attractiveness, and adaptive temperature.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix, dtype=float)\n    temperature = np.median(distance_matrix)\n    inverse_distance = 1.0 / (distance_matrix + np.eye(n))\n    node_attractiveness = np.sum(inverse_distance, axis=0)\n    node_attractiveness = 1.0 / (node_attractiveness / np.mean(node_attractiveness))\n    node_centrality = np.sum(inverse_distance, axis=1)\n    node_centrality = node_centrality / np.mean(node_centrality)\n    node_centrality_penalty = 1.0 / node_centrality\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristics[i, j] = (inverse_distance[i, j]**attractiveness_exponent) * \\\n                                   (node_attractiveness[i] * node_attractiveness[j]) * \\\n                                   (node_centrality_penalty[i] * node_centrality_penalty[j]) * \\\n                                   np.exp(-distance_matrix[i, j] / temperature)\n\n    threshold = np.mean(heuristics) / sparsification_factor\n    heuristics[heuristics < threshold] = 0\n\n    return heuristics\n\nNow, think outside the box write a mutated function `heuristics_v2` better than current version.\nYou can use some hints below:\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, let's redefine \"Current Self-Reflection\" to provide more actionable advice for designing better heuristics, while avoiding the pitfalls of \"Ineffective Self-Reflection.\" Here's a breakdown:\n\n*   **Keywords:** Parameterization, Normalization, Dynamic Adaptation, Factor Combination.\n\n*   **Advice:** Focus on creating modular heuristic components with adjustable parameters. Normalize inputs to allow fair comparisons. Design mechanisms that dynamically adapt to problem characteristics during runtime.\n\n*   **Avoid:** Blindly combining factors without understanding their interactions. Over-reliance on single, static threshold values.\n\n*   **Explanation:** Robust heuristics result from carefully integrating adaptable components. Parameterization facilitates tuning and generalization. Dynamic adaptation allows the heuristic to respond to the problem's nuances. Normalization ensures fair evaluation of different factors.\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}