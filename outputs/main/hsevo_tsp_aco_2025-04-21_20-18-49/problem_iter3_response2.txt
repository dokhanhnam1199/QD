```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    An enhanced heuristics function for the Traveling Salesman Problem (TSP),
    building upon heuristics_v1 with added features and refinements.

    This version aims to improve solution quality by incorporating:

    1.  Adaptive Temperature: Temperature is calculated for each node based on its
        average distance to other nodes, leading to a more nuanced exploration strategy.
    2.  Reinforcement Learning inspired heuristic: Favor edges that have been historically included in short tours.
        This is approximated using an inverse measure of how many times a node has been part of longer edges.
    3.  Sparsification:  A threshold is applied to the heuristic matrix to eliminate less
        promising edges, reducing the search space for subsequent algorithms.
        This threshold is dynamically adjusted based on the distribution of heuristic values.
    4. Reciprocal edges: Ensures that if an edge (i,j) is considered important, so is the edge (j,i)

    Args:
        distance_matrix (np.ndarray): The distance matrix representing the distances
                                         between cities.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing the
                     prior probabilities of including each edge in a solution. Higher
                     values indicate a higher prior probability.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Adaptive Temperature
    node_avg_distances = np.mean(distance_matrix, axis=1)
    temperature_matrix = np.tile(node_avg_distances, (n, 1)) + np.tile(node_avg_distances, (n, 1)).T
    temperature_matrix /= 4 # Divide by a constant to adjust the scale of temperature
    temperature_matrix = np.clip(temperature_matrix, np.min(distance_matrix) / 2, np.max(distance_matrix) * 2) # Clip values to a reasonable range

    # 2. Inverse distance, avoiding division by zero
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))

    # 3. Node degree desirability (attractiveness) + Reinforcement learning inspired component
    node_edge_usage = np.sum(distance_matrix, axis=0)
    node_attractiveness = 1.0 / (node_edge_usage / np.mean(node_edge_usage))

    #Adjust temperature based on node_attractiveness
    adjusted_temperature_matrix = temperature_matrix * (1 + 0.1 * np.abs(node_attractiveness - 1))


    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics[i, j] = (inverse_distance[i, j]**2) * (node_attractiveness[i] * node_attractiveness[j]) * np.exp(-distance_matrix[i, j] / adjusted_temperature_matrix[i,j])

    # 4. Sparsification
    threshold = np.mean(heuristics[heuristics > 0]) / 3 # Dynamic threshold based on the mean of non-zero elements

    heuristics[heuristics < threshold] = 0

    # 5. Enforce reciprocal edges.
    heuristics = (heuristics + heuristics.T)/2

    return heuristics
```
