```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray,
                  distance_exponent: float = 2.0,
                  attractiveness_exponent: float = 1.5,
                  centrality_exponent: float = 0.7,
                  sparsification_factor: float = 3.5) -> np.ndarray:
    """Enhanced heuristics using distance, node degree centrality, and adaptive sparsification."""
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance with small constant to avoid division by zero
    inverse_distance = 1.0 / (distance_matrix + np.eye(n) * 1e-9)

    # Node degree centrality (sum of inverse distances)
    node_degree_centrality = np.sum(inverse_distance, axis=0)
    # Normalize node degree centrality to be between 0 and 1
    node_degree_centrality_normalized = (node_degree_centrality - np.min(node_degree_centrality)) / (np.max(node_degree_centrality) - np.min(node_degree_centrality)) + 1e-9 #avoid division by zero


    # Edge attractiveness based on inverse distance and node centrality
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics[i, j] = (inverse_distance[i, j] ** distance_exponent) * \
                                   (node_degree_centrality_normalized[i] ** attractiveness_exponent) * \
                                   (node_degree_centrality_normalized[j] ** centrality_exponent)

    # Adaptive sparsification based on mean and standard deviation
    threshold = np.mean(heuristics) + (sparsification_factor * np.std(heuristics))
    heuristics[heuristics < threshold] = 0

    return heuristics
```
