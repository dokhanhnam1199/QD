```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Enhanced heuristics for the Traveling Salesman Problem, inspired by radioactive decay principles.

    This version combines inverse distance with a normalized rank-based approach and a probabilistic factor
    to favor shorter distances and prevent getting stuck in local optima.  It considers edge 'half-life',
    a concept from radioactivity, where shorter edges 'decay' slower (are more promising).

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i, j] is the distance
                                         between city i and city j. Diagonal elements are ignored
                                         and often contain 0 or np.inf.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing the heuristic values
                      for each edge. Higher values indicate more promising edges.
    """

    n = distance_matrix.shape[0]

    # Handle potential division by zero by adding a small epsilon
    epsilon = 1e-9
    distance_matrix = distance_matrix + epsilon

    # 1. Inverse Distance (Basic Attraction): Shorter distances are initially more attractive
    inverse_distance = 1 / distance_matrix

    # 2. Rank-Based Normalization:  Emphasize relative edge importance, independent of scale.
    #    For each city, rank the edges by distance and normalize these ranks.

    rank_matrix = np.zeros((n, n))
    for i in range(n):
        distances = distance_matrix[i, :]  # Distances from city i to all others
        ranks = np.argsort(distances) # indices sorted by increasing distance.

        # Store indices to efficiently populate the rank_matrix
        for j, r in enumerate(ranks):
           rank_matrix[i, r] = (n - j) / n   # Shorter edges get higher rank (close to 1)

    # 3.  Radioactive Decay Analogy (Edge Half-Life): Favor shorter edges using a probabilistic component
    #     Simulate half-life decay based on distance.  Shorter edges 'decay' slower, remain promising longer.

    decay_factor = np.exp(-distance_matrix / np.mean(distance_matrix))  # Shorter edges decay slower (higher value).

    # 4. Combined Heuristic:  Balance attraction, relative importance, and half-life.
    heuristic_matrix = inverse_distance * rank_matrix * decay_factor

    # Optional: Enhance exploitation by emphasizing the edges with already higher chances

    #Normalize between 0-1:
    min_val = np.min(heuristic_matrix)
    max_val = np.max(heuristic_matrix)
    heuristic_matrix = (heuristic_matrix - min_val) / (max_val - min_val)

    return heuristic_matrix
```
