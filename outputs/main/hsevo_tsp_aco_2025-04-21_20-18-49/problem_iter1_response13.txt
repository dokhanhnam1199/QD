```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Marie Curie's Heuristic for TSP using Stochastic Solution Sampling:

    Combines inverse distance with node connectivity estimates for edge prioritization.
    This approach favors shorter distances but also considers how "central" a node is
    within the overall graph, making it more likely to be included in a good tour.

    Args:
        distance_matrix (np.ndarray): A numpy array representing the distance matrix
                                      where distance_matrix[i][j] is the distance
                                      between node i and node j.

    Returns:
        np.ndarray: A numpy array of the same shape as distance_matrix, representing
                      the heuristic values for each edge.  Higher values indicate
                      more promising edges.
    """
    n = distance_matrix.shape[0]

    # Inverse distance as a base heuristic (shorter distances are better).
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add a small value to avoid division by zero

    # Node connectivity estimate (how well-connected each node is).
    # We can estimate this based on the sum of inverse distances to other nodes.
    node_connectivity = np.sum(inverse_distance, axis=1)

    # Normalize node connectivity to a reasonable range.
    normalized_connectivity = (node_connectivity - np.min(node_connectivity)) / (np.max(node_connectivity) - np.min(node_connectivity) + 1e-9)


    # Combine inverse distance with connectivity to prioritize edges.
    # Edges connecting well-connected nodes and having short distances are favored.

    heuristic_matrix = inverse_distance * (np.tile(normalized_connectivity, (n, 1)).T + np.tile(normalized_connectivity, (n, 1)))/2 # average connectivity of two ends.

    # Further refine based on stochastic sampling results (simulated annealing inspiration).
    # Initially, we don't have actual sampling results, so we'll simulate some stochastic
    # influence using random noise. In a real application, this section would be replaced
    # by updates based on the performance of edges within sampled TSP solutions.

    # Scale heuristics and add some random variation
    heuristic_matrix = (heuristic_matrix - np.min(heuristic_matrix))/(np.max(heuristic_matrix)-np.min(heuristic_matrix)+1e-9)
    heuristic_matrix += 0.01 * np.random.rand(n, n)  # Add a small random factor
    return heuristic_matrix
```
