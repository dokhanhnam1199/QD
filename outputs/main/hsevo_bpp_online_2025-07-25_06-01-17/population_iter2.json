[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines bin fullness and item fit for priority scoring.\n    \"\"\"\n    # Calculate the ratio of the item to each bin's remaining capacity\n    ratio = np.where(bins_remain_cap == 0, 0, item / bins_remain_cap)\n    \n    # Calculate the remaining space in each bin after adding the item\n    remaining_space = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n    \n    # Calculate a \"fill\" score for each bin: how much of the bin would be full after adding the item\n    fill_score = np.where(remaining_space == 0, 1, 1 - remaining_space / bins_remain_cap)\n    \n    # Calculate the priority score for each bin, favoring bins with just enough capacity\n    priority_score = np.where(ratio == 0, 0, ratio * fill_score)\n    \n    # Apply a penalty to bins that are already close to full\n    penalty = (1 - (bins_remain_cap / item)) * (bins_remain_cap < item)\n    \n    # Adjust the priority score with the penalty\n    priority = priority_score * (1 - penalty)\n    \n    # Add a small positive value to avoid division by zero\n    priority += np.finfo(np.float64).eps\n    \n    # Normalize the priority scores to favor bins with the most remaining capacity\n    priority = priority / np.sum(priority)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of v0 and v1 heuristics for better results.\n    \"\"\"\n    # Calculate priority based on how full the bin is and how well the item fits\n    priority_fullness = np.where(bins_remain_cap >= item, \n                                 # for bins that can hold the item, the priority is inversely proportional to the remaining capacity\n                                 1.0 / (bins_remain_cap + 1), \n                                 # for bins that cannot hold the item, the priority is zero\n                                 0.0)\n    \n    # Calculate priority based on available space relative to the item size\n    priority_space = np.where(bins_remain_cap >= item, bins_remain_cap, -1)\n    \n    # Combine the two priorities, giving more weight to the fullness priority\n    priorities = 0.7 * priority_fullness + 0.3 * priority_space\n    \n    # Ensure priorities are not negative\n    priorities = np.where(priorities < 0, 0, priorities)\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combine bin fullness and item fit for priority.\n    \"\"\"\n    # Calculate the ratio of the item size to the remaining capacity of each bin\n    ratio = item / np.maximum(bins_remain_cap, 1e-8)  # avoid division by zero\n    \n    # Assign higher priority to bins with lower ratio (i.e., less likely to leave a small gap)\n    # and with more remaining capacity (i.e., more space to accommodate future items)\n    priority = np.where(bins_remain_cap >= item, \n                       # for bins that can hold the item, the priority is inversely proportional to the remaining capacity\n                       bins_remain_cap * (1 - ratio) / (bins_remain_cap + 1), \n                       # for bins that cannot hold the item, the priority is zero\n                       0.0)\n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of previous heuristics for better performance.\n    \"\"\"\n    # Calculate the waste (remaining capacity) if the item is added to each bin\n    waste = bins_remain_cap - item\n    \n    # Give higher priority to bins where item fits more tightly\n    delta = np.where(waste < 0, -np.inf, waste)\n    \n    # Prioritize bins with just enough capacity and higher available space\n    priority = np.where(delta > 0, bins_remain_cap / (delta + 1e-10), -np.inf)\n    \n    # Avoid bins that are too full or too empty\n    priority = np.where(bins_remain_cap < item, -np.inf, priority)\n    priority = np.where(bins_remain_cap == 0, priority * 0.9, priority)  # reduce priority for empty bins\n    \n    # Balance priorities based on bin fullness and item fit\n    priority = np.where(bins_remain_cap > item, priority * (1 + (bins_remain_cap - item) / (bins_remain_cap + 1e-10)), priority)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 5.195452732349436,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of v0 and v1 heuristics for better outcomes.\n    \"\"\"\n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap * penalty_factor, -1)\n    \n    # Ensure bins with higher remaining capacity get higher priority when the item fits\n    priority = np.where(bins_remain_cap >= item, priority + bins_remain_cap, priority)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 148.53410450737937,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Balances item fit and remaining capacity.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority_fit = 1 / (1 + capacity_diff)\n    \n    # Calculate the remaining capacity relative to the item size\n    relative_cap = bins_remain_cap / item\n    \n    # Favor bins with enough capacity to fit the item\n    capacity_mask = bins_remain_cap >= item\n    \n    # Use a weighted sum to balance the two objectives\n    priority_capacity = np.where(capacity_mask, relative_cap, 0)\n    \n    # Combine the two priorities, favoring a good fit and sufficient capacity\n    priority = priority_fit * priority_capacity\n    \n    # Ensure bins with negative remaining capacity or insufficient capacity have zero priority\n    priority[bins_remain_cap < item] = 0\n    \n    # Ensure all priorities are non-negative\n    priority = np.maximum(priority, 0)\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines bin fullness and item fit for priority.\n    \"\"\"\n    # Calculate the \"closeness\" of each bin to being full after adding the item\n    remaining_capacity_after_item = bins_remain_cap - item\n    \n    # Ignore bins that cannot accommodate the item\n    eligible_bins = remaining_capacity_after_item >= 0\n    \n    # For eligible bins, calculate priority based on bin fullness and item fit\n    priority_scores = np.zeros_like(bins_remain_cap)\n    priority_scores[eligible_bins] = 1 / (1 + remaining_capacity_after_item[eligible_bins])\n    \n    # Favor bins with higher remaining capacity\n    priority_scores[eligible_bins] += bins_remain_cap[eligible_bins] / (1 + np.abs(remaining_capacity_after_item[eligible_bins]))\n    \n    # Set priority to -inf for bins that cannot accommodate the item\n    priority_scores[~eligible_bins] = -np.inf\n    \n    return priority_scores",
    "response_id": 6,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 18, in priority_v2\n    bins_remain_cap - item + 1, \nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n7\n1\n120.92782504182705\n83.62596713757605\n108\n"
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines factors for a balanced heuristic.\n    \"\"\"\n    # Calculate the wasted space for each bin if the item is added\n    wasted_space = np.maximum(bins_remain_cap - item, 0)\n    \n    # Invert the wasted space so that bins with least wasted space get higher priority\n    inverted_wasted_space = 1 / (wasted_space + 1e-6)  # Add small value for numerical stability\n    \n    # Calculate the priority score for each bin based on the remaining capacity and item fit\n    priority_score = inverted_wasted_space * (bins_remain_cap / (bins_remain_cap + item + 1e-6))  # Add small value for numerical stability\n    \n    # Consider bins that have enough capacity to hold the item and favor tight fits\n    capacity_priority = np.where(bins_remain_cap >= item, \n                                 bins_remain_cap - item + 1, \n                                 0)\n    \n    # Combine the two priorities\n    combined_priority = priority_score * capacity_priority\n    \n    # Normalize the priorities to ensure they add up to 1\n    normalized_priority = combined_priority / (np.sum(combined_priority) + 1e-6)\n    \n    return normalized_priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 82.46908655763862,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins with enough capacity, favoring tight fits and low waste.\n    \"\"\"\n    # Create a mask to identify bins that can hold the item\n    can_hold_item = bins_remain_cap >= item\n    \n    # Calculate the waste that would be caused by adding the item to each bin\n    waste = bins_remain_cap - item\n    \n    # Calculate the \"closeness\" of each bin to being full after adding the item\n    remaining_capacity_after_item = bins_remain_cap - item\n    \n    # Calculate the priority score for each bin, considering both waste and closeness to full\n    priority = np.where(can_hold_item, 1 / (waste + 1) * (1 / (1 + remaining_capacity_after_item)), 0)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combine balance and forecasting to prioritize bins.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    # to encourage packing items into bins where the item size is close to the remaining capacity\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # Calculate the available space in each bin relative to the item size\n    # to favor bins that have enough capacity to fit the item and have the most available space\n    relative_available_space = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Combine the two priorities to balance competing factors\n    combined_priority = priority * relative_available_space / (item + 1e-6)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    combined_priority[bins_remain_cap < item] = 0\n    \n    return combined_priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  }
]