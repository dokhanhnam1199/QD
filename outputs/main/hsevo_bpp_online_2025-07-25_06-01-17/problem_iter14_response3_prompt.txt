{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    An evolved priority function that incorporates dynamic weighting, forecasting, and problem state adaptation.\n    \n    Parameters:\n    item (float): The size of the current item to be packed.\n    bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.\n    alpha (float): Weight for the current item's fit priority (default: 0.4).\n    beta (float): Weight for the bin utilization priority (default: 0.3).\n    gamma (float): Weight for the future potential and forecasting priority (default: 0.3).\n    \n    Returns:\n    np.ndarray: A priority score for each bin, with the highest score indicating the best bin for the current item.\n    \"\"\"\n\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    fit_priority = 1 / (1 + np.log(1 + capacity_diff))\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    fit_priority[bins_remain_cap < item] = 0\n    \n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    avg_historic_size = np.mean(bins_remain_cap)  # Using mean remaining capacity as a proxy for historic item sizes\n    utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)\n    \n    # Forecast future item sizes based on the average remaining capacity\n    forecasted_item_size = np.mean(bins_remain_cap) + np.std(bins_remain_cap)\n    future_potential_priority = bins_remain_cap / (bins_remain_cap + forecasted_item_size)\n    \n    # Calculate the overall priority, balancing the current item's fit, bin utilization, and future potential\n    priority = alpha * fit_priority + beta * utilization_priority + gamma * future_potential_priority * penalty_factor * bins_remain_cap\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    priority = np.nan_to_num(priority)\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, priority, -1)\n    \n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Improved heuristic combining adaptive weighting and balancing.\n    \"\"\"\n    \n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    fit_priority = 1 / (1 + capacity_diff)  # Using a simple invert function\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    fit_priority[bins_remain_cap < item] = 0\n    \n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    avg_historic_size = np.mean(bins_remain_cap)  # Using mean remaining capacity as a proxy for historic item sizes\n    utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)\n    \n    # Adaptive weighting based on the problem's current state\n    total_remain_cap = np.sum(bins_remain_cap)\n    if total_remain_cap == 0:\n        adapt_weight = 0\n    else:\n        adapt_weight = (item / total_remain_cap) * 0.4 + (1 - item / total_remain_cap) * 0.3  # Dynamic weighting\n    \n    # Introduce a 'balance' factor to prioritize bins with remaining capacity close to 50% of the bin size\n    balance_factor = 1 - np.abs((bins_remain_cap / (bins_remain_cap + item)) - 0.5)\n    \n    # Calculate the overall priority, balancing the current item's fit, bin utilization, and adaptive weighting\n    priority = adapt_weight * fit_priority + (1 - adapt_weight) * (0.3 * utilization_priority + 0.3 * balance_factor)\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    priority = np.nan_to_num(priority)\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, priority, -1)\n    \n    # Dynamic prioritization based on the remaining capacity of each bin\n    priority *= (bins_remain_cap / np.sum(bins_remain_cap))\n    \n    return priority\n\n### Analyze & experience\n- Comparing the 1st vs the 20th heuristics, we see a significant difference in the approach to calculating priorities, with the 1st heuristic using a more complex formula involving dynamic weighting and forecasting, while the 20th heuristic uses a simpler approach based on capacity differences and bin fullness. \nComparing the 2nd vs the 19th heuristics, we see that both use similar techniques, but the 2nd heuristic incorporates additional factors such as shortfall and excess capacity, which may lead to more efficient bin packing. \nComparing the 3rd vs the 18th heuristics, we see that the 3rd heuristic uses a more adaptive approach to weighting, taking into account the problem's current state, whereas the 18th heuristic uses a fixed weighting scheme. \nComparing the 4th vs the 17th heuristics, we see that the 4th heuristic incorporates a forecasted utilization priority, which may help to avoid overfilling bins, whereas the 17th heuristic does not consider this factor. \nComparing the 5th vs the 16th heuristics, we see that the 5th heuristic uses a more sophisticated approach to calculating the overall priority, involving alpha, beta, and gamma weights, whereas the 16th heuristic uses a simpler approach based on priority capacity and fullness. \nComparing the 6th vs the 15th heuristics, we see that the 6th heuristic uses a more dynamic approach to weighting, involving log and exponential functions, whereas the 15th heuristic uses a more static approach. \nComparing the 7th vs the 14th heuristics, we see that the 7th heuristic incorporates a balance factor to prioritize bins with remaining capacity close to 50% of the bin size, whereas the 14th heuristic does not consider this factor. \nComparing the 8th vs the 13th heuristics, we see that the 8th heuristic uses a more complex approach involving forecasting and adaptation to the problem state, whereas the 13th heuristic uses a simpler approach based on capacity differences and bin fullness. \nComparing the 9th vs the 12th heuristics, we see that the 9th heuristic incorporates a penalty factor for bins with low remaining capacity, whereas the 12th heuristic does not consider this factor. \nComparing the 10th vs the 11th heuristics, we see that the 10th heuristic uses a more static approach to weighting, whereas the 11th heuristic uses a more dynamic approach involving adaptation to the problem state. \nOverall: The better heuristics tend to use more complex and adaptive approaches to calculating priorities, incorporating factors such as dynamic weighting, forecasting, and adaptation to the problem state.\n- \nHere's a redefined 'Current self-reflection' to design better heuristics:\n* Keywords: Adaptive weighting, multiple objectives, dynamic weighting\n* Advice: Combine multiple objectives, use dynamic weighting, and incorporate forecasting\n* Avoid: Prioritizing tight fits, overemphasizing future item placements\n* Explanation: Effective heuristics balance multiple objectives, adapt to the problem's state, and use dynamic weighting to optimize solutions.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}