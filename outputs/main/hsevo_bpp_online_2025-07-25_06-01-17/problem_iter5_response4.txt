```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, 
                all_items: np.ndarray = None, alpha: float = 0.5, beta: float = 0.3, gamma: float = 0.2) -> np.ndarray:
    """
    Combines capacity difference, balance factor, and forecasting for bin prioritization.
    """
    
    # Calculate the difference between the remaining capacity of each bin and the item size
    capacity_diff = np.abs(bins_remain_cap - item)
    
    # Invert the differences to obtain a priority score for the capacity difference factor
    priority_capacity = 1 / (1 + capacity_diff)  # Prioritize bins with smallest capacity difference
    
    # Calculate the current utilization of each bin
    current_utilization = 1 - (bins_remain_cap / np.sum(bins_remain_cap))
    
    # Calculate the priority score for the current utilization factor
    priority_utilization = 1 / (1 + current_utilization)  # Prioritize bins with lowest utilization
    
    # If all item sizes are provided, calculate the expected future utilization
    if all_items is not None:
        # Calculate the average item size
        avg_item_size = np.mean(all_items)
        
        # Calculate the expected future utilization of each bin
        future_utilization = bins_remain_cap / (np.sum(bins_remain_cap) + avg_item_size)
        
        # Calculate the priority score for the future utilization factor
        priority_future = 1 / (1 + future_utilization)  # Prioritize bins with lowest expected future utilization
    else:
        priority_future = np.ones_like(bins_remain_cap)
    
    # Calculate the overall priority score by combining the three factors
    priority = alpha * priority_capacity + beta * priority_utilization + gamma * priority_future
    
    # If the item size exceeds the remaining capacity, set the priority to 0
    priority[bins_remain_cap < item] = 0  # Ensure item can fit in bin
    
    return priority
```
