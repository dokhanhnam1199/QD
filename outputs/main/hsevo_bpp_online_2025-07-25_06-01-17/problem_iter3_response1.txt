```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, historic_item_sizes: np.ndarray = None, alpha: float = 0.5, beta: float = 0.3) -> np.ndarray:
    """
    Returns a priority score for each bin, balancing the current item's fit with future potential and bin utilization.

    Args:
        item: Size of the item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.
        historic_item_sizes: Optional array of previously packed item sizes for forecasting.
        alpha: Weight for the current item's fit (default: 0.5).
        beta: Weight for bin utilization and future potential (default: 0.3).

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the difference between the remaining capacity of each bin and the item size
    capacity_diff = np.abs(bins_remain_cap - item)
    
    # Invert the differences to obtain a priority score for the current item's fit
    fit_priority = 1 / (1 + capacity_diff)
    
    # If the item size exceeds the remaining capacity, set the priority to 0
    fit_priority[bins_remain_cap < item] = 0
    
    # Calculate the bin utilization, considering both the current item and future potential
    if historic_item_sizes is not None:
        avg_historic_size = np.mean(historic_item_sizes)
        utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)
    else:
        utilization_priority = bins_remain_cap / (bins_remain_cap + item)
    
    # Calculate the overall priority, balancing the current item's fit and bin utilization
    priority = alpha * fit_priority + beta * utilization_priority
    
    # Ensure the priority scores are not NaN (e.g., due to division by zero)
    priority = np.nan_to_num(priority)
    
    return priority
```
