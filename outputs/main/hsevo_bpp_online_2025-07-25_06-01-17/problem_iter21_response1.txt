```python
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler

class AdaptivePriorityFunction:
    def __init__(self):
        self.model = LinearRegression()
        self.scaler = StandardScaler()
        self.alpha = 0.4  # Adaptive weighting for fit priority
        self.beta = 0.3  # Adaptive weighting for utilization priority
        self.gamma = 0.3  # Adaptive weighting for penalty factor
        self.item_history = []  # Store item sizes for dynamic weighting
        self.bin_history = []  # Store bin capacities for dynamic weighting

    def priority_v2(self, item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
        """
        Adaptive priority function for online Bin Packing Problem.
        
        This function incorporates machine learning, problem constraints, and iterative refinement
        to provide a nuanced and balanced priority score for each bin.
        """
        # Update item and bin history
        self.item_history.append(item)
        self.bin_history.extend(bins_remain_cap)

        # Calculate the difference between the remaining capacity of each bin and the item size
        capacity_diff = np.abs(bins_remain_cap - item)

        # Invert the differences to obtain a priority score for the current item's fit
        fit_priority = 1 / (1 + capacity_diff)

        # If the item size exceeds the remaining capacity, set the priority to 0
        fit_priority[bins_remain_cap < item] = 0

        # Calculate the shortfall or excess capacity for each bin
        shortfall = np.maximum(0, item - bins_remain_cap)
        excess = np.maximum(0, bins_remain_cap - item)

        # Calculate a penalty factor for each bin based on the shortfall or excess capacity
        penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))

        # Calculate the bin utilization, considering both the current item and future potential
        avg_historic_size = np.mean(self.item_history) if self.item_history else item
        utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)

        # Train a linear regression model to predict the optimal bin utilization
        if len(self.bin_history) > 10:
            X = np.array(self.bin_history).reshape(-1, 1)
            y = np.array([item] * len(self.bin_history))
            X_scaled = self.scaler.fit_transform(X)
            self.model.fit(X_scaled, y)
            predicted_utilization = self.model.predict(self.scaler.transform(bins_remain_cap.reshape(-1, 1)))
            utilization_priority = np.maximum(0, predicted_utilization)

        # Calculate the overall priority, balancing the current item's fit and bin utilization
        priority = self.alpha * fit_priority + self.beta * utilization_priority + self.gamma * penalty_factor * bins_remain_cap

        # Ensure the priority scores are not NaN (e.g., due to division by zero)
        priority = np.nan_to_num(priority)

        # Assign high priority to bins with enough capacity and a good fit
        priority = np.where(bins_remain_cap >= item, priority, -1)

        # Adaptive weighting for dynamic problem conditions
        if np.mean(bins_remain_cap) < item * 0.5:
            self.alpha += 0.1
            self.beta -= 0.1
        elif np.mean(bins_remain_cap) > item * 1.5:
            self.alpha -= 0.1
            self.beta += 0.1

        return priority

# Example usage:
apf = AdaptivePriorityFunction()
item = 10.0
bins_remain_cap = np.array([5.0, 10.0, 15.0])
priority_scores = apf.priority_v2(item, bins_remain_cap)
print(priority_scores)
```
