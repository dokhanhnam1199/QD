```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines bin fullness and item fit for priority scoring.
    """
    # Calculate the ratio of the item to each bin's remaining capacity
    ratio = np.where(bins_remain_cap == 0, 0, item / bins_remain_cap)
    
    # Calculate the remaining space in each bin after adding the item
    remaining_space = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)
    
    # Calculate a "fill" score for each bin: how much of the bin would be full after adding the item
    fill_score = np.where(remaining_space == 0, 1, 1 - remaining_space / bins_remain_cap)
    
    # Calculate the priority score for each bin, favoring bins with just enough capacity
    priority_score = np.where(ratio == 0, 0, ratio * fill_score)
    
    # Apply a penalty to bins that are already close to full
    penalty = (1 - (bins_remain_cap / item)) * (bins_remain_cap < item)
    
    # Adjust the priority score with the penalty
    priority = priority_score * (1 - penalty)
    
    # Add a small positive value to avoid division by zero
    priority += np.finfo(np.float64).eps
    
    # Normalize the priority scores to favor bins with the most remaining capacity
    priority = priority / np.sum(priority)
    
    return priority
```
