{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on how full they are, \n    and how well the item fits in the bin. The bin that can fill up the most \n    with the item, or the bin that is closest to being full after adding the \n    item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the ratio of the item to each bin's remaining capacity\n    ratio = np.where(bins_remain_cap == 0, 0, item / bins_remain_cap)\n    \n    # Calculate the remaining space in each bin after adding the item\n    remaining_space = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n    \n    # Calculate a \"fill\" score for each bin: how much of the bin would be full after adding the item\n    fill_score = np.where(remaining_space == 0, 1, 1 - remaining_space / bins_remain_cap)\n    \n    # Calculate the priority score for each bin\n    priority_score = np.where(ratio == 0, 0, ratio * fill_score)\n    \n    return priority_score\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have enough capacity to hold the item,\n    and gives higher priority to bins that have just enough capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.where(bins_remain_cap >= item, \n                          # for bins that can hold the item, the priority is inversely proportional to the remaining capacity\n                          1.0 / (bins_remain_cap + 1), \n                          # for bins that cannot hold the item, the priority is zero\n                          0.0)\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have enough capacity to hold the item,\n    and gives higher priority to bins that have just enough capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.where(bins_remain_cap >= item, \n                          # for bins that can hold the item, the priority is inversely proportional to the remaining capacity\n                          1.0 / (bins_remain_cap + 1), \n                          # for bins that cannot hold the item, the priority is zero\n                          0.0)\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to pack items into the bins that have the\n    most available space. It's based on the idea that the best strategy for the\n    online bin packing problem is to use the 'First-Fit Decreasing' algorithm, \n    but adapted to the priority function framework. The priority function score \n    is inversely proportional to the difference between the bin's remaining capacity \n    and the item size, with a higher score indicating a better fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check for zero division errors\n    denominators = np.maximum(bins_remain_cap - item, 1e-9)\n    \n    # Calculate priority score based on difference between bin capacity and item size\n    priority_scores = 1 / denominators\n    \n    # We also prefer bins that are not empty, so let's give them extra points\n    non_empty_bins = (bins_remain_cap > 0)\n    priority_scores[non_empty_bins] *= 1.1  # Magic factor, tune it as you like\n\n    return priority_scores\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have enough capacity to hold the item\n    and penalize bins that are too full or too empty. The priority score is calculated as the \n    product of the remaining capacity and a penalty factor that decreases as the remaining capacity\n    approaches zero or the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Calculate the priority score as the product of the remaining capacity and the penalty factor\n    priority_score = bins_remain_cap * penalty_factor\n    \n    return priority_score\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is close to the remaining capacity, thereby minimizing waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function favors bins that have the most remaining capacity\n    and anticipate the item size to fit with least wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the wasted space for each bin if the item is added\n    wasted_space = np.maximum(bins_remain_cap - item, 0)\n    \n    # Invert the wasted space so that bins with least wasted space get higher priority\n    inverted_wasted_space = 1 / (wasted_space + 1e-6)  # Add small value for numerical stability\n    \n    # Calculate the priority score for each bin based on the remaining capacity\n    priority_score = inverted_wasted_space * (bins_remain_cap / (bins_remain_cap + item + 1e-6))  # Add small value for numerical stability\n    \n    return priority_score\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have enough capacity to hold the item\n    and give higher priority to bins that have just enough capacity, thus minimizing waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Create a mask to identify bins that can hold the item\n    can_hold_item = bins_remain_cap >= item\n    \n    # Calculate the waste that would be caused by adding the item to each bin\n    waste = bins_remain_cap - item\n    \n    # Calculate the priority score for each bin\n    priority = np.where(can_hold_item, 1 / (waste + 1), 0)\n    \n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is close to the remaining capacity, thereby minimizing waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to \n    accommodate the item, to avoid splitting items across multiple bins. It uses a \n    combination of the remaining capacity and the item size to calculate the priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the \"closeness\" of each bin to being full after adding the item\n    remaining_capacity_after_item = bins_remain_cap - item\n    \n    # Initialize priority scores with zeros\n    priority_scores = np.zeros_like(bins_remain_cap)\n    \n    # Ignore bins that cannot accommodate the item\n    eligible_bins = remaining_capacity_after_item >= 0\n    \n    # For eligible bins, higher priorities are assigned to bins that are closer to being full\n    priority_scores[eligible_bins] = 1 / (1 + remaining_capacity_after_item[eligible_bins])\n    \n    # Alternatively, if we want to favor the least full bin that can accommodate the item,\n    # we can use the following formula instead:\n    # priority_scores[eligible_bins] = -remaining_capacity_after_item[eligible_bins]\n    \n    return priority_scores\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to \n    accommodate the item, to avoid splitting items across multiple bins. It uses a \n    combination of the remaining capacity and the item size to calculate the priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the \"closeness\" of each bin to being full after adding the item\n    remaining_capacity_after_item = bins_remain_cap - item\n    \n    # Initialize priority scores with zeros\n    priority_scores = np.zeros_like(bins_remain_cap)\n    \n    # Ignore bins that cannot accommodate the item\n    eligible_bins = remaining_capacity_after_item >= 0\n    \n    # For eligible bins, higher priorities are assigned to bins that are closer to being full\n    priority_scores[eligible_bins] = 1 / (1 + remaining_capacity_after_item[eligible_bins])\n    \n    # Alternatively, if we want to favor the least full bin that can accommodate the item,\n    # we can use the following formula instead:\n    # priority_scores[eligible_bins] = -remaining_capacity_after_item[eligible_bins]\n    \n    return priority_scores\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function favors bins that have the most remaining capacity,\n    while at the same time trying to fit items into bins where they would \n    minimize the remaining capacity, thus reducing waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste (remaining capacity) if the item is added to each bin\n    waste = bins_remain_cap - item\n    \n    # Delta : Give higher priority to bins where item fits more tightly\n    delta = np.where(waste < 0, -np.inf, waste)\n    \n    # More remaining space, higher priority\n    priority = bins_remain_cap\n    \n    # Balance priorities such that bins with higher remaining capacity have lower priority scores when item cannot fit\n    priority = np.where(delta > 0, priority / (delta + 1e-10), -np.inf)\n    \n    # If item cannot be packed, bin should not be selected.\n    priority = np.where(bins_remain_cap < item, -np.inf, priority)\n    \n    return priority\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function favors bins that have the most remaining capacity,\n    while at the same time trying to fit items into bins where they would \n    minimize the remaining capacity, thus reducing waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste (remaining capacity) if the item is added to each bin\n    waste = bins_remain_cap - item\n    \n    # Delta : Give higher priority to bins where item fits more tightly\n    delta = np.where(waste < 0, -np.inf, waste)\n    \n    # More remaining space, higher priority\n    priority = bins_remain_cap\n    \n    # Balance priorities such that bins with higher remaining capacity have lower priority scores when item cannot fit\n    priority = np.where(delta > 0, priority / (delta + 1e-10), -np.inf)\n    \n    # If item cannot be packed, bin should not be selected.\n    priority = np.where(bins_remain_cap < item, -np.inf, priority)\n    \n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function favors bins that have the most remaining capacity,\n    while taking into account the size of the item to be added.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the ratio of remaining capacity to item size for each bin\n    ratio = bins_remain_cap / item\n    \n    # Apply a penalty to bins that are already close to full\n    penalty = (1 - (bins_remain_cap / item)) * (bins_remain_cap < item)\n    \n    # Calculate the priority score as the product of the ratio and the penalty\n    priority = ratio * (1 - penalty)\n    \n    # Add a small positive value to avoid division by zero\n    priority += np.finfo(np.float64).eps\n    \n    # Normalize the priority scores to favor bins with the most remaining capacity\n    priority = priority / np.sum(priority)\n    \n    return np.array(priority)\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins with the most remaining capacity,\n    and essentially acts as a First-Fit Decreasing (FFD) heuristic.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap, -1)\n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function favors bins that have the most remaining capacity\n    and.dispose of bins that are likely to leave a small gap after the item is placed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the ratio of the item size to the remaining capacity of each bin\n    ratio = item / np.maximum(bins_remain_cap, 1e-8)  # avoid division by zero\n    \n    # Assign higher priority to bins with lower ratio (i.e., less likely to leave a small gap)\n    # and with more remaining capacity (i.e., more space to accommodate future items)\n    priority = bins_remain_cap * (1 - ratio)\n    \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins with the most remaining capacity,\n    and essentially acts as a First-Fit Decreasing (FFD) heuristic.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap, -1)\n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function favors bins that have the most remaining capacity\n    and_Set_Failed have enough capacity to fit the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity relative to the item size\n    relative_cap = bins_remain_cap / item\n    \n    # Favor bins with enough capacity to fit the item\n    capacity_mask = bins_remain_cap >= item\n    \n    # Use a weighted sum to balance the two objectives\n    priority = np.where(capacity_mask, relative_cap, 0)\n    \n    # Ensure bins with negative remaining capacity have zero priority\n    priority = np.maximum(priority, 0)\n    \n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have enough capacity to hold the item,\n    and gives higher priority to bins that have just enough capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.where(bins_remain_cap >= item, \n                          bins_remain_cap - item + 1, \n                          0)\n    # The '+1' in the np.where line ensures that the priority is higher for bins that have \n    # just enough capacity to hold the item. This encourages the algorithm to pack bins tightly.\n    return priorities / (priorities.sum() + 1)  # Normalize priorities to add more stability\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have enough capacity to fit the item,\n    and give higher priority to bins that have the most available space relative to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the available space in each bin relative to the item size\n    relative_available_space = bins_remain_cap - item\n    \n    # Favor bins that can fit the item and have the most available space relative to the item size\n    priority = np.where(relative_available_space >= 0, relative_available_space / item, -np.inf)\n    \n    # Add a small perturbation to break ties in favor of bins with more absolute available space\n    priority += 1e-6 * bins_remain_cap / (1 + bins_remain_cap.sum())\n    \n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}