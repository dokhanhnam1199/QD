{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, all_items: np.ndarray = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to improve upon the previous version by \n    considering multiple objectives, prioritizing efficient placements, and \n    anticipating future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        all_items: Optional array of all items (including future ones) for forecasting.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    # Introduce a 'balance' factor to prioritize bins with remaining capacity close to 50% of the bin size\n    balance_factor = 1 - np.abs((bins_remain_cap - item) / (bins_remain_cap + item))\n    priority *= balance_factor\n    \n    # If all items are provided, consider forecasting future items to anticipate constraints\n    if all_items is not None:\n        future_items = all_items[all_items > item]\n        forecast_factor = 1 / (1 + np.sum(future_items))\n        priority *= forecast_factor\n    \n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, all_items: np.ndarray = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to improve upon the previous version by \n    considering multiple objectives, prioritizing efficient placements, and \n    anticipating future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        all_items: Optional array of all items (including future ones) for forecasting.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    # Introduce a 'balance' factor to prioritize bins with remaining capacity close to 50% of the bin size\n    balance_factor = 1 - np.abs((bins_remain_cap - item) / (bins_remain_cap + item))\n    priority *= balance_factor\n    \n    # If all items are provided, consider forecasting future items to anticipate constraints\n    if all_items is not None:\n        future_items = all_items[all_items > item]\n        forecast_factor = 1 / (1 + np.sum(future_items))\n        priority *= forecast_factor\n    \n    return priority\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, all_items: np.ndarray = None, alpha: float = 0.5, beta: float = 0.3, gamma: float = 0.2) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to balance competing factors, prioritize efficient placements, and anticipate future items.\n    It considers the difference between the remaining capacity and the item size, the current utilization of each bin, and the expected future utilization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        all_items: Array of all item sizes (optional).\n        alpha: Weight for the capacity difference factor.\n        beta: Weight for the current utilization factor.\n        gamma: Weight for the future utilization factor.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the capacity difference factor\n    priority_capacity = 1 / (1 + capacity_diff)\n    \n    # Calculate the current utilization of each bin\n    current_utilization = 1 - (bins_remain_cap / np.sum(bins_remain_cap))\n    \n    # Calculate the priority score for the current utilization factor\n    priority_utilization = 1 / (1 + current_utilization)\n    \n    # If all item sizes are provided, calculate the expected future utilization\n    if all_items is not None:\n        # Calculate the average item size\n        avg_item_size = np.mean(all_items)\n        \n        # Calculate the expected future utilization of each bin\n        future_utilization = bins_remain_cap / (np.sum(bins_remain_cap) + avg_item_size)\n        \n        # Calculate the priority score for the future utilization factor\n        priority_future = 1 / (1 + future_utilization)\n    else:\n        priority_future = np.ones_like(bins_remain_cap)\n    \n    # Calculate the overall priority score by combining the three factors\n    priority = alpha * priority_capacity + beta * priority_utilization + gamma * priority_future\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, historic_item_sizes: np.ndarray = None, alpha: float = 0.5, beta: float = 0.3) -> np.ndarray:\n    \"\"\"\n    Returns a priority score for each bin, taking into account the item size, remaining capacity, \n    and potential future items. This heuristic aims to balance efficient placements, minimize waste, \n    and anticipate future constraints.\n\n    Args:\n        item: Size of the item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        historic_item_sizes: Array of previously seen item sizes (default is None).\n        alpha: Weight for the capacity difference objective (default is 0.5).\n        beta: Weight for the future item forecasting objective (default is 0.3).\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority_capacity = 1 / (1 + capacity_diff)\n    \n    # If historic item sizes are available, forecast future item sizes\n    if historic_item_sizes is not None:\n        # Calculate the average size of historic items\n        avg_historic_size = np.mean(historic_item_sizes)\n        \n        # Calculate the difference between the remaining capacity of each bin and the forecasted item size\n        forecast_diff = np.abs(bins_remain_cap - avg_historic_size)\n        \n        # Invert the differences to obtain a priority score (lower difference -> higher priority)\n        priority_forecast = 1 / (1 + forecast_diff)\n        \n        # Combine the priority scores using weighting factors\n        priority = alpha * priority_capacity + beta * priority_forecast\n    else:\n        # If no historic item sizes are available, use only the capacity difference objective\n        priority = priority_capacity\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    return priority\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, historic_item_sizes: np.ndarray = None, alpha: float = 0.5, beta: float = 0.3) -> np.ndarray:\n    \"\"\"\n    Returns a priority score for each bin, taking into account the item size, remaining capacity, \n    and potential future items. This heuristic aims to balance efficient placements, minimize waste, \n    and anticipate future constraints.\n\n    Args:\n        item: Size of the item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        historic_item_sizes: Array of previously seen item sizes (default is None).\n        alpha: Weight for the capacity difference objective (default is 0.5).\n        beta: Weight for the future item forecasting objective (default is 0.3).\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority_capacity = 1 / (1 + capacity_diff)\n    \n    # If historic item sizes are available, forecast future item sizes\n    if historic_item_sizes is not None:\n        # Calculate the average size of historic items\n        avg_historic_size = np.mean(historic_item_sizes)\n        \n        # Calculate the difference between the remaining capacity of each bin and the forecasted item size\n        forecast_diff = np.abs(bins_remain_cap - avg_historic_size)\n        \n        # Invert the differences to obtain a priority score (lower difference -> higher priority)\n        priority_forecast = 1 / (1 + forecast_diff)\n        \n        # Combine the priority scores using weighting factors\n        priority = alpha * priority_capacity + beta * priority_forecast\n    else:\n        # If no historic item sizes are available, use only the capacity difference objective\n        priority = priority_capacity\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    return priority\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, all_items: np.ndarray = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to improve upon the previous version by \n    considering multiple objectives, prioritizing efficient placements, and \n    anticipating future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        all_items: Optional array of all items (including future ones) for forecasting.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    # Introduce a 'balance' factor to prioritize bins with remaining capacity close to 50% of the bin size\n    balance_factor = 1 - np.abs((bins_remain_cap - item) / (bins_remain_cap + item))\n    priority *= balance_factor\n    \n    # If all items are provided, consider forecasting future items to anticipate constraints\n    if all_items is not None:\n        future_items = all_items[all_items > item]\n        forecast_factor = 1 / (1 + np.sum(future_items))\n        priority *= forecast_factor\n    \n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of previous heuristics for better performance.\n    \"\"\"\n    # Calculate the waste (remaining capacity) if the item is added to each bin\n    waste = bins_remain_cap - item\n    \n    # Give higher priority to bins where item fits more tightly\n    delta = np.where(waste < 0, -np.inf, waste)\n    \n    # Prioritize bins with just enough capacity and higher available space\n    priority = np.where(delta > 0, bins_remain_cap / (delta + 1e-10), -np.inf)\n    \n    # Avoid bins that are too full or too empty\n    priority = np.where(bins_remain_cap < item, -np.inf, priority)\n    priority = np.where(bins_remain_cap == 0, priority * 0.9, priority)  # reduce priority for empty bins\n    \n    # Balance priorities based on bin fullness and item fit\n    priority = np.where(bins_remain_cap > item, priority * (1 + (bins_remain_cap - item) / (bins_remain_cap + 1e-10)), priority)\n    \n    return priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of previous heuristics for better performance.\n    \"\"\"\n    # Calculate the waste (remaining capacity) if the item is added to each bin\n    waste = bins_remain_cap - item\n    \n    # Give higher priority to bins where item fits more tightly\n    delta = np.where(waste < 0, -np.inf, waste)\n    \n    # Prioritize bins with just enough capacity and higher available space\n    priority = np.where(delta > 0, bins_remain_cap / (delta + 1e-10), -np.inf)\n    \n    # Avoid bins that are too full or too empty\n    priority = np.where(bins_remain_cap < item, -np.inf, priority)\n    priority = np.where(bins_remain_cap == 0, priority * 0.9, priority)  # reduce priority for empty bins\n    \n    # Balance priorities based on bin fullness and item fit\n    priority = np.where(bins_remain_cap > item, priority * (1 + (bins_remain_cap - item) / (bins_remain_cap + 1e-10)), priority)\n    \n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, historic_item_sizes: np.ndarray = None, alpha: float = 0.5, beta: float = 0.3) -> np.ndarray:\n    \"\"\"\n    Returns a priority score for each bin, balancing the current item's fit with future potential and bin utilization.\n\n    Args:\n        item: Size of the item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        historic_item_sizes: Optional array of previously packed item sizes for forecasting.\n        alpha: Weight for the current item's fit (default: 0.5).\n        beta: Weight for bin utilization and future potential (default: 0.3).\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    fit_priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    fit_priority[bins_remain_cap < item] = 0\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    if historic_item_sizes is not None:\n        avg_historic_size = np.mean(historic_item_sizes)\n        utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)\n    else:\n        utilization_priority = bins_remain_cap / (bins_remain_cap + item)\n    \n    # Calculate the overall priority, balancing the current item's fit and bin utilization\n    priority = alpha * fit_priority + beta * utilization_priority\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    priority = np.nan_to_num(priority)\n    \n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, historic_item_sizes: np.ndarray = None, alpha: float = 0.5, beta: float = 0.3) -> np.ndarray:\n    \"\"\"\n    Returns a priority score for each bin, balancing the current item's fit with future potential and bin utilization.\n\n    Args:\n        item: Size of the item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        historic_item_sizes: Optional array of previously packed item sizes for forecasting.\n        alpha: Weight for the current item's fit (default: 0.5).\n        beta: Weight for bin utilization and future potential (default: 0.3).\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    fit_priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    fit_priority[bins_remain_cap < item] = 0\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    if historic_item_sizes is not None:\n        avg_historic_size = np.mean(historic_item_sizes)\n        utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)\n    else:\n        utilization_priority = bins_remain_cap / (bins_remain_cap + item)\n    \n    # Calculate the overall priority, balancing the current item's fit and bin utilization\n    priority = alpha * fit_priority + beta * utilization_priority\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    priority = np.nan_to_num(priority)\n    \n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, historic_item_sizes: np.ndarray = None, alpha: float = 0.5, beta: float = 0.3) -> np.ndarray:\n    \"\"\"\n    Returns a priority score for each bin, balancing the current item's fit with future potential and bin utilization.\n\n    Args:\n        item: Size of the item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        historic_item_sizes: Optional array of previously packed item sizes for forecasting.\n        alpha: Weight for the current item's fit (default: 0.5).\n        beta: Weight for bin utilization and future potential (default: 0.3).\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    fit_priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    fit_priority[bins_remain_cap < item] = 0\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    if historic_item_sizes is not None:\n        avg_historic_size = np.mean(historic_item_sizes)\n        utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)\n    else:\n        utilization_priority = bins_remain_cap / (bins_remain_cap + item)\n    \n    # Calculate the overall priority, balancing the current item's fit and bin utilization\n    priority = alpha * fit_priority + beta * utilization_priority\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    priority = np.nan_to_num(priority)\n    \n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines factors for a balanced heuristic.\n    \"\"\"\n    # Calculate the wasted space for each bin if the item is added\n    wasted_space = np.maximum(bins_remain_cap - item, 0)\n    \n    # Invert the wasted space so that bins with least wasted space get higher priority\n    inverted_wasted_space = 1 / (wasted_space + 1e-6)  # Add small value for numerical stability\n    \n    # Calculate the priority score for each bin based on the remaining capacity and item fit\n    priority_score = inverted_wasted_space * (bins_remain_cap / (bins_remain_cap + item + 1e-6))  # Add small value for numerical stability\n    \n    # Consider bins that have enough capacity to hold the item and favor tight fits\n    capacity_priority = np.where(bins_remain_cap >= item, \n                                 bins_remain_cap - item + 1, \n                                 0)\n    \n    # Combine the two priorities\n    combined_priority = priority_score * capacity_priority\n    \n    # Normalize the priorities to ensure they add up to 1\n    normalized_priority = combined_priority / (np.sum(combined_priority) + 1e-6)\n    \n    return normalized_priority\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, penalty_factor_weight: float = 8.58149997527536, high_priority_threshold: float = 0.746603897593442, capacity_weight: float = 2.2257343880522464) -> np.ndarray:\n    \"\"\"\n    Combines elements of v0 and v1 heuristics for better outcomes.\n    \"\"\"\n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = penalty_factor_weight / (1 + np.exp(shortfall)) * penalty_factor_weight / (1 + np.exp(excess))\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap * penalty_factor, -1)\n    \n    # Ensure bins with higher remaining capacity get higher priority when the item fits\n    priority = np.where(bins_remain_cap >= item, priority + capacity_weight * bins_remain_cap, priority)\n    \n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of v0 and v1 heuristics for better outcomes.\n    \"\"\"\n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap * penalty_factor, -1)\n    \n    # Ensure bins with higher remaining capacity get higher priority when the item fits\n    priority = np.where(bins_remain_cap >= item, priority + bins_remain_cap, priority)\n    \n    return priority\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of v0 and v1 heuristics for better outcomes.\n    \"\"\"\n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap * penalty_factor, -1)\n    \n    # Ensure bins with higher remaining capacity get higher priority when the item fits\n    priority = np.where(bins_remain_cap >= item, priority + bins_remain_cap, priority)\n    \n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of v0 and v1 heuristics for better outcomes.\n    \"\"\"\n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap * penalty_factor, -1)\n    \n    # Ensure bins with higher remaining capacity get higher priority when the item fits\n    priority = np.where(bins_remain_cap >= item, priority + bins_remain_cap, priority)\n    \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combine bin fullness and item fit for priority.\n    \"\"\"\n    # Calculate the ratio of the item size to the remaining capacity of each bin\n    ratio = item / np.maximum(bins_remain_cap, 1e-8)  # avoid division by zero\n    \n    # Assign higher priority to bins with lower ratio (i.e., less likely to leave a small gap)\n    # and with more remaining capacity (i.e., more space to accommodate future items)\n    priority = np.where(bins_remain_cap >= item, \n                       # for bins that can hold the item, the priority is inversely proportional to the remaining capacity\n                       bins_remain_cap * (1 - ratio) / (bins_remain_cap + 1), \n                       # for bins that cannot hold the item, the priority is zero\n                       0.0)\n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of v0 and v1 heuristics for better results.\n    \"\"\"\n    # Calculate priority based on how full the bin is and how well the item fits\n    priority_fullness = np.where(bins_remain_cap >= item, \n                                 # for bins that can hold the item, the priority is inversely proportional to the remaining capacity\n                                 1.0 / (bins_remain_cap + 1), \n                                 # for bins that cannot hold the item, the priority is zero\n                                 0.0)\n    \n    # Calculate priority based on available space relative to the item size\n    priority_space = np.where(bins_remain_cap >= item, bins_remain_cap, -1)\n    \n    # Combine the two priorities, giving more weight to the fullness priority\n    priorities = 0.7 * priority_fullness + 0.3 * priority_space\n    \n    # Ensure priorities are not negative\n    priorities = np.where(priorities < 0, 0, priorities)\n    \n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combine balance and forecasting to prioritize bins.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    # to encourage packing items into bins where the item size is close to the remaining capacity\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # Calculate the available space in each bin relative to the item size\n    # to favor bins that have enough capacity to fit the item and have the most available space\n    relative_available_space = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Combine the two priorities to balance competing factors\n    combined_priority = priority * relative_available_space / (item + 1e-6)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    combined_priority[bins_remain_cap < item] = 0\n    \n    return combined_priority\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combine balance and forecasting to prioritize bins.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    # to encourage packing items into bins where the item size is close to the remaining capacity\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # Calculate the available space in each bin relative to the item size\n    # to favor bins that have enough capacity to fit the item and have the most available space\n    relative_available_space = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Combine the two priorities to balance competing factors\n    combined_priority = priority * relative_available_space / (item + 1e-6)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    combined_priority[bins_remain_cap < item] = 0\n    \n    return combined_priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}