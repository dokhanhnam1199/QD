```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, all_items: np.ndarray = None, alpha: float = 0.5, beta: float = 0.3, gamma: float = 0.2) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.

    This priority function is designed to balance competing factors, prioritize efficient placements, and anticipate future items.
    It considers the difference between the remaining capacity and the item size, the current utilization of each bin, and the expected future utilization.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
        all_items: Array of all item sizes (optional).
        alpha: Weight for the capacity difference factor.
        beta: Weight for the current utilization factor.
        gamma: Weight for the future utilization factor.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the difference between the remaining capacity of each bin and the item size
    capacity_diff = np.abs(bins_remain_cap - item)
    
    # Invert the differences to obtain a priority score for the capacity difference factor
    priority_capacity = 1 / (1 + capacity_diff)
    
    # Calculate the current utilization of each bin
    current_utilization = 1 - (bins_remain_cap / np.sum(bins_remain_cap))
    
    # Calculate the priority score for the current utilization factor
    priority_utilization = 1 / (1 + current_utilization)
    
    # If all item sizes are provided, calculate the expected future utilization
    if all_items is not None:
        # Calculate the average item size
        avg_item_size = np.mean(all_items)
        
        # Calculate the expected future utilization of each bin
        future_utilization = bins_remain_cap / (np.sum(bins_remain_cap) + avg_item_size)
        
        # Calculate the priority score for the future utilization factor
        priority_future = 1 / (1 + future_utilization)
    else:
        priority_future = np.ones_like(bins_remain_cap)
    
    # Calculate the overall priority score by combining the three factors
    priority = alpha * priority_capacity + beta * priority_utilization + gamma * priority_future
    
    # If the item size exceeds the remaining capacity, set the priority to 0
    priority[bins_remain_cap < item] = 0
    
    return priority
```
