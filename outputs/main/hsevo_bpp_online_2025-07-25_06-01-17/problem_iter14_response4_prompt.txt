{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines adaptive weighting and multi-objective optimization.\n    \"\"\"\n    # Calculate the waste (remaining capacity) if the item is added to each bin\n    waste = bins_remain_cap - item\n    \n    # Give higher priority to bins where item fits more tightly\n    delta = np.where(waste < 0, -np.inf, waste)\n    \n    # Prioritize bins with just enough capacity and higher available space\n    priority_tight_fit = np.where(delta > 0, bins_remain_cap / (delta + 1e-10), -np.inf)\n    \n    # Calculate the ratio of the item size to the remaining capacity of each bin\n    ratio = item / np.maximum(bins_remain_cap, 1e-8)  # avoid division by zero\n    \n    # Assign higher priority to bins with lower ratio (i.e., less likely to leave a small gap)\n    # and with more remaining capacity (i.e., more space to accommodate future items)\n    priority_ratio = np.where(bins_remain_cap >= item, \n                              # for bins that can hold the item, the priority is inversely proportional to the remaining capacity\n                              bins_remain_cap * (1 - ratio) / (bins_remain_cap + 1), \n                              # for bins that cannot hold the item, the priority is zero\n                              0.0)\n    \n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority_capacity = 1 / (1 + capacity_diff)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Calculate the shortfall or excess capacity for each bin\n    adaptive_shortfall = np.maximum(0, item - bins_remain_cap)\n    adaptive_excess = np.maximum(0, bins_remain_cap - item)\n    adaptive_weight = 1 / (1 + np.exp(-item / np.mean(bins_remain_cap)))\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    adaptive_fit_priority = adaptive_weight / (1 + capacity_diff)\n    \n    # Calculate a utilization-aware penalty factor for each bin\n    utilization_penalty = 1 / (1 + np.exp(-adaptive_shortfall / np.mean(bins_remain_cap))) * 1 / (1 + np.exp(adaptive_excess / np.mean(bins_remain_cap)))\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    avg_historic_size = np.mean(bins_remain_cap)  # Using mean remaining capacity as a proxy for historic item sizes\n    utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)\n    \n    # Calculate a dynamic weight for balancing fit and utilization priorities\n    dynamic_weight = np.exp(-(capacity_diff / np.mean(capacity_diff)))\n    \n    # Combine priorities using adaptive weighting\n    alpha = 0.7  # weight for priority based on waste\n    beta = 0.2  # weight for priority based on ratio\n    gamma = 0.1  # weight for priority based on capacity difference\n    delta_weight = 0.5  # weight for adaptive fit priority\n    epsilon_weight = 0.5  # weight for utilization priority\n    combined_priority = alpha * priority_tight_fit + beta * priority_ratio + gamma * priority_capacity * penalty_factor\n    combined_priority += delta_weight * adaptive_fit_priority + epsilon_weight * utilization_priority * utilization_penalty * bins_remain_cap\n    \n    # Avoid bins that are too full or too empty\n    combined_priority = np.where(bins_remain_cap < item, -np.inf, combined_priority)\n    combined_priority = np.where(bins_remain_cap == 0, combined_priority * 0.9, combined_priority)  # reduce priority for empty bins\n    \n    return combined_priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines adaptive weighting and multi-objective optimization with balancing.\n    \"\"\"\n    \n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority_capacity = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority_capacity[bins_remain_cap < item] = 0\n    \n    # Calculate priority based on how full the bin is and how well the item fits\n    priority_fullness = np.where(bins_remain_cap >= item, \n                                 # for bins that can hold the item, the priority is inversely proportional to the remaining capacity\n                                 1.0 / (bins_remain_cap + 1), \n                                 # for bins that cannot hold the item, the priority is zero\n                                 0.0)\n    \n    # Introduce a 'balance' factor to prioritize bins with remaining capacity close to 50% of the bin size\n    balance_factor = 1 - np.abs((bins_remain_cap - item) / (bins_remain_cap + item))\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    avg_historic_size = np.mean(bins_remain_cap)  # Using mean remaining capacity as a proxy for historic item sizes\n    utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)\n    \n    # Adaptive weighting based on the problem's current state\n    total_remain_cap = np.sum(bins_remain_cap)\n    if total_remain_cap == 0:\n        adapt_weight = 0\n    else:\n        adapt_weight = (item / total_remain_cap) * 0.4 + (1 - item / total_remain_cap) * 0.3\n    \n    # Dynamic prioritization based on the current item's size and the remaining capacities\n    dynamic_prioritization = np.exp(-capacity_diff / (1 + item))\n    \n    # Combine the priorities using adaptive weighting\n    priorities = adapt_weight * priority_capacity + (1 - adapt_weight) * (0.3 * utilization_priority + 0.2 * balance_factor + 0.1 * penalty_factor + 0.1 * dynamic_prioritization)\n    \n    # Ensure priorities are not negative\n    priorities = np.where(priorities < 0, 0, priorities)\n    \n    # Consider the remaining capacity of each bin to avoid overfilling\n    priorities = np.where(bins_remain_cap >= item, priorities + 0.01 * bins_remain_cap, priorities)\n    \n    return priorities\n\n### Analyze & experience\n- Comparing the 1st vs the 20th heuristics, we see a significant difference in the approach to calculating priorities, with the 1st heuristic using a more complex formula involving dynamic weighting and forecasting, while the 20th heuristic uses a simpler approach based on capacity differences and bin fullness. \nComparing the 2nd vs the 19th heuristics, we see that both use similar techniques, but the 2nd heuristic incorporates additional factors such as shortfall and excess capacity, which may lead to more efficient bin packing. \nComparing the 3rd vs the 18th heuristics, we see that the 3rd heuristic uses a more adaptive approach to weighting, taking into account the problem's current state, whereas the 18th heuristic uses a fixed weighting scheme. \nComparing the 4th vs the 17th heuristics, we see that the 4th heuristic incorporates a forecasted utilization priority, which may help to avoid overfilling bins, whereas the 17th heuristic does not consider this factor. \nComparing the 5th vs the 16th heuristics, we see that the 5th heuristic uses a more sophisticated approach to calculating the overall priority, involving alpha, beta, and gamma weights, whereas the 16th heuristic uses a simpler approach based on priority capacity and fullness. \nComparing the 6th vs the 15th heuristics, we see that the 6th heuristic uses a more dynamic approach to weighting, involving log and exponential functions, whereas the 15th heuristic uses a more static approach. \nComparing the 7th vs the 14th heuristics, we see that the 7th heuristic incorporates a balance factor to prioritize bins with remaining capacity close to 50% of the bin size, whereas the 14th heuristic does not consider this factor. \nComparing the 8th vs the 13th heuristics, we see that the 8th heuristic uses a more complex approach involving forecasting and adaptation to the problem state, whereas the 13th heuristic uses a simpler approach based on capacity differences and bin fullness. \nComparing the 9th vs the 12th heuristics, we see that the 9th heuristic incorporates a penalty factor for bins with low remaining capacity, whereas the 12th heuristic does not consider this factor. \nComparing the 10th vs the 11th heuristics, we see that the 10th heuristic uses a more static approach to weighting, whereas the 11th heuristic uses a more dynamic approach involving adaptation to the problem state. \nOverall: The better heuristics tend to use more complex and adaptive approaches to calculating priorities, incorporating factors such as dynamic weighting, forecasting, and adaptation to the problem state.\n- \nHere's a redefined 'Current self-reflection' to design better heuristics:\n* Keywords: Adaptive weighting, multiple objectives, dynamic weighting\n* Advice: Combine multiple objectives, use dynamic weighting, and incorporate forecasting\n* Avoid: Prioritizing tight fits, overemphasizing future item placements\n* Explanation: Effective heuristics balance multiple objectives, adapt to the problem's state, and use dynamic weighting to optimize solutions.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}