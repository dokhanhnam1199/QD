{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.5, beta: float = 0.3) -> np.ndarray:\n    \"\"\"\n    Combines multi-objective priorities with dynamic weighting.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    fit_priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    fit_priority[bins_remain_cap < item] = 0\n    \n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    avg_historic_size = np.mean(bins_remain_cap)  # Using mean remaining capacity as a proxy for historic item sizes\n    utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)\n    \n    # Calculate the overall priority, balancing the current item's fit and bin utilization\n    priority = alpha * fit_priority + beta * utilization_priority + (1 - alpha - beta) * penalty_factor * bins_remain_cap\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    priority = np.nan_to_num(priority)\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, priority, -1)\n    \n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, all_items: np.ndarray = None) -> np.ndarray:\n    \"\"\"\n    Combines capacity difference, balance factor, and forecasting for a robust heuristic.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    # Introduce a 'balance' factor to prioritize bins with remaining capacity close to 50% of the bin size\n    balance_factor = 1 - np.abs((bins_remain_cap - item) / (bins_remain_cap + item))\n    priority *= balance_factor\n    \n    # Calculate the wasted space for each bin if the item is added\n    wasted_space = np.maximum(bins_remain_cap - item, 0)\n    \n    # Invert the wasted space so that bins with least wasted space get higher priority\n    inverted_wasted_space = 1 / (wasted_space + 1e-6)  # Add small value for numerical stability\n    \n    # Combine the two priorities\n    combined_priority = priority * inverted_wasted_space\n    \n    # Consider forecasting future items to anticipate constraints\n    if all_items is not None:\n        future_items = all_items[all_items > item]\n        forecast_factor = 1 / (1 + np.sum(future_items))\n        combined_priority *= forecast_factor\n    \n    # Normalize the priorities to ensure they add up to 1\n    normalized_priority = combined_priority / (np.sum(combined_priority) + 1e-6)\n    \n    return normalized_priority\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                all_items: np.ndarray = None, alpha: float = 0.5, beta: float = 0.3, gamma: float = 0.2) -> np.ndarray:\n    \"\"\"\n    Combines capacity difference, balance factor, and forecasting for bin prioritization.\n    \"\"\"\n    \n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the capacity difference factor\n    priority_capacity = 1 / (1 + capacity_diff)  # Prioritize bins with smallest capacity difference\n    \n    # Calculate the current utilization of each bin\n    current_utilization = 1 - (bins_remain_cap / np.sum(bins_remain_cap))\n    \n    # Calculate the priority score for the current utilization factor\n    priority_utilization = 1 / (1 + current_utilization)  # Prioritize bins with lowest utilization\n    \n    # If all item sizes are provided, calculate the expected future utilization\n    if all_items is not None:\n        # Calculate the average item size\n        avg_item_size = np.mean(all_items)\n        \n        # Calculate the expected future utilization of each bin\n        future_utilization = bins_remain_cap / (np.sum(bins_remain_cap) + avg_item_size)\n        \n        # Calculate the priority score for the future utilization factor\n        priority_future = 1 / (1 + future_utilization)  # Prioritize bins with lowest expected future utilization\n    else:\n        priority_future = np.ones_like(bins_remain_cap)\n    \n    # Calculate the overall priority score by combining the three factors\n    priority = alpha * priority_capacity + beta * priority_utilization + gamma * priority_future\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0  # Ensure item can fit in bin\n    \n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.4, beta: float = 0.3, gamma: float = 0.3) -> np.ndarray:\n    \"\"\"\n    Combines multi-objective priorities with dynamic weighting, incorporating trade-offs and flexibility.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    fit_priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    fit_priority[bins_remain_cap < item] = 0\n    \n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    avg_historic_size = np.mean(bins_remain_cap)  # Using mean remaining capacity as a proxy for historic item sizes\n    utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)\n    \n    # Calculate the bin fragmentation, prioritizing bins with less wasted space\n    fragmentation_priority = 1 / (1 + np.abs(bins_remain_cap - item) / bins_remain_cap)\n    fragmentation_priority[bins_remain_cap == 0] = 0\n    \n    # Calculate the overall priority, balancing the current item's fit, bin utilization, and fragmentation\n    priority = alpha * fit_priority + beta * utilization_priority + gamma * fragmentation_priority\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    priority = np.nan_to_num(priority)\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, priority, -1)\n    \n    return priority\n\ndef adaptive_priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.4, beta: float = 0.3, gamma: float = 0.3) -> np.ndarray:\n    \"\"\"\n    Dynamically adjusts the weighting of priorities based on the problem's progress.\n    \"\"\"\n    # Calculate the average remaining capacity and item size\n    avg_remain_cap = np.mean(bins_remain_cap)\n    avg_item_size = item\n    \n    # Adjust the weighting factors based on the problem's progress\n    if avg_remain_cap < avg_item_size:\n        alpha += 0.1\n        beta -= 0.1\n    else:\n        alpha -= 0.1\n        beta += 0.1\n    \n    # Ensure the weighting factors are within valid ranges\n    alpha = max(0, min(alpha, 1))\n    beta = max(0, min(beta, 1))\n    gamma = 1 - alpha - beta\n    \n    # Calculate the priority using the adjusted weighting factors\n    priority = priority_v2(item, bins_remain_cap, alpha, beta, gamma)\n    \n    return priority\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, all_items: np.ndarray = None) -> np.ndarray:\n    \"\"\"\n    Combines capacity difference, balance factor, and forecasting for a robust heuristic.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    # Introduce a 'balance' factor to prioritize bins with remaining capacity close to 50% of the bin size\n    balance_factor = 1 - np.abs((bins_remain_cap - item) / (bins_remain_cap + item))\n    priority *= balance_factor\n    \n    # Calculate the wasted space for each bin if the item is added\n    wasted_space = np.maximum(bins_remain_cap - item, 0)\n    \n    # Invert the wasted space so that bins with least wasted space get higher priority\n    inverted_wasted_space = 1 / (wasted_space + 1e-6)  # Add small value for numerical stability\n    \n    # Combine the two priorities\n    combined_priority = priority * inverted_wasted_space\n    \n    # Consider forecasting future items to anticipate constraints\n    if all_items is not None:\n        future_items = all_items[all_items > item]\n        forecast_factor = 1 / (1 + np.sum(future_items))\n        combined_priority *= forecast_factor\n    \n    # Normalize the priorities to ensure they add up to 1\n    normalized_priority = combined_priority / (np.sum(combined_priority) + 1e-6)\n    \n    return normalized_priority\n\n[Heuristics 6th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    alpha: float = 0.5029788187823183, \n    beta: float = 0.354118246767853, \n    threshold_item_size: float = 1.7749043239515936, \n    utilization_threshold: float = 0.8882678823010766, \n    penalty_factor_weight: float = 5.6183698719462525, \n    historic_size_weight: float = 5.24157358822766) -> np.ndarray:\n    \"\"\"\n    Combines multi-objective priorities with dynamic weighting.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    fit_priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    fit_priority[bins_remain_cap < item] = 0\n    \n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = penalty_factor_weight / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    avg_historic_size = historic_size_weight * np.mean(bins_remain_cap)  # Using mean remaining capacity as a proxy for historic item sizes\n    utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)\n    \n    # Ensure utilization_priority does not exceed the utilization_threshold\n    utilization_priority = np.where(utilization_priority > utilization_threshold, utilization_threshold, utilization_priority)\n    \n    # Calculate the overall priority, balancing the current item's fit and bin utilization\n    priority = alpha * fit_priority + beta * utilization_priority + (1 - alpha - beta) * penalty_factor * bins_remain_cap\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    priority = np.nan_to_num(priority)\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= threshold_item_size, priority, -1)\n    \n    return priority\n\n[Heuristics 7th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    alpha: float = 0.5029788187823183, \n    beta: float = 0.354118246767853, \n    threshold_item_size: float = 1.7749043239515936, \n    utilization_threshold: float = 0.8882678823010766, \n    penalty_factor_weight: float = 5.6183698719462525, \n    historic_size_weight: float = 5.24157358822766) -> np.ndarray:\n    \"\"\"\n    Combines multi-objective priorities with dynamic weighting.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    fit_priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    fit_priority[bins_remain_cap < item] = 0\n    \n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = penalty_factor_weight / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    avg_historic_size = historic_size_weight * np.mean(bins_remain_cap)  # Using mean remaining capacity as a proxy for historic item sizes\n    utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)\n    \n    # Ensure utilization_priority does not exceed the utilization_threshold\n    utilization_priority = np.where(utilization_priority > utilization_threshold, utilization_threshold, utilization_priority)\n    \n    # Calculate the overall priority, balancing the current item's fit and bin utilization\n    priority = alpha * fit_priority + beta * utilization_priority + (1 - alpha - beta) * penalty_factor * bins_remain_cap\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    priority = np.nan_to_num(priority)\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= threshold_item_size, priority, -1)\n    \n    return priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, all_items: np.ndarray = None) -> np.ndarray:\n    \"\"\"\n    Combines capacity difference, balance factor, and forecasting for a robust heuristic.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    # Introduce a 'balance' factor to prioritize bins with remaining capacity close to 50% of the bin size\n    balance_factor = 1 - np.abs((bins_remain_cap - item) / (bins_remain_cap + item))\n    priority *= balance_factor\n    \n    # Calculate the wasted space for each bin if the item is added\n    wasted_space = np.maximum(bins_remain_cap - item, 0)\n    \n    # Invert the wasted space so that bins with least wasted space get higher priority\n    inverted_wasted_space = 1 / (wasted_space + 1e-6)  # Add small value for numerical stability\n    \n    # Combine the two priorities\n    combined_priority = priority * inverted_wasted_space\n    \n    # Consider forecasting future items to anticipate constraints\n    if all_items is not None:\n        future_items = all_items[all_items > item]\n        forecast_factor = 1 / (1 + np.sum(future_items))\n        combined_priority *= forecast_factor\n    \n    # Normalize the priorities to ensure they add up to 1\n    normalized_priority = combined_priority / (np.sum(combined_priority) + 1e-6)\n    \n    return normalized_priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines multi-objective and weighted factors for better bin packing.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority_capacity = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority_capacity[bins_remain_cap < item] = 0\n    \n    # Calculate priority based on how full the bin is and how well the item fits\n    priority_fullness = np.where(bins_remain_cap >= item, \n                                 # for bins that can hold the item, the priority is inversely proportional to the remaining capacity\n                                 1.0 / (bins_remain_cap + 1), \n                                 # for bins that cannot hold the item, the priority is zero\n                                 0.0)\n    \n    # Introduce a 'balance' factor to prioritize bins with remaining capacity close to 50% of the bin size\n    balance_factor = 1 - np.abs((bins_remain_cap - item) / (bins_remain_cap + item))\n    \n    # Combine the priorities using adaptive weighting\n    priorities = 0.5 * priority_capacity + 0.3 * priority_fullness + 0.2 * balance_factor\n    \n    # Ensure priorities are not negative\n    priorities = np.where(priorities < 0, 0, priorities)\n    \n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines multi-objective approach with dynamic weighting.\n    \"\"\"\n    # Calculate waste (remaining capacity) if the item is added to each bin\n    waste = bins_remain_cap - item\n    \n    # Give higher priority to bins where item fits more tightly\n    delta = np.where(waste < 0, -np.inf, waste)\n    \n    # Prioritize bins with just enough capacity and higher available space\n    priority_tight_fit = np.where(delta > 0, bins_remain_cap / (delta + 1e-10), -np.inf)\n    \n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    priority_capacity_diff = 1 / (1 + capacity_diff)\n    \n    # Calculate bin utilization, considering both the current item and future potential\n    utilization_priority = bins_remain_cap / (bins_remain_cap + item)\n    \n    # Calculate the overall priority, balancing the current item's fit, bin utilization, and tight fit\n    # Use dynamic weighting based on the item size and remaining capacity\n    weight_tight_fit = np.where(item > np.mean(bins_remain_cap), 0.6, 0.4)\n    weight_capacity_diff = np.where(item < np.mean(bins_remain_cap), 0.3, 0.2)\n    weight_utilization = 1 - weight_tight_fit - weight_capacity_diff\n    \n    priority = weight_tight_fit * priority_tight_fit + weight_capacity_diff * priority_capacity_diff + weight_utilization * utilization_priority\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero) and avoid bins that are too full or too empty\n    priority = np.where(bins_remain_cap < item, -np.inf, priority)\n    priority = np.where(bins_remain_cap == 0, priority * 0.9, priority)  # reduce priority for empty bins\n    \n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines multi-objective approach with dynamic weighting.\n    \"\"\"\n    # Calculate the waste (remaining capacity) if the item is added to each bin\n    waste = bins_remain_cap - item\n    \n    # Give higher priority to bins where item fits more tightly\n    delta = np.where(waste < 0, -np.inf, waste)\n    \n    # Prioritize bins with just enough capacity and higher available space\n    priority = np.where(delta > 0, bins_remain_cap / (delta + 1e-10), -np.inf)\n    \n    # Calculate the ratio of the item size to the remaining capacity of each bin\n    ratio = item / np.maximum(bins_remain_cap, 1e-8)  # avoid division by zero\n    \n    # Assign higher priority to bins with lower ratio (i.e., less likely to leave a small gap)\n    # and with more remaining capacity (i.e., more space to accommodate future items)\n    priority_ratio = np.where(bins_remain_cap >= item, \n                              # for bins that can hold the item, the priority is inversely proportional to the remaining capacity\n                              bins_remain_cap * (1 - ratio) / (bins_remain_cap + 1), \n                              # for bins that cannot hold the item, the priority is zero\n                              0.0)\n    \n    # Combine priorities using dynamic weighting\n    alpha = 0.7  # weight for priority based on waste\n    beta = 0.3  # weight for priority based on ratio\n    combined_priority = alpha * priority + beta * priority_ratio\n    \n    # Avoid bins that are too full or too empty\n    combined_priority = np.where(bins_remain_cap < item, -np.inf, combined_priority)\n    combined_priority = np.where(bins_remain_cap == 0, combined_priority * 0.9, combined_priority)  # reduce priority for empty bins\n    \n    return combined_priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines multi-objective approach with dynamic weighting.\n    \"\"\"\n    # Calculate waste (remaining capacity) if the item is added to each bin\n    waste = bins_remain_cap - item\n    \n    # Give higher priority to bins where item fits more tightly\n    delta = np.where(waste < 0, -np.inf, waste)\n    \n    # Prioritize bins with just enough capacity and higher available space\n    priority_tight_fit = np.where(delta > 0, bins_remain_cap / (delta + 1e-10), -np.inf)\n    \n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    priority_capacity_diff = 1 / (1 + capacity_diff)\n    \n    # Calculate bin utilization, considering both the current item and future potential\n    utilization_priority = bins_remain_cap / (bins_remain_cap + item)\n    \n    # Calculate the overall priority, balancing the current item's fit, bin utilization, and tight fit\n    # Use dynamic weighting based on the item size and remaining capacity\n    weight_tight_fit = np.where(item > np.mean(bins_remain_cap), 0.6, 0.4)\n    weight_capacity_diff = np.where(item < np.mean(bins_remain_cap), 0.3, 0.2)\n    weight_utilization = 1 - weight_tight_fit - weight_capacity_diff\n    \n    priority = weight_tight_fit * priority_tight_fit + weight_capacity_diff * priority_capacity_diff + weight_utilization * utilization_priority\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero) and avoid bins that are too full or too empty\n    priority = np.where(bins_remain_cap < item, -np.inf, priority)\n    priority = np.where(bins_remain_cap == 0, priority * 0.9, priority)  # reduce priority for empty bins\n    \n    return priority\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    A mutated priority function for online Bin Packing Problem, \n    incorporating adaptive weighting and multi-objective optimization.\n    \"\"\"\n    \n    # Calculate the tightness of fit for the current item in each bin\n    fit_priority = np.exp(-np.abs(bins_remain_cap - item))\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    fit_priority = np.where(bins_remain_cap >= item, fit_priority, 0)\n    \n    # Calculate the utilization ratio for each bin, considering the current item\n    utilization_priority = (bins_remain_cap + item) / (bins_remain_cap + np.mean(bins_remain_cap))\n    \n    # Calculate a penalty factor for each bin based on the excess capacity\n    excess_penalty = np.exp(-np.maximum(0, bins_remain_cap - item))\n    \n    # Calculate the overall priority, balancing the current item's fit, bin utilization, and excess penalty\n    alpha = 0.4  # Dynamic weighting for fit priority\n    beta = 0.3   # Dynamic weighting for utilization priority\n    gamma = 0.3  # Dynamic weighting for excess penalty\n    \n    priority = alpha * fit_priority + beta * utilization_priority + gamma * excess_penalty\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    priority = np.nan_to_num(priority)\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, priority, -1)\n    \n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines multi-objective approach with dynamic weighting.\n    \"\"\"\n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n\n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n\n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority_score = 1 / (1 + capacity_diff)\n\n    # Calculate the available space in each bin relative to the item size\n    relative_available_space = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n\n    # Combine the priorities using dynamic weighting\n    # Weight1: gives more importance to bins with enough capacity and a good fit\n    weight1 = np.where(bins_remain_cap >= item, bins_remain_cap * penalty_factor, 0)\n    # Weight2: favors bins that have enough capacity to fit the item and have the most available space\n    weight2 = priority_score * relative_available_space / (item + 1e-6)\n\n    # Combine the weighted priorities\n    combined_priority = weight1 + weight2\n\n    # If the item size exceeds the remaining capacity, set the priority to 0\n    combined_priority[bins_remain_cap < item] = 0\n\n    # Ensure bins with higher remaining capacity get higher priority when the item fits\n    combined_priority = np.where(bins_remain_cap >= item, combined_priority + bins_remain_cap, combined_priority)\n\n    return combined_priority\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines multi-objective approach with dynamic weighting.\n    \"\"\"\n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n\n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n\n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority_score = 1 / (1 + capacity_diff)\n\n    # Calculate the available space in each bin relative to the item size\n    relative_available_space = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n\n    # Combine the priorities using dynamic weighting\n    # Weight1: gives more importance to bins with enough capacity and a good fit\n    weight1 = np.where(bins_remain_cap >= item, bins_remain_cap * penalty_factor, 0)\n    # Weight2: favors bins that have enough capacity to fit the item and have the most available space\n    weight2 = priority_score * relative_available_space / (item + 1e-6)\n\n    # Combine the weighted priorities\n    combined_priority = weight1 + weight2\n\n    # If the item size exceeds the remaining capacity, set the priority to 0\n    combined_priority[bins_remain_cap < item] = 0\n\n    # Ensure bins with higher remaining capacity get higher priority when the item fits\n    combined_priority = np.where(bins_remain_cap >= item, combined_priority + bins_remain_cap, combined_priority)\n\n    return combined_priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, all_items: np.ndarray = None) -> np.ndarray:\n    \"\"\"\n    Combines multi-objective and dynamic weighting for better outcomes.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    # Introduce a 'balance' factor to prioritize bins with remaining capacity close to 50% of the bin size\n    balance_factor = 1 - np.abs((bins_remain_cap - item) / (bins_remain_cap + item))\n    priority *= balance_factor\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    priority *= penalty_factor\n    \n    # Consider forecasting future items to anticipate constraints\n    if all_items is not None:\n        future_items = all_items[all_items > item]\n        forecast_factor = 1 / (1 + np.sum(future_items))\n        priority *= forecast_factor\n    \n    # Ensure bins with higher remaining capacity get higher priority when the item fits\n    priority = np.where(bins_remain_cap >= item, priority + 0.1 * bins_remain_cap, priority)\n    \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    A mutated priority function for online Bin Packing Problem, \n    incorporating dynamic weighting, trade-offs, and flexibility.\n    \"\"\"\n    # Calculate the weighted difference between the remaining capacity of each bin and the item size\n    weight = 0.5  # adaptive weighting factor\n    capacity_diff = np.abs(bins_remain_cap - item)\n    weighted_diff = weight * capacity_diff + (1 - weight) * bins_remain_cap\n    \n    # Calculate a priority score based on the weighted difference\n    priority_score = 1 / (1 + weighted_diff)\n    \n    # Incorporate a penalty factor for bins with insufficient capacity\n    penalty_factor = 1 / (1 + np.exp(np.maximum(0, item - bins_remain_cap)))\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    avg_historic_size = np.mean(bins_remain_cap)  # Using mean remaining capacity as a proxy for historic item sizes\n    utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)\n    \n    # Calculate the average bin capacity and item size to inform the weighting\n    avg_bin_cap = np.mean(bins_remain_cap)\n    avg_item_size = item  # or use a running average of item sizes\n    \n    # Adaptive weighting based on the problem landscape\n    alpha = 0.4  # initial weighting for fit priority\n    beta = 0.3  # initial weighting for utilization priority\n    gamma = 0.3  # initial weighting for penalty factor\n    \n    if avg_bin_cap > avg_item_size:\n        alpha += 0.1\n        beta -= 0.1\n    else:\n        alpha -= 0.1\n        beta += 0.1\n    \n    # Calculate the overall priority, balancing the current item's fit, bin utilization, and penalty factor\n    priority = alpha * priority_score + beta * utilization_priority + gamma * penalty_factor * bins_remain_cap\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    priority = np.nan_to_num(priority)\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, priority, -1)\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, historic_item_sizes: np.ndarray = None, alpha: float = 0.5, beta: float = 0.3) -> np.ndarray:\n    \"\"\"\n    Combines multi-objective approach with adaptive weighting.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority_capacity = 1 / (1 + capacity_diff)\n    \n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # If historic item sizes are available, forecast future item sizes\n    if historic_item_sizes is not None:\n        # Calculate the average size of historic items\n        avg_historic_size = np.mean(historic_item_sizes)\n        \n        # Calculate the difference between the remaining capacity of each bin and the forecasted item size\n        forecast_diff = np.abs(bins_remain_cap - avg_historic_size)\n        \n        # Invert the differences to obtain a priority score (lower difference -> higher priority)\n        priority_forecast = 1 / (1 + forecast_diff)\n        \n        # Combine the priority scores using weighting factors\n        priority = alpha * priority_capacity * penalty_factor + beta * priority_forecast * penalty_factor\n    else:\n        # If no historic item sizes are available, use only the capacity difference objective\n        priority = priority_capacity * penalty_factor\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    # Ensure bins with higher remaining capacity get higher priority when the item fits\n    priority = np.where(bins_remain_cap >= item, priority + bins_remain_cap, priority)\n    \n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, all_items: np.ndarray = None) -> np.ndarray:\n    \"\"\"\n    Combines multi-objective and dynamic weighting for better outcomes.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    # Introduce a 'balance' factor to prioritize bins with remaining capacity close to 50% of the bin size\n    balance_factor = 1 - np.abs((bins_remain_cap - item) / (bins_remain_cap + item))\n    priority *= balance_factor\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    priority *= penalty_factor\n    \n    # Consider forecasting future items to anticipate constraints\n    if all_items is not None:\n        future_items = all_items[all_items > item]\n        forecast_factor = 1 / (1 + np.sum(future_items))\n        priority *= forecast_factor\n    \n    # Ensure bins with higher remaining capacity get higher priority when the item fits\n    priority = np.where(bins_remain_cap >= item, priority + 0.1 * bins_remain_cap, priority)\n    \n    return priority\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, all_items: np.ndarray = None) -> np.ndarray:\n    \"\"\"\n    Combines multi-objective and dynamic weighting for better outcomes.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    # Introduce a 'balance' factor to prioritize bins with remaining capacity close to 50% of the bin size\n    balance_factor = 1 - np.abs((bins_remain_cap - item) / (bins_remain_cap + item))\n    priority *= balance_factor\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    priority *= penalty_factor\n    \n    # Consider forecasting future items to anticipate constraints\n    if all_items is not None:\n        future_items = all_items[all_items > item]\n        forecast_factor = 1 / (1 + np.sum(future_items))\n        priority *= forecast_factor\n    \n    # Ensure bins with higher remaining capacity get higher priority when the item fits\n    priority = np.where(bins_remain_cap >= item, priority + 0.1 * bins_remain_cap, priority)\n    \n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}