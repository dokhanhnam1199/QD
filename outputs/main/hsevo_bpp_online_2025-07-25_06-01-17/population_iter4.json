[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines bin fullness and item fit for priority scoring.\n    \"\"\"\n    # Calculate the ratio of the item to each bin's remaining capacity\n    ratio = np.where(bins_remain_cap == 0, 0, item / bins_remain_cap)\n    \n    # Calculate the remaining space in each bin after adding the item\n    remaining_space = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n    \n    # Calculate a \"fill\" score for each bin: how much of the bin would be full after adding the item\n    fill_score = np.where(remaining_space == 0, 1, 1 - remaining_space / bins_remain_cap)\n    \n    # Calculate the priority score for each bin, favoring bins with just enough capacity\n    priority_score = np.where(ratio == 0, 0, ratio * fill_score)\n    \n    # Apply a penalty to bins that are already close to full\n    penalty = (1 - (bins_remain_cap / item)) * (bins_remain_cap < item)\n    \n    # Adjust the priority score with the penalty\n    priority = priority_score * (1 - penalty)\n    \n    # Add a small positive value to avoid division by zero\n    priority += np.finfo(np.float64).eps\n    \n    # Normalize the priority scores to favor bins with the most remaining capacity\n    priority = priority / np.sum(priority)\n    \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of v0 and v1 heuristics for better results.\n    \"\"\"\n    # Calculate priority based on how full the bin is and how well the item fits\n    priority_fullness = np.where(bins_remain_cap >= item, \n                                 # for bins that can hold the item, the priority is inversely proportional to the remaining capacity\n                                 1.0 / (bins_remain_cap + 1), \n                                 # for bins that cannot hold the item, the priority is zero\n                                 0.0)\n    \n    # Calculate priority based on available space relative to the item size\n    priority_space = np.where(bins_remain_cap >= item, bins_remain_cap, -1)\n    \n    # Combine the two priorities, giving more weight to the fullness priority\n    priorities = 0.7 * priority_fullness + 0.3 * priority_space\n    \n    # Ensure priorities are not negative\n    priorities = np.where(priorities < 0, 0, priorities)\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combine bin fullness and item fit for priority.\n    \"\"\"\n    # Calculate the ratio of the item size to the remaining capacity of each bin\n    ratio = item / np.maximum(bins_remain_cap, 1e-8)  # avoid division by zero\n    \n    # Assign higher priority to bins with lower ratio (i.e., less likely to leave a small gap)\n    # and with more remaining capacity (i.e., more space to accommodate future items)\n    priority = np.where(bins_remain_cap >= item, \n                       # for bins that can hold the item, the priority is inversely proportional to the remaining capacity\n                       bins_remain_cap * (1 - ratio) / (bins_remain_cap + 1), \n                       # for bins that cannot hold the item, the priority is zero\n                       0.0)\n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of previous heuristics for better performance.\n    \"\"\"\n    # Calculate the waste (remaining capacity) if the item is added to each bin\n    waste = bins_remain_cap - item\n    \n    # Give higher priority to bins where item fits more tightly\n    delta = np.where(waste < 0, -np.inf, waste)\n    \n    # Prioritize bins with just enough capacity and higher available space\n    priority = np.where(delta > 0, bins_remain_cap / (delta + 1e-10), -np.inf)\n    \n    # Avoid bins that are too full or too empty\n    priority = np.where(bins_remain_cap < item, -np.inf, priority)\n    priority = np.where(bins_remain_cap == 0, priority * 0.9, priority)  # reduce priority for empty bins\n    \n    # Balance priorities based on bin fullness and item fit\n    priority = np.where(bins_remain_cap > item, priority * (1 + (bins_remain_cap - item) / (bins_remain_cap + 1e-10)), priority)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 5.195452732349436,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of v0 and v1 heuristics for better outcomes.\n    \"\"\"\n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap * penalty_factor, -1)\n    \n    # Ensure bins with higher remaining capacity get higher priority when the item fits\n    priority = np.where(bins_remain_cap >= item, priority + bins_remain_cap, priority)\n    \n    return priority",
    "response_id": 4,
    "tryHS": true,
    "obj": 148.53410450737937,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Balances item fit and remaining capacity.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority_fit = 1 / (1 + capacity_diff)\n    \n    # Calculate the remaining capacity relative to the item size\n    relative_cap = bins_remain_cap / item\n    \n    # Favor bins with enough capacity to fit the item\n    capacity_mask = bins_remain_cap >= item\n    \n    # Use a weighted sum to balance the two objectives\n    priority_capacity = np.where(capacity_mask, relative_cap, 0)\n    \n    # Combine the two priorities, favoring a good fit and sufficient capacity\n    priority = priority_fit * priority_capacity\n    \n    # Ensure bins with negative remaining capacity or insufficient capacity have zero priority\n    priority[bins_remain_cap < item] = 0\n    \n    # Ensure all priorities are non-negative\n    priority = np.maximum(priority, 0)\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines bin fullness and item fit for priority.\n    \"\"\"\n    # Calculate the \"closeness\" of each bin to being full after adding the item\n    remaining_capacity_after_item = bins_remain_cap - item\n    \n    # Ignore bins that cannot accommodate the item\n    eligible_bins = remaining_capacity_after_item >= 0\n    \n    # For eligible bins, calculate priority based on bin fullness and item fit\n    priority_scores = np.zeros_like(bins_remain_cap)\n    priority_scores[eligible_bins] = 1 / (1 + remaining_capacity_after_item[eligible_bins])\n    \n    # Favor bins with higher remaining capacity\n    priority_scores[eligible_bins] += bins_remain_cap[eligible_bins] / (1 + np.abs(remaining_capacity_after_item[eligible_bins]))\n    \n    # Set priority to -inf for bins that cannot accommodate the item\n    priority_scores[~eligible_bins] = -np.inf\n    \n    return priority_scores",
    "response_id": 6,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 18, in priority_v2\n    bins_remain_cap - item + 1, \nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n7\n1\n120.92782504182705\n83.62596713757605\n108\n"
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines factors for a balanced heuristic.\n    \"\"\"\n    # Calculate the wasted space for each bin if the item is added\n    wasted_space = np.maximum(bins_remain_cap - item, 0)\n    \n    # Invert the wasted space so that bins with least wasted space get higher priority\n    inverted_wasted_space = 1 / (wasted_space + 1e-6)  # Add small value for numerical stability\n    \n    # Calculate the priority score for each bin based on the remaining capacity and item fit\n    priority_score = inverted_wasted_space * (bins_remain_cap / (bins_remain_cap + item + 1e-6))  # Add small value for numerical stability\n    \n    # Consider bins that have enough capacity to hold the item and favor tight fits\n    capacity_priority = np.where(bins_remain_cap >= item, \n                                 bins_remain_cap - item + 1, \n                                 0)\n    \n    # Combine the two priorities\n    combined_priority = priority_score * capacity_priority\n    \n    # Normalize the priorities to ensure they add up to 1\n    normalized_priority = combined_priority / (np.sum(combined_priority) + 1e-6)\n    \n    return normalized_priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 82.46908655763862,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins with enough capacity, favoring tight fits and low waste.\n    \"\"\"\n    # Create a mask to identify bins that can hold the item\n    can_hold_item = bins_remain_cap >= item\n    \n    # Calculate the waste that would be caused by adding the item to each bin\n    waste = bins_remain_cap - item\n    \n    # Calculate the \"closeness\" of each bin to being full after adding the item\n    remaining_capacity_after_item = bins_remain_cap - item\n    \n    # Calculate the priority score for each bin, considering both waste and closeness to full\n    priority = np.where(can_hold_item, 1 / (waste + 1) * (1 / (1 + remaining_capacity_after_item)), 0)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combine balance and forecasting to prioritize bins.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    # to encourage packing items into bins where the item size is close to the remaining capacity\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # Calculate the available space in each bin relative to the item size\n    # to favor bins that have enough capacity to fit the item and have the most available space\n    relative_available_space = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Combine the two priorities to balance competing factors\n    combined_priority = priority * relative_available_space / (item + 1e-6)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    combined_priority[bins_remain_cap < item] = 0\n    \n    return combined_priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 120.92782504182705,
    "mi": 83.62596713757605,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, historic_item_sizes: np.ndarray = None, alpha: float = 0.5, beta: float = 0.3) -> np.ndarray:\n    \"\"\"\n    Returns a priority score for each bin, taking into account the item size, remaining capacity, \n    and potential future items. This heuristic aims to balance efficient placements, minimize waste, \n    and anticipate future constraints.\n\n    Args:\n        item: Size of the item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        historic_item_sizes: Array of previously seen item sizes (default is None).\n        alpha: Weight for the capacity difference objective (default is 0.5).\n        beta: Weight for the future item forecasting objective (default is 0.3).\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority_capacity = 1 / (1 + capacity_diff)\n    \n    # If historic item sizes are available, forecast future item sizes\n    if historic_item_sizes is not None:\n        # Calculate the average size of historic items\n        avg_historic_size = np.mean(historic_item_sizes)\n        \n        # Calculate the difference between the remaining capacity of each bin and the forecasted item size\n        forecast_diff = np.abs(bins_remain_cap - avg_historic_size)\n        \n        # Invert the differences to obtain a priority score (lower difference -> higher priority)\n        priority_forecast = 1 / (1 + forecast_diff)\n        \n        # Combine the priority scores using weighting factors\n        priority = alpha * priority_capacity + beta * priority_forecast\n    else:\n        # If no historic item sizes are available, use only the capacity difference objective\n        priority = priority_capacity\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 249.1233050614779,
    "mi": 80.09417103676934,
    "token_count": 185.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, historic_item_sizes: np.ndarray = None, alpha: float = 0.5, beta: float = 0.3) -> np.ndarray:\n    \"\"\"\n    Returns a priority score for each bin, balancing the current item's fit with future potential and bin utilization.\n\n    Args:\n        item: Size of the item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        historic_item_sizes: Optional array of previously packed item sizes for forecasting.\n        alpha: Weight for the current item's fit (default: 0.5).\n        beta: Weight for bin utilization and future potential (default: 0.3).\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    fit_priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    fit_priority[bins_remain_cap < item] = 0\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    if historic_item_sizes is not None:\n        avg_historic_size = np.mean(historic_item_sizes)\n        utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)\n    else:\n        utilization_priority = bins_remain_cap / (bins_remain_cap + item)\n    \n    # Calculate the overall priority, balancing the current item's fit and bin utilization\n    priority = alpha * fit_priority + beta * utilization_priority\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    priority = np.nan_to_num(priority)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 69.36577582768251,
    "SLOC": 16.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 249.1233050614779,
    "mi": 80.09417103676934,
    "token_count": 185.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, all_items: np.ndarray = None, alpha: float = 0.5, beta: float = 0.3, gamma: float = 0.2) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to balance competing factors, prioritize efficient placements, and anticipate future items.\n    It considers the difference between the remaining capacity and the item size, the current utilization of each bin, and the expected future utilization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        all_items: Array of all item sizes (optional).\n        alpha: Weight for the capacity difference factor.\n        beta: Weight for the current utilization factor.\n        gamma: Weight for the future utilization factor.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the capacity difference factor\n    priority_capacity = 1 / (1 + capacity_diff)\n    \n    # Calculate the current utilization of each bin\n    current_utilization = 1 - (bins_remain_cap / np.sum(bins_remain_cap))\n    \n    # Calculate the priority score for the current utilization factor\n    priority_utilization = 1 / (1 + current_utilization)\n    \n    # If all item sizes are provided, calculate the expected future utilization\n    if all_items is not None:\n        # Calculate the average item size\n        avg_item_size = np.mean(all_items)\n        \n        # Calculate the expected future utilization of each bin\n        future_utilization = bins_remain_cap / (np.sum(bins_remain_cap) + avg_item_size)\n        \n        # Calculate the priority score for the future utilization factor\n        priority_future = 1 / (1 + future_utilization)\n    else:\n        priority_future = np.ones_like(bins_remain_cap)\n    \n    # Calculate the overall priority score by combining the three factors\n    priority = alpha * priority_capacity + beta * priority_utilization + gamma * priority_future\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 249.1233050614779,
    "mi": 80.09417103676934,
    "token_count": 185.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, all_items: np.ndarray = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to improve upon the previous version by \n    considering multiple objectives, prioritizing efficient placements, and \n    anticipating future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        all_items: Optional array of all items (including future ones) for forecasting.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    # Introduce a 'balance' factor to prioritize bins with remaining capacity close to 50% of the bin size\n    balance_factor = 1 - np.abs((bins_remain_cap - item) / (bins_remain_cap + item))\n    priority *= balance_factor\n    \n    # If all items are provided, consider forecasting future items to anticipate constraints\n    if all_items is not None:\n        future_items = all_items[all_items > item]\n        forecast_factor = 1 / (1 + np.sum(future_items))\n        priority *= forecast_factor\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 249.1233050614779,
    "mi": 80.09417103676934,
    "token_count": 185.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, max_bin_capacity: float, \n                item_arrival_history: list = None, num_future_items: int = 10) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to balance competing factors, prioritize tight fits, \n    and consider future placements to minimize waste and optimize outcomes.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        max_bin_capacity: Maximum capacity of each bin.\n        item_arrival_history: List of item sizes in the order they arrived (optional).\n        num_future_items: Number of future items to consider (optional).\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score (lower difference -> higher priority)\n    priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    priority[bins_remain_cap < item] = 0\n    \n    # Consider the balance between bins by penalizing bins with low remaining capacity\n    balance_factor = 1 - (bins_remain_cap / max_bin_capacity)\n    priority *= (1 - balance_factor)\n    \n    # Consider future item arrivals by forecasting the next items\n    if item_arrival_history:\n        forecast_factor = np.zeros_like(priority)\n        for i in range(num_future_items):\n            next_item_size = item_arrival_history[-i - 1] if i < len(item_arrival_history) else item\n            forecastCapacityDiff = np.abs(bins_remain_cap - next_item_size)\n            forecast_factor += 1 / (1 + forecastCapacityDiff)\n        forecast_factor /= num_future_items\n        priority *= (1 + forecast_factor)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'max_bin_capacity'\n16\n4\n249.1233050614779\n80.09417103676934\n185\n"
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, penalty_factor_weight: float = 8.58149997527536, high_priority_threshold: float = 0.746603897593442, capacity_weight: float = 2.2257343880522464) -> np.ndarray:\n    \"\"\"\n    Combines elements of v0 and v1 heuristics for better outcomes.\n    \"\"\"\n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = penalty_factor_weight / (1 + np.exp(shortfall)) * penalty_factor_weight / (1 + np.exp(excess))\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap * penalty_factor, -1)\n    \n    # Ensure bins with higher remaining capacity get higher priority when the item fits\n    priority = np.where(bins_remain_cap >= item, priority + capacity_weight * bins_remain_cap, priority)\n    \n    return priority",
    "response_id": 1,
    "tryHS": true,
    "obj": 83.65576386118867,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 164.2332676057198,
    "mi": 90.29514824804018,
    "token_count": 148.0,
    "exec_success": true
  }
]