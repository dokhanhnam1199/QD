{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Adaptive priority function for the online Bin Packing Problem (BPP).\n    \n    This function combines dynamic weighting, forecasting, and bin utilization \n    metrics to create an effective heuristic. It adapts to problem state changes \n    and balances multiple objectives to minimize the number of bins used.\n    \"\"\"\n    \n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    fit_priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    fit_priority[bins_remain_cap < item] = 0\n    \n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    avg_historic_size = np.mean(bins_remain_cap)  # Using mean remaining capacity as a proxy for historic item sizes\n    utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)\n    \n    # Calculate the overall priority, balancing the current item's fit and bin utilization\n    # with dynamic weighting based on the problem state\n    alpha = 0.4  # Weight for the current item's fit\n    beta = 0.3  # Weight for bin utilization\n    gamma = 0.3  # Weight for the penalty factor and remaining capacity\n    \n    priority = alpha * fit_priority + beta * utilization_priority + gamma * penalty_factor * bins_remain_cap\n    \n    # Adapt the priority based on the problem state (i.e., the number of bins and their utilization)\n    num_bins = len(bins_remain_cap)\n    avg_utilization = np.mean(bins_remain_cap) / (num_bins * np.mean(bins_remain_cap))\n    \n    if avg_utilization < 0.5:  # Low utilization, prioritize efficient packing\n        priority *= 1.1\n    elif avg_utilization > 0.8:  # High utilization, prioritize bin utilization\n        priority *= 0.9\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    priority = np.nan_to_num(priority)\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, priority, -1)\n    \n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Improved heuristic combining adaptive weighting and multi-objective optimization.\n    \"\"\"\n    \n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate an adaptive weight based on the item size and bin capacities\n    adaptive_weight = 1 / (1 + np.exp(-item / np.mean(bins_remain_cap)))\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    fit_priority = adaptive_weight / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    fit_priority[bins_remain_cap < item] = 0\n    \n    # Calculate the waste (remaining capacity) if the item is added to each bin\n    waste = bins_remain_cap - item\n    \n    # Give higher priority to bins where item fits more tightly\n    delta = np.where(waste < 0, -np.inf, waste)\n    \n    # Prioritize bins with just enough capacity and higher available space\n    priority_tight_fit = np.where(delta > 0, bins_remain_cap / (delta + 1e-10), -np.inf)\n    \n    # Calculate the ratio of the item size to the remaining capacity of each bin\n    ratio = item / np.maximum(bins_remain_cap, 1e-8)  # avoid division by zero\n    \n    # Assign higher priority to bins with lower ratio (i.e., less likely to leave a small gap)\n    # and with more remaining capacity (i.e., more space to accommodate future items)\n    priority_ratio = np.where(bins_remain_cap >= item, \n                              # for bins that can hold the item, the priority is inversely proportional to the remaining capacity\n                              bins_remain_cap * (1 - ratio) / (bins_remain_cap + 1), \n                              # for bins that cannot hold the item, the priority is zero\n                              0.0)\n    \n    # Calculate a balance factor to prioritize bins with remaining capacity close to 50% of the bin size\n    avg_bin_size = np.mean(bins_remain_cap)\n    balance_factor = 1 - np.abs((bins_remain_cap - avg_bin_size / 2) / avg_bin_size)\n    \n    # Calculate the overall priority, balancing the current item's fit, bin utilization, and balance factor\n    alpha = 0.5  # weight for priority based on fit\n    beta = 0.3  # weight for priority based on tight fit\n    gamma = 0.2  # weight for priority based on ratio and balance factor\n    combined_priority = alpha * fit_priority + beta * priority_tight_fit + gamma * (priority_ratio * balance_factor)\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    combined_priority = np.nan_to_num(combined_priority)\n    \n    return combined_priority\n\n### Analyze & experience\n- Comparing the 1st vs the 20th heuristics, we see a significant difference in the approach to calculating priorities, with the 1st heuristic using a more complex formula involving dynamic weighting and forecasting, while the 20th heuristic uses a simpler approach based on capacity differences and bin fullness. \nComparing the 2nd vs the 19th heuristics, we see that both use similar techniques, but the 2nd heuristic incorporates additional factors such as shortfall and excess capacity, which may lead to more efficient bin packing. \nComparing the 3rd vs the 18th heuristics, we see that the 3rd heuristic uses a more adaptive approach to weighting, taking into account the problem's current state, whereas the 18th heuristic uses a fixed weighting scheme. \nComparing the 4th vs the 17th heuristics, we see that the 4th heuristic incorporates a forecasted utilization priority, which may help to avoid overfilling bins, whereas the 17th heuristic does not consider this factor. \nComparing the 5th vs the 16th heuristics, we see that the 5th heuristic uses a more sophisticated approach to calculating the overall priority, involving alpha, beta, and gamma weights, whereas the 16th heuristic uses a simpler approach based on priority capacity and fullness. \nComparing the 6th vs the 15th heuristics, we see that the 6th heuristic uses a more dynamic approach to weighting, involving log and exponential functions, whereas the 15th heuristic uses a more static approach. \nComparing the 7th vs the 14th heuristics, we see that the 7th heuristic incorporates a balance factor to prioritize bins with remaining capacity close to 50% of the bin size, whereas the 14th heuristic does not consider this factor. \nComparing the 8th vs the 13th heuristics, we see that the 8th heuristic uses a more complex approach involving forecasting and adaptation to the problem state, whereas the 13th heuristic uses a simpler approach based on capacity differences and bin fullness. \nComparing the 9th vs the 12th heuristics, we see that the 9th heuristic incorporates a penalty factor for bins with low remaining capacity, whereas the 12th heuristic does not consider this factor. \nComparing the 10th vs the 11th heuristics, we see that the 10th heuristic uses a more static approach to weighting, whereas the 11th heuristic uses a more dynamic approach involving adaptation to the problem state. \nOverall: The better heuristics tend to use more complex and adaptive approaches to calculating priorities, incorporating factors such as dynamic weighting, forecasting, and adaptation to the problem state.\n- \nHere's a redefined 'Current self-reflection' to design better heuristics:\n* Keywords: Adaptive weighting, multiple objectives, dynamic weighting\n* Advice: Combine multiple objectives, use dynamic weighting, and incorporate forecasting\n* Avoid: Prioritizing tight fits, overemphasizing future item placements\n* Explanation: Effective heuristics balance multiple objectives, adapt to the problem's state, and use dynamic weighting to optimize solutions.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}