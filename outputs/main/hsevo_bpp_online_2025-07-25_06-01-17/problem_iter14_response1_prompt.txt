{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Adaptive, multi-objective priority function with dynamic weighting.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    fit_priority = 1 / (1 + np.log(1 + capacity_diff))  # Improved fit priority\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    fit_priority[bins_remain_cap < item] = 0\n    \n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Adaptive weighting based on the problem landscape\n    avg_bin_cap = np.mean(bins_remain_cap)\n    alpha = 0.4 + 0.2 * (item / (item + avg_bin_cap))  # Dynamic weighting for fit priority\n    beta = 0.3 + 0.1 * (bins_remain_cap.mean() / (bins_remain_cap.mean() + item))  # Dynamic weighting for utilization priority\n    gamma = 0.3  # Weighting for penalty factor\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    utilization_priority = (bins_remain_cap + avg_bin_cap) / (bins_remain_cap + item + avg_bin_cap)\n    \n    # Calculate the overall priority, balancing the current item's fit, bin utilization, and penalty factor\n    priority = alpha * fit_priority + beta * utilization_priority + gamma * penalty_factor * bins_remain_cap\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    priority = np.nan_to_num(priority)\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, priority, -1)\n    \n    # Dynamic prioritization based on the current state of the bins\n    max_bin_priority = np.max(priority)\n    priority[priority < max_bin_priority] *= (1 - (max_bin_priority - priority[priority < max_bin_priority]) / max_bin_priority)\n    \n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    A new priority function that incorporates dynamic weighting, forecasting, and adaptation to the problem state.\n    \"\"\"\n    \n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to obtain a priority score for the current item's fit\n    fit_priority = 1 / (1 + capacity_diff)\n    \n    # If the item size exceeds the remaining capacity, set the priority to 0\n    fit_priority[bins_remain_cap < item] = 0\n    \n    # Calculate the shortfall or excess capacity for each bin\n    shortfall = np.maximum(0, item - bins_remain_cap)\n    excess = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate a penalty factor for each bin based on the shortfall or excess capacity\n    penalty_factor = 1 / (1 + np.exp(shortfall)) * 1 / (1 + np.exp(excess))\n    \n    # Calculate the bin utilization, considering both the current item and future potential\n    avg_historic_size = np.mean(bins_remain_cap)  # Using mean remaining capacity as a proxy for historic item sizes\n    utilization_priority = (bins_remain_cap + avg_historic_size) / (bins_remain_cap + item + avg_historic_size)\n    \n    # Calculate a forecasted utilization priority based on the average remaining capacity and item size\n    forecasted_utilization_priority = (np.mean(bins_remain_cap) + item) / (np.mean(bins_remain_cap) + item + avg_historic_size)\n    \n    # Adjust the weighting factors based on the problem state (average remaining capacity and item size)\n    adjusted_alpha = alpha * (1 - np.mean(bins_remain_cap) / (item + np.mean(bins_remain_cap)))\n    adjusted_beta = beta * (1 - np.mean(bins_remain_cap) / (item + np.mean(bins_remain_cap)))\n    adjusted_gamma = gamma * (1 - np.mean(bins_remain_cap) / (item + np.mean(bins_remain_cap)))\n    \n    # Calculate the overall priority, balancing the current item's fit, bin utilization, and forecasted utilization\n    priority = adjusted_alpha * fit_priority + adjusted_beta * utilization_priority + adjusted_gamma * forecasted_utilization_priority\n    \n    # Incorporate a penalty for bins with low remaining capacity\n    penalty_for_low_capacity = 1 / (1 + np.exp(-bins_remain_cap))\n    priority *= penalty_for_low_capacity\n    \n    # Ensure the priority scores are not NaN (e.g., due to division by zero)\n    priority = np.nan_to_num(priority)\n    \n    # Assign high priority to bins with enough capacity and a good fit\n    priority = np.where(bins_remain_cap >= item, priority, -1)\n    \n    return priority\n\n### Analyze & experience\n- Comparing the 1st vs the 20th heuristics, we see a significant difference in the approach to calculating priorities, with the 1st heuristic using a more complex formula involving dynamic weighting and forecasting, while the 20th heuristic uses a simpler approach based on capacity differences and bin fullness. \nComparing the 2nd vs the 19th heuristics, we see that both use similar techniques, but the 2nd heuristic incorporates additional factors such as shortfall and excess capacity, which may lead to more efficient bin packing. \nComparing the 3rd vs the 18th heuristics, we see that the 3rd heuristic uses a more adaptive approach to weighting, taking into account the problem's current state, whereas the 18th heuristic uses a fixed weighting scheme. \nComparing the 4th vs the 17th heuristics, we see that the 4th heuristic incorporates a forecasted utilization priority, which may help to avoid overfilling bins, whereas the 17th heuristic does not consider this factor. \nComparing the 5th vs the 16th heuristics, we see that the 5th heuristic uses a more sophisticated approach to calculating the overall priority, involving alpha, beta, and gamma weights, whereas the 16th heuristic uses a simpler approach based on priority capacity and fullness. \nComparing the 6th vs the 15th heuristics, we see that the 6th heuristic uses a more dynamic approach to weighting, involving log and exponential functions, whereas the 15th heuristic uses a more static approach. \nComparing the 7th vs the 14th heuristics, we see that the 7th heuristic incorporates a balance factor to prioritize bins with remaining capacity close to 50% of the bin size, whereas the 14th heuristic does not consider this factor. \nComparing the 8th vs the 13th heuristics, we see that the 8th heuristic uses a more complex approach involving forecasting and adaptation to the problem state, whereas the 13th heuristic uses a simpler approach based on capacity differences and bin fullness. \nComparing the 9th vs the 12th heuristics, we see that the 9th heuristic incorporates a penalty factor for bins with low remaining capacity, whereas the 12th heuristic does not consider this factor. \nComparing the 10th vs the 11th heuristics, we see that the 10th heuristic uses a more static approach to weighting, whereas the 11th heuristic uses a more dynamic approach involving adaptation to the problem state. \nOverall: The better heuristics tend to use more complex and adaptive approaches to calculating priorities, incorporating factors such as dynamic weighting, forecasting, and adaptation to the problem state.\n- \nHere's a redefined 'Current self-reflection' to design better heuristics:\n* Keywords: Adaptive weighting, multiple objectives, dynamic weighting\n* Advice: Combine multiple objectives, use dynamic weighting, and incorporate forecasting\n* Avoid: Prioritizing tight fits, overemphasizing future item placements\n* Explanation: Effective heuristics balance multiple objectives, adapt to the problem's state, and use dynamic weighting to optimize solutions.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}