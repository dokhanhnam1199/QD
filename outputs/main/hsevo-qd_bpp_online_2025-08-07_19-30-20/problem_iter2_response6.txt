```python
import numpy as np

# Probabilistic best‑fit priority merging inverse leftover bias with stochastic exploration via softmax.
def priority_v2(item: float, bins_remain_cap: np.ndarray,
                temperature: float = 1.0, random_weight: float = 1.0) -> np.ndarray:
    """
    Combine inverse remaining capacity bias and uniform random noise,
    then apply a temperature‑scaled softmax to get probabilistic priorities.
    """
    mask = bins_remain_cap >= item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    if not np.any(mask):
        return priorities
    remaining = bins_remain_cap[mask] - item
    eps = 1e-12
    bias = -np.log(remaining + eps)                     # tighter fit → larger bias
    noise = random_weight * np.random.rand(len(remaining))
    raw = bias + noise                                 # deterministic + stochastic component
    raw_scaled = raw / max(temperature, eps)           # temperature controls exploration
    max_raw = np.max(raw_scaled)
    exp_raw = np.exp(raw_scaled - max_raw)             # numeric stability
    probs = exp_raw / np.sum(exp_raw)                  # normalize to probabilities
    priorities[mask] = probs
    return priorities
```
