[
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    valid = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[valid] = -(bins_remain_cap[valid] - item)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = leftover >= 0\n    priorities[feasible] = -leftover[feasible]\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin using worst-fit strategy.\"\"\"\n    return np.where(bins_remain_cap >= item, bins_remain_cap, -np.inf)",
    "response_id": 2,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Stochastic best\u2011fit: exponential bias toward tighter fits combined with random factor.\"\"\"\n    # -inf for infeasible bins; exponential bias favors low residual, random adds exploration\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities\n    residual = bins_remain_cap[feasible] - item\n    eps = 1e-9\n    temperature = 0.5\n    bias = np.exp(-residual / (temperature + eps))\n    rand = np.random.rand(residual.size)\n    priorities[feasible] = bias * rand\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.01874750698045,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    Random Fit: choose a bin at random among those that can fit the item.\n    We add a weighted random component to prioritize bins with less free space.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    fit = bins_remain_cap >= item\n    if np.any(fit):\n        remaining = bins_remain_cap[fit] - item\n        eps = 1e-6\n        weights = 1.0 / (remaining + eps)\n        random_vals = np.random.rand(np.count_nonzero(fit))\n        priorities[fit] = weights * random_vals\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 3.9289988033506273,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    available = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if available.any():\n        priorities[available] = -(bins_remain_cap[available] - item)\n    return priorities",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    residual = bins_remain_cap - item\n    mask = residual >= 0\n    cap = bins_remain_cap.max() if bins_remain_cap.size else 0.0\n    if cap <= 0:\n        return np.zeros_like(bins_remain_cap)\n    norm_res = residual / cap\n    k = 12.0\n    offset = 0.15\n    raw_score = 1.0 / (1.0 + np.exp(k * (norm_res - offset)))\n    return raw_score * mask",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    mask = bins_remain_cap >= item\n    if not np.any(mask):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    residual = bins_remain_cap - item\n    temperature = 1.0\n    raw = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    raw[mask] = -residual[mask] / temperature\n    max_raw = np.max(raw[mask])\n    exp_raw = np.exp(raw - max_raw)\n    sum_exp = np.sum(exp_raw)\n    if sum_exp == 0:\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    priorities = exp_raw / sum_exp\n    return priorities",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\n# Hybrid priority: tight-fit weight, sigmoid scaling, and random perturbation.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combine 1/(remaining+\u03b5) weight, sigmoid of normalized residual, and small random factor.\"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    fit = bins_remain_cap >= item\n    if not np.any(fit):\n        return priorities\n    remaining = bins_remain_cap[fit] - item\n    eps = 1e-12\n    weight = 1.0 / (remaining + eps)\n    max_rem = bins_remain_cap.max() if bins_remain_cap.size else 1.0\n    normalized = remaining / (max_rem + eps)\n    k = 12.0\n    offset = 0.2\n    sigmoid = 1.0 / (1.0 and 1.0 + np.exp(k * (normalized - offset)))  # sigmoid bias toward tight fit\n    beta = 0.2\n    random_factor = 1.0 + beta * (np.random.rand(remaining.shape[0]) - 0.5)\n    priorities[fit] = weight * sigmoid * random_factor\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.0885520542481055,
    "SLOC": 17.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\n# Combine tight\u2011fit softmax with a slight worst\u2011fit bias\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Softmax over negative residual with a small bias toward larger bins.\"\"\"\n    mask = bins_remain_cap >= item\n    if not np.any(mask):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    residual = bins_remain_cap - item\n    temperature = 0.5\n    bias_factor = 0.1\n    epsilon = 1e-12\n    raw = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    raw[mask] = -residual[mask] / temperature\n    raw[mask] += bias_factor * bins_remain_cap[mask] / (bins_remain_cap.max() + epsilon)\n    max_raw = raw[mask].max()\n    exp_raw = np.exp(raw - max_raw)\n    exp_raw[~mask] = 0.0\n    sum_exp = exp_raw.sum()\n    if sum_exp == 0:\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    priorities = exp_raw / sum_exp\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    eps = 1e-9\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    fit = bins_remain_cap >= item\n    if not np.any(fit):\n        return priorities\n    remaining = bins_remain_cap[fit] - item\n    weight1 = 1.0 / (remaining + eps)\n    max_rem = bins_remain_cap.max() + eps\n    norm_left = remaining / max_rem\n    thresh = 0.2\n    scale = 0.05\n    weight2 = 1.0 / (1.0 + np.exp((norm_left - thresh) / scale))\n    random_vals = np.random.rand(np.count_nonzero(fit))\n    combined = weight1 * weight2 * (1 + 0.1 * random_vals)\n    priorities[fit] = combined\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]