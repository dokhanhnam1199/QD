[
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    valid = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[valid] = -(bins_remain_cap[valid] - item)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    leftover = bins_remain_cap - item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    feasible = leftover >= 0\n    priorities[feasible] = -leftover[feasible]\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin using worst-fit strategy.\"\"\"\n    return np.where(bins_remain_cap >= item, bins_remain_cap, -np.inf)",
    "response_id": 2,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_hs3.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                min_priority: float = -950042335873.0067,\n                eps: float = 0.000436714846983465,\n                weight: float = 9.093301174060638) -> np.ndarray:\n    priorities = np.full_like(bins_remain_cap, min_priority, dtype=np.float64)\n    fit = bins_remain_cap >= item\n    if np.any(fit):\n        remaining = bins_remain_cap[fit] - item\n        weights = weight / (remaining + eps)\n        random_vals = np.random.rand(np.count_nonzero(fit))\n        priorities[fit] = weights * random_vals\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 3.9589150378939015,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    Random Fit: choose a bin at random among those that can fit the item.\n    We add a weighted random component to prioritize bins with less free space.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    fit = bins_remain_cap >= item\n    if np.any(fit):\n        remaining = bins_remain_cap[fit] - item\n        eps = 1e-6\n        weights = 1.0 / (remaining + eps)\n        random_vals = np.random.rand(np.count_nonzero(fit))\n        priorities[fit] = weights * random_vals\n    return priorities",
    "response_id": 7,
    "tryHS": true,
    "obj": 3.9289988033506273,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    available = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if available.any():\n        priorities[available] = -(bins_remain_cap[available] - item)\n    return priorities",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    residual = bins_remain_cap - item\n    mask = residual >= 0\n    cap = bins_remain_cap.max() if bins_remain_cap.size else 0.0\n    if cap <= 0:\n        return np.zeros_like(bins_remain_cap)\n    norm_res = residual / cap\n    k = 12.0\n    offset = 0.15\n    raw_score = 1.0 / (1.0 + np.exp(k * (norm_res - offset)))\n    return raw_score * mask",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    mask = bins_remain_cap >= item\n    if not np.any(mask):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    residual = bins_remain_cap - item\n    temperature = 1.0\n    raw = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    raw[mask] = -residual[mask] / temperature\n    max_raw = np.max(raw[mask])\n    exp_raw = np.exp(raw - max_raw)\n    sum_exp = np.sum(exp_raw)\n    if sum_exp == 0:\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    priorities = exp_raw / sum_exp\n    return priorities",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\n# Hybrid priority: tight-fit weight, sigmoid scaling, and random perturbation.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combine 1/(remaining+\u03b5) weight, sigmoid of normalized residual, and small random factor.\"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    fit = bins_remain_cap >= item\n    if not np.any(fit):\n        return priorities\n    remaining = bins_remain_cap[fit] - item\n    eps = 1e-12\n    weight = 1.0 / (remaining + eps)\n    max_rem = bins_remain_cap.max() if bins_remain_cap.size else 1.0\n    normalized = remaining / (max_rem + eps)\n    k = 12.0\n    offset = 0.2\n    sigmoid = 1.0 / (1.0 and 1.0 + np.exp(k * (normalized - offset)))  # sigmoid bias toward tight fit\n    beta = 0.2\n    random_factor = 1.0 + beta * (np.random.rand(remaining.shape[0]) - 0.5)\n    priorities[fit] = weight * sigmoid * random_factor\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.0885520542481055,
    "SLOC": 17.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse\u2011residual weighting with slight capacity bias and tiny random jitter.\"\"\"\n    mask = bins_remain_cap >= item\n    if not np.any(mask):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    residual = bins_remain_cap - item\n    eps = 1e-12\n    inv_res = 1.0 / (residual + eps)\n    bias_factor = 0.05\n    max_cap = bins_remain_cap.max()\n    bias = bias_factor * bins_remain_cap / (max_cap + eps)\n    weight = inv_res + bias\n    weight[~mask] = 0.0\n    jitter = 1e-3 * weight * np.random.rand(weight.size)\n    weight += jitter\n    total = weight.sum()\n    if total == 0.0:\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    return weight / total",
    "response_id": 9,
    "tryHS": false,
    "obj": 3.8791384124451627,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    eps = 1e-9\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    fit = bins_remain_cap >= item\n    if not np.any(fit):\n        return priorities\n    remaining = bins_remain_cap[fit] - item\n    weight1 = 1.0 / (remaining + eps)\n    max_rem = bins_remain_cap.max() + eps\n    norm_left = remaining / max_rem\n    thresh = 0.2\n    scale = 0.05\n    weight2 = 1.0 / (1.0 + np.exp((norm_left - thresh) / scale))\n    random_vals = np.random.rand(np.count_nonzero(fit))\n    combined = weight1 * weight2 * (1 + 0.1 * random_vals)\n    priorities[fit] = combined\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    eps = 1e-12\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=np.float64)\n    fit = bins_remain_cap >= item\n    if not np.any(fit):\n        return priorities\n    remaining = bins_remain_cap[fit] - item\n    tight_weight = 1.0 / (remaining + eps)\n    max_cap = np.max(bins_remain_cap) if bins_remain_cap.size > 0 else 1.0\n    fill_level = 1.0 - np.mean(bins_remain_cap) / (max_cap + eps)\n    temp = np.clip(1.0 - fill_level, eps, 1.0)\n    scaled = np.log(tight_weight + eps) / temp\n    max_scaled = np.max(scaled)\n    exp_scaled = np.exp(scaled - max_scaled)\n    soft_weights = exp_scaled\n    rnd = np.random.rand(remaining.shape[0])\n    var_factor = np.std(remaining) / (np.mean(remaining) + eps)\n    alpha = np.clip(var_factor, 0.0, 1.0)\n    scores = (1 - alpha) * soft_weights + alpha * rnd\n    priorities[fit] = scores\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\n# priority_v2: combine inverse-remaining weighting, linear bias, variance\u2011scaled jitter.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize tight fits using inverse remaining capacity, a linear bias, and variance\u2011scaled jitter.\"\"\"\n    eps = 1e-12\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=np.float64)\n    fit = bins_remain_cap >= item\n    if not np.any(fit):\n        return priorities\n    remaining = bins_remain_cap[fit] - item\n    weight = 1.0 / (remaining + eps)\n    max_rem = bins_remain_cap.max() if bins_remain_cap.size else 1.0\n    bias = 1.0 - remaining / (max_rem + eps)\n    var_factor = np.clip(np.std(remaining) / (np.mean(remaining) + eps), 0.0, 1.0)\n    jitter = var_factor * (np.random.rand(remaining.size) - 0.5)\n    priorities[fit] = weight * bias * (1.0 + jitter)\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n    fit = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64) if bins_remain_cap.dtype != np.float64 else np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    if not np.any(fit):\n        return priorities\n    remaining = bins_remain_cap[fit] - item\n    eps = 1e-9\n    inv_weight = 1.0 / (remaining + eps)\n    cap = bins_remain_cap.max()\n    norm_rem = remaining / cap if cap > 0 else remaining\n    k = 10.0\n    offset = 0.1\n    exp_term = np.exp(np.clip(k * (norm_rem - offset), -50, 50))\n    sigmoid = 1.0 / (1.0 + exp_term)\n    rand = np.random.rand(remaining.shape[0])\n    priorities[fit] = inv_weight * sigmoid * rand\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.098524132429212,
    "SLOC": 19.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  }
]