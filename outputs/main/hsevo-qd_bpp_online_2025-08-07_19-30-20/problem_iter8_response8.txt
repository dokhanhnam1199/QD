```python
import numpy as np

# Combine inverse-remaining weighting, size bias, jitter, and probability normalization.
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Compute bin priorities favoring tight fits using inverse residual capacity, a small bias toward larger bins, and a tiny random jitter; scores are normalized for feasible bins."""
    eps = 1e-12
    min_priority = -1e12
    priorities = np.full_like(bins_remain_cap, min_priority, dtype=np.float64)
    fit = bins_remain_cap >= item
    if not np.any(fit):
        return priorities
    remaining = bins_remain_cap[fit] - item
    weight = 1.0 / (remaining + eps)                     # inverse residual
    max_cap = bins_remain_cap.max()
    bias_factor = 0.02
    bias = 1.0 + bias_factor * (bins_remain_cap[fit] / (max_cap + eps))  # tiny size bias
    jitter_scale = 0.02
    jitter = jitter_scale * (np.random.rand(remaining.size) - 0.5)        # small tieâ€‘break jitter
    scores = weight * bias * (1.0 + jitter)
    total = scores.sum()
    if total > 0:
        scores /= total                                 # normalize to probabilities
    priorities[fit] = scores
    return priorities
```
