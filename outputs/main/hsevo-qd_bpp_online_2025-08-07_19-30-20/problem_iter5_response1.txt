```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Compute bin priorities using inverse remaining capacity, sigmoid bias toward tight fits, and a small random jitter for tieâ€‘breaking."""
    # Default: bins that cannot fit the item get -inf priority
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    fit = bins_remain_cap >= item
    if not np.any(fit):
        return priorities
    # Remaining space after placing the item in each fitting bin
    remaining = bins_remain_cap[fit] - item
    eps = 1e-9
    # Inverse weight favors tighter fits
    inv_weight = 1.0 / (remaining + eps)
    # Normalized remaining (relative to max capacity) for sigmoid scaling
    max_cap = bins_remain_cap.max() if bins_remain_cap.size if bins_remain_cap.size else 1.0
    normalized = remaining / (max_cap + eps)
    # Sigmoid bias: larger for smaller normalized remaining
    k = 8.0
    offset = 0.2
    sigmoid = 1.0 / (1.0 + np.exp(k * (normalized - offset)))
    # Small random jitter to break ties
    jitter = 0.1
    random_factor = 1.0 + jitter * (np.random.rand(remaining.shape[0]) - 0.5)
    # Combined priority
    priorities[fit] = inv_weight * sigmoid * random_factor
    return priorities
```
