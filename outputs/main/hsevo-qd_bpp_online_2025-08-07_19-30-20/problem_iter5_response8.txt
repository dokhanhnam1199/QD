```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines inverse-remaining weighting, logistic scaling for tight fits, and a small random jitter for tieâ€‘breaking."""
    mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)
    if not np.any(mask):
        return priorities
    remaining = bins_remain_cap[mask] - item
    eps = 1e-12
    weight = 1.0 / (remaining + eps)
    max_rem = remaining.max()
    normalized = remaining / (max_rem + eps)
    k = 12.0
    offset = 0.15
    logistic = 1.0 / (1.0 + np.exp(k * (normalized - offset)))
    beta = 0.05
    jitter = 1.0 + beta * (np.random.rand(remaining.size) - 0.5)
    priorities[mask] = weight * logistic * jitter
    return priorities
```
