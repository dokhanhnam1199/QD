import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    epsilon: float = 4.3641451038778966e-07,
    fill_value: float = -208622190234.29248,  # sentinel for infeasible bins
    var_factor_min: float = 0.09522471848152197,
    var_factor_max: float = 0.6441000042474092,
    jitter_offset: float = 0.8460223371717367,
    jitter_base: float = 0.6436340517995319,
    inv_weight_base: float = 0.44742041255647724,
    bias_base: float = 0.003738342604453715,
) -> np.ndarray:
    """Combine inverse residual, linear bias, varianceâ€‘scaled jitter and uniform randomness for online BPP.

    All magic numbers are exposed as parameters for easy tuning.
    """
    if bins_remain_cap.size == 0:
        return np.empty(0, dtype=np.float64)

    fit = bins_remain_cap >= item
    priorities = np.full(bins_remain_cap.shape, fill_value, dtype=np.float64)

    if not np.any(fit):
        return priorities

    remaining = bins_remain_cap[fit] - item
    inv_weight = inv_weight_base / (remaining + epsilon)

    max_rem = bins_remain_cap.max()
    bias = bias_base - remaining / (max_rem + epsilon)  # bias towards larger bins

    var_factor = np.clip(
        np.std(remaining) / (np.float64(np.mean(remaining)) + epsilon),
        var_factor_min,
        var_factor_max,
    )

    jitter = var_factor * (np.random.rand(remaining.size) - jitter_offset)

    rand_factor = np.random.rand(remaining.size)

    priorities[fit] = inv_weight * bias * (jitter_base + jitter) * rand_factor

    return priorities
