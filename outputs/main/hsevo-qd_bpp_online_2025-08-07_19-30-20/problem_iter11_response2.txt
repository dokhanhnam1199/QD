```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Best‑fit weight (1/(remaining+1)) with tiny random factor; infeasible bins → -inf."""
    # Identify bins that can accommodate the item.
    feasible = bins_remain_cap >= item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    if not feasible.any():
        return priorities
    remaining = bins_remain_cap[feasible] - item
    # Inverse remaining capacity gives higher priority to tighter fits.
    weight = 1.0 / (remaining + 1.0)
    # Small multiplicative jitter to break ties.
    jitter = 1.0 + 1e-6 * (np.random.rand(weight.size) - 0.5)
    priorities[feasible] = weight * jitter
    return priorities
```
