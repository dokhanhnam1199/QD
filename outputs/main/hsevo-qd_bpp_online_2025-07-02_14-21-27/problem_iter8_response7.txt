```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines volume utilization, balance, and a size-based penalty
    with adaptive weighting for online bin packing.
    """
    valid_bins = bins_remain_cap > 0
    if not np.any(valid_bins):
        return np.zeros_like(bins_remain_cap)

    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, -1)

    # Volume utilization priority
    volume_utilization_priority = np.where(safe_bins_remain_cap >= item, item / safe_bins_remain_cap, -np.inf)

    # Remaining space balance priority
    balance_priority = np.where(safe_bins_remain_cap >= item, (safe_bins_remain_cap - item) / np.max(bins_remain_cap), -np.inf)

    # Large item penalty, adaptively weighted.
    item_size_ratio = item / np.mean(bins_remain_cap[valid_bins]) if np.any(valid_bins) else 0.0
    large_item_penalty = -0.1 if item_size_ratio > 1.0 else 0.0  # Only penalize if significantly larger

    # Adaptive weights based on item size.  Larger items emphasize balance.
    weight_volume = max(0.1, 0.7 - item_size_ratio*0.3) # volume decreases as item increases, min value
    weight_balance = min(0.8, 0.2 + item_size_ratio * 0.6) # balance priority increases as item increases, max value
    weight_penalty = 1 - weight_volume - weight_balance

    combined_priority = (
        weight_volume * volume_utilization_priority +
        weight_balance * (-balance_priority) +
        weight_penalty * large_item_penalty
    )

    priorities = np.where(~valid_bins, -np.inf, combined_priority)
    
    return priorities
```
