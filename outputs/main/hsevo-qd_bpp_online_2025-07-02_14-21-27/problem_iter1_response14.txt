```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Strive to minimize wasted space by favoring bins where the item nearly fills it.
    Penalize bins that are too small and heavily penalize empty bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Find feasible bins (bins with enough capacity)
    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        # If no feasible bin, prioritize the least-full bin (least remaining cap)
        priorities = -bins_remain_cap  # Assign negative remaining capacity as priority

    else:
        # Calculate the wasted space if item is placed in each feasible bin
        wasted_space = bins_remain_cap - item

        # Prioritize bins where the wasted space is small (item nearly fits)
        # Use a Gaussian-like distribution to favor bins close to the optimal fit.
        # A smaller standard deviation means we are more strict about the wasted space being close to zero.
        std_dev = np.mean(bins_remain_cap) * 0.1 #10% of average bin capacity

        gaussian_priority = np.exp(-(wasted_space**2) / (2 * std_dev**2))

        # Apply only to feasible bins
        priorities[feasible_bins] = gaussian_priority[feasible_bins]

        #Heavily penalize placing item in almost-empty bin if a better fit is available
        empty_bin_threshold = np.max(bins_remain_cap)*0.9
        almost_empty = bins_remain_cap > empty_bin_threshold
        priorities[almost_empty] *= 0.1 #Reduce priority to near zero for such bins
        
    return priorities
```
