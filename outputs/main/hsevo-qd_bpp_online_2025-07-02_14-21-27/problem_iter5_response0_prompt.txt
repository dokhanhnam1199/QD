{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Adaptive Capacity Matching Heuristic: Prioritizes bins based on how well\n    the item's size \"fits\" into the remaining capacity, considering both\n    the absolute difference and the proportion of the bin filled. Also includes a small random factor to handle pathological cases.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative capacity\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n      return np.zeros_like(bins_remain_cap)\n\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n\n    # Calculate capacity difference\n    capacity_diff = np.abs(safe_bins_remain_cap - item)\n\n    # Calculate proportion of bin filled if item is added\n    proportion_filled = np.where(safe_bins_remain_cap >= item, item / safe_bins_remain_cap, -np.inf)  # Negative inf if item doesn't fit\n\n    # Calculate a combined score: lower difference AND higher fill is better\n    priority = proportion_filled / (capacity_diff + 1e-6) # Adding small number to prevent division by zero and stabilize\n\n    # Add a small random factor to avoid stagnation and explore different solutions\n    priority += np.random.rand(len(bins_remain_cap)) * 0.01\n\n    # Ensure the item fits in the bin, otherwise, very low priority\n    priority = np.where(safe_bins_remain_cap >= item, priority, -np.inf)\n\n    priority = np.nan_to_num(priority, neginf=-np.inf)\n    priority = np.where(~valid_bins, -np.inf, priority)  # Invalid bins get lowest priority\n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines Newtonian and ratio-based approaches for bin packing priority.\"\"\"\n    # Newtonian component (with safety checks)\n    valid_bins = bins_remain_cap > 0\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n    potential = (safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item))\n    newton_priorities = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n    newton_priorities = np.nan_to_num(newton_priorities, neginf=-np.inf)\n    newton_priorities = np.where(~valid_bins, -np.inf, newton_priorities)\n\n    # Ratio component (dampened to avoid dominance)\n    ratios = item / bins_remain_cap\n    ratios = np.clip(ratios, 0.01, 100)  # Clamp for stability\n    log_ratios = np.log(ratios)\n    ratio_priorities = -log_ratios\n\n    # Weighted combination - adaptive weight based on item size relative to bin capacities\n    mean_cap = np.mean(bins_remain_cap) if bins_remain_cap.size > 0 else 0\n    weight = np.clip(item / (mean_cap + 1e-9), 0, 1)  # Avoid division by zero\n\n    combined_priorities = (1 - weight) * newton_priorities + weight * ratio_priorities\n    return combined_priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic uses a combined approach, considering both capacity difference and the proportion of the bin filled, with a small random factor for exploration and safety checks. The worst heuristic simply calculates the log of the ratio of item size to bin capacity.\n\nComparing (5th) vs (11th), the 5th heuristic combines \"Newtonian\" and ratio-based approaches with adaptive weighting and clamping for stability. The 11th heuristic uses only a \"Newtonian\" approach. The adaptive weighting based on item size relative to bin capacity seems to make the combined approach superior.\n\nComparing (14th) vs (17th), we see that even incomplete Newtonian is better.\n\nComparing (2nd) vs (3rd), (3rd) vs (4th), we see that they are exactly the same.\n\nComparing (15th) vs (16th), we see that they are exactly the same.\n\nComparing (18th) vs (19th), (19th) vs (20th), we see that they are exactly the same.\n\nOverall: The better heuristics employ more sophisticated calculations, considering multiple factors (capacity difference, fill proportion, ratios). They also include safety checks (avoiding division by zero, negative capacities) and mechanisms to prevent stagnation (random factors, clamping). Adaptive weighting appears to be a crucial element. Simpler ratio-based approaches are less effective. Using different libraries doesn't help. Incomplete valid checks are useless.\n- \nOkay, let's refine \"Current self-reflection\" to build better heuristics, avoiding pitfalls:\n\n*   **Keywords:** Adaptive learning, robustness, validation, multi-faceted evaluation.\n\n*   **Advice:** Focus on iteratively refining heuristics through rigorous testing and performance analysis. Adapt the complexity of the heuristic to the specific problem characteristics and computational constraints.\n\n*   **Avoid:** Blindly pursuing complexity or relying solely on inspiration from unrelated fields without thorough validation.\n\n*   **Explanation:** Emphasize learning from results and adapting the heuristic. Instead of \"more sophisticated is better\", prioritize effective complexity matched to the problem.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}