```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A more sophisticated priority function combining several factors:
    - Remaining capacity relative to item size (ratio).
    - Absolute remaining capacity.
    - Number of items already in the bin (bin utilization).
    - A stochastic element for exploration.

    It also addresses edge cases and ensures numerical stability.
    """
    valid_bins = bins_remain_cap > 0
    if not np.any(valid_bins):
        return np.zeros_like(bins_remain_cap)

    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, -1)

    # 1. Ratio-based priority (how well the item fits relatively)
    ratio_priority = np.clip(safe_bins_remain_cap / item, 0.001, 1000)
    ratio_priority = np.log(ratio_priority)

    # 2. Absolute remaining capacity priority
    capacity_priority = safe_bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0

    # 3. Bin Utilization (Prioritize bins that are already somewhat full, mimicking First-Fit Decreasing)
    # Assume we don't KNOW the number of items in each bin.  Approximation using remaining capacity as a proxy.
    utilization_proxy = 1 - (safe_bins_remain_cap / np.sum(bins_remain_cap)) if np.sum(bins_remain_cap) > 0 else 0
    utilization_priority = utilization_proxy
    utilization_priority = np.clip(utilization_priority, 0, 1)  # Ensure it's within a reasonable range

    # 4. Stochastic Exploration (add noise to explore different bin assignments)
    exploration_factor = 0.01 * np.random.randn(len(bins_remain_cap))  # Small random noise

    # Adaptive Weighting (Dynamically adjust weights based on item size and bin capacities)
    item_size_ratio = np.clip(item / (np.mean(bins_remain_cap) + 1e-9), 0.0, 1.0) #relative to average bin size
    weight_ratio = 0.4 # Weight for ratio priority. Adjust based on performance
    weight_capacity = 0.3 # Weight for absolute cap. Adjust based on performance
    weight_utilization = 0.2  # Weight for utilization.
    weight_exploration = 0.1  # Weight for exploration

    # Combine priorities with adaptive weights
    combined_priority = (
        weight_ratio * ratio_priority +
        weight_capacity * capacity_priority +
        weight_utilization * utilization_priority +
        weight_exploration * exploration_factor
    )
    
    priorities = np.where(~valid_bins, -np.inf, combined_priority)
    return priorities
```
