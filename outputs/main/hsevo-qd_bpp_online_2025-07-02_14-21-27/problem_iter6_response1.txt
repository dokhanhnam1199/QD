```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Enhanced priority function for online bin packing, combining capacity utilization,
    fragmentation awareness, and a penalty for near-empty bins.
    """
    valid_bins = bins_remain_cap > 0
    if not np.any(valid_bins):
        return np.zeros_like(bins_remain_cap)

    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)

    # 1. Capacity Utilization Score:
    #   - Encourages filling bins as much as possible.  Higher score for bins that will be
    #     more full after packing.
    capacity_utilization = (safe_bins_remain_cap - item) / safe_bins_remain_cap
    capacity_utilization = np.where(safe_bins_remain_cap >= item, 1 - capacity_utilization, -np.inf)

    # 2. Fragmentation Avoidance:
    #   - Penalizes bins that would leave small remaining capacity after packing, to avoid
    #     creating many nearly-empty bins.
    fragmentation_penalty = np.where(
        (safe_bins_remain_cap >= item) & ((safe_bins_remain_cap - item) < 0.1),  # Adjust threshold (0.1) as needed
        -0.5,  # Adjust penalty as needed (negative value)
        0.0
    )
    # 3. Empty Bin Preference: (modified)
    #    Give empty bins (or bins with almost nothing in them) a slight initial preference if the item fits.
    empty_bin_bonus = np.where(
        (safe_bins_remain_cap >= item) & (safe_bins_remain_cap > 0.99), # if almost empty and item fits
        0.2,  # Adjust bonus as needed
        0.0
    )

    # Combine the scores with weights. Adjust weights as needed.
    combined_priority = (
        1.0 * capacity_utilization +
        0.8 * fragmentation_penalty +
        0.5 * empty_bin_bonus
    )

    combined_priority = np.nan_to_num(combined_priority, neginf=-np.inf)
    priorities = np.where(~valid_bins, -np.inf, combined_priority)

    return priorities
```
