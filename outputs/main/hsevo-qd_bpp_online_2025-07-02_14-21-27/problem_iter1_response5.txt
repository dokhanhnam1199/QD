```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item relatively well
    without leaving too much unused space.  It also discourages using nearly
    empty bins unless absolutely necessary. A small constant is added to avoid
    division by zero errors or undefined behavior when bins_remain_cap is zero.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 1e-9  # Small constant to avoid division by zero
    remaining_space = bins_remain_cap - item
    # Give a large penalty if the item doesn't fit.
    priority = np.where(remaining_space < -epsilon, -np.inf, 0)

    # If the item fits, prioritize bins where the remaining space is small,
    # but not too small (avoiding nearly full bins when other options exist).
    # The goal is to balance packing efficiently with avoiding fragmentation.

    #Calculate the relative wasted space if we add to the bin
    relative_waste = remaining_space / (bins_remain_cap + epsilon)
    priority = np.where(remaining_space >= -epsilon, 1 - relative_waste, priority) # Higher remaining capacity => lower priority (unless waste > threshold)
    
    #Add a penalty for very empty bins, especially useful when item cannot fit elsewhere
    penalty = - np.abs(bins_remain_cap-1)/2
    priority = np.where(remaining_space >= -epsilon, priority + penalty, priority)

    return priority
```
