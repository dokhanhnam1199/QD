```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Newtonian and ratio-based approaches."""
    # Newtonian component
    valid_bins = bins_remain_cap > 0
    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)
    potential = (safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item))
    newtonian_priority = np.where(safe_bins_remain_cap >= item, potential, -np.inf)
    newtonian_priority = np.nan_to_num(newtonian_priority, neginf=-np.inf)
    newtonian_priority = np.where(~valid_bins, -np.inf, newtonian_priority)

    # Ratio-based component (handle zero bins)
    ratios = np.where(bins_remain_cap > 0, item / bins_remain_cap, np.inf)
    ratios = np.nan_to_num(ratios, posinf=np.inf)  # Handle division by zero explicitly

    log_ratios = np.where(ratios != np.inf, np.log(ratios), -np.inf) #avoid log of inf
    ratio_priority = -log_ratios
    ratio_priority = np.nan_to_num(ratio_priority, neginf=-np.inf)

    # Combined priority: weight Newtonian more if feasible
    combined_priority = np.where(safe_bins_remain_cap >= item,
                                   0.7 * newtonian_priority + 0.3 * ratio_priority,
                                   ratio_priority) # If not feasible, use ratio for exploration.

    return combined_priority
```
