```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This version prioritizes bins that can fit the item with minimal waste,
    but also avoids bins that are almost exactly the item's size (to prevent future small items from being hard to place).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Give a small negative priority if the bin cannot hold the item.
    cannot_fit = bins_remain_cap < item
    priorities[cannot_fit] = -1e9  # Large negative number ensures these are lowest priority

    # Calculate waste if item is added to each bin.
    waste = bins_remain_cap - item
    
    # Prioritize bins with less waste, but with a non-linear relationship. This will favor less waste but not penalize higher waste too much.
    # Add a tiny value to avoid division by zero. Also penalize exact fits a little
    priorities[~cannot_fit] = np.exp(-waste[~cannot_fit]/(item+1e-6))  - np.abs(waste[~cannot_fit]/(item+1e-6)-0)

    # Further refine priority to reduce the chance of leaving extremely small gaps, making later bin packing difficult.
    # penalize almost perfect fit, give a small negative value close to zero
    almost_perfect_fit = (waste > 0) & (waste < (item * 0.1))
    priorities[almost_perfect_fit] -= 0.2
    return priorities
```
