```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines multiple factors including:
    1. Capacity utilization (ratio of item size to remaining capacity).
    2. Waste minimization (absolute difference between remaining capacity and item size).
    3. Bin fullness (remaining capacity relative to original bin capacity - assume original capacity is 1).
    4. Best Fit Score (Prioritizes bins where item nearly fills it up).
    5. Emptiest Bin Avoidance (Discourages placing items in nearly empty bins).
    """
    valid_bins = bins_remain_cap > 0
    if not np.any(valid_bins):
        return np.zeros_like(bins_remain_cap)

    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)

    # 1. Capacity utilization: Encourage filling bins effectively.
    capacity_utilization = np.clip(item / (safe_bins_remain_cap + 1e-9), 0.0, 1.0)

    # 2. Waste minimization: Prefer bins where the item fits well with minimal waste.
    waste = np.abs(safe_bins_remain_cap - item)
    waste_priority = 1.0 / (waste + 1e-9)  # Invert to prioritize lower waste

    # 3. Bin fullness: Discourage using almost empty bins initially. Assume bin capacity is 1.
    bin_fullness = safe_bins_remain_cap # remaining capacity is already between 0 and 1

    # 4. Best Fit Score: Gives a high score to bins where item almost fills the bin
    best_fit_score = np.exp(-waste)
    best_fit_score = np.where(safe_bins_remain_cap >= item, best_fit_score, 0)

    # 5. Emptiest Bin Avoidance: Avoid placing items in the emptiest bins unless necessary
    emptiest_bin_penalty = np.exp(-10 * safe_bins_remain_cap) # Apply penalty if the remaining capacity is high

    # Adaptive weighting: Combine factors adaptively.
    # Heuristic to dynamically adjust weights based on item size.
    item_size_factor = np.clip(item, 0.1, 0.9)

    combined_priority = (
        0.4 * capacity_utilization +
        0.2 * waste_priority +
        0.1 * bin_fullness +
        0.3 * best_fit_score - # Increased Best Fit, since it's effective
        0.0 * emptiest_bin_penalty # Currently disabled, might be useful later if enabled
    )

    combined_priority = np.nan_to_num(combined_priority, neginf=-np.inf)
    priorities = np.where(~valid_bins, -np.inf, combined_priority)

    return priorities
```
