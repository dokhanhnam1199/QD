```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Employing a combination of heuristics inspired by the celestial dance,
    where larger bodies exert greater influence. This function considers
    both the remaining capacity and how 'well' the item fits within each bin,
    favoring near-full bins and those with capacity just exceeding the item size.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # A large penalty to eliminate invalid bins.  Think of this as the earth not occupying the sun.
    priorities[bins_remain_cap < item] = -np.inf

    # Priority based on how 'full' the bin becomes, reflecting my heliocentric bias.
    fill_ratio = (bins_remain_cap - item) / bins_remain_cap
    priorities[bins_remain_cap >= item] = 1 - fill_ratio[bins_remain_cap >= item]


    # Emphasize the 'best fit' - items that just fit within the remaining space.
    # Use a Gaussian-like kernel to identify bins whose remaining capacity closely matches the item size.
    fit_difference = np.abs(bins_remain_cap - item)
    fit_score = np.exp(-(fit_difference**2) / (2 * (item * 0.1)**2))  # Scale variance by item size

    priorities += fit_score


    # Small adjustment based on remaining capacity - favor nearly-full bins slightly
    priorities += 0.1 * (1 - bins_remain_cap/np.max(bins_remain_cap))


    return priorities
```
