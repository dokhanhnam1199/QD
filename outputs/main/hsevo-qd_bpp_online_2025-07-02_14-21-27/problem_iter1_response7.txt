```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the Many-Worlds Interpretation and Simulated Annealing.
    We explore different "worlds" (bins) probabilistically, favoring bins
    that can accommodate the item with minimal wasted space. Introduce a
    "temperature" parameter that controls exploration vs. exploitation.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    temperature = 0.1  # Controls exploration (higher) vs. exploitation (lower).  Adjust this.

    # Calculate wasted space (positive if fits, negative if doesn't)
    wasted_space = bins_remain_cap - item

    # Probability proportional to negative wasted space if it fits, 0 otherwise.
    # Add a small constant to avoid taking the log of zero if wasted_space exactly zero.

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fits_mask = wasted_space >= 0

    if np.any(fits_mask):
        #Calculate a Boltzmann-like probability distribution. exp(-wasted_space/T)
        energies = -wasted_space[fits_mask] / temperature
        probabilities = np.exp(energies) #Higher wasted space gives smaller energy, and smallr probability
        priorities[fits_mask] = probabilities
    else:
        #If it doesn't fit any, try to find the bin with the least leftover space after hypothetically placing the item
        priorities = -wasted_space # Negative wasted space.

    return priorities
```
