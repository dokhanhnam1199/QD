{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines Newtonian and ratio-based approaches with adaptive weighting.\"\"\"\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n    \n    # Newtonian component\n    potential = safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item)\n    newtonian_priority = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n\n    # Ratio-based component\n    ratio_priority = np.log(np.clip(safe_bins_remain_cap / item, 0.001, 1000))  # Clip for stability\n\n    # Adaptive weighting based on item size relative to bin capacity\n    weight = np.clip(item / (safe_bins_remain_cap + 1e-9), 0.0, 1.0) # Avoid zero division\n    combined_priority = weight * newtonian_priority + (1 - weight) * ratio_priority\n\n    combined_priority = np.nan_to_num(combined_priority, neginf=-np.inf)\n    priorities = np.where(~valid_bins, -np.inf, combined_priority)\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Newtonian and ratio-based approaches for bin packing priority.\"\"\"\n    # Newtonian component (with safety checks)\n    valid_bins = bins_remain_cap > 0\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n    potential = (safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item))\n    newton_priorities = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n    newton_priorities = np.nan_to_num(newton_priorities, neginf=-np.inf)\n    newton_priorities = np.where(~valid_bins, -np.inf, newton_priorities)\n\n    # Ratio component (dampened to avoid dominance)\n    ratios = item / bins_remain_cap\n    ratios = np.clip(ratios, ratio_min, ratio_max)  # Clamp for stability\n    log_ratios = np.log(ratios)\n    ratio_priorities = -log_ratios\n\n    # Weighted combination - adaptive weight based on item size relative to bin capacities\n    mean_cap = np.mean(bins_remain_cap) if bins_remain_cap.size > 0 else 0\n    weight = np.clip(item / (mean_cap + epsilon), weight_clip_min, weight_clip_max)  # Avoid division by zero\n\n    combined_priorities = (1 - weight) * newton_priorities + weight * ratio_priorities\n    return combined_priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the first heuristic combines Newtonian potential and ratio-based approaches with adaptive weighting, while the last heuristic solely relies on log ratios. The first also handles edge cases, such as empty bins.\n\nComparing (1st) vs (11th), the first combines Newtonian and ratio-based approaches with adaptive weighting, while the 11th uses a Newtonian Optimization Heuristic. The first is more robust by including a ratio component and adaptive weighting, which is lacking in the latter.\n\nComparing (7th) vs (11th), both include a check for valid bins and a Newtonian-inspired potential calculation. However, the 7th heuristic incorporates a proportion filled metric and a small random factor, which the 11th lacks, leading to more exploration.\n\nComparing (9th) vs (10th), the 9th combines multiple heuristics (capacity ratio, fit score, bin usage, Newtonian) with adaptive weighting based on item size, while the 10th combines volume utilization, balance, and a large item penalty with fixed weights. The adaptive weighting in the 9th makes it more flexible.\n\nComparing (16th) vs (17th), only one has a default parameter. The 16th version includes an `invalid_priority` parameter which allows more explicit control over handling invalid bins, while the 17th does not have it. This added parameter and the flexibility to control it makes the 16th superior.\n\nOverall: The better heuristics combine multiple factors (Newtonian potential, ratios, capacity utilization, item fit), often with adaptive weighting based on item size or bin fill level. They also include robust error handling (e.g., division by zero, invalid bins) and sometimes a random factor for exploration. Simpler heuristics that rely on a single factor or lack adaptive weighting tend to perform worse. The use of `np.clip` to bound ratio values is another common feature in well-performing functions, which enhances stability.\n- \nOkay, let's redefine \"Current Self-Reflection\" to focus on impactful heuristic design and avoid common pitfalls. We'll aim for actionable advice based on a deeper understanding of the process.\n\nHere's a revised reflection designed to guide better heuristic development:\n\n*   **Keywords:** Contextual awareness, adaptive exploration, validation, iterative refinement.\n*   **Advice:** Instead of blindly combining factors, deeply analyze the *relationships* between them. Prioritize understanding the *why* behind each factor's influence. Design for iterative refinement and validation using diverse datasets.\n*   **Avoid:** Premature complexity, relying solely on sophisticated calculations without clear justification, neglecting the importance of validation and data diversity.\n*   **Explanation:** Effective heuristics are built on understanding the problem's landscape, not just throwing equations at it. Prioritize adaptability and rigorously test assumptions throughout the development process.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}