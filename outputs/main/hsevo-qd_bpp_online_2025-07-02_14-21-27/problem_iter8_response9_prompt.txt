{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Newtonian and ratio-based approaches for bin packing priority.\"\"\"\n    # Newtonian component (with safety checks)\n    valid_bins = bins_remain_cap > 0\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n    potential = (safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item))\n    newton_priorities = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n    newton_priorities = np.nan_to_num(newton_priorities, neginf=-np.inf)\n    newton_priorities = np.where(~valid_bins, -np.inf, newton_priorities)\n\n    # Ratio component (dampened to avoid dominance)\n    ratios = item / bins_remain_cap\n    ratios = np.clip(ratios, ratio_min, ratio_max)  # Clamp for stability\n    log_ratios = np.log(ratios)\n    ratio_priorities = -log_ratios\n\n    # Weighted combination - adaptive weight based on item size relative to bin capacities\n    mean_cap = np.mean(bins_remain_cap) if bins_remain_cap.size > 0 else 0\n    weight = np.clip(item / (mean_cap + epsilon), weight_clip_min, weight_clip_max)  # Avoid division by zero\n\n    combined_priorities = (1 - weight) * newton_priorities + weight * ratio_priorities\n    return combined_priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic combines Newtonian and ratio-based approaches with adaptive weighting and safety checks, while the worst one only uses the ratio of item size to bin capacity and takes the negative logarithm of it; (2nd best) vs (2nd worst) presents the same distinction. Comparing (1st) vs (2nd), we see that they are identical, implying redundancy in the ranking. (3rd) vs (4th) are identical, indicating another redundancy. Comparing (second worst) vs (worst), they are identical. Overall: The best heuristics combine multiple factors (Newtonian potential, ratio, adaptive weighting) with careful handling of edge cases (invalid bins, division by zero). Simpler heuristics focusing on only one factor (e.g., ratio alone) perform poorly. Inclusion of adaptive weighting and safety checks seems to significantly improve performance. Duplicate heuristics exist, indicating a flawed evaluation process.\n- \nOkay, let's refine \"Current Self-Reflection\" to design better heuristics, focusing on actionable advice and avoiding pitfalls.\n\nHere's a breakdown:\n\n*   **Keywords:** Multifactorial, Adaptive, Robustness, Edge Cases, Exploration.\n\n*   **Advice:** Design heuristics that combine diverse, contextually relevant factors. Employ adaptive mechanisms to dynamically weight these factors. Prioritize exploration to escape local optima.\n\n*   **Avoid:** Oversimplification, Single-factor reliance, Premature optimization (start broad).\n\n*   **Explanation:** Effective heuristics balance complexity with adaptability. A multifactorial approach, dynamically weighted, allows for nuanced decision-making and greater robustness across diverse scenarios. Focus on robust code by starting with complete code.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}