{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    A refined priority function for online bin packing that combines multiple factors\n    with adaptive weighting and stochastic exploration.\n    \"\"\"\n\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n\n    # 1. Capacity-Aware Newtonian Potential\n    potential = safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item + 1e-9)\n    newtonian_priority = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n\n    # 2. Normalized Remaining Capacity\n    capacity_ratio = np.clip(safe_bins_remain_cap / (item + 1e-9), 0.001, 1000)\n    capacity_priority = np.log(capacity_ratio)\n\n    # 3. Bin Utilization (Encourages filling partially full bins)\n    bin_utilization = 1 - (safe_bins_remain_cap / np.max(bins_remain_cap))  # Normalize to 0-1\n    utilization_priority = np.where(safe_bins_remain_cap >= item, bin_utilization, -np.inf)\n\n    # 4. Item Size Relative to Average Available Capacity (Adaptive Weighting)\n    avg_capacity = np.mean(bins_remain_cap[valid_bins]) if np.any(valid_bins) else 1e-9\n    weight_newtonian = np.clip(item / (avg_capacity + 1e-9), 0.0, 1.0)\n    weight_capacity = np.clip(1 - item / (avg_capacity + 1e-9), 0.0, 1.0)\n\n    # 5. Combine Priorities with Adaptive Weights\n    combined_priority = (\n        weight_newtonian * newtonian_priority +\n        weight_capacity * capacity_priority +\n        0.2 * utilization_priority # Weight for utilization\n    )\n\n    # 6. Stochastic Exploration (Introduce some randomness)\n    exploration_factor = 0.01  # Adjust for desired exploration level\n    random_noise = np.random.normal(0, exploration_factor, size=bins_remain_cap.shape)\n    combined_priority += random_noise\n\n    # 7. Handling Invalid Bins and NaN values\n    combined_priority = np.nan_to_num(combined_priority, neginf=-np.inf)\n    priorities = np.where(~valid_bins, -np.inf, combined_priority)\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid priority: Newtonian potential + adaptive capacity ratio.\"\"\"\n\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n\n    # Newtonian potential\n    potential = safe_bins_remain_cap / (np.abs(safe_bins_remain_cap - item) + 1e-9)\n    newtonian_priority = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n\n    # Adaptive capacity ratio\n    capacity_ratio = np.clip(safe_bins_remain_cap / (item + 1e-9), 0.001, 1000)\n    ratio_priority = np.log(capacity_ratio)\n\n    # Adaptive Weight\n    mean_available_capacity = np.mean(bins_remain_cap[valid_bins]) if np.any(valid_bins) else 1.0\n    weight = np.clip(item / (mean_available_capacity + 1e-9), 0.0, 1.0)\n\n    # Combined priority with adaptive weighting\n    combined_priority = weight * newtonian_priority + (1 - weight) * ratio_priority\n\n    combined_priority = np.nan_to_num(combined_priority, neginf=-np.inf)\n    priorities = np.where(~valid_bins, -np.inf, combined_priority)\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid priority: Newtonian potential + adaptive capacity ratio.\"\"\"\n\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n\n    # Newtonian potential\n    potential = safe_bins_remain_cap / (np.abs(safe_bins_remain_cap - item) + 1e-9)\n    newtonian_priority = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n\n    # Adaptive capacity ratio\n    capacity_ratio = np.clip(safe_bins_remain_cap / (item + 1e-9), 0.001, 1000)\n    ratio_priority = np.log(capacity_ratio)\n\n    # Adaptive Weight\n    mean_available_capacity = np.mean(bins_remain_cap[valid_bins]) if np.any(valid_bins) else 1.0\n    weight = np.clip(item / (mean_available_capacity + 1e-9), 0.0, 1.0)\n\n    # Combined priority with adaptive weighting\n    combined_priority = weight * newtonian_priority + (1 - weight) * ratio_priority\n\n    combined_priority = np.nan_to_num(combined_priority, neginf=-np.inf)\n    priorities = np.where(~valid_bins, -np.inf, combined_priority)\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Newtonian potential and capacity ratio with adaptive weighting.\"\"\"\n\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n\n    # Newtonian component (Focuses on bins close to the item size)\n    potential = safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item + 1e-9)\n    newtonian_priority = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n\n    # Capacity ratio component (Prioritizes bins that have space relative to item)\n    capacity_ratio = np.clip(safe_bins_remain_cap / (item + 1e-9), 0.001, 1000)\n    ratio_priority = np.log(capacity_ratio)\n\n    # Adaptive weighting based on item size relative to *available* capacity\n    weight = np.clip(item / (np.mean(bins_remain_cap[valid_bins]) + 1e-9), 0.0, 1.0)\n\n    # Combine the priorities with adaptive weighting\n    combined_priority = weight * newtonian_priority + (1 - weight) * ratio_priority\n\n    combined_priority = np.nan_to_num(combined_priority, neginf=-np.inf)\n    priorities = np.where(~valid_bins, -np.inf, combined_priority)\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Newtonian potential and ratio, adaptively weighted.\"\"\"\n    valid_bins = bins_remain_cap > 0\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n\n    # Newtonian component\n    potential = safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item)\n    newtonian_priority = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n    newtonian_priority = np.nan_to_num(newtonian_priority, neginf=-np.inf)\n\n    # Ratio component\n    ratio_priority = np.log(np.clip(safe_bins_remain_cap / item, 0.001, 1000))\n\n    # Adaptive weighting\n    weight = np.clip(item / (safe_bins_remain_cap + 1e-9), 0.0, 1.0)\n    combined_priority = weight * newtonian_priority + (1 - weight) * ratio_priority\n\n    priorities = np.where(~valid_bins, -np.inf, combined_priority)\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Newtonian potential and ratio, adaptively weighted.\"\"\"\n    valid_bins = bins_remain_cap > 0\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n\n    # Newtonian component\n    potential = safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item)\n    newtonian_priority = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n    newtonian_priority = np.nan_to_num(newtonian_priority, neginf=-np.inf)\n\n    # Ratio component\n    ratio_priority = np.log(np.clip(safe_bins_remain_cap / item, 0.001, 1000))\n\n    # Adaptive weighting\n    weight = np.clip(item / (safe_bins_remain_cap + 1e-9), 0.0, 1.0)\n    combined_priority = weight * newtonian_priority + (1 - weight) * ratio_priority\n\n    priorities = np.where(~valid_bins, -np.inf, combined_priority)\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    An enhanced priority function that incorporates adaptive weighting, temperature-based exploration,\n    a refined capacity ratio, and penalties for near-misses.\n    \"\"\"\n\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n\n    # 1. Capacity-Aware Newtonian Potential (with softened denominator)\n    potential = safe_bins_remain_cap / (np.abs(safe_bins_remain_cap - item) + 0.1)\n    newtonian_priority = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n\n    # 2. Refined Capacity Ratio: Emphasize bins slightly larger than the item.\n    capacity_ratio = safe_bins_remain_cap / (item + 1e-9)\n    capacity_priority = np.where(\n        safe_bins_remain_cap >= item,\n        np.exp(-(capacity_ratio - 1)**2 / 0.5),  # Gaussian-like preference around ratio=1\n        -np.inf\n    )\n\n    # 3. Bin Utilization (Encourages filling partially full bins)\n    bin_utilization = 1 - (safe_bins_remain_cap / np.max(bins_remain_cap))\n    utilization_priority = np.where(safe_bins_remain_cap >= item, bin_utilization, -np.inf)\n\n    # 4. Near-Miss Penalty: Discourage bins that are almost big enough.\n    near_miss_penalty = np.where(\n        (safe_bins_remain_cap < item) & (safe_bins_remain_cap > item * 0.75),  # Tune 0.75\n        -10,  # Significant penalty\n        0\n    )\n\n    # 5. Adaptive Weighting based on Item Size and Available Capacity\n    avg_capacity = np.mean(bins_remain_cap[valid_bins]) if np.any(valid_bins) else 1e-9\n    item_size_ratio = np.clip(item / (avg_capacity + 1e-9), 0.0, 1.0)\n    weight_newtonian = 1 - item_size_ratio\n    weight_capacity = item_size_ratio\n\n    # 6. Temperature-Based Stochastic Exploration (Simulated Annealing)\n    temperature = 0.1  # Adjust cooling schedule as needed\n    exploration_factor = temperature * np.exp(-item_size_ratio) # Reduce exploration as item size increase\n    random_noise = np.random.normal(0, exploration_factor, size=bins_remain_cap.shape)\n\n    # 7. Combine Priorities with Adaptive Weights\n    combined_priority = (\n        weight_newtonian * newtonian_priority +\n        weight_capacity * capacity_priority +\n        0.2 * utilization_priority +\n        near_miss_penalty + # Directly add penalty\n        random_noise # Add the noise\n    )\n\n    # 8. Handle Invalid Bins and NaN values\n    combined_priority = np.nan_to_num(combined_priority, neginf=-np.inf)\n    priorities = np.where(~valid_bins, -np.inf, combined_priority)\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    An enhanced priority function that incorporates adaptive weighting, temperature-based exploration,\n    a refined capacity ratio, and penalties for near-misses.\n    \"\"\"\n\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n\n    # 1. Capacity-Aware Newtonian Potential (with softened denominator)\n    potential = safe_bins_remain_cap / (np.abs(safe_bins_remain_cap - item) + 0.1)\n    newtonian_priority = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n\n    # 2. Refined Capacity Ratio: Emphasize bins slightly larger than the item.\n    capacity_ratio = safe_bins_remain_cap / (item + 1e-9)\n    capacity_priority = np.where(\n        safe_bins_remain_cap >= item,\n        np.exp(-(capacity_ratio - 1)**2 / 0.5),  # Gaussian-like preference around ratio=1\n        -np.inf\n    )\n\n    # 3. Bin Utilization (Encourages filling partially full bins)\n    bin_utilization = 1 - (safe_bins_remain_cap / np.max(bins_remain_cap))\n    utilization_priority = np.where(safe_bins_remain_cap >= item, bin_utilization, -np.inf)\n\n    # 4. Near-Miss Penalty: Discourage bins that are almost big enough.\n    near_miss_penalty = np.where(\n        (safe_bins_remain_cap < item) & (safe_bins_remain_cap > item * 0.75),  # Tune 0.75\n        -10,  # Significant penalty\n        0\n    )\n\n    # 5. Adaptive Weighting based on Item Size and Available Capacity\n    avg_capacity = np.mean(bins_remain_cap[valid_bins]) if np.any(valid_bins) else 1e-9\n    item_size_ratio = np.clip(item / (avg_capacity + 1e-9), 0.0, 1.0)\n    weight_newtonian = 1 - item_size_ratio\n    weight_capacity = item_size_ratio\n\n    # 6. Temperature-Based Stochastic Exploration (Simulated Annealing)\n    temperature = 0.1  # Adjust cooling schedule as needed\n    exploration_factor = temperature * np.exp(-item_size_ratio) # Reduce exploration as item size increase\n    random_noise = np.random.normal(0, exploration_factor, size=bins_remain_cap.shape)\n\n    # 7. Combine Priorities with Adaptive Weights\n    combined_priority = (\n        weight_newtonian * newtonian_priority +\n        weight_capacity * capacity_priority +\n        0.2 * utilization_priority +\n        near_miss_penalty + # Directly add penalty\n        random_noise # Add the noise\n    )\n\n    # 8. Handle Invalid Bins and NaN values\n    combined_priority = np.nan_to_num(combined_priority, neginf=-np.inf)\n    priorities = np.where(~valid_bins, -np.inf, combined_priority)\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    An enhanced priority function that incorporates adaptive weighting, temperature-based exploration,\n    a refined capacity ratio, and penalties for near-misses.\n    \"\"\"\n\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n\n    # 1. Capacity-Aware Newtonian Potential (with softened denominator)\n    potential = safe_bins_remain_cap / (np.abs(safe_bins_remain_cap - item) + 0.1)\n    newtonian_priority = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n\n    # 2. Refined Capacity Ratio: Emphasize bins slightly larger than the item.\n    capacity_ratio = safe_bins_remain_cap / (item + 1e-9)\n    capacity_priority = np.where(\n        safe_bins_remain_cap >= item,\n        np.exp(-(capacity_ratio - 1)**2 / 0.5),  # Gaussian-like preference around ratio=1\n        -np.inf\n    )\n\n    # 3. Bin Utilization (Encourages filling partially full bins)\n    bin_utilization = 1 - (safe_bins_remain_cap / np.max(bins_remain_cap))\n    utilization_priority = np.where(safe_bins_remain_cap >= item, bin_utilization, -np.inf)\n\n    # 4. Near-Miss Penalty: Discourage bins that are almost big enough.\n    near_miss_penalty = np.where(\n        (safe_bins_remain_cap < item) & (safe_bins_remain_cap > item * 0.75),  # Tune 0.75\n        -10,  # Significant penalty\n        0\n    )\n\n    # 5. Adaptive Weighting based on Item Size and Available Capacity\n    avg_capacity = np.mean(bins_remain_cap[valid_bins]) if np.any(valid_bins) else 1e-9\n    item_size_ratio = np.clip(item / (avg_capacity + 1e-9), 0.0, 1.0)\n    weight_newtonian = 1 - item_size_ratio\n    weight_capacity = item_size_ratio\n\n    # 6. Temperature-Based Stochastic Exploration (Simulated Annealing)\n    temperature = 0.1  # Adjust cooling schedule as needed\n    exploration_factor = temperature * np.exp(-item_size_ratio) # Reduce exploration as item size increase\n    random_noise = np.random.normal(0, exploration_factor, size=bins_remain_cap.shape)\n\n    # 7. Combine Priorities with Adaptive Weights\n    combined_priority = (\n        weight_newtonian * newtonian_priority +\n        weight_capacity * capacity_priority +\n        0.2 * utilization_priority +\n        near_miss_penalty + # Directly add penalty\n        random_noise # Add the noise\n    )\n\n    # 8. Handle Invalid Bins and NaN values\n    combined_priority = np.nan_to_num(combined_priority, neginf=-np.inf)\n    priorities = np.where(~valid_bins, -np.inf, combined_priority)\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    An enhanced priority function that incorporates adaptive weighting, temperature-based exploration,\n    a refined capacity ratio, and penalties for near-misses.\n    \"\"\"\n\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n\n    # 1. Capacity-Aware Newtonian Potential (with softened denominator)\n    potential = safe_bins_remain_cap / (np.abs(safe_bins_remain_cap - item) + 0.1)\n    newtonian_priority = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n\n    # 2. Refined Capacity Ratio: Emphasize bins slightly larger than the item.\n    capacity_ratio = safe_bins_remain_cap / (item + 1e-9)\n    capacity_priority = np.where(\n        safe_bins_remain_cap >= item,\n        np.exp(-(capacity_ratio - 1)**2 / 0.5),  # Gaussian-like preference around ratio=1\n        -np.inf\n    )\n\n    # 3. Bin Utilization (Encourages filling partially full bins)\n    bin_utilization = 1 - (safe_bins_remain_cap / np.max(bins_remain_cap))\n    utilization_priority = np.where(safe_bins_remain_cap >= item, bin_utilization, -np.inf)\n\n    # 4. Near-Miss Penalty: Discourage bins that are almost big enough.\n    near_miss_penalty = np.where(\n        (safe_bins_remain_cap < item) & (safe_bins_remain_cap > item * 0.75),  # Tune 0.75\n        -10,  # Significant penalty\n        0\n    )\n\n    # 5. Adaptive Weighting based on Item Size and Available Capacity\n    avg_capacity = np.mean(bins_remain_cap[valid_bins]) if np.any(valid_bins) else 1e-9\n    item_size_ratio = np.clip(item / (avg_capacity + 1e-9), 0.0, 1.0)\n    weight_newtonian = 1 - item_size_ratio\n    weight_capacity = item_size_ratio\n\n    # 6. Temperature-Based Stochastic Exploration (Simulated Annealing)\n    temperature = 0.1  # Adjust cooling schedule as needed\n    exploration_factor = temperature * np.exp(-item_size_ratio) # Reduce exploration as item size increase\n    random_noise = np.random.normal(0, exploration_factor, size=bins_remain_cap.shape)\n\n    # 7. Combine Priorities with Adaptive Weights\n    combined_priority = (\n        weight_newtonian * newtonian_priority +\n        weight_capacity * capacity_priority +\n        0.2 * utilization_priority +\n        near_miss_penalty + # Directly add penalty\n        random_noise # Add the noise\n    )\n\n    # 8. Handle Invalid Bins and NaN values\n    combined_priority = np.nan_to_num(combined_priority, neginf=-np.inf)\n    priorities = np.where(~valid_bins, -np.inf, combined_priority)\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    An enhanced priority function that incorporates adaptive weighting, temperature-based exploration,\n    a refined capacity ratio, and penalties for near-misses.\n    \"\"\"\n\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n\n    # 1. Capacity-Aware Newtonian Potential (with softened denominator)\n    potential = safe_bins_remain_cap / (np.abs(safe_bins_remain_cap - item) + 0.1)\n    newtonian_priority = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n\n    # 2. Refined Capacity Ratio: Emphasize bins slightly larger than the item.\n    capacity_ratio = safe_bins_remain_cap / (item + 1e-9)\n    capacity_priority = np.where(\n        safe_bins_remain_cap >= item,\n        np.exp(-(capacity_ratio - 1)**2 / 0.5),  # Gaussian-like preference around ratio=1\n        -np.inf\n    )\n\n    # 3. Bin Utilization (Encourages filling partially full bins)\n    bin_utilization = 1 - (safe_bins_remain_cap / np.max(bins_remain_cap))\n    utilization_priority = np.where(safe_bins_remain_cap >= item, bin_utilization, -np.inf)\n\n    # 4. Near-Miss Penalty: Discourage bins that are almost big enough.\n    near_miss_penalty = np.where(\n        (safe_bins_remain_cap < item) & (safe_bins_remain_cap > item * 0.75),  # Tune 0.75\n        -10,  # Significant penalty\n        0\n    )\n\n    # 5. Adaptive Weighting based on Item Size and Available Capacity\n    avg_capacity = np.mean(bins_remain_cap[valid_bins]) if np.any(valid_bins) else 1e-9\n    item_size_ratio = np.clip(item / (avg_capacity + 1e-9), 0.0, 1.0)\n    weight_newtonian = 1 - item_size_ratio\n    weight_capacity = item_size_ratio\n\n    # 6. Temperature-Based Stochastic Exploration (Simulated Annealing)\n    temperature = 0.1  # Adjust cooling schedule as needed\n    exploration_factor = temperature * np.exp(-item_size_ratio) # Reduce exploration as item size increase\n    random_noise = np.random.normal(0, exploration_factor, size=bins_remain_cap.shape)\n\n    # 7. Combine Priorities with Adaptive Weights\n    combined_priority = (\n        weight_newtonian * newtonian_priority +\n        weight_capacity * capacity_priority +\n        0.2 * utilization_priority +\n        near_miss_penalty + # Directly add penalty\n        random_noise # Add the noise\n    )\n\n    # 8. Handle Invalid Bins and NaN values\n    combined_priority = np.nan_to_num(combined_priority, neginf=-np.inf)\n    priorities = np.where(~valid_bins, -np.inf, combined_priority)\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, ratio_min: float = 0.06147170424328355, ratio_max: float = 22.675894460204006, weight_clip_min: float = 0.049915106775598406, weight_clip_max: float = 0.9977039285217217, epsilon: float = 4.547998327897835e-09) -> np.ndarray:\n    \"\"\"Combines Newtonian and ratio-based approaches for bin packing priority.\"\"\"\n    # Newtonian component (with safety checks)\n    valid_bins = bins_remain_cap > 0\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n    potential = (safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item))\n    newton_priorities = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n    newton_priorities = np.nan_to_num(newton_priorities, neginf=-np.inf)\n    newton_priorities = np.where(~valid_bins, -np.inf, newton_priorities)\n\n    # Ratio component (dampened to avoid dominance)\n    ratios = item / bins_remain_cap\n    ratios = np.clip(ratios, ratio_min, ratio_max)  # Clamp for stability\n    log_ratios = np.log(ratios)\n    ratio_priorities = -log_ratios\n\n    # Weighted combination - adaptive weight based on item size relative to bin capacities\n    mean_cap = np.mean(bins_remain_cap) if bins_remain_cap.size > 0 else 0\n    weight = np.clip(item / (mean_cap + epsilon), weight_clip_min, weight_clip_max)  # Avoid division by zero\n\n    combined_priorities = (1 - weight) * newton_priorities + weight * ratio_priorities\n    return combined_priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Newtonian and ratio-based approaches for bin packing priority.\"\"\"\n    # Newtonian component (with safety checks)\n    valid_bins = bins_remain_cap > 0\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n    potential = (safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item))\n    newton_priorities = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n    newton_priorities = np.nan_to_num(newton_priorities, neginf=-np.inf)\n    newton_priorities = np.where(~valid_bins, -np.inf, newton_priorities)\n\n    # Ratio component (dampened to avoid dominance)\n    ratios = item / bins_remain_cap\n    ratios = np.clip(ratios, 0.01, 100)  # Clamp for stability\n    log_ratios = np.log(ratios)\n    ratio_priorities = -log_ratios\n\n    # Weighted combination - adaptive weight based on item size relative to bin capacities\n    mean_cap = np.mean(bins_remain_cap) if bins_remain_cap.size > 0 else 0\n    weight = np.clip(item / (mean_cap + 1e-9), 0, 1)  # Avoid division by zero\n\n    combined_priorities = (1 - weight) * newton_priorities + weight * ratio_priorities\n    return combined_priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Newtonian and ratio-based approaches for bin packing priority.\"\"\"\n    # Newtonian component (with safety checks)\n    valid_bins = bins_remain_cap > 0\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n    potential = (safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item))\n    newton_priorities = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n    newton_priorities = np.nan_to_num(newton_priorities, neginf=-np.inf)\n    newton_priorities = np.where(~valid_bins, -np.inf, newton_priorities)\n\n    # Ratio component (dampened to avoid dominance)\n    ratios = item / bins_remain_cap\n    ratios = np.clip(ratios, 0.01, 100)  # Clamp for stability\n    log_ratios = np.log(ratios)\n    ratio_priorities = -log_ratios\n\n    # Weighted combination - adaptive weight based on item size relative to bin capacities\n    mean_cap = np.mean(bins_remain_cap) if bins_remain_cap.size > 0 else 0\n    weight = np.clip(item / (mean_cap + 1e-9), 0, 1)  # Avoid division by zero\n\n    combined_priorities = (1 - weight) * newton_priorities + weight * ratio_priorities\n    return combined_priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Newtonian Optimization Heuristic: Inspired by gravitational potential,\n    prioritizes bins based on how \"close\" the item's size is to the bin's\n    remaining capacity, scaled by the remaining capacity itself.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative capacity\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n      return np.zeros_like(bins_remain_cap)\n\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n\n    # Calculate \"gravitational potential\" - higher potential = higher priority\n    potential = (safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item))\n\n    # Further emphasize bins with capacities closest to the item size but also penalize overflowing the bin\n    priorities = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n    priorities = np.nan_to_num(priorities, neginf=-np.inf) # Handle inf values when item >> safe_bins_remain_cap after masking\n    priorities = np.where(~valid_bins, -np.inf, priorities) # Ensure that bins that are initially invalid has -inf priorities\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, ratio_clip_lower: float = 0.009147337158257685, ratio_clip_upper: float = 2188.9067474017284, weight_clip_lower: float = -0.8025456592788214, weight_clip_upper: float = 0.42596515735241103, weight_epsilon: float = 5.620047065084735e-07) -> np.ndarray:\n    \"\"\"Combines Newtonian and ratio-based approaches with adaptive weighting.\"\"\"\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n[Heuristics 17th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, invalid_priority: float = -66.93412907195969) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Newtonian Optimization Heuristic: Inspired by gravitational potential,\n    prioritizes bins based on how \"close\" the item's size is to the bin's\n    remaining capacity, scaled by the remaining capacity itself.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        invalid_priority: Priority assigned to invalid bins (e.g., negative capacity).\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative capacity\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n      return np.zeros_like(bins_remain_cap)\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}