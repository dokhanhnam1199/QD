```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap >= item
    
    if not np.any(valid_bins):
        # No bin can fit the item, assign a very low priority to all bins.
        # This ideally should never happen because a new bin should always be opened
        # if no existing bin can accommodate the item. But, we add it for robustness.
        return priorities - np.inf 
    
    # First Fit Decreasing inspired heuristic.
    # Prioritize bins where the item fits best, but not too snugly
    # Aim for a bin that, after placement, has a remaining capacity
    # within a certain 'sweet spot' range to allow for subsequent smaller items.
    
    remaining_after_fit = bins_remain_cap - item
    
    # Define sweet spot (as proportion of bin size, or absolute value)
    sweet_spot_min = 0.1  # Lower bound: want some space left.  Proportion
    sweet_spot_max = 0.5  # Upper bound: don't want too much wasted space. Proportion

    # Calculate a score based on remaining capacity after placing the item.

    # Scale and shift the capacities to improve discriminability
    scaled_capacities = bins_remain_cap / np.max(bins_remain_cap)  # Scale to [0, 1]
    
    for i in range(len(bins_remain_cap)):
        if not valid_bins[i]:
            priorities[i] = -np.inf  # Extremely low priority for bins that can't fit
            continue
            
        if sweet_spot_min * bins_remain_cap[i] <= remaining_after_fit[i] <= sweet_spot_max * bins_remain_cap[i]:
            priorities[i] = 1 + (remaining_after_fit[i] / bins_remain_cap[i])  # High priority within sweet spot
        else:
            # Slightly penalize bins outside the sweet spot, but not too harshly.
            # Prefer to waste little space (if remaining_after_fit is small)

            space_waste = remaining_after_fit[i]
            if space_waste < 0:
                space_waste = 0

            priorities[i] = 0.5 / (1 + space_waste) # Add small value

    return priorities
```
