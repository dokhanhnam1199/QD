```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the path integral formulation and the idea of exploring multiple possibilities.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Filter out bins that cannot accommodate the item immediately to avoid division by zero or negative remainders
    eligible_bins_indices = np.where(bins_remain_cap >= item)[0]
    eligible_bins_cap = bins_remain_cap[eligible_bins_indices]

    if len(eligible_bins_cap) == 0:
        # No suitable bins - very low priority for all. In a real implementation, this would trigger opening a new bin
        return np.zeros_like(bins_remain_cap) - 1e9  # Large negative value

    # 1. Capacity Utilization: How well the item fits in the bin (higher is better, more utilization)
    capacity_utilization = item / eligible_bins_cap

    # 2. Remaining Space Penalty: Penalize bins with too much remaining space after the item is added.
    remaining_space = eligible_bins_cap - item
    space_penalty = np.exp(-remaining_space) # Exponential decay

    # 3. Combine these factors.
    priorities_eligible = capacity_utilization * space_penalty

    # Create a priority array of the same size as bins_remain_cap, initialized to a very low value.
    priorities = np.zeros_like(bins_remain_cap) - 1e9
    priorities[eligible_bins_indices] = priorities_eligible

    return priorities
```
