{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines Newtonian potential and ratio, adaptively weighted.\"\"\"\n    valid_bins = bins_remain_cap > 0\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n\n    # Newtonian component\n    potential = safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item)\n    newtonian_priority = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n    newtonian_priority = np.nan_to_num(newtonian_priority, neginf=-np.inf)\n\n    # Ratio component\n    ratio_priority = np.log(np.clip(safe_bins_remain_cap / item, 0.001, 1000))\n\n    # Adaptive weighting\n    weight = np.clip(item / (safe_bins_remain_cap + 1e-9), 0.0, 1.0)\n    combined_priority = weight * newtonian_priority + (1 - weight) * ratio_priority\n\n    priorities = np.where(~valid_bins, -np.inf, combined_priority)\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    A multifactorial and adaptive priority function for online bin packing.\n\n    Combines multiple heuristics with adaptive weighting based on bin fill level and item size.\n    Prioritizes bins that are neither too full nor too empty and encourages exploration of less utilized bins.\n    \"\"\"\n\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n    bin_size = np.max(bins_remain_cap) # Assuming all bins have the same max capacity\n\n    # Heuristic 1: Remaining Capacity Ratio (Focus: Utilization)\n    capacity_ratio = safe_bins_remain_cap / bin_size\n    capacity_priority = capacity_ratio  # Higher remaining capacity is initially better.\n\n    # Heuristic 2: Item Fit Score (Focus: Avoiding Fragmentation)\n    fit_score = np.exp(-np.abs(safe_bins_remain_cap - item) / (bin_size / 4)) # Gaussian-like preference for close fits. Adjusted standard deviation to bin_size /4\n    fit_priority = fit_score\n\n    # Heuristic 3: Bin Usage (Focus: Exploration)\n    usage_level = 1 - capacity_ratio\n    usage_priority = np.sqrt(usage_level) # Preferentially selects bins with higher utilization for exploration. Square root dampens the effect.\n\n    # Heuristic 4: Modified Newtonian (Focus: Packing Efficiency)\n    newtonian_component = safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item + 1e-9)\n    newtonian_priority = np.where(safe_bins_remain_cap >= item, newtonian_component, -np.inf)\n\n\n    # Adaptive Weighting based on item size\n    item_size_ratio = item / bin_size\n    weight_capacity = 0.2 if item_size_ratio < 0.3 else (0.1 if item_size_ratio < 0.6 else 0.05)  # Smaller items: prioritize filling almost empty bins.\n    weight_fit = 0.5 if item_size_ratio < 0.3 else (0.4 if item_size_ratio < 0.6 else 0.3 ) # Moderate item fit is more important for small items\n    weight_usage = 0.2 if item_size_ratio < 0.3 else (0.3 if item_size_ratio < 0.6 else 0.4)  # larger items focus on usage\n    weight_newtonian = 0.1 if item_size_ratio < 0.3 else (0.2 if item_size_ratio < 0.6 else 0.25) # packing efficiency\n\n    # Combined Priority\n    combined_priority = (\n        weight_capacity * capacity_priority +\n        weight_fit * fit_priority +\n        weight_usage * usage_priority +\n        weight_newtonian * newtonian_priority\n    )\n\n    combined_priority = np.nan_to_num(combined_priority, neginf=-np.inf)\n    priorities = np.where(~valid_bins, -np.inf, combined_priority)\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the first heuristic combines Newtonian potential and ratio-based approaches with adaptive weighting, while the last heuristic solely relies on log ratios. The first also handles edge cases, such as empty bins.\n\nComparing (1st) vs (11th), the first combines Newtonian and ratio-based approaches with adaptive weighting, while the 11th uses a Newtonian Optimization Heuristic. The first is more robust by including a ratio component and adaptive weighting, which is lacking in the latter.\n\nComparing (7th) vs (11th), both include a check for valid bins and a Newtonian-inspired potential calculation. However, the 7th heuristic incorporates a proportion filled metric and a small random factor, which the 11th lacks, leading to more exploration.\n\nComparing (9th) vs (10th), the 9th combines multiple heuristics (capacity ratio, fit score, bin usage, Newtonian) with adaptive weighting based on item size, while the 10th combines volume utilization, balance, and a large item penalty with fixed weights. The adaptive weighting in the 9th makes it more flexible.\n\nComparing (16th) vs (17th), only one has a default parameter. The 16th version includes an `invalid_priority` parameter which allows more explicit control over handling invalid bins, while the 17th does not have it. This added parameter and the flexibility to control it makes the 16th superior.\n\nOverall: The better heuristics combine multiple factors (Newtonian potential, ratios, capacity utilization, item fit), often with adaptive weighting based on item size or bin fill level. They also include robust error handling (e.g., division by zero, invalid bins) and sometimes a random factor for exploration. Simpler heuristics that rely on a single factor or lack adaptive weighting tend to perform worse. The use of `np.clip` to bound ratio values is another common feature in well-performing functions, which enhances stability.\n- \nOkay, let's redefine \"Current Self-Reflection\" to focus on impactful heuristic design and avoid common pitfalls. We'll aim for actionable advice based on a deeper understanding of the process.\n\nHere's a revised reflection designed to guide better heuristic development:\n\n*   **Keywords:** Contextual awareness, adaptive exploration, validation, iterative refinement.\n*   **Advice:** Instead of blindly combining factors, deeply analyze the *relationships* between them. Prioritize understanding the *why* behind each factor's influence. Design for iterative refinement and validation using diverse datasets.\n*   **Avoid:** Premature complexity, relying solely on sophisticated calculations without clear justification, neglecting the importance of validation and data diversity.\n*   **Explanation:** Effective heuristics are built on understanding the problem's landscape, not just throwing equations at it. Prioritize adaptability and rigorously test assumptions throughout the development process.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}