```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can fit the item with minimal waste,
    but also discourages filling bins too completely. It uses a combination
    of the remaining capacity and the waste if the item is placed in the bin.
    Einstein's touch: Consider relative space and "bending" capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    waste = bins_remain_cap - item
    can_fit = waste >= 0

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    #Give higher priority to bins which can fit the item.
    fit_indices = np.where(can_fit)[0]
    if len(fit_indices) > 0:
        waste_fit = waste[fit_indices]
        # Prioritize bins with minimal waste, but not zero waste (avoid overfilling)
        priorities[fit_indices] = np.where(waste_fit > 0, (item / (waste_fit + 0.00001)) * (1-(waste_fit/np.max(bins_remain_cap))), 0) #avoid division by zero and normalise by max bin size. Adding 1-term favors lower waste.
        # Add a slight bias to filling bins which are close to full before new bins
        priorities[fit_indices] += 0.1 * (1 - (bins_remain_cap[fit_indices] / np.max(bins_remain_cap)))


    #For bins that can't fit the item the priority remains zero. This implicitly enforces the "First Fit Decreasing" principle in a softened manner.

    return priorities
```
