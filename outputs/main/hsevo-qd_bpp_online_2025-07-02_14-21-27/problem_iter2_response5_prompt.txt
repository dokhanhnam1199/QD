{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Newtonian Optimization Heuristic: Inspired by gravitational potential,\n    prioritizes bins based on how \"close\" the item's size is to the bin's\n    remaining capacity, scaled by the remaining capacity itself.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative capacity\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n      return np.zeros_like(bins_remain_cap)\n\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)\n\n    # Calculate \"gravitational potential\" - higher potential = higher priority\n    potential = (safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item))\n\n    # Further emphasize bins with capacities closest to the item size but also penalize overflowing the bin\n    priorities = np.where(safe_bins_remain_cap >= item, potential, -np.inf)\n    priorities = np.nan_to_num(priorities, neginf=-np.inf) # Handle inf values when item >> safe_bins_remain_cap after masking\n    priorities = np.where(~valid_bins, -np.inf, priorities) # Ensure that bins that are initially invalid has -inf priorities\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first heuristic implements a Newtonian Optimization Heuristic, inspired by gravitational potential, while the 20th uses a simple ratio-based logarithmic approach. The Newtonian approach prioritizes bins based on the \"closeness\" of the item's size to the remaining capacity, scaled by the remaining capacity. It handles edge cases like division by zero and negative capacity, and penalizes overflowing. The ratio-based approach simply calculates the ratio of item size to remaining capacity, takes the logarithm, and negates it. This makes the Newtonian approach much more sophisticated and robust.\n\nComparing (2nd) vs (19th) ... (10th) vs (11th), we observe the same pattern; the first 10 heuristics are all identical and use Newtonian Optimization while the remaining heuristics use a simple ratio-based logarithmic approach. The difference lies primarily in the algorithmic approach.\n\nOverall: The \"Newtonian Optimization\" heuristic is much more robust due to handling edge cases and a more nuanced priority calculation. The ratio approach is simplistic and lacks sophistication.\n- \nOkay, here's a refined take on \"Current Self-Reflection\" for better heuristic design, focusing on actionable advice and avoiding pitfalls:\n\n*   **Keywords:** Adaptive, iterative, context-aware, validation.\n*   **Advice:** Design heuristics that adapt to the problem instance, learn from past iterations, and incorporate contextual information. Rigorously validate heuristic performance across diverse scenarios.\n*   **Avoid:** Over-reliance on single solutions, neglecting edge cases, static approaches unresponsive to changing conditions, and insufficient testing.\n*   **Explanation:** Effective heuristics are not \"one-size-fits-all.\" They evolve and adjust based on feedback and awareness of the specific problem characteristics. Continuous validation ensures robustness.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}