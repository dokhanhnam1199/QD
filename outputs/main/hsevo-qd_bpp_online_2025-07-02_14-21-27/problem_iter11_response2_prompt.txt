{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    An enhanced priority function for online bin packing that combines several strategies:\n    - Volume Utilization: Encourages filling bins as much as possible.\n    - Balance: Tries to equalize the remaining space in the bins.\n    - Penalty for large items: Reduce the chance that large items leave bins highly fragmented.\n    \"\"\"\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, -1)  # Use -1 for invalid bins\n\n    # 1. Volume Utilization Priority: Favor bins that will be filled well.\n    volume_utilization_priority = np.where(safe_bins_remain_cap >= item, item / safe_bins_remain_cap, -np.inf)\n\n    # 2. Remaining Space Balance Priority:  Penalize bins which after insertion would have small remaining space and large items.\n    balance_priority = np.where(safe_bins_remain_cap >= item, (safe_bins_remain_cap - item) / np.max(bins_remain_cap), -np.inf)\n\n    # 3. Large Item Penalty\n    large_item_penalty = np.where(item > np.mean(bins_remain_cap), -0.1, 0.0)  # Small penalty if item is large\n\n    # 4. Combine Priorities with weights\n\n    combined_priority = (\n        0.6 * volume_utilization_priority +\n        0.3 * (-balance_priority) +  # Invert to prefer smaller remaining space.\n        0.1 * large_item_penalty\n    )\n\n    priorities = np.where(~valid_bins, -np.inf, combined_priority)\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Newtonian Optimization Heuristic: Inspired by gravitational potential,\n    prioritizes bins based on how \"close\" the item's size is to the bin's\n    remaining capacity, scaled by the remaining capacity itself.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        invalid_priority: Priority assigned to invalid bins (e.g., negative capacity).\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative capacity\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n      return np.zeros_like(bins_remain_cap)\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the first heuristic combines Newtonian potential and ratio-based approaches with adaptive weighting, while the last heuristic solely relies on log ratios. The first also handles edge cases, such as empty bins.\n\nComparing (1st) vs (11th), the first combines Newtonian and ratio-based approaches with adaptive weighting, while the 11th uses a Newtonian Optimization Heuristic. The first is more robust by including a ratio component and adaptive weighting, which is lacking in the latter.\n\nComparing (7th) vs (11th), both include a check for valid bins and a Newtonian-inspired potential calculation. However, the 7th heuristic incorporates a proportion filled metric and a small random factor, which the 11th lacks, leading to more exploration.\n\nComparing (9th) vs (10th), the 9th combines multiple heuristics (capacity ratio, fit score, bin usage, Newtonian) with adaptive weighting based on item size, while the 10th combines volume utilization, balance, and a large item penalty with fixed weights. The adaptive weighting in the 9th makes it more flexible.\n\nComparing (16th) vs (17th), only one has a default parameter. The 16th version includes an `invalid_priority` parameter which allows more explicit control over handling invalid bins, while the 17th does not have it. This added parameter and the flexibility to control it makes the 16th superior.\n\nOverall: The better heuristics combine multiple factors (Newtonian potential, ratios, capacity utilization, item fit), often with adaptive weighting based on item size or bin fill level. They also include robust error handling (e.g., division by zero, invalid bins) and sometimes a random factor for exploration. Simpler heuristics that rely on a single factor or lack adaptive weighting tend to perform worse. The use of `np.clip` to bound ratio values is another common feature in well-performing functions, which enhances stability.\n- \nOkay, let's redefine \"Current Self-Reflection\" to focus on impactful heuristic design and avoid common pitfalls. We'll aim for actionable advice based on a deeper understanding of the process.\n\nHere's a revised reflection designed to guide better heuristic development:\n\n*   **Keywords:** Contextual awareness, adaptive exploration, validation, iterative refinement.\n*   **Advice:** Instead of blindly combining factors, deeply analyze the *relationships* between them. Prioritize understanding the *why* behind each factor's influence. Design for iterative refinement and validation using diverse datasets.\n*   **Avoid:** Premature complexity, relying solely on sophisticated calculations without clear justification, neglecting the importance of validation and data diversity.\n*   **Explanation:** Effective heuristics are built on understanding the problem's landscape, not just throwing equations at it. Prioritize adaptability and rigorously test assumptions throughout the development process.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}