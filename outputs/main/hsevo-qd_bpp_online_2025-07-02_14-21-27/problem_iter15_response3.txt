```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines multiple factors with adaptive weighting and stochastic exploration.
    Includes robust error handling and considers various edge cases.
    """

    valid_bins = bins_remain_cap > 0
    if not np.any(valid_bins):
        return np.zeros_like(bins_remain_cap)

    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)

    # 1. Newtonian Potential Component
    potential = safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item + 1e-9)
    newtonian_priority = np.where(safe_bins_remain_cap >= item, potential, -np.inf)

    # 2. Capacity Ratio Component
    capacity_ratio = np.clip(safe_bins_remain_cap / (item + 1e-9), 0.001, 1000)
    ratio_priority = np.log(capacity_ratio)

    # 3. Waste Minimization Component: Penalize bins with excessive remaining capacity
    waste_penalty = np.exp(-0.1 * safe_bins_remain_cap)  # Exponential decay
    waste_priority = -waste_penalty

    # 4. Balance Factor: Prefer bins with a "balanced" fill level relative to other bins
    mean_capacity = np.mean(safe_bins_remain_cap[valid_bins])
    balance_factor = np.abs(safe_bins_remain_cap - mean_capacity)
    balance_priority = -balance_factor  # Smaller difference is better

    # 5. Item Size Consideration: Prioritize bins that are a slightly larger than the item
    size_difference = safe_bins_remain_cap - item
    size_priority = -np.abs(size_difference)  # Closer is better

    # Adaptive Weighting based on item size, bin availability, and variance in capacities
    item_ratio = np.clip(item / (np.mean(bins_remain_cap[valid_bins]) + 1e-9), 0.0, 1.0)
    capacity_variance = np.var(bins_remain_cap[valid_bins]) + 1e-9

    # Adjust weights based on item size and capacity variance
    weight_newtonian = 0.4 * (1 - item_ratio)  # Larger items, less reliance on newtonian
    weight_ratio = 0.3 * item_ratio
    weight_waste = 0.1 * np.clip(capacity_variance, 0, 1)
    weight_balance = 0.1 * (1 - np.clip(capacity_variance, 0, 1))
    weight_size = 0.1

    # Combine Priorities with Adaptive Weights
    combined_priority = (
        weight_newtonian * newtonian_priority
        + weight_ratio * ratio_priority
        + weight_waste * waste_priority
        + weight_balance * balance_priority
        + weight_size * size_priority
    )

    # Stochastic Exploration: Add small random noise to priorities
    exploration_factor = 0.01  # Adjust for desired level of exploration
    noise = np.random.normal(0, exploration_factor, size=bins_remain_cap.shape)
    combined_priority += noise

    # Error Handling and Finalization
    combined_priority = np.nan_to_num(combined_priority, neginf=-np.inf)
    priorities = np.where(~valid_bins, -np.inf, combined_priority)

    return priorities
```
