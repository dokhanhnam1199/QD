```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Enhanced priority using volume, balance, and item size."""

    valid_bins = bins_remain_cap > 0
    if not np.any(valid_bins):
        return np.zeros_like(bins_remain_cap)

    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, -1)

    # Volume Utilization: Favor bins filled well.
    volume_utilization = np.where(safe_bins_remain_cap >= item, item / safe_bins_remain_cap, -np.inf)

    # Balance: Penalize bins with small remaining space after insertion.
    balance = np.where(safe_bins_remain_cap >= item, (safe_bins_remain_cap - item) / np.max(bins_remain_cap), -np.inf)

    # Large Item Penalty: Discourage large items fragmenting bins.
    large_item_penalty = np.where(item > np.mean(bins_remain_cap), -0.1, 0.0)

    # Newtonian Optimization Heuristic
    newtonian = np.where(safe_bins_remain_cap >= item, (item / safe_bins_remain_cap) / (np.abs(safe_bins_remain_cap - item) + 1e-9), -np.inf)

    # Adaptive Weighting
    weights = [0.4, 0.2, 0.1, 0.3] # volume, balance, large_item_penalty, newtonian

    combined_priority = (
        weights[0] * volume_utilization +
        weights[1] * (-balance) +
        weights[2] * large_item_penalty +
        weights[3] * newtonian
    )

    priorities = np.where(~valid_bins, -np.inf, combined_priority)
    
    return priorities
```
