```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A multifactorial and adaptive priority function for online bin packing.

    Combines multiple heuristics with adaptive weighting based on bin fill level and item size.
    Prioritizes bins that are neither too full nor too empty and encourages exploration of less utilized bins.
    """

    valid_bins = bins_remain_cap > 0
    if not np.any(valid_bins):
        return np.zeros_like(bins_remain_cap)

    safe_bins_remain_cap = np.where(valid_bins, bins_remain_cap, np.inf)
    bin_size = np.max(bins_remain_cap) # Assuming all bins have the same max capacity

    # Heuristic 1: Remaining Capacity Ratio (Focus: Utilization)
    capacity_ratio = safe_bins_remain_cap / bin_size
    capacity_priority = capacity_ratio  # Higher remaining capacity is initially better.

    # Heuristic 2: Item Fit Score (Focus: Avoiding Fragmentation)
    fit_score = np.exp(-np.abs(safe_bins_remain_cap - item) / (bin_size / 4)) # Gaussian-like preference for close fits. Adjusted standard deviation to bin_size /4
    fit_priority = fit_score

    # Heuristic 3: Bin Usage (Focus: Exploration)
    usage_level = 1 - capacity_ratio
    usage_priority = np.sqrt(usage_level) # Preferentially selects bins with higher utilization for exploration. Square root dampens the effect.

    # Heuristic 4: Modified Newtonian (Focus: Packing Efficiency)
    newtonian_component = safe_bins_remain_cap / np.abs(safe_bins_remain_cap - item + 1e-9)
    newtonian_priority = np.where(safe_bins_remain_cap >= item, newtonian_component, -np.inf)


    # Adaptive Weighting based on item size
    item_size_ratio = item / bin_size
    weight_capacity = 0.2 if item_size_ratio < 0.3 else (0.1 if item_size_ratio < 0.6 else 0.05)  # Smaller items: prioritize filling almost empty bins.
    weight_fit = 0.5 if item_size_ratio < 0.3 else (0.4 if item_size_ratio < 0.6 else 0.3 ) # Moderate item fit is more important for small items
    weight_usage = 0.2 if item_size_ratio < 0.3 else (0.3 if item_size_ratio < 0.6 else 0.4)  # larger items focus on usage
    weight_newtonian = 0.1 if item_size_ratio < 0.3 else (0.2 if item_size_ratio < 0.6 else 0.25) # packing efficiency

    # Combined Priority
    combined_priority = (
        weight_capacity * capacity_priority +
        weight_fit * fit_priority +
        weight_usage * usage_priority +
        weight_newtonian * newtonian_priority
    )

    combined_priority = np.nan_to_num(combined_priority, neginf=-np.inf)
    priorities = np.where(~valid_bins, -np.inf, combined_priority)

    return priorities
```
