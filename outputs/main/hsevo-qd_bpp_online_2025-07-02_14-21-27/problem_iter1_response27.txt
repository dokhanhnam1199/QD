```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version combines several heuristics:
    1.  Best Fit heuristic: Prioritizes bins with smallest remaining capacity that can still fit the item.
    2.  First Fit Decreasing influence: Bins checked earlier get a small priority boost.
    3.  Capacity Cushioning: Introduce a small cushioning effect to avoid filling bins completely.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap >= item
    
    if not np.any(valid_bins):
        return priorities  # No valid bins, all priorities remain zero

    # Best Fit component (negative difference between remaining capacity and item size)
    diffs = bins_remain_cap - item
    priorities[valid_bins] = -diffs[valid_bins]

    # Capacity Cushioning: Reduces priority as bins approach full capacity.
    # Avoids filling bins completely and leaving only very small items that might be packed better in new bins
    fullness_ratios = (bins_remain_cap - item) / bins_remain_cap
    priorities[valid_bins] += 0.1*fullness_ratios[valid_bins]  # Adjust weight (0.1) as needed
    
    #Small bin preference when capacities are close to the item size
    near_fit = np.isclose(bins_remain_cap, item, rtol=0, atol=0.01) & valid_bins #consider sizes similar if they are within .01 of each other
    priorities[near_fit] +=0.2

    # First Fit Decreasing influence: gives a very slight advantage to bins appearing earlier.
    # Essential for breaking ties in the Best Fit score, and avoiding constant rearrangement of bins.
    priorities += np.linspace(0.01, 0, len(bins_remain_cap))
    
    return priorities
```
