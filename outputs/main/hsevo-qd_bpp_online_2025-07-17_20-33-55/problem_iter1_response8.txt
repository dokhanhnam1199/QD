```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This version prioritizes bins that can fit the item reasonably well,
    but also considers the amount of wasted space if the item is placed.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Give bins that can fit the item a base priority
    can_fit = bins_remain_cap >= item
    priorities[can_fit] = 1.0

    # Adjust priority based on how well the item fits
    remaining_space = bins_remain_cap - item
    fit_ratio = item / bins_remain_cap  # ratio of item size to bin capacity

    # Higher priority if the item utilizes a larger proportion of the bin
    # Also penalize bins that will have too much wasted space, say 10% capacity left.
    small_waste = remaining_space / bins_remain_cap < 0.1
    priorities[can_fit & small_waste] += fit_ratio[can_fit & small_waste]

    priorities[can_fit & ~small_waste] += 0.5 * fit_ratio[can_fit & ~small_waste]

    # Significantly penalize bins where the item doesn't fit
    priorities[~can_fit] = -1000.0 # Ensure these bins are not considered unless no other option

    return priorities
```
