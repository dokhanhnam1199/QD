```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, waste_penalty_weight: float = 0.2013748833676067,
                fullness_bonus_weight: float = 0.3, item_size_weight: float = 0.1,
                noise_level: float = 1e-9, capacity_threshold: float = 0.9) -> np.ndarray:
    """
    Returns priority scores for adding an item to each bin, considering multiple factors
    and using a more dynamic approach.

    Args:
        item: Size of the item to be added.
        bins_remain_cap: Remaining capacity of each bin.
        waste_penalty_weight: Weight for the small waste penalty.
        fullness_bonus_weight: Weight for the fullness bonus.
        item_size_weight: Weight for prioritizing bins closer to item size.
        noise_level: Magnitude of random noise.
        capacity_threshold: Bins with remaining capacity above this fraction are penalized.

    Returns:
        Array of priority scores for each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Infeasibility Check
    infeasible_bins = bins_remain_cap < item
    priorities[infeasible_bins] = -np.inf

    # 2. Waste Calculation and Normalization
    waste = bins_remain_cap - item
    waste[infeasible_bins] = np.inf

    normalized_waste_item = waste / item
    normalized_waste_bin = waste / bins_remain_cap

    # 3. Small Waste Penalty
    small_waste_penalty = np.exp(-normalized_waste_item)

    # 4. Fill Ratio Reward
    fill_ratio = item / bins_remain_cap

    # 5. Item Size Matching: Reward bins where the remaining capacity is close to item size
    item_size_diff = np.abs(bins_remain_cap - item)
    normalized_item_size_diff = 1.0 / (1.0 + item_size_diff)  # Avoid division by zero
    item_size_priority = normalized_item_size_diff

    # 6. Large capacity penalty. Penalize bins that have large capacity left unused
    large_capacity_penalty = np.where(bins_remain_cap / np.max(bins_remain_cap) > capacity_threshold, 0.5, 0)

    # 7. Combine Factors with Weights
    priorities[~infeasible_bins] = (
            fill_ratio[~infeasible_bins]
            - waste_penalty_weight * small_waste_penalty[~infeasible_bins]
            + fullness_bonus_weight * (1 - normalized_waste_bin[~infeasible_bins])
            + item_size_weight * item_size_priority[~infeasible_bins]
            - large_capacity_penalty[~infeasible_bins]
    )

    # 8. Add Noise
    priorities += np.random.rand(len(bins_remain_cap)) * noise_level

    return priorities
```
