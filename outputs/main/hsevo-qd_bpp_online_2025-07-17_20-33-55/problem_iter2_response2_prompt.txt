{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A bin is feasible only if its remaining capacity is greater than or equal to the item size.\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No feasible bins, assign very low priority to all bins. It practically means open a new bin\n        return priorities - 1e9  # or -np.inf, ensuring it's the lowest. Avoid np.inf for numerical stability\n\n    # 1. Prioritize bins with a capacity close to the item size (minimize wasted space)\n    waste = bins_remain_cap - item\n    priorities[feasible_bins] = -np.abs(waste[feasible_bins])  # Negate waste to make smaller waste higher priority\n\n    # 2. Slightly prefer bins that are fuller (minimize the creation of almost-empty bins). A small perturbation.\n    priorities[feasible_bins] += 0.1 * (1 - bins_remain_cap[feasible_bins] / np.max(bins_remain_cap))  # Bias towards using less full bins less.\n\n    # 3. Add large negative values to infeasible bins.\n    priorities[~feasible_bins] = -1e8 #make these impossible if there are feasible options.\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    A high priority indicates a bin is preferred.\n\n    This version prioritizes bins that can accommodate the item with minimal wasted space,\n    but also penalizes near-full bins that would be a poor choice for future items.\n    It also adds a small random element to break ties and encourage exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n        return priorities  # No bin can hold the item\n\n    # Calculate wasted space if the item is placed in the bin\n    wasted_space = bins_remain_cap - item\n\n    # Prioritize bins based on minimal wasted space (higher is better)\n    space_priority = np.zeros_like(bins_remain_cap, dtype=float)\n    space_priority[eligible_bins] = -np.abs(wasted_space[eligible_bins])  # Negative since we want to minimize wasted space\n\n\n    # Penalize near-full bins to avoid fragmentation (lower is worse)\n    fullness_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    fullness_penalty[bins_remain_cap < 1.1 * item] = -10  # Significantly penalize near full\n\n    # Reward bins that are nearly full, but *can* still fit the current item.\n    # Encourage consolidation. Note: This can be improved.\n    consolidation_bonus = np.zeros_like(bins_remain_cap, dtype=float)\n    consolidation_bonus[eligible_bins & (bins_remain_cap < 1.2 * item)] = 5\n\n    # Add a small random factor to break ties and encourage exploration\n    random_factor = np.random.rand(len(bins_remain_cap)) * 0.1\n\n    # Combine all factors to calculate the final priority\n    priorities = space_priority + fullness_penalty + consolidation_bonus + random_factor\n\n    # Set priority of bins that *cannot* hold the item to a very low value\n    priorities[~eligible_bins] = -np.inf  # ensures these bins are never selected.\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first one uses multiple criteria like \"almost full\", \"low waste\", and \"capacity difference\", while the last one only focuses on remaining space ratio. The first also uses larger absolute priority values (1000, 500, 100) to allow clear distinctions between bins, where the last uses ratio values.\n\nComparing (2nd) vs (19th), the second uses advanced techniques such as high priority to almost-full bins, lower priority to bins with low waste and priority to bins with capacity closest to item size while the 19th one uses log ratio\n\nComparing (3rd) vs (18th), the third one considers waste minimization, fuller bins, and penalizes infeasible bins and the 18th one uses log ratio\n\nComparing (4th) vs (17th), the fourth one inspired by \"First-Fit Decreasing\" and \"Best-Fit Decreasing\" and considers waste while the 17th one uses log ratio\n\nComparing (5th) vs (16th), the fifth one considers waste minimization, fuller bins, and penalizes infeasible bins, while the sixteenth one penalizes small bin, gives score based on \"snugness\" and also remaining capacities\n\nComparing (second worst) vs (worst), we see the second worst uses logarithmic ratios directly as priorities, while the worst only focuses on remaining space ratio. The second worst also has unused imports, which suggests potentially incomplete or abandoned features.\nComparing (1st) vs (2nd), they are identical, implying redundancy. Comparing (3rd) vs (4th), we see the third heuristic tries to avoid creating almost empty bins (minimizes waste), while the fourth uses a combination of the First-Fit Decreasing and Best-Fit Decreasing approaches.\nComparing (second worst) vs (worst), both are relatively simplistic, calculating ratios and using them as or to derive priorities. But the latter one is inferior.\nOverall:\n\nThe better heuristics use a combination of multiple factors such as waste, fill ratio, and penalties for near-full or infeasible bins. They incorporate more complex logic and scaling to differentiate between bins effectively. They are also more explicitly designed with inspiration from known bin packing strategies such as First-Fit and Best-Fit Decreasing. Simplistic approaches that focus on a single metric or lack scaling tend to perform worse.\nAlso, the heuristics with more clear and well-defined priorities that leverage constant values tend to do better. Avoid using a single ratio.\n- \nOkay, here's a redefinition of \"Current Self-Reflection\" designed to guide the creation of better heuristics, while actively avoiding pitfalls of ineffective reflection, and focusing on actionable advice:\n\n*   **Keywords:** Multi-objective, penalty-based, priority-driven, algorithm-inspired, code simplification.\n*   **Advice:** Design heuristics that balance competing objectives (waste, fill ratio, etc.) using weighted penalties reflecting their importance. Prioritize key decision factors through scaling and ordering.\n*   **Avoid:** Over-reliance on single metrics, neglecting established algorithms, and code redundancy.\n*   **Explanation:** Heuristics should be nuanced, mimicking successful algorithms, while penalizing undesirable states based on a priority order, all while striving for simplicity and efficiency in code.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}