{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version introduces adaptive elements:\n    - `aggressive_fill`: If True, prioritizes filling bins closer to full when sufficient capacity remains.\n    - `capacity_threshold`: If bins have low remaining capacity, focus on filling them completely.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        target_relative_residual: Ideal relative residual capacity after placing item.\n        random_priority_scale: Scale of random constant added to priorities.\n        aggressive_fill: Whether to prioritize bins that are close to full.\n        capacity_threshold: Threshold below which filling a bin takes highest priority.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # 2. Prioritize bins with very low capacity to encourage completion.\n    low_capacity_bins = bins_remain_cap < capacity_threshold\n    if np.any(low_capacity_bins):\n        priorities[low_capacity_bins] = 10  # High priority to fill these.\n\n    # 3. Maximize bin utilization: Prefer bins where the item fills a large portion\n    # of the remaining capacity, but not too large that it creates near-empty bins\n    # with the next item.\n    \n    # Fill ratio: item size / remaining capacity. Higher is better, but should be < 1.\n    fill_ratios = item / bins_remain_cap\n    \n    # Residual capacity after placing item\n    residual_capacity = bins_remain_cap - item\n    \n    # Relative residual capacity compared to item size. We want it large enough\n    # that we will likely fill it with some other item.\n    relative_residual = residual_capacity / item\n\n    # Score based on fill ratio, penalized if near-full or too empty after insertion.\n    # Scale by 1 / (1+abs(relative_residual-target)), where target = ideal value (say, 0.5 or 1)\n    priorities[~infeasible_bins & ~low_capacity_bins] = fill_ratios[~infeasible_bins & ~low_capacity_bins] / (1 + np.abs(relative_residual[~infeasible_bins & ~low_capacity_bins] - target_relative_residual))\n\n    # 4. Aggressive Fill: Give a boost to bins that are already relatively full\n    #    This encourages using partially filled bins over empty ones (when applicable)\n    if aggressive_fill:\n        fullness = 1 - (bins_remain_cap / np.max(bins_remain_cap))  # Normalize to bin size.\n        priorities[~infeasible_bins & ~low_capacity_bins] += fullness[~infeasible_bins & ~low_capacity_bins] * 0.5\n\n    # Add small constant to avoid identical priorities and encourage some differentiation.\n    priorities += np.random.rand(len(bins_remain_cap)) * random_priority_scale\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # 2.  First-Fit Decreasing inspired: Prioritize bins that can accommodate the item\n    #     with minimal waste.  Avoid creating very small remaining spaces if possible.\n\n    # Waste: Remaining capacity after placing the item.\n    waste = bins_remain_cap - item\n    waste[infeasible_bins] = np.inf  # Ensure infeasible bins are penalized\n\n    # Normalized Waste: Waste relative to the item size and bin size.\n    normalized_waste_item = waste / item\n    normalized_waste_bin = waste / bins_remain_cap\n\n    # Penalty for too small waste (encourages filling bins reasonably)\n    small_waste_penalty = np.exp(-normalized_waste_item)  # Exponential penalty for small waste\n\n    # Reward for filling the bin well.  A higher fill ratio is generally better.\n    fill_ratio = item / bins_remain_cap\n    fill_reward = fill_ratio\n\n    # Combine the factors: Prioritize based on fill ratio, penalized by small waste\n    priorities[~infeasible_bins] = fill_reward[~infeasible_bins] - 0.5 * small_waste_penalty[~infeasible_bins]\n\n    # Bonus:  Slightly prioritize bins closer to full if other factors are equal.\n    # This helps close out bins more quickly. Only apply if not infeasible.\n    priorities[~infeasible_bins] += 0.1 * (1 - normalized_waste_bin[~infeasible_bins])\n        \n    # Add small constant to avoid identical priorities and encourage some differentiation.\n    priorities += np.random.rand(len(bins_remain_cap)) * 1e-9\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic prioritizes feasibility, manages waste (penalizing small waste and rewarding fullness), and adds noise for differentiation, while the worst simply uses the negative log of the fill ratio. (2nd) vs (19th) is similar to (1st) vs (20th). (3rd) vs (18th) is similar to (1st) vs (20th). Comparing (1st) vs (2nd), we see the best heuristic incorporates explicit waste and fullness considerations with tunable weights, while the second focuses on a target relative residual capacity. (3rd) vs (4th) are identical. Comparing (second worst) vs (worst), we see the second worst includes the standard imports. Overall: The better heuristics incorporate more factors (feasibility, fill ratio, waste management, fullness), often with tunable parameters, and add a small amount of noise to break ties. Simpler heuristics rely primarily on fill ratio and lack specific mechanisms to handle waste or prioritize bin completion. Adaptive bonuses and capacity thresholds help improve performance.\n- \nOkay, I understand. Let's redefine \"Current Self-Reflection\" focusing on actionable insights for designing better bin packing heuristics, while avoiding the pitfalls of \"Ineffective Self-Reflection\" (which seem to be high-level, generic suggestions). We want *specific* advice that leads to *concrete* design improvements.\n\nHere's the refined approach:\n\n*   **Keywords:** Multi-criteria optimization, dynamic weighting, adaptive parameters, instance-specific tuning, component-wise analysis, performance profiling, iterative refinement, trade-off exploration.\n\n*   **Advice:** Instead of simply *considering* multiple factors, identify *specific, quantifiable metrics* for each factor (e.g., waste as a percentage, fill as a ratio, feasibility as a penalty score for constraint violations). Focus on designing mechanisms to dynamically *learn and adjust* the weights assigned to these metrics *during runtime*, possibly using techniques like reinforcement learning or online optimization. Implement and test individual heuristic components separately, then in combination.\n\n*   **Avoid:** General statements like \"consider multiple factors\" or \"fine-tune parameters.\" Avoid vague suggestions and focus on quantifiable metrics. Stay away from hardcoded parameters and the over-reliance on established algorithms without critical adaptation. Also, avoid focusing on \"fragmentation\" as a primary factor. Instead, it should naturally be tackled in conjunction with other factors.\n\n*   **Explanation:** The goal is to move from abstract considerations to concrete implementation strategies. Dynamic weighting allows adaptation to problem instance characteristics. Component-wise analysis helps isolate the impact of different heuristic elements. Iterative refinement allows for continuous improvement based on empirical results. Prioritizing quantifiable metrics enables systematic evaluation and comparison of different heuristic designs. Essentially, we should be aiming to build heuristics that *learn* and *adapt* to the specific problem instance they are solving.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}