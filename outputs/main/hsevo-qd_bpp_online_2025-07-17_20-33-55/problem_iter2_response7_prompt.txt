{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by gravitational potential and energy minimization.\n    A bin is more attractive (higher priority) if:\n    1. It can accommodate the item.\n    2. The item is a 'significant' portion of the bin's capacity (efficiency).\n    3. We avoid leaving bins only slightly filled (stability).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter out bins that cannot accommodate the item.\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n        #If no bins fit, prioritize bins with smallest remaining capacity to hopefully finish those bins first\n        priorities = -bins_remain_cap\n        return priorities\n\n    # Efficiency: Item size as a fraction of bin capacity.\n    efficiency = item / bins_remain_cap\n    efficiency[~eligible_bins] = 0  # Zero out ineligible bins\n\n    # Stability: Penalty for leaving too much space after adding the item.\n    remaining_space = bins_remain_cap - item\n    stability = np.exp(-remaining_space) # Exponential decay for penalty\n    stability[~eligible_bins] = 0\n\n    # Combined priority: Efficiency balanced with stability, only for eligible bins\n    priorities[eligible_bins] = efficiency[eligible_bins] * stability[eligible_bins]\n\n    #Further refine by slightly preferring nearly-full bins if any are available\n    nearly_full = (remaining_space > 0) & (remaining_space < 0.1 * bins_remain_cap)\n    priorities[nearly_full] += 0.5 # small preference to nearly-full\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first one uses multiple criteria like \"almost full\", \"low waste\", and \"capacity difference\", while the last one only focuses on remaining space ratio. The first also uses larger absolute priority values (1000, 500, 100) to allow clear distinctions between bins, where the last uses ratio values.\n\nComparing (2nd) vs (19th), the second uses advanced techniques such as high priority to almost-full bins, lower priority to bins with low waste and priority to bins with capacity closest to item size while the 19th one uses log ratio\n\nComparing (3rd) vs (18th), the third one considers waste minimization, fuller bins, and penalizes infeasible bins and the 18th one uses log ratio\n\nComparing (4th) vs (17th), the fourth one inspired by \"First-Fit Decreasing\" and \"Best-Fit Decreasing\" and considers waste while the 17th one uses log ratio\n\nComparing (5th) vs (16th), the fifth one considers waste minimization, fuller bins, and penalizes infeasible bins, while the sixteenth one penalizes small bin, gives score based on \"snugness\" and also remaining capacities\n\nComparing (second worst) vs (worst), we see the second worst uses logarithmic ratios directly as priorities, while the worst only focuses on remaining space ratio. The second worst also has unused imports, which suggests potentially incomplete or abandoned features.\nComparing (1st) vs (2nd), they are identical, implying redundancy. Comparing (3rd) vs (4th), we see the third heuristic tries to avoid creating almost empty bins (minimizes waste), while the fourth uses a combination of the First-Fit Decreasing and Best-Fit Decreasing approaches.\nComparing (second worst) vs (worst), both are relatively simplistic, calculating ratios and using them as or to derive priorities. But the latter one is inferior.\nOverall:\n\nThe better heuristics use a combination of multiple factors such as waste, fill ratio, and penalties for near-full or infeasible bins. They incorporate more complex logic and scaling to differentiate between bins effectively. They are also more explicitly designed with inspiration from known bin packing strategies such as First-Fit and Best-Fit Decreasing. Simplistic approaches that focus on a single metric or lack scaling tend to perform worse.\nAlso, the heuristics with more clear and well-defined priorities that leverage constant values tend to do better. Avoid using a single ratio.\n- \nOkay, here's a redefinition of \"Current Self-Reflection\" designed to guide the creation of better heuristics, while actively avoiding pitfalls of ineffective reflection, and focusing on actionable advice:\n\n*   **Keywords:** Multi-objective, penalty-based, priority-driven, algorithm-inspired, code simplification.\n*   **Advice:** Design heuristics that balance competing objectives (waste, fill ratio, etc.) using weighted penalties reflecting their importance. Prioritize key decision factors through scaling and ordering.\n*   **Avoid:** Over-reliance on single metrics, neglecting established algorithms, and code redundancy.\n*   **Explanation:** Heuristics should be nuanced, mimicking successful algorithms, while penalizing undesirable states based on a priority order, all while striving for simplicity and efficiency in code.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}