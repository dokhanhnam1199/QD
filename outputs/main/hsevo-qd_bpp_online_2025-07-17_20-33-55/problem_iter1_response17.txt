```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by:
    1.  First-Fit Decreasing (FFD): Prefer bins with enough space for the item.
    2.  Best-Fit Decreasing (BFD): Among bins with enough space, prefer the one with smallest remaining space after packing the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Assign high priority to bins where the item fits
    fit_mask = bins_remain_cap >= item
    priorities[fit_mask] = 1.0  # Base priority

    # Prioritize based on the remaining space *after* fitting the item (Best-Fit Decreasing inspired)
    remaining_space = bins_remain_cap[fit_mask] - item
    # Invert the remaining space; small space becomes a higher number.
    # Adding a small constant to avoid division by zero or very large negative numbers
    inverted_remaining_space = 1.0 / (remaining_space + 0.00001)
    priorities[fit_mask] += inverted_remaining_space

    # Consider "waste". A bin that fits tightly should be preferred.
    waste_ratio = item / bins_remain_cap
    priorities[fit_mask] += (1.0 - np.abs(waste_ratio[fit_mask]- 1))  # penalizing waste if we fill more than what is required in the selected bin. We prefer the minimum waste from using a bin. This forces utilization as an approximation to solve the problem.

    # Scale to balance the priorities:
    if np.sum(priorities) > 0: #If all bins cannot accomodate, do nothing
        priorities = priorities / np.max(priorities)  # Normalize to 0-1 range
    #Small noise injection to create diversity

    noise = np.random.normal(0, 0.0001, len(priorities))
    priorities = priorities + noise

    return priorities
```
