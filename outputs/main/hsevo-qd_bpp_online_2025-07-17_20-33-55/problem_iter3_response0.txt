```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.
    infeasible_bins = bins_remain_cap < item
    priorities[infeasible_bins] = -np.inf

    # 2. Maximize bin utilization and minimize waste. We introduce penalties for bins
    #    that are either too full (leaving little space for future items) or have
    #    too much remaining space after placing the current item.

    # Fill ratio: item size / remaining capacity. Higher is generally better.
    fill_ratios = item / bins_remain_cap
    fill_ratios[infeasible_bins] = 0  # Avoid division by zero

    # Residual capacity after placing item.
    residual_capacity = bins_remain_cap - item

    # Define penalties based on residual capacity.
    # Penalty if residual capacity is too small (near-full bin).
    near_full_penalty = np.where(residual_capacity < 0.1, 10, 0)  # High penalty if almost full
    # Penalty if residual capacity is too large (wasteful bin).
    waste_penalty = np.where(residual_capacity > 0.5, residual_capacity, 0)  # Increased penalty for larger waste

    # Base priority on fill ratio, then subtract penalties. We want to maximize the fill
    # ratio while minimizing both near-full and waste penalties.  The penalties
    # are scaled to be more influential than small differences in fill ratio.
    priorities[~infeasible_bins] = fill_ratios[~infeasible_bins] - near_full_penalty[~infeasible_bins] - waste_penalty[~infeasible_bins]
    #Refine by adding penalty term
    mean_cap = np.mean(bins_remain_cap)
    cap_diff_penalty = np.abs(bins_remain_cap - mean_cap) / mean_cap
    priorities[~infeasible_bins] -= cap_diff_penalty[~infeasible_bins] * 0.1


    # Add small constant to avoid identical priorities and encourage some differentiation.
    priorities += np.random.rand(len(bins_remain_cap)) * 1e-9

    return priorities
```
