```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines fill ratio, adaptive waste target, and dynamic bonus."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    feasible_bins = bins_remain_cap >= item

    # 1. Infeasibility penalty
    priorities[~feasible_bins] = -np.inf

    # 2. Fill ratio with adaptive residual target
    fill_ratios = item / bins_remain_cap
    residual_capacity = bins_remain_cap - item
    
    # Dynamically adjust the target residual based on the item size
    target_relative_residual = 0.5 + 0.25 * (item / np.max(bins_remain_cap))  # Target adjusts based on item size
    relative_residual = residual_capacity / item
    priorities[feasible_bins] = fill_ratios[feasible_bins] / (1 + np.abs(relative_residual[feasible_bins] - target_relative_residual))

    # 3. Dynamic low waste bonus
    
    #Base the low_waste_threshold upon the item size
    low_waste_threshold = 0.05 + 0.05 * (item / np.max(bins_remain_cap))
    low_waste_bins = (bins_remain_cap - item) / np.max(bins_remain_cap) < low_waste_threshold
    #Adaptive bonus to low_waste_bins
    waste = bins_remain_cap - item
    normalized_waste_bin = waste / bins_remain_cap
    priorities[feasible_bins & low_waste_bins] += 0.1 * (1 - normalized_waste_bin[feasible_bins & low_waste_bins]) # Add bonus for low waste

    # 4. Fill level bonus
    fill_level_bonus = 0.05 * fill_ratios
    priorities[feasible_bins] += fill_level_bonus[feasible_bins]
    
    # 5. Small random number for tie-breaking
    priorities += np.random.rand(len(bins_remain_cap)) * 1e-9
    
    return priorities
```
