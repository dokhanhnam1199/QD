{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, waste_penalty_weight: float = 0.898487989707919,\n                fullness_bonus_weight: float = 0.2013748833676067, noise_level: float = 2.0819988765816894e-09) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        waste_penalty_weight: Weight of the small waste penalty.\n        fullness_bonus_weight: Weight of the bonus for bins closer to full.\n        noise_level: Magnitude of the random noise added to priorities.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # 2.  First-Fit Decreasing inspired: Prioritize bins that can accommodate the item\n    #     with minimal waste.  Avoid creating very small remaining spaces if possible.\n\n    # Waste: Remaining capacity after placing the item.\n    waste = bins_remain_cap - item\n    waste[infeasible_bins] = np.inf  # Ensure infeasible bins are penalized\n\n    # Normalized Waste: Waste relative to the item size and bin size.\n    normalized_waste_item = waste / item\n    normalized_waste_bin = waste / bins_remain_cap\n\n    # Penalty for too small waste (encourages filling bins reasonably)\n    small_waste_penalty = np.exp(-normalized_waste_item)  # Exponential penalty for small waste\n\n    # Reward for filling the bin well.  A higher fill ratio is generally better.\n    fill_ratio = item / bins_remain_cap\n    fill_reward = fill_ratio\n\n    # Combine the factors: Prioritize based on fill ratio, penalized by small waste\n    priorities[~infeasible_bins] = fill_reward[~infeasible_bins] - waste_penalty_weight * small_waste_penalty[~infeasible_bins]\n\n    # Bonus:  Slightly prioritize bins closer to full if other factors are equal.\n    # This helps close out bins more quickly. Only apply if not infeasible.\n    priorities[~infeasible_bins] += fullness_bonus_weight * (1 - normalized_waste_bin[~infeasible_bins])\n        \n    # Add small constant to avoid identical priorities and encourage some differentiation.\n    priorities += np.random.rand(len(bins_remain_cap)) * noise_level\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, waste_penalty_weight: float = 0.898487989707919,\n                fullness_bonus_weight: float = 0.2013748833676067, noise_level: float = 2.0819988765816894e-09) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        waste_penalty_weight: Weight of the small waste penalty.\n        fullness_bonus_weight: Weight of the bonus for bins closer to full.\n        noise_level: Magnitude of the random noise added to priorities.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # 2.  First-Fit Decreasing inspired: Prioritize bins that can accommodate the item\n    #     with minimal waste.  Avoid creating very small remaining spaces if possible.\n\n    # Waste: Remaining capacity after placing the item.\n    waste = bins_remain_cap - item\n    waste[infeasible_bins] = np.inf  # Ensure infeasible bins are penalized\n\n    # Normalized Waste: Waste relative to the item size and bin size.\n    normalized_waste_item = waste / item\n    normalized_waste_bin = waste / bins_remain_cap\n\n    # Penalty for too small waste (encourages filling bins reasonably)\n    small_waste_penalty = np.exp(-normalized_waste_item)  # Exponential penalty for small waste\n\n    # Reward for filling the bin well.  A higher fill ratio is generally better.\n    fill_ratio = item / bins_remain_cap\n    fill_reward = fill_ratio\n\n    # Combine the factors: Prioritize based on fill ratio, penalized by small waste\n    priorities[~infeasible_bins] = fill_reward[~infeasible_bins] - waste_penalty_weight * small_waste_penalty[~infeasible_bins]\n\n    # Bonus:  Slightly prioritize bins closer to full if other factors are equal.\n    # This helps close out bins more quickly. Only apply if not infeasible.\n    priorities[~infeasible_bins] += fullness_bonus_weight * (1 - normalized_waste_bin[~infeasible_bins])\n        \n    # Add small constant to avoid identical priorities and encourage some differentiation.\n    priorities += np.random.rand(len(bins_remain_cap)) * noise_level\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                target_relative_residual: float = 0.9647642401422942,\n                random_noise_scale: float = 3.6399893513957206e-09) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        target_relative_residual: Ideal relative residual capacity after placing the item.\n        random_noise_scale: Scale of the random noise added to priorities.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n    \n    # 2. Maximize bin utilization: Prefer bins where the item fills a large portion\n    # of the remaining capacity, but not too large that it creates near-empty bins\n    # with the next item.\n    \n    # Fill ratio: item size / remaining capacity. Higher is better, but should be < 1.\n    fill_ratios = item / bins_remain_cap\n    \n    # Residual capacity after placing item\n    residual_capacity = bins_remain_cap - item\n    \n    # Relative residual capacity compared to item size. We want it large enough\n    # that we will likely fill it with some other item.\n    relative_residual = residual_capacity / item\n\n    # Score based on fill ratio, penalized if near-full or too empty after insertion.\n    # Scale by 1 / (1+abs(relative_residual-target)), where target = ideal value (say, 0.5 or 1)\n    priorities[~infeasible_bins] = fill_ratios[~infeasible_bins] / (1 + np.abs(relative_residual[~infeasible_bins] - target_relative_residual))\n    \n    # Add small constant to avoid identical priorities and encourage some differentiation.\n    priorities += np.random.rand(len(bins_remain_cap)) * random_noise_scale\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                target_relative_residual: float = 0.9647642401422942,\n                random_noise_scale: float = 3.6399893513957206e-09) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        target_relative_residual: Ideal relative residual capacity after placing the item.\n        random_noise_scale: Scale of the random noise added to priorities.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n    \n    # 2. Maximize bin utilization: Prefer bins where the item fills a large portion\n    # of the remaining capacity, but not too large that it creates near-empty bins\n    # with the next item.\n    \n    # Fill ratio: item size / remaining capacity. Higher is better, but should be < 1.\n    fill_ratios = item / bins_remain_cap\n    \n    # Residual capacity after placing item\n    residual_capacity = bins_remain_cap - item\n    \n    # Relative residual capacity compared to item size. We want it large enough\n    # that we will likely fill it with some other item.\n    relative_residual = residual_capacity / item\n\n    # Score based on fill ratio, penalized if near-full or too empty after insertion.\n    # Scale by 1 / (1+abs(relative_residual-target)), where target = ideal value (say, 0.5 or 1)\n    priorities[~infeasible_bins] = fill_ratios[~infeasible_bins] / (1 + np.abs(relative_residual[~infeasible_bins] - target_relative_residual))\n    \n    # Add small constant to avoid identical priorities and encourage some differentiation.\n    priorities += np.random.rand(len(bins_remain_cap)) * random_noise_scale\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                target_relative_residual: float = 0.9647642401422942,\n                random_noise_scale: float = 3.6399893513957206e-09) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        target_relative_residual: Ideal relative residual capacity after placing the item.\n        random_noise_scale: Scale of the random noise added to priorities.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n    \n    # 2. Maximize bin utilization: Prefer bins where the item fills a large portion\n    # of the remaining capacity, but not too large that it creates near-empty bins\n    # with the next item.\n    \n    # Fill ratio: item size / remaining capacity. Higher is better, but should be < 1.\n    fill_ratios = item / bins_remain_cap\n    \n    # Residual capacity after placing item\n    residual_capacity = bins_remain_cap - item\n    \n    # Relative residual capacity compared to item size. We want it large enough\n    # that we will likely fill it with some other item.\n    relative_residual = residual_capacity / item\n\n    # Score based on fill ratio, penalized if near-full or too empty after insertion.\n    # Scale by 1 / (1+abs(relative_residual-target)), where target = ideal value (say, 0.5 or 1)\n    priorities[~infeasible_bins] = fill_ratios[~infeasible_bins] / (1 + np.abs(relative_residual[~infeasible_bins] - target_relative_residual))\n    \n    # Add small constant to avoid identical priorities and encourage some differentiation.\n    priorities += np.random.rand(len(bins_remain_cap)) * random_noise_scale\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, target_relative_residual: float = 0.9831522182052662, small_constant: float = 1.2189556856252112e-09) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        target_relative_residual: Ideal relative residual capacity after placing item.\n        small_constant: Small constant to avoid identical priorities.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n    \n    # 2. Maximize bin utilization: Prefer bins where the item fills a large portion\n    # of the remaining capacity, but not too large that it creates near-empty bins\n    # with the next item.\n    \n    # Fill ratio: item size / remaining capacity. Higher is better, but should be < 1.\n    fill_ratios = item / bins_remain_cap\n    \n    # Residual capacity after placing item\n    residual_capacity = bins_remain_cap - item\n    \n    # Relative residual capacity compared to item size. We want it large enough\n    # that we will likely fill it with some other item.\n    relative_residual = residual_capacity / item\n\n    # Score based on fill ratio, penalized if near-full or too empty after insertion.\n    # Scale by 1 / (1+abs(relative_residual-target)), where target = ideal value (say, 0.5 or 1)\n    priorities[~infeasible_bins] = fill_ratios[~infeasible_bins] / (1 + np.abs(relative_residual[~infeasible_bins] - target_relative_residual))\n    \n    # Add small constant to avoid identical priorities and encourage some differentiation.\n    priorities += np.random.rand(len(bins_remain_cap)) * small_constant\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                target_relative_residual: float = 0.96,\n                fullness_bonus_weight: float = 0.2,\n                noise_level: float = 1e-9) -> np.ndarray:\n    \"\"\"Combines fill ratio, target residual, fullness bonus, and noise.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    fill_ratios = item / bins_remain_cap\n    residual_capacity = bins_remain_cap - item\n    relative_residual = residual_capacity / item\n\n    priorities[~infeasible_bins] = fill_ratios[~infeasible_bins] / (1 + np.abs(relative_residual[~infeasible_bins] - target_relative_residual))\n\n    normalized_waste_bin = residual_capacity / bins_remain_cap\n    almost_full_bonus = np.exp(-20 * normalized_waste_bin)\n    priorities[~infeasible_bins] += fullness_bonus_weight * almost_full_bonus[~infeasible_bins]\n\n    priorities += np.random.rand(len(bins_remain_cap)) * noise_level\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                target_relative_residual: float = 0.96,\n                fullness_bonus_weight: float = 0.2,\n                noise_level: float = 1e-9) -> np.ndarray:\n    \"\"\"Combines fill ratio, target residual, fullness bonus, and noise.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    fill_ratios = item / bins_remain_cap\n    residual_capacity = bins_remain_cap - item\n    relative_residual = residual_capacity / item\n\n    priorities[~infeasible_bins] = fill_ratios[~infeasible_bins] / (1 + np.abs(relative_residual[~infeasible_bins] - target_relative_residual))\n\n    normalized_waste_bin = residual_capacity / bins_remain_cap\n    almost_full_bonus = np.exp(-20 * normalized_waste_bin)\n    priorities[~infeasible_bins] += fullness_bonus_weight * almost_full_bonus[~infeasible_bins]\n\n    priorities += np.random.rand(len(bins_remain_cap)) * noise_level\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n    \n    # 2. Maximize bin utilization: Prefer bins where the item fills a large portion\n    # of the remaining capacity, but not too large that it creates near-empty bins\n    # with the next item.\n    \n    # Fill ratio: item size / remaining capacity. Higher is better, but should be < 1.\n    fill_ratios = item / bins_remain_cap\n    \n    # Residual capacity after placing item\n    residual_capacity = bins_remain_cap - item\n    \n    # Relative residual capacity compared to item size. We want it large enough\n    # that we will likely fill it with some other item.\n    relative_residual = residual_capacity / item\n\n    # Score based on fill ratio, penalized if near-full or too empty after insertion.\n    # Scale by 1 / (1+abs(relative_residual-target)), where target = ideal value (say, 0.5 or 1)\n    target_relative_residual = 0.75\n    priorities[~infeasible_bins] = fill_ratios[~infeasible_bins] / (1 + np.abs(relative_residual[~infeasible_bins] - target_relative_residual))\n    \n    # Add small constant to avoid identical priorities and encourage some differentiation.\n    priorities += np.random.rand(len(bins_remain_cap)) * 1e-9\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill ratio, residual capacity target, and low waste.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    # 1. Infeasible penalty\n    priorities[~feasible_bins] = -np.inf\n\n    # 2. Fill ratio with residual target\n    fill_ratios = item / bins_remain_cap\n    residual_capacity = bins_remain_cap - item\n    target_relative_residual = 0.75\n    relative_residual = residual_capacity / item\n    priorities[feasible_bins] = fill_ratios[feasible_bins] / (1 + np.abs(relative_residual[feasible_bins] - target_relative_residual))\n\n    # 3. Low waste bonus\n    low_waste_threshold = 0.1\n    low_waste_bins = (bins_remain_cap - item) / np.max(bins_remain_cap) < low_waste_threshold\n    priorities[feasible_bins & low_waste_bins] += 0.1  # Add a bonus for low waste\n\n    # 4. Small random number for tie-breaking\n    priorities += np.random.rand(len(bins_remain_cap)) * 1e-9\n    \n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill ratio, residual capacity target, and low waste.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    # 1. Infeasible penalty\n    priorities[~feasible_bins] = -np.inf\n\n    # 2. Fill ratio with residual target\n    fill_ratios = item / bins_remain_cap\n    residual_capacity = bins_remain_cap - item\n    target_relative_residual = 0.75\n    relative_residual = residual_capacity / item\n    priorities[feasible_bins] = fill_ratios[feasible_bins] / (1 + np.abs(relative_residual[feasible_bins] - target_relative_residual))\n\n    # 3. Low waste bonus\n    low_waste_threshold = 0.1\n    low_waste_bins = (bins_remain_cap - item) / np.max(bins_remain_cap) < low_waste_threshold\n    priorities[feasible_bins & low_waste_bins] += 0.1  # Add a bonus for low waste\n\n    # 4. Small random number for tie-breaking\n    priorities += np.random.rand(len(bins_remain_cap)) * 1e-9\n    \n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill ratio, residual capacity target, and low waste.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    # 1. Infeasible penalty\n    priorities[~feasible_bins] = -np.inf\n\n    # 2. Fill ratio with residual target\n    fill_ratios = item / bins_remain_cap\n    residual_capacity = bins_remain_cap - item\n    target_relative_residual = 0.75\n    relative_residual = residual_capacity / item\n    priorities[feasible_bins] = fill_ratios[feasible_bins] / (1 + np.abs(relative_residual[feasible_bins] - target_relative_residual))\n\n    # 3. Low waste bonus\n    low_waste_threshold = 0.1\n    low_waste_bins = (bins_remain_cap - item) / np.max(bins_remain_cap) < low_waste_threshold\n    priorities[feasible_bins & low_waste_bins] += 0.1  # Add a bonus for low waste\n\n    # 4. Small random number for tie-breaking\n    priorities += np.random.rand(len(bins_remain_cap)) * 1e-9\n    \n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, target_relative_residual: float = 0.7266002280300371, low_waste_threshold: float = 0.0023973308483336564, fullness_bonus_weight: float = 0.07364669264928025, adaptive_bonus_scale: float = 0.34239041171043005, tie_breaking_noise: float = 6.734584657147387e-10) -> np.ndarray:\n    \"\"\"Combines fill ratio, adaptive waste bonus, and residual target.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    # 1. Infeasible penalty\n    priorities[~feasible_bins] = -np.inf\n\n    # 2. Fill ratio with residual target\n    fill_ratios = item / bins_remain_cap\n    residual_capacity = bins_remain_cap - item\n    relative_residual = residual_capacity / item\n    priorities[feasible_bins] = fill_ratios[feasible_bins] / (1 + np.abs(relative_residual[feasible_bins] - target_relative_residual))\n\n    # 3. Low waste bonus (adaptive)\n    waste = bins_remain_cap - item\n    normalized_waste_bin = waste / bins_remain_cap\n    low_waste_bins = normalized_waste_bin < low_waste_threshold\n    \n    # Adaptive bonus: Larger bonus when bins are closer to full.\n    bonus_scale = adaptive_bonus_scale * (1 - normalized_waste_bin)\n    priorities[feasible_bins & low_waste_bins] += bonus_scale[feasible_bins & low_waste_bins]\n\n    # 4. Fullness Bonus: Prioritize bins that are closer to being full.\n    priorities[feasible_bins] += fullness_bonus_weight * (1 - normalized_waste_bin[feasible_bins])\n\n    # 5. Small random number for tie-breaking\n    priorities += np.random.rand(len(bins_remain_cap)) * tie_breaking_noise\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, target_relative_residual: float = 0.75, low_waste_threshold: float = 0.1, small_constant: float = 1e-9) -> np.ndarray:\n    \"\"\"Combines fill ratio, residual capacity target, and low waste with adaptive bonus.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    # 1. Infeasible penalty\n    priorities[~feasible_bins] = -np.inf\n\n    # 2. Fill ratio with residual target\n    fill_ratios = item / bins_remain_cap\n    residual_capacity = bins_remain_cap - item\n    relative_residual = residual_capacity / item\n    priorities[feasible_bins] = fill_ratios[feasible_bins] / (1 + np.abs(relative_residual[feasible_bins] - target_relative_residual))\n\n    # 3. Low waste bonus, adaptively scaled\n    low_waste_amount = (bins_remain_cap[feasible_bins] - item) / np.max(bins_remain_cap)\n    low_waste_bins = low_waste_amount < low_waste_threshold\n    bonus_scale = np.clip(1 - (low_waste_amount[low_waste_bins] / low_waste_threshold), 0, 1)  # Scale bonus inversely to how close we are to the threshold\n    priorities[feasible_bins][low_waste_bins] += 0.1 * bonus_scale\n\n    # 4. Small random number for tie-breaking\n    priorities += np.random.rand(len(bins_remain_cap)) * small_constant\n    \n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best aspects of v0 and v1. Balances fill, waste, feasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    \n    #Almost Full Bins\n    almost_full_threshold = 0.95\n    almost_full_bins = (bins_remain_cap - item) / bins_remain_cap < (1-almost_full_threshold)\n    priorities[feasible_bins & almost_full_bins] = 1000\n    \n    #Low Waste Bins\n    low_waste_bins = (bins_remain_cap - item) / np.max(bins_remain_cap) < 0.1\n    priorities[feasible_bins & low_waste_bins] = 500\n\n    # Capacity Difference\n    capacity_diff = np.abs(bins_remain_cap - item)\n    priorities[feasible_bins] = 100 - (capacity_diff[feasible_bins] / np.max(bins_remain_cap)) * 50\n\n    # Non-empty nudge\n    non_empty_bins = bins_remain_cap < np.max(bins_remain_cap)\n    priorities[feasible_bins & non_empty_bins] += 5\n\n    # Infeasible penalty\n    priorities[~feasible_bins] = -1000\n    \n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, waste_penalty_weight: float = 0.2013748833676067, fullness_bonus_weight: float = 0.2013748833676067, noise_level: float = 2.0819988765816894e-09) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, improved version.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        waste_penalty_weight: Weight of the small waste penalty.\n        fullness_bonus_weight: Weight of the bonus for bins closer to full.\n        noise_level: Magnitude of the random noise added to priorities.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # Waste calculation\n    waste = bins_remain_cap - item\n    waste[infeasible_bins] = np.inf\n\n    # Fill Ratio Calculation\n    fill_ratio = item / bins_remain_cap\n    fill_ratio[infeasible_bins] = 0  # No fill if infeasible\n\n    # Normalized Waste: Waste relative to the item size. This is crucial.\n    normalized_waste_item = waste / item\n    normalized_waste_bin = waste / bins_remain_cap\n\n    # Small Waste Penalty (Revised): Stronger penalty for tiny waste.  Also, make it depend on bin size to some extent\n    small_waste_threshold = 0.1 * bins_remain_cap # Dynamic threshold proportional to bin size\n    small_waste_penalty = np.where(waste < small_waste_threshold, np.exp(5 * (waste - small_waste_threshold)/small_waste_threshold), 0.0)\n\n    # Fullness Bonus (Revised):  Reward higher fill ratios more aggressively.\n    fullness_bonus = fill_ratio**2  # Quadratic bonus for high fill ratios\n\n    # Reward for bins that will be completely filled after the addition of the item\n    perfect_fit = np.isclose(waste, 0)\n    priorities[perfect_fit] = np.inf  # Huge priority for perfect fits\n\n    # Combine factors with weights\n    priorities[~infeasible_bins] = (fill_ratio[~infeasible_bins] +\n                                     fullness_bonus_weight * fullness_bonus[~infeasible_bins] -\n                                     waste_penalty_weight * small_waste_penalty[~infeasible_bins])\n\n    # Add noise for tie-breaking\n    priorities += np.random.rand(len(bins_remain_cap)) * noise_level\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, waste_penalty_weight: float = 0.2013748833676067,\n                fullness_bonus_weight: float = 0.2013748833676067, noise_level: float = 2.0819988765816894e-09,\n                capacity_threshold: float = 0.9) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        waste_penalty_weight: Weight of the small waste penalty.\n        fullness_bonus_weight: Weight of the bonus for bins closer to full.\n        noise_level: Magnitude of the random noise added to priorities.\n        capacity_threshold: Threshold for considering a bin 'almost full'.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # 2.  First-Fit Decreasing inspired: Prioritize bins that can accommodate the item\n    #     with minimal waste.  Avoid creating very small remaining spaces if possible.\n\n    # Waste: Remaining capacity after placing the item.\n    waste = bins_remain_cap - item\n    waste[infeasible_bins] = np.inf  # Ensure infeasible bins are penalized\n\n    # Normalized Waste: Waste relative to the item size and bin size.\n    normalized_waste_item = waste / item\n    normalized_waste_bin = waste / bins_remain_cap\n\n    # Penalty for too small waste (encourages filling bins reasonably)\n    small_waste_penalty = np.exp(-normalized_waste_item)  # Exponential penalty for small waste\n\n    # Reward for filling the bin well.  A higher fill ratio is generally better.\n    fill_ratio = item / bins_remain_cap\n    fill_reward = fill_ratio\n\n    # Check if the bin will be close to full after adding the item\n    almost_full = (bins_remain_cap - item) / 1 < (1 - capacity_threshold) \n    \n    #Prioritize almost full bins\n    priorities[almost_full] += 1.0\n\n    # Combine the factors: Prioritize based on fill ratio, penalized by small waste\n    priorities[~infeasible_bins] += fill_reward[~infeasible_bins] - waste_penalty_weight * small_waste_penalty[~infeasible_bins]\n\n    # Bonus:  Slightly prioritize bins closer to full if other factors are equal.\n    # This helps close out bins more quickly. Only apply if not infeasible.\n    priorities[~infeasible_bins] += fullness_bonus_weight * (1 - normalized_waste_bin[~infeasible_bins])\n        \n    # Add small constant to avoid identical priorities and encourage some differentiation.\n    priorities += np.random.rand(len(bins_remain_cap)) * noise_level\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, waste_penalty_weight: float = 0.2013748833676067,\n                fullness_bonus_weight: float = 0.2013748833676067, noise_level: float = 2.0819988765816894e-09) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version includes adaptive weighting and a consideration for bin utilization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        waste_penalty_weight: Weight of the small waste penalty.\n        fullness_bonus_weight: Weight of the bonus for bins closer to full.\n        noise_level: Magnitude of the random noise added to priorities.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # 2. Waste Calculation\n    waste = bins_remain_cap - item\n    waste[infeasible_bins] = np.inf\n\n    # 3. Normalized Metrics\n    normalized_waste_item = waste / item\n    normalized_waste_bin = waste / bins_remain_cap\n    fill_ratio = item / bins_remain_cap\n\n    # 4. Penalty and Reward Components\n    small_waste_penalty = np.exp(-normalized_waste_item)\n    fill_reward = fill_ratio\n\n    # 5. Bin Utilization Consideration\n    bin_utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))  # Normalize remaining capacity\n\n    # 6. Adaptive Weighting (Dynamically adjust waste penalty based on bin utilization)\n    # High utilization bins are penalized more for small waste to encourage complete filling.\n    adaptive_waste_penalty_weight = waste_penalty_weight * (1 + bin_utilization)\n    # Limit adaptive weight growth\n    adaptive_waste_penalty_weight = np.clip(adaptive_waste_penalty_weight, 0, 2 * waste_penalty_weight)\n\n\n    # 7. Combined Priority\n    priorities[~infeasible_bins] = (\n        fill_reward[~infeasible_bins]\n        - adaptive_waste_penalty_weight[~infeasible_bins] * small_waste_penalty[~infeasible_bins]\n        + fullness_bonus_weight * (1 - normalized_waste_bin[~infeasible_bins])\n    )\n\n    # 8. Exploration Noise\n    priorities += np.random.rand(len(bins_remain_cap)) * noise_level\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, waste_penalty_weight: float = 0.2013748833676067,\n                fullness_bonus_weight: float = 0.2013748833676067, noise_level: float = 2.0819988765816894e-09) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        waste_penalty_weight: Weight of the small waste penalty.\n        fullness_bonus_weight: Weight of the bonus for bins closer to full.\n        noise_level: Magnitude of the random noise added to priorities.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # 2. Waste calculation and handling of infeasible bins\n    waste = bins_remain_cap - item\n    waste[infeasible_bins] = np.inf\n\n    # 3. Normalized waste based on item size and bin capacity\n    normalized_waste_item = waste / item\n    normalized_waste_bin = waste / bins_remain_cap\n\n    # 4. Small waste penalty: Exponential penalty, more sensitive.\n    small_waste_penalty = np.exp(-5 * normalized_waste_item) # Increase the exponent to penalize more\n\n    # 5. Fill ratio reward: Sigmoid function to reward high fill ratios more\n    fill_ratio = item / bins_remain_cap\n    fill_reward = 1 / (1 + np.exp(-10 * (fill_ratio - 0.8)))  # Sigmoid, centerd around 0.8\n\n    # 6. Combine factors: Adjusted weights for better balance\n    priorities[~infeasible_bins] = fill_reward[~infeasible_bins] - waste_penalty_weight * small_waste_penalty[~infeasible_bins]\n\n    # 7. Fullness bonus: Stronger bonus for almost-full bins\n    almost_full_bonus = np.exp(-20 * normalized_waste_bin) # Strong bonus when bin is nearly full\n    priorities[~infeasible_bins] += fullness_bonus_weight * almost_full_bonus[~infeasible_bins]\n\n    # 8. Introduce a bin-selection bias based on current bin utilization\n    bin_utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    utilization_bias = 0.01 * bin_utilization  # Small bias to prefer bins with more items already in them\n    priorities[~infeasible_bins] += utilization_bias[~infeasible_bins]\n\n    # 9. Noise\n    priorities += np.random.rand(len(bins_remain_cap)) * noise_level\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}