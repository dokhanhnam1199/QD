{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by:\n    1.  First-Fit Decreasing (FFD): Prefer bins with enough space for the item.\n    2.  Best-Fit Decreasing (BFD): Among bins with enough space, prefer the one with smallest remaining space after packing the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Assign high priority to bins where the item fits\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = 1.0  # Base priority\n\n    # Prioritize based on the remaining space *after* fitting the item (Best-Fit Decreasing inspired)\n    remaining_space = bins_remain_cap[fit_mask] - item\n    # Invert the remaining space; small space becomes a higher number.\n    # Adding a small constant to avoid division by zero or very large negative numbers\n    inverted_remaining_space = 1.0 / (remaining_space + 0.00001)\n    priorities[fit_mask] += inverted_remaining_space\n\n    # Consider \"waste\". A bin that fits tightly should be preferred.\n    waste_ratio = item / bins_remain_cap\n    priorities[fit_mask] += (1.0 - np.abs(waste_ratio[fit_mask]- 1))  # penalizing waste if we fill more than what is required in the selected bin. We prefer the minimum waste from using a bin. This forces utilization as an approximation to solve the problem.\n\n    # Scale to balance the priorities:\n    if np.sum(priorities) > 0: #If all bins cannot accomodate, do nothing\n        priorities = priorities / np.max(priorities)  # Normalize to 0-1 range\n    #Small noise injection to create diversity\n\n    noise = np.random.normal(0, 0.0001, len(priorities))\n    priorities = priorities + noise\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Uses a more sophisticated priority function considering:\n    1. Waste (remaining capacity after adding the item)\n    2. Fill Ratio (item size relative to remaining capacity)\n    3. Avoidance of tiny residuals that are hard to fill later.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item is placed in each bin\n    remaining_capacity = bins_remain_cap - item\n\n    # Initialize priority with a low value for bins that cannot fit the item\n    priorities = np.full(bins_remain_cap.shape, -np.inf)\n\n    # Identify bins where the item fits\n    valid_bins = remaining_capacity >= 0\n\n    if np.any(valid_bins):  # Ensure there's at least one valid bin.\n        # Calculate fill ratios for the valid bins\n        fill_ratios = item / bins_remain_cap[valid_bins]\n\n        # Calculate waste (remaining capacity) for valid bins\n        waste = remaining_capacity[valid_bins]\n\n        # Define scaling factor to penalize extremely small waste. Higher lambda yields to bins that are more fully filled (larger item/capacity ratios)\n        lambda_waste = 1.0 # Larger lambda gives emphasis on the waste function\n\n        # Define scaling factor to penalize low item/capacity fill ratios\n        lambda_fill = 1.0 # Larger lambda gives emphasis on the fill function\n\n        # A function to make small residuals undesirable - Hawking radiation of tiny residual\n        waste_score = -lambda_waste * np.exp(-waste)\n        fill_score = lambda_fill * fill_ratios # Favors higher fill ratio\n\n        priorities[valid_bins] = fill_score + waste_score\n\n        #Boost the score of bins nearly perfectly fitting the item\n        nearly_perfect = (waste < 0.05) & valid_bins #Tolerance is a small residual.\n        priorities[nearly_perfect] += 2*lambda_fill\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first one uses multiple criteria like \"almost full\", \"low waste\", and \"capacity difference\", while the last one only focuses on remaining space ratio. The first also uses larger absolute priority values (1000, 500, 100) to allow clear distinctions between bins, where the last uses ratio values.\n\nComparing (2nd) vs (19th), the second uses advanced techniques such as high priority to almost-full bins, lower priority to bins with low waste and priority to bins with capacity closest to item size while the 19th one uses log ratio\n\nComparing (3rd) vs (18th), the third one considers waste minimization, fuller bins, and penalizes infeasible bins and the 18th one uses log ratio\n\nComparing (4th) vs (17th), the fourth one inspired by \"First-Fit Decreasing\" and \"Best-Fit Decreasing\" and considers waste while the 17th one uses log ratio\n\nComparing (5th) vs (16th), the fifth one considers waste minimization, fuller bins, and penalizes infeasible bins, while the sixteenth one penalizes small bin, gives score based on \"snugness\" and also remaining capacities\n\nComparing (second worst) vs (worst), we see the second worst uses logarithmic ratios directly as priorities, while the worst only focuses on remaining space ratio. The second worst also has unused imports, which suggests potentially incomplete or abandoned features.\nComparing (1st) vs (2nd), they are identical, implying redundancy. Comparing (3rd) vs (4th), we see the third heuristic tries to avoid creating almost empty bins (minimizes waste), while the fourth uses a combination of the First-Fit Decreasing and Best-Fit Decreasing approaches.\nComparing (second worst) vs (worst), both are relatively simplistic, calculating ratios and using them as or to derive priorities. But the latter one is inferior.\nOverall:\n\nThe better heuristics use a combination of multiple factors such as waste, fill ratio, and penalties for near-full or infeasible bins. They incorporate more complex logic and scaling to differentiate between bins effectively. They are also more explicitly designed with inspiration from known bin packing strategies such as First-Fit and Best-Fit Decreasing. Simplistic approaches that focus on a single metric or lack scaling tend to perform worse.\nAlso, the heuristics with more clear and well-defined priorities that leverage constant values tend to do better. Avoid using a single ratio.\n- \nOkay, here's a redefinition of \"Current Self-Reflection\" designed to guide the creation of better heuristics, while actively avoiding pitfalls of ineffective reflection, and focusing on actionable advice:\n\n*   **Keywords:** Multi-objective, penalty-based, priority-driven, algorithm-inspired, code simplification.\n*   **Advice:** Design heuristics that balance competing objectives (waste, fill ratio, etc.) using weighted penalties reflecting their importance. Prioritize key decision factors through scaling and ordering.\n*   **Avoid:** Over-reliance on single metrics, neglecting established algorithms, and code redundancy.\n*   **Explanation:** Heuristics should be nuanced, mimicking successful algorithms, while penalizing undesirable states based on a priority order, all while striving for simplicity and efficiency in code.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}