```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version attempts to improve upon priority_v1 by incorporating several key changes:

    1.  **Rejection of near-full bins:** A harsher penalty is applied to bins that become nearly full after the item is placed. This discourages creating bins that are difficult to fill later.

    2.  **Encouraging balanced fill:** A bonus is given to bins that, after the item is placed, have a remaining capacity that is a desirable fraction of the bin's *original* capacity (implicitly assuming that all bins have the same original capacity, which is a reasonable assumption for BPP). This promotes creating bins with more uniform fill levels.

    3.  **Explicit Waste Penalty:** Directly penalizes bins based on the waste created if the item were placed into that bin.

    4.  **Code simplification and efficiency:** The calculations are streamlined for better performance.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.
    infeasible_bins = bins_remain_cap < item
    priorities[infeasible_bins] = -np.inf

    # Only consider feasible bins
    feasible_bins = ~infeasible_bins

    if np.any(feasible_bins):
        # 2. Fill Ratio: Maximize bin utilization.
        fill_ratios = item / bins_remain_cap[feasible_bins]

        # 3. Waste penalty: Penalize bins based on the amount of waste after insertion.  Scale waste by item size
        waste = bins_remain_cap[feasible_bins] - item
        waste_penalty = waste / item

        # 4. Near-full penalty:  Heavily penalize bins that become nearly full.
        nearly_full = (bins_remain_cap[feasible_bins] - item) < 0.1  # Remaining capacity < 0.1 (adjust as needed)
        near_full_penalty = np.where(nearly_full, -10, 0)  # Large penalty

        # 5. Balanced Fill Bonus: Reward bins that result in a remaining capacity
        #    that is a desirable fraction of the original capacity. We assume original capacity = 1 for simplicity.

        target_residual_ratio = 0.5
        residual_capacity = bins_remain_cap[feasible_bins] - item
        residual_ratio = residual_capacity  # Since original capacity is assumed to be 1.

        balanced_fill_bonus = -np.abs(residual_ratio - target_residual_ratio)

        # Combine all the metrics into a single priority score. The weights can be tuned.
        priorities[feasible_bins] = (
            fill_ratios
            - 0.1 * waste_penalty  # Reduce the impact of waste penalty
            + 0.5 * balanced_fill_bonus # Boost balanced fill reward
            + near_full_penalty  # Apply near-full penalty
        )


    # Add small constant to avoid identical priorities and encourage some differentiation.
    priorities += np.random.rand(len(bins_remain_cap)) * 1e-9

    return priorities
```
