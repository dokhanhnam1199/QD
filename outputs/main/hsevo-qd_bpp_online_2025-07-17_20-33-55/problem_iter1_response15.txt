```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # First, consider only bins that can actually hold the item.
    eligible_bins = bins_remain_cap >= item

    if not np.any(eligible_bins):
        # If no bin can hold the item, prioritize bins with the most remaining capacity (least recently used).  Important to not return 0's if no bin can hold it, and to rather try to maximize remaining space to avoid the very frequent problem of using an extra bin right before running out in all bins
        priorities = bins_remain_cap
        return priorities

    # Calculate remaining capacity after placing the item in eligible bins.
    remaining_capacity_after_placement = bins_remain_cap[eligible_bins] - item

    # Prioritize bins that leave the least amount of wasted space, but don't fill the bin entirely. Small value added so we dont only priortize completely filled bins
    space_efficiency = 1 - (remaining_capacity_after_placement / bins_remain_cap[eligible_bins] + 0.000001 )
    priorities[eligible_bins] = space_efficiency
        #Give priority to fully filled bin in the case we do fill them, otherwise prioritize the bin such that we leave the least empty space (we use the most amount of space)
    is_fully_filled = remaining_capacity_after_placement == 0
    priorities[eligible_bins][is_fully_filled] = 100 #arbitarily large number
    return priorities
```
