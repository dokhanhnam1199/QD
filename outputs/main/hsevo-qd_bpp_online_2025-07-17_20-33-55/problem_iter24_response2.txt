```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, waste_penalty_weight: float = 0.2013748833676067,
                fullness_bonus_weight: float = 0.2013748833676067, noise_level: float = 2.0819988765816894e-09,
                bin_utilization_threshold: float = 0.8, high_utilization_bonus: float = 0.1) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that are already highly utilized and employs dynamic weight adjustment
    based on bin utilization.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
        waste_penalty_weight: Weight of the small waste penalty.
        fullness_bonus_weight: Weight of the bonus for bins closer to full.
        noise_level: Magnitude of the random noise added to priorities.
        bin_utilization_threshold: Threshold for considering a bin highly utilized.
        high_utilization_bonus: Bonus for placing the item in a highly utilized bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.
    infeasible_bins = bins_remain_cap < item
    priorities[infeasible_bins] = -np.inf

    # 2. Calculate waste and fill ratio
    waste = bins_remain_cap - item
    waste[infeasible_bins] = np.inf  # Ensure infeasible bins are penalized

    fill_ratio = item / bins_remain_cap
    normalized_waste_bin = waste / bins_remain_cap


    # 3. Small waste penalty (exponential penalty for small waste relative to item size)
    normalized_waste_item = waste / item
    small_waste_penalty = np.exp(-normalized_waste_item)

    # 4. Fill reward: Prioritize higher fill ratios
    fill_reward = fill_ratio

    # 5. Bin utilization bonus: Give a bonus if the bin is already highly utilized
    current_utilization = (1 - normalized_waste_bin)
    highly_utilized_bins = current_utilization > bin_utilization_threshold
    priorities[highly_utilized_bins] += high_utilization_bonus

    # 6. Combine factors:  Fill reward, waste penalty, and fullness bonus

    priorities[~infeasible_bins] = fill_reward[~infeasible_bins] - waste_penalty_weight * small_waste_penalty[~infeasible_bins] + fullness_bonus_weight * (1 - normalized_waste_bin[~infeasible_bins])


    # 7. Add small noise for tie-breaking and exploration
    priorities += np.random.rand(len(bins_remain_cap)) * noise_level

    return priorities
```
