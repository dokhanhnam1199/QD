```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the principles of relativity, this priority function seeks
    a balance between filling bins and avoiding excessive fragmentation.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # A bin is suitable if it has enough space
    suitable_bins = bins_remain_cap >= item

    if not np.any(suitable_bins):
        # No bin can fit the item. Return a very low priority for all bins.
        # This essentially forces the creation of a new bin (handled externally).
        return priorities - 1e9  # Very negative priority

    for i, cap in enumerate(bins_remain_cap):
        if suitable_bins[i]:
            # Priority is higher for bins with remaining capacity closer to the item size
            # to minimize wasted space. This is like finding the "closest fit"
            # but also penalizes small gaps to encourage packing full bins.

            waste = cap - item
            #Prioritize bins that leaves minimal waste
            priorities[i] = np.exp(-waste)  # Exponential decay as waste increases. A faster decay.
            # A relativistic perspective: The "distance" (waste) impacts the priority exponentially.
            # Furthermore, penalize bins that leave extremely small capacity (fragmentation)
            if waste < 0.1 : #if waste is below this tolerance consider it fragmentation
                 priorities[i] *=0.5  # Reduce priority of almost full bins (fragmentation). Not to choose often.


    # Apply a global adjustment to favor filling nearly full bins. Inspired by energy conservation, we want
    # to fill up high-potential bins (nearly full) and discourage fragmenting almost-empty ones.

    relative_fullness = bins_remain_cap / np.max(bins_remain_cap) # Relative fullness (between 0 and 1.0)

    # Amplify the "relativistic effect" by squaring fullness. Favor packing bins that are already relatively full.

    priority_multiplier =  relative_fullness # original fullness

    priorities = priorities * priority_multiplier  #Adjust initial bin priorities with overall bin fullness.


    return priorities
```
