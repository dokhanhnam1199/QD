```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the waste if the item is placed in the bin.  Negative waste is impossible.
    waste = bins_remain_cap - item
    waste[waste < 0] = np.inf # Mark infeasible bins. It's infinity b/c small waste is good.
    # Heuristic 1: Favor bins with small waste but big enough to fit
    priority = -waste

    # Heuristic 2: If item is small and many bins are very empty (e.g., first few items), use First Fit Decreasing (FFD)
    # Give high priority to almost full bins to fill them before new bins open

    near_full_threshold = 0.9 # Bin almost full (e.g. last 10% free)
    if item < 0.2 and np.sum(bins_remain_cap > near_full_threshold) == 0:
        priority += 0.1 * bins_remain_cap  # Smaller remaining capacities will get slightly higher scores. Small number, because we are early and do not want this dominating the 'waste' calculation.

    # Heuristic 3: Encourage efficient packing in the long run
    # Penalize extremely empty bins (e.g., > 80% empty) from being used unless truly needed. This only applied to bins capable of holding the item.

    extremely_empty_threshold = 0.8
    for i in range(len(bins_remain_cap)):
        if bins_remain_cap[i] > item: # Applicable ONLY to bins capable of containing the item, hence IF

           if bins_remain_cap[i] > extremely_empty_threshold :

                priority[i] -= 0.05   #Reduce priority for those bins. The reduction will depend on how full they are relatively. The more full the less reduction. Important to be a small number.


    # Heuristic 4 : Moderate size items, prevent "hole creation". If near to bin capacity, strongly prefer.
    moderate_threshold_low = 0.3 # item is relatively large
    moderate_threshold_high = 0.7

    if moderate_threshold_low <= item <= moderate_threshold_high:
        near_capacity_bins = (bins_remain_cap -item < 0.1) & (bins_remain_cap -item >= 0) # small room left

        priority[near_capacity_bins] += 0.2 # very strong preferece if near capacity and fits.
    return priority
```
