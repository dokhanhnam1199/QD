{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best aspects of v0 and v1. Balances fill, waste, feasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    \n    #Almost Full Bins\n    almost_full_threshold = 0.95\n    almost_full_bins = (bins_remain_cap - item) / bins_remain_cap < (1-almost_full_threshold)\n    priorities[feasible_bins & almost_full_bins] = 1000\n    \n    #Low Waste Bins\n    low_waste_bins = (bins_remain_cap - item) / np.max(bins_remain_cap) < 0.1\n    priorities[feasible_bins & low_waste_bins] = 500\n\n    # Capacity Difference\n    capacity_diff = np.abs(bins_remain_cap - item)\n    priorities[feasible_bins] = 100 - (capacity_diff[feasible_bins] / np.max(bins_remain_cap)) * 50\n\n    # Non-empty nudge\n    non_empty_bins = bins_remain_cap < np.max(bins_remain_cap)\n    priorities[feasible_bins & non_empty_bins] += 5\n\n    # Infeasible penalty\n    priorities[~feasible_bins] = -1000\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Assign -inf priority if the item doesn't fit.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # 2.  First-Fit Decreasing inspired: Prioritize bins that can accommodate the item\n    #     with minimal waste.  Avoid creating very small remaining spaces if possible.\n\n    # Waste: Remaining capacity after placing the item.\n    waste = bins_remain_cap - item\n    waste[infeasible_bins] = np.inf  # Ensure infeasible bins are penalized\n\n    # Normalized Waste: Waste relative to the item size and bin size.\n    normalized_waste_item = waste / item\n    normalized_waste_bin = waste / bins_remain_cap\n\n    # Penalty for too small waste (encourages filling bins reasonably)\n    small_waste_penalty = np.exp(-normalized_waste_item)  # Exponential penalty for small waste\n\n    # Reward for filling the bin well.  A higher fill ratio is generally better.\n    fill_ratio = item / bins_remain_cap\n    fill_reward = fill_ratio\n\n    # Combine the factors: Prioritize based on fill ratio, penalized by small waste\n    priorities[~infeasible_bins] = fill_reward[~infeasible_bins] - 0.5 * small_waste_penalty[~infeasible_bins]\n\n    # Bonus:  Slightly prioritize bins closer to full if other factors are equal.\n    # This helps close out bins more quickly. Only apply if not infeasible.\n    priorities[~infeasible_bins] += 0.1 * (1 - normalized_waste_bin[~infeasible_bins])\n        \n    # Add small constant to avoid identical priorities and encourage some differentiation.\n    priorities += np.random.rand(len(bins_remain_cap)) * 1e-9\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the earlier heuristics consider \"target_relative_residual\" and \"random_priority_scale\" for maximizing bin utilization and encouraging differentiation, whereas the last one only focuses on log ratios. (11th) vs (20th) shows earlier ones balance fill, waste, and feasibility, assigning specific priorities based on bin fullness and waste levels, while the last only uses log ratios. Comparing (1st) vs (5th), the better one has configurable \"target_relative_residual\" and \"random_priority_scale\", the worse one hardcodes these values. Comparing (16th) vs (20th), the earlier one uses normalized waste, exponential penalty, fill reward, and a bonus for nearly full bins, while the last only uses log ratios. Comparing (1st) vs (16th), the better one uses \"target_relative_residual\" and \"random_priority_scale\" and fill ratios penalized by residual capacity. (11th) vs (16th), 11th gives fixed high priorities to almost full and low waste bins. Comparing (1st) vs (11th), the earlier one uses fill ratios penalized by the difference between the relative residual capacity and a target, adding a small random constant. Overall, the better heuristics incorporate more factors like target residual capacity, waste minimization, and dynamic scoring based on bin utilization, while the worse heuristics rely on simpler calculations and hardcoded values.\n- \nHere's a redefined self-reflection approach for designing heuristics, focusing on actionable insights and avoiding common pitfalls:\n\n*   **Keywords:** Adaptive, Configurable, Multi-objective, Dynamic priorities, Trade-off analysis.\n\n*   **Advice:** Design heuristics with parameters adjustable to problem instance characteristics. Continuously re-evaluate and dynamically adjust the weights given to different objectives (e.g., fill, waste, feasibility) based on performance feedback.\n\n*   **Avoid:** Static, single-objective rules, hardcoded parameters, neglecting interdependencies between objectives.\n\n*   **Explanation:** Effective heuristics dynamically balance conflicting objectives. Parameter configuration and objective prioritization should adapt based on problem characteristics and performance feedback, not fixed assumptions.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}