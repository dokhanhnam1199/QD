[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Optimizes tight packing vs future flexibility via geometric mean synergy,\n    with size-aware exact fit bonuses and stability-focused numerical handling.\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    eps = 1e-9  # Precision stabilization\n    \n    # Core packing efficiency metric (item/bin ratio)\n    fill_ratio = item / (bins_remain_cap + eps)\n    \n    # Future flexibility metric (sqrt residual encourages mid-sized gaps)\n    residual_utility = np.sqrt(np.maximum(remaining_after, 0) + eps)\n    \n    # Balanced synergy via geometric mean\n    synergy = np.sqrt(fill_ratio * residual_utility)\n    \n    # Size-proportional exact fit bonus (2.0 base + 1.5*item scaling)\n    exact_fit = np.isclose(remaining_after, 0, atol=1e-8)\n    fit_bonus = exact_fit * (2.0 + 1.5 * item)  # Calibrated scaling\n    \n    # Combine components only for valid bins\n    scores = np.where(valid_mask, synergy + fit_bonus, -np.inf)\n    \n    return scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 2.183885121659363,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Optimal balance: Geometric mean of immediate packing efficiency (item/remaining) \n    and future flexibility (sqrt residual), with boosted exact-fit precision.\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Core packing efficiency: maximize item-to-remaining ratio\n    fill_ratio = item / (bins_remain_cap + 1e-10)  # Prevent division explosion\n    \n    # Future flexibility: sqrt residual favors medium future items\n    residual_utility = np.sqrt(np.maximum(remaining_after, 0) + 1e-10)\n    \n    # Synergistic balance using geometric mean\n    balanced_score = np.sqrt(fill_ratio * residual_utility)\n    \n    # Precision-aware exact fit boost (avoids floating point pitfalls)\n    exact_fit_boost = np.isclose(remaining_after, 0, atol=1e-8) * 3.0  # Stronger than v0\n    \n    # Combine components only for valid bins\n    scores = np.where(valid_mask, balanced_score + exact_fit_boost, -np.inf)\n    \n    return scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 2.183885121659363,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic combining dynamic objective balancing with precision-aware\n    residual optimization. Key features:\n    1. Adaptive geometric mean of fill efficiency/residual potential\n    2. Context-sensitive exact fit detection\n    3. Item-size modulated weight interpolation\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Dynamic fill efficiency with bin-size aware scaling\n    fill_ratio = item / (bins_remain_cap + 1e-12)\n    fill_power = np.where(bins_remain_cap > 0.5, fill_ratio**0.75, fill_ratio**1.1)\n    \n    # Residual potential combines preservation and forecasting\n    residual_space = np.maximum(remaining_after, 0)\n    residual_value = (residual_space**0.5 + 0.4*residual_space**0.7) / (1.2 + 0.15*item)\n    \n    # Item-adaptive weight balancing (emphasize fill for large items)\n    weight = np.clip(item * 1.6, 0.25, 0.75)\n    synergy = (fill_power**weight) * (residual_value**(1-weight))\n    \n    # Precision bonus with item-proportional scaling\n    exact_boost = np.exp(-(remaining_after**2)/(1e-7 + 0.02*item**2)) * (0.6 + 1.4*item)\n    \n    return np.where(valid_mask, synergy + exact_boost, -np.inf)",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Optimal exact-fit prioritization with geometric synergy between \n    immediate packing density and future flexibility potential.\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    exact_fit = np.isclose(remaining_after, 0, atol=5e-6)  # Precision-tuned\n    \n    # Synergy components with stabilized denominators\n    fill_ratio = item / (bins_remain_cap + 1e-7)  # Prevent div0 while preserving ratio accuracy\n    residual_potential = np.sqrt(np.maximum(remaining_after, 0) + 1e-7)  # Future flexibility metric\n    synergy = np.sqrt(fill_ratio * residual_potential)  # Geometric balance\n    \n    # Strategic priority assignment\n    return np.where(exact_fit, np.inf, np.where(valid_mask, synergy, -np.inf))",
    "response_id": 3,
    "tryHS": false,
    "obj": 2.183885121659363,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balances tight packing with residual utility using geometric mean synergy\n    and item-scaled exact fit rewards. Calibrated epsilons prevent instabilities.\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Core synergy components\n    fill_efficiency = item / (bins_remain_cap + 3.2e-7)  # Prevent zero-division\n    residual_potential = np.sqrt(np.maximum(remaining_after, 0) + 1.8e-7)  # Future flexibility\n    synergy_score = np.sqrt(fill_efficiency * residual_potential)  # Geometric balance\n    \n    # Dynamic exact fit reward proportional to item size\n    exact_fit_bonus = np.isclose(remaining_after, 0, atol=4.5e-6) * item * 2.65\n    \n    scores = np.where(valid_mask, synergy_score + exact_fit_bonus, -np.inf)\n    return scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 2.183885121659363,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Optimally balances tight packing (item/bin fit) with residual space \n    utility using geometric synergy and precision-tuned exact-fit rewards.\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Core synergy: Geometric mean of immediate efficiency vs future flexibility\n    fill_ratio = item / (bins_remain_cap + 1e-7)  # Prefer bins where item fills significant portion\n    residual_utility = np.sqrt(np.maximum(remaining_after, 0) + 1e-7)  # Value remaining space diminishingly\n    synergy = np.sqrt(fill_ratio * residual_utility)  # Balanced multiplicative interaction\n    \n    # Precision-aware exact fit detection with calibrated bonus\n    exact_fit_bonus = np.isclose(remaining_after, 0, atol=1e-5, rtol=0) * 3.0  # Weight from empirical optimization\n    \n    scores = np.where(valid_mask, synergy + exact_fit_bonus, -np.inf)\n    return scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 2.183885121659363,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic: Prioritizes exact fits, combines geometric mean of \n    tightness/utilization from v0 with v1's residual alignment bonus (simplified).\"\"\"\n    remaining_space = bins_remain_cap - item\n    exact_fit = np.isclose(remaining_space, 0, atol=1e-9)\n    valid = remaining_space >= 0\n    \n    # Core geometric mean calculation from v0\n    tightness = 1 / (np.abs(remaining_space) + 1e-9)\n    utilization = 1 / (bins_remain_cap + 1e-9)\n    combined_score = np.sqrt(tightness * utilization)\n    \n    # Simplified residual alignment from v1: Encourage space matching item size\n    alignment_bonus = 0.15 * np.exp(-np.abs(remaining_space - item)/(item + 1e-9))\n    \n    priorities = np.where(\n        exact_fit,\n        np.inf,  # Absolute priority for perfect fits\n        np.where(\n            valid,\n            combined_score + alignment_bonus,  # Balanced core + alignment bonus\n            -np.inf  # Exclude invalid bins\n        )\n    )\n    \n    return priorities",
    "response_id": 6,
    "tryHS": true,
    "obj": 1.984443558037504,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes exact fits, then balances fill efficiency and residual \n    potential using geometric mean with calibrated stability constants.\"\"\"\n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Precision parameters from v0's calibration\n    eps_fill = 3.9947e-07\n    eps_residual = 2.3511e-07\n    atol_perfection = 5.4225e-06\n    \n    # Detect exact fits with tight tolerance\n    exact_fit = np.isclose(remaining_after, 0, atol=atol_perfection)\n    \n    # Calculate synergy score for non-exact valid bins\n    fill_efficiency = item / (bins_remain_cap + eps_fill)\n    residual_potential = np.sqrt(np.maximum(remaining_after, 0) + eps_residual)\n    synergy_score = np.sqrt(fill_efficiency * residual_potential)  # Geometric mean\n    \n    # Assign scores: exact fits get infinity, others use synergy or -inf\n    scores = np.where(exact_fit, np.inf, \n                      np.where(valid_mask, synergy_score, -np.inf))\n    \n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 2.183885121659363,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Optimizes tight fit vs post-packing utilization via geometric mean. Explicitly\n    prioritizes perfect fits while maintaining smooth gradients for near-optimal cases.\n    \"\"\"\n    residual_space = bins_remain_cap - item\n    valid_mask = residual_space >= 0\n    eps = 1e-9  # Numerical stability\n    \n    # Core synergy: Balance immediate fit with final packed density\n    tightness = 1 / (residual_space + eps)\n    post_utilization = 1 - residual_space  # Utilization after packing\n    combined = np.sqrt(tightness * post_utilization)  # Geometric mean preserves proportionality\n    \n    scores = np.where(valid_mask, combined, -np.inf)\n    \n    # Strategic perfect fit prioritization\n    exact_fits = np.isclose(residual_space, 0, atol=eps)\n    scores = np.where(exact_fits, scores * 5 + 1e9, scores)  # Dominant boost while preserving order\n    \n    return scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 6.591543677702447,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balances geometric mean of fill efficiency and residual potential\n    with exact-fit bonuses and anti-microgap penalties. Uses adaptive\n    exponents and size-aware weighting for balanced packing.\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    eps = 1e-9\n    \n    # Core geometric balance (fill efficiency vs residual flexibility)\n    fill_efficiency = (item ** 1.4) / (bins_remain_cap + eps)\n    residual_base = np.maximum(remaining_after, 0) + eps\n    adaptive_exp = 0.35 + 0.65 * (1 - item)  # Smaller items value future space more\n    residual_potential = residual_base ** adaptive_exp\n    synergy = (fill_efficiency * residual_potential) ** 0.62  # Tuned geometric mean\n    \n    # Size-aware exact fit bonus with utilization scaling\n    exact_fit = np.isclose(remaining_after, 0, atol=1e-8)\n    utilization_bonus = 1.8 + 3.2 * (1 - bins_remain_cap)  # Reward filling underutilized\n    perfection_bonus = exact_fit * (utilization_bonus + np.sqrt(item))\n    \n    # Progressive anti-fragmentation penalty \n    micro_gap_penalty = np.exp(-residual_base * 18) * 0.7  # Stronger decay than v0\n    \n    return np.where(valid_mask, \n                   synergy + perfection_bonus - micro_gap_penalty, \n                   -np.inf)",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    remaining_space = bins_remain_cap - item\n    exact_fit = np.isclose(remaining_space, 0, atol=1e-12)\n    valid = remaining_space >= 0\n    \n    residual = remaining_space\n    bin_capacity = 1.0  # Assuming standard bin capacity\n    \n    # Core packing pressure components\n    density = (bin_capacity - residual) / bin_capacity  # Final bin utilization\n    tightness = np.exp(-residual / (item + 1e-12))  # Exponential decay for small residuals\n    \n    # Dynamic alignment: Favor residuals matching common fractions of item size\n    alignment = (\n        0.5 * np.exp(-np.abs(residual - item/2)/(item + 1e-12)) +  # Half-item space\n        0.3 * np.exp(-np.abs(residual - item)/(item + 1e-12))     # Full-item space\n    )\n    \n    # Capacity-aware scaling\n    capacity_weight = np.sqrt(item / bin_capacity)  # Favor alignment for larger items\n    \n    # Non-linear combination with phase transition\n    combined = (\n        np.power(density, 2.0 - capacity_weight) * \n        np.power(tightness, 1.0 + capacity_weight) * \n        (1.0 + alignment)\n    )\n    \n    priorities = np.where(\n        exact_fit,\n        np.inf,\n        np.where(\n            valid,\n            np.where(\n                residual > item,\n                combined * (1.0 + 0.2 * np.sqrt(residual - item)),  # Bonus for super-alignment\n                combined\n            ),\n            -np.inf\n        )\n    )\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 6.422018348623862,
    "SLOC": 27.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    remaining_space = bins_remain_cap - item\n    exact_fit = np.isclose(remaining_space, 0, atol=1e-9)\n    valid = remaining_space >= 0\n    \n    # Dynamic numerical stability factor\n    eps = max(1e-9, item * 1e-12)\n    \n    # Core packing tension metrics\n    space_tension = 1 / (np.abs(remaining_space) + eps)\n    density_potential = 1 / (bins_remain_cap + eps)\n    \n    # Adaptive weighting based on item/bin ratio\n    capacity_ratio = item / (bins_remain_cap + eps)\n    tightness_weight = np.clip(capacity_ratio, 0.2, 0.8)\n    combined_score = (space_tension**tightness_weight) * (density_potential**(1 - tightness_weight))\n    \n    # Harmonic alignment bonus\n    residual_harmonics = np.where(remaining_space > 0, \n                                1 / (1 + np.abs((remaining_space % item) - item/2)), \n                                0)\n    harmonic_bonus = 0.25 * np.tanh(residual_harmonics / item)\n    \n    # Future packing potential\n    future_capacity = np.where(remaining_space >= item, \n                             np.sqrt(remaining_space / (item + eps)), \n                             -0.1/(remaining_space + eps))\n    \n    priorities = np.where(\n        exact_fit,\n        np.inf,\n        np.where(\n            valid,\n            combined_score + harmonic_bonus + future_capacity,\n            -np.inf\n        )\n    )\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 85.98923015556443,
    "SLOC": 27.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    remaining_space = bins_remain_cap - item\n    exact_fit = np.isclose(remaining_space, 0, atol=1e-9)\n    valid = remaining_space >= 0\n    \n    # Core packing quality metrics\n    tightness = 1 / (np.abs(remaining_space) + 1e-9)\n    utilization = (1 - bins_remain_cap) ** 2  # Quadratic emphasis on filled bins\n    combined_score = np.sqrt(tightness * utilization)\n    \n    # Dynamic residual alignment with item-adaptive parameters\n    residual = remaining_space\n    alignment_center = item * 0.7  # Target slightly smaller than item size\n    sigma = item * 0.4  # Adaptive Gaussian width\n    alignment_bonus = 0.25 * np.exp(-(residual - alignment_center)**2 / (2*sigma**2 + 1e-9))\n    \n    # Fractal packing incentive for modular residuals\n    fractal_bonus = 0.15 * np.sin(np.pi * residual/item)**2 / (residual/item + 0.2)**0.5\n    \n    # Anti-fragmentation penalty for non-useful small spaces\n    fragmentation_penalty = np.where(\n        residual < 0.1, \n        np.exp(-10*(0.1 - residual)), \n        1.0\n    )\n    \n    priorities = np.where(\n        exact_fit,\n        np.inf,\n        np.where(\n            valid,\n            (combined_score + alignment_bonus + fractal_bonus) * fragmentation_penalty,\n            -np.inf\n        )\n    )\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.15835660151576,
    "SLOC": 27.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    remaining_space = bins_remain_cap - item\n    exact_fit = np.isclose(remaining_space, 0, atol=1e-12)\n    valid = remaining_space >= 0\n    \n    # Dynamic resource balancing using harmonic potential field\n    tightness = 1 / (np.abs(remaining_space) + 1e-12)\n    density = (1 - bins_remain_cap) ** 2  # Quadratic pressure for filled bins\n    harmonic_balance = np.sqrt(tightness * density)\n    \n    # Quantum tunneling-inspired alignment (only when beneficial)\n    tunnel_threshold = item * 1.5\n    alignment = np.where(\n        remaining_space > item,\n        np.exp(-(remaining_space - item)**2 / (0.2*item + 1e-12)),\n        np.zeros_like(remaining_space)\n    )\n    \n    # Phase transition smoothing\n    phase_shift = 0.7 * (1 - np.tanh(10*(bins_remain_cap - 0.9)))\n    stability_boost = np.where(\n        bins_remain_cap > item,\n        1 + 0.3 * np.sin(np.pi * bins_remain_cap / item),\n        np.ones_like(bins_remain_cap)\n    )\n    \n    priorities = np.where(\n        exact_fit,\n        np.inf,\n        np.where(\n            valid,\n            harmonic_balance * stability_boost + phase_shift * alignment,\n            -np.inf\n        )\n    )\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 3.1412046270442766,
    "SLOC": 27.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    remaining_space = bins_remain_cap - item\n    exact_fit = np.isclose(remaining_space, 0, atol=1e-9)\n    valid = remaining_space >= 0\n    \n    eps = max(1e-9, 1e-9 * item)  # Dynamic epsilon scaled with item size\n    tightness = 1 / (np.abs(remaining_space) + eps)\n    utilization = 1 / (bins_remain_cap + eps)\n    combined_score = np.sqrt(tightness * utilization)\n    \n    # Harmonic alignment: Prefer residual spaces that are integer multiples of item size\n    residual = remaining_space.copy()\n    np.abs(residual, out=residual)  # Work with absolute values\n    with np.errstate(divide='ignore', invalid='ignore'):\n        harmonic_ratio = np.where(residual > 0, (residual / item) % 1, 0)\n    harmonic_dist = np.minimum(harmonic_ratio, 1 - harmonic_ratio)\n    harmonic_bonus = 0.2 * np.exp(-harmonic_dist / 0.1)\n    \n    # Spring potential: Favor bins where residual space creates optimal tension\n    spring_constant = np.clip(item / bins_remain_cap, 0.1, 0.9)\n    spring_potential = 0.15 * np.exp(-np.abs(remaining_space - spring_constant*bins_remain_cap)/(item + eps))\n    \n    # Adaptive weighting based on item size significance\n    size_adapt = 0.4 * np.tanh(item * 10)  # Smooth scaling 0-0.4\n    \n    priorities = np.where(\n        exact_fit,\n        np.inf,\n        np.where(\n            valid,\n            combined_score * (1 + size_adapt) + harmonic_bonus + spring_potential,\n            -np.inf\n        )\n    )\n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 2.8619864379736786,
    "SLOC": 27.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_hs4.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    exact_fit_atol: float = 5.550494942929915e-07,\n    tightness_epsilon: float = 9.335195461559172e-07,\n    utilization_epsilon: float = 8.899578910890616e-07,\n    alignment_bonus_weight: float = 0.32541695897792977,\n    alignment_epsilon: float = 6.746653765434427e-07) -> np.ndarray:\n    \"\"\"Hybrid heuristic: Prioritizes exact fits, combines geometric mean of \n    tightness/utilization from v0 with v1's residual alignment bonus (simplified).\"\"\"\n    remaining_space = bins_remain_cap - item\n    exact_fit = np.isclose(remaining_space, 0, atol=exact_fit_atol)\n    valid = remaining_space >= 0\n    \n    # Core geometric mean calculation from v0\n    tightness = 1 / (np.abs(remaining_space) + tightness_epsilon)\n    utilization = 1 / (bins_remain_cap + utilization_epsilon)\n    combined_score = np.sqrt(tightness * utilization)\n    \n    # Simplified residual alignment from v1: Encourage space matching item size\n    alignment_bonus = alignment_bonus_weight * np.exp(-np.abs(remaining_space - item)/(item + alignment_epsilon))\n    \n    priorities = np.where(\n        exact_fit,\n        np.inf,  # Absolute priority for perfect fits\n        np.where(\n            valid,\n            combined_score + alignment_bonus,  # Balanced core + alignment bonus\n            -np.inf  # Exclude invalid bins\n        )\n    )\n    \n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 1.5955325089748704,
    "SLOC": 25.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]