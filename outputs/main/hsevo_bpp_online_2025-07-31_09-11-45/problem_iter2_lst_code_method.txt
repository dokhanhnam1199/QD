{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Quantum-inspired priority using harmonic packing efficiency and residual capacity potential.\"\"\"\n    # Calculate residual capacity after potential placement\n    residual = bins_remain_cap - item\n    \n    # Create mask for valid bins that can accommodate the item\n    valid_mask = residual >= 0\n    \n    # Initialize priorities with negative infinity (invalid placement)\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For valid bins, calculate quantum-inspired priority score\n    valid_indices = valid_mask.nonzero()[0]\n    if valid_indices.size > 0:\n        # Harmonic efficiency term (encourages tight fits)\n        harmonic_term = 1 / (residual[valid_indices] + 1e-9)\n        \n        # Residual potential term (favors bins needing less future energy to fill)\n        potential_term = np.sqrt(bins_remain_cap[valid_indices])\n        \n        # Combine terms using geometric mean for quantum-style optimization\n        priorities[valid_indices] = harmonic_term * potential_term\n        \n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins using celestial harmony principles - balance between tight fit and future flexibility.\"\"\"\n    # Calculate remaining space after hypothetical placement\n    remaining_after = bins_remain_cap - item\n    \n    # Favor bins where item fills remaining space completely (divine perfection)\n    perfection_bonus = np.where(remaining_after == 0, 10.0, 0.0)\n    \n    # Reward bins that leave space for medium future items (0.3-0.7 range)\n    future_fit = np.clip(remaining_after, 0.3, 0.7) - 0.3\n    \n    # Combine factors with weights inspired by planetary motion ratios\n    scores = (\n        (1.0 / (remaining_after + 1e-9)) * 0.618 +  # Golden ratio weighting for tight fits\n        future_fit * 0.382 +  # Complementary ratio for future flexibility\n        perfection_bonus\n    )\n    \n    # For bins that can't accommodate the item, set priority to cosmic void\n    scores = np.where(bins_remain_cap >= item, scores, -np.inf)\n    \n    return scores\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins where the item fills maximum remaining capacity proportion.\n       Favors bins where item/remaining_ratio is highest to tightly pack items.\"\"\"\n    # Calculate remaining capacity after potential placement\n    remaining_after = bins_remain_cap - item\n    \n    # Create mask for valid bins that can accommodate the item\n    valid_mask = remaining_after >= 0\n    \n    # Calculate item-to-remaining ratio with epsilon to avoid division by zero\n    with np.errstate(divide='ignore', invalid='ignore'):\n        fill_ratio = item / (bins_remain_cap + 1e-9)\n    \n    # Boost score for bins that would be perfectly filled\n    perfection_bonus = (remaining_after == 0) * 2.0\n    \n    # Combine metrics and invalidate impossible bins\n    scores = np.where(valid_mask, fill_ratio + perfection_bonus, -np.inf)\n    \n    return scores\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins using gravitational attraction analogy: items are drawn to bins \n    where they create maximum density (exact fit first, then minimal remaining space)\"\"\"\n    remaining_space = bins_remain_cap - item\n    exact_fit = (remaining_space == 0)\n    \n    # Give infinite priority to exact fits, then use inverse square law for others\n    priorities = np.where(\n        exact_fit,\n        np.inf,\n        np.where(\n            remaining_space > 0,\n            1/(remaining_space**2 + 1e-9),  # Inverse square law for tighter packing\n            -np.inf\n        )\n    )\n    \n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best Fit with utilization boost: Prioritizes bins that minimize wasted space\n    after placement, with preference for bins that would become nearly full.\"\"\"\n    # Calculate remaining capacity after potential placement\n    after_placement = bins_remain_cap - item\n    \n    # Create mask for valid bins that can accommodate the item\n    valid_mask = bins_remain_cap >= item\n    \n    # Calculate utilization ratio (1 - remaining_after_placement/original_capacity)\n    # Assuming original bin capacity is 1.0 (common normalized scenario)\n    utilization = 1.0 - after_placement\n    \n    # Boost score for bins that would become highly utilized (>90%)\n    utilization_boost = np.where(utilization > 0.9, 2.0, 1.0)\n    \n    # Base score is inverse of wasted space (higher = better fit)\n    # Add boosted utilization as tiebreaker for nearly-full bins\n    scores = np.where(\n        valid_mask,\n        (1 / (after_placement + 1e-9)) * utilization_boost,\n        -np.inf\n    )\n    \n    return scores\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins that exactly fit the item, then uses a combination of\n    remaining capacity utilization and inverse gap size for other valid bins.\"\"\"\n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Reward exact fits with highest priority\n    exact_fit_priority = np.where(bins_remain_cap == item, np.inf, 0)\n    \n    # For non-exact fits, combine inverse gap size and remaining capacity utilization\n    gap_priority = np.where(valid_mask, 1/(remaining_after + 1e-9), -np.inf)\n    utilization_priority = np.where(valid_mask, (bins_remain_cap - remaining_after)/bins_remain_cap, -np.inf)\n    \n    # Combine priorities with weighted sum\n    combined_priority = gap_priority * 0.7 + utilization_priority * 0.3\n    \n    # Override with exact fit priority\n    return np.where(exact_fit_priority > 0, np.inf, combined_priority)\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using inverse square of remaining space combined with current utilization.\n    \n    Combines tightness of fit (1/remaining\u00b2) with inverse of current bin capacity\n    to favor packing into bins that are both efficiently filled now and were previously underutilized.\n    \"\"\"\n    remaining_after = bins_remain_cap - item\n    feasible = remaining_after >= 0\n    epsilon = 1e-9\n    \n    # Calculate two complementary factors\n    tightness_factor = 1 / (remaining_after**2 + epsilon)  # Favors smallest remaining space\n    utilization_factor = 1 / (bins_remain_cap + epsilon)    # Favors bins that were more full originally\n    \n    # Combine factors multiplicatively\n    combined_score = tightness_factor * utilization_factor\n    \n    return np.where(feasible, combined_score, -np.inf)\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using relativistic 'space-time tightness' heuristic.\n    \n    1. Prefer bins where item fits exactly (quantum harmony)\n    2. Maximize space utilization through hyperbolic scoring\n    3. Use inverse square law for near-fit penalization\n    \"\"\"\n    remaining_space = bins_remain_cap - item\n    valid_mask = remaining_space >= 0\n    \n    # Base score combines hyperbolic fit and inverse square residual\n    fit_score = 1 / (remaining_space + 1e-9)  # Hyperbolic priority for tight fits\n    density_bonus = np.sqrt(bins_remain_cap)  # Favor bins with higher existing density\n    \n    # Combine factors with relativistic weights\n    scores = np.where(\n        valid_mask,\n        fit_score * (1 + density_bonus) / (1 + np.abs(remaining_space)**0.5),\n        -np.inf\n    )\n    \n    # Apply special reward for perfect fits (E=mc\u00b2 equivalence)\n    perfect_fit_mask = np.isclose(remaining_space, 0, atol=1e-9)\n    scores = np.where(perfect_fit_mask, 2 * scores.max() + 1, scores)\n    \n    return scores\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins that exactly fit the item, then uses a combination of\n    remaining capacity utilization and inverse gap size for other valid bins.\"\"\"\n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Reward exact fits with highest priority\n    exact_fit_priority = np.where(bins_remain_cap == item, np.inf, 0)\n    \n    # For non-exact fits, combine inverse gap size and remaining capacity utilization\n    gap_priority = np.where(valid_mask, 1/(remaining_after + 1e-9), -np.inf)\n    utilization_priority = np.where(valid_mask, (bins_remain_cap - remaining_after)/bins_remain_cap, -np.inf)\n    \n    # Combine priorities with weighted sum\n    combined_priority = gap_priority * 0.7 + utilization_priority * 0.3\n    \n    # Override with exact fit priority\n    return np.where(exact_fit_priority > 0, np.inf, combined_priority)\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins that exactly fit the item, then use inverse remaining capacity.\"\"\"\n    remaining_after = bins_remain_cap - item\n    can_fit = remaining_after >= 0\n    exact_fit = (remaining_after == 0)\n    \n    # Give extreme priority to exact fits, then prioritize smallest remaining space\n    priority = np.where(\n        can_fit,\n        -remaining_after + 1e9 * exact_fit,  # Exact fits get +1e9 boost\n        -np.inf  # Infeasible bins get lowest priority\n    )\n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using a radiation-inspired 'decay balance' heuristic.\n    Combines tight packing with capacity preservation using exponential terms.\"\"\"\n    fit_mask = bins_remain_cap >= item\n    remaining_space = bins_remain_cap - item\n    \n    # Favor bins where item fills radioactive \"half-life\" proportions\n    decay_factor = np.exp(-5 * remaining_space)  # Strong preference for near-exact fits\n    capacity_preservation = np.sqrt(bins_remain_cap)  # Preserve mid-sized capacities\n    \n    scores = np.where(\n        fit_mask,\n        decay_factor * (1 + capacity_preservation),\n        -np.inf\n    )\n    \n    # Prefer creating new bins for items >0.5 capacity to prevent fragmentation\n    if item > 0.5:\n        scores = np.where(fit_mask, scores * 0.2, scores)\n    \n    return scores\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins where the item fills a large portion of remaining space.\n       Uses inverse of post-placement remaining capacity with non-linear scaling.\"\"\"\n    # Calculate remaining capacity after potential placement\n    remaining_after = bins_remain_cap - item\n    \n    # Create validity mask and initialize scores\n    valid_mask = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For valid bins, calculate dynamic priority score combining multiple factors\n    valid_indices = valid_mask.nonzero()[0]\n    if valid_indices.size > 0:\n        # Use inverse square of remaining space to strongly favor tight fits\n        remaining_valid = remaining_after[valid_indices]\n        density_boost = item / (remaining_valid + 1e-9)  # Base density score\n        capacity_penalty = 0.1 * bins_remain_cap[valid_indices]  # Prefer smaller bins\n        scores[valid_indices] = density_boost - capacity_penalty + np.sqrt(item)\n        \n    return scores\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize exact fits, then bins with smallest leftover space using reciprocal.\"\"\"\n    leftover = bins_remain_cap - item\n    can_fit = bins_remain_cap >= (item - 1e-9)  # Floating point tolerance\n    exact_fit = np.isclose(leftover, 0, atol=1e-9, rtol=0)\n    \n    scores = np.full_like(bins_remain_cap, -np.inf)\n    valid_bins = can_fit\n    \n    # Apply massive priority boost for exact fits, reciprocal of leftover otherwise\n    scores[valid_bins] = np.where(\n        exact_fit[valid_bins],\n        1e9,  # Arbitrarily large value to prioritize exact fits\n        1.0 / (leftover[valid_bins] + 1e-9)  # +epsilon to avoid division by zero\n    )\n    \n    return scores\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins that achieve tightest fit while favoring fuller bins.\n    \n    1. Bins that can't fit the item get -infinity priority\n    2. For valid bins, score combines remaining space after placement \n       and current utilization using harmonic mean\n    \"\"\"\n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Calculate two complementary factors\n    tightness = 1 / (remaining_after + 1e-9)  # Favors smallest remaining space\n    utilization = 1 - (bins_remain_cap / 1.0)  # Favors more full bins (assuming bin size=1)\n    \n    # Combine factors using harmonic mean to balance both objectives\n    combined_score = 2 * tightness * utilization / (tightness + utilization + 1e-9)\n    \n    return np.where(valid_mask, combined_score, -np.inf)\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Black Hole-inspired Bin Packing Priority: Items are drawn towards bins like matter approaching an event horizon.\n       Prioritizes bins where the item creates maximum density while avoiding singularities (overflows).\"\"\"\n    event_horizon = 1e-9  # Prevent division singularity\n    remaining_space = bins_remain_cap - item\n    \n    # Calculate spacetime curvature (priority inversely proportional to remaining space)\n    curvature = np.where(remaining_space >= 0, \n                         1/(remaining_space + event_horizon) + (bins_remain_cap/(item + event_horizon)), \n                         -np.inf)\n    \n    # Apply Hawking radiation penalty to near-empty bins\n    density = (bins_remain_cap - remaining_space + item)/bins_remain_cap\n    radiation = np.where(density < 0.2, -10, 1)\n    \n    return curvature * radiation\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Black Hole-inspired Bin Packing Priority: Items are drawn towards bins like matter approaching an event horizon.\n       Prioritizes bins where the item creates maximum density while avoiding singularities (overflows).\"\"\"\n    event_horizon = 1e-9  # Prevent division singularity\n    remaining_space = bins_remain_cap - item\n    \n    # Calculate spacetime curvature (priority inversely proportional to remaining space)\n    curvature = np.where(remaining_space >= 0, \n                         1/(remaining_space + event_horizon) + (bins_remain_cap/(item + event_horizon)), \n                         -np.inf)\n    \n    # Apply Hawking radiation penalty to near-empty bins\n    density = (bins_remain_cap - remaining_space + item)/bins_remain_cap\n    radiation = np.where(density < 0.2, -10, 1)\n    \n    return curvature * radiation\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins that would be nearly filled, with exponential boost for perfect fits.\"\"\"\n    remain_after = bins_remain_cap - item\n    feasible_mask = remain_after >= 0\n    \n    # Base score combines remaining space efficiency and square of utilization\n    utilization = 1.0 - (bins_remain_cap - item)  # Assuming bin capacity = 1.0\n    space_efficiency = 1 / (remain_after + 1e-9)\n    \n    # Boost for bins that would be 95%+ full\n    fill_boost = np.where(utilization >= 0.95, 10, 1)\n    \n    # Extreme boost for perfect fits\n    perfect_fit_boost = np.where(remain_after == 0, 1000, 1)\n    \n    scores = utilization**2 * space_efficiency * fill_boost * perfect_fit_boost\n    return np.where(feasible_mask, scores, -np.inf)\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins that would be nearly filled, with exponential boost for perfect fits.\"\"\"\n    remain_after = bins_remain_cap - item\n    feasible_mask = remain_after >= 0\n    \n    # Base score combines remaining space efficiency and square of utilization\n    utilization = 1.0 - (bins_remain_cap - item)  # Assuming bin capacity = 1.0\n    space_efficiency = 1 / (remain_after + 1e-9)\n    \n    # Boost for bins that would be 95%+ full\n    fill_boost = np.where(utilization >= 0.95, 10, 1)\n    \n    # Extreme boost for perfect fits\n    perfect_fit_boost = np.where(remain_after == 0, 1000, 1)\n    \n    scores = utilization**2 * space_efficiency * fill_boost * perfect_fit_boost\n    return np.where(feasible_mask, scores, -np.inf)\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using radioactive decay-inspired heuristic combining:\n    1. Inverse of remaining space after placement (tighter fit = better)\n    2. Current utilization of the bin (more utilized = better)\n    3. Exponential bonus for near-exact fits\"\"\"\n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Base score combines inverse remaining space and current utilization\n    tightness_factor = 1 / (remaining_after + 1e-9)\n    utilization_factor = 1 - bins_remain_cap  # Current utilization\n    \n    # Exponential bonus for bins that would be nearly full after placement\n    decay_bonus = np.exp(-10 * remaining_after)\n    \n    scores = np.where(\n        valid_mask,\n        tightness_factor * utilization_factor * decay_bonus,\n        -np.inf\n    )\n    return scores\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using radioactive decay-inspired heuristic combining:\n    1. Inverse of remaining space after placement (tighter fit = better)\n    2. Current utilization of the bin (more utilized = better)\n    3. Exponential bonus for near-exact fits\"\"\"\n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Base score combines inverse remaining space and current utilization\n    tightness_factor = 1 / (remaining_after + 1e-9)\n    utilization_factor = 1 - bins_remain_cap  # Current utilization\n    \n    # Exponential bonus for bins that would be nearly full after placement\n    decay_bonus = np.exp(-10 * remaining_after)\n    \n    scores = np.where(\n        valid_mask,\n        tightness_factor * utilization_factor * decay_bonus,\n        -np.inf\n    )\n    return scores\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}