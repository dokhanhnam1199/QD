import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    exact_fit_atol: float = 8.51201071968802e-07,
    tightness_epsilon: float = 3.331778422916044e-07,
    utilization_epsilon: float = 8.206854569866348e-07,
    alignment_bonus_weight: float = 0.74810250217578,
    alignment_epsilon: float = 1.6377676440669124e-07) -> np.ndarray:
    """Hybrid heuristic: Prioritizes exact fits, combines geometric mean of 
    tightness/utilization from v0 with v1's residual alignment bonus (simplified)."""
    remaining_space = bins_remain_cap - item
    exact_fit = np.isclose(remaining_space, 0, atol=exact_fit_atol)
    valid = remaining_space >= 0
    
    # Core geometric mean calculation from v0
    tightness = 1 / (np.abs(remaining_space) + tightness_epsilon)
    utilization = 1 / (bins_remain_cap + utilization_epsilon)
    combined_score = np.sqrt(tightness * utilization)
    
    # Simplified residual alignment from v1: Encourage space matching item size
    alignment_bonus = alignment_bonus_weight * np.exp(-np.abs(remaining_space - item)/(item + alignment_epsilon))
    
    priorities = np.where(
        exact_fit,
        np.inf,  # Absolute priority for perfect fits
        np.where(
            valid,
            combined_score + alignment_bonus,  # Balanced core + alignment bonus
            -np.inf  # Exclude invalid bins
        )
    )
    
    return priorities
