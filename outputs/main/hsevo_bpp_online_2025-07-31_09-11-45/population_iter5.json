[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Optimizes tight packing vs future flexibility via geometric mean synergy,\n    with size-aware exact fit bonuses and stability-focused numerical handling.\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    eps = 1e-9  # Precision stabilization\n    \n    # Core packing efficiency metric (item/bin ratio)\n    fill_ratio = item / (bins_remain_cap + eps)\n    \n    # Future flexibility metric (sqrt residual encourages mid-sized gaps)\n    residual_utility = np.sqrt(np.maximum(remaining_after, 0) + eps)\n    \n    # Balanced synergy via geometric mean\n    synergy = np.sqrt(fill_ratio * residual_utility)\n    \n    # Size-proportional exact fit bonus (2.0 base + 1.5*item scaling)\n    exact_fit = np.isclose(remaining_after, 0, atol=1e-8)\n    fit_bonus = exact_fit * (2.0 + 1.5 * item)  # Calibrated scaling\n    \n    # Combine components only for valid bins\n    scores = np.where(valid_mask, synergy + fit_bonus, -np.inf)\n    \n    return scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 2.183885121659363,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Optimal balance: Geometric mean of immediate packing efficiency (item/remaining) \n    and future flexibility (sqrt residual), with boosted exact-fit precision.\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Core packing efficiency: maximize item-to-remaining ratio\n    fill_ratio = item / (bins_remain_cap + 1e-10)  # Prevent division explosion\n    \n    # Future flexibility: sqrt residual favors medium future items\n    residual_utility = np.sqrt(np.maximum(remaining_after, 0) + 1e-10)\n    \n    # Synergistic balance using geometric mean\n    balanced_score = np.sqrt(fill_ratio * residual_utility)\n    \n    # Precision-aware exact fit boost (avoids floating point pitfalls)\n    exact_fit_boost = np.isclose(remaining_after, 0, atol=1e-8) * 3.0  # Stronger than v0\n    \n    # Combine components only for valid bins\n    scores = np.where(valid_mask, balanced_score + exact_fit_boost, -np.inf)\n    \n    return scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 2.183885121659363,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic combining dynamic objective balancing with precision-aware\n    residual optimization. Key features:\n    1. Adaptive geometric mean of fill efficiency/residual potential\n    2. Context-sensitive exact fit detection\n    3. Item-size modulated weight interpolation\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Dynamic fill efficiency with bin-size aware scaling\n    fill_ratio = item / (bins_remain_cap + 1e-12)\n    fill_power = np.where(bins_remain_cap > 0.5, fill_ratio**0.75, fill_ratio**1.1)\n    \n    # Residual potential combines preservation and forecasting\n    residual_space = np.maximum(remaining_after, 0)\n    residual_value = (residual_space**0.5 + 0.4*residual_space**0.7) / (1.2 + 0.15*item)\n    \n    # Item-adaptive weight balancing (emphasize fill for large items)\n    weight = np.clip(item * 1.6, 0.25, 0.75)\n    synergy = (fill_power**weight) * (residual_value**(1-weight))\n    \n    # Precision bonus with item-proportional scaling\n    exact_boost = np.exp(-(remaining_after**2)/(1e-7 + 0.02*item**2)) * (0.6 + 1.4*item)\n    \n    return np.where(valid_mask, synergy + exact_boost, -np.inf)",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Optimal exact-fit prioritization with geometric synergy between \n    immediate packing density and future flexibility potential.\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    exact_fit = np.isclose(remaining_after, 0, atol=5e-6)  # Precision-tuned\n    \n    # Synergy components with stabilized denominators\n    fill_ratio = item / (bins_remain_cap + 1e-7)  # Prevent div0 while preserving ratio accuracy\n    residual_potential = np.sqrt(np.maximum(remaining_after, 0) + 1e-7)  # Future flexibility metric\n    synergy = np.sqrt(fill_ratio * residual_potential)  # Geometric balance\n    \n    # Strategic priority assignment\n    return np.where(exact_fit, np.inf, np.where(valid_mask, synergy, -np.inf))",
    "response_id": 3,
    "tryHS": false,
    "obj": 2.183885121659363,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balances tight packing with residual utility using geometric mean synergy\n    and item-scaled exact fit rewards. Calibrated epsilons prevent instabilities.\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Core synergy components\n    fill_efficiency = item / (bins_remain_cap + 3.2e-7)  # Prevent zero-division\n    residual_potential = np.sqrt(np.maximum(remaining_after, 0) + 1.8e-7)  # Future flexibility\n    synergy_score = np.sqrt(fill_efficiency * residual_potential)  # Geometric balance\n    \n    # Dynamic exact fit reward proportional to item size\n    exact_fit_bonus = np.isclose(remaining_after, 0, atol=4.5e-6) * item * 2.65\n    \n    scores = np.where(valid_mask, synergy_score + exact_fit_bonus, -np.inf)\n    return scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 2.183885121659363,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Optimally balances tight packing (item/bin fit) with residual space \n    utility using geometric synergy and precision-tuned exact-fit rewards.\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Core synergy: Geometric mean of immediate efficiency vs future flexibility\n    fill_ratio = item / (bins_remain_cap + 1e-7)  # Prefer bins where item fills significant portion\n    residual_utility = np.sqrt(np.maximum(remaining_after, 0) + 1e-7)  # Value remaining space diminishingly\n    synergy = np.sqrt(fill_ratio * residual_utility)  # Balanced multiplicative interaction\n    \n    # Precision-aware exact fit detection with calibrated bonus\n    exact_fit_bonus = np.isclose(remaining_after, 0, atol=1e-5, rtol=0) * 3.0  # Weight from empirical optimization\n    \n    scores = np.where(valid_mask, synergy + exact_fit_bonus, -np.inf)\n    return scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 2.183885121659363,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic: Prioritizes exact fits, combines geometric mean of \n    tightness/utilization from v0 with v1's residual alignment bonus (simplified).\"\"\"\n    remaining_space = bins_remain_cap - item\n    exact_fit = np.isclose(remaining_space, 0, atol=1e-9)\n    valid = remaining_space >= 0\n    \n    # Core geometric mean calculation from v0\n    tightness = 1 / (np.abs(remaining_space) + 1e-9)\n    utilization = 1 / (bins_remain_cap + 1e-9)\n    combined_score = np.sqrt(tightness * utilization)\n    \n    # Simplified residual alignment from v1: Encourage space matching item size\n    alignment_bonus = 0.15 * np.exp(-np.abs(remaining_space - item)/(item + 1e-9))\n    \n    priorities = np.where(\n        exact_fit,\n        np.inf,  # Absolute priority for perfect fits\n        np.where(\n            valid,\n            combined_score + alignment_bonus,  # Balanced core + alignment bonus\n            -np.inf  # Exclude invalid bins\n        )\n    )\n    \n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 1.984443558037504,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes exact fits, then balances fill efficiency and residual \n    potential using geometric mean with calibrated stability constants.\"\"\"\n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Precision parameters from v0's calibration\n    eps_fill = 3.9947e-07\n    eps_residual = 2.3511e-07\n    atol_perfection = 5.4225e-06\n    \n    # Detect exact fits with tight tolerance\n    exact_fit = np.isclose(remaining_after, 0, atol=atol_perfection)\n    \n    # Calculate synergy score for non-exact valid bins\n    fill_efficiency = item / (bins_remain_cap + eps_fill)\n    residual_potential = np.sqrt(np.maximum(remaining_after, 0) + eps_residual)\n    synergy_score = np.sqrt(fill_efficiency * residual_potential)  # Geometric mean\n    \n    # Assign scores: exact fits get infinity, others use synergy or -inf\n    scores = np.where(exact_fit, np.inf, \n                      np.where(valid_mask, synergy_score, -np.inf))\n    \n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 2.183885121659363,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Optimizes tight fit vs post-packing utilization via geometric mean. Explicitly\n    prioritizes perfect fits while maintaining smooth gradients for near-optimal cases.\n    \"\"\"\n    residual_space = bins_remain_cap - item\n    valid_mask = residual_space >= 0\n    eps = 1e-9  # Numerical stability\n    \n    # Core synergy: Balance immediate fit with final packed density\n    tightness = 1 / (residual_space + eps)\n    post_utilization = 1 - residual_space  # Utilization after packing\n    combined = np.sqrt(tightness * post_utilization)  # Geometric mean preserves proportionality\n    \n    scores = np.where(valid_mask, combined, -np.inf)\n    \n    # Strategic perfect fit prioritization\n    exact_fits = np.isclose(residual_space, 0, atol=eps)\n    scores = np.where(exact_fits, scores * 5 + 1e9, scores)  # Dominant boost while preserving order\n    \n    return scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 6.591543677702447,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balances geometric mean of fill efficiency and residual potential\n    with exact-fit bonuses and anti-microgap penalties. Uses adaptive\n    exponents and size-aware weighting for balanced packing.\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    eps = 1e-9\n    \n    # Core geometric balance (fill efficiency vs residual flexibility)\n    fill_efficiency = (item ** 1.4) / (bins_remain_cap + eps)\n    residual_base = np.maximum(remaining_after, 0) + eps\n    adaptive_exp = 0.35 + 0.65 * (1 - item)  # Smaller items value future space more\n    residual_potential = residual_base ** adaptive_exp\n    synergy = (fill_efficiency * residual_potential) ** 0.62  # Tuned geometric mean\n    \n    # Size-aware exact fit bonus with utilization scaling\n    exact_fit = np.isclose(remaining_after, 0, atol=1e-8)\n    utilization_bonus = 1.8 + 3.2 * (1 - bins_remain_cap)  # Reward filling underutilized\n    perfection_bonus = exact_fit * (utilization_bonus + np.sqrt(item))\n    \n    # Progressive anti-fragmentation penalty \n    micro_gap_penalty = np.exp(-residual_base * 18) * 0.7  # Stronger decay than v0\n    \n    return np.where(valid_mask, \n                   synergy + perfection_bonus - micro_gap_penalty, \n                   -np.inf)",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]