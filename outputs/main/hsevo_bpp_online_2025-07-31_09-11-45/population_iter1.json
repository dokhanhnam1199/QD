[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best Fit with utilization boost: Prioritizes bins that minimize wasted space\n    after placement, with preference for bins that would become nearly full.\"\"\"\n    # Calculate remaining capacity after potential placement\n    after_placement = bins_remain_cap - item\n    \n    # Create mask for valid bins that can accommodate the item\n    valid_mask = bins_remain_cap >= item\n    \n    # Calculate utilization ratio (1 - remaining_after_placement/original_capacity)\n    # Assuming original bin capacity is 1.0 (common normalized scenario)\n    utilization = 1.0 - after_placement\n    \n    # Boost score for bins that would become highly utilized (>90%)\n    utilization_boost = np.where(utilization > 0.9, 2.0, 1.0)\n    \n    # Base score is inverse of wasted space (higher = better fit)\n    # Add boosted utilization as tiebreaker for nearly-full bins\n    scores = np.where(\n        valid_mask,\n        (1 / (after_placement + 1e-9)) * utilization_boost,\n        -np.inf\n    )\n    \n    return scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using relativistic space optimization strategy.\n    \n    1. Gives maximum priority to perfect-fit bins (remaining == item)\n    2. For other feasible bins, prioritizes minimal \"wasted spacetime\" \n       (remaining - item) with gravitational weighting\n    3. Uses negative infinity for bins that can't accommodate the item\n    \"\"\"\n    space_after_packing = bins_remain_cap - item\n    gravitational_potential = 1 / (space_after_packing + 1e-9)  # Prevent division by zero\n    \n    # Special relativity condition: perfect space-time alignment\n    perfect_fit_mask = np.isclose(space_after_packing, 0, atol=1e-9)\n    \n    # General relativity condition: warped space-time continuum\n    valid_mask = space_after_packing >= -1e-9  # Account for floating point errors\n    warped_priority = np.where(valid_mask, gravitational_potential, -np.inf)\n    \n    # Combine effects using Einstein's field equations\n    priorities = np.where(perfect_fit_mask, np.inf, warped_priority)\n    \n    # Event horizon filter (ensure non-viable bins get -inf)\n    return np.where(valid_mask, priorities, -np.inf)",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins using gravitational-inspired tight packing and energy minimization.\n    \n    1. Bins that can't fit item get -inf priority\n    2. For viable bins, score increases with tighter fit (inverse square law)\n    3. Additional boost for bins where item fills >50% remaining capacity\n    \"\"\"\n    remaining_after = bins_remain_cap - item\n    can_fit = remaining_after >= 0\n    \n    # Base gravitational attraction (inverse square of remaining space)\n    gravitational = 1 / (remaining_after + 1e-9)**2\n    \n    # Potential energy bonus for significant space utilization\n    utilization_bonus = np.where(remaining_after <= bins_remain_cap/2, 1.618, 0)  # Golden ratio boost\n    \n    priorities = np.where(can_fit, gravitational + utilization_bonus, -np.inf)\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using inverse square of remaining space combined with current utilization.\n    \n    Combines tightness of fit (1/remaining\u00b2) with inverse of current bin capacity\n    to favor packing into bins that are both efficiently filled now and were previously underutilized.\n    \"\"\"\n    remaining_after = bins_remain_cap - item\n    feasible = remaining_after >= 0\n    epsilon = 1e-9\n    \n    # Calculate two complementary factors\n    tightness_factor = 1 / (remaining_after**2 + epsilon)  # Favors smallest remaining space\n    utilization_factor = 1 / (bins_remain_cap + epsilon)    # Favors bins that were more full originally\n    \n    # Combine factors multiplicatively\n    combined_score = tightness_factor * utilization_factor\n    \n    return np.where(feasible, combined_score, -np.inf)",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins using electromagnetic resonance principles:\n    1. Favor bins where item fits exactly (harmonic resonance)\n    2. Prefer bins that leave prime-numbered remaining capacity\n    3. Use inverse square law for remaining capacity\"\"\"\n    \n    # Calculate remaining capacity after placement\n    new_remain = bins_remain_cap - item\n    \n    # Basic validity mask\n    valid_mask = new_remain >= 0\n    \n    # Prime number bonus calculation\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(np.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    prime_bonus = np.vectorize(lambda x: 10 if is_prime(x) else 0)(new_remain)\n    \n    # Resonance components\n    exact_fit_bonus = np.where(new_remain == 0, 100, 0)\n    capacity_field = np.where(valid_mask, 1 / (new_remain + 1e-9)**2, -np.inf)\n    \n    # Combine components with Tesla's special coefficients\n    priority_scores = (\n        0.5 * capacity_field + \n        3.0 * exact_fit_bonus + \n        1.2 * prime_bonus\n    )\n    \n    return np.where(valid_mask, priority_scores, -np.inf)",
    "response_id": 4,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997413891833 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins that exactly fit the item, then use inverse remaining capacity.\"\"\"\n    remaining_after = bins_remain_cap - item\n    can_fit = remaining_after >= 0\n    exact_fit = (remaining_after == 0)\n    \n    # Give extreme priority to exact fits, then prioritize smallest remaining space\n    priority = np.where(\n        can_fit,\n        -remaining_after + 1e9 * exact_fit,  # Exact fits get +1e9 boost\n        -np.inf  # Infeasible bins get lowest priority\n    )\n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Black Hole-inspired Bin Packing Priority: Items are drawn towards bins like matter approaching an event horizon.\n       Prioritizes bins where the item creates maximum density while avoiding singularities (overflows).\"\"\"\n    event_horizon = 1e-9  # Prevent division singularity\n    remaining_space = bins_remain_cap - item\n    \n    # Calculate spacetime curvature (priority inversely proportional to remaining space)\n    curvature = np.where(remaining_space >= 0, \n                         1/(remaining_space + event_horizon) + (bins_remain_cap/(item + event_horizon)), \n                         -np.inf)\n    \n    # Apply Hawking radiation penalty to near-empty bins\n    density = (bins_remain_cap - remaining_space + item)/bins_remain_cap\n    radiation = np.where(density < 0.2, -10, 1)\n    \n    return curvature * radiation",
    "response_id": 6,
    "tryHS": false,
    "obj": 83.85520542481053,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Quantum-inspired priority using space utilization efficiency and residual entropy potential.\n    \n    Prioritizes bins where:\n    1. Item fits perfectly (quantum state collapse to perfect match)\n    2. Higher space utilization ratio (item_size/remaining_cap)\n    3. Leaves residual capacity with higher \"quantum usefulness\" (1 - sqrt(residual))\n    \"\"\"\n    residual = bins_remain_cap - item\n    valid_mask = residual >= 0\n    \n    # Perfect match gets highest priority\n    perfect_fit = np.isclose(residual, 0, atol=1e-9)\n    \n    # Space utilization ratio (higher is better)\n    utilization = item / (bins_remain_cap + 1e-9)\n    \n    # Quantum potential for future items (penalizes awkward residual sizes)\n    quantum_potential = 1 - np.sqrt(np.abs(residual))\n    \n    # Combined score with priority ordering\n    scores = np.where(\n        valid_mask,\n        perfect_fit * 2.0 + utilization + quantum_potential,\n        -np.inf\n    )\n    \n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins where the item fits snugly, leaving minimal wasted space.\n       Uses reciprocal of remaining capacity after placement for valid bins,\n       with penalty for bins that can't accommodate the item.\"\"\"\n    remaining_after_placement = bins_remain_cap - item\n    valid_mask = remaining_after_placement >= 0\n    # Use reciprocal to favor smallest remaining space, add epsilon to avoid division by zero\n    priorities = np.where(valid_mask, 1/(remaining_after_placement + 1e-9), -np.inf)\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins that achieve tightest fit while favoring fuller bins.\n    \n    1. Bins that can't fit the item get -infinity priority\n    2. For valid bins, score combines remaining space after placement \n       and current utilization using harmonic mean\n    \"\"\"\n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Calculate two complementary factors\n    tightness = 1 / (remaining_after + 1e-9)  # Favors smallest remaining space\n    utilization = 1 - (bins_remain_cap / 1.0)  # Favors more full bins (assuming bin size=1)\n    \n    # Combine factors using harmonic mean to balance both objectives\n    combined_score = 2 * tightness * utilization / (tightness + utilization + 1e-9)\n    \n    return np.where(valid_mask, combined_score, -np.inf)",
    "response_id": 9,
    "tryHS": false,
    "obj": 5.195452732349436,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins that exactly fit the item, then uses a combination of\n    remaining capacity utilization and inverse gap size for other valid bins.\"\"\"\n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Reward exact fits with highest priority\n    exact_fit_priority = np.where(bins_remain_cap == item, np.inf, 0)\n    \n    # For non-exact fits, combine inverse gap size and remaining capacity utilization\n    gap_priority = np.where(valid_mask, 1/(remaining_after + 1e-9), -np.inf)\n    utilization_priority = np.where(valid_mask, (bins_remain_cap - remaining_after)/bins_remain_cap, -np.inf)\n    \n    # Combine priorities with weighted sum\n    combined_priority = gap_priority * 0.7 + utilization_priority * 0.3\n    \n    # Override with exact fit priority\n    return np.where(exact_fit_priority > 0, np.inf, combined_priority)",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using relativistic 'space-time efficiency' metric.\n    \n    1. Bins with exact fit (item == remaining space) get maximum priority\n    2. Prefer bins where item fills relativistic \"potential gap\"\n    3. Penalize bins that would leave fragmented residual space\n    \"\"\"\n    space_after = bins_remain_cap - item\n    fit_quality = np.where(space_after >= 0, \n                          (item / (space_after + 1e-9)) * np.exp(-space_after), \n                          -np.inf)\n    return np.where(bins_remain_cap == item, np.inf, fit_quality)",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using hybrid of best-fit and fullness optimization.\n    \n    1. Primary factor: Minimize remaining space after placement (best-fit)\n    2. Secondary factor: Prefer already fuller bins when ties occur\n    \"\"\"\n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Use scaled combination where remaining_after dominates bin fullness\n    priority_scores = (-remaining_after * 1000) - bins_remain_cap\n    \n    return np.where(valid_mask, priority_scores, -np.inf)",
    "response_id": 12,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using radioactive decay-inspired heuristic combining:\n    1. Inverse of remaining space after placement (tighter fit = better)\n    2. Current utilization of the bin (more utilized = better)\n    3. Exponential bonus for near-exact fits\"\"\"\n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Base score combines inverse remaining space and current utilization\n    tightness_factor = 1 / (remaining_after + 1e-9)\n    utilization_factor = 1 - bins_remain_cap  # Current utilization\n    \n    # Exponential bonus for bins that would be nearly full after placement\n    decay_bonus = np.exp(-10 * remaining_after)\n    \n    scores = np.where(\n        valid_mask,\n        tightness_factor * utilization_factor * decay_bonus,\n        -np.inf\n    )\n    return scores",
    "response_id": 13,
    "tryHS": false,
    "obj": 143.99680893498208,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins using electromagnetic field-inspired heuristic:\n       1. Bins act like capacitors - higher \"energy density\" (item/bin_ratio) gets priority\n       2. Prefer resonant matches where item perfectly fills remaining space\n       3. Favor harmonic balance between current load and remaining capacity\"\"\"\n    \n    remaining_space = bins_remain_cap - item\n    valid_mask = remaining_space >= 0\n    \n    # Calculate harmonic balance ratio (1 - remaining/capacity would be better but we work with remainders)\n    harmonic_balance = np.abs(1/(bins_remain_cap + 1e-9) - 1/(item + 1e-9))\n    \n    # Energy density score (inverse of remaining space with bonus for perfect fits)\n    energy_density = np.where(\n        valid_mask,\n        (1 / (remaining_space + 1e-9)) * (1 + 10 * np.isclose(remaining_space, 0)),\n        -np.inf\n    )\n    \n    # Combine with harmonic balance (lower difference gets higher priority)\n    return energy_density * (1 / (harmonic_balance + 1e-9))",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins where the item fills maximum remaining capacity proportion.\n       Favors bins where item/remaining_ratio is highest to tightly pack items.\"\"\"\n    # Calculate remaining capacity after potential placement\n    remaining_after = bins_remain_cap - item\n    \n    # Create mask for valid bins that can accommodate the item\n    valid_mask = remaining_after >= 0\n    \n    # Calculate item-to-remaining ratio with epsilon to avoid division by zero\n    with np.errstate(divide='ignore', invalid='ignore'):\n        fill_ratio = item / (bins_remain_cap + 1e-9)\n    \n    # Boost score for bins that would be perfectly filled\n    perfection_bonus = (remaining_after == 0) * 2.0\n    \n    # Combine metrics and invalidate impossible bins\n    scores = np.where(valid_mask, fill_ratio + perfection_bonus, -np.inf)\n    \n    return scores",
    "response_id": 15,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using a black hole-inspired metric combining relativistic \n    density and gravitational binding efficiency. Favors bins where the item:\n    1. Maximizes post-packing mass-energy density (filled/(remaining + \u03b5))\n    2. Minimizes spacetime 'fragmentation' through inverse capacity weighting\"\"\"\n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    filled_after = 1.0 - remaining_after  # Total filled fraction after insertion\n    \n    # Event horizon condition: prevent division by zero while allowing perfect fits\n    epsilon = 1e-12\n    density_metric = filled_after / (remaining_after + epsilon)\n    \n    # Gravitational binding term: prioritize bins where item fills \"orbital gaps\"\n    binding_term = 1 / (bins_remain_cap + epsilon)\n    \n    # Combine metrics using relativistic addition (prioritize density with binding modifier)\n    combined_score = density_metric * (1 + binding_term)\n    \n    return np.where(valid_mask, combined_score, -np.inf)",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Quantum-inspired priority using harmonic potential and utilization boost.\n    \n    Combines inverse remaining capacity (tight fit) with existing bin utilization\n    to create superposition-like scoring that favors both efficient packing and\n    consolidation of partially filled bins.\"\"\"\n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Quantum-inspired harmonic potential term (1/(remaining_space + \u03b5))\n    harmonic_term = 1.0 / (remaining_after + 1e-9)\n    \n    # Utilization boost (1 + current utilization) to favor consolidating items\n    utilization = 1.0 - bins_remain_cap  # Assuming normalized bin capacity\n    boost_term = 1.0 + utilization\n    \n    # Combine terms with geometric mean for quantum-like entanglement effect\n    priority = harmonic_term * np.sqrt(boost_term)\n    \n    # Nullify invalid bins using quantum Zeno effect analogy\n    return np.where(valid_mask, priority, -np.inf)",
    "response_id": 17,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using a dynamic scoring system considering tight fit, \n    bin utilization, and leaves strategic residual capacity.\"\"\"\n    residual = bins_remain_cap - item\n    valid_mask = residual >= 0\n    \n    # Base score favors tight fits (Best Fit characteristic)\n    tight_fit_score = -residual\n    \n    # Bonus for bins that would be over 75% utilized after placement\n    post_utilization = 1 - (residual / bins_remain_cap)\n    utilization_bonus = np.where(post_utilization > 0.75, 0.5, 0)\n    \n    # Penalty for leaving small residual capacity (strategic space reservation)\n    residual_penalty = np.where((residual > 0) & (residual < 0.2*item), -0.3, 0)\n    \n    # Combine scores only for valid bins\n    combined_score = np.where(\n        valid_mask,\n        tight_fit_score + utilization_bonus + residual_penalty,\n        -np.inf\n    )\n    \n    return combined_score",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize exact fits, then bins with smallest leftover space using reciprocal.\"\"\"\n    leftover = bins_remain_cap - item\n    can_fit = bins_remain_cap >= (item - 1e-9)  # Floating point tolerance\n    exact_fit = np.isclose(leftover, 0, atol=1e-9, rtol=0)\n    \n    scores = np.full_like(bins_remain_cap, -np.inf)\n    valid_bins = can_fit\n    \n    # Apply massive priority boost for exact fits, reciprocal of leftover otherwise\n    scores[valid_bins] = np.where(\n        exact_fit[valid_bins],\n        1e9,  # Arbitrarily large value to prioritize exact fits\n        1.0 / (leftover[valid_bins] + 1e-9)  # +epsilon to avoid division by zero\n    )\n    \n    return scores",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using a combination of fit quality and fragmentation prevention.\n    \n    1. Gives highest priority to perfect fits (remaining capacity == item)\n    2. Favors bins where item fills largest proportion of remaining space\n    3. Penalizes bins that would leave small residual capacities\n    \"\"\"\n    residual = bins_remain_cap - item\n    valid_mask = residual >= 0\n    \n    # Base score: inverse of residual space (prioritize tight fits)\n    fit_quality = np.divide(item, bins_remain_cap, where=valid_mask)\n    \n    # Penalty for small residual spaces (below 20% of bin size)\n    residual_penalty = np.where((residual > 0) & (residual < 0.2), -0.5/residual, 0)\n    \n    # Bonus for perfect fits\n    perfect_fit_bonus = np.where(residual == 0, 2.0, 0)\n    \n    scores = np.where(\n        valid_mask,\n        fit_quality + perfect_fit_bonus + residual_penalty,\n        -np.inf\n    )\n    \n    return scores",
    "response_id": 20,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using relativistic 'space-time tightness' heuristic.\n    \n    1. Prefer bins where item fits exactly (quantum harmony)\n    2. Maximize space utilization through hyperbolic scoring\n    3. Use inverse square law for near-fit penalization\n    \"\"\"\n    remaining_space = bins_remain_cap - item\n    valid_mask = remaining_space >= 0\n    \n    # Base score combines hyperbolic fit and inverse square residual\n    fit_score = 1 / (remaining_space + 1e-9)  # Hyperbolic priority for tight fits\n    density_bonus = np.sqrt(bins_remain_cap)  # Favor bins with higher existing density\n    \n    # Combine factors with relativistic weights\n    scores = np.where(\n        valid_mask,\n        fit_score * (1 + density_bonus) / (1 + np.abs(remaining_space)**0.5),\n        -np.inf\n    )\n    \n    # Apply special reward for perfect fits (E=mc\u00b2 equivalence)\n    perfect_fit_mask = np.isclose(remaining_space, 0, atol=1e-9)\n    scores = np.where(perfect_fit_mask, 2 * scores.max() + 1, scores)\n    \n    return scores",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins using gravitational attraction analogy: items are drawn to bins \n    where they create maximum density (exact fit first, then minimal remaining space)\"\"\"\n    remaining_space = bins_remain_cap - item\n    exact_fit = (remaining_space == 0)\n    \n    # Give infinite priority to exact fits, then use inverse square law for others\n    priorities = np.where(\n        exact_fit,\n        np.inf,\n        np.where(\n            remaining_space > 0,\n            1/(remaining_space**2 + 1e-9),  # Inverse square law for tighter packing\n            -np.inf\n        )\n    )\n    \n    return priorities",
    "response_id": 22,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using a radiation-inspired 'decay balance' heuristic.\n    Combines tight packing with capacity preservation using exponential terms.\"\"\"\n    fit_mask = bins_remain_cap >= item\n    remaining_space = bins_remain_cap - item\n    \n    # Favor bins where item fills radioactive \"half-life\" proportions\n    decay_factor = np.exp(-5 * remaining_space)  # Strong preference for near-exact fits\n    capacity_preservation = np.sqrt(bins_remain_cap)  # Preserve mid-sized capacities\n    \n    scores = np.where(\n        fit_mask,\n        decay_factor * (1 + capacity_preservation),\n        -np.inf\n    )\n    \n    # Prefer creating new bins for items >0.5 capacity to prevent fragmentation\n    if item > 0.5:\n        scores = np.where(fit_mask, scores * 0.2, scores)\n    \n    return scores",
    "response_id": 23,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins using electromagnetic-inspired heuristic:\n    1. Bins act as capacitors - higher \"resonance\" when item fills remaining space\n    2. Exponential reward for tight fits (simulating dielectric breakdown potential)\n    3. Penalize near-empty bins with inverse square law of remaining capacity\"\"\"\n    \n    new_remaining = bins_remain_cap - item\n    valid_mask = bins_remain_cap >= item\n    \n    # Base resonance score (exponential tight fit reward)\n    resonance = np.exp(-10 * new_remaining)\n    \n    # Dielectric breakdown bonus for near-exact fits\n    breakdown_bonus = 100 * np.exp(-100 * np.abs(new_remaining - 0.01))\n    \n    # Inverse square penalty for remaining capacity (encourage dense packing)\n    density_penalty = 1 / (bins_remain_cap**2 + 1e-9)\n    \n    # Combine components using Tesla's \"alternating current\" balance\n    priorities = resonance + breakdown_bonus + density_penalty\n    \n    # Apply mask and convert invalid bins to -inf\n    priorities = np.where(valid_mask, priorities, -np.inf)\n    \n    return priorities",
    "response_id": 24,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins using celestial harmony principles - balance between tight fit and future flexibility.\"\"\"\n    # Calculate remaining space after hypothetical placement\n    remaining_after = bins_remain_cap - item\n    \n    # Favor bins where item fills remaining space completely (divine perfection)\n    perfection_bonus = np.where(remaining_after == 0, 10.0, 0.0)\n    \n    # Reward bins that leave space for medium future items (0.3-0.7 range)\n    future_fit = np.clip(remaining_after, 0.3, 0.7) - 0.3\n    \n    # Combine factors with weights inspired by planetary motion ratios\n    scores = (\n        (1.0 / (remaining_after + 1e-9)) * 0.618 +  # Golden ratio weighting for tight fits\n        future_fit * 0.382 +  # Complementary ratio for future flexibility\n        perfection_bonus\n    )\n    \n    # For bins that can't accommodate the item, set priority to cosmic void\n    scores = np.where(bins_remain_cap >= item, scores, -np.inf)\n    \n    return scores",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using a 'cosmic compression' heuristic inspired by black hole physics.\n    \n    Combines best-fit strategy with gravitational weighting favoring bins that would\n    approach critical density (near-full) after insertion, while penalizing bins that\n    would cross the event horizon (overflow).\"\"\"\n    \n    # Calculate remaining space if item were placed in each bin\n    post_insert_cap = bins_remain_cap - item\n    \n    # Create gravitational weights (exponentially favor near-perfect fits)\n    gravitational_weights = np.exp(-10 * np.abs(post_insert_cap))\n    \n    # Event horizon penalty (infinite negative for overflow bins)\n    valid_mask = post_insert_cap >= 0\n    priorities = np.where(\n        valid_mask,\n        (bins_remain_cap / (post_insert_cap + 1e-9)) * gravitational_weights,  # Favor high utilization\n        -np.inf  # Singularity penalty (overflow bins get infinite negative priority)\n    )\n    \n    # Apply Hawking radiation correction (allow slight overflow tolerance for quantum fluctuations)\n    priorities = np.where(\n        np.isclose(post_insert_cap, 0, atol=1e-6),\n        priorities * 1.1,  # Small boost for perfect fits\n        priorities\n    )\n    \n    return priorities",
    "response_id": 26,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Quantum-inspired priority using harmonic packing efficiency and residual capacity potential.\"\"\"\n    # Calculate residual capacity after potential placement\n    residual = bins_remain_cap - item\n    \n    # Create mask for valid bins that can accommodate the item\n    valid_mask = residual >= 0\n    \n    # Initialize priorities with negative infinity (invalid placement)\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For valid bins, calculate quantum-inspired priority score\n    valid_indices = valid_mask.nonzero()[0]\n    if valid_indices.size > 0:\n        # Harmonic efficiency term (encourages tight fits)\n        harmonic_term = 1 / (residual[valid_indices] + 1e-9)\n        \n        # Residual potential term (favors bins needing less future energy to fill)\n        potential_term = np.sqrt(bins_remain_cap[valid_indices])\n        \n        # Combine terms using geometric mean for quantum-style optimization\n        priorities[valid_indices] = harmonic_term * potential_term\n        \n    return priorities",
    "response_id": 27,
    "tryHS": false,
    "obj": 3.9888312724371757,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins where the item fills a large portion of remaining space.\n       Uses inverse of post-placement remaining capacity with non-linear scaling.\"\"\"\n    # Calculate remaining capacity after potential placement\n    remaining_after = bins_remain_cap - item\n    \n    # Create validity mask and initialize scores\n    valid_mask = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For valid bins, calculate dynamic priority score combining multiple factors\n    valid_indices = valid_mask.nonzero()[0]\n    if valid_indices.size > 0:\n        # Use inverse square of remaining space to strongly favor tight fits\n        remaining_valid = remaining_after[valid_indices]\n        density_boost = item / (remaining_valid + 1e-9)  # Base density score\n        capacity_penalty = 0.1 * bins_remain_cap[valid_indices]  # Prefer smaller bins\n        scores[valid_indices] = density_boost - capacity_penalty + np.sqrt(item)\n        \n    return scores",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.078579976067022,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins that would be nearly filled, with exponential boost for perfect fits.\"\"\"\n    remain_after = bins_remain_cap - item\n    feasible_mask = remain_after >= 0\n    \n    # Base score combines remaining space efficiency and square of utilization\n    utilization = 1.0 - (bins_remain_cap - item)  # Assuming bin capacity = 1.0\n    space_efficiency = 1 / (remain_after + 1e-9)\n    \n    # Boost for bins that would be 95%+ full\n    fill_boost = np.where(utilization >= 0.95, 10, 1)\n    \n    # Extreme boost for perfect fits\n    perfect_fit_boost = np.where(remain_after == 0, 1000, 1)\n    \n    scores = utilization**2 * space_efficiency * fill_boost * perfect_fit_boost\n    return np.where(feasible_mask, scores, -np.inf)",
    "response_id": 29,
    "tryHS": false,
    "obj": 86.58755484643,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]