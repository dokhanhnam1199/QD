[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic: Gaussian future flexibility with exact-fit priority,\n    using adaptive tightness scaling and numerical stability.\"\"\"\n    \n    remaining = bins_remain_cap - item\n    valid_mask = remaining >= -1e-9  # Account for floating point errors\n    \n    # Exact match detection with tolerance\n    exact_fit = np.isclose(remaining, 0, atol=1e-8, rtol=0)\n    perfection_boost = exact_fit * 15.0  # Higher boost than v0\n    \n    # Dynamic flexibility target based on item size\n    flex_center = 0.5 * (1 - item)  # Larger items -> lower ideal remaining space\n    flex_width = 0.15 + item*0.2  # Adaptive bandwidth\n    \n    # Gaussian future flexibility score\n    future_flex = np.exp(-(remaining - flex_center)**2 / (2*(flex_width**2)))\n    \n    # Logarithmic tightness score prevents extreme values\n    tightness = np.log(1 + 1/(remaining + 1e-9))  # Smoother than raw reciprocal\n    \n    # Balanced combination with golden ratio weights\n    scores = (0.618 * tightness + \n              0.382 * future_flex * (1 + item) +  # Item-size modulated flexibility\n              perfection_boost)\n    \n    # Apply validity mask and return\n    return np.where(valid_mask, scores, -np.inf)",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balances immediate tight packing (item/remaining_ratio) with future \n    flexibility (sqrt residual space), using geometric mean for synergy.\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    \n    # Core efficiency metric: item fills current bin proportion\n    fill_efficiency = item / (bins_remain_cap + 1e-9)  # +eps prevents div0\n    \n    # Flexibility metric: sqrt residual space allows mid-sized future items\n    residual_potential = np.sqrt(np.maximum(remaining_after, 0) + 1e-9)\n    \n    # Geometric mean creates balanced synergy between competing objectives\n    synergy_score = np.sqrt(fill_efficiency * residual_potential)\n    \n    # Precision-aware exact fit bonus (better than ==0 for floating point)\n    perfection_bonus = np.isclose(remaining_after, 0, atol=1e-8) * 2.0\n    \n    # Combine components only for valid bins\n    scores = np.where(valid_mask, synergy_score + perfection_bonus, -np.inf)\n    \n    return scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 2.183885121659363,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balanced packing heuristic: Prioritizes exact fits (with float tolerance), \n    then geometric mean of tightness (1/remaining_space) and bin utilization (1/remaining_capacity).\"\"\"\n    remaining_space = bins_remain_cap - item\n    exact_fit = np.isclose(remaining_space, 0, atol=1e-9)\n    valid = remaining_space >= 0\n    \n    # Calculate components with epsilon smoothing\n    tightness = 1 / (np.abs(remaining_space) + 1e-9)  # Prefer minimal leftover space\n    utilization = 1 / (bins_remain_cap + 1e-9)        # Prefer bins closer to being full\n    \n    # Geometric mean balances both objectives\n    combined_score = np.sqrt(tightness * utilization)\n    \n    priorities = np.where(\n        exact_fit,\n        np.inf,  # Absolute priority for perfect fits\n        np.where(\n            valid,\n            combined_score,\n            -np.inf  # Exclude bins without capacity\n        )\n    )\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic: Balances tight packing (Best Fit) with smooth utilization \n    incentives and exact-fit prioritization using numerical stability best practices.\"\"\"\n    \n    after_placement = bins_remain_cap - item\n    valid_mask = after_placement >= -1e-9  # Floating-point tolerant validity check\n    \n    # Base score: Harmonic tightness (1/residual) promotes minimal wasted space\n    tightness_score = 1 / (after_placement + 1e-9)\n    \n    # Utilization boost: Sigmoid-shaped bonus for bins crossing 85-95% fullness\n    utilization = 1.0 - after_placement\n    utilization_boost = 1 + 2 * np.exp(-5*(0.9 - utilization)**2)  # Smooth peak at 90%\n    \n    # Exact fit detection with numerical stability\n    exact_fit = np.isclose(after_placement, 0, atol=1e-9, rtol=0)\n    \n    # Combine components with controlled scaling\n    scores = np.where(\n        valid_mask,\n        tightness_score * utilization_boost + 1e6 * exact_fit,  # Additive exact-fit priority\n        -np.inf\n    )\n    \n    return scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines exact fit detection (with float tolerance) with harmonic efficiency\n    and residual potential scoring using geometric mean for balanced packing.\n    \"\"\"\n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    exact_fit = np.isclose(remaining_after, 0, atol=1e-9)\n    \n    # Base score combines harmonic efficiency (1/gap) and residual potential (sqrt(original capacity))\n    harmonic = 1 / (remaining_after + 1e-9)  # +epsilon prevents div0\n    residual = np.sqrt(bins_remain_cap)  # Reward using larger available bins\n    combined = harmonic * residual  # Geometric mean via multiplication\n    \n    # Boost exact fits to maximum priority\n    return np.where(exact_fit, np.inf, np.where(valid_mask, combined, -np.inf))",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines geometric mean of harmonic tightness (1/remaining) and residual \n    potential (\u221aoriginal capacity) with exact-fit nuclear binding bonus.\"\"\"\n    \n    remaining_after = bins_remain_cap - item\n    feasible = remaining_after >= 0\n    epsilon = 1e-9\n    \n    # Core balance: Geometric mean between tight packing and residual flexibility\n    harmonic_tightness = 1 / (remaining_after + epsilon)\n    residual_potential = np.sqrt(bins_remain_cap + epsilon)  # \u221a(original capacity - used)\n    balanced_score = np.sqrt(harmonic_tightness * residual_potential)\n    \n    # Nuclear binding bonus: Extreme priority for exact fits (0 remaining)\n    exact_fit = np.isclose(remaining_after, 0, atol=1e-9, rtol=0)\n    nuclear_bonus = exact_fit * 1e20  # Physically inspired dominance\n    \n    return np.where(feasible, balanced_score + nuclear_bonus, -np.inf)",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balances tight fit (1/remaining_space) with bin utilization (1 - bin_cap_remain)\n    using geometric mean. Applies exponential boost for perfect fits while maintaining\n    smooth gradient for near-optimal placements.\"\"\"\n    \n    remaining_space = bins_remain_cap - item\n    valid_mask = remaining_space >= 0\n    eps = 1e-9  # Prevent division by zero\n    \n    # Core components\n    tightness = 1 / (remaining_space + eps)  # Hyperbolic fit priority\n    utilization = 1 - bins_remain_cap  # Existing bin fullness (assuming bin size=1)\n    \n    # Geometric mean balances immediate fit vs existing utilization\n    combined = np.sqrt(tightness * utilization)\n    \n    scores = np.where(valid_mask, combined, -np.inf)\n    \n    # Exponential boost for perfect fits using tolerance-aware check\n    perfect_fits = np.isclose(remaining_space, 0, atol=eps)\n    scores = np.where(perfect_fits, scores * 2 + 1e6, scores)  # Maintain relative ordering\n    \n    return scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balances exact-fit prioritization with harmonic tightness and original capacity potential using geometric combination.\"\"\"\n    residual = bins_remain_cap - item\n    valid_mask = residual >= 0\n    exact_fit = np.isclose(bins_remain_cap, item, atol=1e-9)\n    \n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    valid_exact = valid_mask & exact_fit\n    \n    if np.any(valid_exact):\n        priorities[valid_exact] = np.inf  # Absolute priority for perfect fits\n        return priorities\n    \n    valid_indices = valid_mask.nonzero()[0]\n    if valid_indices.size > 0:\n        # Harmonic term rewards tight fits, sqrt(bins_remain_cap) preserves potential\n        harmonic = 1 / (residual[valid_indices] + 1e-9)\n        potential = np.sqrt(bins_remain_cap[valid_indices])  # Original capacity potential\n        priorities[valid_indices] = harmonic * potential  # Geometric combination\n        \n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 13, in priority_v2\n    \nOverflowError: cannot convert float infinity to integer\n10\n2\n"
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize exact fits, then balance tight packing (1/leftover) and residual capacity (sqrt) via geometric mean.\"\"\"\n    leftover = bins_remain_cap - item\n    can_fit = leftover >= -1e-9  # Tolerance for floating point errors\n    exact_fit = np.isclose(leftover, 0, atol=1e-9)\n    \n    eps = 1e-9  # Prevent division by zero and stabilize sqrt\n    harmonic = 1.0 / (leftover + eps)  # Tight packing incentive\n    residual = np.sqrt(bins_remain_cap + eps)  # Future capacity potential\n    combined = np.sqrt(harmonic * residual)  # Geometric mean balance\n    \n    priority = np.where(exact_fit, 1e9, combined)  # Exact fits get max priority\n    return np.where(can_fit, priority, -np.inf)  # Filter invalid bins",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balances tight packing with future flexibility using:\n    1. Exponential decay for near-exact fits\n    2. Square root residual capacity preservation\n    3. Dynamic large-item penalty with exponential scaling\"\"\"\n    \n    fit_mask = bins_remain_cap >= item\n    remaining_after = bins_remain_cap - item\n    \n    # Base score combines tightness and preservation components\n    tightness = np.exp(-6 * remaining_after)  # Strong preference for <0.1 residual\n    preservation = np.sqrt(np.maximum(remaining_after, 1e-9))  # Protect usable capacity\n    scores = np.where(fit_mask, tightness * preservation, -np.inf)\n    \n    # Dynamic penalty for items that could fragment large bins\n    if item > 0.3:  # Applies penalty gradient starting at lower threshold\n        penalty_scale = np.exp(-4 * (bins_remain_cap - item))  # Penalize bins that would leave <0.25 capacity\n        scores = np.where(fit_mask, scores * (1 - 0.6*penalty_scale), scores)\n    \n    return scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.427602712405275,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]