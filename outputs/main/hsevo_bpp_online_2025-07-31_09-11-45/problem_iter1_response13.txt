<think>
Okay, I need to design a priority function for the online bin packing problem. The goal is to assign a priority score to each bin based on the item's size and the remaining capacities of the bins. The highest priority bin will be chosen to pack the item.

First, let's think about existing heuristics. The Best Fit heuristic places an item in the bin that leaves the least remaining space. But maybe there's a smarter way. Marie Curie was a pioneer, so perhaps the heuristic should be inspired by scientific principles, like optimizing resource usage or minimizing waste.

Wait, the priority function needs to return a score for each bin. Bins that can't fit the item (remaining capacity < item size) should have a very low priority, maybe negative infinity so they're ignored. For valid bins, the score should reflect how good a fit the item is.

What if we consider both the remaining capacity after placing the item and the utilization of the bin? For example, a bin that, after adding the item, has very little space left (high utilization) is good. Also, maybe we want to prioritize bins that are already more full, but not too full. Or perhaps balance between filling bins and leaving room for future items.

Another angle: the efficiency of packing. If the item takes up a large portion of the remaining space, that's efficient. So the score could be higher for bins where the item fits exactly or leaves minimal space. But also, maybe we can use a function that combines multiple factors.

Let me think of a formula. For each bin, if the bin can fit the item (remain >= item), then compute a score. Maybe:

score = (remaining_capacity - item) + some other term. Wait, but smaller remaining after insertion is better. So (remaining_capacity - item) is the space left after adding the item. We want this to be as small as possible, so the negative of that would be a higher priority. But how to turn that into a score.

Alternatively, the score could be (remaining_capacity - item) but inverted. So for a bin that can fit the item, the score is 1/(remaining_capacity - item + epsilon) to avoid division by zero. That way, bins that leave less space get higher scores. But this is similar to Best Fit.

But maybe we can add another term. For example, the current utilization of the bin. The bin's used space is (original capacity - remaining). If original capacity is 1 (assuming normalized bins), then used is 1 - remain. So after adding the item, the used becomes (1 - (remain - item)) = 1 - remain + item. The utilization would be (1 - (remain - item)) / 1 = 1 - remain + item. Wait, maybe not. Let's say the bin's remaining capacity is 'r'. The item size is 's'. After adding, the remaining is r - s. The used space is (original capacity) - (r - s) = (original capacity - r) + s. If original capacity is 1, then used is (1 - r) + s. So the utilization is (1 - r + s) / 1 = 1 - r + s. But since r is the remaining before adding the item, the new remaining is r - s. So the new utilization is (1 - (r - s)) = 1 - r + s. So higher utilization is better.

But how to combine these factors. Maybe the priority is a combination of the remaining space after insertion (which we want to minimize) and the utilization (which we want to maximize). For example, a weighted sum of (1/(remaining_after)) and utilization. Or perhaps a product.

Alternatively, think of it as a multi-objective optimization. Maybe the priority should be such that bins that can fit the item and have the highest possible utilization after adding the item, but also leave space that's a multiple of some common item sizes. But since it's online, we don't know future items.

Hmm. Another approach: inspired by the "First Fit Decreasing" or other heuristics, but adapted for online. But since items come one by one, we can't sort them. So the priority function must make a smart choice based on current state.

Wait, here's an idea: for each bin, compute a score that is the sum of two terms. The first term is the negative of the remaining space after inserting the item (so higher if less space left). The second term is the square of the remaining space in the bin after insertion. Wait, that might not make sense. Alternatively, maybe the score is (remaining_capacity_after) but inverted. Wait, no. Let me think again.

If the remaining capacity after adding the item is 'r', then we want to minimize 'r'. So the priority could be -r. But that's exactly what Best Fit does. So the highest priority is the bin with the smallest 'r' (i.e., the best fit).

But maybe we can add a term that encourages bins that are already more filled. For example, if a bin has a higher existing utilization, it's better to fill it up first. So the priority could be a combination of the remaining after insertion and the current utilization.

Alternatively, consider the harmonic mean between the current utilization and the new utilization. Or some other mathematical function.

Another angle: the score could be the product of the remaining capacity after insertion and the current remaining capacity. Wait, that might not be helpful. Let's see: if a bin has a remaining capacity of 0.5, and the item is 0.3, then after insertion, remaining is 0.2. The product would be 0.5 * 0.2 = 0.1. But another bin with remaining 0.4 and item 0.3 would have product 0.4 * 0.1 = 0.04. Lower product is better, so higher priority. Hmm, but this might not capture the right intuition.

Alternatively, the score could be the sum of the current remaining and the remaining after insertion. For example, if a bin has remaining 0.5, and after adding 0.3, it's 0.2. The sum is 0.5 + 0.2 = 0.7. Another bin with remaining 0.4 and item 0.3 would sum 0.4 + 0.1 = 0.5. Lower sum is better. But how does this compare to just using the remaining after insertion?

Alternatively, the score could be the remaining after insertion divided by the current remaining. For example, 0.2 / 0.5 = 0.4, and 0.1 / 0.4 = 0.25. Lower values are better, so higher priority. But this ratio might favor bins where the item takes a larger proportion of the remaining space. For example, if a bin has 0.3 remaining and the item is 0.2, the ratio is 0.1/0.3 = 0.333. Another bin with 0.4 remaining and item 0.3, ratio is 0.1/0.4=0.25. So the second bin would have a lower ratio, hence higher priority. But in this case, both leave 0.1, so same as Best Fit. But maybe this ratio helps in other cases.

Alternatively, the score could be (current remaining) - (remaining after insertion) = item size. But that's the same for all bins that can fit the item, so not useful.

Wait, perhaps the priority should be a combination of how tightly the item fits and how much the bin is already filled. For example, a bin that is already 80% full and can take the item (which would make it 90% full) might be better than a bin that is 10% full and can take the item to become 20% full, even if the remaining space after is the same. Because the first bin is closer to being fully utilized.

So maybe the priority should be higher for bins that, after adding the item, have a higher utilization. So the priority score is (1 - (remaining - item)) which is the new utilization. So for each bin, the new utilization is (original capacity - (remaining_cap - item)) / original capacity. Assuming original capacity is 1, it's (1 - (r - s)) = 1 - r + s. So the priority is 1 - r + s. But since r is the current remaining, and s is the item size. Wait, but 1 - r is the current utilization. So the new utilization is current_utilization + s. So the priority is current_utilization + s. But that's the same as (1 - r) + s. So the priority would be higher for bins where the current utilization plus the item's size is higher. But this might not account for the remaining space after insertion.

Alternatively, the priority could be the new utilization (1 - (r - s)) which is 1 - r + s. So higher is better. But this is equivalent to (current_utilization + s). For example, a bin with r=0.5 (current_utilization 0.5) and s=0.3 would have new utilization 0.8. Another bin with r=0.6 (current_utilization 0.4) and s=0.3 would have new utilization 0.7. So the first bin is better. But in this case, the remaining after insertion is 0.2 vs 0.3. So the first bin is better, which aligns with Best Fit. But this approach would prioritize higher new utilization, which is the same as Best Fit. Because the new utilization is 1 - (r - s) = (1 - r) + s. So the priority is (current_utilization + s). But since s is the same for all bins, the priority is higher for bins with higher current_utilization. So this would be equivalent to Best Fit, because the current_utilization is (1 - r), so the priority is (1 - r) + s. But since s is fixed, the priority is higher for bins with higher (1 - r), i.e., lower remaining capacity. So this is equivalent to Best Fit. Because Best Fit chooses the bin with the smallest remaining after insertion, which is equivalent to the largest (1 - (r - s)) = new utilization.

Wait, no. Let's see: Best Fit picks the bin with the smallest remaining after insertion. The remaining after insertion is (r - s). So the priority for Best Fit is -(r - s). So the highest priority is the bin with the smallest (r - s). The new utilization is (1 - (r - s)) = 1 - r + s. So maximizing new utilization is the same as minimizing (r - s), which is Best Fit. So using new utilization as the priority is the same as Best Fit.

So if I use the new utilization as the priority, that's equivalent to Best Fit. But maybe we can modify it. For example, add a term that also considers the remaining space in a way that encourages certain distributions.

Another idea: consider the square of the remaining space after insertion. For example, the score could be -(r - s) - (r - s)^2. This would penalize larger remaining spaces more. But I'm not sure.

Alternatively, use a weighted sum of the remaining after insertion and the current remaining. For example, 0.7*(r - s) + 0.3*r. But this would need to be minimized. Wait, but how to combine them. Maybe the priority is a combination that prefers bins that are already more full and can fit the item with minimal waste.

Wait, here's a different approach inspired by the "Almost Full" heuristic. If a bin can fit the item and the remaining after insertion is below a certain threshold (like 0.1), then prioritize those bins. Otherwise, use Best Fit. But how to encode that into a priority function.

Alternatively, the priority could be a function that gives a very high score to bins where the remaining after insertion is below a certain epsilon (like 0.1), and otherwise uses Best Fit. But this requires setting a threshold, which might not be dynamic.

Alternatively, use a sigmoid function to give higher scores to bins where the remaining after insertion is small, but scaled in a way that's smooth. For example, the priority could be 1 / (1 + exp(k*(r_after - threshold))), where k and threshold are parameters. This would create a smooth transition, but requires parameter tuning.

But since the problem is online, we can't tune parameters. So perhaps a parameter-free approach.

Another idea: the priority is the reciprocal of the remaining after insertion, multiplied by the current utilization. So (1/(r_after)) * (1 - r). This way, bins that have less remaining after insertion (higher 1/(r_after)) and higher current utilization (1 - r) get higher scores. For example, if a bin has r=0.5, s=0.3, then r_after=0.2. The score is (1/0.2) * 0.5 = 5 * 0.5 = 2.5. Another bin with r=0.6, s=0.3, r_after=0.3. Score is (1/0.3)*0.4 ≈ 1.333. So the first bin has higher priority. This combines both the remaining after insertion and the current utilization. This might encourage packing into bins that are already more utilized and leave less space.

Alternatively, the product of the new utilization and the reciprocal of the remaining after. New utilization is (1 - r_after) = 1 - (r - s) = 1 - r + s. So the product would be (1 - r + s) * (1/(r - s)). But this could be (1 - r_after) / r_after. For example, if r_after is 0.2, then (0.8)/0.2 =4. If r_after is 0.3, then 0.7/0.3 ≈2.333. So higher for smaller r_after. But this is similar to Best Fit but scaled by the new utilization.

Alternatively, the priority could be (1 - r_after) + (1 / (r_after + epsilon)), where epsilon is a small value to prevent division by zero. This way, the priority increases with higher new utilization and smaller remaining after. But this might overemphasize the reciprocal term.

Hmm. Let's think of a concrete example. Suppose we have two bins:

Bin A: remaining capacity 0.5. Item size is 0.3. After insertion, remaining is 0.2. New utilization is 0.8.

Bin B: remaining capacity 0.4. Item size is 0.3. After insertion, remaining is 0.1. New utilization is 0.9.

Best Fit would choose Bin B because 0.1 < 0.2. The reciprocal approach (1/(r_after)) would give Bin B a higher score (10 vs 5). If we multiply by current utilization (1 - r), then for Bin A: (1/0.2) * (1 - 0.5) =5 *0.5=2.5. Bin B: (1/0.1) * (1-0.4)=10 *0.6=6. So Bin B is better. So this approach would work.

Another example: Bin C has remaining 0.3, item 0.25. After insertion, remaining 0.05. Current utilization is 0.7. Score is (1/0.05) *0.7=20 *0.7=14. Bin D has remaining 0.2, item 0.15. After insertion, remaining 0.05. Current utilization is 0.8. Score is (1/0.05)*0.8=20*0.8=16. So Bin D would be chosen, even though both have same remaining after. But since current utilization is higher, it's better. So this approach might help in cases where multiple bins have the same remaining after insertion, preferring the one that was already more full.

This seems promising. So the priority function would be:

For each bin, if the bin can fit the item (r >= s), then the priority is (1/(r - s + epsilon)) * (1 - r). Else, -infinity.

But adding epsilon to avoid division by zero. Also, (1 - r) is the current utilization. So this combines the reciprocal of the remaining after insertion (encouraging tight fits) and the current utilization (encouraging filling up bins that are already more full).

Another example: two bins with same remaining after insertion. Bin X has r=0.4, s=0.3. r_after=0.1. Current utilization is 0.6. Score: (1/0.1) *0.6=10*0.6=6. Bin Y has r=0.3, s=0.2. r_after=0.1. Current utilization is 0.7. Score: (1/0.1)*0.7=7. So Bin Y is preferred. This makes sense because even though both have same remaining after, Bin Y was more utilized before adding the item.

So this heuristic combines Best Fit with a preference for bins that are already more filled. This could lead to better overall utilization by consolidating items into fewer bins.

Another consideration: when the item is large, it's better to place it in a bin that can accommodate it with as little space left as possible. The reciprocal term would handle that. The current utilization term would help in cases where multiple bins can fit the item similarly.

So the code would need to compute for each bin:

if bin_remain_cap[i] >= item:

    score[i] = (1 / (bin_remain_cap[i] - item + 1e-9)) * (1 - (bin_remain_cap[i] - item) - item? Wait, no. Wait, the current utilization is (original capacity - remaining capacity). Assuming original capacity is 1, current utilization is 1 - bin_remain_cap[i]. So the term (1 - bin_remain_cap[i]) is the current utilization. So the code would multiply (1 - bin_remain_cap[i]) by the reciprocal of (bin_remain_cap[i] - item) plus a small epsilon.

Wait, no. The current utilization is 1 - bin_remain_cap[i]. The new utilization after adding the item is 1 - (bin_remain_cap[i] - item) = 1 - bin_remain_cap[i] + item. But in the priority function, we are using the current utilization (before adding the item) multiplied by the reciprocal of the remaining after insertion.

So the code would be:

scores = np.where(
    bins_remain_cap >= item,
    (1 / (bins_remain_cap - item + 1e-9)) * (1 - bins_remain_cap),
    -np.inf
)

Wait, but (1 - bins_remain_cap) is the current utilization. So the score is (current utilization) * (1 / (remaining after insertion)).

Yes. So this combines both factors. Bins that are more utilized and have less remaining after insertion get higher scores.

But wait, if a bin has a high current utilization (1 - r is high) and after adding the item, the remaining is small (r - s is small), then the product is high. This seems like a good combination.

So this would be the priority_v2 function. Let's code this.

But also, need to handle cases where bins_remain_cap is exactly equal to the item. Then, (r - s) is zero. Adding epsilon (1e-9) prevents division by zero.

So the code would be:

import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    # Calculate remaining capacity after inserting the item
    remaining_after = bins_remain_cap - item
    valid_mask = remaining_after >= 0
    # Current utilization is 1 - bins_remain_cap (assuming bin size 1)
    current_utilization = 1 - bins_remain_cap
    # Calculate priority scores
    scores = np.where(
        valid_mask,
        (1 / (remaining_after + 1e-9)) * current_utilization,
        -np.inf
    )
    return scores

Wait, but current_utilization is 1 - bins_remain_cap. So for a bin with remaining capacity 0.5, current_utilization is 0.5. Then, after adding an item of 0.3, remaining_after is 0.2. The score is (1/0.2) * 0.5 = 2.5. Another bin with remaining 0.4 and item 0.3: remaining_after 0.1, current_utilization 0.6. Score is 10 * 0.6 =6. So this bin is preferred.

Yes, this seems correct. So the code would look like that. Also, using np.where to set invalid bins to -infinity.

Another test case: item is 0.3. Bins_remain_cap = [0.5, 0.4, 0.3]. Then:

For bin 0: remaining_after 0.2, current_utilization 0.5. Score 1/0.2 *0.5=5*0.5=2.5.

Bin1: remaining_after 0.1, current_utilization 0.6. Score 10 *0.6=6.

Bin2: remaining_after 0.0, current_utilization 0.7. Score 1/(0.0 +1e-9) *0.7 ≈ 1e9 *0.7. But this would be a very high number. So this bin would be selected first. Because adding the item fills it exactly.

Yes, that's correct. So this heuristic would prioritize bins that can exactly fit the item (since 1/(0 + epsilon) is very large), then those with the best combination of current utilization and remaining after.

This seems like a good approach. So the code for priority_v2 is as written.
</think>

```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins using radioactive decay-inspired heuristic combining:
    1. Inverse of remaining space after placement (tighter fit = better)
    2. Current utilization of the bin (more utilized = better)
    3. Exponential bonus for near-exact fits"""
    remaining_after = bins_remain_cap - item
    valid_mask = remaining_after >= 0
    
    # Base score combines inverse remaining space and current utilization
    tightness_factor = 1 / (remaining_after + 1e-9)
    utilization_factor = 1 - bins_remain_cap  # Current utilization
    
    # Exponential bonus for bins that would be nearly full after placement
    decay_bonus = np.exp(-10 * remaining_after)
    
    scores = np.where(
        valid_mask,
        tightness_factor * utilization_factor * decay_bonus,
        -np.inf
    )
    return scores
```
