```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Provides heuristics for the Traveling Salesman Problem (TSP) based on the distance matrix.

    This version incorporates a few key ideas, informed by my observations of celestial mechanics, 
    to encourage promising edges and discourage less desirable ones. Just as the planets move 
    in elliptical orbits, favoring proximity to the sun (or in this case, shorter distances),
    and are influenced by the gravitational pull of other bodies (nearby nodes), so too shall our heuristic!

    Specifically, it favors shorter distances, considers node degree (avoiding isolated nodes prematurely),
    and introduces a small stochastic element.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance (primary driver - closer is better, like planetary orbits)
    heuristics = 1 / (distance_matrix + 1e-9)  # Add a small value to avoid division by zero

    # 2. Node degree encouragement (like the gravitational influence of neighboring bodies).
    #   Encourage connections to nodes that don't have many nearby neighbors.
    #   This encourages exploring different regions of the search space, especially at start.
    degree_penalty = np.zeros(n)
    for i in range(n):
        degree_penalty[i] = np.sum(distance_matrix[i, :] < np.median(distance_matrix[i, :])) #nodes that have less than the average distance to this point are its neightbors. The more neighbours, the larger the penalty.

    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics[i, j] *= (1 + np.random.normal(0,0.01)) # adding stochasticity. 
    #Avoid diagonals
    for i in range(n):
      heuristics[i,i] = 0

    return heuristics
```
