```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improves upon the basic 1/distance_matrix heuristic for TSP.

    This heuristic combines several factors to estimate the desirability
    of including an edge:

    1.  Inverse distance: Shorter edges are generally better.
    2.  Node degree penalty: Avoids high-degree nodes early on to encourage
        a more balanced tour.  Calculated from average distances. Edges
        connecting nodes that are, on average, further away from others are preferred.
    3.  Global distance context: Considers the overall distance distribution.  Encourages
        inclusion of edges that are significantly shorter than the average.

    Args:
        distance_matrix: A numpy array representing the distance matrix.

    Returns:
        A numpy array of the same shape as distance_matrix, where each element
        represents the desirability of including the corresponding edge in the TSP tour.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate average distance for each node
    avg_distances = np.mean(distance_matrix, axis=0)

    # Global average distance
    global_avg_distance = np.mean(distance_matrix)


    for i in range(n):
        for j in range(n):
            if i != j:
                # Inverse distance
                distance_component = 1 / distance_matrix[i, j]

                # Node degree penalty/preference (using average distances as proxy for centrality)
                degree_component = avg_distances[i] + avg_distances[j]  # Prefer edges connecting "peripheral" nodes

                #Global distance context:
                global_context_component = np.exp(-(distance_matrix[i, j] / global_avg_distance)) #exp(-x) decays as x grows. Shorter edges get higher weights.


                heuristic_matrix[i, j] = distance_component * (1 / (degree_component)) * global_context_component
            else:
                heuristic_matrix[i, j] = 0  # Avoid self-loops

    return heuristic_matrix
```
