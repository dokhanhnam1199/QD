```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A heuristic function for the Traveling Salesman Problem (TSP) based on a
    combination of inverse distance, node degree (favoring less-connected nodes),
    and a stochastic element to encourage exploration.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances
                                         between cities. distance_matrix[i, j] is
                                         the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each
                      element represents the "promise" or desirability of including
                      the corresponding edge in the TSP tour. Higher values
                      indicate more promising edges.
    """

    n = distance_matrix.shape[0]  # Number of cities

    # 1. Inverse Distance: Shorter distances are more desirable.
    inverse_distance = 1.0 / (distance_matrix + 1e-9) # Avoid division by zero

    # 2. Node Degree:  Penalize already highly connected node.
    degree_penalty = np.ones_like(distance_matrix)
    for i in range(n):
        #Calculate 'attractiveness' from each node.
        attractiveness = inverse_distance[i, :]
        #Scale from 0 to 1
        attractiveness = (attractiveness - np.min(attractiveness)) / (np.max(attractiveness) - np.min(attractiveness) + 1e-9)

        degree_penalty[i, :] = 1- attractiveness # Nodes that are attractive to many others, this link is less preferred

    # 3. Stochastic Element: Add a random component to encourage exploration.
    stochasticity = np.random.rand(n, n) * 0.1  # Small random values

    # Combine the heuristics:
    heuristic_matrix = inverse_distance * degree_penalty + stochasticity

    #Set diagonal to 0 for the trivial solution.
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
