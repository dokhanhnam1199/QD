```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A more sophisticated heuristic for TSP that considers:
    1. Inverse distance: Shorter edges are generally better.
    2. Node degree: Avoid high-degree nodes early on to prevent getting stuck.  Prioritize connecting low degree nodes.
    3. Global connectivity: Prefer edges that contribute to overall connectivity early in the search.

    Args:
        distance_matrix: A numpy array representing the distance matrix.

    Returns:
        A numpy array of the same shape as distance_matrix, representing heuristic values for each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance component
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # Node degree component (initialized equally for all edges at start)
    node_degree = np.ones(n)
    degree_factor = np.zeros_like(distance_matrix, dtype=float)

    for i in range(n):
        for j in range(n):
            if i != j:
                degree_factor[i, j] = (1 / (node_degree[i] + node_degree[j]))

    # Connectivity component (encouraging exploring sparsely connected parts). Initialize to all 1s.
    connectivity_boost = np.ones_like(distance_matrix, dtype=float)

    # Combine the components
    heuristic_matrix = inverse_distance * degree_factor * connectivity_boost
    
    #Zero out diagonals, and where dist = 0.  Also make it symmetric
    for i in range(n):
        for j in range(n):
            if distance_matrix[i,j] == 0:
                heuristic_matrix[i,j] = 0

    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T)/2

    np.fill_diagonal(heuristic_matrix, 0) #ensure no self-loops are preferred
    return heuristic_matrix
```
