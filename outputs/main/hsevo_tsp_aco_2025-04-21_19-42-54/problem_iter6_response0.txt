```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray,
                  epsilon: float = 1e-9,
                  initial_temperature: float = 1.0,
                  sparsification_percentile: float = 40.0,
                  high_variance_threshold: float = 0.1,
                  cooling_high_variance: float = 0.99,
                  cooling_low_variance: float = 0.999,
                  min_temperature: float = 0.01) -> np.ndarray:
    """
    Adaptive Heuristics for TSP Edge Prioritization with Enhanced Contextual Awareness:

    This version integrates more contextual information and adaptive mechanisms for better
    edge prioritization in TSP. It combines gravitational attraction, node desirability,
    and introduces edge-based context and dynamic temperature adjustments.  Sparsification
    is also employed to focus the search.

    Args:
        distance_matrix (np.ndarray): Distance matrix representing the TSP instance.
        epsilon (float): Small value to avoid division by zero.
        initial_temperature (float): Initial temperature for exploration.
        sparsification_percentile (float): Percentile for sparsification.
        high_variance_threshold (float): Threshold for high variance in edge values.
        cooling_high_variance (float): Cooling factor when variance is high.
        cooling_low_variance (float): Cooling factor when variance is low.
        min_temperature (float): Minimum temperature to prevent it from becoming too small.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution.
                     Higher values suggest higher priority. Sparsified.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # 1. Node Desirability Scores (Normalized):
    node_desirability = np.zeros(n)
    for i in range(n):
        node_desirability[i] = np.sum(1.0 / (distance_matrix[i, :] + epsilon))  # Sum of inverse distances
    node_desirability = (node_desirability - np.min(node_desirability)) / (np.max(node_desirability) - np.min(node_desirability) + epsilon) # Normalize 0-1

    # 2. Edge Attraction (Gravitational, Normalized):
    edge_attraction = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                edge_attraction[i, j] = (1.0 / (distance_matrix[i, j]**2 + epsilon))
            else:
                edge_attraction[i, j] = 0.0

    edge_attraction = (edge_attraction - np.min(edge_attraction)) / (np.max(edge_attraction) - np.min(edge_attraction) + epsilon)  # Normalize between 0 and 1

    # 3. Edge Context:  Encourage edges that "bridge gaps" between distant nodes.
    #    For each edge (i,j), look at the *minimum* distance from i to any other node *except* j,
    #    and the minimum distance from j to any other node *except* i.  Smaller minimum distances
    #    suggest that i and j are already well-connected, and (i,j) is less valuable.

    edge_context = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                min_dist_i = np.min(distance_matrix[i, np.arange(n) != j])
                min_dist_j = np.min(distance_matrix[j, np.arange(n) != i])
                edge_context[i, j] = 1.0 / (min_dist_i + min_dist_j + epsilon)  # Inverse sum of min distances
            else:
                edge_context[i, j] = 0.0

    edge_context = (edge_context - np.min(edge_context)) / (np.max(edge_context) - np.min(edge_context) + epsilon)  # Normalize 0-1
    # 4. Adaptive Temperature:
    temperature = initial_temperature

    # Combine all factors (with temperature)
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics[i, j] = (edge_attraction[i, j] *
                                     (node_desirability[i] + node_desirability[j]) *
                                     edge_context[i, j] *  # Include edge context
                                     temperature)
            else:
                heuristics[i, j] = 0.0

    # 5. Sparsification:
    threshold = np.percentile(heuristics[heuristics > 0], sparsification_percentile)
    heuristics[heuristics < threshold] = 0.0

    # 6. Adaptive Cooling (based on *non-zero* values)
    edge_values = heuristics[heuristics > 0]
    if len(edge_values) > 0:
        edge_variance = np.var(edge_values)
    else:
        edge_variance = 0.0

    if edge_variance > high_variance_threshold:
        temperature *= cooling_high_variance
    else:
        temperature *= cooling_low_variance

    temperature = max(temperature, min_temperature)

    return heuristics
```
