```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for the Traveling Salesman Problem (TSP) based on distance.

    This version incorporates several ideas:

    1.  Inverse Distance:  As in v1, shorter distances are initially preferred.
    2.  Greedy Start Bias: To encourage better starting edges for local search, prefer edges that link to locations
        that have smaller summed distances to all others.
    3.  Global connection boost: Edges that bridge regions of high density, represented
        by distant neighbors are somewhat preferred.  It tries to help 'stitch together'
        separated clusters.
    4. Prevent Self-Loops: Explicitly sets the heuristic value of self-loops (distance of 0) to 0.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance (primary heuristic)
    heuristics = 1.0 / (distance_matrix + 1e-9)  # Avoid division by zero

    # Calculate node 'importance' (sum of distances to all other nodes)
    node_importance = np.sum(distance_matrix, axis=1)

    # Node bias. Preferentially links two "important" nodes.
    for i in range(n):
        for j in range(n):
           heuristics[i,j] = heuristics[i, j] * ((1/(node_importance[i]+ 1e-9)) + (1/(node_importance[j] + 1e-9)))

    #Global Connection Boost: Penalize edges to locations already closeby
    for i in range(n):
        for j in range(n):

            avg_dist_to_neighbors_i = np.mean(distance_matrix[i,:])
            avg_dist_to_neighbors_j = np.mean(distance_matrix[j,:])
            heuristics[i,j] = heuristics[i,j] * (avg_dist_to_neighbors_i + avg_dist_to_neighbors_j)

    # Zero out self-loops (distance of 0)
    for i in range(n):
        heuristics[i, i] = 0.0

    return heuristics
```
