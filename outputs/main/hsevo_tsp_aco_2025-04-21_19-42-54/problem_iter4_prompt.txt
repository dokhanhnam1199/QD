{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Adaptive Heuristics for TSP Edge Prioritization:\n    Combines gravitational attraction with node-based desirability scores and\n    an adaptive temperature to balance exploration and exploitation. Also includes sparsification.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix representing the TSP instance.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution.\n                     Higher values suggest higher priority. Sparsified.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    epsilon = 1e-9  # Small value to avoid division by zero\n\n    # 1. Node Desirability Scores:\n    #    Nodes connected to very long edges are considered \"undesirable\" and vice-versa.\n    node_desirability = np.zeros(n)\n    for i in range(n):\n        node_desirability[i] = np.sum(1.0 / (distance_matrix[i, :] + epsilon))  # Sum of inverse distances\n    node_desirability /= np.max(node_desirability) # Normalize 0-1.  More connected nodes = higher score\n\n    # 2. Adaptive Temperature:\n    #    Start with a high temperature for exploration, decrease adaptively based on the variance\n    #    of edge costs in the current solution. If variance is high, explore more.\n    initial_temperature = 1.0\n    temperature = initial_temperature\n    edge_attraction = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_attraction[i, j] = (1.0 / (distance_matrix[i, j]**2 + epsilon))\n            else:\n                edge_attraction[i, j] = 0.0\n\n    edge_attraction = edge_attraction / np.max(edge_attraction)  # Normalize between 0 and 1\n\n    # Combine all factors and sparsify\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristics[i, j] = edge_attraction[i, j] * (node_desirability[i] + node_desirability[j]) * temperature\n            else:\n                heuristics[i, j] = 0.0\n\n    # 3. Sparsification: Zero out low-probability edges to focus search\n    threshold = np.percentile(heuristics[heuristics > 0], 40)  # Keep top 60%\n    heuristics[heuristics < threshold] = 0.0\n\n    # Adaptive cooling\n    edge_values = heuristics[heuristics > 0]\n\n    if len(edge_values) > 0: #Prevent errors if all zero.\n        edge_variance = np.var(edge_values)\n    else:\n        edge_variance = 0.0 #No edges.\n\n    if edge_variance > 0.1:  #High Variance explore more\n         temperature *= 0.99\n    else: #Low variance, exploit more\n         temperature *= 0.999\n\n    temperature = max(temperature, 0.01)  # Prevent temperature from becoming too small\n\n    return heuristics\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}