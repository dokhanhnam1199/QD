```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improves upon the basic heuristic by incorporating a 'nearest neighbor'
    tendency.  Edges connecting to nodes with generally shorter distances
    are given higher prior probabilities.  This nudges the sampler
    towards more locally optimized solutions.

    Args:
        distance_matrix:  A square numpy array where distance_matrix[i][j]
                          gives the distance between node i and node j.
                          Should be symmetric.

    Returns:
        A numpy array of the same shape as distance_matrix, representing the
        prior probability of including each edge in a solution. Higher
        values indicate a more promising edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate the average distance for each node to all other nodes
    node_averages = np.mean(distance_matrix, axis=1)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Edge desirability based on inverse distance *AND*
                # the combined "nearness" of both connected nodes to others.
                # Nodes that are generally close to others are deemed better connections
                heuristic_matrix[i, j] = (1 / distance_matrix[i, j]) * (1 / (node_averages[i] * node_averages[j])) #Avoid nodes with large average distances to everyone else

                # Scale the value so smaller values get mapped to larger multipliers.
                # Alternatively (1 - (node_averages[i] + node_averages[j]))

                # To ensure the value is between 0 and 1.
                heuristic_matrix[i, j] =  max(0.000001, heuristic_matrix[i, j])


    return heuristic_matrix
```
