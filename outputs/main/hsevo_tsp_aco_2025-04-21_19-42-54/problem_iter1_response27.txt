```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for TSP using a combination of inverse distance and node centrality.

    The idea here is to favor edges that are short and connect to nodes that are centrally located in the graph.
    This aims to prevent solutions that branch out to distant nodes early on.

    Args:
        distance_matrix: A NumPy ndarray representing the distance matrix for the TSP.

    Returns:
        A NumPy ndarray of the same shape as the input distance matrix,
        where each element represents the "promise" of including the corresponding edge in a solution.
    """

    n = distance_matrix.shape[0]

    # Inverse distance heuristic
    inverse_distance = 1 / (distance_matrix + np.eye(n)) # Add identity to avoid division by zero for self-loops.  Self-loops aren't part of TSP, but numerical stability matters

    # Node centrality heuristic (degree centrality based on inverse distances)
    node_centrality = np.sum(inverse_distance, axis=1) # Sum of inverse distances for each node, giving how well a node connected to the rest.

    # Edge-wise centrality (product of the centrality of the two nodes connected by an edge)
    edge_centrality = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            edge_centrality[i, j] = node_centrality[i] * node_centrality[j]

    # Combine the heuristics
    # Adding small constance for numerical stability,
    # scaling the distance with node centrality information
    heuristic_matrix = inverse_distance * (edge_centrality**0.5 + 1e-9)

    return heuristic_matrix
```
