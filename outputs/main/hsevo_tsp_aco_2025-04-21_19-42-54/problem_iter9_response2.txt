```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray,
                  epsilon: float = 2.5408635945870555e-07,
                  initial_temperature: float = 3.301010802589493,
                  sparsification_percentile: float = 49.22462731911484,
                  high_variance_threshold: float = 0.46775928005587575,
                  cooling_high_variance: float = 0.9952012128425347,
                  cooling_low_variance: float = 0.9959702645502414,
                  min_temperature: float = 0.056679815478619666) -> np.ndarray:
    """
    Adaptive Heuristics for TSP Edge Prioritization:
    Combines gravitational attraction with node-based desirability scores,
    an adaptive temperature, pheromone-inspired reinforcement, and dynamic sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix representing the TSP instance.
        epsilon (float): Small value to avoid division by zero.
        initial_temperature (float): Initial temperature for exploration.
        sparsification_percentile (float): Percentile for sparsification.
        high_variance_threshold (float): Threshold for high variance in edge values.
        cooling_high_variance (float): Cooling factor when variance is high.
        cooling_low_variance (float): Cooling factor when variance is low.
        min_temperature (float): Minimum temperature to prevent it from becoming too small.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution.
                     Higher values suggest higher priority. Sparsified.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # 1. Node Desirability Scores:
    node_desirability = np.zeros(n)
    for i in range(n):
        node_desirability[i] = np.sum(1.0 / (distance_matrix[i, :] + epsilon))  # Sum of inverse distances
    node_desirability /= np.max(node_desirability)  # Normalize 0-1

    # 2. Edge Attraction (Gravity):
    edge_attraction = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                edge_attraction[i, j] = (1.0 / (distance_matrix[i, j]**2 + epsilon))
            else:
                edge_attraction[i, j] = 0.0

    edge_attraction = edge_attraction / np.max(edge_attraction)  # Normalize between 0 and 1

    # 3. Pheromone-Inspired Reinforcement: (Initially uniform)
    pheromone_matrix = np.ones_like(distance_matrix) * 0.1 #Small Initial values. Avoids early bias

    # 4. Adaptive Temperature:
    temperature = initial_temperature

    # --- Iteration to refine heuristics ---
    num_iterations = 5 # Adjust as needed;  More iterations, more refine.
    for iteration in range(num_iterations):
        # Combine factors:
        for i in range(n):
            for j in range(n):
                if i != j:
                    heuristics[i, j] = edge_attraction[i, j] * (node_desirability[i] + node_desirability[j]) * \
                                        pheromone_matrix[i, j] * temperature
                else:
                    heuristics[i, j] = 0.0

        # 5. Dynamic Sparsification: Adjust percentile based on iteration
        current_percentile = sparsification_percentile + (iteration / num_iterations) * (100 - sparsification_percentile) * 0.2 # Increase percentile over time
        threshold = np.percentile(heuristics[heuristics > 0], current_percentile)
        heuristics[heuristics < threshold] = 0.0

        # Adaptive cooling
        edge_values = heuristics[heuristics > 0]

        if len(edge_values) > 0:
            edge_variance = np.var(edge_values)
        else:
            edge_variance = 0.0

        if edge_variance > high_variance_threshold:
            temperature *= cooling_high_variance
        else:
            temperature *= cooling_low_variance

        temperature = max(temperature, min_temperature)

        # Simulated "solution sampling" and Pheromone update (simplified):
        # In a real scenario, this would involve generating candidate solutions
        # and updating pheromones based on the quality of those solutions.
        # Here, we simulate it by increasing pheromone values for edges with high heuristics values.
        pheromone_update_factor = 0.1 #Adjust.
        for i in range(n):
            for j in range(n):
                if heuristics[i, j] > 0:
                    pheromone_matrix[i, j] += pheromone_update_factor * heuristics[i, j]
        pheromone_matrix /= np.max(pheromone_matrix) #Normalize to prevent dominance

    return heuristics
```
