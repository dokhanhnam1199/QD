```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray,
                  epsilon: float = 1e-9,
                  initial_temperature: float = 1.0,
                  sparsification_percentile: float = 40.0,
                  high_variance_threshold: float = 0.1,
                  cooling_high_variance: float = 0.99,
                  cooling_low_variance: float = 0.999,
                  min_temperature: float = 0.01) -> np.ndarray:
    """
    Adaptive Heuristics for TSP Edge Prioritization (v2):
    Combines gravitational attraction, node-based desirability scores,
    adaptive temperature, and edge frequency from sampled solutions.

    Args:
        distance_matrix (np.ndarray): Distance matrix representing the TSP instance.
        epsilon (float): Small value to avoid division by zero. Default is 1e-9.
        initial_temperature (float): Initial temperature for exploration. Default is 1.0.
        sparsification_percentile (float): Percentile for sparsification. Default is 40.0.
        high_variance_threshold (float): Threshold for high variance in edge values. Default is 0.1.
        cooling_high_variance (float): Cooling factor when variance is high. Default is 0.99.
        cooling_low_variance (float): Cooling factor when variance is low. Default is 0.999.
        min_temperature (float): Minimum temperature to prevent it from becoming too small. Default is 0.01.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution.
                     Higher values suggest higher priority. Sparsified.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # 1. Node Desirability Scores:
    node_desirability = np.zeros(n)
    for i in range(n):
        node_desirability[i] = np.sum(1.0 / (distance_matrix[i, :] + epsilon))
    node_desirability /= np.max(node_desirability)

    # 2. Edge Attraction (Gravitational):
    edge_attraction = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                edge_attraction[i, j] = (1.0 / (distance_matrix[i, j]**2 + epsilon))
            else:
                edge_attraction[i, j] = 0.0
    edge_attraction = edge_attraction / np.max(edge_attraction)

    # 3. Edge Frequency (Simulated Annealing Samples):
    #    Sample a few solutions using simulated annealing and track edge frequencies.
    num_samples = 10  # Reduced sample size for speed
    edge_frequency = np.zeros_like(distance_matrix)

    def simulated_annealing_sample(distance_matrix, initial_temperature, cooling_rate, min_temperature):
        n = distance_matrix.shape[0]
        current_solution = np.random.permutation(n)
        best_solution = current_solution.copy()
        current_cost = calculate_cost(distance_matrix, current_solution)
        best_cost = current_cost

        temperature = initial_temperature
        while temperature > min_temperature:
            # Generate neighbor solution by swapping two cities
            i, j = np.random.choice(n, 2, replace=False)
            neighbor_solution = current_solution.copy()
            neighbor_solution[i], neighbor_solution[j] = neighbor_solution[j], neighbor_solution[i]
            neighbor_cost = calculate_cost(distance_matrix, neighbor_solution)

            # Accept or reject the neighbor solution
            delta_cost = neighbor_cost - current_cost
            if delta_cost < 0 or np.random.rand() < np.exp(-delta_cost / temperature):
                current_solution = neighbor_solution
                current_cost = neighbor_cost

                if current_cost < best_cost:
                    best_solution = current_solution.copy()
                    best_cost = current_cost

            temperature *= cooling_rate
        return best_solution


    def calculate_cost(distance_matrix, solution):
        cost = 0
        n = len(solution)
        for i in range(n - 1):
            cost += distance_matrix[solution[i], solution[i+1]]
        cost += distance_matrix[solution[n-1], solution[0]]
        return cost


    for _ in range(num_samples):
        sample_solution = simulated_annealing_sample(distance_matrix, initial_temperature, cooling_low_variance, min_temperature) #Keep temp params lower
        for i in range(n - 1):
            edge_frequency[sample_solution[i], sample_solution[i+1]] += 1
            edge_frequency[sample_solution[i+1], sample_solution[i]] += 1 #Symmetric
        edge_frequency[sample_solution[n-1], sample_solution[0]] += 1
        edge_frequency[sample_solution[0], sample_solution[n-1]] += 1

    edge_frequency /= np.max(edge_frequency + epsilon) # Normalize

    # 4. Adaptive Temperature:
    temperature = initial_temperature

    # Combine factors:
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics[i, j] = (edge_attraction[i, j] + node_desirability[i] + node_desirability[j] + edge_frequency[i, j]) * temperature #Evenly weighted
            else:
                heuristics[i, j] = 0.0

    # Normalize Heuristics
    heuristics /= np.max(heuristics + epsilon)

    # 5. Sparsification:
    threshold = np.percentile(heuristics[heuristics > 0], sparsification_percentile)
    heuristics[heuristics < threshold] = 0.0

    # 6. Adaptive Cooling:
    edge_values = heuristics[heuristics > 0]
    if len(edge_values) > 0:
        edge_variance = np.var(edge_values)
    else:
        edge_variance = 0.0

    if edge_variance > high_variance_threshold:
        temperature *= cooling_high_variance
    else:
        temperature *= cooling_low_variance

    temperature = max(temperature, min_temperature)

    return heuristics
```
