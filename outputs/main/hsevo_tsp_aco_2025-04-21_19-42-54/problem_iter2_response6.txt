```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines inverse distance, node importance, and global connection boost.
    Dynamically balances exploitation/exploration.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance
    heuristics = 1.0 / (distance_matrix + 1e-9)

    # Node importance
    node_importance = np.sum(distance_matrix, axis=1)
    for i in range(n):
        for j in range(n):
           heuristics[i,j] = heuristics[i, j] * ((1/(node_importance[i]+ 1e-9)) + (1/(node_importance[j] + 1e-9)))

    # Global Connection Boost
    for i in range(n):
        for j in range(n):
            avg_dist_to_neighbors_i = np.mean(distance_matrix[i,:])
            avg_dist_to_neighbors_j = np.mean(distance_matrix[j,:])
            heuristics[i,j] = heuristics[i,j] * (avg_dist_to_neighbors_i + avg_dist_to_neighbors_j)

    # Sparsify (Adaptive)
    threshold = np.mean(heuristics) * 0.1 #dynamic sparsification
    heuristics[heuristics < threshold] = 0

    # Zero out self-loops
    for i in range(n):
        heuristics[i, i] = 0.0

    return heuristics
```
