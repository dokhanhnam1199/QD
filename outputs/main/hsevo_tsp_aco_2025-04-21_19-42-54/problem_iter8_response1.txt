```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """Adaptive heuristics with inverse distance, node desirability, and sparsification."""
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    epsilon = 1e-9
    temperature = 1.0

    # Node Desirability (like v0)
    node_desirability = np.zeros(n)
    for i in range(n):
        node_desirability[i] = np.sum(1.0 / (distance_matrix[i, :] + epsilon))
    node_desirability /= np.max(node_desirability)

    # Inverse Distance (like v1)
    inverse_distance = 1.0 / (distance_matrix + epsilon)

    # Combine Node Desirability and Inverse Distance
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics[i, j] = inverse_distance[i, j] * (node_desirability[i] + node_desirability[j])
            else:
                heuristics[i, j] = 0.0

    # Adaptive Sparsification (like v1, but adaptive threshold)
    threshold = np.mean(heuristics[heuristics > 0]) * 0.5  # Dynamic threshold
    heuristics[heuristics < threshold] = 0.0

    # Normalize (like v1)
    max_val = np.max(heuristics)
    min_val = np.min(heuristics)
    if max_val > min_val:
        heuristics = (heuristics - min_val) / (max_val - min_val)
    else:
        heuristics = np.zeros_like(heuristics)
    
    temperature *= 0.995

    return heuristics
```
