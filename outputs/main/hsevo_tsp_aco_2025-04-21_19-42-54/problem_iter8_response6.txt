```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """Adaptive heuristic: Node desirability, gravity, sparsification."""

    epsilon: float = 2.5408635945870555e-07
    initial_temperature: float = 3.301010802589493
    sparsification_percentile: float = 49.22462731911484
    high_variance_threshold: float = 0.46775928005587575
    cooling_high_variance: float = 0.9952012128425347
    cooling_low_variance: float = 0.9959702645502414
    min_temperature: float = 0.056679815478619666

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Node desirability
    node_desirability = np.zeros(n)
    for i in range(n):
        node_desirability[i] = np.sum(1.0 / (distance_matrix[i, :] + epsilon))
    node_desirability /= np.max(node_desirability)

    # Edge attraction (gravity)
    edge_attraction = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                edge_attraction[i, j] = (1.0 / (distance_matrix[i, j]**2 + epsilon))
            else:
                edge_attraction[i, j] = 0.0

    edge_attraction = edge_attraction / np.max(edge_attraction)

    # Contextual Node Connectivity (New)
    node_connectivity = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                # Count common neighbors
                common_neighbors = 0
                for k in range(n):
                    if k != i and k != j:
                        common_neighbors += (1 if (distance_matrix[i, k] < np.inf and distance_matrix[j, k] < np.inf) else 0) # Check for valid edges, instead of 0 distance
                node_connectivity[i, j] = common_neighbors / (n - 2 + epsilon) # normalized
            else:
                node_connectivity[i, j] = 0.0

    node_connectivity = 1 - node_connectivity #Inverse: High value if nodes *aren't* connected.

    # Adaptive temperature
    temperature = initial_temperature

    # Combine factors
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics[i, j] = edge_attraction[i, j] * (node_desirability[i] + node_desirability[j]) * node_connectivity[i,j] * temperature
            else:
                heuristics[i, j] = 0.0

    # Sparsification
    threshold = np.percentile(heuristics[heuristics > 0], sparsification_percentile)
    heuristics[heuristics < threshold] = 0.0

    # Adaptive cooling
    edge_values = heuristics[heuristics > 0]
    if len(edge_values) > 0:
        edge_variance = np.var(edge_values)
    else:
        edge_variance = 0.0

    if edge_variance > high_variance_threshold:
        temperature *= cooling_high_variance
    else:
        temperature *= cooling_low_variance

    temperature = max(temperature, min_temperature)

    return heuristics
```
