```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Generates heuristic values for the Traveling Salesman Problem (TSP) based on a combination of inverse distance,
    relative distance compared to the node's nearest neighbors, and an added "Tesla-inspired" stochasticity.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                        distance_matrix[i, j] is the distance from city i to city j.

    Returns:
        np.ndarray: A matrix of heuristic values. Higher values indicate a more promising edge.
    """

    n = distance_matrix.shape[0]  # Number of cities

    # 1. Inverse Distance: Basic indicator; shorter distances are generally better.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # 2. Nearest Neighbor Context:  How much shorter is this edge compared to other options from the origin node?
    nearest_neighbors = np.zeros((n, n))
    for i in range(n):
        distances_from_i = distance_matrix[i, :]
        sorted_indices = np.argsort(distances_from_i)
        # Consider the 3 nearest neighbors beyond the current candidate
        nearest_neighbor_distance = np.mean(distances_from_i[sorted_indices[1:4]]) #Exclude itself
        nearest_neighbors[i, :] = np.exp(-distance_matrix[i, :] / nearest_neighbor_distance) #Normalized


    # 3. Global Scaling: Scale the combined heuristics to influence solution diversity and convergence.
    global_scale = np.mean(distance_matrix)
    scaling_factor = np.exp(-distance_matrix / global_scale)


    # 4. "Tesla" Stochasticity:  Introduce some randomness, like unpredictable electromagnetic fluctuations.
    # The intensity decreases with global average distance.
    tesla_factor = np.random.rand(n, n) * (1 / (1 + global_scale))


    # Combine the heuristics:  Weighted sum with emphasis on inverse distance.
    heuristic_matrix = (0.6 * inverse_distance +
                        0.3 * nearest_neighbors +
                        0.1 * tesla_factor) * scaling_factor


    return heuristic_matrix
```
