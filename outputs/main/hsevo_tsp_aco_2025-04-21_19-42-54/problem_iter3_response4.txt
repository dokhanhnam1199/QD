```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Enhanced Heuristics for TSP Edge Prioritization:
    Combines gravitational attraction (inverse square distance), node degree bias (favoring less-connected nodes),
    and a simulated annealing-inspired temperature factor with adaptive cooling to balance exploration and exploitation.
    Sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix representing the TSP instance.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution. Higher values suggest higher priority.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Handle potential division by zero or near-zero distances:
    epsilon = 1e-9  # A small value to avoid division by zero

    # Temperature parameter - Decreases as algorithm runs, adaptive cooling.
    initial_temperature = 10.0
    temperature = initial_temperature  # Initial Temperature - High initially allows exploration.
    min_temperature = 0.01 # Minimum Temperature
    cooling_rate = 0.995
    adaptive_cooling_threshold = 0.05 #When to trigger a slower cooling

    # Node degree bias (favor less-connected nodes - initially uniform).  Will become dynamic during search (simulated annealing will be used to select edges)
    node_degrees = np.ones(n)  # Initially all nodes are considered equally unconnected


    # Gravitational attraction component (scaled and temperature modulated):
    for i in range(n):
        for j in range(n):
            if i != j:
                #Edge score combination
                distance_factor = 1.0 / (distance_matrix[i, j]**2 + epsilon)
                degree_factor = node_degrees[i] * node_degrees[j] #Promotes connections to nodes with lower degree
                heuristics[i, j] = distance_factor * degree_factor * temperature
            else:
                heuristics[i, j] = 0.0  # No self-loops

    #Sparsification (attempt to cut off edges that are considered too long, only if temperature is low enough)
    sparsification_threshold = np.mean(heuristics) * 0.1 # Dynamic threshold relative to average heuristic value. Can be further tuned.
    if temperature < 1.0:
      heuristics[heuristics < sparsification_threshold] = 0.0

    # Annealing Schedule - Decay of the temperature (adaptive)
    if np.sum(heuristics > 0) / (n * (n - 1)) < adaptive_cooling_threshold: #If many edges are already zeroed out, cool more slowly
      cooling_rate = 0.999 #Slow down cooling
    temperature *= cooling_rate #Reduce temperature each step (simulates cooling)
    temperature = max(temperature, min_temperature) #Ensure the temperature doesnt drop below the minimum

    return heuristics
```
