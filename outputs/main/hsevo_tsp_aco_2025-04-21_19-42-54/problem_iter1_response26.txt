```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for TSP based on a combination of factors inspired by gravitational concepts
    and simulated annealing. Higher values indicate more promising edges.

    Args:
        distance_matrix: A numpy array representing the distance matrix.

    Returns:
        A numpy array of the same shape as distance_matrix, representing the heuristics.
    """

    # 1. Inverse Distance (Gravity-like attraction)
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # 2. Node Degree Preference (Avoid isolated nodes early on)
    n = distance_matrix.shape[0]
    degree_preference = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                degree_i = np.sum(inverse_distance[i,:]) - inverse_distance[i,i]
                degree_j = np.sum(inverse_distance[j,:]) - inverse_distance[j,j]
                degree_preference[i, j] = (degree_i + degree_j)  # Prefer edges connecting to nodes with higher potential connections.
    
    # 3. "Temperature" Parameter for Simulated Annealing (Adaptive)
    #   Initially high to explore, then gradually decreases to exploit.
    #   This is a simplified concept; a full simulated annealing requires a separate search procedure.

    temperature = np.mean(distance_matrix)  # Initial temperature based on average distance

    #4. Combined Heuristic (Applying some weights and softmax/Boltzmann to promote exploitation after initial exploration).
    combined_heuristic = inverse_distance + 0.1 * degree_preference

    # Softmax to encourage diversity early on but to sharpen selection later
    #  (Inspired by Boltzmann distribution, but simplified).

    normalized_heuristic = np.exp(combined_heuristic / temperature) / np.sum(np.exp(combined_heuristic / temperature))

    return normalized_heuristic
```
