```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Enhanced Heuristics for TSP Edge Prioritization:
    Combines gravitational attraction with adaptive temperature, nearest neighbor considerations,
    and sparsification to focus on promising edges.  It also uses global shortest edge.

    Args:
        distance_matrix (np.ndarray):  Distance matrix representing the TSP instance.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution.  Higher values suggest higher priority.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Epsilon to avoid division by zero:
    epsilon = 1e-9

    # Adaptive Temperature (starts high, decreases based on progress):
    initial_temperature = 10.0
    temperature = initial_temperature

    # Nearest Neighbor Consideration: For each node, find the nearest neighbors.
    nearest_neighbors = []
    for i in range(n):
        distances = distance_matrix[i, :]
        nearest_neighbor_indices = np.argsort(distances)[1:4]  # Exclude self, take top 3 nearest
        nearest_neighbors.append(nearest_neighbor_indices)

    #Global shortest edge:
    min_dist = np.inf
    min_i = -1
    min_j = -1

    for i in range(n):
      for j in range(i + 1, n):
        if distance_matrix[i,j] < min_dist:
          min_dist = distance_matrix[i,j]
          min_i = i
          min_j = j


    # Heuristic calculation:  Gravitational attraction + Nearest Neighbor boost + Temp
    for i in range(n):
        for j in range(n):
            if i != j:
                attraction = (1.0 / (distance_matrix[i, j]**2 + epsilon))

                # Nearest Neighbor Boost: Give a higher value if j is a nearest neighbor of i, or vice-versa.
                neighbor_boost = 0.0
                if j in nearest_neighbors[i] or i in nearest_neighbors[j]:
                    neighbor_boost = 1.5 # Boost factor for nearest neighbors

                #Global shortest edge boost:
                global_boost = 0.0
                if (i == min_i and j == min_j) or (i == min_j and j == min_i):
                    global_boost = 2.0

                heuristics[i, j] = (attraction + neighbor_boost + global_boost) * temperature
            else:
                heuristics[i, j] = 0.0  # No self-loops

    # Sparsification: Zero out edges with very low priority.
    # Calculate a threshold based on the mean heuristic value
    mean_heuristic = np.mean(heuristics)
    sparsification_threshold = 0.1 * mean_heuristic  # Example: keep only top 10% on average

    heuristics[heuristics < sparsification_threshold] = 0.0

    #Adaptive Temperature update based on sparsity
    sparsity = np.sum(heuristics == 0.0) / heuristics.size
    temperature_decay = 0.995 - 0.1 * sparsity # Reduce temp faster when more sparse

    temperature *= temperature_decay
    temperature = max(temperature, 0.01) # Ensure temperature doesn't go to zero.


    return heuristics
```
