{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\nCurrent heuristics:\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Newtonian Heuristics for TSP Edge Prioritization:\n    Combines gravitational attraction (inverse square distance) with a simulated annealing-inspired temperature factor\n    to prioritize shorter edges and prevent premature convergence.\n\n    Args:\n        distance_matrix (np.ndarray):  Distance matrix representing the TSP instance.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution.  Higher values suggest higher priority.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Handle potential division by zero or near-zero distances:\n    epsilon = 1e-9  # A small value to avoid division by zero\n\n    # Temperature parameter - Decreases as algorithm runs\n    temperature = 1.0  # Initial Temperature - High initially allows exploration.\n\n    # Gravitational attraction component (scaled and temperature modulated):\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristics[i, j] = (1.0 / (distance_matrix[i, j]**2 + epsilon)) * temperature\n            else:\n                heuristics[i, j] = 0.0 # No self loops\n\n    # Annealing Schedule - Decay of the temperature\n    temperature *= 0.995 #Reduce temperature each step (simulates cooling)\n    # Can use other annealing functions, such as: temperature = initial_temperature / (1 + np.log(iteration_count))\n\n    return heuristics\n\nNow, think outside the box write a mutated function `heuristics_v2` better than current version.\nYou can use some hints below:\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, here's a redefinition of \"Current self-reflection\" focused on designing better heuristics, avoiding common pitfalls, and a roadmap for improvement:\n\n*   **Keywords:** Heuristic design, exploitation-exploration balance, global context, premature convergence, adaptive strategies, performance metrics.\n\n*   **Advice:** Design heuristics that dynamically adapt their exploration/exploitation ratio based on search progress and problem characteristics. Incorporate global information strategically, using it to guide, not dictate, the search. Rigorously test and benchmark heuristics against diverse problem instances.\n\n*   **Avoid:** Over-reliance on any single strategy (e.g., pure exploitation), neglecting global problem context, ignoring performance metrics and feedback loops.\n\n*   **Explanation:** Effective heuristic design requires a nuanced understanding of the problem landscape. Balance short-term gains with broader exploration guided by global awareness and adapt your strategy based on real-world performance data.\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}