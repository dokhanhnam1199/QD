```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Newtonian Heuristic for TSP Edge Prioritization.

    This heuristic leverages principles inspired by gravitational force and potential energy to estimate
    the desirability of including each edge in the Traveling Salesman Problem (TSP) solution.

    Specifically:
    1.  Inverse Distance: The base heuristic is the inverse of the distance, reflecting a greater
        attraction (probability of inclusion) for shorter edges, akin to stronger gravitational force.
    2.  Edge Neighborhood Consideration:
        a.  The mean distance to other points from each endpoint of an edge is computed. Edges connecting
            nodes with shorter mean distances to all other nodes are favored, mimicking a system trying to minimize potential energy.

    3. Balancing global and local cost: favors edges which not only connect 'close' points, but also favors segments where the source and destinate node have a short average distance to all the others nodes.

    Returns:
        np.ndarray: A matrix of the same shape as the distance matrix, representing the heuristic
                      score for each edge. Higher scores indicate a higher probability of the edge
                      being included in the optimal TSP tour.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Base heuristic: inverse distance
                base_heuristic = 1 / distance_matrix[i, j]

                # Neighborhood consideration: mean distance from endpoints to all other points
                mean_dist_i = np.mean(distance_matrix[i, :])
                mean_dist_j = np.mean(distance_matrix[j, :])
                neighborhood_heuristic = 1 / (mean_dist_i + mean_dist_j) # Lower means stronger

                # Combine heuristics - try using multiplication, which balances the local vs. global effects:
                heuristic_matrix[i, j] = base_heuristic * neighborhood_heuristic


    return heuristic_matrix
```
