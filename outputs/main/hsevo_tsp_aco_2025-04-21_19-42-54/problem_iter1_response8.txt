```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improves upon v1 by incorporating a "gravity" towards the center of the nodes
    and penalizing edges that cross far from the center, potentially leading to
    more compact and efficient routes. It also combines information about minimal outgoing edges,
    avoiding premature convergence and promoting exploration.

    Args:
        distance_matrix: A numpy ndarray representing the distance matrix.

    Returns:
        A numpy ndarray of the same shape as distance_matrix, representing the
        heuristic values for each edge.
    """
    n = distance_matrix.shape[0]

    # 1. Inverse distance (basic heuristic)
    heuristic_matrix = 1 / (distance_matrix + 1e-9)  # Adding a small value to avoid division by zero

    # 2. Center of the nodes (proxy for geographical center)
    center_x = np.mean(np.arange(n))
    center_y = np.mean(np.arange(n))

    # 3. Calculate distances from each node to the center
    center_distances = np.sqrt((np.arange(n) - center_x)**2 + (np.arange(n) - center_y)**2)

    # 4. Heuristic factor based on proximity to the center
    center_proximity_factor = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
             center_proximity_factor[i,j] = 1.0 - (abs(center_distances[i] - center_distances[j]) / (np.max(center_distances)+1e-9))

    # 5. Minimal outgoing edge bonus: Helps explore different paths by
    #   identifying for each node edges that have small distances.
    min_outgoing_indices = np.argmin(distance_matrix, axis=1)
    min_outgoing_bonus = np.zeros((n, n))
    for i in range(n):
        min_outgoing_bonus[i, min_outgoing_indices[i]] = 1.0 # encourage to take edges that lead to the closest cities, at least once.

    # 6. Combine all factors (weighted)

    heuristic_matrix = (0.6 * heuristic_matrix +
                           0.3 * center_proximity_factor +
                           0.1 * min_outgoing_bonus) # emphasize distance, but consider geographical proximity.

    return heuristic_matrix
```
