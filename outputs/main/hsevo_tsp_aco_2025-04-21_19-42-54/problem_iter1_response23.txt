```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for the Traveling Salesman Problem (TSP) using a combination of inverse distance,
    savings heuristic, and a touch of randomness to encourage exploration.

    Args:
        distance_matrix: A NumPy ndarray representing the distance matrix between cities.

    Returns:
        A NumPy ndarray of the same shape as distance_matrix, representing the prior
        indicator of how promising each edge is. Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # 1. Inverse distance (basic heuristic)
    inverse_distance = 1 / (distance_matrix + np.eye(n))  # Add identity to avoid division by zero on the diagonal
    heuristics += inverse_distance

    # 2. Savings Heuristic:  Measure the "savings" from directly linking two cities rather than going back to a depot (city 0).  Normalize savings by distance.

    depot = 0  # Arbitrarily choose city 0 as the depot/starting point. This can be randomized as well.
    savings = np.zeros_like(distance_matrix)

    for i in range(n):
        for j in range(n):
            if i != j: # Avoid savings between same city
                savings[i, j] = distance_matrix[depot, i] + distance_matrix[depot, j] - distance_matrix[i, j]
    #scale savings by overall distances involved.
    heuristics += savings / (distance_matrix + np.eye(n))
    # 3. Randomness (Encourage exploration)
    randomness = np.random.rand(n, n) * 0.1  # Small random values

    heuristics += randomness

    # 4. Make sure diagnal is small/zero

    heuristics[np.diag_indices_from(heuristics)] = -1
    # 5. Normalize the heuristics
    heuristics = (heuristics - np.min(heuristics)) / (np.max(heuristics) - np.min(heuristics))  # Scale to [0, 1]


    return heuristics
```
