```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines adaptive temperature scaling with sparsification,
    and node density for effective TSP edge prioritization.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    epsilon = 1e-9
    initial_temperature = 10.0
    temperature = initial_temperature
    min_temperature = 0.01
    cooling_rate = 0.995
    adaptive_cooling_threshold = 0.05
    node_degrees = np.ones(n)

    # Gravitational attraction and node degree
    for i in range(n):
        for j in range(n):
            if i != j:
                distance_factor = 1.0 / (distance_matrix[i, j]**2 + epsilon)
                degree_factor = node_degrees[i] * node_degrees[j]
                heuristics[i, j] = distance_factor * degree_factor * temperature
            else:
                heuristics[i, j] = 0.0

    #Sparsification
    sparsification_threshold = np.mean(heuristics) * 0.1
    if temperature < 1.0:
      heuristics[heuristics < sparsification_threshold] = 0.0

    # Annealing Schedule
    if np.sum(heuristics > 0) / (n * (n - 1)) < adaptive_cooling_threshold:
      cooling_rate = 0.999
    temperature *= cooling_rate
    temperature = max(temperature, min_temperature)

    # Node importance using density scaling from v1
    inverse_distance = 1.0 / (distance_matrix + epsilon)
    node_densities = np.zeros(n)
    for i in range(n):
        node_densities[i] = np.mean(inverse_distance[i, :])

    density_scaling = 1.0 / (1.0 + node_densities)
    density_scaling = np.tile(density_scaling, (n, 1))
    density_scaling = np.minimum(density_scaling, density_scaling.T)

    # Apply density scaling
    heuristics = heuristics * density_scaling

    return heuristics
```
