```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for the Traveling Salesman Problem (TSP) based on a combination of
    inverse distance, savings heuristic, and random perturbations, inspired
    by quantum mechanics principles (stochastic sampling with "path integrals").

    Args:
        distance_matrix: A numpy ndarray representing the distance matrix between cities.

    Returns:
        A numpy ndarray of the same shape as distance_matrix, representing the
        prior probability of including each edge in a solution.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance (short distances are preferred)
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Adding a small value to avoid division by zero

    # Savings heuristic (inspired by Clarke-Wright algorithm)
    #  Higher savings indicate a higher likelihood of inclusion.
    savings = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Savings from merging i and j into a route
                savings[i, j] = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j] # assuming start node is 0
                savings[j, i] = distance_matrix[j, 0] + distance_matrix[0, i] - distance_matrix[j, i]

    # Combine inverse distance and savings
    heuristics = inverse_distance + savings # maybe add scaling factors

    # Add a stochastic element -  "quantum fluctuations"
    # This introduces some randomness to allow for exploration of different paths
    # even if some edges seem less promising initially.
    random_perturbation = np.random.normal(0, 0.1, size=(n, n)) # scaled random noise
    heuristics += random_perturbation

    # Ensure the diagonal is zero and all values are non-negative.

    for i in range(n):
        heuristics[i, i] = 0

    heuristics = np.maximum(heuristics, 0) # Ensure probabilities are non-negative


    # Normalize the heuristics
    total_sum = np.sum(heuristics)
    if total_sum > 0:
        heuristics /= total_sum  # Convert to probabilities (optional, but useful)
    else:
        heuristics = np.ones_like(distance_matrix) / (n * (n -1))

    return heuristics
```
