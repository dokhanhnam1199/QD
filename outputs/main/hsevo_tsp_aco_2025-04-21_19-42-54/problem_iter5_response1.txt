```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines inverse distance, node importance, adaptive sparsification.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance
    heuristics = 1.0 / (distance_matrix + 1e-9)

    # Node importance
    node_importance = np.sum(distance_matrix, axis=1)
    for i in range(n):
        for j in range(n):
           heuristics[i,j] = heuristics[i, j] * ((1/(node_importance[i]+ 1e-9)) + (1/(node_importance[j] + 1e-9)))

    # Sparsify (Adaptive)
    threshold = np.mean(heuristics) * 0.1 #dynamic sparsification
    heuristics[heuristics < threshold] = 0

    # Zero out self-loops
    for i in range(n):
        heuristics[i, i] = 0.0

    return heuristics
```
