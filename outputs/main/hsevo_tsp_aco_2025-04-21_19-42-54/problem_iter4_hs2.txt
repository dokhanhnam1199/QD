import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, 
                  epsilon: float = 2.5408635945870555e-07,
                  initial_temperature: float = 3.823959781057867,
                  sparsification_percentile: float = 49.22462731911484,
                  high_variance_threshold: float = 0.26328881235395674,
                  cooling_high_variance: float = 0.9909264314475309,
                  cooling_low_variance: float = 0.9953268216244845,
                  min_temperature: float = 0.006268057898554004) -> np.ndarray:
    """
    Adaptive Heuristics for TSP Edge Prioritization:
    Combines gravitational attraction with node-based desirability scores and
    an adaptive temperature to balance exploration and exploitation. Also includes sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix representing the TSP instance.
        epsilon (float): Small value to avoid division by zero. Default is 1e-9.
        initial_temperature (float): Initial temperature for exploration. Default is 1.0.
        sparsification_percentile (float): Percentile for sparsification. Default is 40.0.
        high_variance_threshold (float): Threshold for high variance in edge values. Default is 0.1.
        cooling_high_variance (float): Cooling factor when variance is high. Default is 0.99.
        cooling_low_variance (float): Cooling factor when variance is low. Default is 0.999.
        min_temperature (float): Minimum temperature to prevent it from becoming too small. Default is 0.01.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution.
                     Higher values suggest higher priority. Sparsified.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # 1. Node Desirability Scores:
    #    Nodes connected to very long edges are considered "undesirable" and vice-versa.
    node_desirability = np.zeros(n)
    for i in range(n):
        node_desirability[i] = np.sum(1.0 / (distance_matrix[i, :] + epsilon))  # Sum of inverse distances
    node_desirability /= np.max(node_desirability) # Normalize 0-1.  More connected nodes = higher score

    # 2. Adaptive Temperature:
    #    Start with a high temperature for exploration, decrease adaptively based on the variance
    #    of edge costs in the current solution. If variance is high, explore more.
    temperature = initial_temperature
    edge_attraction = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                edge_attraction[i, j] = (1.0 / (distance_matrix[i, j]**2 + epsilon))
            else:
                edge_attraction[i, j] = 0.0

    edge_attraction = edge_attraction / np.max(edge_attraction)  # Normalize between 0 and 1

    # Combine all factors and sparsify
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics[i, j] = edge_attraction[i, j] * (node_desirability[i] + node_desirability[j]) * temperature
            else:
                heuristics[i, j] = 0.0

    # 3. Sparsification: Zero out low-probability edges to focus search
    threshold = np.percentile(heuristics[heuristics > 0], sparsification_percentile)  # Keep top 60%
    heuristics[heuristics < threshold] = 0.0

    # Adaptive cooling
    edge_values = heuristics[heuristics > 0]

    if len(edge_values) > 0: #Prevent errors if all zero.
        edge_variance = np.var(edge_values)
    else:
        edge_variance = 0.0 #No edges.

    if edge_variance > high_variance_threshold:  #High Variance explore more
         temperature *= cooling_high_variance
    else: #Low variance, exploit more
         temperature *= cooling_low_variance

    temperature = max(temperature, min_temperature)  # Prevent temperature from becoming too small

    return heuristics
