```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics function for TSP based on a combination of inverse distance and a modified Clarke-Wright savings algorithm.
    This is inspired by both my work and subsequent research into the behavior of particles within certain materials
    (i.e. how edges cluster and minimize overall potential energy/distance traveled).  It assigns higher promise to
    edges that connect nodes which are close to each other, but also considers the potential savings by combining edges
    through a common node (Clarke-Wright).

    Args:
        distance_matrix: A numpy ndarray representing the distance matrix between nodes.

    Returns:
        A numpy ndarray of the same shape as distance_matrix, representing the heuristics scores for each edge.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Basic inverse distance heuristic
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Avoid division by zero

    # Clarke-Wright Savings heuristic (modified for probabilistic guidance)
    savings = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(i + 1, n):
            # Calculate savings for merging routes through node i and j from a central depot (node 0)
            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings[j, i] = savings[i, j]  # Savings are symmetric

    # Normalize savings to be between 0 and 1
    max_savings = np.max(savings)
    if max_savings > 0:
        normalized_savings = savings / max_savings
    else:
        normalized_savings = np.zeros_like(savings)  # No savings to be made.

    # Combine inverse distance and normalized savings
    # Give higher weight to inverse distance for immediate proximity,
    # but incorporate savings to encourage efficient route consolidation
    heuristics = 0.7 * inverse_distance + 0.3 * normalized_savings

    # Ensure diagonal elements are zero (no self-loops)
    np.fill_diagonal(heuristics, 0)

    return heuristics
```
