```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for Traveling Salesman Problem (TSP) based on distance and node degree.

    This function calculates a heuristic score for each edge in the distance matrix,
    indicating how promising it is to include that edge in the final TSP solution.
    The heuristic combines the inverse of distance with a node degree penalty.  Edges
    connected to nodes with fewer connections are preferred.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances
            between all pairs of nodes.  distance_matrix[i, j] is the distance
            from node i to node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each
            element represents the heuristic score for the corresponding edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Calculate node degree desirability: nodes with lower degree should be prioritized.
    # This helps prevent premature closure of sub-tours.

    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] = 1 / (distance_matrix[i, j] + 1e-9) # avoid division by zero
            else:
                heuristic_matrix[i, j] = 0  # No self-loops

    # Normalize to ensure values between 0 and 1, enhancing exploration
    heuristic_matrix = (heuristic_matrix - np.min(heuristic_matrix)) / (np.max(heuristic_matrix) - np.min(heuristic_matrix) + 1e-9)


    #Calculate node degree "attractiveness".
    node_degree = np.sum(heuristic_matrix > 0, axis=0)  # Approximate current node degrees.

    # Modify the heuristic by penalizing higher degree nodes. Favor connecting to low degree nodes.
    for i in range(n):
        for j in range(n):
            if i != j:

                degree_penalty = 1 / (node_degree[i] + node_degree[j] + 1e-9) # Favor low degree connections.

                heuristic_matrix[i,j] = heuristic_matrix[i, j] * degree_penalty #Combines distance and node desirability


    #Re-normalize
    heuristic_matrix = (heuristic_matrix - np.min(heuristic_matrix)) / (np.max(heuristic_matrix) - np.min(heuristic_matrix) + 1e-9)

    return heuristic_matrix
```
