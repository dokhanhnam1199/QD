```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray,
                  epsilon: float = 2.5408635945870555e-07,
                  initial_temperature: float = 3.301010802589493,
                  sparsification_percentile: float = 49.22462731911484,
                  high_variance_threshold: float = 0.46775928005587575,
                  cooling_high_variance: float = 0.9952012128425347,
                  cooling_low_variance: float = 0.9959702645502414,
                  min_temperature: float = 0.056679815478619666,
                  node_degree_weight: float = 0.5,
                  edge_proximity_weight: float = 0.5) -> np.ndarray:
    """
    Enhanced Adaptive Heuristics for TSP Edge Prioritization:

    This version refines the heuristics by incorporating node degree desirability,
    edge proximity, and adaptive temperature control for improved exploration-exploitation balance.
    It dynamically adjusts the weights of different heuristic components based on
    real-time performance and solution context. Sparsification is also applied.

    Args:
        distance_matrix (np.ndarray): Distance matrix representing the TSP instance.
        epsilon (float): Small value to avoid division by zero. Default is 1e-9.
        initial_temperature (float): Initial temperature for exploration. Default is 1.0.
        sparsification_percentile (float): Percentile for sparsification. Default is 40.0.
        high_variance_threshold (float): Threshold for high variance in edge values. Default is 0.1.
        cooling_high_variance (float): Cooling factor when variance is high. Default is 0.99.
        cooling_low_variance (float): Cooling factor when variance is low. Default is 0.999.
        min_temperature (float): Minimum temperature to prevent it from becoming too small. Default is 0.01.
        node_degree_weight (float): Weight for node degree desirability. Default is 0.5.
        edge_proximity_weight (float): Weight for edge proximity. Default is 0.5.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution.
                     Higher values suggest higher priority. Sparsified.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # 1. Node Desirability Scores (Node Degree):
    #    Nodes with higher degree are more desirable, encouraging connection to more nodes.
    node_degree = np.sum(distance_matrix > 0, axis=1)  # Number of neighbors
    node_degree = node_degree / np.max(node_degree) if np.max(node_degree) > 0 else np.zeros(n) # Normalize 0-1

    # 2. Edge Proximity:
    #    Edges connecting nodes that are "close" to other nodes are preferred.
    edge_proximity = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Calculate average distance from i and j to all other nodes
                proximity_i = np.mean(distance_matrix[i, :])
                proximity_j = np.mean(distance_matrix[j, :])
                edge_proximity[i, j] = 1.0 / (distance_matrix[i, j] + epsilon) * (proximity_i + proximity_j)
            else:
                edge_proximity[i, j] = 0.0

    edge_proximity = edge_proximity / np.max(edge_proximity) if np.max(edge_proximity) > 0 else np.zeros_like(distance_matrix)  # Normalize

    # 3. Adaptive Temperature:
    temperature = initial_temperature
    edge_attraction = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                edge_attraction[i, j] = (1.0 / (distance_matrix[i, j]**2 + epsilon))
            else:
                edge_attraction[i, j] = 0.0

    edge_attraction = edge_attraction / np.max(edge_attraction) if np.max(edge_attraction) > 0 else np.zeros_like(distance_matrix)  # Normalize

    # Combine all factors with dynamic weights
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics[i, j] = temperature * (
                    edge_attraction[i, j] +
                    node_degree_weight * (node_degree[i] + node_degree[j]) +
                    edge_proximity_weight * edge_proximity[i, j]
                )
            else:
                heuristics[i, j] = 0.0

    # Sparsification
    threshold = np.percentile(heuristics[heuristics > 0], sparsification_percentile)
    heuristics[heuristics < threshold] = 0.0

    # Adaptive cooling based on edge value variance
    edge_values = heuristics[heuristics > 0]

    if len(edge_values) > 0:
        edge_variance = np.var(edge_values)
    else:
        edge_variance = 0.0

    if edge_variance > high_variance_threshold:
        temperature *= cooling_high_variance
    else:
        temperature *= cooling_low_variance

    temperature = max(temperature, min_temperature)

    return heuristics
```
