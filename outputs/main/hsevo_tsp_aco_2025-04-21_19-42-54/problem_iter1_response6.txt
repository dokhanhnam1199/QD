```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for the Traveling Salesman Problem (TSP) using concepts inspired by
    black holes and gravitational lensing. The core idea is to bias the search towards
    edges that are shorter (stronger gravitational pull) and connect to nodes with fewer
    nearby nodes (less obscured).

    This heuristic attempts to mimic the way light bends around a black hole, where shorter paths
    are preferred, and areas of lower node density are more "visible" (less obscured).

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between nodes.
                                         distance_matrix[i, j] is the distance between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element
                      indicates the desirability of including the corresponding edge in the solution.
                      Higher values represent more desirable edges.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse of distance, analogous to gravitational pull (shorter distances are preferred)
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add small constant to avoid division by zero

    # Node degree heuristic: Favors nodes with fewer nearby neighbors
    # Mimics the idea that nodes in less dense regions are more accessible.

    for i in range(n):
        # Calculate a "node visibility" score for each node i.
        # Lower degree (fewer neighbors within a certain radius) implies higher visibility.

        # Option 1: Simple inverse degree
        node_degree = np.sum(distance_matrix[i, :] < np.mean(distance_matrix[i,:])) # count how many nodes nearby

        node_visibility = 1.0 / (node_degree + 1)  # Avoid division by zero

        # Option 2: More complex "gravitational potential" based on inverse distance.
        # potential = np.sum(inverse_distance[i, :])
        # node_visibility = 1.0 / (potential + 1e-9)

        for j in range(n):
            # Combine inverse distance (attraction) and node visibility.
            heuristics_matrix[i, j] = inverse_distance[i, j] * (node_visibility+ 1e-9)  #Adjust to encourage visibility



    # Additional edge weighting - prioritize shorter edges, but also consider
    # how well they connect to the overall graph structure. A small adjustment
    # ensures symmetry and avoids zero division
    for i in range(n):
        for j in range(n):
                heuristics_matrix[i, j] +=  np.mean([heuristics_matrix[i, k] + heuristics_matrix[k,j] for k in range(n)])/(n+1e-9) # give higher score if intermediate hop would also be useful


    # Normalize to avoid extreme values (improve numerical stability).
    max_val = np.max(heuristics_matrix)
    if max_val > 0:
      heuristics_matrix /= max_val

    return heuristics_matrix
```
