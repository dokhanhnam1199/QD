```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines inverse distance, savings, node degree, and triangle inequality.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # 1. Inverse distance
    heuristic_matrix = 1 / (distance_matrix + 1e-9)

    # 2. Savings Heuristic
    depot = 0
    savings = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                savings[i, j] = distance_matrix[depot, i] + distance_matrix[depot, j] - distance_matrix[i, j]
    heuristic_matrix += savings / (distance_matrix + 1e-9)

    # 3. Node degree centrality adjustment
    degree_centrality = np.sum(heuristic_matrix, axis=0)
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] /= (degree_centrality[i] * degree_centrality[j])**0.25

    # 4. Triangle Inequality violation penalty
    for i in range(n):
        for j in range(n):
            if i != j:
                shortcut_factor = 0.0
                for k in range(n):
                    if i != k and j != k:
                         potential_shortcut = distance_matrix[i, k] + distance_matrix[k, j]
                         shortcut_factor += np.maximum(0, (distance_matrix[i, j] - potential_shortcut) / distance_matrix[i,j])
                heuristic_matrix[i, j] /= (1 + shortcut_factor/ n )

    # 5. Symmetry correction
    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2

    # 6. Normalization to encourage exploration (focus on diversity)
    heuristic_matrix = (heuristic_matrix - np.min(heuristic_matrix)) / (np.max(heuristic_matrix) - np.min(heuristic_matrix))
    
    return heuristic_matrix
```
