{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Encourages filling bins as much as possible (minimize wasted space)\n    but penalizes bins that are too full after placing item. Also give preference\n    to bins which can accommodate the item to minimize fragmentation\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            # Preference to bins that can fit the item\n            fill_ratio = item / capacity\n\n            # Encourage bins to be filled completely but not overfilled\n            priority = (1 - np.abs(fill_ratio - 0.8)) #0.8 selected by experimentation to see performance\n\n            #Add scaling for remaining capacity, to prefer filling bins\n            remaining_capacity = capacity - item\n            priority = priority + (1-remaining_capacity/capacity) #Higher priority for less remaining\n            priorities[i] = priority\n\n        else:\n            priorities[i] = -np.inf  # Cannot fit, so lowest priority\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    A subtle blend of gravity and least-action principles, balanced with a touch of divine chaos.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Initialize priorities with small values.  Let no bin start at absolute zero, for nature abhors a vacuum.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) + 1e-9  # Ensure non-zero values to prevent division errors and ensure that zero capacity bins have non-zero values (penalized later).\n\n    # Gravity component:  Bins closer to the item's size attract more strongly. Inverse square law, naturally.\n    gravity = np.exp(-((bins_remain_cap - item)**2) / (2 * (item/3)**2)) # A gaussian function.\n\n    # Least action: Favor bins where the item fits almost perfectly, avoiding both waste and overflow.  Think of it as minimizing wasted potential energy.\n    waste = bins_remain_cap - item  # How much space remains after adding the item\n    # Give very low priority (large negative number) if waste is negative. Let nature abhor overflow.\n    waste_penalty = np.where(waste < 0, -1e9, 0)\n    waste[waste < 0] = 0  # Reset negative waste to 0 for calculations.\n\n    # Prefer smaller waste amounts, to avoid having bins with much empty spaces,\n    # however, avoid too small wastes to avoid bins that overflow when perturbed by small changes.\n\n    waste_optimization = np.exp(-(waste**2)/((item/4)**2))\n\n    # Combine the forces: Gravity attracts, least action guides. Let there be balance.\n    priorities = gravity * waste_optimization + waste_penalty\n\n    # Introduce a touch of divine chaos:  A small random element to prevent settling into local minima. The subtle hand of the Almighty.\n    priorities += np.random.normal(0, 0.01, size=bins_remain_cap.shape)\n\n    # Ensure bins that cannot fit the item have VERY low priority. Bins that cannot accommodate shall not be considered.\n    priorities[bins_remain_cap < item] = -1e9\n\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st heuristic prioritizes bins based on a combination of \"fit score\" (remaining space after placing the item) and proximity to being half-empty, while the 20th focuses on a target fill ratio (0.6), remaining capacity, and penalizes capacities close to the item size. The 1st heuristic uses inverse of wasted space + boost close to half empty, while 20th uses absolute difference from a specific ratio + remaining capacity + penalty close to item size.\n\nComparing (2nd) vs (19th), the 2nd version uses an \"electrical intuition\" approach, incorporating resonance and balance utilization while the 19th prioritizes fill ratio, gives bonus to perfect fit, and adjusts by available capacity. 2nd focuses on resonance for difference while 19th focuses on fill ratio and perfect fit.\n\nComparing (1st) vs (2nd), the 1st uses inverse of wasted space to give priority and boost to bins close to half empty, while 2nd focuses on electrical intuition using wasted space inversion, resonance amplification, and balance utilization. 1st has simpler logic.\n\nComparing (3rd) vs (4th), the 3rd adds a stochastic element to escape local optima. The 4th heuristic combines waste minimization, fill percentage, and moderate bin utilization. 3rd has randomness + discourages, 4th minimize waste.\n\nComparing (2nd) vs (3rd), the 2nd heuristic is guided by \"electrical intuition\" while the 3rd introduces stochasticity to avoid local optima. The stochastic element provides exploration.\n\nComparing (19th) vs (20th), the 19th utilizes a fill ratio and perfect fit bonus while the 20th uses an absolute difference from a specific fill ratio combined with remaining capacity and penalty.\n\nOverall: The better heuristics seem to balance several factors such as minimizing waste, promoting utilization, avoiding overfilling, and adding slight stochasticity. They often prioritize fitting items snugly but also consider the bin's overall fill level and how it may affect future placements. Heuristics that are too specific (e.g., targeting a precise fill ratio) or lack exploration (e.g., consistently picking the best fit without randomness) perform worse. Also, simple logic performs better.\n- \nOkay, I'm ready to help you refine \"Current self-reflection\" for designing better heuristics, focusing on actionable insights and avoiding common pitfalls. Here's a redefined approach:\n\n*   **Keywords:** Adaptive learning, trade-offs, bias mitigation, problem-specific knowledge.\n*   **Advice:** Analyze heuristic performance on diverse problem instances. Identify biases. Incorporate feedback mechanisms to adjust parameters and strategies dynamically.\n*   **Avoid:** Rigid adherence to pre-defined rules, neglecting problem-specific characteristics, and prematurely focusing on optimization.\n*   **Explanation:** Effective heuristic design requires continuous adaptation, acknowledging inherent biases, and integrating understanding of the specific problem structure. This leads to more robust and efficient solutions.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}