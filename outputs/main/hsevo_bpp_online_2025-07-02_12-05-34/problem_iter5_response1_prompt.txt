{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines waste minimization, fill percentage, and balance bin utilization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = -waste  # Minimize waste\n        fill_percentage = item / bins_remain_cap[valid_bins]\n        priorities[valid_bins] += fill_percentage  # Fill percentage\n        priorities[valid_bins] += (bins_remain_cap[valid_bins] > 0.5) * 0.1  # Moderate use\n        remaining_after_add = bins_remain_cap[valid_bins] - item\n        near_full_penalty = np.where(remaining_after_add < (0.1*bins_remain_cap.max()), -0.5, 0.0)\n        priorities[valid_bins] += near_full_penalty\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines waste minimization and target fill ratio for bin priority.\"\"\"\n\n    can_fit = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if np.any(can_fit):\n        wasted_space = bins_remain_cap[can_fit] - item\n        priorities[can_fit] = 1.0 / (wasted_space + 0.0001)\n\n        fill_ratio = (bins_remain_cap[can_fit] - wasted_space) / bins_remain_cap[can_fit]\n        target_ratio = 0.6\n        priorities[can_fit] += 5.0 * np.exp(-((fill_ratio - target_ratio)**2) / 0.02) # gaussian curve\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see that they are exactly the same. This indicates redundancy in the list.\n\nComparing (3rd) vs (4th), 3rd introduces `fullness_score` and `too_close_threshold` which are not present in the 4th. 3rd gives higher priority to bins that are relatively full using `fullness_score` and penalizes bins that are too close in size to the item using `too_close_threshold`. 4th boosts priority for bins with remaining capacity close to the item size (using `item_proximity_score`), prioritizes fuller bins and penalizes bins that become too empty after placing the item.\n\nComparing (4th) vs (5th), the fifth gives a negative infinity if no bins are valid. The fifth prioritizes `waste` minimization and `fill_percentage`. The 4th prioritizes item proximity and full bins, adding penalty if they become too empty.\n\nComparing (1st) vs (6th), 6th prioritizes item proximity and full bins adding penalty if they become too empty. The first only minimizes space.\n\nComparing (7th) vs (8th), 7th uses fill ratio and wasted space. 8th combines waste minimization, fill percentage, and bin balancing. if not np.any(fit_within_capacity) on 7th the priorities are calculated based on ratio between bin size and item size, while if no bin can fit on 8th, all priorities are assigned negative infinite values.\n\nComparing (9th) vs (10th), identical again.\n\nComparing (11th) vs (1st), 11th takes additional parameters such as `division_avoidance`, `half_empty_weight`, `fullness_weight`, `too_close_fraction`, `too_close_penalty`. but the code is uncompleted as it misses other parts after handling valid bins.\n\nComparing (12th) vs (1st), 12th adds residual capacity, close fit and capacity utilization ration, but lacks the avoidance of division by zero.\n\nComparing (13th) vs (1st), the later favors bins with remaining capacity close to a target value. It also includes bin usage counts, which would require storing state between calls. First only prioritizes minimization of wasted space.\n\nComparing (14th) vs (15th), the same again.\n\nComparing (16th) vs (1st), 16th target a fill ratio using a gaussian curve.\n\nComparing (17th) vs (1st), 17th iterates the capacities one by one.\n\nComparing (19th) vs (20th), 19th adds a balance factor considering target fill level (e.g., 75%), small randomness and penalizes near full bins. The 20th utilizes randomness and prioritizes capacity close to the average.\n\nOverall: The better heuristics attempt to balance several factors: minimizing wasted space, targeting a fill level, avoiding bins that become too full or too empty, and some randomness to avoid local optima. The worse ones often lack one or more of these considerations or are incomplete. Also, the better heuristics, use of numpy allows for calculation across all bins at once rather than looping.\n- \nOkay, let's refine \"Current Self-Reflection\" to design better bin packing heuristics, specifically avoiding the pitfalls of \"Ineffective Self-Reflection.\"\n\nHere's a breakdown:\n\n*   **Keywords:** Objective weighting, Threshold tuning, Vectorized operations, Randomization strategies, Local optima escape, Fill level targets, Waste minimization.\n\n*   **Advice:** Quantify objective contributions. Experiment with adaptive weighting based on solution progress. Profile code and aggressively optimize bottlenecks, paying close attention to the performance gains from vectorized operations.\n\n*   **Avoid:** Broad generalizations, oversimplification, vague goals (e.g. \"balance exploitation/exploration\" without concrete mechanisms).\n\n*   **Explanation:** Instead of simply stating principles, focus on actionable steps. Emphasize empirical evaluation and iterative refinement of parameters. Prioritize performance optimization through vectorized operations. Explore specific randomization techniques (e.g., simulated annealing, genetic algorithms) for escaping local optima.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}