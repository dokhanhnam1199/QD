{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version prioritizes bins that can accommodate the item with minimal waste,\n    but also includes a stochastic element to avoid getting stuck in local optima.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate waste if item is placed in each bin. Negative waste means the item doesn't fit.\n    waste = bins_remain_cap - item\n\n    # Give bins that can fit the item a priority based on how little waste there is.\n    # Use a large negative number for bins that can't fit the item to strongly discourage them.\n    priorities = -np.abs(waste)\n    priorities[waste < 0] = -np.inf\n\n    # Add a small amount of randomness to break ties and escape local optima.\n    # The amount of randomness scales with the item size.  Smaller item = more randomness.\n    randomness = np.random.rand(len(bins_remain_cap)) * (0.1 / (item+0.00001) )  # avoid division by zero. small item makes more random.\n\n    priorities = priorities + randomness\n\n    # If no bins can accommodate the item, return a low priority for all bins.  In practice a new bin will be created if all are negative inf\n    if np.all(waste < 0):\n         priorities = -np.ones(len(bins_remain_cap)) * (item *100) # discourage using any existing bins heavily.\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Utilizes a combination of fill ratio, wasted space penalty, and a preference for bins that can perfectly fit items.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Small constant to avoid division by zero.\n    epsilon = 1e-9\n    \n    # Calculate the fill ratio for each bin if the item were placed in it.\n    fill_ratios = item / (bins_remain_cap + epsilon)  # Add epsilon to avoid div by 0\n    \n    # Initialize priorities with the fill ratio (higher fill ratio is generally better).\n    priorities = fill_ratios.copy()\n\n    #Perfect fit heuristic\n    perfect_fit_bonus = np.isclose(item, bins_remain_cap).astype(float) * 10\n\n    #Add bonus for perfect fit\n    priorities = priorities + perfect_fit_bonus\n\n    # Penalize bins where the item doesn't fit (set priority to a very low value)\n    priorities[item > bins_remain_cap] = -np.inf\n    \n    #Adjust by available capacity, prefer higher remaining capacity.\n    priorities = priorities + bins_remain_cap * 0.1\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st heuristic prioritizes bins based on a combination of \"fit score\" (remaining space after placing the item) and proximity to being half-empty, while the 20th focuses on a target fill ratio (0.6), remaining capacity, and penalizes capacities close to the item size. The 1st heuristic uses inverse of wasted space + boost close to half empty, while 20th uses absolute difference from a specific ratio + remaining capacity + penalty close to item size.\n\nComparing (2nd) vs (19th), the 2nd version uses an \"electrical intuition\" approach, incorporating resonance and balance utilization while the 19th prioritizes fill ratio, gives bonus to perfect fit, and adjusts by available capacity. 2nd focuses on resonance for difference while 19th focuses on fill ratio and perfect fit.\n\nComparing (1st) vs (2nd), the 1st uses inverse of wasted space to give priority and boost to bins close to half empty, while 2nd focuses on electrical intuition using wasted space inversion, resonance amplification, and balance utilization. 1st has simpler logic.\n\nComparing (3rd) vs (4th), the 3rd adds a stochastic element to escape local optima. The 4th heuristic combines waste minimization, fill percentage, and moderate bin utilization. 3rd has randomness + discourages, 4th minimize waste.\n\nComparing (2nd) vs (3rd), the 2nd heuristic is guided by \"electrical intuition\" while the 3rd introduces stochasticity to avoid local optima. The stochastic element provides exploration.\n\nComparing (19th) vs (20th), the 19th utilizes a fill ratio and perfect fit bonus while the 20th uses an absolute difference from a specific fill ratio combined with remaining capacity and penalty.\n\nOverall: The better heuristics seem to balance several factors such as minimizing waste, promoting utilization, avoiding overfilling, and adding slight stochasticity. They often prioritize fitting items snugly but also consider the bin's overall fill level and how it may affect future placements. Heuristics that are too specific (e.g., targeting a precise fill ratio) or lack exploration (e.g., consistently picking the best fit without randomness) perform worse. Also, simple logic performs better.\n- \nOkay, I'm ready to help you refine \"Current self-reflection\" for designing better heuristics, focusing on actionable insights and avoiding common pitfalls. Here's a redefined approach:\n\n*   **Keywords:** Adaptive learning, trade-offs, bias mitigation, problem-specific knowledge.\n*   **Advice:** Analyze heuristic performance on diverse problem instances. Identify biases. Incorporate feedback mechanisms to adjust parameters and strategies dynamically.\n*   **Avoid:** Rigid adherence to pre-defined rules, neglecting problem-specific characteristics, and prematurely focusing on optimization.\n*   **Explanation:** Effective heuristic design requires continuous adaptation, acknowledging inherent biases, and integrating understanding of the specific problem structure. This leads to more robust and efficient solutions.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}