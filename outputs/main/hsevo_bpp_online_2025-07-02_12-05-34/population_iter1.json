[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Give a high priority to bins where the item fits snugly\n    fit_score = np.exp(-np.abs(bins_remain_cap - item) / (item + 1e-6)) # Avoid division by zero\n    priorities += 2 * fit_score\n\n    # Give some priority to bins that have enough capacity (First Fit aspect)\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1\n\n    # Penalize bins that are almost full after placing the item (try to keep bins balanced).\n    remaining_after_placement = bins_remain_cap - item\n    almost_full = (remaining_after_placement > 0) & (remaining_after_placement < 0.1) #threshold\n    priorities[almost_full] -= 0.5\n\n    # Bonus for bins that are quite empty\n    quite_empty = bins_remain_cap > 0.75 # threshold\n    priorities[quite_empty] += 0.25\n    \n    # If no bin can fit the item, slightly prioritize bins with more remaining capacity to reduce fragmentation\n    if not np.any(can_fit):\n        priorities = bins_remain_cap / np.max(bins_remain_cap) - 0.1 # slight scaling\n        \n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 17, in priority_v2\n    can_fit = bins_remain_cap >= item\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version considers multiple factors inspired by physics and the nature:\n    - Gravitational Potential: Prefer bins with remaining capacity closest to the item size.\n    - Avoid extremes: Discourage both nearly full and nearly empty bins.\n    - Momentum: Consider the bin utilization history (not implemented in this online version directly).\n    - Stochasticity: Add a small random factor to break ties and explore diverse solutions.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-6  # Small constant to avoid division by zero and log of zero.\n    # Gravitational Potential: The closer the item size to remaining capacity, the higher the priority.\n    gravitational_potential = -np.abs(bins_remain_cap - item)  # Negative to indicate attraction\n    gravitational_potential = gravitational_potential / (np.max(np.abs(gravitational_potential)) + epsilon)\n\n    # Avoid extremes: Bins that are nearly full or nearly empty are less desirable.\n    # Use a Gaussian-like function to penalize near-full and near-empty bins\n    bin_utilization = bins_remain_cap  # remaining capacity is bin_utilization since all bins start full\n    avoid_extremes = -((bin_utilization - np.mean(bin_utilization))**2) / (2 * np.std(bin_utilization)**2 + epsilon)\n    avoid_extremes = avoid_extremes / (np.max(np.abs(avoid_extremes))+ epsilon) # normalize\n\n    # Stochasticity: Add a small random factor to break ties and explore the solution space.\n    stochasticity = np.random.normal(0, 0.01, size=bins_remain_cap.shape)\n\n    # Combine the factors to create the priority score.\n    priorities = gravitational_potential + avoid_extremes + stochasticity\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 23.49421619465498,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base score (e.g., all bins are initially somewhat desirable)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Reward bins that can accommodate the item (avoiding wastage)\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1  # Higher base priority for bins that can fit\n\n    # Prioritize bins with capacity closest to item size (minimize fragmentation)\n    residual_capacity = bins_remain_cap - item\n    close_fit = np.abs(residual_capacity)\n    priorities[can_fit] += (1 / (1 + close_fit[can_fit])) # Smaller residuals are preferable (1/x, bounded)\n\n    # Penalize bins with large remaining capacity (delay filling completely empty bins)\n    priorities -= (bins_remain_cap / np.sum(bins_remain_cap))  # Reduce priority based on relative capacity.\n    # Slightly favor near-full bins\n    almost_full = (bins_remain_cap < item * 2) & (bins_remain_cap >= item)\n    priorities[almost_full] += 0.5 # Give a small bonus to partially filled bins that still fit the item\n\n    # Avoid bins that cannot fit, assign low priority (can be set to -inf but may cause issues)\n    priorities[~can_fit] = -1e9  # Vastly deprioritize infeasible bins.\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can fit the item with minimal wasted space,\n    while also discouraging filling bins to exactly full (to reduce edge cases later).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give a very negative priority to bins that can't fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Calculate wasted space if the item were placed in each bin\n    wasted_space = bins_remain_cap - item\n\n    # Assign a high priority to bins with small wasted space. Use a reciprocal function to\n    # boost the priority of bins that are close to the item size.\n    valid_bins = bins_remain_cap >= item\n    priorities[valid_bins] = 1.0 / (wasted_space[valid_bins] + 0.01)  # Add small constant to avoid division by zero\n\n    # Penalize bins that would become exactly full (risk of future inefficiency)\n    exact_fit = wasted_space == 0\n    priorities[exact_fit] = -1  # Significantly reduce the priority of exact fits\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 5.195452732349436,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item relatively tightly,\n    while also discouraging near-empty bins if other more suitable options exist.\n    It balances the remaining capacity after placement with the original size, and penalizes bins that are too large relative to the item size, unless nearly full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Handle cases where the item doesn't fit in some bins:\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities # No valid bins at all. return zeros.\n\n    # Prioritize valid bins.\n    valid_bin_indices = np.where(valid_bins)[0] # Only work with bins the item can fit.\n\n    remaining_after = bins_remain_cap[valid_bins] - item\n    capacity_ratio = item / bins_remain_cap[valid_bins]\n    # 1. Tight fit is good. Small remainders are better. (But not zero)\n    tightness = 1 / (remaining_after + 0.0001)  # To avoid division by zero. Avoid completely full bin\n    tightness_score = tightness\n    # 2. Preferentially filling bins that are already partially full to make better use of existing bins before using new ones.\n    # Filling Score based on how full a bin already is (before the item is placed)\n    fullness_score = 1 - (bins_remain_cap[valid_bins] / bins_remain_cap.max()) # Higher score if already full\n    # Ensure all values are positive.\n    # Scale the filling score appropriately so we avoid empty bins as a default\n    priorities[valid_bin_indices] = (tightness_score * 0.7) + (fullness_score * 0.3)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Employing a combination of first-fit and best-fit characteristics,\n    modulated by a factor reflecting the 'tightness' of fit. A bin with\n    capacity exactly matching the item's size gets the highest priority.\n    Also discourage bins that are only just large enough, prioritizing those\n    that allow a reasonable margin after packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Heavily favor perfect fits\n    perfect_fit_mask = bins_remain_cap == item\n    priorities[perfect_fit_mask] = np.inf # Max priority if perfect fit\n    \n    # Filter out bins where the item doesn't fit\n    incompatible_mask = bins_remain_cap < item\n    priorities[incompatible_mask] = -np.inf # Min priority if cannot fit\n\n    # Calculate the \"waste\" after putting the item in\n    waste = bins_remain_cap - item\n    \n    # Reward smaller waste, but not *too* small. We want *some* buffer.\n    # The more available cap beyond just the item size is a little better.\n    # Using log to prevent overflowing if we accidentally provide enormous bins.\n    valid_bins_mask = ~incompatible_mask & ~perfect_fit_mask\n\n    if np.any(valid_bins_mask):\n\n        priorities[valid_bins_mask] = np.log(bins_remain_cap[valid_bins_mask]/(waste[valid_bins_mask] + 1e-6) * (1 / (waste[valid_bins_mask] + 1e-6))) # Log to stablilize if there are extremely small wastes. The reciprocal reduces small wastes\n        # Normalize the values\n        priorities[valid_bins_mask] = (priorities[valid_bins_mask] - np.min(priorities[valid_bins_mask])) / (np.max(priorities[valid_bins_mask]) - np.min(priorities[valid_bins_mask]))\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.287993617869964,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with sufficient capacity to accommodate the item\n    without excessive leftover space, while also penalizing near-full bins to\n    encourage efficient packing. It uses a combination of capacity difference and fill ratio.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # If no bin can fit the item, return a small negative priority for all bins\n        # to signify that none are suitable but allow selection based on other criteria\n        # (e.g., least-full if a new bin needs to be opened).  Use -np.inf may lead to errors\n        priority[:] = -1e-9\n        return priority\n\n    # Calculate capacity difference (remaining capacity after placing the item) for valid bins\n    capacity_difference = bins_remain_cap[valid_bins] - item\n\n    # A smaller difference indicates a better fit (less wasted space).\n    # Inverse the difference to get a higher priority for smaller differences, and adding\n    # small amount to denominator for avoid dividing by 0\n    priority[valid_bins] = 1 / (capacity_difference + 0.001)\n\n    # Further boost priority for bins with higher fill ratios (closer to being full after adding the item).\n    # But also include a penalty for near full bins that are already very full to avoid fragmentation\n\n    fill_ratios = (bins_remain_cap[valid_bins] - capacity_difference) / bins_remain_cap[valid_bins]\n\n    # Apply a weight to the fill ratio. This weight could be tuned.\n    fill_ratio_weight = 0.5\n\n    near_full_penalty = np.where(bins_remain_cap[valid_bins] < (1.1 * item), -0.2 * bins_remain_cap[valid_bins], 0)\n    priority[valid_bins] += fill_ratio_weight * fill_ratios + near_full_penalty\n\n    # Scale to make zero mean and unit variance (helps prevent domination by single bin).\n    priority[valid_bins] = (priority[valid_bins] - np.mean(priority[valid_bins])) / (np.std(priority[valid_bins]) + 1e-8)\n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 5.215396888711603,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version incorporates several ideas:\n    1.  Bins that cannot accommodate the item get a very low priority.\n    2.  Among bins that *can* accommodate the item, prioritize bins\n        with remaining capacity close to the item size. This encourages\n        filling bins optimally and reduces fragmentation.\n    3. Introduce randomness to explore different packings.\n    4. Scale with bin size - favors bins with smaller size to pack since its easier to fill\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give very low priority to bins that cannot fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # For feasible bins, calculate a priority based on remaining capacity\n    feasible_bins = ~infeasible_bins\n    remaining_space = bins_remain_cap[feasible_bins] - item\n\n    #Prioritize bins where item size is close to capacity.\n    priority_score = np.exp(-np.abs(remaining_space)/(item+1e-9)) # e^-|remaining_space|/item\n\n    # Add some randomness to encourage exploration (Gaussian noise)\n    randomness = np.random.normal(0, 0.1, size=remaining_space.shape)\n    priority_score += randomness\n\n    # Scale the priority by the bin capacity. Smaller remaining bin capacity -> higher priority.\n    priority_score /= bins_remain_cap[feasible_bins]\n\n    priorities[feasible_bins] = priority_score\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.038691663342641,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version prioritizes bins that can accommodate the item with minimal waste,\n    but also includes a stochastic element to avoid getting stuck in local optima.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate waste if item is placed in each bin. Negative waste means the item doesn't fit.\n    waste = bins_remain_cap - item\n\n    # Give bins that can fit the item a priority based on how little waste there is.\n    # Use a large negative number for bins that can't fit the item to strongly discourage them.\n    priorities = -np.abs(waste)\n    priorities[waste < 0] = -np.inf\n\n    # Add a small amount of randomness to break ties and escape local optima.\n    # The amount of randomness scales with the item size.  Smaller item = more randomness.\n    randomness = np.random.rand(len(bins_remain_cap)) * (0.1 / (item+0.00001) )  # avoid division by zero. small item makes more random.\n\n    priorities = priorities + randomness\n\n    # If no bins can accommodate the item, return a low priority for all bins.  In practice a new bin will be created if all are negative inf\n    if np.all(waste < 0):\n         priorities = -np.ones(len(bins_remain_cap)) * (item *100) # discourage using any existing bins heavily.\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, identify bins that can actually fit the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # If no bins can fit, assign low priority to all (might need a new bin)\n        return priorities\n\n    # For valid bins, calculate a \"fit score\"\n    fit_score = bins_remain_cap[valid_bins] - item  # Remaining space after placing the item\n\n    # Give higher priority to bins where the item fits snugly (minimize wasted space)\n    # We can use the inverse of the remaining space as a priority\n    priorities[valid_bins] = 1.0 / (fit_score + 0.0001) # Avoid division by zero\n\n    #Boost priority for bins close to being half empty, could potentially improve packing next items\n    half_empty_score = np.abs(bins_remain_cap[valid_bins] - bins_remain_cap.max()/2)\n    priorities[valid_bins] += 1.0/(half_empty_score+0.0001)\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 3.6597526924611135,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits, but not too well, to avoid fragmentation.\n    # Also, give some priority to bins that cannot fit the item (a \"desperation\" strategy)\n    for i, rem in enumerate(bins_remain_cap):\n        if rem >= item:\n            # Bin fits the item\n            fit_ratio = item / rem  # How well the item fits (0 to 1)\n            slack = rem - item # The leftover capacity after adding the item\n\n            #A good fit should get high priority, penalize either too perfect fit, or too fragmented.\n            priorities[i] = np.exp(-((fit_ratio - 0.7)**2) / 0.05) + np.exp(-(slack/item)**2) # Gaussian-like priority\n\n        else:\n            # Bin does not fit, prioritize based on how close the item is to fitting, inverse exponential to allow a big negative slope.\n            priorities[i] = -np.exp((item - rem) * 2)  # Prioritize by \"almost fitting\" - a desperation strategy\n\n    return priorities",
    "response_id": 10,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997511100082 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins based on a combination of factors,\n    including:\n    1.  Remaining capacity relative to item size (to avoid fragmentation).\n    2.  Absolute remaining capacity (to favor bins with more space).\n    3.  A 'sweet spot' penalty if the item fits 'too perfectly' (leading\n        to potentially suboptimal packing of future items).\n    4.  Relevance of both capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Capacity relative to item size (avoid fragmentation).  Favor closer fits.\n            capacity_ratio = item / cap  # Higher is better. Close to 1 is ideal\n\n            # Absolute remaining capacity (favor bins with more space).\n            # Encourages use of existing bins before opening new ones. A small value means that the bin has a larger relative occupied space\n            capacity_impact = cap\n            # Introduce a \"sweet spot\" penalty. If the item fills the bin nearly perfectly,\n            # slightly discourage it to prevent premature exhaustion of larger bins.  It encourages larger free bins to receive smaller elements\n            sweet_spot_threshold = 0.9  # Tune this parameter\n            sweet_spot_penalty = 0.0\n\n            if capacity_ratio > sweet_spot_threshold:\n                sweet_spot_penalty = -0.1\n            priorities[i] = (1 - abs(capacity_ratio - 0.8 )) + capacity_impact/np.max(bins_remain_cap) + sweet_spot_penalty # capacity_ratio near 1 is good\n\n\n        else:\n            priorities[i] = -np.inf  # Impossible to place, lowest priority\n\n    return priorities",
    "response_id": 11,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999970439996105 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    A subtle blend of gravity and least-action principles, balanced with a touch of divine chaos.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Initialize priorities with small values.  Let no bin start at absolute zero, for nature abhors a vacuum.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) + 1e-9  # Ensure non-zero values to prevent division errors and ensure that zero capacity bins have non-zero values (penalized later).\n\n    # Gravity component:  Bins closer to the item's size attract more strongly. Inverse square law, naturally.\n    gravity = np.exp(-((bins_remain_cap - item)**2) / (2 * (item/3)**2)) # A gaussian function.\n\n    # Least action: Favor bins where the item fits almost perfectly, avoiding both waste and overflow.  Think of it as minimizing wasted potential energy.\n    waste = bins_remain_cap - item  # How much space remains after adding the item\n    # Give very low priority (large negative number) if waste is negative. Let nature abhor overflow.\n    waste_penalty = np.where(waste < 0, -1e9, 0)\n    waste[waste < 0] = 0  # Reset negative waste to 0 for calculations.\n\n    # Prefer smaller waste amounts, to avoid having bins with much empty spaces,\n    # however, avoid too small wastes to avoid bins that overflow when perturbed by small changes.\n\n    waste_optimization = np.exp(-(waste**2)/((item/4)**2))\n\n    # Combine the forces: Gravity attracts, least action guides. Let there be balance.\n    priorities = gravity * waste_optimization + waste_penalty\n\n    # Introduce a touch of divine chaos:  A small random element to prevent settling into local minima. The subtle hand of the Almighty.\n    priorities += np.random.normal(0, 0.01, size=bins_remain_cap.shape)\n\n    # Ensure bins that cannot fit the item have VERY low priority. Bins that cannot accommodate shall not be considered.\n    priorities[bins_remain_cap < item] = -1e9\n\n\n    return priorities",
    "response_id": 12,
    "tryHS": false,
    "obj": 19.285999202233757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can fit the item relatively well,\n    but also considers avoiding bins that are left nearly empty after packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Give negative priority to bins that cannot fit the item\n    cannot_fit = item > bins_remain_cap\n    priorities[cannot_fit] = -np.inf\n\n    # Calculate the fill ratio for bins that can fit the item. The higher the better but not 1\n    can_fit = item <= bins_remain_cap\n    if np.any(can_fit):\n        fill_ratio = item / bins_remain_cap[can_fit]\n\n        # Give a higher priority for bins that can be filled more\n        priorities[can_fit] = (1 - np.abs(fill_ratio - 0.6)) * 10 # Modified fill ratio\n        post_fill = bins_remain_cap[can_fit] - item\n\n        #Avoid small residual space\n        small_residuals = post_fill <= 0.1\n        priorities[can_fit][small_residuals] -= 100 #Strong Penalty\n        \n        #Bins close to full\n        fullish = post_fill/bins_remain_cap[can_fit] <= 0.2\n        priorities[can_fit][fullish] += 5\n        \n    return priorities",
    "response_id": 13,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 20, in priority_v2\n    for i, remaining_capacity in enumerate(bins_remain_cap):\nOverflowError: cannot convert float infinity to integer\n"
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by Tesla's resonance principle and seeking maximum energy transfer.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Tesla's Resonance: Maximize Energy Transfer (Packing Efficiency)\n    # Higher priority if the item size is close to the remaining capacity\n    # But also penalize if the item is larger than the remaining capacity\n\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if remaining_capacity >= item:\n             priority = np.exp(-np.abs(item - remaining_capacity) / item)  # Resonant Peak\n        else:\n            priority = -np.abs(item - remaining_capacity) # Strong negative if it doesn't fit.\n\n        priorities[i] = priority\n\n    return priorities",
    "response_id": 14,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999979631000315 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    A novel heuristic inspired by the celestial dance! We consider both how well the item \"fits\"\n    into a bin (like a planet finding its orbit) AND a tendency to fill bins, thus reducing waste\n    (akin to consolidating heavenly matter).  We want bins where the item fits reasonably well,\n    but also bins that aren't *already* almost full.  A near-empty bin is given a low priority unless\n    the item almost perfectly fits it.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # The item *can* fit. This is good, let's consider.\n\n            # \"Fit\" score:  Smaller remaining space after insertion is *better*,\n            # but give HUGE penalty if item is more than 90% the size of bin,\n            # so we don't force bins to be packed tight with possibly bad fit.\n\n            remaining_space = cap - item\n            if item > 0.9 * cap:  #Prevent from filling up to 90%\n                fit_score = -1e9\n            elif remaining_space == 0: #The best fit possible\n                fit_score = 1e9\n            else:\n                fit_score = 1.0 / (remaining_space + 0.0001) #avoid division by 0\n\n            # \"Fill\" score: Bins that are already pretty full are slightly penalized, to encourage\n            # more completely filled bins rather than lots of almost-empty bins. This only\n            # works if it is more efficient to group larger items.\n            fill_score = cap #Larger cap gives more score.\n\n            priorities[i] = fit_score + fill_score\n        else:\n            # The item *cannot* fit.  Priority is zero or negative infinity!\n            priorities[i] = -np.inf\n    return priorities",
    "response_id": 15,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996604000626 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Utilizes a combination of fill ratio, wasted space penalty, and a preference for bins that can perfectly fit items.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Small constant to avoid division by zero.\n    epsilon = 1e-9\n    \n    # Calculate the fill ratio for each bin if the item were placed in it.\n    fill_ratios = item / (bins_remain_cap + epsilon)  # Add epsilon to avoid div by 0\n    \n    # Initialize priorities with the fill ratio (higher fill ratio is generally better).\n    priorities = fill_ratios.copy()\n\n    #Perfect fit heuristic\n    perfect_fit_bonus = np.isclose(item, bins_remain_cap).astype(float) * 10\n\n    #Add bonus for perfect fit\n    priorities = priorities + perfect_fit_bonus\n\n    # Penalize bins where the item doesn't fit (set priority to a very low value)\n    priorities[item > bins_remain_cap] = -np.inf\n    \n    #Adjust by available capacity, prefer higher remaining capacity.\n    priorities = priorities + bins_remain_cap * 0.1\n\n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "obj": 86.58755484643,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates a few ideas:\n    1.  A term that favors bins that can accommodate the item well (closer fit).\n    2.  A term that discourages nearly full bins from getting further burdened. This is only activated if the item fits.\n    3. A 'quantum tunneling' effect. Even if the item doesn't perfectly fit, there's a small probability (simulated by a small negative value if item > cap).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Higher priority for bins that offer a tighter fit (less wasted space).\n            fit_score = np.exp(-np.abs(cap - item)) # e^(-|cap-item|), so closer fit -> larger exp.  Faster calculation\n\n            # Discourage almost-full bins.  Only if item fits. This helps avoid creating many bins near-full, which would be inefficient.\n            fullness_penalty = (cap > 0.1) * (cap/bins_remain_cap.max())\n\n            priorities[i] = fit_score - 0.1*fullness_penalty\n\n        else:\n            # \"Quantum tunneling\": Small probability of putting it in anyway.\n            # Use a small negative value, so it's unlikely, but not impossible.  Proportional to amount above the limit, normalized.\n            priorities[i] = -0.01 * (item - cap) / item  # Small penalty, scaled to item size.\n            # This is a heuristic to handle potentially very small bins and items.\n            # Scale the \"penalty\" with how much we are violating the bin capacity.\n\n    return priorities",
    "response_id": 17,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999981410001055 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Initialize priorities with a default low value\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf\n\n    # Identify bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):  # Check if there are any bins where the item can fit\n\n        # Calculate the waste if the item is placed in each valid bin\n        waste = bins_remain_cap[valid_bins] - item\n\n        # Heuristic 1: Minimize Waste (First-Fit Decreasing adaptation):\n        #   Prioritize bins with the least waste.  This attempts to leave\n        #   bins full to allow for the insertion of larger subsequent items.\n        priorities[valid_bins] = -waste\n\n        # Heuristic 2: Fill percentage, to avoid large wastes.  This encourages utilization.\n        fill_percentage = item / bins_remain_cap[valid_bins]\n        priorities[valid_bins] += fill_percentage\n\n        # Heuristic 3: Moderate bin utilization before favoring near-full bins\n        #   This helps in avoiding creating too many almost-empty bins\n        #   when early items are small.  This acts as a slight balancing factor.\n        priorities[valid_bins] += (bins_remain_cap[valid_bins] > 0.5) * 0.1  # Small bonus\n\n        #If the item is larger than half of bin's capacity then strongly prioritise them for balancing load\n        priorities[valid_bins] += (item > 0.5) * (bins_remain_cap[valid_bins]/bins_remain_cap[valid_bins].max()) * 0.2\n        # Heuristic 4: If several bins has minimum waste, try to choose bin with lowest index.\n        #   It will help to have similar results in similar circumstances\n    else:\n        # If no bins can fit the item, return very small priorities\n        pass\n\n    return priorities",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that have enough space for the item\n    but also penalizes bins that would have too much space remaining\n    after the item is added (to avoid excessive fragmentation).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            remaining_space = cap - item\n            # Reward bins that can fit the item\n            priorities[i] += 1.0\n\n            # Penalize bins that would leave too much space unused (fragmentation)\n            # The amount of penalty depends on how much space is left, relative to the item size\n            # We use a sigmoid function to create a smooth penalty that saturates.\n            penalty = 1 / (1 + np.exp(-5 * (remaining_space / item - 0.5))) # Sigmoid scaled to item size\n            priorities[i] -= penalty\n\n            # Prioritize bins where the remaining space is closest to zero.\n            priorities[i] += np.exp(-10 * remaining_space / np.max(bins_remain_cap))\n        else:\n            # Very negative priority if the item doesn't fit\n            priorities[i] = -1e9\n    return priorities",
    "response_id": 19,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99998988000152 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate remaining capacity after placing the item in each bin.\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Give a high priority to bins where the item fits.\n    fit_mask = remaining_after_fit >= 0\n    priorities[fit_mask] = 1  # Base priority for bins that fit\n    \n    # Prioritize bins with smaller remaining capacity after fit, but only if it fits\n    priorities[fit_mask] += 1 / (remaining_after_fit[fit_mask] + 1e-9)  # avoid division by zero\n    \n    # Consider \"almost full\" bins: prioritize bins which are already nearly full\n    # relative to the item size\n    almost_full_mask = (bins_remain_cap > 0) & (bins_remain_cap < 2 * item)  # Adjust threshold as needed\n\n    # If the item does NOT fit, give a slight negative priority, but avoid over-penalizing.\n    not_fit_mask = remaining_after_fit < 0\n    priorities[not_fit_mask] = -np.abs(remaining_after_fit[not_fit_mask]) / (item + 1e-9)\n    \n    return priorities",
    "response_id": 20,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 23, in priority_v2\n    priorities[fit_within_capacity] = 1.0 / (1e-6 + wasted_space) #Add a small number to avoid division by zero.\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins that can fit the item almost perfectly.\n    # This encourages filling bins as much as possible.\n\n    fit_within_capacity = bins_remain_cap >= item\n    if np.any(fit_within_capacity):\n        # Calculate wasted space for bins that can fit. We want to MINIMIZE the waste\n        wasted_space = bins_remain_cap[fit_within_capacity] - item\n        #The least wasted space means higher priority\n        priorities[fit_within_capacity] = 1.0 / (1e-6 + wasted_space) #Add a small number to avoid division by zero.\n    \n        #Heuristic for preventing too many almost full bins. Penalize almost full\n        #but still valid bins less if there are not too many\n        almost_full_mask = (wasted_space > 0) & (wasted_space < 0.1)\n        \n        if(np.sum(almost_full_mask)>0):\n            num_available = np.sum(fit_within_capacity)\n\n            priorities[fit_within_capacity] *= (1 + 0.1 * (num_available - np.sum(almost_full_mask))/num_available)\n\n    #Heuristic: If no bin can fit the item, put the item into the largest possible bin. This may create a new bin eventually but prevents creating numerous partially empty bins.\n    else:\n        priorities = bins_remain_cap/item #Assigns high priority to largest remaining capacities\n\n    return priorities",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities to a very low value to penalize infeasible bins.\n    priorities = np.full(bins_remain_cap.shape, -np.inf)\n\n    # Identify feasible bins.\n    feasible_bins = bins_remain_cap >= item\n\n    if np.any(feasible_bins):\n        # Calculate the wasted space after placing the item in each feasible bin.\n        wasted_space = bins_remain_cap[feasible_bins] - item\n\n        # Calculate the utilization ratio (item size / original bin capacity).  We'll\n        # need the original bin capacity, let's assume it's a constant 1.0 for now.\n        # A higher utilization is generally desirable, but we don't want to\n        # prioritize small items that perfectly fill a small number of bins.\n        utilization = item # Because the full bin size is 1, item = item/1\n\n        # Define some coefficients to balance different factors. You can adjust these!\n        wasted_space_coeff = -1.0  # Penalize more wasted space, using a negative coefficient.\n        utilization_coeff = 1.5    # Encourage higher utilization.\n\n        # Calculate scores for each feasible bin.\n        scores = wasted_space_coeff * wasted_space + utilization_coeff * utilization\n\n        # Assign scores to the corresponding bins.\n        priorities[feasible_bins] = scores\n\n        # Preferentially use bins that are close to full.\n        close_to_full = (bins_remain_cap[feasible_bins] > 0.99) # if remcap = item.\n        priorities[feasible_bins & close_to_full] += 2 # Bonus\n\n    return priorities",
    "response_id": 22,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Aims to balance bin utilization and avoid overfilling.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity < item:\n            priorities[i] = -np.inf  # Cannot fit, lowest priority\n        else:\n            # Calculate the fill ratio if the item is placed in the bin\n            fill_ratio = item / capacity\n            # Heuristic 1: Prefer bins that can be filled reasonably well, but not perfectly\n            # Avoid bins that are nearly empty or nearly full after adding the item\n            priority_fill_ratio = -abs(fill_ratio - 0.6) # Closer to 0.6 the better, can tune.\n\n            # Heuristic 2: Consider the remaining capacity after placing the item.\n            remaining_capacity = capacity - item\n            priority_remaining_capacity = remaining_capacity  # Prefer bins with higher remaining capacity, to accommodate future items.\n\n            # Heuristic 3: Penalize bins with capacity close to the item size.\n            if capacity <= 1.1*item:\n                priority_close_capacity = -10 # strongly penalize to avoid tight fills.\n            else:\n                priority_close_capacity = 0\n\n            # Combine the heuristics - prioritize based on a weighted sum.\n            priorities[i] = priority_fill_ratio + 0.5 * priority_remaining_capacity + priority_close_capacity\n\n    return priorities",
    "response_id": 23,
    "tryHS": false,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    A manifestation of my electrical intuition, harnessing resonance for optimal bin packing!\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Find bins that can fit the item\n    can_fit = bins_remain_cap >= item\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize bins that can fit the item\n    if np.any(can_fit):\n        # Calculate the wasted space if the item is placed in the bin. Prioritize fitting in snuggly.\n        wasted_space = bins_remain_cap - item\n        # Encourage using bins that provide minimal wastage by inverting.\n        priorities[can_fit] = 1.0 / (wasted_space[can_fit] + 0.0001) # Prevent division by zero.\n\n        # Amplifying resonance, enhancing difference\n        # Make bins which has closest waste value higher priority.\n        min_wasted_space = np.min(wasted_space[can_fit])\n        priorities[can_fit] += 10.0 * np.exp(-5.0 * (wasted_space[can_fit] - min_wasted_space))\n\n        # Balance utilization\n        bins_utilization = (bins_remain_cap[can_fit] - wasted_space[can_fit]) / bins_remain_cap[can_fit]\n        priorities[can_fit] += bins_utilization\n\n    # If no bin can fit the item, return all zero priorities, will raise error, handled outside.\n    # This mimics circuit overload behavior.\n\n    return priorities",
    "response_id": 24,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Employs a combined strategy: favors bins where the item fits reasonably well\n    (to avoid excessive fragmentation) and penalizes bins nearing full capacity\n    to delay their closure, increasing opportunity for later, larger items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, identify bins that can accommodate the item. Give -inf priority if can't fit.\n    can_fit = bins_remain_cap >= item\n    priorities = np.where(can_fit, 0.0, -np.inf)  # Large negative value for bins that can't fit\n\n    # If no bins can fit the item, return a vector with equal priority (random pick)\n    if not np.any(can_fit):\n        return np.ones_like(bins_remain_cap)\n\n    # Calculate how much space would be left after adding the item.\n    remaining_after_add = bins_remain_cap - item\n\n    # Ratio of used capacity AFTER adding the item to original remaining capacity.\n    # Aim to fill the bins moderately well.\n    capacity_utilization_ratio = (bins_remain_cap - remaining_after_add) / bins_remain_cap\n\n    # Give a bonus to bins where the item fills the space well (between 0.7 and 0.9)\n    # This range can be adjusted based on experimentation.\n    good_fit_bonus = np.where((capacity_utilization_ratio > 0.7) & (capacity_utilization_ratio < 0.9), 1.0, 0.0)\n\n    #Penalize bins close to full (less than item size remaining after adding) to increase chance of packing future large items\n    near_full_penalty = np.where(remaining_after_add < (0.1*bins_remain_cap.max()), -0.5, 0.0)  #Adjusting weight factor\n    # Combine the factors.\n    priorities = priorities + good_fit_bonus + near_full_penalty\n    return priorities",
    "response_id": 25,
    "tryHS": false,
    "obj": 8.895093737534907,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers multiple factors to prioritize bins:\n    1. Remaining capacity: Bins with sufficient capacity are preferred.\n    2. Waste minimization: Bins that minimize wasted space are preferred.\n    3. Avoidance of near-full bins: Penalizes bins that would become near-full.\n    4. Empty Bin Preference: Strongly prefers empty bins if the item fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    n_bins = len(bins_remain_cap)\n\n    for i in range(n_bins):\n        remaining_capacity = bins_remain_cap[i]\n\n        if remaining_capacity >= item:\n            # Empty Bin Preference (highest priority)\n            if remaining_capacity == bins_remain_cap.max() and remaining_capacity == bins_remain_cap.min():\n               priorities[i] += 1000.0 # Prefer the first empty bin\n\n            # Capacity-based score (minimize wasted space)\n            waste = remaining_capacity - item\n            priorities[i] += (1.0 / (waste + 0.0001))  # Avoid division by zero\n\n            # Remaining Capacity Reward\n            priorities[i] += remaining_capacity\n\n            # Near-Full Penalty\n            if remaining_capacity - item < 0.1:  # Adjust threshold as needed\n                priorities[i] -= 50  # High Penalty\n        else:\n            # Negative priority for bins that cannot accommodate the item\n            priorities[i] = -10000 # Should be smaller than all possible positive priorities\n\n    return priorities",
    "response_id": 26,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99999241098703 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function combines several heuristics inspired by physics:\n    1.  **Inverse Capacity Difference:** Bins with remaining capacity closer to the item size are preferred. Think of it as a potential energy well where the item prefers to settle.\n    2.  **Boltzmann Distribution (Temperature):** Introduce a \"temperature\" parameter to control the exploration vs. exploitation.  Higher temperature flattens the priorities, encouraging exploration of less-full bins. Lower temperature makes the decision more deterministic towards near-fit bins.\n    3.  **Gravitational Potential:** A slight preference for bins that are already somewhat full (lower remaining capacity) to consolidate items and free up entirely empty bins. This is a weak attraction to existing \"mass.\"  But only applicable if item fits!\n    4.  **Safety Margin:** A small penalty if the item *barely* fits, avoiding extremely tight packs that might cause issues later.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    temperature = 0.5 # Tunable parameter, controls exploration\n    gravity = 0.1 #Tunable parameter, strength of gravitational attraction\n\n    #Inverse capacity difference, with Boltzmann distribution applied\n    cap_diff = np.abs(bins_remain_cap - item)\n    boltzmann_factor = np.exp(-cap_diff / temperature)\n\n    #Gravitational Potential (only apply to bins where the item *fits*)\n    gravitational_potential = np.where(bins_remain_cap >= item, gravity / (bins_remain_cap + 1e-9), 0) #avoid zero div.\n\n    #Safety Margin: Slightly penalize near fits\n    near_fit_penalty = np.where(np.logical_and(bins_remain_cap >= item, bins_remain_cap < (item + 0.1)), -0.2, 0) # slightly penalise if within 0.1 of item size.\n\n    #Combine the heuristics\n    priorities = boltzmann_factor + gravitational_potential + near_fit_penalty\n\n\n    return priorities",
    "response_id": 27,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # First priority: Can the item fit?\n            priority = 1.0\n\n            # Prioritize bins with less wasted space, but not excessively.\n            waste = cap - item\n            priority += np.exp(-waste)  # Smaller waste is better\n\n            # Prioritize bins closer to being full to capacity if item fits well\n            priority += item/cap\n            priorities[i] = priority\n    return priorities",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Encourages filling bins as much as possible (minimize wasted space)\n    but penalizes bins that are too full after placing item. Also give preference\n    to bins which can accommodate the item to minimize fragmentation\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            # Preference to bins that can fit the item\n            fill_ratio = item / capacity\n\n            # Encourage bins to be filled completely but not overfilled\n            priority = (1 - np.abs(fill_ratio - 0.8)) #0.8 selected by experimentation to see performance\n\n            #Add scaling for remaining capacity, to prefer filling bins\n            remaining_capacity = capacity - item\n            priority = priority + (1-remaining_capacity/capacity) #Higher priority for less remaining\n            priorities[i] = priority\n\n        else:\n            priorities[i] = -np.inf  # Cannot fit, so lowest priority\n\n    return priorities",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.47746310331074,
    "exec_success": true
  }
]