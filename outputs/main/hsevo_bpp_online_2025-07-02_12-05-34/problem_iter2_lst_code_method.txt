{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, identify bins that can actually fit the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # If no bins can fit, assign low priority to all (might need a new bin)\n        return priorities\n\n    # For valid bins, calculate a \"fit score\"\n    fit_score = bins_remain_cap[valid_bins] - item  # Remaining space after placing the item\n\n    # Give higher priority to bins where the item fits snugly (minimize wasted space)\n    # We can use the inverse of the remaining space as a priority\n    priorities[valid_bins] = 1.0 / (fit_score + 0.0001) # Avoid division by zero\n\n    #Boost priority for bins close to being half empty, could potentially improve packing next items\n    half_empty_score = np.abs(bins_remain_cap[valid_bins] - bins_remain_cap.max()/2)\n    priorities[valid_bins] += 1.0/(half_empty_score+0.0001)\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    A manifestation of my electrical intuition, harnessing resonance for optimal bin packing!\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Find bins that can fit the item\n    can_fit = bins_remain_cap >= item\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize bins that can fit the item\n    if np.any(can_fit):\n        # Calculate the wasted space if the item is placed in the bin. Prioritize fitting in snuggly.\n        wasted_space = bins_remain_cap - item\n        # Encourage using bins that provide minimal wastage by inverting.\n        priorities[can_fit] = 1.0 / (wasted_space[can_fit] + 0.0001) # Prevent division by zero.\n\n        # Amplifying resonance, enhancing difference\n        # Make bins which has closest waste value higher priority.\n        min_wasted_space = np.min(wasted_space[can_fit])\n        priorities[can_fit] += 10.0 * np.exp(-5.0 * (wasted_space[can_fit] - min_wasted_space))\n\n        # Balance utilization\n        bins_utilization = (bins_remain_cap[can_fit] - wasted_space[can_fit]) / bins_remain_cap[can_fit]\n        priorities[can_fit] += bins_utilization\n\n    # If no bin can fit the item, return all zero priorities, will raise error, handled outside.\n    # This mimics circuit overload behavior.\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version prioritizes bins that can accommodate the item with minimal waste,\n    but also includes a stochastic element to avoid getting stuck in local optima.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate waste if item is placed in each bin. Negative waste means the item doesn't fit.\n    waste = bins_remain_cap - item\n\n    # Give bins that can fit the item a priority based on how little waste there is.\n    # Use a large negative number for bins that can't fit the item to strongly discourage them.\n    priorities = -np.abs(waste)\n    priorities[waste < 0] = -np.inf\n\n    # Add a small amount of randomness to break ties and escape local optima.\n    # The amount of randomness scales with the item size.  Smaller item = more randomness.\n    randomness = np.random.rand(len(bins_remain_cap)) * (0.1 / (item+0.00001) )  # avoid division by zero. small item makes more random.\n\n    priorities = priorities + randomness\n\n    # If no bins can accommodate the item, return a low priority for all bins.  In practice a new bin will be created if all are negative inf\n    if np.all(waste < 0):\n         priorities = -np.ones(len(bins_remain_cap)) * (item *100) # discourage using any existing bins heavily.\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Initialize priorities with a default low value\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf\n\n    # Identify bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):  # Check if there are any bins where the item can fit\n\n        # Calculate the waste if the item is placed in each valid bin\n        waste = bins_remain_cap[valid_bins] - item\n\n        # Heuristic 1: Minimize Waste (First-Fit Decreasing adaptation):\n        #   Prioritize bins with the least waste.  This attempts to leave\n        #   bins full to allow for the insertion of larger subsequent items.\n        priorities[valid_bins] = -waste\n\n        # Heuristic 2: Fill percentage, to avoid large wastes.  This encourages utilization.\n        fill_percentage = item / bins_remain_cap[valid_bins]\n        priorities[valid_bins] += fill_percentage\n\n        # Heuristic 3: Moderate bin utilization before favoring near-full bins\n        #   This helps in avoiding creating too many almost-empty bins\n        #   when early items are small.  This acts as a slight balancing factor.\n        priorities[valid_bins] += (bins_remain_cap[valid_bins] > 0.5) * 0.1  # Small bonus\n\n        #If the item is larger than half of bin's capacity then strongly prioritise them for balancing load\n        priorities[valid_bins] += (item > 0.5) * (bins_remain_cap[valid_bins]/bins_remain_cap[valid_bins].max()) * 0.2\n        # Heuristic 4: If several bins has minimum waste, try to choose bin with lowest index.\n        #   It will help to have similar results in similar circumstances\n    else:\n        # If no bins can fit the item, return very small priorities\n        pass\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins that can fit the item almost perfectly.\n    # This encourages filling bins as much as possible.\n\n    fit_within_capacity = bins_remain_cap >= item\n    if np.any(fit_within_capacity):\n        # Calculate wasted space for bins that can fit. We want to MINIMIZE the waste\n        wasted_space = bins_remain_cap[fit_within_capacity] - item\n        #The least wasted space means higher priority\n        priorities[fit_within_capacity] = 1.0 / (1e-6 + wasted_space) #Add a small number to avoid division by zero.\n    \n        #Heuristic for preventing too many almost full bins. Penalize almost full\n        #but still valid bins less if there are not too many\n        almost_full_mask = (wasted_space > 0) & (wasted_space < 0.1)\n        \n        if(np.sum(almost_full_mask)>0):\n            num_available = np.sum(fit_within_capacity)\n\n            priorities[fit_within_capacity] *= (1 + 0.1 * (num_available - np.sum(almost_full_mask))/num_available)\n\n    #Heuristic: If no bin can fit the item, put the item into the largest possible bin. This may create a new bin eventually but prevents creating numerous partially empty bins.\n    else:\n        priorities = bins_remain_cap/item #Assigns high priority to largest remaining capacities\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    A manifestation of my electrical intuition, harnessing resonance for optimal bin packing!\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Find bins that can fit the item\n    can_fit = bins_remain_cap >= item\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize bins that can fit the item\n    if np.any(can_fit):\n        # Calculate the wasted space if the item is placed in the bin. Prioritize fitting in snuggly.\n        wasted_space = bins_remain_cap - item\n        # Encourage using bins that provide minimal wastage by inverting.\n        priorities[can_fit] = 1.0 / (wasted_space[can_fit] + 0.0001) # Prevent division by zero.\n\n        # Amplifying resonance, enhancing difference\n        # Make bins which has closest waste value higher priority.\n        min_wasted_space = np.min(wasted_space[can_fit])\n        priorities[can_fit] += 10.0 * np.exp(-5.0 * (wasted_space[can_fit] - min_wasted_space))\n\n        # Balance utilization\n        bins_utilization = (bins_remain_cap[can_fit] - wasted_space[can_fit]) / bins_remain_cap[can_fit]\n        priorities[can_fit] += bins_utilization\n\n    # If no bin can fit the item, return all zero priorities, will raise error, handled outside.\n    # This mimics circuit overload behavior.\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base score (e.g., all bins are initially somewhat desirable)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Reward bins that can accommodate the item (avoiding wastage)\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1  # Higher base priority for bins that can fit\n\n    # Prioritize bins with capacity closest to item size (minimize fragmentation)\n    residual_capacity = bins_remain_cap - item\n    close_fit = np.abs(residual_capacity)\n    priorities[can_fit] += (1 / (1 + close_fit[can_fit])) # Smaller residuals are preferable (1/x, bounded)\n\n    # Penalize bins with large remaining capacity (delay filling completely empty bins)\n    priorities -= (bins_remain_cap / np.sum(bins_remain_cap))  # Reduce priority based on relative capacity.\n    # Slightly favor near-full bins\n    almost_full = (bins_remain_cap < item * 2) & (bins_remain_cap >= item)\n    priorities[almost_full] += 0.5 # Give a small bonus to partially filled bins that still fit the item\n\n    # Avoid bins that cannot fit, assign low priority (can be set to -inf but may cause issues)\n    priorities[~can_fit] = -1e9  # Vastly deprioritize infeasible bins.\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item relatively tightly,\n    while also discouraging near-empty bins if other more suitable options exist.\n    It balances the remaining capacity after placement with the original size, and penalizes bins that are too large relative to the item size, unless nearly full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Handle cases where the item doesn't fit in some bins:\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities # No valid bins at all. return zeros.\n\n    # Prioritize valid bins.\n    valid_bin_indices = np.where(valid_bins)[0] # Only work with bins the item can fit.\n\n    remaining_after = bins_remain_cap[valid_bins] - item\n    capacity_ratio = item / bins_remain_cap[valid_bins]\n    # 1. Tight fit is good. Small remainders are better. (But not zero)\n    tightness = 1 / (remaining_after + 0.0001)  # To avoid division by zero. Avoid completely full bin\n    tightness_score = tightness\n    # 2. Preferentially filling bins that are already partially full to make better use of existing bins before using new ones.\n    # Filling Score based on how full a bin already is (before the item is placed)\n    fullness_score = 1 - (bins_remain_cap[valid_bins] / bins_remain_cap.max()) # Higher score if already full\n    # Ensure all values are positive.\n    # Scale the filling score appropriately so we avoid empty bins as a default\n    priorities[valid_bin_indices] = (tightness_score * 0.7) + (fullness_score * 0.3)\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base score (e.g., all bins are initially somewhat desirable)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Reward bins that can accommodate the item (avoiding wastage)\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1  # Higher base priority for bins that can fit\n\n    # Prioritize bins with capacity closest to item size (minimize fragmentation)\n    residual_capacity = bins_remain_cap - item\n    close_fit = np.abs(residual_capacity)\n    priorities[can_fit] += (1 / (1 + close_fit[can_fit])) # Smaller residuals are preferable (1/x, bounded)\n\n    # Penalize bins with large remaining capacity (delay filling completely empty bins)\n    priorities -= (bins_remain_cap / np.sum(bins_remain_cap))  # Reduce priority based on relative capacity.\n    # Slightly favor near-full bins\n    almost_full = (bins_remain_cap < item * 2) & (bins_remain_cap >= item)\n    priorities[almost_full] += 0.5 # Give a small bonus to partially filled bins that still fit the item\n\n    # Avoid bins that cannot fit, assign low priority (can be set to -inf but may cause issues)\n    priorities[~can_fit] = -1e9  # Vastly deprioritize infeasible bins.\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Encourages filling bins as much as possible (minimize wasted space)\n    but penalizes bins that are too full after placing item. Also give preference\n    to bins which can accommodate the item to minimize fragmentation\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            # Preference to bins that can fit the item\n            fill_ratio = item / capacity\n\n            # Encourage bins to be filled completely but not overfilled\n            priority = (1 - np.abs(fill_ratio - 0.8)) #0.8 selected by experimentation to see performance\n\n            #Add scaling for remaining capacity, to prefer filling bins\n            remaining_capacity = capacity - item\n            priority = priority + (1-remaining_capacity/capacity) #Higher priority for less remaining\n            priorities[i] = priority\n\n        else:\n            priorities[i] = -np.inf  # Cannot fit, so lowest priority\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Encourages filling bins as much as possible (minimize wasted space)\n    but penalizes bins that are too full after placing item. Also give preference\n    to bins which can accommodate the item to minimize fragmentation\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            # Preference to bins that can fit the item\n            fill_ratio = item / capacity\n\n            # Encourage bins to be filled completely but not overfilled\n            priority = (1 - np.abs(fill_ratio - 0.8)) #0.8 selected by experimentation to see performance\n\n            #Add scaling for remaining capacity, to prefer filling bins\n            remaining_capacity = capacity - item\n            priority = priority + (1-remaining_capacity/capacity) #Higher priority for less remaining\n            priorities[i] = priority\n\n        else:\n            priorities[i] = -np.inf  # Cannot fit, so lowest priority\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Employs a combined strategy: favors bins where the item fits reasonably well\n    (to avoid excessive fragmentation) and penalizes bins nearing full capacity\n    to delay their closure, increasing opportunity for later, larger items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, identify bins that can accommodate the item. Give -inf priority if can't fit.\n    can_fit = bins_remain_cap >= item\n    priorities = np.where(can_fit, 0.0, -np.inf)  # Large negative value for bins that can't fit\n\n    # If no bins can fit the item, return a vector with equal priority (random pick)\n    if not np.any(can_fit):\n        return np.ones_like(bins_remain_cap)\n\n    # Calculate how much space would be left after adding the item.\n    remaining_after_add = bins_remain_cap - item\n\n    # Ratio of used capacity AFTER adding the item to original remaining capacity.\n    # Aim to fill the bins moderately well.\n    capacity_utilization_ratio = (bins_remain_cap - remaining_after_add) / bins_remain_cap\n\n    # Give a bonus to bins where the item fills the space well (between 0.7 and 0.9)\n    # This range can be adjusted based on experimentation.\n    good_fit_bonus = np.where((capacity_utilization_ratio > 0.7) & (capacity_utilization_ratio < 0.9), 1.0, 0.0)\n\n    #Penalize bins close to full (less than item size remaining after adding) to increase chance of packing future large items\n    near_full_penalty = np.where(remaining_after_add < (0.1*bins_remain_cap.max()), -0.5, 0.0)  #Adjusting weight factor\n    # Combine the factors.\n    priorities = priorities + good_fit_bonus + near_full_penalty\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Employs a combined strategy: favors bins where the item fits reasonably well\n    (to avoid excessive fragmentation) and penalizes bins nearing full capacity\n    to delay their closure, increasing opportunity for later, larger items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, identify bins that can accommodate the item. Give -inf priority if can't fit.\n    can_fit = bins_remain_cap >= item\n    priorities = np.where(can_fit, 0.0, -np.inf)  # Large negative value for bins that can't fit\n\n    # If no bins can fit the item, return a vector with equal priority (random pick)\n    if not np.any(can_fit):\n        return np.ones_like(bins_remain_cap)\n\n    # Calculate how much space would be left after adding the item.\n    remaining_after_add = bins_remain_cap - item\n\n    # Ratio of used capacity AFTER adding the item to original remaining capacity.\n    # Aim to fill the bins moderately well.\n    capacity_utilization_ratio = (bins_remain_cap - remaining_after_add) / bins_remain_cap\n\n    # Give a bonus to bins where the item fills the space well (between 0.7 and 0.9)\n    # This range can be adjusted based on experimentation.\n    good_fit_bonus = np.where((capacity_utilization_ratio > 0.7) & (capacity_utilization_ratio < 0.9), 1.0, 0.0)\n\n    #Penalize bins close to full (less than item size remaining after adding) to increase chance of packing future large items\n    near_full_penalty = np.where(remaining_after_add < (0.1*bins_remain_cap.max()), -0.5, 0.0)  #Adjusting weight factor\n    # Combine the factors.\n    priorities = priorities + good_fit_bonus + near_full_penalty\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Employs a combined strategy: favors bins where the item fits reasonably well\n    (to avoid excessive fragmentation) and penalizes bins nearing full capacity\n    to delay their closure, increasing opportunity for later, larger items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, identify bins that can accommodate the item. Give -inf priority if can't fit.\n    can_fit = bins_remain_cap >= item\n    priorities = np.where(can_fit, 0.0, -np.inf)  # Large negative value for bins that can't fit\n\n    # If no bins can fit the item, return a vector with equal priority (random pick)\n    if not np.any(can_fit):\n        return np.ones_like(bins_remain_cap)\n\n    # Calculate how much space would be left after adding the item.\n    remaining_after_add = bins_remain_cap - item\n\n    # Ratio of used capacity AFTER adding the item to original remaining capacity.\n    # Aim to fill the bins moderately well.\n    capacity_utilization_ratio = (bins_remain_cap - remaining_after_add) / bins_remain_cap\n\n    # Give a bonus to bins where the item fills the space well (between 0.7 and 0.9)\n    # This range can be adjusted based on experimentation.\n    good_fit_bonus = np.where((capacity_utilization_ratio > 0.7) & (capacity_utilization_ratio < 0.9), 1.0, 0.0)\n\n    #Penalize bins close to full (less than item size remaining after adding) to increase chance of packing future large items\n    near_full_penalty = np.where(remaining_after_add < (0.1*bins_remain_cap.max()), -0.5, 0.0)  #Adjusting weight factor\n    # Combine the factors.\n    priorities = priorities + good_fit_bonus + near_full_penalty\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Employs a combined strategy: favors bins where the item fits reasonably well\n    (to avoid excessive fragmentation) and penalizes bins nearing full capacity\n    to delay their closure, increasing opportunity for later, larger items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, identify bins that can accommodate the item. Give -inf priority if can't fit.\n    can_fit = bins_remain_cap >= item\n    priorities = np.where(can_fit, 0.0, -np.inf)  # Large negative value for bins that can't fit\n\n    # If no bins can fit the item, return a vector with equal priority (random pick)\n    if not np.any(can_fit):\n        return np.ones_like(bins_remain_cap)\n\n    # Calculate how much space would be left after adding the item.\n    remaining_after_add = bins_remain_cap - item\n\n    # Ratio of used capacity AFTER adding the item to original remaining capacity.\n    # Aim to fill the bins moderately well.\n    capacity_utilization_ratio = (bins_remain_cap - remaining_after_add) / bins_remain_cap\n\n    # Give a bonus to bins where the item fills the space well (between 0.7 and 0.9)\n    # This range can be adjusted based on experimentation.\n    good_fit_bonus = np.where((capacity_utilization_ratio > 0.7) & (capacity_utilization_ratio < 0.9), 1.0, 0.0)\n\n    #Penalize bins close to full (less than item size remaining after adding) to increase chance of packing future large items\n    near_full_penalty = np.where(remaining_after_add < (0.1*bins_remain_cap.max()), -0.5, 0.0)  #Adjusting weight factor\n    # Combine the factors.\n    priorities = priorities + good_fit_bonus + near_full_penalty\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Employs a combined strategy: favors bins where the item fits reasonably well\n    (to avoid excessive fragmentation) and penalizes bins nearing full capacity\n    to delay their closure, increasing opportunity for later, larger items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, identify bins that can accommodate the item. Give -inf priority if can't fit.\n    can_fit = bins_remain_cap >= item\n    priorities = np.where(can_fit, 0.0, -np.inf)  # Large negative value for bins that can't fit\n\n    # If no bins can fit the item, return a vector with equal priority (random pick)\n    if not np.any(can_fit):\n        return np.ones_like(bins_remain_cap)\n\n    # Calculate how much space would be left after adding the item.\n    remaining_after_add = bins_remain_cap - item\n\n    # Ratio of used capacity AFTER adding the item to original remaining capacity.\n    # Aim to fill the bins moderately well.\n    capacity_utilization_ratio = (bins_remain_cap - remaining_after_add) / bins_remain_cap\n\n    # Give a bonus to bins where the item fills the space well (between 0.7 and 0.9)\n    # This range can be adjusted based on experimentation.\n    good_fit_bonus = np.where((capacity_utilization_ratio > 0.7) & (capacity_utilization_ratio < 0.9), 1.0, 0.0)\n\n    #Penalize bins close to full (less than item size remaining after adding) to increase chance of packing future large items\n    near_full_penalty = np.where(remaining_after_add < (0.1*bins_remain_cap.max()), -0.5, 0.0)  #Adjusting weight factor\n    # Combine the factors.\n    priorities = priorities + good_fit_bonus + near_full_penalty\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    A subtle blend of gravity and least-action principles, balanced with a touch of divine chaos.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Initialize priorities with small values.  Let no bin start at absolute zero, for nature abhors a vacuum.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) + 1e-9  # Ensure non-zero values to prevent division errors and ensure that zero capacity bins have non-zero values (penalized later).\n\n    # Gravity component:  Bins closer to the item's size attract more strongly. Inverse square law, naturally.\n    gravity = np.exp(-((bins_remain_cap - item)**2) / (2 * (item/3)**2)) # A gaussian function.\n\n    # Least action: Favor bins where the item fits almost perfectly, avoiding both waste and overflow.  Think of it as minimizing wasted potential energy.\n    waste = bins_remain_cap - item  # How much space remains after adding the item\n    # Give very low priority (large negative number) if waste is negative. Let nature abhor overflow.\n    waste_penalty = np.where(waste < 0, -1e9, 0)\n    waste[waste < 0] = 0  # Reset negative waste to 0 for calculations.\n\n    # Prefer smaller waste amounts, to avoid having bins with much empty spaces,\n    # however, avoid too small wastes to avoid bins that overflow when perturbed by small changes.\n\n    waste_optimization = np.exp(-(waste**2)/((item/4)**2))\n\n    # Combine the forces: Gravity attracts, least action guides. Let there be balance.\n    priorities = gravity * waste_optimization + waste_penalty\n\n    # Introduce a touch of divine chaos:  A small random element to prevent settling into local minima. The subtle hand of the Almighty.\n    priorities += np.random.normal(0, 0.01, size=bins_remain_cap.shape)\n\n    # Ensure bins that cannot fit the item have VERY low priority. Bins that cannot accommodate shall not be considered.\n    priorities[bins_remain_cap < item] = -1e9\n\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Utilizes a combination of fill ratio, wasted space penalty, and a preference for bins that can perfectly fit items.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Small constant to avoid division by zero.\n    epsilon = 1e-9\n    \n    # Calculate the fill ratio for each bin if the item were placed in it.\n    fill_ratios = item / (bins_remain_cap + epsilon)  # Add epsilon to avoid div by 0\n    \n    # Initialize priorities with the fill ratio (higher fill ratio is generally better).\n    priorities = fill_ratios.copy()\n\n    #Perfect fit heuristic\n    perfect_fit_bonus = np.isclose(item, bins_remain_cap).astype(float) * 10\n\n    #Add bonus for perfect fit\n    priorities = priorities + perfect_fit_bonus\n\n    # Penalize bins where the item doesn't fit (set priority to a very low value)\n    priorities[item > bins_remain_cap] = -np.inf\n    \n    #Adjust by available capacity, prefer higher remaining capacity.\n    priorities = priorities + bins_remain_cap * 0.1\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Utilizes a combination of fill ratio, wasted space penalty, and a preference for bins that can perfectly fit items.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Small constant to avoid division by zero.\n    epsilon = 1e-9\n    \n    # Calculate the fill ratio for each bin if the item were placed in it.\n    fill_ratios = item / (bins_remain_cap + epsilon)  # Add epsilon to avoid div by 0\n    \n    # Initialize priorities with the fill ratio (higher fill ratio is generally better).\n    priorities = fill_ratios.copy()\n\n    #Perfect fit heuristic\n    perfect_fit_bonus = np.isclose(item, bins_remain_cap).astype(float) * 10\n\n    #Add bonus for perfect fit\n    priorities = priorities + perfect_fit_bonus\n\n    # Penalize bins where the item doesn't fit (set priority to a very low value)\n    priorities[item > bins_remain_cap] = -np.inf\n    \n    #Adjust by available capacity, prefer higher remaining capacity.\n    priorities = priorities + bins_remain_cap * 0.1\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Aims to balance bin utilization and avoid overfilling.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity < item:\n            priorities[i] = -np.inf  # Cannot fit, lowest priority\n        else:\n            # Calculate the fill ratio if the item is placed in the bin\n            fill_ratio = item / capacity\n            # Heuristic 1: Prefer bins that can be filled reasonably well, but not perfectly\n            # Avoid bins that are nearly empty or nearly full after adding the item\n            priority_fill_ratio = -abs(fill_ratio - 0.6) # Closer to 0.6 the better, can tune.\n\n            # Heuristic 2: Consider the remaining capacity after placing the item.\n            remaining_capacity = capacity - item\n            priority_remaining_capacity = remaining_capacity  # Prefer bins with higher remaining capacity, to accommodate future items.\n\n            # Heuristic 3: Penalize bins with capacity close to the item size.\n            if capacity <= 1.1*item:\n                priority_close_capacity = -10 # strongly penalize to avoid tight fills.\n            else:\n                priority_close_capacity = 0\n\n            # Combine the heuristics - prioritize based on a weighted sum.\n            priorities[i] = priority_fill_ratio + 0.5 * priority_remaining_capacity + priority_close_capacity\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}