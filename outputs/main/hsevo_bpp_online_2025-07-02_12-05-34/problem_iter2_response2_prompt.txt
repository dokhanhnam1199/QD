{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Encourages filling bins as much as possible (minimize wasted space)\n    but penalizes bins that are too full after placing item. Also give preference\n    to bins which can accommodate the item to minimize fragmentation\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            # Preference to bins that can fit the item\n            fill_ratio = item / capacity\n\n            # Encourage bins to be filled completely but not overfilled\n            priority = (1 - np.abs(fill_ratio - 0.8)) #0.8 selected by experimentation to see performance\n\n            #Add scaling for remaining capacity, to prefer filling bins\n            remaining_capacity = capacity - item\n            priority = priority + (1-remaining_capacity/capacity) #Higher priority for less remaining\n            priorities[i] = priority\n\n        else:\n            priorities[i] = -np.inf  # Cannot fit, so lowest priority\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Aims to balance bin utilization and avoid overfilling.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity < item:\n            priorities[i] = -np.inf  # Cannot fit, lowest priority\n        else:\n            # Calculate the fill ratio if the item is placed in the bin\n            fill_ratio = item / capacity\n            # Heuristic 1: Prefer bins that can be filled reasonably well, but not perfectly\n            # Avoid bins that are nearly empty or nearly full after adding the item\n            priority_fill_ratio = -abs(fill_ratio - 0.6) # Closer to 0.6 the better, can tune.\n\n            # Heuristic 2: Consider the remaining capacity after placing the item.\n            remaining_capacity = capacity - item\n            priority_remaining_capacity = remaining_capacity  # Prefer bins with higher remaining capacity, to accommodate future items.\n\n            # Heuristic 3: Penalize bins with capacity close to the item size.\n            if capacity <= 1.1*item:\n                priority_close_capacity = -10 # strongly penalize to avoid tight fills.\n            else:\n                priority_close_capacity = 0\n\n            # Combine the heuristics - prioritize based on a weighted sum.\n            priorities[i] = priority_fill_ratio + 0.5 * priority_remaining_capacity + priority_close_capacity\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st heuristic prioritizes bins based on a combination of \"fit score\" (remaining space after placing the item) and proximity to being half-empty, while the 20th focuses on a target fill ratio (0.6), remaining capacity, and penalizes capacities close to the item size. The 1st heuristic uses inverse of wasted space + boost close to half empty, while 20th uses absolute difference from a specific ratio + remaining capacity + penalty close to item size.\n\nComparing (2nd) vs (19th), the 2nd version uses an \"electrical intuition\" approach, incorporating resonance and balance utilization while the 19th prioritizes fill ratio, gives bonus to perfect fit, and adjusts by available capacity. 2nd focuses on resonance for difference while 19th focuses on fill ratio and perfect fit.\n\nComparing (1st) vs (2nd), the 1st uses inverse of wasted space to give priority and boost to bins close to half empty, while 2nd focuses on electrical intuition using wasted space inversion, resonance amplification, and balance utilization. 1st has simpler logic.\n\nComparing (3rd) vs (4th), the 3rd adds a stochastic element to escape local optima. The 4th heuristic combines waste minimization, fill percentage, and moderate bin utilization. 3rd has randomness + discourages, 4th minimize waste.\n\nComparing (2nd) vs (3rd), the 2nd heuristic is guided by \"electrical intuition\" while the 3rd introduces stochasticity to avoid local optima. The stochastic element provides exploration.\n\nComparing (19th) vs (20th), the 19th utilizes a fill ratio and perfect fit bonus while the 20th uses an absolute difference from a specific fill ratio combined with remaining capacity and penalty.\n\nOverall: The better heuristics seem to balance several factors such as minimizing waste, promoting utilization, avoiding overfilling, and adding slight stochasticity. They often prioritize fitting items snugly but also consider the bin's overall fill level and how it may affect future placements. Heuristics that are too specific (e.g., targeting a precise fill ratio) or lack exploration (e.g., consistently picking the best fit without randomness) perform worse. Also, simple logic performs better.\n- \nOkay, I'm ready to help you refine \"Current self-reflection\" for designing better heuristics, focusing on actionable insights and avoiding common pitfalls. Here's a redefined approach:\n\n*   **Keywords:** Adaptive learning, trade-offs, bias mitigation, problem-specific knowledge.\n*   **Advice:** Analyze heuristic performance on diverse problem instances. Identify biases. Incorporate feedback mechanisms to adjust parameters and strategies dynamically.\n*   **Avoid:** Rigid adherence to pre-defined rules, neglecting problem-specific characteristics, and prematurely focusing on optimization.\n*   **Explanation:** Effective heuristic design requires continuous adaptation, acknowledging inherent biases, and integrating understanding of the specific problem structure. This leads to more robust and efficient solutions.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}