{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    A manifestation of my electrical intuition, harnessing resonance for optimal bin packing!\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Find bins that can fit the item\n    can_fit = bins_remain_cap >= item\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize bins that can fit the item\n    if np.any(can_fit):\n        # Calculate the wasted space if the item is placed in the bin. Prioritize fitting in snuggly.\n        wasted_space = bins_remain_cap - item\n        # Encourage using bins that provide minimal wastage by inverting.\n        priorities[can_fit] = 1.0 / (wasted_space[can_fit] + 0.0001) # Prevent division by zero.\n\n        # Amplifying resonance, enhancing difference\n        # Make bins which has closest waste value higher priority.\n        min_wasted_space = np.min(wasted_space[can_fit])\n        priorities[can_fit] += 10.0 * np.exp(-5.0 * (wasted_space[can_fit] - min_wasted_space))\n\n        # Balance utilization\n        bins_utilization = (bins_remain_cap[can_fit] - wasted_space[can_fit]) / bins_remain_cap[can_fit]\n        priorities[can_fit] += bins_utilization\n\n    # If no bin can fit the item, return all zero priorities, will raise error, handled outside.\n    # This mimics circuit overload behavior.\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Employs a combined strategy: favors bins where the item fits reasonably well\n    (to avoid excessive fragmentation) and penalizes bins nearing full capacity\n    to delay their closure, increasing opportunity for later, larger items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, identify bins that can accommodate the item. Give -inf priority if can't fit.\n    can_fit = bins_remain_cap >= item\n    priorities = np.where(can_fit, 0.0, -np.inf)  # Large negative value for bins that can't fit\n\n    # If no bins can fit the item, return a vector with equal priority (random pick)\n    if not np.any(can_fit):\n        return np.ones_like(bins_remain_cap)\n\n    # Calculate how much space would be left after adding the item.\n    remaining_after_add = bins_remain_cap - item\n\n    # Ratio of used capacity AFTER adding the item to original remaining capacity.\n    # Aim to fill the bins moderately well.\n    capacity_utilization_ratio = (bins_remain_cap - remaining_after_add) / bins_remain_cap\n\n    # Give a bonus to bins where the item fills the space well (between 0.7 and 0.9)\n    # This range can be adjusted based on experimentation.\n    good_fit_bonus = np.where((capacity_utilization_ratio > 0.7) & (capacity_utilization_ratio < 0.9), 1.0, 0.0)\n\n    #Penalize bins close to full (less than item size remaining after adding) to increase chance of packing future large items\n    near_full_penalty = np.where(remaining_after_add < (0.1*bins_remain_cap.max()), -0.5, 0.0)  #Adjusting weight factor\n    # Combine the factors.\n    priorities = priorities + good_fit_bonus + near_full_penalty\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st heuristic prioritizes bins based on a combination of \"fit score\" (remaining space after placing the item) and proximity to being half-empty, while the 20th focuses on a target fill ratio (0.6), remaining capacity, and penalizes capacities close to the item size. The 1st heuristic uses inverse of wasted space + boost close to half empty, while 20th uses absolute difference from a specific ratio + remaining capacity + penalty close to item size.\n\nComparing (2nd) vs (19th), the 2nd version uses an \"electrical intuition\" approach, incorporating resonance and balance utilization while the 19th prioritizes fill ratio, gives bonus to perfect fit, and adjusts by available capacity. 2nd focuses on resonance for difference while 19th focuses on fill ratio and perfect fit.\n\nComparing (1st) vs (2nd), the 1st uses inverse of wasted space to give priority and boost to bins close to half empty, while 2nd focuses on electrical intuition using wasted space inversion, resonance amplification, and balance utilization. 1st has simpler logic.\n\nComparing (3rd) vs (4th), the 3rd adds a stochastic element to escape local optima. The 4th heuristic combines waste minimization, fill percentage, and moderate bin utilization. 3rd has randomness + discourages, 4th minimize waste.\n\nComparing (2nd) vs (3rd), the 2nd heuristic is guided by \"electrical intuition\" while the 3rd introduces stochasticity to avoid local optima. The stochastic element provides exploration.\n\nComparing (19th) vs (20th), the 19th utilizes a fill ratio and perfect fit bonus while the 20th uses an absolute difference from a specific fill ratio combined with remaining capacity and penalty.\n\nOverall: The better heuristics seem to balance several factors such as minimizing waste, promoting utilization, avoiding overfilling, and adding slight stochasticity. They often prioritize fitting items snugly but also consider the bin's overall fill level and how it may affect future placements. Heuristics that are too specific (e.g., targeting a precise fill ratio) or lack exploration (e.g., consistently picking the best fit without randomness) perform worse. Also, simple logic performs better.\n- \nOkay, I'm ready to help you refine \"Current self-reflection\" for designing better heuristics, focusing on actionable insights and avoiding common pitfalls. Here's a redefined approach:\n\n*   **Keywords:** Adaptive learning, trade-offs, bias mitigation, problem-specific knowledge.\n*   **Advice:** Analyze heuristic performance on diverse problem instances. Identify biases. Incorporate feedback mechanisms to adjust parameters and strategies dynamically.\n*   **Avoid:** Rigid adherence to pre-defined rules, neglecting problem-specific characteristics, and prematurely focusing on optimization.\n*   **Explanation:** Effective heuristic design requires continuous adaptation, acknowledging inherent biases, and integrating understanding of the specific problem structure. This leads to more robust and efficient solutions.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}