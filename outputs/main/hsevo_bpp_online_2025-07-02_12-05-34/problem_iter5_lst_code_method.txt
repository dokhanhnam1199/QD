{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, identify bins that can actually fit the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # If no bins can fit, assign low priority to all (might need a new bin)\n        return priorities\n\n    # For valid bins, calculate a \"fit score\"\n    fit_score = bins_remain_cap[valid_bins] - item  # Remaining space after placing the item\n\n    # Give higher priority to bins where the item fits snugly (minimize wasted space)\n    # We can use the inverse of the remaining space as a priority\n    priorities[valid_bins] = 1.0 / (fit_score + 0.0001) # Avoid division by zero\n\n    #Boost priority for bins close to being half empty, could potentially improve packing next items\n    half_empty_score = np.abs(bins_remain_cap[valid_bins] - bins_remain_cap.max()/2)\n    priorities[valid_bins] += 1.0/(half_empty_score+0.0001)\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, identify bins that can actually fit the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # If no bins can fit, assign low priority to all (might need a new bin)\n        return priorities\n\n    # For valid bins, calculate a \"fit score\"\n    fit_score = bins_remain_cap[valid_bins] - item  # Remaining space after placing the item\n\n    # Give higher priority to bins where the item fits snugly (minimize wasted space)\n    # We can use the inverse of the remaining space as a priority\n    priorities[valid_bins] = 1.0 / (fit_score + 0.0001) # Avoid division by zero\n\n    #Boost priority for bins close to being half empty, could potentially improve packing next items\n    half_empty_score = np.abs(bins_remain_cap[valid_bins] - bins_remain_cap.max()/2)\n    priorities[valid_bins] += 1.0/(half_empty_score+0.0001)\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, identify bins that can actually fit the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # If no bins can fit, assign low priority to all (might need a new bin)\n        return priorities\n\n    # For valid bins, calculate a \"fit score\"\n    fit_score = bins_remain_cap[valid_bins] - item  # Remaining space after placing the item\n\n    # Give higher priority to bins where the item fits snugly (minimize wasted space)\n    # We can use the inverse of the remaining space as a priority\n    priorities[valid_bins] = 1.0 / (fit_score + 0.0001) # Avoid division by zero\n\n    #Boost priority for bins close to being half empty, could potentially improve packing next items\n    half_empty_score = np.abs(bins_remain_cap[valid_bins] - bins_remain_cap.max()/2)\n    priorities[valid_bins] += 0.5/(half_empty_score+0.0001)\n\n    # Prioritize bins that are relatively full to consolidate items\n    fullness_score = bins_remain_cap[valid_bins] / bins_remain_cap.max()  # Fraction of capacity remaining\n    priorities[valid_bins] += 2* (1 - fullness_score) # Higher score for fuller bins (lower remaining capacity)\n\n    # Introduce a slight penalty for bins that are *too* close in size to the item\n    # This can sometimes prevent very tight fits that block future, potentially better fits.\n    too_close_threshold = item * 0.1  # e.g., if item is 10, penalize if remaining space is less than 1\n    too_close = fit_score < too_close_threshold\n    priorities[valid_bins][too_close] *= 0.75  # Reduce priority if too close.\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, identify bins that can actually fit the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # If no bins can fit, assign low priority to all (might need a new bin)\n        return priorities\n\n    # For valid bins, calculate a \"fit score\"\n    fit_score = bins_remain_cap[valid_bins] - item  # Remaining space after placing the item\n\n    # Give higher priority to bins where the item fits snugly (minimize wasted space)\n    # We can use the inverse of the remaining space as a priority\n    priorities[valid_bins] = 1.0 / (fit_score + 0.0001) # Avoid division by zero\n\n    # Boost priority for bins that have remaining capacity close to the item size.\n    item_proximity_score = np.abs(bins_remain_cap[valid_bins] - item)\n    priorities[valid_bins] += 1.0 / (item_proximity_score + 0.0001)\n\n    # Prioritize bins that are more full (avoid creating many almost-empty bins) but not too full\n    fullness_score = bins_remain_cap[valid_bins] / bins_remain_cap.max() # Normalized remaining capacity\n    priorities[valid_bins] += (1 - fullness_score) * 2 # Higher score for fuller bins\n\n    # Add a penalty for bins that will become too empty after placing the item\n    empty_threshold = 0.2 * bins_remain_cap.max()  # Threshold for \"too empty\" (20% of max capacity)\n    too_empty = (fit_score > empty_threshold)\n    priorities[valid_bins][too_empty] *= 0.5  # Reduce priority if it becomes too empty\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization, fill percentage, and balance bin utilization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = -waste  # Minimize waste\n        fill_percentage = item / bins_remain_cap[valid_bins]\n        priorities[valid_bins] += fill_percentage  # Fill percentage\n        priorities[valid_bins] += (bins_remain_cap[valid_bins] > 0.5) * 0.1  # Moderate use\n        remaining_after_add = bins_remain_cap[valid_bins] - item\n        near_full_penalty = np.where(remaining_after_add < (0.1*bins_remain_cap.max()), -0.5, 0.0)\n        priorities[valid_bins] += near_full_penalty\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, identify bins that can actually fit the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # If no bins can fit, assign low priority to all (might need a new bin)\n        return priorities\n\n    # For valid bins, calculate a \"fit score\"\n    fit_score = bins_remain_cap[valid_bins] - item  # Remaining space after placing the item\n\n    # Give higher priority to bins where the item fits snugly (minimize wasted space)\n    # We can use the inverse of the remaining space as a priority\n    priorities[valid_bins] = 1.0 / (fit_score + 0.0001) # Avoid division by zero\n\n    # Boost priority for bins that have remaining capacity close to the item size.\n    item_proximity_score = np.abs(bins_remain_cap[valid_bins] - item)\n    priorities[valid_bins] += 1.0 / (item_proximity_score + 0.0001)\n\n    # Prioritize bins that are more full (avoid creating many almost-empty bins) but not too full\n    fullness_score = bins_remain_cap[valid_bins] / bins_remain_cap.max() # Normalized remaining capacity\n    priorities[valid_bins] += (1 - fullness_score) * 2 # Higher score for fuller bins\n\n    # Add a penalty for bins that will become too empty after placing the item\n    empty_threshold = 0.2 * bins_remain_cap.max()  # Threshold for \"too empty\" (20% of max capacity)\n    too_empty = (fit_score > empty_threshold)\n    priorities[valid_bins][too_empty] *= 0.5  # Reduce priority if it becomes too empty\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines wasted space minimization and fill ratio prioritization.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fit_within_capacity = bins_remain_cap >= item\n\n    if np.any(fit_within_capacity):\n        wasted_space = bins_remain_cap[fit_within_capacity] - item\n        priorities[fit_within_capacity] = 1.0 / (1e-6 + wasted_space)\n\n        fill_ratios = item / bins_remain_cap[fit_within_capacity]\n        priorities[fit_within_capacity] += fill_ratios * 0.1  #fill ratio weight\n    else:\n        priorities = bins_remain_cap/item\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization, fill percentage, and balance bin utilization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = -waste  # Minimize waste\n        fill_percentage = item / bins_remain_cap[valid_bins]\n        priorities[valid_bins] += fill_percentage  # Fill percentage\n        priorities[valid_bins] += (bins_remain_cap[valid_bins] > 0.5) * 0.1  # Moderate use\n        remaining_after_add = bins_remain_cap[valid_bins] - item\n        near_full_penalty = np.where(remaining_after_add < (0.1*bins_remain_cap.max()), -0.5, 0.0)\n        priorities[valid_bins] += near_full_penalty\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and current fill level, with small penalty for near-full bins.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n\n    if not np.any(can_fit):\n        return priorities\n\n    valid_bins = np.where(can_fit)[0]\n    remaining_after = bins_remain_cap[can_fit] - item\n    tightness = 1 / (remaining_after + 0.0001)\n    fullness = 1 - (bins_remain_cap[can_fit] / bins_remain_cap.max())\n    near_full_penalty = np.where(remaining_after < (0.1 * bins_remain_cap.max()), -0.2, 0.0)  # Penalty if bin nearly full\n\n    priorities[valid_bins] = (0.6 * tightness) + (0.3 * fullness) + near_full_penalty\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and current fill level, with small penalty for near-full bins.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n\n    if not np.any(can_fit):\n        return priorities\n\n    valid_bins = np.where(can_fit)[0]\n    remaining_after = bins_remain_cap[can_fit] - item\n    tightness = 1 / (remaining_after + 0.0001)\n    fullness = 1 - (bins_remain_cap[can_fit] / bins_remain_cap.max())\n    near_full_penalty = np.where(remaining_after < (0.1 * bins_remain_cap.max()), -0.2, 0.0)  # Penalty if bin nearly full\n\n    priorities[valid_bins] = (0.6 * tightness) + (0.3 * fullness) + near_full_penalty\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                division_avoidance: float = 8.656090136839894e-05, \n                half_empty_weight: float = 0.9715594430076816, \n                fullness_weight: float = 1.8109582497427539, \n                too_close_fraction: float = 0.15953501070263026, \n                too_close_penalty: float = 0.7945007169142028) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_avoidance: small value to avoid division by zero\n        half_empty_weight: weight of the half empty score\n        fullness_weight: weight of the fullness score\n        too_close_fraction: The percentage of item size to determine 'too close'.\n        too_close_penalty: Reduction factor for bins that are too close in size to the item.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, identify bins that can actually fit the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # If no bins can fit, assign low priority to all (might need a new bin)\n        return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization & target utilization, avoids overfilling.\"\"\"\n    can_fit = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    priorities[can_fit] += 1\n\n    residual_capacity = bins_remain_cap - item\n    close_fit = np.abs(residual_capacity)\n    priorities[can_fit] += (1 / (1 + close_fit[can_fit]))\n\n    capacity_utilization_ratio = (bins_remain_cap - residual_capacity) / bins_remain_cap\n    good_fit_bonus = np.where((capacity_utilization_ratio > 0.7) & (capacity_utilization_ratio < 0.9), 0.5, 0.0)\n\n    priorities = priorities + good_fit_bonus\n    priorities[~can_fit] = -1e9\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # If no bins can fit, assign low priority to all (might need a new bin)\n        return priorities\n\n    # Calculate remaining space if item is placed in each valid bin\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Primary priority: Minimize wasted space (best fit)\n    priorities[valid_bins] = 1.0 / (remaining_space + 0.0001)\n\n    # Secondary priority:  Favor bins with remaining capacity close to a \"target\" value\n    # This encourages filling bins to a certain level without overfilling\n    # Target value can be a fraction of the bin capacity or based on item size distribution\n    target_capacity = 0.75 * bins_remain_cap.max()  # Example: Target 75% full\n    capacity_diff = np.abs(bins_remain_cap[valid_bins] - target_capacity)\n    priorities[valid_bins] += 0.5 / (capacity_diff + 0.0001)  # Scale this bonus\n\n    # Tertiary priority: Penalize bins that become nearly full after placing the item\n    # This discourages creating bins with very little remaining space,\n    # which are unlikely to be useful for subsequent items\n    nearly_full_threshold = 0.1 * bins_remain_cap.max()  # Example: Less than 10% remaining\n    nearly_full_penalty = (remaining_space < nearly_full_threshold) * 0.75  #Binary penalty: 0 or 0.75\n    priorities[valid_bins] -= nearly_full_penalty #subtract this from prioritiies\n\n    #Quaternary Priority: consider previous usage, penalize often used bins\n    bin_usage_counts = np.zeros_like(bins_remain_cap,dtype = float) # keep track of how many times a bin is used, initialize to 0\n    #priorities -= bin_usage_counts #simple penalization of often used bins\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # If no bins can fit, assign low priority to all (might need a new bin)\n        return priorities\n\n    # Calculate remaining space if item is placed in each valid bin\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Primary priority: Minimize wasted space (best fit)\n    priorities[valid_bins] = 1.0 / (remaining_space + 0.0001)\n\n    # Secondary priority:  Favor bins with remaining capacity close to a \"target\" value\n    # This encourages filling bins to a certain level without overfilling\n    # Target value can be a fraction of the bin capacity or based on item size distribution\n    target_capacity = 0.75 * bins_remain_cap.max()  # Example: Target 75% full\n    capacity_diff = np.abs(bins_remain_cap[valid_bins] - target_capacity)\n    priorities[valid_bins] += 0.5 / (capacity_diff + 0.0001)  # Scale this bonus\n\n    # Tertiary priority: Penalize bins that become nearly full after placing the item\n    # This discourages creating bins with very little remaining space,\n    # which are unlikely to be useful for subsequent items\n    nearly_full_threshold = 0.1 * bins_remain_cap.max()  # Example: Less than 10% remaining\n    nearly_full_penalty = (remaining_space < nearly_full_threshold) * 0.75  #Binary penalty: 0 or 0.75\n    priorities[valid_bins] -= nearly_full_penalty #subtract this from prioritiies\n\n    #Quaternary Priority: consider previous usage, penalize often used bins\n    bin_usage_counts = np.zeros_like(bins_remain_cap,dtype = float) # keep track of how many times a bin is used, initialize to 0\n    #priorities -= bin_usage_counts #simple penalization of often used bins\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # If no bins can fit, assign low priority to all (might need a new bin)\n        return priorities\n\n    # Calculate remaining space if item is placed in each valid bin\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Primary priority: Minimize wasted space (best fit)\n    priorities[valid_bins] = 1.0 / (remaining_space + 0.0001)\n\n    # Secondary priority:  Favor bins with remaining capacity close to a \"target\" value\n    # This encourages filling bins to a certain level without overfilling\n    # Target value can be a fraction of the bin capacity or based on item size distribution\n    target_capacity = 0.75 * bins_remain_cap.max()  # Example: Target 75% full\n    capacity_diff = np.abs(bins_remain_cap[valid_bins] - target_capacity)\n    priorities[valid_bins] += 0.5 / (capacity_diff + 0.0001)  # Scale this bonus\n\n    # Tertiary priority: Penalize bins that become nearly full after placing the item\n    # This discourages creating bins with very little remaining space,\n    # which are unlikely to be useful for subsequent items\n    nearly_full_threshold = 0.1 * bins_remain_cap.max()  # Example: Less than 10% remaining\n    nearly_full_penalty = (remaining_space < nearly_full_threshold) * 0.75  #Binary penalty: 0 or 0.75\n    priorities[valid_bins] -= nearly_full_penalty #subtract this from prioritiies\n\n    #Quaternary Priority: consider previous usage, penalize often used bins\n    bin_usage_counts = np.zeros_like(bins_remain_cap,dtype = float) # keep track of how many times a bin is used, initialize to 0\n    #priorities -= bin_usage_counts #simple penalization of often used bins\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization and target fill ratio for bin priority.\"\"\"\n\n    can_fit = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if np.any(can_fit):\n        wasted_space = bins_remain_cap[can_fit] - item\n        priorities[can_fit] = 1.0 / (wasted_space + 0.0001)\n\n        fill_ratio = (bins_remain_cap[can_fit] - wasted_space) / bins_remain_cap[can_fit]\n        target_ratio = 0.6\n        priorities[can_fit] += 5.0 * np.exp(-((fill_ratio - target_ratio)**2) / 0.02) # gaussian curve\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill ratio target, remaining capacity, and penalizes tight fits.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity < item:\n            priorities[i] = -np.inf\n        else:\n            fill_ratio = item / capacity\n            priority_fill_ratio = -abs(fill_ratio - 0.8)  # Target fill around 0.8\n            remaining_capacity = capacity - item\n            priority_remaining_capacity = (1-remaining_capacity/capacity)\n            if capacity <= 1.1*item:\n                priority_close_capacity = -10\n            else:\n                priority_close_capacity = 0\n            priorities[i] = priority_fill_ratio + priority_remaining_capacity + priority_close_capacity\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill ratio target, remaining capacity, and penalizes tight fits.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity < item:\n            priorities[i] = -np.inf\n        else:\n            fill_ratio = item / capacity\n            priority_fill_ratio = -abs(fill_ratio - 0.8)  # Target fill around 0.8\n            remaining_capacity = capacity - item\n            priority_remaining_capacity = (1-remaining_capacity/capacity)\n            if capacity <= 1.1*item:\n                priority_close_capacity = -10\n            else:\n                priority_close_capacity = 0\n            priorities[i] = priority_fill_ratio + priority_remaining_capacity + priority_close_capacity\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        # If no bins can fit, assign low priority to all (might need a new bin)\n        return priorities\n\n    # Calculate remaining space after placing the item in valid bins\n    fit_score = bins_remain_cap[valid_bins] - item\n\n    # Prioritize bins with tighter fit (smaller remaining space)\n    priorities[valid_bins] = 1.0 / (fit_score + 0.0001)  # Avoid division by zero\n\n    # Introduce a \"balance\" factor - prioritize bins that, after placing the item,\n    # are closer to a target fill level (e.g., 75% full).  This encourages better\n    # utilization without over-committing to a bin. The target fill level\n    # can also be a parameter to tune adaptively.\n\n    target_fill_level = 0.75 * bins_remain_cap.max()  # 75% of bin capacity\n    balance_score = np.abs((bins_remain_cap[valid_bins] - item) - target_fill_level)\n    priorities[valid_bins] += 1.0 / (balance_score + 0.0001)\n\n\n    #Add a small randomness to avoid getting stuck in local optima\n    priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * 0.01\n\n\n    #Penalize bins that would become nearly full after placing the item, avoids very small remaining space.\n    nearly_full_threshold = 0.1 * bins_remain_cap.max()\n    nearly_full_bins = (bins_remain_cap[valid_bins] - item) < nearly_full_threshold\n    priorities[valid_bins][nearly_full_bins] *= 0.5  # Reduce priority if nearly full\n\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and remaining capacity, with randomness.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    fit_score = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (fit_score + 0.0001)\n\n    # Add a bit of randomness to avoid local optima\n    priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * 0.1\n\n    # Boost priority based on remaining capacity relative to average.\n    avg_capacity = np.mean(bins_remain_cap)\n    capacity_diff = np.abs(bins_remain_cap[valid_bins] - avg_capacity)\n    priorities[valid_bins] += 1.0 / (capacity_diff + 0.0001)\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}