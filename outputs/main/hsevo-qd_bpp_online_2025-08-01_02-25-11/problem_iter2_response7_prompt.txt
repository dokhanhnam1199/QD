{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add an item to each bin,\n    guided by the principle of minimizing 'spatiotemporal curvature' or\n    'residual energy' within the bins, analogous to seeking a minimal\n    potential energy state (Best Fit).\n\n    This heuristic prioritizes bins that, after accommodating the item,\n    will leave the least amount of remaining capacity. This effectively\n    maximizes the 'packing density' for existing bins, aiming to reduce\n    the total number of required 'dimensional receptacles'. Bins that\n    cannot physically contain the item are assigned an infinitely low\n    priority, as they represent an 'inaccessible' state for the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        A higher score indicates a more favorable bin.\n    \"\"\"\n    # Calculate the hypothetical remaining space if the item were placed in each bin.\n    # This represents the 'residual void' or 'unfilled potential' after insertion.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priorities with an infinitely low value for all bins.\n    # This ensures that bins incapable of holding the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'accessible dimensions' \u2013 bins where the item can actually fit.\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For accessible bins, we apply the 'Best Fit' principle.\n    # We desire to minimize the 'potential_remaining_space', which translates\n    # to maximizing the *negative* of this value. A smaller positive remaining\n    # space (closer to a perfect fit) will result in a higher priority score.\n    # This steers the system towards the 'tightest' possible configuration,\n    # thereby consolidating items and minimizing the need for new bins.\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), both implement the \"Best Fit\" heuristic by prioritizing bins that will have the smallest remaining capacity. The core logic of assigning `-potential_remaining_cap` as priority and `-np.inf` for non-fitting bins is identical. The subtle difference lies in the order of operations: Heuristic 1st calculates `potential_remaining_cap` only for fitting bins after masking, while Heuristic 2nd calculates it for all bins first, then masks for assignment. The higher ranking of 1st suggests that masking *before* subtraction, potentially reducing the size of the temporary array for calculation, might offer a marginal performance or memory advantage in specific scenarios.\n\nComparing (2nd) vs (3rd), both aim for tight fits. Heuristic 2nd uses a direct linear negation (`-remaining_capacity`) for priority, while Heuristic 3rd uses an inverse relationship (`1.0 / (remaining_capacity + epsilon)`). The ranking indicates that the linear negation approach is superior. The non-linear inverse, while aiming to heavily favor tight fits, likely struggles due to the `epsilon` term (which introduces a fixed offset and can blur distinctions between very small non-zero remainders) or simply provides a less effective gradient for decision-making compared to the simple linear mapping.\n\nComparing (3rd) vs (4th), these two heuristics are functionally identical in their source code, docstrings, and comments. Their differing ranks suggest either non-deterministic performance variations in evaluation or an arbitrary distinction within the ranking of similar performing heuristics.\n\nComparing (10th) vs (11th), Heuristic 10th still correctly implements a \"Best Fit\" strategy, differentiating between bins and correctly assigning `-np.inf` for impossible fits. In contrast, Heuristic 11th returns a constant array of zeros, effectively providing no intelligent prioritization and failing to mark impossible fits. This highlights the critical importance of having any intelligent heuristic logic that correctly prioritizes and handles infeasibility, as even a basic \"Best Fit\" performs vastly better than a null operation.\n\nOverall, the list shows a clear hierarchy: sophisticated Best Fit variants (1st-10th) are superior to Best Fit variants with less optimal mathematical transformations (3rd-4th), which are in turn vastly superior to non-functional or non-prioritizing heuristics (11th-20th).\n- \nHere's a redefined self-reflection for designing better heuristics:\n\n*   **Keywords:** Transparency, Robustness, Simplicity, Iteration.\n*   **Advice:** Prioritize designs with clear, monotonic objective function relationships. Explicitly handle all feasibility constraints. Favor simpler linear logic over complex non-linearities unless thoroughly validated. Systematically build from robust baselines.\n*   **Avoid:** Obscure, non-interpretable logic; implicit or ignored constraint handling; arbitrary \"magic numbers\" or unverified transformations; and trying to leapfrog foundational improvements.\n*   **Explanation:** Effective self-reflection focuses on creating transparent, robust, and incrementally improvable heuristics by valuing clarity and systematic development over unproven complexity.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}