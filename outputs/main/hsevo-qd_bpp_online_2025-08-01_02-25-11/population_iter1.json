[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation aims for a \"Best Fit\" strategy:\n    It prioritizes bins that, after the item is placed, will have the smallest\n    remaining capacity. This helps to 'tightly pack' items into existing bins,\n    leaving larger capacities open for larger items or reducing fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Find bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # For fitting bins, we want to maximize the \"tightness\".\n    # A smaller remaining capacity means a tighter fit.\n    # To achieve this with argmax (which finds the maximum priority score),\n    # we can use the negative of the potential_remaining_cap.\n    # E.g., if remainders are [0.1, 0.5, 0.8], their negatives are [-0.1, -0.5, -0.8].\n    # The max of negatives is -0.1, which corresponds to the smallest positive remainder 0.1.\n    priorities[can_fit_mask] = -potential_remaining_cap\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin,\n    guided by the principle of minimizing 'spatiotemporal curvature' or\n    'residual energy' within the bins, analogous to seeking a minimal\n    potential energy state (Best Fit).\n\n    This heuristic prioritizes bins that, after accommodating the item,\n    will leave the least amount of remaining capacity. This effectively\n    maximizes the 'packing density' for existing bins, aiming to reduce\n    the total number of required 'dimensional receptacles'. Bins that\n    cannot physically contain the item are assigned an infinitely low\n    priority, as they represent an 'inaccessible' state for the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        A higher score indicates a more favorable bin.\n    \"\"\"\n    # Calculate the hypothetical remaining space if the item were placed in each bin.\n    # This represents the 'residual void' or 'unfilled potential' after insertion.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priorities with an infinitely low value for all bins.\n    # This ensures that bins incapable of holding the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'accessible dimensions' \u2013 bins where the item can actually fit.\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For accessible bins, we apply the 'Best Fit' principle.\n    # We desire to minimize the 'potential_remaining_space', which translates\n    # to maximizing the *negative* of this value. A smaller positive remaining\n    # space (closer to a perfect fit) will result in a higher priority score.\n    # This steers the system towards the 'tightest' possible configuration,\n    # thereby consolidating items and minimizing the need for new bins.\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    As Isaac Newton, I postulate that efficiency is paramount. We must strive\n    to achieve the most complete filling of each bin, thereby minimizing the\n    number of receptacles required. This method, which I term 'Best Fit',\n    prioritizes the bin that, after receiving the item, will have the smallest\n    remaining capacity. This ensures a tighter packing and leaves less\n    undesirable void.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable bin. Bins where the item\n        does not fit are assigned a very low (negative infinity) priority.\n    \"\"\"\n    # Initialize all priorities to a state of utter undesirability (negative infinity).\n    # This ensures that any bin where the item cannot fit will not be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Ascertain which bins possess the capacity to accommodate the item.\n    fits_mask = bins_remain_cap >= item\n\n    # For those bins where the item demonstrably fits, calculate the theoretical\n    # remaining capacity should the item be placed within.\n    potential_remaining_cap = bins_remain_cap[fits_mask] - item\n\n    # To embody the 'Best Fit' principle, we desire to minimize this\n    # 'potential_remaining_cap'. A smaller positive remainder is superior.\n    # Therefore, we assign priority as the negation of this remainder.\n    # A perfect fit (remainder = 0) yields a priority of 0, which is the\n    # highest possible score for a valid placement. Larger remainders result\n    # in more negative scores, thus lower priority.\n    priorities[fits_mask] = -potential_remaining_cap\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by the 'Best Fit' approach, we prioritize bins that, upon\n    receiving the item, will have the smallest remaining capacity,\n    thus ensuring a 'tightest fit' for our precious particles and\n    minimizing wasted space, much like finding the precise energy levels\n    for electrons in an atom. We assign a very low priority to bins\n    where the item simply does not fit, as they are not viable candidates.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item were hypothetically placed in each bin.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities. By default, all bins are given a very low priority\n    # (negative infinity) to ensure bins where the item does not fit are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item can actually fit.\n    can_fit_mask = potential_remaining_cap >= 0\n\n    # For bins where the item fits, assign a priority based on the negation of the\n    # potential remaining capacity. This way, a smaller positive remaining capacity\n    # (indicating a tighter fit) results in a larger (less negative) priority score.\n    # The bin with the highest priority will be the one leaving the least free space,\n    # ensuring the most efficient use of our bin \"matter.\"\n    priorities[can_fit_mask] = -potential_remaining_cap[can_fit_mask]\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    guided by the principle of \"Optimal Flux\" or \"Resonance Fit,\" reminiscent of my\n    work in efficient energy transmission. My aim is to utilize the available\n    'conduit' (bin) capacity with utmost precision, minimizing the 'waste' or\n    'unfilled potential' within each container.\n\n    A bin that perfectly accommodates an item, or leaves the smallest possible void,\n    is highly prized. This ensures a balanced and efficient distribution of 'load'\n    across our system, preventing a buildup of inefficiencies.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Initialize priorities. Bins that cannot fit the item receive a base priority of zero,\n    # making them ineligible for selection.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A minuscule constant to prevent infinite priority in the rare case of a perfect fit\n    # (where remaining_capacity_after_fit would be exactly zero).\n    # This represents the minimal 'quantum' of space that cannot be perfectly eliminated.\n    epsilon = 1e-9\n\n    # Determine which bins possess sufficient 'potential' (capacity) to hold the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For those capable bins, calculate the 'residual potential' or 'gap' after the item is placed.\n    # This is the amount of 'unoccupied flux' that would remain.\n    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Our 'Optimal Flux' heuristic dictates that the most desirable bin is one that leaves\n    # the smallest 'residual potential'. We achieve this by assigning a higher priority\n    # to bins where (remaining_capacity_after_fit + epsilon) is smaller.\n    # The reciprocal function naturally amplifies smaller values, creating a strong 'gravitational pull'\n    # towards the best fitting bin.\n    priorities[can_fit_mask] = 1.0 / (remaining_capacity_after_fit + epsilon)\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic embodies the principle of 'Best Fit', much like\n    the cosmos finds the most fitting orbit for its celestial bodies.\n    It prioritizes bins that will have the smallest remaining capacity\n    after the item is placed, thus 'snugly' fitting items and\n    preserving larger capacities for future celestial bodies.\n    Bins that cannot accommodate the item are given an infinitely low priority,\n    as they are not viable 'orbits' for the new 'planet'.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # We seek the bin that will be most 'filled' without overflowing.\n    potential_remaining_capacity = bins_remain_cap - item\n\n    # Initialize priority scores for all bins.\n    # By default, all bins are deemed infinitely unsuitable until proven otherwise.\n    priority_scores = np.full_like(bins_remain_cap, np.NINF, dtype=float)\n\n    # A mask to identify only those bins where the item can actually fit\n    # (i.e., where potential remaining capacity is non-negative).\n    can_fit_mask = potential_remaining_capacity >= 0\n\n    # For those bins where the item can be accommodated, we assign a priority.\n    # The Best Fit strategy aims to minimize the remaining capacity after placement.\n    # To convert this 'minimization' goal into a 'maximization' priority score,\n    # we take the negative of the potential remaining capacity.\n    # Thus, a smaller positive remaining capacity (e.g., 0.1) results in a larger\n    # (less negative, closer to zero) priority score (e.g., -0.1), making it\n    # the preferred choice when seeking the maximum priority.\n    priority_scores[can_fit_mask] = -potential_remaining_capacity[can_fit_mask]\n\n    return priority_scores",
    "response_id": 5,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 26, in priority_v2\n    Higher scores indicate a stronger gravitational pull towards selection.\n  File \"/home/dokhanhnam1199/.local/lib/python3.10/site-packages/numpy/__init__.py\", line 400, in __getattr__\n    raise AttributeError(\nAttributeError: `np.NINF` was removed in the NumPy 2.0 release. Use `-np.inf` instead.\n6\n1\n"
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    \"Gravitational Collapse\" Heuristic for Online Bin Packing.\n\n    Drawing inspiration from the relentless pull of gravity that compacts matter\n    into the densest possible states, this heuristic prioritizes bins that, upon\n    accommodating the given item, would have the smallest remaining capacity.\n\n    This strategy encourages \"tight fits,\" aiming to fill bins as completely as\n    possible before their internal 'volume' reaches a critical point of collapse\n    (i.e., minimal remaining space). A bin achieving a 'perfect fit' (remaining\n    capacity exactly zero) is given the ultimate priority, akin to a final,\n    irreversible gravitational collapse.\n\n    Bins that are too small to contain the item are deemed outside the event\n    horizon and are given the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        Higher scores indicate a stronger gravitational pull towards selection.\n    \"\"\"\n    # Initialize all priorities to a state of infinite repulsion (negative infinity)\n    # for bins that cannot even theoretically contain the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'regions of space-time' (bins) that can physically\n    # accommodate the incoming 'matter' (item).\n    can_fit_mask = bins_remain_cap >= item\n\n    # For those eligible regions, we calculate the remaining 'vacuum' (empty space)\n    # after the item is placed.\n    # A tiny epsilon ensures we don't divide by zero in the case of a 'perfect fit'\n    # where the remaining space is exactly zero, giving it the highest possible density score.\n    epsilon = np.finfo(float).eps\n\n    remaining_space_after_fit = bins_remain_cap[can_fit_mask] - item\n    \n    # The 'gravitational pull' (priority) is inversely proportional to the\n    # remaining 'vacuum'. A smaller remaining space implies a denser state\n    # and thus a stronger pull for the item.\n    priorities[can_fit_mask] = 1.0 / (remaining_space_after_fit + epsilon)\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    As Richard Feynman might say, \"The most elegant solution is often the one\n    that minimizes wasted potential.\" This implementation embodies the 'Best Fit'\n    heuristic, which aims to minimize the \"empty space potential\" remaining\n    in a bin after an item is placed. We seek the bin that will be left\n    with the smallest, non-negative gap, effectively \"snugly\" fitting the item\n    to maximize bin utilization and minimize the number of bins required.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable bin. Bins where the item\n        does not fit receive a very low (negative infinity) score.\n    \"\"\"\n    # Initialize scores. Bins where the item doesn't fit get a score of -infinity,\n    # ensuring they are never chosen unless absolutely no other option exists\n    # (which would typically lead to opening a new bin in the larger algorithm).\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # First, identify the bins where the item *can* actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins where the item fits, we calculate the \"tightness of fit\".\n    # The 'wasted potential' or 'gap' is (bin_capacity - item_size).\n    # We want to MINIMIZE this gap.\n    # To turn this into a priority score where HIGHER is better, we simply\n    # take the negative of the gap.\n    # A perfect fit (gap = 0) will yield the highest possible score (0).\n    # A small gap (e.g., 0.1) will yield a score of -0.1.\n    # A large gap (e.g., 10.0) will yield a score of -10.0.\n    # This naturally prioritizes the bins with the tightest, positive fit.\n    scores[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)\n\n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function implements a 'Best Fit' heuristic.\n    It prioritizes bins that will have the smallest remaining capacity\n    after the item is placed, thereby encouraging tighter packing.\n    Bins that cannot fit the item are given an extremely low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable bin.\n    \"\"\"\n    # Calculate the remaining capacity if the current item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_capacity = bins_remain_cap - item\n\n    # Initialize priority scores for all bins to a very low value (negative infinity).\n    # This ensures that bins where the item does not fit will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit (remaining capacity >= 0).\n    can_fit_mask = potential_remaining_capacity >= 0\n\n    # For bins where the item can fit, the priority is the negative of the\n    # potential remaining capacity. This means:\n    # - A smaller (closer to zero) positive remaining capacity will result in a\n    #   larger (closer to zero, i.e., less negative) priority score.\n    # - A larger remaining capacity will result in a smaller (more negative) priority score.\n    # This effectively makes the bin that becomes \"fullest\" (least remaining space)\n    # after placing the item the most preferred.\n    priorities[can_fit_mask] = -potential_remaining_capacity[can_fit_mask]\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic implements a \"Best-Fit Decreasing\" strategy by prioritizing\n    bins that, after the item is placed, would have the smallest remaining capacity.\n    This encourages tightly packed bins, preserving larger spaces for future larger items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher preference for the bin.\n    \"\"\"\n    # Calculate the remaining space if the current item were placed in each bin.\n    # For a Best-Fit approach, we aim to minimize this value for bins that can fit the item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priorities. Bins where the item does not fit should have a very low priority.\n    # Using -np.inf ensures these bins are never chosen if any valid option exists.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify bins where the item can actually fit (remaining capacity >= item size).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins where the item fits, the priority should be inversely related to the\n    # potential remaining space. A smaller remaining space implies a tighter fit,\n    # which is preferred. By taking the negative of the remaining space, a value of 0\n    # (perfect fit) yields the highest priority (0), and larger remaining spaces\n    # yield more negative (lower) priorities.\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]