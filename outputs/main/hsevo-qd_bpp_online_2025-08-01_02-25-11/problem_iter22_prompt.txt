{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"Combines Best Fit with an adaptive bonus for consolidating items into\n    already partially filled bins, encouraging finishing off existing bins.\n    \"\"\"\n    # This design prioritizes tight fits (Best Fit) and enhances consolidation.\n    # It introduces an adaptive bonus for already used bins, scaled by their current\n    # fill level, aiming to 'top off' existing bins and reduce the total bin count.\n\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # 1. Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Only consider bins where the item fits\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    if fitting_bins_remain_cap.size == 0:\n        return priorities # No bins can fit the item\n\n    # 2. Calculate remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = fitting_bins_remain_cap - item\n\n    # 3. Base priority: Best Fit strategy (minimize remaining capacity)\n    # A smaller potential_remaining_cap (closer to 0) means a tighter fit,\n    # which is preferred. By taking the negative, we convert minimization to maximization.\n    base_priorities = -potential_remaining_cap\n\n    # 4. Adaptive Consolidation Bonus:\n    # Bonus for already partially filled bins, proportional to their current fill level.\n    # This encourages 'topping off' bins that are already more full.\n    consolidation_scaling_factor = 0.001 # A small constant, tuneable\n\n    # Identify bins that are not \"fresh\" (i.e., not entirely empty/unused).\n    is_used_bin_mask = ~np.isclose(fitting_bins_remain_cap, bin_capacity, atol=1e-9)\n\n    # Calculate the current \"fill level\" for fitting bins\n    current_fill_level = bin_capacity - fitting_bins_remain_cap\n\n    # Apply the adaptive bonus only to bins that can fit and are already used.\n    adaptive_bonus = np.zeros_like(base_priorities)\n    adaptive_bonus[is_used_bin_mask] = consolidation_scaling_factor * current_fill_level[is_used_bin_mask]\n\n    # Combine base priority (Best Fit) and adaptive consolidation bonus\n    priorities[can_fit_mask] = base_priorities + adaptive_bonus\n\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}