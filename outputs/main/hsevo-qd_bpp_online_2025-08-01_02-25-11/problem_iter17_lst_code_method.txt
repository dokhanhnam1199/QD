{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic combines \"Best Fit\" with a \"Bin Consolidation\" and\n    \"Fragmentation Avoidance\" strategy. It aims to achieve global efficacy\n    through local, non-linear interactions, adapting to the current item's size.\n\n    The priority calculation is composed of:\n    1.  **Best Fit Core:** Prioritizes bins that result in the smallest\n        remaining capacity after the item is placed. This is the foundational\n        linear component.\n    2.  **Exact Fit Bonus (Non-linear):** Provides a significant, discrete\n        bonus for bins where the item fits perfectly, leading to zero\n        remaining capacity. This encourages complete bin utilization and closure.\n    3.  **Fragmentation Penalty (Non-linear & Adaptive):** Applies a penalty\n        to bins that, after placing the item, would be left with a small,\n        non-zero remaining capacity. This penalty is particularly harsh if the\n        remaining capacity is less than or equal to the current `item`'s size,\n        discouraging the creation of fragmented space that might be difficult\n        to fill with future items of similar scale. The penalty scales with\n        how close the remainder is to the `item`'s size, pushing towards\n        either very small remainders or sufficiently large (useful) ones.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins where the item can fit (capacity >= item size)\n    can_fit_mask = bins_remain_cap >= item\n\n    # Extract capacities for only the fitting bins\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # If no bin can fit the item, return priorities initialized to -inf\n    if fitting_bins_remain_cap.size == 0:\n        return priorities\n\n    # Calculate potential remaining capacity if the item were placed\n    potential_remaining_cap = fitting_bins_remain_cap - item\n\n    # --- Core Priority Calculation (Best Fit component) ---\n    # We negate the potential remaining capacity so that a smaller remainder\n    # results in a higher (less negative) priority score.\n    # Example: remaining 0.1 -> score -0.1; remaining 0.5 -> score -0.5.\n    calculated_priorities = -potential_remaining_cap\n\n    # --- Hybrid/Non-linear/Adaptive Components ---\n\n    # 1. Exact Fit Bonus: A strong, discrete non-linear bonus for perfect fits.\n    # This highly prioritizes bins that can be perfectly filled.\n    EXACT_FIT_THRESHOLD = 1e-9  # Tolerance for floating point comparisons to zero\n    EXACT_FIT_BONUS = 1000.0    # A large bonus to ensure exact fits are top priority\n\n    exact_fit_mask = np.isclose(potential_remaining_cap, 0.0, atol=EXACT_FIT_THRESHOLD)\n    calculated_priorities[exact_fit_mask] += EXACT_FIT_BONUS\n\n    # 2. Fragmentation Penalty: Penalize creating small, non-zero remnants.\n    # This aims to avoid \"awkward\" remaining capacities that are too small\n    # to be easily useful for typical future items, especially if they are\n    # a significant fraction of the current item's size.\n    \n    # Apply penalty only if the item size is positive to avoid division by zero.\n    # Item sizes in BPP are typically positive.\n    if item > EXACT_FIT_THRESHOLD:\n        # Define the \"fragmentation zone\": remaining capacities that are\n        # non-zero but less than or equal to the current item's size.\n        # This range is problematic as it's not an exact fit, but also not\n        # large enough to easily accommodate another item of the same size.\n        fragment_zone_mask = (potential_remaining_cap > EXACT_FIT_THRESHOLD) & \\\n                             (potential_remaining_cap <= item)\n\n        if np.any(fragment_zone_mask):\n            # Normalize the remaining capacity within this zone by the item's size.\n            # This makes the penalty adaptive to the scale of the current item.\n            normalized_fragment_rem = potential_remaining_cap[fragment_zone_mask] / item\n\n            # Apply a penalty that increases as the normalized remainder\n            # approaches 1 (i.e., remaining capacity is close to item's size).\n            # This strongly discourages leaving a bin with a capacity just\n            # slightly less than the item, effectively making it a \"dead space\".\n            # PENALTY_FACTOR is a tunable parameter controlling the penalty's strength.\n            PENALTY_FACTOR = 5.0 # Example: A factor of 5.0\n\n            penalty = -PENALTY_FACTOR * normalized_fragment_rem\n            calculated_priorities[fragment_zone_mask] += penalty\n\n    # Assign the calculated priorities to the fitting bins in the main array\n    priorities[can_fit_mask] = calculated_priorities\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic combines \"Best Fit\" with a \"Bin Consolidation\" and\n    \"Fragmentation Avoidance\" strategy. It aims to achieve global efficacy\n    through local, non-linear interactions, adapting to the current item's size.\n\n    The priority calculation is composed of:\n    1.  **Best Fit Core:** Prioritizes bins that result in the smallest\n        remaining capacity after the item is placed. This is the foundational\n        linear component.\n    2.  **Exact Fit Bonus (Non-linear):** Provides a significant, discrete\n        bonus for bins where the item fits perfectly, leading to zero\n        remaining capacity. This encourages complete bin utilization and closure.\n    3.  **Fragmentation Penalty (Non-linear & Adaptive):** Applies a penalty\n        to bins that, after placing the item, would be left with a small,\n        non-zero remaining capacity. This penalty is particularly harsh if the\n        remaining capacity is less than or equal to the current `item`'s size,\n        discouraging the creation of fragmented space that might be difficult\n        to fill with future items of similar scale. The penalty scales with\n        how close the remainder is to the `item`'s size, pushing towards\n        either very small remainders or sufficiently large (useful) ones.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins where the item can fit (capacity >= item size)\n    can_fit_mask = bins_remain_cap >= item\n\n    # Extract capacities for only the fitting bins\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # If no bin can fit the item, return priorities initialized to -inf\n    if fitting_bins_remain_cap.size == 0:\n        return priorities\n\n    # Calculate potential remaining capacity if the item were placed\n    potential_remaining_cap = fitting_bins_remain_cap - item\n\n    # --- Core Priority Calculation (Best Fit component) ---\n    # We negate the potential remaining capacity so that a smaller remainder\n    # results in a higher (less negative) priority score.\n    # Example: remaining 0.1 -> score -0.1; remaining 0.5 -> score -0.5.\n    calculated_priorities = -potential_remaining_cap\n\n    # --- Hybrid/Non-linear/Adaptive Components ---\n\n    # 1. Exact Fit Bonus: A strong, discrete non-linear bonus for perfect fits.\n    # This highly prioritizes bins that can be perfectly filled.\n    EXACT_FIT_THRESHOLD = 1e-9  # Tolerance for floating point comparisons to zero\n    EXACT_FIT_BONUS = 1000.0    # A large bonus to ensure exact fits are top priority\n\n    exact_fit_mask = np.isclose(potential_remaining_cap, 0.0, atol=EXACT_FIT_THRESHOLD)\n    calculated_priorities[exact_fit_mask] += EXACT_FIT_BONUS\n\n    # 2. Fragmentation Penalty: Penalize creating small, non-zero remnants.\n    # This aims to avoid \"awkward\" remaining capacities that are too small\n    # to be easily useful for typical future items, especially if they are\n    # a significant fraction of the current item's size.\n    \n    # Apply penalty only if the item size is positive to avoid division by zero.\n    # Item sizes in BPP are typically positive.\n    if item > EXACT_FIT_THRESHOLD:\n        # Define the \"fragmentation zone\": remaining capacities that are\n        # non-zero but less than or equal to the current item's size.\n        # This range is problematic as it's not an exact fit, but also not\n        # large enough to easily accommodate another item of the same size.\n        fragment_zone_mask = (potential_remaining_cap > EXACT_FIT_THRESHOLD) & \\\n                             (potential_remaining_cap <= item)\n\n        if np.any(fragment_zone_mask):\n            # Normalize the remaining capacity within this zone by the item's size.\n            # This makes the penalty adaptive to the scale of the current item.\n            normalized_fragment_rem = potential_remaining_cap[fragment_zone_mask] / item\n\n            # Apply a penalty that increases as the normalized remainder\n            # approaches 1 (i.e., remaining capacity is close to item's size).\n            # This strongly discourages leaving a bin with a capacity just\n            # slightly less than the item, effectively making it a \"dead space\".\n            # PENALTY_FACTOR is a tunable parameter controlling the penalty's strength.\n            PENALTY_FACTOR = 5.0 # Example: A factor of 5.0\n\n            penalty = -PENALTY_FACTOR * normalized_fragment_rem\n            calculated_priorities[fragment_zone_mask] += penalty\n\n    # Assign the calculated priorities to the fitting bins in the main array\n    priorities[can_fit_mask] = calculated_priorities\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic combines \"Best Fit\" with a \"Bin Consolidation\" and\n    \"Fragmentation Avoidance\" strategy. It aims to achieve global efficacy\n    through local, non-linear interactions, adapting to the current item's size.\n\n    The priority calculation is composed of:\n    1.  **Best Fit Core:** Prioritizes bins that result in the smallest\n        remaining capacity after the item is placed. This is the foundational\n        linear component.\n    2.  **Exact Fit Bonus (Non-linear):** Provides a significant, discrete\n        bonus for bins where the item fits perfectly, leading to zero\n        remaining capacity. This encourages complete bin utilization and closure.\n    3.  **Fragmentation Penalty (Non-linear & Adaptive):** Applies a penalty\n        to bins that, after placing the item, would be left with a small,\n        non-zero remaining capacity. This penalty is particularly harsh if the\n        remaining capacity is less than or equal to the current `item`'s size,\n        discouraging the creation of fragmented space that might be difficult\n        to fill with future items of similar scale. The penalty scales with\n        how close the remainder is to the `item`'s size, pushing towards\n        either very small remainders or sufficiently large (useful) ones.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins where the item can fit (capacity >= item size)\n    can_fit_mask = bins_remain_cap >= item\n\n    # Extract capacities for only the fitting bins\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # If no bin can fit the item, return priorities initialized to -inf\n    if fitting_bins_remain_cap.size == 0:\n        return priorities\n\n    # Calculate potential remaining capacity if the item were placed\n    potential_remaining_cap = fitting_bins_remain_cap - item\n\n    # --- Core Priority Calculation (Best Fit component) ---\n    # We negate the potential remaining capacity so that a smaller remainder\n    # results in a higher (less negative) priority score.\n    # Example: remaining 0.1 -> score -0.1; remaining 0.5 -> score -0.5.\n    calculated_priorities = -potential_remaining_cap\n\n    # --- Hybrid/Non-linear/Adaptive Components ---\n\n    # 1. Exact Fit Bonus: A strong, discrete non-linear bonus for perfect fits.\n    # This highly prioritizes bins that can be perfectly filled.\n    EXACT_FIT_THRESHOLD = 1e-9  # Tolerance for floating point comparisons to zero\n    EXACT_FIT_BONUS = 1000.0    # A large bonus to ensure exact fits are top priority\n\n    exact_fit_mask = np.isclose(potential_remaining_cap, 0.0, atol=EXACT_FIT_THRESHOLD)\n    calculated_priorities[exact_fit_mask] += EXACT_FIT_BONUS\n\n    # 2. Fragmentation Penalty: Penalize creating small, non-zero remnants.\n    # This aims to avoid \"awkward\" remaining capacities that are too small\n    # to be easily useful for typical future items, especially if they are\n    # a significant fraction of the current item's size.\n    \n    # Apply penalty only if the item size is positive to avoid division by zero.\n    # Item sizes in BPP are typically positive.\n    if item > EXACT_FIT_THRESHOLD:\n        # Define the \"fragmentation zone\": remaining capacities that are\n        # non-zero but less than or equal to the current item's size.\n        # This range is problematic as it's not an exact fit, but also not\n        # large enough to easily accommodate another item of the same size.\n        fragment_zone_mask = (potential_remaining_cap > EXACT_FIT_THRESHOLD) & \\\n                             (potential_remaining_cap <= item)\n\n        if np.any(fragment_zone_mask):\n            # Normalize the remaining capacity within this zone by the item's size.\n            # This makes the penalty adaptive to the scale of the current item.\n            normalized_fragment_rem = potential_remaining_cap[fragment_zone_mask] / item\n\n            # Apply a penalty that increases as the normalized remainder\n            # approaches 1 (i.e., remaining capacity is close to item's size).\n            # This strongly discourages leaving a bin with a capacity just\n            # slightly less than the item, effectively making it a \"dead space\".\n            # PENALTY_FACTOR is a tunable parameter controlling the penalty's strength.\n            PENALTY_FACTOR = 5.0 # Example: A factor of 5.0\n\n            penalty = -PENALTY_FACTOR * normalized_fragment_rem\n            calculated_priorities[fragment_zone_mask] += penalty\n\n    # Assign the calculated priorities to the fitting bins in the main array\n    priorities[can_fit_mask] = calculated_priorities\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for 'Best Fit' by maximizing the effective filled capacity.\n\n    Prioritizes bins that achieve the highest fill level after placing the item,\n    yielding positive scores for valid fits and penalizing impossible ones.\n    \"\"\"\n    # Initialize all priorities to an extremely low value, ensuring bins that cannot\n    # accommodate the item are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify which bins possess sufficient remaining capacity for the item.\n    fits_mask = bins_remain_cap >= item\n\n    # For bins where the item demonstrably fits, calculate a priority score.\n    # This score, 2 * item - bins_remain_cap[fits_mask], maximizes the resulting\n    # effective filled capacity relative to the item's size. A perfect fit\n    # (where the bin's remaining capacity becomes zero) yields the highest positive\n    # score (equal to `item`), while less efficient fits yield lower positive scores.\n    # This combines the efficiency of masking first with a positive-scaled Best Fit score.\n    priorities[fits_mask] = 2 * item - bins_remain_cap[fits_mask]\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"Combines Best Fit with a progressive consolidation bonus.\n    Prioritizes tighter fits but slightly favors bins that are already more filled,\n    encouraging consolidation and balanced bin usage.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # 1. Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    if not np.any(can_fit_mask):\n        return priorities # No bin can fit the item\n\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # 2. Base priority: Best Fit (minimize remaining capacity)\n    # A smaller potential_remaining_cap (closer to 0) means a tighter fit, which is preferred.\n    # By taking the negative, we convert minimization to maximization.\n    potential_remaining_cap = fitting_bins_remain_cap - item\n    base_priorities_fitting = -potential_remaining_cap\n\n    # 3. Consolidation Bonus: Encourage filling already used bins, scaled by their current fullness.\n    # This adapts the bonus based on how much a bin is already committed, promoting consolidation.\n    current_fullness_fitting = (bin_capacity - fitting_bins_remain_cap) / bin_capacity\n\n    # A small, controlled weight ensures this bonus doesn't override significantly better Best Fits.\n    consolidation_bonus_weight = 1e-4 # This parameter can be tuned for specific problem instances.\n\n    # The bonus is proportional to the bin's current fullness. Empty bins (fullness 0) get 0 bonus.\n    consolidation_bonus_fitting = current_fullness_fitting * consolidation_bonus_weight\n\n    # 4. Combine base Best Fit priority with the adaptive consolidation bonus\n    combined_priorities_fitting = base_priorities_fitting + consolidation_bonus_fitting\n\n    # 5. Assign calculated priorities back to the main priorities array\n    priorities[can_fit_mask] = combined_priorities_fitting\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation aims for a \"Best Fit\" strategy:\n    It prioritizes bins that, after the item is placed, will have the smallest\n    remaining capacity. This helps to 'tightly pack' items into existing bins,\n    leaving larger capacities open for larger items or reducing fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Find bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # For fitting bins, we want to maximize the \"tightness\".\n    # A smaller remaining capacity means a tighter fit.\n    # To achieve this with argmax (which finds the maximum priority score),\n    # we can use the negative of the potential_remaining_cap.\n    # E.g., if remainders are [0.1, 0.5, 0.8], their negatives are [-0.1, -0.5, -0.8].\n    # The max of negatives is -0.1, which corresponds to the smallest positive remainder 0.1.\n    priorities[can_fit_mask] = -potential_remaining_cap\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation builds on the \"Best Fit\" strategy but introduces a slight\n    preference for existing, partially filled bins over entirely new (empty) bins.\n    The goal is to encourage filling up bins already in use, potentially delaying\n    the opening of new bins, which can lead to fewer total bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The maximum capacity of a single bin. Default to 1.0,\n                      assuming item sizes are normalized relative to this capacity.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # 1. Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Only consider bins where the item fits\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # 2. Calculate remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = fitting_bins_remain_cap - item\n\n    # 3. Base priority: Best Fit strategy (minimize remaining capacity)\n    # A smaller potential_remaining_cap (closer to 0) means a tighter fit,\n    # which is preferred. By taking the negative, we convert minimization\n    # to maximization for `np.argmax`.\n    # A perfect fit (potential_remaining_cap == 0) will result in a priority of 0,\n    # which is the highest possible score from this component.\n    base_priorities = -potential_remaining_cap\n\n    # 4. Mutation: Add a small bonus for choosing an already used bin over a fresh one.\n    # This slightly biases towards consolidating items into existing bins.\n    # The bonus value (e.g., 1e-6) should be carefully chosen. It must be\n    # small enough not to override a significantly better Best Fit (i.e., a\n    # much smaller potential_remaining_cap difference), but large enough\n    # to break ties or influence decisions when Best Fit scores are very close.\n    # For floating-point comparisons, a tolerance (e.g., np.finfo(float).eps * 10)\n    # is often used, but for simplicity and common BPP scenarios where `bin_capacity`\n    # is exactly 1.0 for fresh bins, direct comparison or `x < capacity` is often sufficient.\n    used_bin_bonus = 1e-6  # A small constant bonus\n\n    # Identify bins that are not \"fresh\" (i.e., not entirely empty/unused).\n    # A bin is considered 'used' if its remaining capacity is strictly less than the full capacity.\n    # Using np.isclose for robustness against floating-point inaccuracies when comparing to bin_capacity.\n    is_used_bin_mask = ~np.isclose(fitting_bins_remain_cap, bin_capacity)\n\n    # Apply the bonus only to bins that can fit the item AND are already used.\n    # This applies the bonus to the elements within the 'can_fit_mask' subset.\n    priorities[can_fit_mask] = base_priorities\n    priorities[can_fit_mask][is_used_bin_mask] += used_bin_bonus\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation builds on the \"Best Fit\" strategy but introduces a slight\n    preference for existing, partially filled bins over entirely new (empty) bins.\n    The goal is to encourage filling up bins already in use, potentially delaying\n    the opening of new bins, which can lead to fewer total bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The maximum capacity of a single bin. Default to 1.0,\n                      assuming item sizes are normalized relative to this capacity.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # 1. Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Only consider bins where the item fits\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # 2. Calculate remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = fitting_bins_remain_cap - item\n\n    # 3. Base priority: Best Fit strategy (minimize remaining capacity)\n    # A smaller potential_remaining_cap (closer to 0) means a tighter fit,\n    # which is preferred. By taking the negative, we convert minimization\n    # to maximization for `np.argmax`.\n    # A perfect fit (potential_remaining_cap == 0) will result in a priority of 0,\n    # which is the highest possible score from this component.\n    base_priorities = -potential_remaining_cap\n\n    # 4. Mutation: Add a small bonus for choosing an already used bin over a fresh one.\n    # This slightly biases towards consolidating items into existing bins.\n    # The bonus value (e.g., 1e-6) should be carefully chosen. It must be\n    # small enough not to override a significantly better Best Fit (i.e., a\n    # much smaller potential_remaining_cap difference), but large enough\n    # to break ties or influence decisions when Best Fit scores are very close.\n    # For floating-point comparisons, a tolerance (e.g., np.finfo(float).eps * 10)\n    # is often used, but for simplicity and common BPP scenarios where `bin_capacity`\n    # is exactly 1.0 for fresh bins, direct comparison or `x < capacity` is often sufficient.\n    used_bin_bonus = 1e-6  # A small constant bonus\n\n    # Identify bins that are not \"fresh\" (i.e., not entirely empty/unused).\n    # A bin is considered 'used' if its remaining capacity is strictly less than the full capacity.\n    # Using np.isclose for robustness against floating-point inaccuracies when comparing to bin_capacity.\n    is_used_bin_mask = ~np.isclose(fitting_bins_remain_cap, bin_capacity)\n\n    # Apply the bonus only to bins that can fit the item AND are already used.\n    # This applies the bonus to the elements within the 'can_fit_mask' subset.\n    priorities[can_fit_mask] = base_priorities\n    priorities[can_fit_mask][is_used_bin_mask] += used_bin_bonus\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                priority_no_fit: float = -7469923285.667422,\n                weight_remaining_cap: float = -0.493607220196141) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation aims for a \"Best Fit\" strategy:\n    It prioritizes bins that, after the item is placed, will have the smallest\n    remaining capacity. This helps to 'tightly pack' items into existing bins,\n    leaving larger capacities open for larger items or reducing fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        priority_no_fit: The priority assigned to bins where the item cannot fit.\n                         Default is -np.inf, effectively excluding them.\n        weight_remaining_cap: The weight applied to the potential remaining\n                              capacity. A negative value (e.g., -1.0 for Best Fit)\n                              prioritizes smaller remaining capacities. A positive\n                              value would prioritize larger remaining capacities\n                              (Worst Fit).\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, priority_no_fit, dtype=float)\n\n    # Find bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # Apply the weight to the potential remaining capacity.\n    # For Best Fit, weight_remaining_cap should be negative.\n    priorities[can_fit_mask] = weight_remaining_cap * potential_remaining_cap\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation builds on the \"Best Fit\" strategy but introduces a slight\n    preference for existing, partially filled bins over entirely new (empty) bins.\n    The goal is to encourage filling up bins already in use, potentially delaying\n    the opening of new bins, which can lead to fewer total bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The maximum capacity of a single bin. Default to 1.0,\n                      assuming item sizes are normalized relative to this capacity.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # 1. Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Only consider bins where the item fits\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # 2. Calculate remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = fitting_bins_remain_cap - item\n\n    # 3. Base priority: Best Fit strategy (minimize remaining capacity)\n    # A smaller potential_remaining_cap (closer to 0) means a tighter fit,\n    # which is preferred. By taking the negative, we convert minimization\n    # to maximization for `np.argmax`.\n    # A perfect fit (potential_remaining_cap == 0) will result in a priority of 0,\n    # which is the highest possible score from this component.\n    base_priorities = -potential_remaining_cap\n\n    # 4. Mutation: Add a small bonus for choosing an already used bin over a fresh one.\n    # This slightly biases towards consolidating items into existing bins.\n    # The bonus value (e.g., 1e-6) should be carefully chosen. It must be\n    # small enough not to override a significantly better Best Fit (i.e., a\n    # much smaller potential_remaining_cap difference), but large enough\n    # to break ties or influence decisions when Best Fit scores are very close.\n    # For floating-point comparisons, a tolerance (e.g., np.finfo(float).eps * 10)\n    # is often used, but for simplicity and common BPP scenarios where `bin_capacity`\n    # is exactly 1.0 for fresh bins, direct comparison or `x < capacity` is often sufficient.\n    used_bin_bonus = 1e-6  # A small constant bonus\n\n    # Identify bins that are not \"fresh\" (i.e., not entirely empty/unused).\n    # A bin is considered 'used' if its remaining capacity is strictly less than the full capacity.\n    # Using np.isclose for robustness against floating-point inaccuracies when comparing to bin_capacity.\n    is_used_bin_mask = ~np.isclose(fitting_bins_remain_cap, bin_capacity)\n\n    # Apply the bonus only to bins that can fit the item AND are already used.\n    # This applies the bonus to the elements within the 'can_fit_mask' subset.\n    priorities[can_fit_mask] = base_priorities\n    priorities[can_fit_mask][is_used_bin_mask] += used_bin_bonus\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                priority_no_fit: float = -7469923285.667422,\n                weight_remaining_cap: float = -0.493607220196141) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation aims for a \"Best Fit\" strategy:\n    It prioritizes bins that, after the item is placed, will have the smallest\n    remaining capacity. This helps to 'tightly pack' items into existing bins,\n    leaving larger capacities open for larger items or reducing fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        priority_no_fit: The priority assigned to bins where the item cannot fit.\n                         Default is -np.inf, effectively excluding them.\n        weight_remaining_cap: The weight applied to the potential remaining\n                              capacity. A negative value (e.g., -1.0 for Best Fit)\n                              prioritizes smaller remaining capacities. A positive\n                              value would prioritize larger remaining capacities\n                              (Worst Fit).\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, priority_no_fit, dtype=float)\n\n    # Find bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # Apply the weight to the potential remaining capacity.\n    # For Best Fit, weight_remaining_cap should be negative.\n    priorities[can_fit_mask] = weight_remaining_cap * potential_remaining_cap\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, ideal_remainder_ratio: float = 0.31342951204947844) -> np.ndarray:\n    \"\"\"Returns priority with which to add an item to each bin.\n\n    This implementation aims for a \"Target Remainder Fit\" strategy. It seeks to\n    assign an item to a bin such that the bin's remaining capacity after placement\n    is close to a predefined 'ideal' target value. This approach is more adaptive\n    and holistic than a simple Best Fit, as it manages the distribution of\n    remaining bin capacities, potentially leaving more \"useful\" space for\n    future items and promoting a more diverse set of bin states.\n\n    The 'ideal_remainder_ratio' parameter determines the target remaining capacity\n    as a fraction of the total bin capacity. A value of 0.0 would revert to a\n    pure Best Fit (minimizing remaining capacity). A value closer to 1.0 would\n    lean towards Worst Fit (maximizing remaining capacity). A moderate value\n    (e.g., 0.25) attempts to maintain a balanced bin state.\n\n    Assumptions:\n    1. The problem implies a fixed `BIN_CAPACITY` for all bins. Since it's not\n       an explicit argument, we infer it from `bins_remain_cap`. In online BPP,\n       new bins are typically added at full capacity. Therefore, `np.max(bins_remain_cap)`\n       is used as a reasonable proxy for `BIN_CAPACITY`, assuming at least one\n       bin is either empty (full capacity) or has the largest possible remaining capacity.\n       For extreme edge cases (e.g., all bins are almost full and no new empty bin has been opened yet),\n       this inference might be inaccurate, but it's a common practical approach.\n    2. `item` and `bins_remain_cap` values are in consistent units.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n        ideal_remainder_ratio: A heuristic parameter (between 0.0 and 1.0)\n                               determining the target remaining capacity as a\n                               fraction of the total bin capacity.\n                               0.0 for Best Fit, ~0.2-0.3 for a more balanced \"middle-fit\".\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle case where no bins are available or bins_remain_cap is empty\n    if bins_remain_cap.size == 0:\n        return priorities\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, ideal_remainder_ratio: float = 0.31342951204947844) -> np.ndarray:\n    \"\"\"Returns priority with which to add an item to each bin.\n\n    This implementation aims for a \"Target Remainder Fit\" strategy. It seeks to\n    assign an item to a bin such that the bin's remaining capacity after placement\n    is close to a predefined 'ideal' target value. This approach is more adaptive\n    and holistic than a simple Best Fit, as it manages the distribution of\n    remaining bin capacities, potentially leaving more \"useful\" space for\n    future items and promoting a more diverse set of bin states.\n\n    The 'ideal_remainder_ratio' parameter determines the target remaining capacity\n    as a fraction of the total bin capacity. A value of 0.0 would revert to a\n    pure Best Fit (minimizing remaining capacity). A value closer to 1.0 would\n    lean towards Worst Fit (maximizing remaining capacity). A moderate value\n    (e.g., 0.25) attempts to maintain a balanced bin state.\n\n    Assumptions:\n    1. The problem implies a fixed `BIN_CAPACITY` for all bins. Since it's not\n       an explicit argument, we infer it from `bins_remain_cap`. In online BPP,\n       new bins are typically added at full capacity. Therefore, `np.max(bins_remain_cap)`\n       is used as a reasonable proxy for `BIN_CAPACITY`, assuming at least one\n       bin is either empty (full capacity) or has the largest possible remaining capacity.\n       For extreme edge cases (e.g., all bins are almost full and no new empty bin has been opened yet),\n       this inference might be inaccurate, but it's a common practical approach.\n    2. `item` and `bins_remain_cap` values are in consistent units.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n        ideal_remainder_ratio: A heuristic parameter (between 0.0 and 1.0)\n                               determining the target remaining capacity as a\n                               fraction of the total bin capacity.\n                               0.0 for Best Fit, ~0.2-0.3 for a more balanced \"middle-fit\".\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle case where no bins are available or bins_remain_cap is empty\n    if bins_remain_cap.size == 0:\n        return priorities\n\n[Heuristics 15th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, ideal_remainder_ratio: float = 0.31342951204947844) -> np.ndarray:\n    \"\"\"Returns priority with which to add an item to each bin.\n\n    This implementation aims for a \"Target Remainder Fit\" strategy. It seeks to\n    assign an item to a bin such that the bin's remaining capacity after placement\n    is close to a predefined 'ideal' target value. This approach is more adaptive\n    and holistic than a simple Best Fit, as it manages the distribution of\n    remaining bin capacities, potentially leaving more \"useful\" space for\n    future items and promoting a more diverse set of bin states.\n\n    The 'ideal_remainder_ratio' parameter determines the target remaining capacity\n    as a fraction of the total bin capacity. A value of 0.0 would revert to a\n    pure Best Fit (minimizing remaining capacity). A value closer to 1.0 would\n    lean towards Worst Fit (maximizing remaining capacity). A moderate value\n    (e.g., 0.25) attempts to maintain a balanced bin state.\n\n    Assumptions:\n    1. The problem implies a fixed `BIN_CAPACITY` for all bins. Since it's not\n       an explicit argument, we infer it from `bins_remain_cap`. In online BPP,\n       new bins are typically added at full capacity. Therefore, `np.max(bins_remain_cap)`\n       is used as a reasonable proxy for `BIN_CAPACITY`, assuming at least one\n       bin is either empty (full capacity) or has the largest possible remaining capacity.\n       For extreme edge cases (e.g., all bins are almost full and no new empty bin has been opened yet),\n       this inference might be inaccurate, but it's a common practical approach.\n    2. `item` and `bins_remain_cap` values are in consistent units.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n        ideal_remainder_ratio: A heuristic parameter (between 0.0 and 1.0)\n                               determining the target remaining capacity as a\n                               fraction of the total bin capacity.\n                               0.0 for Best Fit, ~0.2-0.3 for a more balanced \"middle-fit\".\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle case where no bins are available or bins_remain_cap is empty\n    if bins_remain_cap.size == 0:\n        return priorities\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which to add an item to each bin.\n\n    This implementation aims for a \"Target Remainder Fit\" strategy. It seeks to\n    assign an item to a bin such that the bin's remaining capacity after placement\n    is close to a predefined 'ideal' target value. This approach is more adaptive\n    and holistic than a simple Best Fit, as it manages the distribution of\n    remaining bin capacities, potentially leaving more \"useful\" space for\n    future items and promoting a more diverse set of bin states.\n\n    The 'ideal_remainder_ratio' parameter determines the target remaining capacity\n    as a fraction of the total bin capacity. A value of 0.0 would revert to a\n    pure Best Fit (minimizing remaining capacity). A value closer to 1.0 would\n    lean towards Worst Fit (maximizing remaining capacity). A moderate value\n    (e.g., 0.25) attempts to maintain a balanced bin state.\n\n    Assumptions:\n    1. The problem implies a fixed `BIN_CAPACITY` for all bins. Since it's not\n       an explicit argument, we infer it from `bins_remain_cap`. In online BPP,\n       new bins are typically added at full capacity. Therefore, `np.max(bins_remain_cap)`\n       is used as a reasonable proxy for `BIN_CAPACITY`, assuming at least one\n       bin is either empty (full capacity) or has the largest possible remaining capacity.\n       For extreme edge cases (e.g., all bins are almost full and no new empty bin has been opened yet),\n       this inference might be inaccurate, but it's a common practical approach.\n    2. `item` and `bins_remain_cap` values are in consistent units.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle case where no bins are available or bins_remain_cap is empty\n    if bins_remain_cap.size == 0:\n        return priorities\n\n    # Infer BIN_CAPACITY from the maximum remaining capacity among current bins.\n    # This assumes that at least one \"fresh\" bin (with full capacity) is or was available,\n    # or that the maximum value represents the standard bin capacity.\n    BIN_CAPACITY = np.max(bins_remain_cap)\n    if BIN_CAPACITY == 0: # Avoid division by zero if all bins are exactly 0 capacity\n        return priorities # No item can fit anywhere\n\n    # Define the ideal remaining capacity ratio after placing an item.\n    # This is a key heuristic parameter for tuning:\n    # 0.0 for Best Fit, ~0.2-0.3 for a more balanced \"middle-fit\".\n    ideal_remainder_ratio = 0.25\n    TARGET_REMAINDER = BIN_CAPACITY * ideal_remainder_ratio\n\n    # Find bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # Calculate priority based on the absolute difference from the TARGET_REMAINDER.\n    # We want to minimize this absolute difference, so we take its negative.\n    # This means bins whose `potential_remaining_cap` is closest to `TARGET_REMAINDER`\n    # will receive the highest priority.\n    priorities[can_fit_mask] = -np.abs(potential_remaining_cap - TARGET_REMAINDER)\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which to add an item to each bin.\n\n    This implementation aims for a \"Target Remainder Fit\" strategy. It seeks to\n    assign an item to a bin such that the bin's remaining capacity after placement\n    is close to a predefined 'ideal' target value. This approach is more adaptive\n    and holistic than a simple Best Fit, as it manages the distribution of\n    remaining bin capacities, potentially leaving more \"useful\" space for\n    future items and promoting a more diverse set of bin states.\n\n    The 'ideal_remainder_ratio' parameter determines the target remaining capacity\n    as a fraction of the total bin capacity. A value of 0.0 would revert to a\n    pure Best Fit (minimizing remaining capacity). A value closer to 1.0 would\n    lean towards Worst Fit (maximizing remaining capacity). A moderate value\n    (e.g., 0.25) attempts to maintain a balanced bin state.\n\n    Assumptions:\n    1. The problem implies a fixed `BIN_CAPACITY` for all bins. Since it's not\n       an explicit argument, we infer it from `bins_remain_cap`. In online BPP,\n       new bins are typically added at full capacity. Therefore, `np.max(bins_remain_cap)`\n       is used as a reasonable proxy for `BIN_CAPACITY`, assuming at least one\n       bin is either empty (full capacity) or has the largest possible remaining capacity.\n       For extreme edge cases (e.g., all bins are almost full and no new empty bin has been opened yet),\n       this inference might be inaccurate, but it's a common practical approach.\n    2. `item` and `bins_remain_cap` values are in consistent units.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle case where no bins are available or bins_remain_cap is empty\n    if bins_remain_cap.size == 0:\n        return priorities\n\n    # Infer BIN_CAPACITY from the maximum remaining capacity among current bins.\n    # This assumes that at least one \"fresh\" bin (with full capacity) is or was available,\n    # or that the maximum value represents the standard bin capacity.\n    BIN_CAPACITY = np.max(bins_remain_cap)\n    if BIN_CAPACITY == 0: # Avoid division by zero if all bins are exactly 0 capacity\n        return priorities # No item can fit anywhere\n\n    # Define the ideal remaining capacity ratio after placing an item.\n    # This is a key heuristic parameter for tuning:\n    # 0.0 for Best Fit, ~0.2-0.3 for a more balanced \"middle-fit\".\n    ideal_remainder_ratio = 0.25\n    TARGET_REMAINDER = BIN_CAPACITY * ideal_remainder_ratio\n\n    # Find bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # Calculate priority based on the absolute difference from the TARGET_REMAINDER.\n    # We want to minimize this absolute difference, so we take its negative.\n    # This means bins whose `potential_remaining_cap` is closest to `TARGET_REMAINDER`\n    # will receive the highest priority.\n    priorities[can_fit_mask] = -np.abs(potential_remaining_cap - TARGET_REMAINDER)\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which to add an item to each bin.\n\n    This implementation aims for a \"Target Remainder Fit\" strategy. It seeks to\n    assign an item to a bin such that the bin's remaining capacity after placement\n    is close to a predefined 'ideal' target value. This approach is more adaptive\n    and holistic than a simple Best Fit, as it manages the distribution of\n    remaining bin capacities, potentially leaving more \"useful\" space for\n    future items and promoting a more diverse set of bin states.\n\n    The 'ideal_remainder_ratio' parameter determines the target remaining capacity\n    as a fraction of the total bin capacity. A value of 0.0 would revert to a\n    pure Best Fit (minimizing remaining capacity). A value closer to 1.0 would\n    lean towards Worst Fit (maximizing remaining capacity). A moderate value\n    (e.g., 0.25) attempts to maintain a balanced bin state.\n\n    Assumptions:\n    1. The problem implies a fixed `BIN_CAPACITY` for all bins. Since it's not\n       an explicit argument, we infer it from `bins_remain_cap`. In online BPP,\n       new bins are typically added at full capacity. Therefore, `np.max(bins_remain_cap)`\n       is used as a reasonable proxy for `BIN_CAPACITY`, assuming at least one\n       bin is either empty (full capacity) or has the largest possible remaining capacity.\n       For extreme edge cases (e.g., all bins are almost full and no new empty bin has been opened yet),\n       this inference might be inaccurate, but it's a common practical approach.\n    2. `item` and `bins_remain_cap` values are in consistent units.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle case where no bins are available or bins_remain_cap is empty\n    if bins_remain_cap.size == 0:\n        return priorities\n\n    # Infer BIN_CAPACITY from the maximum remaining capacity among current bins.\n    # This assumes that at least one \"fresh\" bin (with full capacity) is or was available,\n    # or that the maximum value represents the standard bin capacity.\n    BIN_CAPACITY = np.max(bins_remain_cap)\n    if BIN_CAPACITY == 0: # Avoid division by zero if all bins are exactly 0 capacity\n        return priorities # No item can fit anywhere\n\n    # Define the ideal remaining capacity ratio after placing an item.\n    # This is a key heuristic parameter for tuning:\n    # 0.0 for Best Fit, ~0.2-0.3 for a more balanced \"middle-fit\".\n    ideal_remainder_ratio = 0.25\n    TARGET_REMAINDER = BIN_CAPACITY * ideal_remainder_ratio\n\n    # Find bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # Calculate priority based on the absolute difference from the TARGET_REMAINDER.\n    # We want to minimize this absolute difference, so we take its negative.\n    # This means bins whose `potential_remaining_cap` is closest to `TARGET_REMAINDER`\n    # will receive the highest priority.\n    priorities[can_fit_mask] = -np.abs(potential_remaining_cap - TARGET_REMAINDER)\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which to add an item to each bin.\n\n    This implementation aims for a \"Target Remainder Fit\" strategy. It seeks to\n    assign an item to a bin such that the bin's remaining capacity after placement\n    is close to a predefined 'ideal' target value. This approach is more adaptive\n    and holistic than a simple Best Fit, as it manages the distribution of\n    remaining bin capacities, potentially leaving more \"useful\" space for\n    future items and promoting a more diverse set of bin states.\n\n    The 'ideal_remainder_ratio' parameter determines the target remaining capacity\n    as a fraction of the total bin capacity. A value of 0.0 would revert to a\n    pure Best Fit (minimizing remaining capacity). A value closer to 1.0 would\n    lean towards Worst Fit (maximizing remaining capacity). A moderate value\n    (e.g., 0.25) attempts to maintain a balanced bin state.\n\n    Assumptions:\n    1. The problem implies a fixed `BIN_CAPACITY` for all bins. Since it's not\n       an explicit argument, we infer it from `bins_remain_cap`. In online BPP,\n       new bins are typically added at full capacity. Therefore, `np.max(bins_remain_cap)`\n       is used as a reasonable proxy for `BIN_CAPACITY`, assuming at least one\n       bin is either empty (full capacity) or has the largest possible remaining capacity.\n       For extreme edge cases (e.g., all bins are almost full and no new empty bin has been opened yet),\n       this inference might be inaccurate, but it's a common practical approach.\n    2. `item` and `bins_remain_cap` values are in consistent units.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle case where no bins are available or bins_remain_cap is empty\n    if bins_remain_cap.size == 0:\n        return priorities\n\n    # Infer BIN_CAPACITY from the maximum remaining capacity among current bins.\n    # This assumes that at least one \"fresh\" bin (with full capacity) is or was available,\n    # or that the maximum value represents the standard bin capacity.\n    BIN_CAPACITY = np.max(bins_remain_cap)\n    if BIN_CAPACITY == 0: # Avoid division by zero if all bins are exactly 0 capacity\n        return priorities # No item can fit anywhere\n\n    # Define the ideal remaining capacity ratio after placing an item.\n    # This is a key heuristic parameter for tuning:\n    # 0.0 for Best Fit, ~0.2-0.3 for a more balanced \"middle-fit\".\n    ideal_remainder_ratio = 0.25\n    TARGET_REMAINDER = BIN_CAPACITY * ideal_remainder_ratio\n\n    # Find bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # Calculate priority based on the absolute difference from the TARGET_REMAINDER.\n    # We want to minimize this absolute difference, so we take its negative.\n    # This means bins whose `potential_remaining_cap` is closest to `TARGET_REMAINDER`\n    # will receive the highest priority.\n    priorities[can_fit_mask] = -np.abs(potential_remaining_cap - TARGET_REMAINDER)\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}