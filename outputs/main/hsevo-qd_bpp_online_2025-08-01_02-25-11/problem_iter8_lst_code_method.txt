{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation extends \"Best Fit\" with a \"Consolidation Bonus\".\n    It prioritizes bins that, after the item is placed, will have the smallest\n    remaining capacity (Best Fit). Additionally, it gives a linear bonus\n    to bins that are already partially filled (i.e., not completely empty),\n    to encourage consolidation and avoid opening new bins prematurely.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n                         This array typically includes capacities of active bins\n                         and potentially one or more 'empty' bins representing\n                         new bins that can be opened.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # A small positive constant bonus to encourage consolidation into existing bins.\n    # This value should be carefully chosen. It should be small enough to\n    # generally not override the primary \"Best Fit\" principle, but large enough\n    # to consistently break ties or influence choices when potential remaining\n    # capacities are very close.\n    CONSOLIDATION_BONUS = 0.01\n\n    # Initialize priorities for all bins to negative infinity.\n    # This ensures that bins where the item cannot fit will not be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle the edge case where there are no bins to consider.\n    if len(bins_remain_cap) == 0:\n        return priorities\n\n    # Infer the maximum capacity of an 'empty' bin from the input array.\n    # This assumes that if a new bin is to be opened, its capacity\n    # (or equivalent to a fresh bin's capacity) is present in `bins_remain_cap`.\n    # If all bins are already partially filled, this will consider the least\n    # filled bin as the 'reference empty' for bonus purposes, promoting consolidation\n    # into the most-filled (least remaining capacity) bins among the current set.\n    BIN_CAPACITY = np.max(bins_remain_cap)\n\n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bins can fit the item, return the priorities array with -np.inf.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Calculate the remaining capacity if the item were placed in each fitting bin.\n    # This is the core of the \"Best Fit\" strategy.\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # Base score: The goal is to minimize the remaining capacity, which means\n    # maximizing the negative of the remaining capacity. This creates a monotonic\n    # scoring where a smaller positive remainder yields a higher priority score.\n    base_scores = -potential_remaining_cap\n\n    # Determine which of the fitting bins are \"partially filled\" (not completely empty).\n    # A bin is considered partially filled if its current remaining capacity\n    # is less than the inferred full bin capacity (BIN_CAPACITY).\n    is_partially_filled_mask = (bins_remain_cap[can_fit_mask] < BIN_CAPACITY)\n\n    # Initialize bonuses for fitting bins to zero.\n    consolidation_bonuses = np.zeros_like(base_scores)\n\n    # Apply the consolidation bonus only to the fitting bins that are partially filled.\n    # This encourages using existing, non-empty bins before opening new ones.\n    consolidation_bonuses[is_partially_filled_mask] = CONSOLIDATION_BONUS\n\n    # The total priority for fitting bins is the sum of the base Best Fit score\n    # and the consolidation bonus.\n    priorities[can_fit_mask] = base_scores + consolidation_bonuses\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation extends \"Best Fit\" with a \"Consolidation Bonus\".\n    It prioritizes bins that, after the item is placed, will have the smallest\n    remaining capacity (Best Fit). Additionally, it gives a linear bonus\n    to bins that are already partially filled (i.e., not completely empty),\n    to encourage consolidation and avoid opening new bins prematurely.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n                         This array typically includes capacities of active bins\n                         and potentially one or more 'empty' bins representing\n                         new bins that can be opened.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # A small positive constant bonus to encourage consolidation into existing bins.\n    # This value should be carefully chosen. It should be small enough to\n    # generally not override the primary \"Best Fit\" principle, but large enough\n    # to consistently break ties or influence choices when potential remaining\n    # capacities are very close.\n    CONSOLIDATION_BONUS = 0.01\n\n    # Initialize priorities for all bins to negative infinity.\n    # This ensures that bins where the item cannot fit will not be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle the edge case where there are no bins to consider.\n    if len(bins_remain_cap) == 0:\n        return priorities\n\n    # Infer the maximum capacity of an 'empty' bin from the input array.\n    # This assumes that if a new bin is to be opened, its capacity\n    # (or equivalent to a fresh bin's capacity) is present in `bins_remain_cap`.\n    # If all bins are already partially filled, this will consider the least\n    # filled bin as the 'reference empty' for bonus purposes, promoting consolidation\n    # into the most-filled (least remaining capacity) bins among the current set.\n    BIN_CAPACITY = np.max(bins_remain_cap)\n\n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bins can fit the item, return the priorities array with -np.inf.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Calculate the remaining capacity if the item were placed in each fitting bin.\n    # This is the core of the \"Best Fit\" strategy.\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # Base score: The goal is to minimize the remaining capacity, which means\n    # maximizing the negative of the remaining capacity. This creates a monotonic\n    # scoring where a smaller positive remainder yields a higher priority score.\n    base_scores = -potential_remaining_cap\n\n    # Determine which of the fitting bins are \"partially filled\" (not completely empty).\n    # A bin is considered partially filled if its current remaining capacity\n    # is less than the inferred full bin capacity (BIN_CAPACITY).\n    is_partially_filled_mask = (bins_remain_cap[can_fit_mask] < BIN_CAPACITY)\n\n    # Initialize bonuses for fitting bins to zero.\n    consolidation_bonuses = np.zeros_like(base_scores)\n\n    # Apply the consolidation bonus only to the fitting bins that are partially filled.\n    # This encourages using existing, non-empty bins before opening new ones.\n    consolidation_bonuses[is_partially_filled_mask] = CONSOLIDATION_BONUS\n\n    # The total priority for fitting bins is the sum of the base Best Fit score\n    # and the consolidation bonus.\n    priorities[can_fit_mask] = base_scores + consolidation_bonuses\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation builds on the \"Best Fit\" strategy but introduces a slight\n    preference for existing, partially filled bins over entirely new (empty) bins.\n    The goal is to encourage filling up bins already in use, potentially delaying\n    the opening of new bins, which can lead to fewer total bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The maximum capacity of a single bin. Default to 1.0,\n                      assuming item sizes are normalized relative to this capacity.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # 1. Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Only consider bins where the item fits\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # 2. Calculate remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = fitting_bins_remain_cap - item\n\n    # 3. Base priority: Best Fit strategy (minimize remaining capacity)\n    # A smaller potential_remaining_cap (closer to 0) means a tighter fit,\n    # which is preferred. By taking the negative, we convert minimization\n    # to maximization for `np.argmax`.\n    # A perfect fit (potential_remaining_cap == 0) will result in a priority of 0,\n    # which is the highest possible score from this component.\n    base_priorities = -potential_remaining_cap\n\n    # 4. Mutation: Add a small bonus for choosing an already used bin over a fresh one.\n    # This slightly biases towards consolidating items into existing bins.\n    # The bonus value (e.g., 1e-6) should be carefully chosen. It must be\n    # small enough not to override a significantly better Best Fit (i.e., a\n    # much smaller potential_remaining_cap difference), but large enough\n    # to break ties or influence decisions when Best Fit scores are very close.\n    # For floating-point comparisons, a tolerance (e.g., np.finfo(float).eps * 10)\n    # is often used, but for simplicity and common BPP scenarios where `bin_capacity`\n    # is exactly 1.0 for fresh bins, direct comparison or `x < capacity` is often sufficient.\n    used_bin_bonus = 1e-6  # A small constant bonus\n\n    # Identify bins that are not \"fresh\" (i.e., not entirely empty/unused).\n    # A bin is considered 'used' if its remaining capacity is strictly less than the full capacity.\n    # Using np.isclose for robustness against floating-point inaccuracies when comparing to bin_capacity.\n    is_used_bin_mask = ~np.isclose(fitting_bins_remain_cap, bin_capacity)\n\n    # Apply the bonus only to bins that can fit the item AND are already used.\n    # This applies the bonus to the elements within the 'can_fit_mask' subset.\n    priorities[can_fit_mask] = base_priorities\n    priorities[can_fit_mask][is_used_bin_mask] += used_bin_bonus\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation aims for a \"Best Fit\" strategy:\n    It prioritizes bins that, after the item is placed, will have the smallest\n    remaining capacity. This helps to 'tightly pack' items into existing bins,\n    leaving larger capacities open for larger items or reducing fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Find bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # For fitting bins, we want to maximize the \"tightness\".\n    # A smaller remaining capacity means a tighter fit.\n    # To achieve this with argmax (which finds the maximum priority score),\n    # we can use the negative of the potential_remaining_cap.\n    # E.g., if remainders are [0.1, 0.5, 0.8], their negatives are [-0.1, -0.5, -0.8].\n    # The max of negatives is -0.1, which corresponds to the smallest positive remainder 0.1.\n    priorities[can_fit_mask] = -potential_remaining_cap\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for 'Best Fit' by maximizing the effective filled capacity.\n\n    Prioritizes bins that achieve the highest fill level after placing the item,\n    yielding positive scores for valid fits and penalizing impossible ones.\n    \"\"\"\n    # Initialize all priorities to an extremely low value, ensuring bins that cannot\n    # accommodate the item are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify which bins possess sufficient remaining capacity for the item.\n    fits_mask = bins_remain_cap >= item\n\n    # For bins where the item demonstrably fits, calculate a priority score.\n    # This score, 2 * item - bins_remain_cap[fits_mask], maximizes the resulting\n    # effective filled capacity relative to the item's size. A perfect fit\n    # (where the bin's remaining capacity becomes zero) yields the highest positive\n    # score (equal to `item`), while less efficient fits yield lower positive scores.\n    # This combines the efficiency of masking first with a positive-scaled Best Fit score.\n    priorities[fits_mask] = 2 * item - bins_remain_cap[fits_mask]\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for 'Best Fit' by maximizing the effective filled capacity.\n\n    Prioritizes bins that achieve the highest fill level after placing the item,\n    yielding positive scores for valid fits and penalizing impossible ones.\n    \"\"\"\n    # Initialize all priorities to an extremely low value, ensuring bins that cannot\n    # accommodate the item are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify which bins possess sufficient remaining capacity for the item.\n    fits_mask = bins_remain_cap >= item\n\n    # For bins where the item demonstrably fits, calculate a priority score.\n    # This score, 2 * item - bins_remain_cap[fits_mask], maximizes the resulting\n    # effective filled capacity relative to the item's size. A perfect fit\n    # (where the bin's remaining capacity becomes zero) yields the highest positive\n    # score (equal to `item`), while less efficient fits yield lower positive scores.\n    # This combines the efficiency of masking first with a positive-scaled Best Fit score.\n    priorities[fits_mask] = 2 * item - bins_remain_cap[fits_mask]\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                priority_no_fit: float = -7469923285.667422,\n                weight_remaining_cap: float = -0.493607220196141) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation aims for a \"Best Fit\" strategy:\n    It prioritizes bins that, after the item is placed, will have the smallest\n    remaining capacity. This helps to 'tightly pack' items into existing bins,\n    leaving larger capacities open for larger items or reducing fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        priority_no_fit: The priority assigned to bins where the item cannot fit.\n                         Default is -np.inf, effectively excluding them.\n        weight_remaining_cap: The weight applied to the potential remaining\n                              capacity. A negative value (e.g., -1.0 for Best Fit)\n                              prioritizes smaller remaining capacities. A positive\n                              value would prioritize larger remaining capacities\n                              (Worst Fit).\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, priority_no_fit, dtype=float)\n\n    # Find bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # Apply the weight to the potential remaining capacity.\n    # For Best Fit, weight_remaining_cap should be negative.\n    priorities[can_fit_mask] = weight_remaining_cap * potential_remaining_cap\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for 'Best Fit' by maximizing the effective filled capacity.\n\n    Prioritizes bins that achieve the highest fill level after placing the item,\n    yielding positive scores for valid fits and penalizing impossible ones.\n    \"\"\"\n    # Initialize all priorities to an extremely low value, ensuring bins that cannot\n    # accommodate the item are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify which bins possess sufficient remaining capacity for the item.\n    fits_mask = bins_remain_cap >= item\n\n    # For bins where the item demonstrably fits, calculate a priority score.\n    # This score, 2 * item - bins_remain_cap[fits_mask], maximizes the resulting\n    # effective filled capacity relative to the item's size. A perfect fit\n    # (where the bin's remaining capacity becomes zero) yields the highest positive\n    # score (equal to `item`), while less efficient fits yield lower positive scores.\n    # This combines the efficiency of masking first with a positive-scaled Best Fit score.\n    priorities[fits_mask] = 2 * item - bins_remain_cap[fits_mask]\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"Returns priority for bin selection, combining Best Fit with a consolidation bonus.\n\n    Prioritizes bins that offer the tightest fit, adding a small bonus for\n    partially-filled bins to encourage consolidation and reduce new bin openings.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # 1. Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Get remaining capacities for only the bins that can fit the item\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    if fitting_bins_remain_cap.size == 0:\n        return priorities # No bin can fit the item, return all -inf priorities\n\n    # 2. Calculate potential remaining capacity if item were placed in fitting bins\n    potential_remaining_cap = fitting_bins_remain_cap - item\n\n    # 3. Base priority: Best Fit strategy (minimize remaining capacity)\n    # A smaller potential_remaining_cap (closer to 0) means a tighter fit,\n    # which is preferred. By taking the negative, we convert minimization\n    # to maximization for `np.argmax`. A perfect fit (0 remaining) gets a 0 score here.\n    base_priorities_for_fitting_bins = -potential_remaining_cap\n\n    # 4. Consolidation Bonus: Add a small bonus for choosing an already used bin.\n    # This encourages filling existing bins before opening new ones, potentially saving bins.\n    # The value (e.g., 1e-6) should be small enough not to override a significantly\n    # better \"Best Fit\" (i.e., a much smaller potential_remaining_cap difference),\n    # but large enough to break ties or influence decisions when Best Fit scores are very close.\n    used_bin_bonus = 1e-6\n\n    # Identify bins that are 'used' (i.e., not entirely empty/fresh).\n    # A bin is considered 'used' if its remaining capacity is strictly less than the full bin_capacity.\n    # Using np.isclose for robustness against floating-point inaccuracies when comparing to bin_capacity.\n    is_used_bin_mask = ~np.isclose(fitting_bins_remain_cap, bin_capacity)\n\n    # Apply the bonus only to bins that can fit the item AND are already used.\n    # This modifies the base priorities for the subset of fitting bins.\n    base_priorities_for_fitting_bins[is_used_bin_mask] += used_bin_bonus\n\n    # Assign the calculated priorities back to the main priorities array for the fitting bins\n    priorities[can_fit_mask] = base_priorities_for_fitting_bins\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                priority_no_fit: float = -7469923285.667422,\n                weight_remaining_cap: float = -0.493607220196141) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation aims for a \"Best Fit\" strategy:\n    It prioritizes bins that, after the item is placed, will have the smallest\n    remaining capacity. This helps to 'tightly pack' items into existing bins,\n    leaving larger capacities open for larger items or reducing fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        priority_no_fit: The priority assigned to bins where the item cannot fit.\n                         Default is -np.inf, effectively excluding them.\n        weight_remaining_cap: The weight applied to the potential remaining\n                              capacity. A negative value (e.g., -1.0 for Best Fit)\n                              prioritizes smaller remaining capacities. A positive\n                              value would prioritize larger remaining capacities\n                              (Worst Fit).\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, priority_no_fit, dtype=float)\n\n    # Find bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # Apply the weight to the potential remaining capacity.\n    # For Best Fit, weight_remaining_cap should be negative.\n    priorities[can_fit_mask] = weight_remaining_cap * potential_remaining_cap\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 12th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 15th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 17th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}