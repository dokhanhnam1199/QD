{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation extends \"Best Fit\" with a \"Consolidation Bonus\".\n    It prioritizes bins that, after the item is placed, will have the smallest\n    remaining capacity (Best Fit). Additionally, it gives a linear bonus\n    to bins that are already partially filled (i.e., not completely empty),\n    to encourage consolidation and avoid opening new bins prematurely.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n                         This array typically includes capacities of active bins\n                         and potentially one or more 'empty' bins representing\n                         new bins that can be opened.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # A small positive constant bonus to encourage consolidation into existing bins.\n    # This value should be carefully chosen. It should be small enough to\n    # generally not override the primary \"Best Fit\" principle, but large enough\n    # to consistently break ties or influence choices when potential remaining\n    # capacities are very close.\n    CONSOLIDATION_BONUS = 0.01\n\n    # Initialize priorities for all bins to negative infinity.\n    # This ensures that bins where the item cannot fit will not be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle the edge case where there are no bins to consider.\n    if len(bins_remain_cap) == 0:\n        return priorities\n\n    # Infer the maximum capacity of an 'empty' bin from the input array.\n    # This assumes that if a new bin is to be opened, its capacity\n    # (or equivalent to a fresh bin's capacity) is present in `bins_remain_cap`.\n    # If all bins are already partially filled, this will consider the least\n    # filled bin as the 'reference empty' for bonus purposes, promoting consolidation\n    # into the most-filled (least remaining capacity) bins among the current set.\n    BIN_CAPACITY = np.max(bins_remain_cap)\n\n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bins can fit the item, return the priorities array with -np.inf.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Calculate the remaining capacity if the item were placed in each fitting bin.\n    # This is the core of the \"Best Fit\" strategy.\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # Base score: The goal is to minimize the remaining capacity, which means\n    # maximizing the negative of the remaining capacity. This creates a monotonic\n    # scoring where a smaller positive remainder yields a higher priority score.\n    base_scores = -potential_remaining_cap\n\n    # Determine which of the fitting bins are \"partially filled\" (not completely empty).\n    # A bin is considered partially filled if its current remaining capacity\n    # is less than the inferred full bin capacity (BIN_CAPACITY).\n    is_partially_filled_mask = (bins_remain_cap[can_fit_mask] < BIN_CAPACITY)\n\n    # Initialize bonuses for fitting bins to zero.\n    consolidation_bonuses = np.zeros_like(base_scores)\n\n    # Apply the consolidation bonus only to the fitting bins that are partially filled.\n    # This encourages using existing, non-empty bins before opening new ones.\n    consolidation_bonuses[is_partially_filled_mask] = CONSOLIDATION_BONUS\n\n    # The total priority for fitting bins is the sum of the base Best Fit score\n    # and the consolidation bonus.\n    priorities[can_fit_mask] = base_scores + consolidation_bonuses\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which to add an item to each bin.\n\n    This implementation aims for a \"Target Remainder Fit\" strategy. It seeks to\n    assign an item to a bin such that the bin's remaining capacity after placement\n    is close to a predefined 'ideal' target value. This approach is more adaptive\n    and holistic than a simple Best Fit, as it manages the distribution of\n    remaining bin capacities, potentially leaving more \"useful\" space for\n    future items and promoting a more diverse set of bin states.\n\n    The 'ideal_remainder_ratio' parameter determines the target remaining capacity\n    as a fraction of the total bin capacity. A value of 0.0 would revert to a\n    pure Best Fit (minimizing remaining capacity). A value closer to 1.0 would\n    lean towards Worst Fit (maximizing remaining capacity). A moderate value\n    (e.g., 0.25) attempts to maintain a balanced bin state.\n\n    Assumptions:\n    1. The problem implies a fixed `BIN_CAPACITY` for all bins. Since it's not\n       an explicit argument, we infer it from `bins_remain_cap`. In online BPP,\n       new bins are typically added at full capacity. Therefore, `np.max(bins_remain_cap)`\n       is used as a reasonable proxy for `BIN_CAPACITY`, assuming at least one\n       bin is either empty (full capacity) or has the largest possible remaining capacity.\n       For extreme edge cases (e.g., all bins are almost full and no new empty bin has been opened yet),\n       this inference might be inaccurate, but it's a common practical approach.\n    2. `item` and `bins_remain_cap` values are in consistent units.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n        ideal_remainder_ratio: A heuristic parameter (between 0.0 and 1.0)\n                               determining the target remaining capacity as a\n                               fraction of the total bin capacity.\n                               0.0 for Best Fit, ~0.2-0.3 for a more balanced \"middle-fit\".\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle case where no bins are available or bins_remain_cap is empty\n    if bins_remain_cap.size == 0:\n        return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (4th), we see a significant jump in heuristic sophistication. The top-ranked (1st) introduces an \"aggressively incentivized\" exponential exact-fit bonus (magnitude 5000.0, decay 50.0), a \"Valley of Despair\" fragmentation penalty shaped like a negative Gaussian curve (peaking at 40% of item size), and a \"Quality of Large Remaining Space Bonus\" (logarithmic). In contrast, (4th) uses a discrete exact fit bonus (1000.0) and a simpler linear fragmentation penalty (proportional to normalized remainder, up to item size). The non-linear, adaptive components in (1st) provide far more nuanced control over bin states, encouraging aggressive bin closure and intelligent space management beyond simple minimization.\n\nComparing (4th) vs (8th), the fragmentation penalty shifts from a linearly scaled penalty based on `normalized_fragment_rem` (in 4th) to a fixed `TINY_REMAINDER_PENALTY` applied if the remainder is below `TINY_REMAINDER_THRESHOLD` (in 8th). The exact fit bonus is discrete and high in both (1000.0). The explicit threshold-based penalty in (8th) is simpler but less adaptive than the item-size-normalized linear penalty in (4th), which is itself less sophisticated than the Gaussian penalty in (1st). The higher performance of (4th) suggests its fragmentation handling, though linear, is more effective than a simple \"tiny remainder\" threshold.\n\nComparing (8th) vs (9th), (8th) employs a \"Hybrid Fit\" with a \"Perfect/Near-Perfect Fit Bonus\" and a \"Tiny Remainder Penalty\", while (9th) is a pure \"Best Fit\" strategy, prioritizing only the smallest remaining capacity. The clear improvement from (9th) to (8th) highlights the critical importance of explicitly incentivizing bin completion and penalizing awkward fragment creation.\n\nComparing (9th) vs (13th), both start with a \"Best Fit\" core. (13th) adds a small `used_bin_bonus` (1e-6) to prefer existing, partially filled bins over new ones. This subtle consolidation preference in (13th) leads to better performance than plain Best Fit (9th), indicating that even a minor bias towards existing bins can be beneficial for reducing the total bin count.\n\nComparing (13th) vs (14th), both aim for \"Best Fit\" plus a \"Consolidation Bonus\". (13th) explicitly takes `bin_capacity` as an argument and uses a very small `used_bin_bonus` of 1e-6. (14th) infers `BIN_CAPACITY` from `np.max(bins_remain_cap)` and uses a larger `CONSOLIDATION_BONUS` of 0.01. The stronger consolidation bias and adaptive `BIN_CAPACITY` inference in (14th) likely contribute to its better performance.\n\nComparing (14th) vs (20th), (14th) utilizes Best Fit plus a consolidation bonus, whereas (20th) implements a \"Target Remainder Fit\", aiming to leave a specific `ideal_remainder_ratio` (hardcoded 0.25) of the bin capacity. The higher ranking of (14th) suggests that a combination of Best Fit and consolidation is generally more robust and effective than solely targeting an ideal remainder, which might lead to suboptimal packing if the chosen target isn't universally beneficial across different item sizes.\n\nComparing (20th) vs (16th), (20th) attempts a \"Target Remainder Fit\" by minimizing the absolute difference from a target remaining capacity. In stark contrast, (16th) simply returns `np.zeros_like`, assigning equal priority to all fitting bins, which is equivalent to an arbitrary selection (e.g., First Fit). The functional strategy in (20th), despite its specific approach, vastly outperforms the null strategy of (16th).\n\nComparing (1st/2nd/3rd) with each other, they are identical code snippets. The same applies to (4th/5th/6th), (7th/10th), (8th/11th), (9th/12th), (14th/15th), (16th/17th), and (18th/19th). This suggests that the ranking differences within these identical groups are negligible or due to external factors not present in the code.\n\nOverall: The best heuristics employ a multi-faceted approach, balancing immediate best fit with future bin state management. This includes strong incentives for bin completion, nuanced penalties for fragmentation, and strategies for maintaining useful large spaces. Non-linear, adaptive functions are crucial for expressing these complex preferences. Simple Best Fit is a good baseline, but more sophisticated additions consistently improve performance. Purely arbitrary choices are the worst.\n- \n*   **Keywords:** Adaptive, Non-linear, Hybrid, State-aware, Quality-of-space.\n*   **Advice:** Design hybrid heuristics with adaptive, non-linear rules targeting critical bin states (completion, fragmentation). Use functions like exponential/Gaussian/logarithmic for specific incentives. Prioritize remaining space *quality* via tunable parameters.\n*   **Avoid:** Sole reliance on monotonic/linear relationships, simple additive bonuses, or shying away from non-linear complexity. Do not over-emphasize basic greedy without state awareness of bin characteristics.\n*   **Explanation:** Non-linear, state-aware functions capture nuanced problem dynamics, providing precise incentives/penalties (e.g., sharp fragmentation costs, strong completion bonuses) that linear or overly simplistic approaches miss, yielding superior solutions.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}