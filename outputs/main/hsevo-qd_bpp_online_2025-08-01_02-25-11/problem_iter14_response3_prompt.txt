{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority for bin selection, combining Best Fit with a consolidation bonus.\n\n    Prioritizes bins that offer the tightest fit, adding a small bonus for\n    partially-filled bins to encourage consolidation and reduce new bin openings.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # 1. Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Get remaining capacities for only the bins that can fit the item\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    if fitting_bins_remain_cap.size == 0:\n        return priorities # No bin can fit the item, return all -inf priorities\n\n    # 2. Calculate potential remaining capacity if item were placed in fitting bins\n    potential_remaining_cap = fitting_bins_remain_cap - item\n\n    # 3. Base priority: Best Fit strategy (minimize remaining capacity)\n    # A smaller potential_remaining_cap (closer to 0) means a tighter fit,\n    # which is preferred. By taking the negative, we convert minimization\n    # to maximization for `np.argmax`. A perfect fit (0 remaining) gets a 0 score here.\n    base_priorities_for_fitting_bins = -potential_remaining_cap\n\n    # 4. Consolidation Bonus: Add a small bonus for choosing an already used bin.\n    # This encourages filling existing bins before opening new ones, potentially saving bins.\n    # The value (e.g., 1e-6) should be small enough not to override a significantly\n    # better \"Best Fit\" (i.e., a much smaller potential_remaining_cap difference),\n    # but large enough to break ties or influence decisions when Best Fit scores are very close.\n    used_bin_bonus = 1e-6\n\n    # Identify bins that are 'used' (i.e., not entirely empty/fresh).\n    # A bin is considered 'used' if its remaining capacity is strictly less than the full bin_capacity.\n    # Using np.isclose for robustness against floating-point inaccuracies when comparing to bin_capacity.\n    is_used_bin_mask = ~np.isclose(fitting_bins_remain_cap, bin_capacity)\n\n    # Apply the bonus only to bins that can fit the item AND are already used.\n    # This modifies the base priorities for the subset of fitting bins.\n    base_priorities_for_fitting_bins[is_used_bin_mask] += used_bin_bonus\n\n    # Assign the calculated priorities back to the main priorities array for the fitting bins\n    priorities[can_fit_mask] = base_priorities_for_fitting_bins\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which to add an item to each bin.\n\n    This implementation aims for a \"Target Remainder Fit\" strategy. It seeks to\n    assign an item to a bin such that the bin's remaining capacity after placement\n    is close to a predefined 'ideal' target value. This approach is more adaptive\n    and holistic than a simple Best Fit, as it manages the distribution of\n    remaining bin capacities, potentially leaving more \"useful\" space for\n    future items and promoting a more diverse set of bin states.\n\n    The 'ideal_remainder_ratio' parameter determines the target remaining capacity\n    as a fraction of the total bin capacity. A value of 0.0 would revert to a\n    pure Best Fit (minimizing remaining capacity). A value closer to 1.0 would\n    lean towards Worst Fit (maximizing remaining capacity). A moderate value\n    (e.g., 0.25) attempts to maintain a balanced bin state.\n\n    Assumptions:\n    1. The problem implies a fixed `BIN_CAPACITY` for all bins. Since it's not\n       an explicit argument, we infer it from `bins_remain_cap`. In online BPP,\n       new bins are typically added at full capacity. Therefore, `np.max(bins_remain_cap)`\n       is used as a reasonable proxy for `BIN_CAPACITY`, assuming at least one\n       bin is either empty (full capacity) or has the largest possible remaining capacity.\n       For extreme edge cases (e.g., all bins are almost full and no new empty bin has been opened yet),\n       this inference might be inaccurate, but it's a common practical approach.\n    2. `item` and `bins_remain_cap` values are in consistent units.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle case where no bins are available or bins_remain_cap is empty\n    if bins_remain_cap.size == 0:\n        return priorities\n\n    # Infer BIN_CAPACITY from the maximum remaining capacity among current bins.\n    # This assumes that at least one \"fresh\" bin (with full capacity) is or was available,\n    # or that the maximum value represents the standard bin capacity.\n    BIN_CAPACITY = np.max(bins_remain_cap)\n    if BIN_CAPACITY == 0: # Avoid division by zero if all bins are exactly 0 capacity\n        return priorities # No item can fit anywhere\n\n    # Define the ideal remaining capacity ratio after placing an item.\n    # This is a key heuristic parameter for tuning:\n    # 0.0 for Best Fit, ~0.2-0.3 for a more balanced \"middle-fit\".\n    ideal_remainder_ratio = 0.25\n    TARGET_REMAINDER = BIN_CAPACITY * ideal_remainder_ratio\n\n    # Find bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # Calculate priority based on the absolute difference from the TARGET_REMAINDER.\n    # We want to minimize this absolute difference, so we take its negative.\n    # This means bins whose `potential_remaining_cap` is closest to `TARGET_REMAINDER`\n    # will receive the highest priority.\n    priorities[can_fit_mask] = -np.abs(potential_remaining_cap - TARGET_REMAINDER)\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (11th-15th), we observe that the best heuristic (1st) leverages a refined \"Best Fit\" strategy by adding a small, fixed bonus for partially filled bins, aiming to consolidate items and delay opening new bins. In stark contrast, the worst heuristics (11th-15th) return `np.zeros_like`, effectively making a random choice among bins that can fit an item, demonstrating a complete lack of intelligent prioritization.\n\nComparing (2nd/10th) vs (16th-20th), the second-best heuristics (2nd/10th) implement a pure \"Best Fit\" strategy, prioritizing the tightest possible fit to minimize remaining bin capacity. This simple, effective approach often leads to good packing density. The second-worst heuristics (16th-20th), \"Target Remainder Fit,\" aim to leave a predefined target amount of space in bins. While conceptually advanced, this strategy often performs worse than Best Fit for minimizing bin count because it prioritizes leaving \"useful\" space over tight packing, which can lead to more bins being used or less optimal utilization overall.\n\nComparing (1st) vs (2nd/10th), the primary difference is the `used_bin_bonus` in 1st. While 2nd/10th strictly minimize remaining capacity, 1st introduces a tiny preference for existing, partially filled bins. This subtle bias in 1st encourages consolidation, which can lead to fewer total bins compared to pure Best Fit by slightly prioritizing filling an already-opened bin over opening a new one that might offer an almost identical (but infinitesimally better) fit. This minor, well-controlled perturbation seems to yield better results.\n\nComparing (3rd) vs (4th), 4th is functionally identical to 1st (Best Fit with a small consolidation bonus) and is ranked much higher than 3rd. Heuristic 3rd attempts a \"Hybrid Fit\" with large, hard-coded bonuses for perfect fits and penalties for \"tiny remainders.\" This indicates that overly complex heuristics with aggressive, fixed magnitude parameters can perform worse than simpler, more robust Best Fit variants. The large parameter values in 3rd (`PERFECT_FIT_BONUS=1000.0`, `TINY_REMAINDER_PENALTY=500.0`) can drastically distort the priority landscape, leading to non-optimal decisions without careful, instance-specific tuning.\n\nComparing (second worst: 16th-20th) vs (worst: 11th-15th), the \"Target Remainder Fit\" heuristics (16th-20th) at least attempt a coherent (though often suboptimal for bin minimization) strategy. They involve calculations based on potential remaining capacity and a target. In contrast, the `np.zeros_like` heuristics (11th-15th) provide no decision-making logic, leading to random or arbitrary bin assignments, which is demonstrably the least effective approach for an optimization problem. The Target Remainder Fit, while performing poorly here, is still a structured heuristic, unlike the \"no-op\" of returning zeros.\n- \nHere's a redefinition of 'Current self-reflection', explicitly avoiding the points from 'Ineffective self-reflection':\n\n*   **Keywords:** Adaptive, Emergent, Hybrid, Non-linear, Learning, Meta-heuristics.\n*   **Advice:** Design heuristics where global efficacy arises from local, non-linear interactions. Integrate adaptive components that learn from solution progress or problem characteristics. Explore hybrid strategies combining diverse principles.\n*   **Avoid:** Limiting design to strictly monotonic, linear relationships or fixed, small-magnitude bonuses. Over-reliance on single, static baselines. Shying away from complex parameter spaces or non-obvious transformations.\n*   **Explanation:** This approach leverages emergent properties and dynamic adaptation, moving beyond rigid, pre-defined rules. It embraces computational complexity and advanced tuning to uncover superior, context-aware solutions that fixed, simple methods often miss.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}