{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    As Isaac Newton, I postulate that efficiency is paramount. We must strive\n    to achieve the most complete filling of each bin, thereby minimizing the\n    number of receptacles required. This method, which I term 'Best Fit',\n    prioritizes the bin that, after receiving the item, will have the smallest\n    remaining capacity. This ensures a tighter packing and leaves less\n    undesirable void.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable bin. Bins where the item\n        does not fit are assigned a very low (negative infinity) priority.\n    \"\"\"\n    # Initialize all priorities to a state of utter undesirability (negative infinity).\n    # This ensures that any bin where the item cannot fit will not be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Ascertain which bins possess the capacity to accommodate the item.\n    fits_mask = bins_remain_cap >= item\n\n    # For those bins where the item demonstrably fits, calculate the theoretical\n    # remaining capacity should the item be placed within.\n    potential_remaining_cap = bins_remain_cap[fits_mask] - item\n\n    # To embody the 'Best Fit' principle, we desire to minimize this\n    # 'potential_remaining_cap'. A smaller positive remainder is superior.\n    # Therefore, we assign priority as the negation of this remainder.\n    # A perfect fit (remainder = 0) yields a priority of 0, which is the\n    # highest possible score for a valid placement. Larger remainders result\n    # in more negative scores, thus lower priority.\n    priorities[fits_mask] = -potential_remaining_cap\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin,\n    guided by the principle of minimizing 'spatiotemporal curvature' or\n    'residual energy' within the bins, analogous to seeking a minimal\n    potential energy state (Best Fit).\n\n    This heuristic prioritizes bins that, after accommodating the item,\n    will leave the least amount of remaining capacity. This effectively\n    maximizes the 'packing density' for existing bins, aiming to reduce\n    the total number of required 'dimensional receptacles'. Bins that\n    cannot physically contain the item are assigned an infinitely low\n    priority, as they represent an 'inaccessible' state for the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        A higher score indicates a more favorable bin.\n    \"\"\"\n    # Calculate the hypothetical remaining space if the item were placed in each bin.\n    # This represents the 'residual void' or 'unfilled potential' after insertion.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priorities with an infinitely low value for all bins.\n    # This ensures that bins incapable of holding the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'accessible dimensions' \u2013 bins where the item can actually fit.\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For accessible bins, we apply the 'Best Fit' principle.\n    # We desire to minimize the 'potential_remaining_space', which translates\n    # to maximizing the *negative* of this value. A smaller positive remaining\n    # space (closer to a perfect fit) will result in a higher priority score.\n    # This steers the system towards the 'tightest' possible configuration,\n    # thereby consolidating items and minimizing the need for new bins.\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    \"Gravitational Collapse\" Heuristic for Online Bin Packing.\n\n    Drawing inspiration from the relentless pull of gravity that compacts matter\n    into the densest possible states, this heuristic prioritizes bins that, upon\n    accommodating the given item, would have the smallest remaining capacity.\n\n    This strategy encourages \"tight fits,\" aiming to fill bins as completely as\n    possible before their internal 'volume' reaches a critical point of collapse\n    (i.e., minimal remaining space). A bin achieving a 'perfect fit' (remaining\n    capacity exactly zero) is given the ultimate priority, akin to a final,\n    irreversible gravitational collapse.\n\n    Bins that are too small to contain the item are deemed outside the event\n    horizon and are given the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        Higher scores indicate a stronger gravitational pull towards selection.\n    \"\"\"\n    # Initialize all priorities to a state of infinite repulsion (negative infinity)\n    # for bins that cannot even theoretically contain the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'regions of space-time' (bins) that can physically\n    # accommodate the incoming 'matter' (item).\n    can_fit_mask = bins_remain_cap >= item\n\n    # For those eligible regions, we calculate the remaining 'vacuum' (empty space)\n    # after the item is placed.\n    # A tiny epsilon ensures we don't divide by zero in the case of a 'perfect fit'\n    # where the remaining space is exactly zero, giving it the highest possible density score.\n    epsilon = np.finfo(float).eps\n\n    remaining_space_after_fit = bins_remain_cap[can_fit_mask] - item\n    \n    # The 'gravitational pull' (priority) is inversely proportional to the\n    # remaining 'vacuum'. A smaller remaining space implies a denser state\n    # and thus a stronger pull for the item.\n    priorities[can_fit_mask] = 1.0 / (remaining_space_after_fit + epsilon)\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    \"Gravitational Collapse\" Heuristic for Online Bin Packing.\n\n    Drawing inspiration from the relentless pull of gravity that compacts matter\n    into the densest possible states, this heuristic prioritizes bins that, upon\n    accommodating the given item, would have the smallest remaining capacity.\n\n    This strategy encourages \"tight fits,\" aiming to fill bins as completely as\n    possible before their internal 'volume' reaches a critical point of collapse\n    (i.e., minimal remaining space). A bin achieving a 'perfect fit' (remaining\n    capacity exactly zero) is given the ultimate priority, akin to a final,\n    irreversible gravitational collapse.\n\n    Bins that are too small to contain the item are deemed outside the event\n    horizon and are given the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        Higher scores indicate a stronger gravitational pull towards selection.\n    \"\"\"\n    # Initialize all priorities to a state of infinite repulsion (negative infinity)\n    # for bins that cannot even theoretically contain the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'regions of space-time' (bins) that can physically\n    # accommodate the incoming 'matter' (item).\n    can_fit_mask = bins_remain_cap >= item\n\n    # For those eligible regions, we calculate the remaining 'vacuum' (empty space)\n    # after the item is placed.\n    # A tiny epsilon ensures we don't divide by zero in the case of a 'perfect fit'\n    # where the remaining space is exactly zero, giving it the highest possible density score.\n    epsilon = np.finfo(float).eps\n\n    remaining_space_after_fit = bins_remain_cap[can_fit_mask] - item\n    \n    # The 'gravitational pull' (priority) is inversely proportional to the\n    # remaining 'vacuum'. A smaller remaining space implies a denser state\n    # and thus a stronger pull for the item.\n    priorities[can_fit_mask] = 1.0 / (remaining_space_after_fit + epsilon)\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic implements a \"Best-Fit Decreasing\" strategy by prioritizing\n    bins that, after the item is placed, would have the smallest remaining capacity.\n    This encourages tightly packed bins, preserving larger spaces for future larger items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher preference for the bin.\n    \"\"\"\n    # Calculate the remaining space if the current item were placed in each bin.\n    # For a Best-Fit approach, we aim to minimize this value for bins that can fit the item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priorities. Bins where the item does not fit should have a very low priority.\n    # Using -np.inf ensures these bins are never chosen if any valid option exists.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify bins where the item can actually fit (remaining capacity >= item size).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins where the item fits, the priority should be inversely related to the\n    # potential remaining space. A smaller remaining space implies a tighter fit,\n    # which is preferred. By taking the negative of the remaining space, a value of 0\n    # (perfect fit) yields the highest priority (0), and larger remaining spaces\n    # yield more negative (lower) priorities.\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation aims for a \"Best Fit\" strategy:\n    It prioritizes bins that, after the item is placed, will have the smallest\n    remaining capacity. This helps to 'tightly pack' items into existing bins,\n    leaving larger capacities open for larger items or reducing fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Find bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity if the item were placed in fitting bins\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # For fitting bins, we want to maximize the \"tightness\".\n    # A smaller remaining capacity means a tighter fit.\n    # To achieve this with argmax (which finds the maximum priority score),\n    # we can use the negative of the potential_remaining_cap.\n    # E.g., if remainders are [0.1, 0.5, 0.8], their negatives are [-0.1, -0.5, -0.8].\n    # The max of negatives is -0.1, which corresponds to the smallest positive remainder 0.1.\n    priorities[can_fit_mask] = -potential_remaining_cap\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by the 'Best Fit' approach, we prioritize bins that, upon\n    receiving the item, will have the smallest remaining capacity,\n    thus ensuring a 'tightest fit' for our precious particles and\n    minimizing wasted space, much like finding the precise energy levels\n    for electrons in an atom. We assign a very low priority to bins\n    where the item simply does not fit, as they are not viable candidates.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item were hypothetically placed in each bin.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities. By default, all bins are given a very low priority\n    # (negative infinity) to ensure bins where the item does not fit are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item can actually fit.\n    can_fit_mask = potential_remaining_cap >= 0\n\n    # For bins where the item fits, assign a priority based on the negation of the\n    # potential remaining capacity. This way, a smaller positive remaining capacity\n    # (indicating a tighter fit) results in a larger (less negative) priority score.\n    # The bin with the highest priority will be the one leaving the least free space,\n    # ensuring the most efficient use of our bin \"matter.\"\n    priorities[can_fit_mask] = -potential_remaining_cap[can_fit_mask]\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin,\n    guided by the principle of minimizing 'spatiotemporal curvature' or\n    'residual energy' within the bins, analogous to seeking a minimal\n    potential energy state (Best Fit).\n\n    This heuristic prioritizes bins that, after accommodating the item,\n    will leave the least amount of remaining capacity. This effectively\n    maximizes the 'packing density' for existing bins, aiming to reduce\n    the total number of required 'dimensional receptacles'. Bins that\n    cannot physically contain the item are assigned an infinitely low\n    priority, as they represent an 'inaccessible' state for the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        A higher score indicates a more favorable bin.\n    \"\"\"\n    # Calculate the hypothetical remaining space if the item were placed in each bin.\n    # This represents the 'residual void' or 'unfilled potential' after insertion.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priorities with an infinitely low value for all bins.\n    # This ensures that bins incapable of holding the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'accessible dimensions' \u2013 bins where the item can actually fit.\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For accessible bins, we apply the 'Best Fit' principle.\n    # We desire to minimize the 'potential_remaining_space', which translates\n    # to maximizing the *negative* of this value. A smaller positive remaining\n    # space (closer to a perfect fit) will result in a higher priority score.\n    # This steers the system towards the 'tightest' possible configuration,\n    # thereby consolidating items and minimizing the need for new bins.\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic implements a \"Best-Fit Decreasing\" strategy by prioritizing\n    bins that, after the item is placed, would have the smallest remaining capacity.\n    This encourages tightly packed bins, preserving larger spaces for future larger items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher preference for the bin.\n    \"\"\"\n    # Calculate the remaining space if the current item were placed in each bin.\n    # For a Best-Fit approach, we aim to minimize this value for bins that can fit the item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priorities. Bins where the item does not fit should have a very low priority.\n    # Using -np.inf ensures these bins are never chosen if any valid option exists.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify bins where the item can actually fit (remaining capacity >= item size).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins where the item fits, the priority should be inversely related to the\n    # potential remaining space. A smaller remaining space implies a tighter fit,\n    # which is preferred. By taking the negative of the remaining space, a value of 0\n    # (perfect fit) yields the highest priority (0), and larger remaining spaces\n    # yield more negative (lower) priorities.\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by the 'Best Fit' approach, we prioritize bins that, upon\n    receiving the item, will have the smallest remaining capacity,\n    thus ensuring a 'tightest fit' for our precious particles and\n    minimizing wasted space, much like finding the precise energy levels\n    for electrons in an atom. We assign a very low priority to bins\n    where the item simply does not fit, as they are not viable candidates.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item were hypothetically placed in each bin.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities. By default, all bins are given a very low priority\n    # (negative infinity) to ensure bins where the item does not fit are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item can actually fit.\n    can_fit_mask = potential_remaining_cap >= 0\n\n    # For bins where the item fits, assign a priority based on the negation of the\n    # potential remaining capacity. This way, a smaller positive remaining capacity\n    # (indicating a tighter fit) results in a larger (less negative) priority score.\n    # The bin with the highest priority will be the one leaving the least free space,\n    # ensuring the most efficient use of our bin \"matter.\"\n    priorities[can_fit_mask] = -potential_remaining_cap[can_fit_mask]\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 12th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 15th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 17th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}