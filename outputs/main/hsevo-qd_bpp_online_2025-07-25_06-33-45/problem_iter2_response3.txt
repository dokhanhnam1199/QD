```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Heuristic prioritizing exact fit, remaining capacity, and avoiding small gaps.
    """
    # Calculate a base priority score based on how much capacity is left in each bin
    base_priority = bins_remain_cap - item
    
    # Give higher priority to bins that can exactly fit the item
    exact_fit_priority = np.where(np.isclose(base_priority, 0), np.inf, 0)
    
    # Give lower priority to bins that cannot hold the item
    invalid_bins_priority = np.where(base_priority < 0, -np.inf, 0)
    
    # Give higher priority to bins with less remaining capacity, to avoid leaving small gaps
    capacity_priority = -bins_remain_cap + item
    
    # Calculate how much space would be left in each bin if the item is added
    remaining_space = bins_remain_cap - item
    
    # Give a moderate priority to bins where the item would leave some space
    partial_fit_priority = np.where(remaining_space > 0, 0.5, 0.0)
    
    # Combine the priorities into a single score for each bin
    # Using the weighted sum to balance competing objectives
    priority_scores = exact_fit_priority + invalid_bins_priority + 0.5 * capacity_priority + 0.2 * partial_fit_priority
    
    # Ensure that the priority scores are finite (important for stability and avoiding NaNs)
    priority_scores = np.minimum(np.maximum(priority_scores, -1e10), 1e10)
    
    return priority_scores
```
