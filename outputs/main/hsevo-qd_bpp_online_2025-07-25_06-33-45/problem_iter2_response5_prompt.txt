{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function favors bins that have the most remaining capacity,\n    while minimizing the number of bins used.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_adding_item = bins_remain_cap - item\n    \n    # Give high priority to bins with enough capacity\n    has_enough_capacity = (remaining_cap_after_adding_item >= 0).astype(int)\n    \n    # Calculate a score based on the remaining capacity after adding the item\n    score = remaining_cap_after_adding_item.copy()\n    score[remaining_cap_after_adding_item < 0] = np.inf  # Invalid bins have very low priority\n    \n    # Bins with more remaining capacity get higher priority\n    priority = -1 * has_enough_capacity * score / bins_remain_cap\n    \n    # Avoid adding item to a super tight bin to minimize probability of next item exceeding capacity\n    non_tight_bin_factor = np.tanh(1 - (item / bins_remain_cap))\n    priority *= non_tight_bin_factor\n    \n    # Also avoid many items with small size prefer same super empty bin\n    item_size_factor = item / np.sum(bins_remain_cap)\n    priority *= np.tanh(1 - item_size_factor)\n    \n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function favors bins that have the most remaining capacity,\n    while at the same time trying to fit items into bins where they will use the \n    least amount of remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the ratio of item size to remaining bin capacity\n    # A high ratio means the item will use a lot of the remaining capacity\n    # We want to avoid this, so we take the negative of the ratio\n    ratio = -item / np.maximum(bins_remain_cap, 1e-6)\n\n    # Calculate the remaining capacity after adding the item\n    # We want to maximize this, so we add it to the priority\n    remaining_cap = bins_remain_cap - item\n    remaining_cap = np.where(remaining_cap < 0, 0, remaining_cap)\n\n    # Calculate the priority score using the remaining capacity and ratio\n    # The bin with the highest priority score will be selected for the item\n    priority = ratio + remaining_cap / np.maximum(bins_remain_cap, 1e-6)\n    priority = np.where(bins_remain_cap < item, -np.inf, priority)  # Set priority to -inf if the item doesn't fit\n\n    return priority\n\n### Analyze & experience\n- Comparing 1st vs 20th, we see that the first heuristic prioritizes bins based on the ratio of the remaining capacity and the item size, while the 20th heuristic favors bins with the most remaining capacity but also considers the ratio of item size to remaining capacity. \nComparing 2nd vs 19th, we see that the second heuristic favors bins that have just enough capacity to accommodate the item and bins with less remaining capacity, while the 19th heuristic favors bins with the most remaining capacity relative to the item size. \nComparing 3rd vs 18th, we see that the third heuristic prioritizes bins that can exactly fit the item and gives lower priority to bins that cannot hold the item, while the 18th heuristic favors bins with the most available capacity, normalizing the remaining capacity. \nOverall: Better heuristics consider multiple factors such as remaining capacity, item size, and bin utilization, while worse heuristics focus on a single aspect.\n- \nHere's a redefined 'Current self-reflection':\n* **Keywords**: Balance, Prioritization, Objective\n* **Advice**: Identify key factors, weigh their importance, and adjust heuristics accordingly\n* **Avoid**: Overemphasis on single objectives, neglect of trade-offs\n* **Explanation**: Effective heuristics require balancing competing objectives, considering multiple factors to achieve optimal outcomes, and avoiding pitfalls of overly narrow focus.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}