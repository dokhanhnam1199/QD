```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines elements of priority_v0 and priority_v1 for better performance.
    """
    # Calculate how much space would be left in each bin if the item is added
    remaining_space = bins_remain_cap - item
    
    # Give a high priority to bins where the item fills them exactly
    exact_fit = np.where(remaining_space == 0, 1.0, 0.0)
    
    # Calculate the absolute difference between each bin's remaining capacity and the item size
    diff = np.abs(bins_remain_cap - item)
    
    # Calculate the normalized remaining capacities
    normalized_caps = bins_remain_cap / np.sum(bins_remain_cap)
    
    # Create a priority score array based on the remaining capacity, difference, and normalized capacities
    # This favors bins with more remaining capacity but also considers the ratio of item size to remaining capacity
    priority = bins_remain_cap / (diff + 1e-6)  # Adding a small value to avoid division by zero
    
    # Give a moderate priority to bins where the item would leave some space
    # and consider the normalized remaining capacities
    partial_fit = np.where(remaining_space > 0, 0.5 * normalized_caps, 0.0)
    
    # Avoid using bins that are too small
    invalid_bins = np.where(bins_remain_cap < item, -1.0, 0.0)
    
    # Calculate the final priority as a weighted sum
    priorities = 2.0 * exact_fit + 0.5 * priority + partial_fit + invalid_bins
    
    # Ensure invalid bins have a lower priority than others
    priorities = np.where(priorities < 0, -1.0, priorities)
    
    # Introduce an additional term to prioritize bins with less remaining capacity
    # when the item size is large compared to the bin capacity
    capacity_ratio = item / (bins_remain_cap + 1e-6)  # Adding a small value to avoid division by zero
    priorities -= 0.1 * capacity_ratio
    
    return priorities
```
