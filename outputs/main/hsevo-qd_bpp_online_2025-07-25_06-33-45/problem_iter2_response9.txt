```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines remaining capacity and item size factors.
    """
    # Calculate remaining capacity after adding the item
    remaining_cap_after_adding_item = bins_remain_cap - item
    
    # Give high priority to bins with enough capacity
    has_enough_capacity = (remaining_cap_after_adding_item >= 0).astype(int)
    
    # Calculate a score based on the remaining capacity after adding the item
    score = remaining_cap_after_adding_item.copy()
    score[remaining_cap_after_adding_item < 0] = np.inf  # Invalid bins have very low priority
    
    # Bins with more remaining capacity get higher priority
    priority = -1 * has_enough_capacity * score / bins_remain_cap
    
    # Also consider the ratio of item size to remaining bin capacity
    ratio = -item / np.maximum(bins_remain_cap, 1e-6)
    priority += ratio  # Add the ratio to the priority
    
    # Avoid adding item to a super tight bin to minimize probability of next item exceeding capacity
    non_tight_bin_factor = np.tanh(1 - (item / bins_remain_cap))
    priority *= non_tight_bin_factor
    
    # Set priority to -inf if the item doesn't fit
    priority = np.where(bins_remain_cap < item, -np.inf, priority)
    
    return priority
```
