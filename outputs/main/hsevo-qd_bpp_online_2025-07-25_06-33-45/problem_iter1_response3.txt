```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.

    This priority function is designed to favor bins that have just enough capacity to 
    hold the item, to avoid splitting items across multiple bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate a base priority score based on how much capacity is left in each bin
    base_priority = bins_remain_cap - item
    
    # Give higher priority to bins that can exactly fit the item
    exact_fit_priority = np.where(np.isclose(base_priority, 0), np.inf, 0)
    
    # Give lower priority to bins that cannot hold the item
    invalid_bins_priority = np.where(base_priority < 0, -np.inf, 0)
    
    # Give higher priority to bins with less remaining capacity, to avoid leaving small gaps
    capacity_priority = -bins_remain_cap + item
    
    # Combine the priorities into a single score for each bin
    priority_scores = exact_fit_priority + invalid_bins_priority + capacity_priority
    
    # Ensure that the priority scores are finite (important for stability and avoiding NaNs)
    priority_scores = np.minimum(np.maximum(priority_scores, -1e10), 1e10)
    
    return priority_scores
```
