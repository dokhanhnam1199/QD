```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines ratio, difference, and penalty for priority scores.
    """
    # Calculate the ratio of the remaining capacity and the item size
    ratio = bins_remain_cap / item
    
    # Calculate the absolute difference between the remaining capacity and the item size
    diff = np.abs(bins_remain_cap - item)
    
    # Calculate a penalty term for bins that are nearly full
    penalty = np.maximum(0, 1 - (bins_remain_cap / item))
    
    # Calculate the priority score as a weighted combination of the ratio and difference
    priority_score = (1 / (diff + 1e-9)) * np.exp(-penalty) * (1 + 1 / (ratio + 1e-9))
    
    # Give a high priority to bins where the item fills them exactly
    exact_fit = np.where(bins_remain_cap - item == 0, 2.0, 1.0)
    
    # Calculate the normalized remaining capacities
    normalized_caps = bins_remain_cap / np.sum(bins_remain_cap)
    
    # Give a moderate priority to bins where the item would leave some space
    partial_fit = np.where(bins_remain_cap - item > 0, 0.5 * normalized_caps, 0.0)
    
    # Combine the priority score with exact fit and partial fit
    priority_score = priority_score * exact_fit + partial_fit
    
    # Avoid using bins that are too small
    priority_score = np.where(bins_remain_cap < item, -1.0, priority_score)
    
    return priority_score
```
