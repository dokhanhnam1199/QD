[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines ratio, difference, and penalty for nuanced bin selection.\n    \"\"\"\n    # Calculate the ratio of the remaining capacity and the item size\n    ratio = bins_remain_cap / item\n    \n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate a penalty term for bins that are nearly full\n    penalty = np.maximum(0, 1 - (bins_remain_cap / item))\n    \n    # Calculate the priority score as a weighted combination of the factors\n    # Weigh the ratio and difference equally, and give a smaller weight to the penalty term\n    priority_score = (1 / (diff + 1e-9)) * (1 / (ratio + 1e-9)) * (1 - 0.1 * penalty)\n    \n    # Consider exact fit and partial fit for additional prioritization\n    remaining_space = bins_remain_cap - item\n    exact_fit = np.where(remaining_space == 0, 1.0, 0.0)\n    partial_fit = np.where(remaining_space > 0, 0.5, 0.0)\n    \n    # Combine the priority scores with exact and partial fit considerations\n    priority_score += 2.0 * exact_fit + 0.5 * partial_fit\n    \n    # Ensure invalid bins have a lower priority than others\n    invalid_bins = np.where(bins_remain_cap < item, -1.0, 0.0)\n    priority_score += invalid_bins\n    \n    return priority_score",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 257.47299274176135,
    "mi": 85.8482479317976,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines remaining capacity, exact fit, and item size ratio.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity of each bin and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score as the inverse of the difference and consider remaining capacity\n    priority_score = (bins_remain_cap / (diff + 1e-9))  # add a small value to avoid division by zero\n    \n    # Calculate how much space would be left in each bin if the item is added\n    remaining_space = bins_remain_cap - item\n    \n    # Give a high priority to bins where the item fills them exactly\n    exact_fit = np.where(remaining_space == 0, 2.0, 1.0)  # increased weight for exact fit\n    \n    # Calculate the normalized remaining capacities\n    normalized_caps = bins_remain_cap / np.sum(bins_remain_cap)\n    \n    # Give a moderate priority to bins where the item would leave some space\n    # and consider the normalized remaining capacities\n    partial_fit = np.where(remaining_space > 0, 0.5 * normalized_caps, 0.0)\n    \n    # Avoid using bins that are too small\n    invalid_bins = np.where(bins_remain_cap < item, -1.0, 0.0)\n    \n    # Calculate the final priority as a weighted sum of the three components\n    priorities = priority_score * exact_fit + partial_fit + invalid_bins\n    \n    # Ensure invalid bins have a lower priority than others\n    priorities = np.where(priorities < 0, -1.0, priorities)\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 257.47299274176135,
    "mi": 85.8482479317976,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\n# Define thresholds\nzero_threshold = 1e-6\nhalf_full_threshold = 0.5\nlarge_value = 1e6\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines nuanced calculations from priority_v0 and simplicity of priority_v1.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    diff = bins_remain_cap - item\n    \n    # Create a mask where the item can fit into the bin\n    can_fit = diff >= zero_threshold\n    \n    # Calculate the normalized remaining capacities\n    normalized_caps = bins_remain_cap / np.sum(bins_remain_cap)\n    \n    # Calculate the priority score, combining remaining capacity, item size, and normalized capacities\n    priorities = np.where(can_fit, \n                          1 / (1 + np.abs(diff)) * normalized_caps, \n                          np.zeros_like(normalized_caps))\n    \n    # Add a bonus for exact fit bins and a penalty for nearly full bins\n    exact_fit_bonus = np.where(diff == 0, 1.0, 0.0)\n    nearly_full_penalty = np.where(can_fit & (bins_remain_cap / (item + bins_remain_cap) > half_full_threshold), \n                                   -large_value, \n                                   0.0)\n    \n    # Calculate the final priority score\n    priorities = priorities + exact_fit_bonus + nearly_full_penalty\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 257.47299274176135,
    "mi": 85.8482479317976,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines ratio, difference, and penalty for optimal bin selection.\n    \"\"\"\n    # Calculate the ratio of the remaining capacity to the item size\n    ratio = bins_remain_cap / item\n    \n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate a penalty term for bins that are nearly full\n    penalty = np.maximum(0, 1 - (bins_remain_cap / item))\n    \n    # Calculate the priority score as a weighted sum of the ratio and difference, with a penalty term\n    priority_score = (1 / (diff + 1e-9)) * (1 / (ratio + 1e-9)) * (1 - penalty * 0.5)\n    \n    # Add a small bonus for bins that are exactly the right size (exact fit)\n    bonus = np.where(np.isclose(bins_remain_cap, item), 1e6, 0)\n    \n    # Consider the normalized remaining capacities (partial fit)\n    normalized_caps = bins_remain_cap / np.sum(bins_remain_cap)\n    partial_fit = np.where(bins_remain_cap > item, 0.5 * normalized_caps, 0.0)\n    \n    # Combine the priority score, bonus, and partial fit\n    combined_score = priority_score + bonus + partial_fit\n    \n    # Avoid using bins that are too small\n    invalid_bins = np.where(bins_remain_cap < item, -1.0, 0.0)\n    final_score = np.where(combined_score < 0, -1.0, combined_score) + invalid_bins\n    \n    return final_score",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 257.47299274176135,
    "mi": 85.8482479317976,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines ratio, difference, and penalty for priority scores.\n    \"\"\"\n    # Calculate the ratio of the remaining capacity and the item size\n    ratio = bins_remain_cap / item\n    \n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate a penalty term for bins that are nearly full\n    penalty = np.maximum(0, 1 - (bins_remain_cap / item))\n    \n    # Calculate the priority score as a weighted combination of the ratio and difference\n    priority_score = (1 / (diff + 1e-9)) * np.exp(-penalty) * (1 + 1 / (ratio + 1e-9))\n    \n    # Give a high priority to bins where the item fills them exactly\n    exact_fit = np.where(bins_remain_cap - item == 0, 2.0, 1.0)\n    \n    # Calculate the normalized remaining capacities\n    normalized_caps = bins_remain_cap / np.sum(bins_remain_cap)\n    \n    # Give a moderate priority to bins where the item would leave some space\n    partial_fit = np.where(bins_remain_cap - item > 0, 0.5 * normalized_caps, 0.0)\n    \n    # Combine the priority score with exact fit and partial fit\n    priority_score = priority_score * exact_fit + partial_fit\n    \n    # Avoid using bins that are too small\n    priority_score = np.where(bins_remain_cap < item, -1.0, priority_score)\n    \n    return priority_score",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 257.47299274176135,
    "mi": 85.8482479317976,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of priority_v0 and priority_v1 for better performance.\n    \"\"\"\n    # Calculate how much space would be left in each bin if the item is added\n    remaining_space = bins_remain_cap - item\n    \n    # Give a high priority to bins where the item fills them exactly\n    exact_fit = np.where(remaining_space == 0, 1.0, 0.0)\n    \n    # Calculate the absolute difference between each bin's remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the normalized remaining capacities\n    normalized_caps = bins_remain_cap / np.sum(bins_remain_cap)\n    \n    # Create a priority score array based on the remaining capacity, difference, and normalized capacities\n    # This favors bins with more remaining capacity but also considers the ratio of item size to remaining capacity\n    priority = bins_remain_cap / (diff + 1e-6)  # Adding a small value to avoid division by zero\n    \n    # Give a moderate priority to bins where the item would leave some space\n    # and consider the normalized remaining capacities\n    partial_fit = np.where(remaining_space > 0, 0.5 * normalized_caps, 0.0)\n    \n    # Avoid using bins that are too small\n    invalid_bins = np.where(bins_remain_cap < item, -1.0, 0.0)\n    \n    # Calculate the final priority as a weighted sum\n    priorities = 2.0 * exact_fit + 0.5 * priority + partial_fit + invalid_bins\n    \n    # Ensure invalid bins have a lower priority than others\n    priorities = np.where(priorities < 0, -1.0, priorities)\n    \n    # Introduce an additional term to prioritize bins with less remaining capacity\n    # when the item size is large compared to the bin capacity\n    capacity_ratio = item / (bins_remain_cap + 1e-6)  # Adding a small value to avoid division by zero\n    priorities -= 0.1 * capacity_ratio\n    \n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 257.47299274176135,
    "mi": 85.8482479317976,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines nuanced calculations for remaining capacity and item size.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    diff = bins_remain_cap - item\n    \n    # Create a mask where the item can fit into the bin\n    can_fit = diff >= 0\n    \n    # Set the priority to 0 for bins that cannot accommodate the item\n    priorities = np.where(can_fit, diff, 0)\n    \n    # Give a high priority to bins where the item fills them exactly\n    exact_fit = np.where(priorities == 0, 1.0, 0.0)\n    \n    # Calculate the normalized remaining capacities\n    normalized_caps = bins_remain_cap / np.sum(bins_remain_cap)\n    \n    # Calculate the final priorities, combining remaining capacity and item size considerations\n    # Higher priorities for bins with just enough capacity and higher normalized capacities\n    priorities = np.where(can_fit, \n                          exact_fit + 1 / (1 + np.abs(priorities)) * normalized_caps, \n                          np.zeros_like(normalized_caps))\n    \n    # Subtract a large value from the priorities of bins that are more than half full\n    priorities = np.where(can_fit & (bins_remain_cap / (item + bins_remain_cap) > 0.5), \n                          priorities - np.max(priorities), \n                          priorities)\n    \n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 257.47299274176135,
    "mi": 85.8482479317976,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines ratio, difference, and penalty with exact fit and partial fit considerations.\n    \"\"\"\n    # Calculate the ratio of the remaining capacity and the item size\n    ratio = bins_remain_cap / item\n    \n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate a penalty term for bins that are nearly full\n    penalty = np.maximum(0, 1 - (bins_remain_cap / (item + 1e-9)))\n    \n    # Calculate the priority score as a combination of the ratio, difference, and penalty\n    priority_score = (1 / (diff + 1e-9)) * np.exp(-ratio) * (1 - penalty)\n    \n    # Consider exact fit and partial fit\n    remaining_space = bins_remain_cap - item\n    exact_fit = np.where(remaining_space == 0, 1.0, 0.0)\n    partial_fit = np.where(remaining_space > 0, 0.5, 0.0)\n    \n    # Combine the priority score with exact and partial fit considerations\n    priority_score *= (exact_fit + partial_fit + 1)  # prioritize exact fit and partial fit\n    \n    # Apply a tie-breaker to prioritize bins with more remaining capacity\n    priority_score *= bins_remain_cap + 1e-9\n    \n    return priority_score",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 257.47299274176135,
    "mi": 85.8482479317976,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines ratio, difference, and penalty with exact fit and partial fit considerations.\n    \"\"\"\n    # Calculate the ratio of the remaining capacity and the item size\n    ratio = bins_remain_cap / item\n    \n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate a penalty term for bins that are nearly full\n    penalty = np.maximum(0, 1 - (bins_remain_cap / (item + 1e-9)))\n    \n    # Calculate the priority score as a combination of the ratio, difference, and penalty\n    priority_score = (1 / (diff + 1e-9)) * np.exp(-ratio) * (1 - penalty)\n    \n    # Consider exact fit and partial fit\n    exact_fit = np.where(bins_remain_cap - item == 0, 2.0, 0.0)\n    partial_fit = np.where(bins_remain_cap - item > 0, 0.5, 0.0)\n    \n    # Combine priority scores with exact and partial fit considerations\n    combined_priority = priority_score * (exact_fit + partial_fit + 1)\n    \n    # Apply a tie-breaker to prioritize bins with more remaining capacity\n    combined_priority *= bins_remain_cap + 1e-9\n    \n    return combined_priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 257.47299274176135,
    "mi": 85.8482479317976,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines ratio, difference, and penalty for priority scores.\n    \"\"\"\n    # Calculate the ratio of the remaining capacity and the item size\n    ratio = bins_remain_cap / item\n    \n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate a penalty term for bins that are nearly full\n    penalty = np.maximum(0, 1 - (bins_remain_cap / item))\n    \n    # Calculate a bonus term for exact fit\n    exact_fit = np.where(bins_remain_cap - item == 0, 1.0, 0.0)\n    \n    # Calculate the priority score as a weighted combination of the factors\n    priority_score = (1 / (diff + 1e-9)) * (1 / (ratio + 1e-9)) * (1 - 0.1 * penalty) + 2.0 * exact_fit\n    \n    # Ensure the priority score is high for bins that can fit the item exactly\n    priority_score = np.where(bins_remain_cap < item, -1.0, priority_score)\n    \n    return priority_score",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 257.47299274176135,
    "mi": 85.8482479317976,
    "token_count": 146.0,
    "exec_success": true
  }
]