```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines remaining capacity, exact fit, and item size ratio.
    """
    # Calculate the absolute difference between the remaining capacity of each bin and the item size
    diff = np.abs(bins_remain_cap - item)
    
    # Calculate the priority score as the inverse of the difference and consider remaining capacity
    priority_score = (bins_remain_cap / (diff + 1e-9))  # add a small value to avoid division by zero
    
    # Calculate how much space would be left in each bin if the item is added
    remaining_space = bins_remain_cap - item
    
    # Give a high priority to bins where the item fills them exactly
    exact_fit = np.where(remaining_space == 0, 2.0, 1.0)  # increased weight for exact fit
    
    # Calculate the normalized remaining capacities
    normalized_caps = bins_remain_cap / np.sum(bins_remain_cap)
    
    # Give a moderate priority to bins where the item would leave some space
    # and consider the normalized remaining capacities
    partial_fit = np.where(remaining_space > 0, 0.5 * normalized_caps, 0.0)
    
    # Avoid using bins that are too small
    invalid_bins = np.where(bins_remain_cap < item, -1.0, 0.0)
    
    # Calculate the final priority as a weighted sum of the three components
    priorities = priority_score * exact_fit + partial_fit + invalid_bins
    
    # Ensure invalid bins have a lower priority than others
    priorities = np.where(priorities < 0, -1.0, priorities)
    
    return priorities
```
