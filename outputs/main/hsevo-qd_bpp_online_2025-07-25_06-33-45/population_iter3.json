[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines remaining capacity and item size considerations.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    diff = bins_remain_cap - item\n    \n    # Create a mask where the item can fit into the bin\n    can_fit = diff >= 0\n    \n    # Set the priority to 0 for bins that cannot accommodate the item\n    priorities = np.where(can_fit, diff, 0)\n    \n    # Calculate the normalized remaining capacities\n    normalized_caps = bins_remain_cap / np.sum(bins_remain_cap)\n    \n    # Calculate the final priorities, combining remaining capacity and item size considerations\n    # Higher priorities for bins with just enough capacity and higher normalized capacities\n    priorities = np.where(can_fit, \n                          1 / (1 + np.abs(priorities)) * normalized_caps, \n                          np.zeros_like(normalized_caps))\n    \n    # Subtract a large value from the priorities of bins that are more than half full\n    priorities = np.where(can_fit & (bins_remain_cap / (item + bins_remain_cap) > 0.5), \n                          priorities - np.max(priorities), \n                          priorities)\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 192.56842503028858,
    "mi": 85.2115937500424,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by remaining capacity and item size ratio.\n    \"\"\"\n    # calculate the absolute difference between the remaining capacity of each bin and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # calculate the priority score as the inverse of the difference and consider remaining capacity\n    priority_score = (bins_remain_cap / (diff + 1e-9))  # add a small value to avoid division by zero\n    \n    return priority_score",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 192.56842503028858,
    "mi": 85.2115937500424,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Balance remaining capacity and utilization.\n    \"\"\"\n    # Calculate the available space in each bin\n    available_space = bins_remain_cap - item\n    \n    # Assign a high priority to bins that have just enough capacity to accommodate the item\n    exact_fit_priority = np.where(available_space == 0, 1e6, 0)\n    \n    # Assign a priority to bins based on the available space and remaining capacity\n    available_space_priority = 1 / (1 + np.maximum(available_space, 0))\n    remaining_capacity_priority = bins_remain_cap / np.sum(bins_remain_cap)\n    \n    # Combine the priorities, favoring exact fit, then available space, and finally remaining capacity\n    priority_scores = available_space_priority + 0.1 * exact_fit_priority + 0.1 * remaining_capacity_priority\n    \n    # Ensure that bins that cannot accommodate the item have a priority of 0\n    return np.where(bins_remain_cap >= item, priority_scores, 0)\n\n# Example usage:\nitem_size = 5.0\nbins_remaining_cap = np.array([10.0, 8.0, 12.0, 7.0])\npriority_scores = priority_v2(item_size, bins_remaining_cap)\nprint(priority_scores)",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 192.56842503028858,
    "mi": 85.2115937500424,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Heuristic prioritizing exact fit, remaining capacity, and avoiding small gaps.\n    \"\"\"\n    # Calculate a base priority score based on how much capacity is left in each bin\n    base_priority = bins_remain_cap - item\n    \n    # Give higher priority to bins that can exactly fit the item\n    exact_fit_priority = np.where(np.isclose(base_priority, 0), np.inf, 0)\n    \n    # Give lower priority to bins that cannot hold the item\n    invalid_bins_priority = np.where(base_priority < 0, -np.inf, 0)\n    \n    # Give higher priority to bins with less remaining capacity, to avoid leaving small gaps\n    capacity_priority = -bins_remain_cap + item\n    \n    # Calculate how much space would be left in each bin if the item is added\n    remaining_space = bins_remain_cap - item\n    \n    # Give a moderate priority to bins where the item would leave some space\n    partial_fit_priority = np.where(remaining_space > 0, 0.5, 0.0)\n    \n    # Combine the priorities into a single score for each bin\n    # Using the weighted sum to balance competing objectives\n    priority_scores = exact_fit_priority + invalid_bins_priority + 0.5 * capacity_priority + 0.2 * partial_fit_priority\n    \n    # Ensure that the priority scores are finite (important for stability and avoiding NaNs)\n    priority_scores = np.minimum(np.maximum(priority_scores, -1e10), 1e10)\n    \n    return priority_scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 192.56842503028858,
    "mi": 85.2115937500424,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Balances item fit and bin utilization.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    # This favors bins that have just enough capacity to accommodate the item\n    diff = bins_remain_cap - item\n    \n    # Calculate the priority score based on the difference and remaining capacity\n    # A higher priority is given to bins with a smaller difference and more remaining capacity\n    priority = np.where(diff >= 0, -np.abs(diff) + 1e-6 * bins_remain_cap, -np.inf)\n    \n    # Alternative calculation: prioritize bins with a remaining capacity closer to the item size\n    # priority_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    # priority_scores += 1e-6 * bins_remain_cap\n    \n    # Combine both calculations to balance item fit and bin utilization\n    # priority = np.maximum(priority, priority_scores)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 192.56842503028858,
    "mi": 85.2115937500424,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines remaining capacity and item size factors.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_adding_item = bins_remain_cap - item\n    \n    # Give high priority to bins with enough capacity\n    has_enough_capacity = (remaining_cap_after_adding_item >= 0).astype(int)\n    \n    # Calculate a score based on the remaining capacity after adding the item\n    score = remaining_cap_after_adding_item.copy()\n    score[remaining_cap_after_adding_item < 0] = np.inf  # Invalid bins have very low priority\n    \n    # Bins with more remaining capacity get higher priority\n    priority = -1 * has_enough_capacity * score / bins_remain_cap\n    \n    # Also consider the ratio of item size to remaining bin capacity\n    ratio = -item / np.maximum(bins_remain_cap, 1e-6)\n    priority += ratio  # Add the ratio to the priority\n    \n    # Avoid adding item to a super tight bin to minimize probability of next item exceeding capacity\n    non_tight_bin_factor = np.tanh(1 - (item / bins_remain_cap))\n    priority *= non_tight_bin_factor\n    \n    # Set priority to -inf if the item doesn't fit\n    priority = np.where(bins_remain_cap < item, -np.inf, priority)\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 192.56842503028858,
    "mi": 85.2115937500424,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Balances remaining capacity, exact fit, and item size.\n    \"\"\"\n    # Calculate how much space would be left in each bin if the item is added\n    remaining_space = bins_remain_cap - item\n    \n    # Give a high priority to bins where the item fills them exactly\n    exact_fit = np.where(remaining_space == 0, 1.0, 0.0)\n    \n    # Calculate the normalized remaining capacities\n    normalized_caps = bins_remain_cap / np.sum(bins_remain_cap)\n    \n    # Give a moderate priority to bins where the item would leave some space\n    # and consider the normalized remaining capacities\n    partial_fit = np.where(remaining_space > 0, 0.5 * normalized_caps, 0.0)\n    \n    # Avoid using bins that are too small\n    invalid_bins = np.where(bins_remain_cap < item, -1.0, 0.0)\n    \n    # Calculate the priority as a weighted sum\n    priorities = 2.0 * exact_fit + partial_fit + invalid_bins\n    \n    # Ensure invalid bins have a lower priority than others\n    priorities = np.where(priorities < 0, -1.0, priorities)\n    \n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 86.58755484643,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 192.56842503028858,
    "mi": 85.2115937500424,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of previous heuristics for better performance.\n    \"\"\"\n    # Calculate how much space would be left in each bin if the item is added\n    remaining_space = bins_remain_cap - item\n    \n    # Give a high priority to bins where the item fills them exactly\n    exact_fit = np.where(remaining_space == 0, 1.0, 0.0)\n    \n    # Calculate the absolute difference between each bin's remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Create a priority score array based on the remaining capacity and difference\n    # This favors bins with more remaining capacity but also considers the ratio of item size to remaining capacity\n    priority = bins_remain_cap / (diff + 1e-6)  # Adding a small value to avoid division by zero\n    \n    # Give a moderate priority to bins where the item would leave some space\n    partial_fit = np.where(remaining_space > 0, 0.5, 0.0)\n    \n    # Avoid using bins that are too small\n    invalid_bins = np.where(bins_remain_cap < item, -1.0, 0.0)\n    \n    # Calculate the final priority as a weighted sum\n    priorities = 2.0 * exact_fit + 0.5 * priority + partial_fit + invalid_bins\n    \n    # Ensure invalid bins have a lower priority than others\n    priorities = np.where(priorities < 0, -1.0, priorities)\n    \n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 192.56842503028858,
    "mi": 85.2115937500424,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines prioritization by remaining capacity and item size.\n    \"\"\"\n    # Calculate priority scores based on the ratio of remaining capacity to item size\n    # and favor bins that are not full to minimize the number of bins used\n    priority_scores = np.where(bins_remain_cap >= item, \n                              -bins_remain_cap * (1 - np.exp(-bins_remain_cap)), \n                              -np.inf)\n    \n    # Add a factor to prioritize bins with less remaining capacity relative to item size\n    priority_scores *= np.where(priority_scores < 0, 1 + np.log(1 + bins_remain_cap / (item + 1e-8)), 0)\n    \n    return priority_scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 192.56842503028858,
    "mi": 85.2115937500424,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines remaining capacity and item size factors.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_adding_item = bins_remain_cap - item\n    \n    # Give high priority to bins with enough capacity\n    has_enough_capacity = (remaining_cap_after_adding_item >= 0).astype(int)\n    \n    # Calculate a score based on the remaining capacity after adding the item\n    score = remaining_cap_after_adding_item.copy()\n    score[remaining_cap_after_adding_item < 0] = np.inf  # Invalid bins have very low priority\n    \n    # Bins with more remaining capacity get higher priority\n    priority = -1 * has_enough_capacity * score / bins_remain_cap\n    \n    # Also consider the ratio of item size to remaining bin capacity\n    ratio = -item / np.maximum(bins_remain_cap, 1e-6)\n    priority += ratio  # Add the ratio to the priority\n    \n    # Avoid adding item to a super tight bin to minimize probability of next item exceeding capacity\n    non_tight_bin_factor = np.tanh(1 - (item / bins_remain_cap))\n    priority *= non_tight_bin_factor\n    \n    # Set priority to -inf if the item doesn't fit\n    priority = np.where(bins_remain_cap < item, -np.inf, priority)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 192.56842503028858,
    "mi": 85.2115937500424,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on a combination of factors:\n    - The ratio of the remaining capacity and the item size (to minimize waste)\n    - The absolute difference between the remaining capacity and the item size (to minimize the number of bins)\n    - A penalty term for bins that are nearly full (to prevent overfilling)\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the ratio of the remaining capacity and the item size\n    ratio = bins_remain_cap / item\n    \n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate a penalty term for bins that are nearly full\n    penalty = np.maximum(0, 1 - (bins_remain_cap / (item + 1e-9)))\n    \n    # Calculate the priority score as a combination of the ratio, difference, and penalty\n    priority_score = (1 / (diff + 1e-9)) * np.exp(-ratio) * (1 - penalty)\n    \n    # Apply a tie-breaker to prioritize bins with more remaining capacity\n    priority_score *= bins_remain_cap + 1e-9\n    \n    return priority_score",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 173.9178331268546,
    "mi": 59.21145598574435,
    "token_count": 131.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on a combination of factors:\n    - The ratio of the remaining capacity and the item size (to minimize waste)\n    - The absolute difference between the remaining capacity and the item size (to minimize the number of bins)\n    - A penalty term for bins that are nearly full (to prevent overfilling)\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the ratio of the remaining capacity and the item size\n    ratio = bins_remain_cap / item\n    \n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate a penalty term for bins that are nearly full\n    penalty = np.maximum(0, 1 - (bins_remain_cap / item))\n    \n    # Calculate the priority score as a weighted combination of the factors\n    # Weigh the ratio and difference equally, and give a smaller weight to the penalty term\n    priority_score = (1 / (diff + 1e-9)) * (1 / (ratio + 1e-9)) * (1 - 0.1 * penalty)\n    \n    return priority_score",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 173.9178331268546,
    "mi": 59.21145598574435,
    "token_count": 131.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on a combination of factors:\n    - The ratio of the remaining capacity and the item size (as in v1)\n    - The absolute difference between the remaining capacity of each bin and the item size (as in v1)\n    - The relative remaining capacity of each bin, to prevent overloading of bins\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # calculate the absolute difference between the remaining capacity of each bin and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # calculate the relative remaining capacity of each bin\n    rel_remain_cap = bins_remain_cap / np.sum(bins_remain_cap)\n    \n    # calculate the priority score as a combination of the inverse of the difference and the relative remaining capacity\n    priority_score = (1 / (diff + 1e-9)) * (1 - rel_remain_cap)  # add a small value to avoid division by zero\n    \n    # to further prioritize bins with remaining capacity closest to the item size, we can add a bonus term\n    bonus = np.exp(-((bins_remain_cap - item) / item) ** 2)\n    priority_score *= bonus\n    \n    return priority_score",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 173.9178331268546,
    "mi": 59.21145598574435,
    "token_count": 131.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on a combination of factors:\n    - The ratio of the remaining capacity and the item size (to minimize waste)\n    - The absolute difference between the remaining capacity and the item size (to minimize the number of bins)\n    - A penalty term for bins that are nearly full (to prevent overfilling)\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the ratio of the remaining capacity and the item size\n    ratio = bins_remain_cap / item\n    \n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate a penalty term for bins that are nearly full\n    penalty = np.maximum(0, 1 - (bins_remain_cap / item))\n    \n    # Calculate the priority score as a weighted combination of the ratio and difference\n    priority_score = (1 / (diff + 1e-9)) * np.exp(-penalty) * (1 + 1 / (ratio + 1e-9))\n    \n    return priority_score",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 173.9178331268546,
    "mi": 59.21145598574435,
    "token_count": 131.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on a combination of factors:\n    - The ratio of the remaining capacity to the item size (to minimize waste)\n    - The absolute difference between the remaining capacity and the item size (to minimize the number of bins)\n    - A penalty term for bins that are nearly full (to prevent overfilling)\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # calculate the ratio of the remaining capacity to the item size\n    ratio = bins_remain_cap / item\n    \n    # calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # calculate a penalty term for bins that are nearly full\n    penalty = np.maximum(0, 1 - (bins_remain_cap / item))\n    \n    # calculate the priority score as a weighted sum of the ratio and difference, with a penalty term\n    priority_score = (1 / (diff + 1e-9)) * (1 / (ratio + 1e-9)) * (1 - penalty * 0.5)\n    \n    # add a small bonus for bins that are exactly the right size\n    bonus = np.where(np.isclose(bins_remain_cap, item), 1e6, 0)\n    \n    # return the final priority score\n    return priority_score + bonus",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 173.9178331268546,
    "mi": 59.21145598574435,
    "token_count": 131.0,
    "exec_success": true
  }
]