import numpy as np

def priority_v2(
    item: float, 
    bins_remain_cap: np.ndarray, 
    min_diff: float = 5.648486396687896e-07, 
    min_ratio: float = 6.753507431042158e-07, 
    penalty_weight: float = 0.1440068556190109, 
    exact_fit_weight: float = 1.705403847291516, 
    partial_fit_weight: float = 0.31616218661283046) -> np.ndarray:
    """
    Combines ratio, difference, and penalty for nuanced bin selection.
    """
    # Calculate the ratio of the remaining capacity and the item size
    ratio = bins_remain_cap / item
    
    # Calculate the absolute difference between the remaining capacity and the item size
    diff = np.abs(bins_remain_cap - item)
    
    # Calculate a penalty term for bins that are nearly full
    penalty = np.maximum(0, 1 - (bins_remain_cap / item))
    
    # Calculate the priority score as a weighted combination of the factors
    # Weigh the ratio and difference equally, and give a smaller weight to the penalty term
    priority_score = (1 / (diff + min_diff)) * (1 / (ratio + min_ratio)) * (1 - penalty_weight * penalty)
    
    # Consider exact fit and partial fit for additional prioritization
    remaining_space = bins_remain_cap - item
    exact_fit = np.where(remaining_space == 0, 1.0, 0.0)
    partial_fit = np.where(remaining_space > 0, 0.5, 0.0)
    
    # Combine the priority scores with exact and partial fit considerations
    priority_score += exact_fit_weight * exact_fit + partial_fit_weight * partial_fit
    
    # Ensure invalid bins have a lower priority than others
    invalid_bins = np.where(bins_remain_cap < item, -1.0, 0.0)
    priority_score += invalid_bins
    
    return priority_score
