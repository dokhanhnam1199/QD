```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines ratio, difference, and penalty for nuanced bin selection.
    """
    # Calculate the ratio of the remaining capacity and the item size
    ratio = bins_remain_cap / item
    
    # Calculate the absolute difference between the remaining capacity and the item size
    diff = np.abs(bins_remain_cap - item)
    
    # Calculate a penalty term for bins that are nearly full
    penalty = np.maximum(0, 1 - (bins_remain_cap / item))
    
    # Calculate the priority score as a weighted combination of the factors
    # Weigh the ratio and difference equally, and give a smaller weight to the penalty term
    priority_score = (1 / (diff + 1e-9)) * (1 / (ratio + 1e-9)) * (1 - 0.1 * penalty)
    
    # Consider exact fit and partial fit for additional prioritization
    remaining_space = bins_remain_cap - item
    exact_fit = np.where(remaining_space == 0, 1.0, 0.0)
    partial_fit = np.where(remaining_space > 0, 0.5, 0.0)
    
    # Combine the priority scores with exact and partial fit considerations
    priority_score += 2.0 * exact_fit + 0.5 * partial_fit
    
    # Ensure invalid bins have a lower priority than others
    invalid_bins = np.where(bins_remain_cap < item, -1.0, 0.0)
    priority_score += invalid_bins
    
    return priority_score
```
