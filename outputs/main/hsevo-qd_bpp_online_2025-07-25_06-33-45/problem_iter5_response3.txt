```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines ratio, difference, and penalty for optimal bin selection.
    """
    # Calculate the ratio of the remaining capacity to the item size
    ratio = bins_remain_cap / item
    
    # Calculate the absolute difference between the remaining capacity and the item size
    diff = np.abs(bins_remain_cap - item)
    
    # Calculate a penalty term for bins that are nearly full
    penalty = np.maximum(0, 1 - (bins_remain_cap / item))
    
    # Calculate the priority score as a weighted sum of the ratio and difference, with a penalty term
    priority_score = (1 / (diff + 1e-9)) * (1 / (ratio + 1e-9)) * (1 - penalty * 0.5)
    
    # Add a small bonus for bins that are exactly the right size (exact fit)
    bonus = np.where(np.isclose(bins_remain_cap, item), 1e6, 0)
    
    # Consider the normalized remaining capacities (partial fit)
    normalized_caps = bins_remain_cap / np.sum(bins_remain_cap)
    partial_fit = np.where(bins_remain_cap > item, 0.5 * normalized_caps, 0.0)
    
    # Combine the priority score, bonus, and partial fit
    combined_score = priority_score + bonus + partial_fit
    
    # Avoid using bins that are too small
    invalid_bins = np.where(bins_remain_cap < item, -1.0, 0.0)
    final_score = np.where(combined_score < 0, -1.0, combined_score) + invalid_bins
    
    return final_score
```
