```python
import numpy as np

# Define thresholds
zero_threshold = 1e-6
half_full_threshold = 0.5
large_value = 1e6

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines nuanced calculations from priority_v0 and simplicity of priority_v1.
    """
    # Calculate the difference between the remaining capacity of each bin and the item size
    diff = bins_remain_cap - item
    
    # Create a mask where the item can fit into the bin
    can_fit = diff >= zero_threshold
    
    # Calculate the normalized remaining capacities
    normalized_caps = bins_remain_cap / np.sum(bins_remain_cap)
    
    # Calculate the priority score, combining remaining capacity, item size, and normalized capacities
    priorities = np.where(can_fit, 
                          1 / (1 + np.abs(diff)) * normalized_caps, 
                          np.zeros_like(normalized_caps))
    
    # Add a bonus for exact fit bins and a penalty for nearly full bins
    exact_fit_bonus = np.where(diff == 0, 1.0, 0.0)
    nearly_full_penalty = np.where(can_fit & (bins_remain_cap / (item + bins_remain_cap) > half_full_threshold), 
                                   -large_value, 
                                   0.0)
    
    # Calculate the final priority score
    priorities = priorities + exact_fit_bonus + nearly_full_penalty
    
    return priorities
```
