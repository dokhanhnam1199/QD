def priority_v2(item, bins_remain_cap):
    """{This algorithm prioritizes bins based on a weighted combination of remaining capacity, number of items already in the bin, and the absolute difference between the item size and remaining capacity.}"""
    priority = []
    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            # Initialize priority score
            score = 0.0

            # Weight for remaining capacity (favor bins with more space, but not too much)
            capacity_weight = max(0, 1 - (item / cap))

            # Weight for number of items in bin (assume index represents # items packed, favor fewer items)
            items_weight = 1 / (i + 1)

            # Weight for difference between item size and remaining capacity (smaller difference is better)
            difference_weight = 1 / (abs(cap - item) + 1)

            # Combine weights to create overall score
            score = 0.4 * capacity_weight + 0.3 * items_weight + 0.3 * difference_weight  #Adjust weights as needed

            priority.append(score)
        else:
            priority.append(-1)  # Bin is too small
    return priority
