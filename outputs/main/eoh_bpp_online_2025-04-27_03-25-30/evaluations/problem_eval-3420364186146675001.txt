def priority_v2(item, bins_remain_cap):
    """{This algorithm prioritizes bins by considering a weighted combination of the remaining capacity ratio and a fragmentation penalty, favoring bins with lower remaining capacity ratio and penalizing bins that leave small leftover spaces after packing the item.}"""
    priority = []
    bin_capacity = 100  # Assuming bin capacity is 100

    for cap in bins_remain_cap:
        if cap >= item:
            waste = cap - item
            capacity_ratio = cap / bin_capacity
            
            fragmentation_penalty = 0
            if 5 < waste < 15:
                fragmentation_penalty = 0.2 # Moderate penalty for fragmentation
            elif waste <= 5:
                fragmentation_penalty = 0.4 # Higher penalty for small waste

            priority_score = (1 - capacity_ratio) * 0.6 + (1 - fragmentation_penalty) * 0.4

            priority.append(priority_score)
        else:
            priority.append(-1)
    return priority
