def priority_v2(item, bins_remain_cap):
  """{This algorithm prioritizes bins based on a combination of remaining capacity, fragmentation avoidance, and a penalty for creating small gaps.}"""
  priorities = []
  for cap in bins_remain_cap:
    if cap >= item:
      remaining_cap = cap - item
      # Base priority is inversely proportional to remaining capacity (smaller remaining capacity is better)
      priority = 1.0 / (remaining_cap + 0.0001)

      # Fragmentation avoidance: Penalize bins that will leave very small gaps
      if 0 < remaining_cap < 0.1:  # Assuming bin capacity is normalized to 1
        priority *= 0.5  # Reduce priority if a small gap is created

      # Encourage filling bins: Higher priority if the bin is more full after placing the item
      fill_ratio = item / (1 - remaining_cap + 0.0001)
      priority *= (1 + fill_ratio)
      
      priorities.append(priority)
    else:
      priorities.append(-1)
  return priority
