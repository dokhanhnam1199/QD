[
     {
          "algorithm": "This algorithm assigns a priority to each bin based on the wasted space if the item is placed in it, penalizing bins with excessive or very little wasted space.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm assigns a priority to each bin based on the wasted space if the item is placed in it, penalizing bins with excessive or very little wasted space.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            if waste > 20:  # Penalize excessive waste\n                priority.append(0.1)\n            elif waste < 5: # Penalize very little waste\n                priority.append(0.5)\n            else:\n                priority.append(1 / (waste + 1))\n        else:\n            priority.append(-1)\n    return priority",
          "objective": 3.83925,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on the remaining capacity, favoring bins that can accommodate the item with minimal wasted space, and also considering how evenly filled the bin would be after packing the item.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates a priority score for each bin based on the remaining capacity, favoring bins that can accommodate the item with minimal wasted space, and also considering how evenly filled the bin would be after packing the item.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      waste = cap - item\n      fill_ratio = item / (100-cap+item if (100-cap+item) > 0 else 1) \n      priority_score = (1/(waste + 0.0001)) * fill_ratio  \n    else:\n      priority_score = -1\n    priority.append(priority_score)\n  return priority",
          "objective": 3.87914,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity and fullness, favoring bins that can accommodate the item with minimal waste and are already relatively full.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm prioritizes bins based on a combination of remaining capacity and fullness, favoring bins that can accommodate the item with minimal waste and are already relatively full.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            fullness_ratio = (1 - (cap / 100)) # Assuming bin capacity is 100\n            priority_score = (1 / (waste + 1)) + fullness_ratio\n            priority.append(priority_score)\n        else:\n            priority.append(-1)\n    return priority",
          "objective": 4.04866,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on how well the item fills the bin relative to the bin's capacity, favoring bins that are filled to a high percentage without overflowing.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm prioritizes bins based on how well the item fills the bin relative to the bin's capacity, favoring bins that are filled to a high percentage without overflowing.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            fill_ratio = item / cap\n            if fill_ratio > 0.95:\n                priority.append(1.0) # Highly prioritize almost-full bins\n            elif fill_ratio < 0.5:\n                priority.append(fill_ratio * 0.5)  #Lower prio for small fills\n            else:\n                priority.append(fill_ratio)\n        else:\n            priority.append(-1)\n    return priority",
          "objective": 4.07858,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a combination of remaining capacity and wasted space, prioritizing bins that can accommodate the item without excessive waste.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin based on a combination of remaining capacity and wasted space, prioritizing bins that can accommodate the item without excessive waste.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      wasted_space = cap - item\n      priority_score = cap - wasted_space**2 #Prefer not to have too much wasted space\n    else:\n      priority_score = -1 \n    priority.append(priority_score)\n  return priority",
          "objective": 4.11847,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm assigns a priority to each bin based on how well the item fits, favoring bins with remaining capacity close to the item size and penalizing those with significantly more or less capacity.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm assigns a priority to each bin based on how well the item fits, favoring bins with remaining capacity close to the item size and penalizing those with significantly more or less capacity.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            if waste > item * 0.5:  # Penalize excessive waste\n                priority.append(0.2)\n            elif waste < item * 0.1:  # Penalize very little waste\n                priority.append(0.6)\n            else:\n                priority.append(1 / (abs(waste - item * 0.2) + 1)) # Closer waste to 20% of item, higher priority\n        else:\n            priority.append(-1)\n    return priority",
          "objective": 4.21819,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on the remaining capacity after placing the item, favoring bins that are neither too full nor too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on the remaining capacity after placing the item, favoring bins that are neither too full nor too empty.}\"\"\"\n  priorities = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      remaining_cap = cap - item\n      # Prioritize bins where the remaining capacity is a moderate fraction of the bin size (e.g., around 50%)\n      priority = 1.0 / (abs(remaining_cap - 0.5 * 1) + 0.0001)  # 1 is the bin capacity (normalized)\n      priorities.append(priority)\n    else:\n      priorities.append(-1)  # Assign low priority to bins that cannot fit the item\n  return priority",
          "objective": 4.48744,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm assigns a priority to each bin based on how well the item fits, rewarding bins with remaining capacity slightly larger than the item size and severely penalizing those with significantly more or less capacity.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm assigns a priority to each bin based on how well the item fits, rewarding bins with remaining capacity slightly larger than the item size and severely penalizing those with significantly more or less capacity.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            if waste > item * 0.3:  # Heavily Penalize excessive waste\n                priority.append(0.1)\n            elif waste < 0:  # Penalize negative waste\n                priority.append(-1)\n            else:\n                priority.append(1 / (abs(waste - item * 0.1) + 0.5)) # Closer waste to 10% of item, higher priority\n        else:\n            priority.append(-1)\n    return priority",
          "objective": 4.71679,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on the remaining capacity, prioritizing bins that can accommodate the item while maximizing the fill ratio relative to the bin's original capacity and penalizing bins with very small remaining capacity after packing the item.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates a priority score for each bin based on the remaining capacity, prioritizing bins that can accommodate the item while maximizing the fill ratio relative to the bin's original capacity and penalizing bins with very small remaining capacity after packing the item.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      waste = cap - item\n      fill_ratio = (100-cap+item)/100 \n      small_waste_penalty = 1 / (waste + 0.0001) if waste < 10 else 1\n      priority_score = fill_ratio * small_waste_penalty\n    else:\n      priority_score = -1\n    priority.append(priority_score)\n  return priority",
          "objective": 4.97607,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins by balancing the remaining capacity, fullness, and a penalty for creating small remaining spaces.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins by balancing the remaining capacity, fullness, and a penalty for creating small remaining spaces.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      waste = cap - item\n      fullness = 1 - (cap / 100)\n      penalty = 0\n      if waste < 10:\n        penalty = (10 - waste) / 10  \n      priority_score = fullness + (1 / (waste + 1)) - penalty\n      priority.append(priority_score)\n    else:\n      priority.append(-1)\n  return priority",
          "objective": 4.98604,
          "other_inf": null
     }
]