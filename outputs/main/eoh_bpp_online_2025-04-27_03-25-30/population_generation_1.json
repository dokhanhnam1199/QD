[
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on the remaining capacity, favoring bins that can accommodate the item with minimal wasted space, and also considering how evenly filled the bin would be after packing the item.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates a priority score for each bin based on the remaining capacity, favoring bins that can accommodate the item with minimal wasted space, and also considering how evenly filled the bin would be after packing the item.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      waste = cap - item\n      fill_ratio = item / (100-cap+item if (100-cap+item) > 0 else 1) \n      priority_score = (1/(waste + 0.0001)) * fill_ratio  \n    else:\n      priority_score = -1\n    priority.append(priority_score)\n  return priority",
          "objective": 3.87914,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity and fullness, favoring bins that can accommodate the item with minimal waste and are already relatively full.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm prioritizes bins based on a combination of remaining capacity and fullness, favoring bins that can accommodate the item with minimal waste and are already relatively full.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            fullness_ratio = (1 - (cap / 100)) # Assuming bin capacity is 100\n            priority_score = (1 / (waste + 1)) + fullness_ratio\n            priority.append(priority_score)\n        else:\n            priority.append(-1)\n    return priority",
          "objective": 4.04866,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a combination of remaining capacity and wasted space, prioritizing bins that can accommodate the item without excessive waste.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin based on a combination of remaining capacity and wasted space, prioritizing bins that can accommodate the item without excessive waste.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      wasted_space = cap - item\n      priority_score = cap - wasted_space**2 #Prefer not to have too much wasted space\n    else:\n      priority_score = -1 \n    priority.append(priority_score)\n  return priority",
          "objective": 4.11847,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on the remaining capacity after placing the item, favoring bins that are neither too full nor too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on the remaining capacity after placing the item, favoring bins that are neither too full nor too empty.}\"\"\"\n  priorities = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      remaining_cap = cap - item\n      # Prioritize bins where the remaining capacity is a moderate fraction of the bin size (e.g., around 50%)\n      priority = 1.0 / (abs(remaining_cap - 0.5 * 1) + 0.0001)  # 1 is the bin capacity (normalized)\n      priorities.append(priority)\n    else:\n      priorities.append(-1)  # Assign low priority to bins that cannot fit the item\n  return priority",
          "objective": 4.48744,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on the remaining capacity, prioritizing bins that can accommodate the item while maximizing the fill ratio relative to the bin's original capacity and penalizing bins with very small remaining capacity after packing the item.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates a priority score for each bin based on the remaining capacity, prioritizing bins that can accommodate the item while maximizing the fill ratio relative to the bin's original capacity and penalizing bins with very small remaining capacity after packing the item.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      waste = cap - item\n      fill_ratio = (100-cap+item)/100 \n      small_waste_penalty = 1 / (waste + 0.0001) if waste < 10 else 1\n      priority_score = fill_ratio * small_waste_penalty\n    else:\n      priority_score = -1\n    priority.append(priority_score)\n  return priority",
          "objective": 4.97607,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a combination of remaining capacity and wasted space, penalizing bins with very low remaining capacity more heavily to avoid fragmentation.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin based on a combination of remaining capacity and wasted space, penalizing bins with very low remaining capacity more heavily to avoid fragmentation.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      wasted_space = cap - item\n      if cap < 2 * item:\n        priority_score = cap - (wasted_space)**3\n      else:\n        priority_score = cap - (wasted_space)**2\n    else:\n      priority_score = -1\n    priority.append(priority_score)\n  return priority",
          "objective": 5.1057,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm assigns a priority to each bin based on how well the item fills the remaining capacity, giving higher scores to bins that are filled closest to a target fill ratio after the item is placed.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm assigns a priority to each bin based on how well the item fills the remaining capacity, giving higher scores to bins that are filled closest to a target fill ratio after the item is placed.}\"\"\"\n    priority = []\n    target_fill_ratio = 0.8  # Aim for 80% filled bins\n    for cap in bins_remain_cap:\n        if cap >= item:\n            fill_ratio_after_item = (cap - item) / cap if cap > 0 else 0 #avoid division by zero\n            priority.append(1 - abs(fill_ratio_after_item - (1 - target_fill_ratio)))\n        else:\n            priority.append(-1) # Invalid bin\n    return priority",
          "objective": 6.66135,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm assigns priority based on the bin's proximity to being half-full after placing the item, favoring bins that result in a capacity closest to 50 after the item is added.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm assigns priority based on the bin's proximity to being half-full after placing the item, favoring bins that result in a capacity closest to 50 after the item is added.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            new_cap = cap - item\n            proximity_to_half = abs(new_cap - 50) # Assuming bin capacity is 100\n            priority_score = 100 - proximity_to_half  # Higher score for bins closer to 50\n            priority.append(priority_score)\n        else:\n            priority.append(-1)\n    return priority",
          "objective": 76.42601,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority score for each bin based on a combination of remaining capacity and wasted space if the item is placed in the bin.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates the priority score for each bin based on a combination of remaining capacity and wasted space if the item is placed in the bin.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            wasted_space = cap - item\n            priority_score = cap + (1.0 / (wasted_space + 1e-9))\n            priority.append(priority_score)\n        else:\n            priority.append(-1)  # Assign a low priority if the item doesn't fit\n    return priority",
          "objective": 86.58755,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm assigns a priority to each bin based on the remaining capacity and item size, favoring bins with remaining capacity slightly larger than the item and penalizing bins that are too full or too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm assigns a priority to each bin based on the remaining capacity and item size, favoring bins with remaining capacity slightly larger than the item and penalizing bins that are too full or too empty.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            priority.append(cap - item)\n        else:\n            priority.append(-1)\n\n    return priority",
          "objective": 149.30195,
          "other_inf": null
     }
]