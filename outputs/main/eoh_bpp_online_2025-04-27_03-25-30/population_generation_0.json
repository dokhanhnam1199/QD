[
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on the remaining capacity, favoring bins that can accommodate the item with minimal wasted space, and also considering how evenly filled the bin would be after packing the item.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates a priority score for each bin based on the remaining capacity, favoring bins that can accommodate the item with minimal wasted space, and also considering how evenly filled the bin would be after packing the item.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      waste = cap - item\n      fill_ratio = item / (100-cap+item if (100-cap+item) > 0 else 1) \n      priority_score = (1/(waste + 0.0001)) * fill_ratio  \n    else:\n      priority_score = -1\n    priority.append(priority_score)\n  return priority",
          "objective": 3.87914,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity and fullness, favoring bins that can accommodate the item with minimal waste and are already relatively full.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm prioritizes bins based on a combination of remaining capacity and fullness, favoring bins that can accommodate the item with minimal waste and are already relatively full.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            fullness_ratio = (1 - (cap / 100)) # Assuming bin capacity is 100\n            priority_score = (1 / (waste + 1)) + fullness_ratio\n            priority.append(priority_score)\n        else:\n            priority.append(-1)\n    return priority",
          "objective": 4.04866,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a combination of remaining capacity and wasted space, prioritizing bins that can accommodate the item without excessive waste.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin based on a combination of remaining capacity and wasted space, prioritizing bins that can accommodate the item without excessive waste.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      wasted_space = cap - item\n      priority_score = cap - wasted_space**2 #Prefer not to have too much wasted space\n    else:\n      priority_score = -1 \n    priority.append(priority_score)\n  return priority",
          "objective": 4.11847,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on the remaining capacity after placing the item, favoring bins that are neither too full nor too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on the remaining capacity after placing the item, favoring bins that are neither too full nor too empty.}\"\"\"\n  priorities = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      remaining_cap = cap - item\n      # Prioritize bins where the remaining capacity is a moderate fraction of the bin size (e.g., around 50%)\n      priority = 1.0 / (abs(remaining_cap - 0.5 * 1) + 0.0001)  # 1 is the bin capacity (normalized)\n      priorities.append(priority)\n    else:\n      priorities.append(-1)  # Assign low priority to bins that cannot fit the item\n  return priority",
          "objective": 4.48744,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority score for each bin based on a combination of remaining capacity and wasted space if the item is placed in the bin.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates the priority score for each bin based on a combination of remaining capacity and wasted space if the item is placed in the bin.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            wasted_space = cap - item\n            priority_score = cap + (1.0 / (wasted_space + 1e-9))\n            priority.append(priority_score)\n        else:\n            priority.append(-1)  # Assign a low priority if the item doesn't fit\n    return priority",
          "objective": 86.58755,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm assigns a priority to each bin based on the remaining capacity and item size, favoring bins with remaining capacity slightly larger than the item and penalizing bins that are too full or too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm assigns a priority to each bin based on the remaining capacity and item size, favoring bins with remaining capacity slightly larger than the item and penalizing bins that are too full or too empty.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            priority.append(cap - item)\n        else:\n            priority.append(-1)\n\n    return priority",
          "objective": 149.30195,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity and a penalty for bins that are too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm prioritizes bins based on a combination of remaining capacity and a penalty for bins that are too empty.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            # Basic remaining capacity priority, encouraging fuller bins\n            score = cap - item \n            # Penalty for bins that would become excessively empty after packing. This encourages filling more bins\n            if cap - item > 0.75:  # e.g., 75% empty\n                score -= 0.5\n            priority.append(score)\n        else:\n            priority.append(-1000)  # Assign a very low priority if the item doesn't fit\n\n    return priority",
          "objective": Infinity,
          "other_inf": null
     }
]