```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray,
                epsilon0: float = 0.1,
                reuse_factor: float = 0.1,
                noise_scale: float = 1e-6) -> np.ndarray:
    """
    Compute priority scores for each bin for an online bin‑packing item.

    The priority takes into account:
    * Exact‑fit preference – bins that would leave zero leftover get the
      highest score.
    * Best‑fit principle – among non‑exact fits the bin with the smallest
      remaining capacity after placement is favored.
    * Dynamic exploration – an epsilon‑greedy policy where epsilon decreases
      as the bins become fuller.  This encourages exploration when bins
      have plenty of space and exploitation when the packing is tight.
    * Tie‑breaking noise – a tiny random noise is added to break ties.
    * Reuse penalty – bins that are already partially filled receive a
      small penalty to discourage using heavily occupied bins.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    epsilon0 : float, optional
        Base exploration probability (default 0.1).  The actual exploration
        probability is scaled by how full the bins are.
    reuse_factor : float, optional
        Strength of the reuse penalty (default 0.1).
    noise_scale : float, optional
        Scale of the tiny random noise added when exploiting (default 1e‑6).

    Returns
    -------
    np.ndarray
        Priority scores; higher values mean higher preference.  Bins that
        cannot hold the item receive ``-np.inf``.
    """
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)
    n = bins_remain_cap.size
    if n == 0:
        return np.empty(0, dtype=float)

    max_remain = bins_remain_cap.max()
    avg_remaining = bins_remain_cap.mean()
    # Compute a fill ratio: 0 when bins are empty, 1 when they are full.
    fill_ratio = 0.0
    if max_remain > 0:
        fill_ratio = 1.0 - (avg_remaining / max_remain)
    # Dynamic epsilon: more exploration when bins are loosely filled.
    epsilon = epsilon0 * (1.0 - fill_ratio)
    epsilon = np.clip(epsilon, 0.0, 1.0)

    feasible = bins_remain_cap >= item
    leftover = bins_remain_cap - item

    # Reuse penalty: penalize bins that already have a large used fraction.
    if max_remain > 0:
        used_fraction = (max_remain - bins_remain_cap) / max_remain
    else:
        used_fraction = np.zeros_like(bins_remain_cap)
    penalty = reuse_factor * used_fraction
    # Do not penalize exact‑fit bins – they are the best choice.
    penalty = np.where(leftover > 0, penalty, 0.0)

    base_score = np.where(feasible, -leftover - penalty, -np.inf)

    # Random scores for exploration
    random_score = np.where(feasible, np.random.rand(n), -np.inf)

    # Tiny noise to break ties during exploitation
    noise = np.random.rand(n) * noise_scale

    if np.random.rand() < epsilon:
        priorities = random_score
    else:
        priorities = base_score + noise

    return priorities
```
