```python
import numpy as np
from typing import Optional


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    capacity: Optional[float] = None,
    epsilon: float = 0.05,
    noise_scale: float = 1e-4,
    alpha_fit: float = 12.0,
    target_fit: float = 0.80,
    alpha_waste: float = 12.0,
    waste_target: float = 0.07,
    alpha_used: float = 10.0,
    used_target: float = 0.40,
    temperature: Optional[float] = None,
    rng: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Compute a priority score for each open bin in an online bin‑packing
    setting.

    Parameters
    ----------
    item : float
        Size of the incoming item (must be positive).
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    capacity : float | None, optional
        Fixed bin capacity.  If ``None`` the maximum remaining capacity
        among the current bins is used as an estimate.
    epsilon : float, default 0.05
        Probability of performing ε‑greedy random selection among the
        feasible bins.
    noise_scale : float, default 1e-4
        Uniform noise magnitude added to the raw scores.  The noise_scale
        is damped by ``(1 - fit_ratio)`` so that near‑perfect fits are
        perturbed less.
    alpha_fit, target_fit : float, default 12.0, 0.80
        Sigmoid parameters for the *fit‑ratio* component
        (``item / remaining_capacity``).
    alpha_waste, waste_target : float, default 12.0, 0.07
        Sigmoid parameters for the *waste* component
        (``remaining_capacity - item`` normalised by ``capacity``).
    alpha_used, used_target : float, default 10.0, 0.40
        Sigmoid parameters for the *used‑fraction* component
        (``(capacity - remaining_capacity) / capacity``).
    temperature : float | None, optional
        If provided, the final scores are transformed into a probability
        distribution using a temperature‑scaled softmax.
    rng : np.random.Generator | None, optional
        Random number generator for reproducibility.  If ``None`` a new
        default generator is created.

    Returns
    -------
    np.ndarray
        Priority scores for each bin.  Feasible bins receive a finite
        value (or a probability when ``temperature`` is set); infeasible
        bins receive ``-np.inf``.
    """
    # ------------------------------------------------------------------
    # RNG setup
    # ------------------------------------------------------------------
    if rng is None:
        rng = np.random.default_rng()

    # ------------------------------------------------------------------
    # Input handling & validation
    # ------------------------------------------------------------------
    bins = np.asarray(bins_remain_cap, dtype=np.float64).ravel()
    if bins.ndim != 1:
        raise ValueError("bins_remain_cap must be a one‑dimensional array")
    if item <= 0.0:
        raise ValueError("item size must be positive")
    if not (0.0 <= epsilon <= 1.0):
        raise ValueError("epsilon must be in [0, 1]")
    if noise_scale < 0.0:
        raise ValueError("noise_scale must be non‑negative")
    if temperature is not None and temperature <= 0.0:
        raise ValueError("temperature must be positive when provided")

    # Early exit for an empty bin list
    if bins.size == 0:
        return np.array([], dtype=np.float64)

    # ------------------------------------------------------------------
    # Feasibility mask
    # ------------------------------------------------------------------
    # A bin is feasible if it can accommodate the item.
    feasible = bins >= item
    if not np.any(feasible):
        return np.full_like(bins, -np.inf, dtype=np.float64)

    # ------------------------------------------------------------------
    # Bin capacity (fixed size) handling
    # ------------------------------------------------------------------
    if capacity is None:
        # Estimate from the largest remaining capacity seen so far.
        cap_est = float(bins.max())
        capacity = cap_est if cap_est > 0.0 else 1.0
    else:
        if capacity <= 0.0:
            raise ValueError("capacity must be positive")

    # ------------------------------------------------------------------
    # Component 1 – Fit ratio (item / remaining capacity)
    # ------------------------------------------------------------------
    fit_ratio = np.zeros_like(bins, dtype=np.float64)
    np.divide(item, bins, out=fit_ratio, where=feasible)
    np.clip(fit_ratio, 0.0, 1.0, out=fit_ratio)
    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))
    fit_score[~feasible] = 0.0

    # ------------------------------------------------------------------
    # Component 2.0 – Waste (remaining capacity after placement)
    # ------------------------------------------------------------------
    waste = bins - item
    waste_norm = waste / capacity
    np.clip(waste_norm, 0.0, 1.0, out=waste_norm)
    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))
    waste_score[~feasible] = 0.0

    # ------------------------------------------------------------------
    # Component 3 – Used fraction (how full the bin already is)
    # ------------------------------------------------------------------
    used_fraction = (capacity - bins) / capacity
    np.clip(used_fraction, 0.0, 1.0, out=used_fraction)
    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))
    used_score[~feasible] = 0.0

    # ------------------------------------------------------------------
    # Combine the three components multiplicatively
    # ------------------------------------------------------------------
    priorities = fit_score * waste_score * used_score

    # ------------------------------------------------------------------
    # Add exploration noise, damped by (1 - fit_ratio)
    # ------------------------------------------------------------------
    if noise_scale > 0.0:
        noise_scale = float(noise_scale)  # ensure python float for rng
        noise = rng.uniform(-noise_scale, noise_scale, size=priorities.shape)
        # Dampen noise for bins that already fit well
        noise *= (1.0 - fit_ratio) * feasible
        priorities += noise

    # ------------------------------------------------------------------
    # ε‑greedy random exploration
    # ------------------------------------------------------------------
    if rng.random() < epsilon:
        rand_scores = rng.random(size=priorities.shape)
        rand_scores[~feasible] = -np.inf
        priorities = rand_scores

    # ------------------------------------------------------------------
    # Explicitly mark infeasible bins
    # ------------------------------------------------------------------
    priorities[~feasible] = -np.inf

    # ------------------------------------------------------------------
    # Optional temperature‑scaled softmax → probability distribution
    # ------------------------------------------------------------------
    if temperature is not None:
        feasible_scores = priorities[feasible]
        if feasible_scores.size > 0:
            # Stabilise exponentiation by subtracting the max
            max_score = feasible_scores.max()
            exp_vals = np.exp((feasible_scores - max_score) / temperature)
            probs = exp_vals / exp_vals.sum()
            out = np.full_like(priorities, -np.inf, dtype=np.float64)
            out[feasible] = probs
            priorities = out

    return priorities
```
