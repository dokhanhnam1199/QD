{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n                bins_remain_cap: np.ndarray,\n                *,\n                random_state: Optional[int] = None,\n                epsilon_min: float = 0.05,\n                epsilon_max: float = 0.25) -> np.ndarray:\n    \"\"\"\n    Adaptive priority for online bin packing using a variance\u2011aware sigmoid\n    and epsilon\u2011greedy exploration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    random_state : int or None, optional\n        Seed for reproducibility.\n    epsilon_min, epsilon_max : float, optional\n        Bounds for the exploration probability epsilon.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores; infeasible bins receive -np.inf.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility mask\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Remaining capacity after placing the item\n    leftover = bins_remain_cap - item\n\n    # Statistics on the leftover space of feasible bins\n    lo = leftover[feasible]\n    L = np.max(lo) if lo.size > 0 else 0.0\n    var = np.var(lo)\n    var_norm = var / ((L**2) / 4.0) if L > 0 else 0.0\n    var_norm = np.clip(var_norm, 0.0, 1.0)\n\n    # Temperature / steepness of the sigmoid\n    k_min, k_max = 1.0, 10.0\n    k = k_min + (k_max - k_min) * (1.0 - var_norm)\n\n    # Center of the sigmoid at half of the maximal leftover\n    c = L / 2.0\n\n    # Base score: tighter fits (smaller leftover) get higher scores\n    base = np.zeros_like(bins_remain_cap)\n    base[feasible] = 1.0 / (1.0 + np.exp(k * (leftover[feasible] - c)))\n\n    # Exploration probability (epsilon\u2011greedy)\n    epsilon = epsilon_min + (epsilon_max - epsilon_min) * (1.0 - var_norm)\n    rng = np.random.default_rng(random_state)\n    random_score = rng.random(bins_remain_cap.shape)\n\n    # Combine exploitation and exploration\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    priorities[feasible] = (1.0 - epsilon) * base[feasible] + epsilon * random_score[feasible]\n\n    # Deterministic tie\u2011breaker: very small incremental value\n    priorities += np.arange(bins_remain_cap.size, dtype=np.float64) * 1e-12\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    weight_leftover: float = 1.0,\n    weight_fit: float = 1.0,\n    weight_variance: float = 0.5,\n    temperature: float = 0.1,\n    epsilon: float = 0.05,\n    noise_scale: float = 1e-4,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority (probability) for each currently open bin for an\n    incoming item in the online bin\u2011packing problem.\n\n    The raw score for a feasible bin *i* is a linear combination of three\n    intuitive components:\n\n    * **Leftover capacity** after placement (negative weight; smaller is\n      better).\n    * **Fit ratio** = item / remaining_capacity (positive weight; larger\n      is better).\n    * **Variance penalty** \u2013 variance of the remaining capacities after\n      placement (negative weight; lower variance is better).\n\n    The raw scores are transformed into a probability distribution using\n    a temperature\u2011scaled softmax.  Infeasible bins (remaining capacity <\n    item) receive a priority of ``0``.  Optional \u03b5\u2011greedy exploration and a\n    tiny random noise can be enabled to break ties and encourage\n    exploration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (must be positive).\n    bins_remain_cap : array\u2011like of shape (n_bins,)\n        Remaining capacity of each open bin.\n    weight_leftover : float, default=1.0\n        Linear weight for the leftover\u2011capacity term.\n    weight_fit : float, default=1.0\n        Linear weight for the fit\u2011ratio term.\n    weight_variance : float, default=0.5\n        Linear weight for the variance\u2011penalty term.\n    temperature : float, default=0.1\n        Softmax temperature; lower values make the distribution sharper.\n    epsilon : float, default=0.05\n        Probability of performing \u03b5\u2011greedy exploration (choose a random\n        feasible bin).  Set to ``0`` to disable.\n    noise_scale : float, default=1e-4\n        Scale of uniform random noise added to raw scores before the\n        softmax.  Set to ``0`` to disable.\n\n    Returns\n    -------\n    priorities : ndarray of shape (n_bins,)\n        Probability for selecting each bin.  Infeasible bins have priority\n        ``0``.  If no bin can accommodate the item, all priorities are\n        ``0``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # Input validation and conversion\n    # ------------------------------------------------------------------\n    if item <= 0:\n        raise ValueError(\"Item size must be positive.\")\n    if temperature <= 0:\n        raise ValueError(\"Temperature must be positive.\")\n    bins = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = bins.size\n    if n_bins == 0:\n        return np.array([], dtype=float)\n\n    rng = np.random.default_rng()\n\n    # ------------------------------------------------------------------\n    # Feasibility mask\n    # ------------------------------------------------------------------\n    feasible = bins >= item\n    if not np.any(feasible):\n        # No bin can hold the item \u2013 return zeros\n        return np.zeros_like(bins, dtype=float)\n\n    # ------------------------------------------------------------------\n    # Component calculations (vectorised)\n    # ------------------------------------------------------------------\n    # Leftover capacity after placement\n    leftover = bins - item\n\n    # Fit ratio (item / remaining capacity)\n    fit_ratio = np.empty_like(bins)\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        np.divide(item, bins, out=fit_ratio, where=feasible)\n    fit_ratio[~feasible] = 0.0\n\n    # Variance of remaining capacities after placing the item into each bin\n    total_sum = bins.sum()\n    total_sq = np.square(bins).sum()\n    mean_new = (total_sum - item) / n_bins\n    sq_new = total_sq - 2.0 * item * bins + item ** 2\n    var_after = sq_new / n_bins - mean_new ** 2\n    var_after[~feasible] = 0.0\n\n    # ------------------------------------------------------------------\n    # Linear combination \u2192 raw score\n    # ------------------------------------------------------------------\n    raw_score = (\n        -weight_leftover * leftover\n        + weight_fit * fit_ratio\n        - weight_variance * var_after\n    )\n    raw_score = np.where(feasible, raw_score, -np.inf)\n\n    # ------------------------------------------------------------------\n    # Optional exploration noise\n    # ------------------------------------------------------------------\n    if noise_scale > 0.0:\n        noise = rng.random(n_bins) * noise_scale\n        raw_score[feasible] += noise[feasible]\n\n    # ------------------------------------------------------------------\n    # \u03b5\u2011greedy exploration\n    # ------------------------------------------------------------------\n    if epsilon > 0.0 and rng.random() < epsilon:\n        rand_scores = np.full_like(bins, -np.inf)\n        rand_scores[feasible] = rng.random(np.count_nonzero(feasible))\n        raw_score = rand_scores\n\n    # ------------------------------------------------------------------\n    # Softmax with temperature \u2192 probability distribution\n    # ------------------------------------------------------------------\n    max_feas = raw_score[feasible].max()\n    shifted = (raw_score - max_feas) / temperature\n    exp_vals = np.exp(shifted)\n    exp_vals[~feasible] = 0.0\n    total = exp_vals.sum()\n    if total == 0.0:\n        return np.zeros_like(bins, dtype=float)\n    priorities = exp_vals / total\n    return priorities\n\n[Reflection]\nWeighted sum of leftover, fit, variance; softmax, epsilon, noise; tune weights, temperature, epsilon.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}