```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Almost Full Fit priority function for online Bin Packing.

    The function assigns a high score to bins where the item fits and leaves
    the smallest possible remaining capacity after placement (i.e., the bin
    becomes "almost full"). Bins that cannot accommodate the item receive a
    very low priority.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array with the remaining capacity of each bin.

    Returns:
        np.ndarray: Priority scores (higher = more preferable) for each bin.
    """
    # Compute the capacity that would remain after placing the item in each bin
    remaining_after = bins_remain_cap - item

    # Determine which bins can actually host the item
    can_fit = remaining_after >= 0

    # Small epsilon to avoid division by zero when remaining_after is exactly 0
    eps = np.finfo(bins_remain_cap.dtype).eps

    # Priority for fitting bins:
    #   - Exact fits (remaining_after ≈ 0) receive an extremely high priority.
    #   - Otherwise priority grows as the leftover space shrinks:
    #       priority = 1 / (remaining_after + eps)
    #   This makes bins that would be "almost full" the most attractive.
    # Bins that cannot fit the item get -inf (lowest possible priority).
    exact_fit = np.isclose(remaining_after, 0.0, atol=eps)
    priority = np.where(
        can_fit,
        np.where(
            exact_fit,
            np.inf,                         # perfect fit -> highest possible priority
            1.0 / (remaining_after + eps)   # smaller leftover -> larger priority
        ),
        -np.inf                           # cannot fit -> lowest priority
    )

    # Optional random tie‑breaker to avoid deterministic bias when priorities are equal.
    # This adds a tiny uniform noise only to the bins that are viable.
    # The noise magnitude is far smaller than the smallest possible difference
    # created by the 1/(remaining_after) term.
    tie_break_noise = np.random.uniform(0, eps, size=bins_remain_cap.shape)
    priority = np.where(can_fit, priority + tie_break_noise, priority)

    return priority
```
