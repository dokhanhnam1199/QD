[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nfrom typing import Optional\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    epsilon: float = 0.05,\n    noise_scale: float = 1e-4,\n    alpha_fit: float = 12.0,\n    target_fit: float = 0.80,\n    alpha_waste: float = 12.0,\n    waste_target: float = 0.07,\n    alpha_used: float =0.0,  # placeholder, will be overwritten below\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in the online Bin Packing Problem.\n\n    The function evaluates three sigmoid\u2011based criteria (fit, waste, used\u2011fraction)\n    for each feasible bin, adapts their steepness to the current leftover\n    distribution, adds a small amount of random noise, and optionally performs\n    \u03b5\u2011greedy randomisation. Infeasible bins receive ``-np.inf`` so they are never\n    selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (0 < item \u2264 bin capacity).\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    epsilon : float, optional\n        Probability of replacing the deterministic ranking with a random one\n        (default 0.05).\n    noise_scale : float, optional\n        Scale of uniform additive noise added to deterministic scores\n        (default 1e\u20114).\n    alpha_fit, target_fit : float, optional\n        Steepness and target for the fit\u2011ratio sigmoid.\n    alpha_waste, waste_target : float, optional\n        Steepness and target for the waste sigmoid (smaller waste \u2192 higher score).\n    alpha_used, used_target : float, optional\n        Steepness and target for the used\u2011fraction sigmoid (prefers partially\u2011filled\n        bins).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) with the same shape as\n        ``bins_remain_cap``.  Infeasible bins contain ``-np.inf``.\n    \"\"\"\n    # Convert input to a NumPy array of float64 for reliable arithmetic.\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Edge case: no bins.\n    if caps.size == 0:\n        return np.array([], dtype=np.float64)\n\n    # Initialise all priorities to -inf (infeasible by default).\n    priorities = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # Feasibility mask: bins that can accommodate the item.\n    feasible = caps >= item\n    if not np.any(feasible):\n        return priorities\n\n    # Estimate true bin capacity.\n    # If an empty bin exists its remaining capacity equals the bin capacity.\n    # Otherwise we use the maximum observed remaining capacity as an estimate.\n    eps = 1e-0\n    est_capacity = max(np.max(caps), eps)\n\n    # -----------------------------------------------------------------\n    # Adaptive scaling of sigmoid steepness based on leftover distribution\n    # -----------------------------------------------------------------\n    leftover = caps - item\n    norm_leftover = np.empty_like(caps, dtype=np.float64)\n    norm_leftover[feasible] = leftover[feasible] / caps[feasible]\n    norm_leftover[~feasible] = 0.0\n\n    std = np.std(norm_leftover[feasible])\n    scale = std if std > 1e-6 else 1.0\n\n    # Scale steepness parameters.\n    a_fit = alpha_fit / scale\n    a_waste = alpha_waste / scale\n    a_used = alpha_used / scale\n\n    # -----------------------------------------------------------------\n    # 1) Fit\u2011ratio component (item / remaining capacity)\n    # -----------------------------------------------------------------\n    fit_ratio = np.empty_like(caps, dtype=np.float64)\n    np.divide(item, caps, out=fit_ratio, where=feasible)\n    fit_ratio[~feasible] = 0.0\n    fit_logit = a_fit * (fit_ratio - target_fit)\n    fit_score = 1.0 / (1.0 # placeholder, will be overwritten below\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in the online Bin Packing Problem.\n\n    The function evaluates three sigmoid\u2011based criteria (fit, waste, used\u2011fraction)\n    for each feasible bin, adapts their steepness to the current leftover\n    distribution, adds a small amount of random noise, and optionally performs\n    \u03b5\u2011greedy randomisation. Infeasible bins receive ``-np.inf`` so they are never\n    selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (0 < item \u2264 bin capacity).\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    epsilon : float, optional\n        Probability of replacing the deterministic ranking with a random one\n        (default 0.05).\n    noise_scale : float, optional\n        Scale of uniform additive noise added to deterministic scores\n        (default 1e\u20114).\n    alpha_fit, target_fit : float, optional\n        Steepness and target for the fit\u2011ratio sigmoid.\n    alpha_waste, waste_target : float, optional\n        Steepness and target for the waste sigmoid (smaller waste \u2192 higher score).\n    alpha_used, used_target : float, optional\n        Steepness and target for the used\u2011fraction sigmoid (prefers partially\u2011filled\n        bins).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) with the same shape as\n        ``bins_remain_cap``.  Infeasible bins contain ``-np.inf``.\n    \"\"\"\n    # Convert input to a NumPy array of float64 for reliable arithmetic.\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Edge case: no bins.\n    if caps.size == 0:\n        return np.array([], dtype=np.float64)\n\n    # Initialise all priorities to -inf (infeasible by default).\n    priorities = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # Feasibility mask: bins that can accommodate the item.\n    feasible = caps >= item\n    if not np.any(feasible):\n        return priorities\n\n    # Estimate true bin capacity.\n    # If an empty bin exists its remaining capacity equals the bin capacity.\n    # Otherwise we use the maximum observed remaining capacity as an estimate.\n    eps = 1e-12\n    est_capacity = max(np.max(caps), eps)\n\n    # -----------------------------------------------------------------\n    # Adaptive scaling of sigmoid steepness based on leftover distribution\n    # -----------------------------------------------------------------\n    leftover = caps - item\n    norm_leftover = np.empty_like(caps, dtype=np.float64)\n    norm_leftover[feasible] = leftover[feasible] / caps[feasible]\n    norm_leftover[~feasible] = 0.0\n\n    std = np.std(norm_leftover[feasible])\n    scale = std if std > 1e-6 else 1.0\n\n    # Scale steepness parameters.\n    a_fit = alpha_fit / scale\n    a_waste = alpha_waste / scale\n    a_used = alpha_used / scale\n\n    # -----------------------------------------------------------------\n    # 1) Fit\u2011ratio component (item / remaining capacity)\n    # -----------------------------------------------------------------\n    fit_ratio = np.empty_like(caps, dtype=np.float64)\n    np.divide(item, caps, out=fit_ratio, where=feasible)\n    fit_ratio[~feasible] = 0.0\n    fit_logit = a_fit * (fit_ratio - target_fit)\n    fit_score = 1.0 / (1.0 + np.exp(-np",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 97\n    ) -> np.ndarray:\n      ^^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 97\n    ) -> np.ndarray:\n      ^^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 97\n    ) -> np.ndarray:\n      ^^\nSyntaxError: invalid syntax\n"
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    temperature: float = 1.0,\n    alpha: float = 0.5,\n    fit_weight: float = 1.0,\n) -> np.ndarray:\n    \"\"\"\n    Softmax\u2011based priority for online bin packing.\n\n    The score for each *feasible* bin i combines three criteria:\n        \u2022 leftover capacity after placement (smaller is better)\n        \u2022 fit ratio   = item / remaining_capacity (larger is better)\n        \u2022 variance of the remaining capacities after placement\n          (smaller variance promotes load\u2011balancing)\n\n    The raw score for bin i is\n        s_i = - (remaining_i - item)\n              + fit_weight * (item / remaining_i)\n              - alpha * var_i\n\n    where var_i is the variance of the capacities after hypothetically\n    placing the item into bin i.\n\n    The scores are transformed with a temperature\u2011scaled softmax:\n        priority_i = exp((s_i - max(s)) / temperature)\n                     / \u03a3_j exp((s_j - max(s)) / temperature)\n\n    Infeasible bins (remaining capacity < item) receive priority 0.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n    temperature : float, optional\n        Softmax temperature (>0). Small values make the selection\n        more deterministic; larger values yield a flatter distribution.\n    alpha : float, optional\n        Weight of the variance penalty. Larger values favour a more\n        balanced load across bins.\n    fit_weight : float, optional\n        Weight of the fit\u2011ratio term. Larger values give preference to\n        bins that fit the item tightly.\n\n    Returns\n    -------\n    np.ndarray\n        Priority values for each bin (same shape as ``bins_remain_cap``).\n        The values sum to 1 across feasible bins; infeasible bins have\n        priority 0.\n    \"\"\"\n    # Convert input to a float array and handle empty input\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = bins_remain_cap.size\n    if n_bins == 0:\n        return np.array([], dtype=float)\n\n    if temperature <= 0.0:\n        raise ValueError(\"temperature must be a positive number\")\n\n    # Feasibility mask\n    feasible = bins_remain_cap >= item\n\n    # If no bin can accommodate the item, return all zeros\n    if not feasible.any():\n        return np.zeros_like(bins_remain_cap, dtype=float)\n\n    # --- Component 1: leftover capacity after placement ---\n    leftover = bins_remain_cap - item                     # shape (n_bins,)\n\n    # --- Component 2: fit ratio ---\n    # item / capacity; safe because bins_remain_cap > 0 (feasible implies >= item > 0)\n    fit_ratio = np.empty_like(bins_remain_cap)\n    # Avoid division by zero for zero-capacity bins (should be infeasible anyway)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        fit_ratio[:] = item / bins_remain_cap\n    fit_ratio[~feasible] = 0.0  # irrelevant for infeasible bins\n\n    # --- Component 3: variance after placement ---\n    # Compute total sum and sum of squares once\n    total_sum = bins_remain_cap.sum()\n    total_sq_sum = np.square(bins_remain_cap).sum()\n    new_sum = total_sum - item  # total remaining capacity after placing the item\n\n    # Variance after placing the item into each bin i:\n    # var_i = (total_sq_sum - 2*item*cap_i + item**2) / n_bins - (new_sum / n_bins)**2\n    var_after = (\n        (total_sq_sum - 2.0 * item * bins_remain_cap + item ** 2) / n_bins\n        - (new_sum / n_bins) ** 2\n    )\n    var_after[~feasible] = 0.0  # irrelevant for infeasible bins\n\n    # --- Raw score ---\n    # We want high score for good bins, so combine with signs accordingly\n    raw_score = -leftover + fit_weight * fit_ratio - alpha * var_after\n\n    # Infeasible bins should never be selected: assign -inf before softmax\n    raw_score = np.where(feasible, raw_score, -np.inf)\n\n    # --- Softmax transformation ---\n    # Numerical stability: subtract the max of feasible scores\n    max_feas = raw_score[feasible].max()\n    scaled = (raw_score - max_feas) / temperature\n\n    # Exponentiate; exp(-inf) -> 0 automatically\n    exp_scaled = np.exp(scaled)\n\n    # Normalise to obtain probabilities (priorities)\n    total_exp = exp_scaled[feasible].sum()\n    if total_exp == 0.0:\n        # Edge case: all feasible scores were -inf (should not happen)\n        priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    else:\n        priorities = exp_scaled / total_exp\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 41.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in the online Bin Packing Problem.\n\n    The heuristic normalises the leftover capacity after hypothetically placing the\n    item, then feeds this value into a sigmoid that rewards tight fits.  When\n    ``adaptive`` behaviour is enabled (hard\u2011coded to True), the steepness of the\n    sigmoid is scaled by the standard deviation of the normalised leftovers among\n    feasible bins, allowing the method to react to the current distribution of\n    bin utilizations.  A tiny deterministic tie\u2011breaker proportional to the tightness\n    of the fit ensures a unique selection when scores are otherwise equal.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins (non\u2011negative).\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores with the same shape as ``bins_remain_cap``.\n        Infeasible bins (where the item does not fit) receive ``-np.inf``.\n    \"\"\"\n    # Ensure a NumPy array of floats for safe vectorised operations\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute leftover capacity after (hypothetically) placing the item\n    leftover = caps - item\n\n    # Feasibility mask: True where the item fits\n    feasible = leftover >= 0\n\n    # Initialise all priorities to -inf (infeasible)\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # If no bin can accommodate the item, return early\n    if not np.any(feasible):\n        return priorities\n\n    # Normalised leftover fraction: 0 \u2192 perfect fit, 1 \u2192 empty bin\n    # Guard division by zero (possible only when caps == 0 and item == 0)\n    norm_leftover = np.empty_like(caps, dtype=float)\n    caps_feas = caps[feasible]\n    leftover_feas = leftover[feasible]\n    with np.errstate(divide='ignore', invalid='ignore'):\n        norm_leftover[feasible] = np.where(\n            caps_feas > 0,\n            leftover_feas / caps_feas,\n            0.0\n        )\n    # Infeasible entries are irrelevant; set to zero for completeness\n    norm_leftover[~feasible] = 0.0\n\n    # Adaptive steepness scaling based on variance of normalised leftovers\n    adaptive = True  # hard\u2011coded as per reflection\n    if adaptive:\n        std = np.std(norm_leftover[feasible])\n        scale = std if std > 1e-12 else 1.0  # avoid division by zero\n    else:\n        scale = 1.0\n\n    # Sigmoid parameters (tuned for typical bin\u2011packing ranges)\n    a = 5.0   # offset \u2013 shifts the curve upward\n    b = 10.0  # base steepness \u2013 larger \u2192 sharper drop for looser fits\n\n    # Logits for the sigmoid: larger when norm_leftover is small (tight fit)\n    logits = a - (b / scale) * norm_leftover[feasible]\n\n    # Numerically stable sigmoid using tanh formulation:\n    # sigmoid(x) = 0.5 * (1 + tanh(x/2))\n    scores = 0.5 * (1.0 + np.tanh(logits / 2.0))\n\n    # Deterministic tie\u2011breaker: favour tighter fits (smaller norm_leftover)\n    eps_tie = 1e-8\n    tie = eps_tie * (1.0 - norm_leftover[feasible])\n\n    # Assign final priority scores to feasible bins\n    priorities[feasible] = scores + tie\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 31.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                *,\n                epsilon: float = 0.05,\n                noise_scale: float = 1e-4,\n                alpha_fit: float = 12.0,\n                target_fit: float = 0.80,\n                alpha_waste: float = 12.0,\n                waste_target: float = 0.07,\n                alpha_used: float = 10.0,\n                used_target: float = 0.40) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing based on a multiplicative\n    combination of three sigmoid\u2011based criteria (fit, waste, usage)\n    with adaptive noise and optional \u03b5\u2011greedy exploration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacity in each currently open bin.\n    epsilon : float, optional\n        Probability of choosing a completely random feasible bin.\n    noise_scale : float, optional\n        Base scale of the additive uniform noise.\n    alpha_fit, target_fit : float, optional\n        Sigmoid hyper\u2011parameters for the fit\u2011ratio component.\n    alpha_waste, waste_target : float, optional\n        Sigmoid hyper\u2011parameters for the waste component.\n    alpha_used, used_target : float, optional\n        Sigmoid hyper\u2011parameters for the used\u2011fraction component.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better); infeasible bins receive\n        ``-np.inf``.  The returned array has the same shape as\n        ``bins_remain_cap``.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    est_capacity = float(np.max(bins_remain_cap))\n\n    # Fit\u2011ratio component\n    fit_ratio = np.zeros_like(bins_remain_cap)\n    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)\n    fit_ratio = np.clip(fit_ratio, 0.0, 1.0)\n    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))\n    fit_score[~feasible] = 0.0\n\n    # Waste component\n    waste = bins_remain_cap - item\n    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)\n    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))\n    waste_score[~feasible] = 0.0\n\n    # Used\u2011fraction component\n    used_fraction = (est_capacity - bins_remain_cap) / est_capacity\n    used_fraction[~feasible] = 0.0\n    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))\n    used_score[~feasible] = 0.0\n\n    priorities = fit_score * waste_score * used_score\n\n    rng = np.random.default_rng()\n\n    if noise_scale > 0.0:\n        noise = rng.uniform(-noise_scale, noise_scale, size=bins_remain_cap.shape)\n        noise *= (1.0 - fit_ratio)\n        priorities += noise\n\n    if epsilon > 0.0 and rng.random() < epsilon:\n        random_scores = rng.random(bins_remain_cap.shape)\n        random_scores[~feasible] = -np.inf\n        priorities = random_scores\n\n    priorities[~feasible] = -np.inf\n    return priorities",
    "response_id": 3,
    "obj": 3.9888312724371757,
    "SLOC": 43.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    epsilon: float = 0.05,\n    noise_scale: float = 1e-4,\n    alpha_fit: float = 12.0,\n    target_fit: float = 0.80,\n    alpha_waste: float = 12.0,\n    waste_target: float = 0.07,\n    alpha_used: float = 10.0,\n    used_target: float = 0.40,\n) -> np.ndarray:\n    \"\"\"\n    Multi\u2011sigmoid priority function for online bin packing.\n\n    For each currently open bin the function returns a priority score that\n    combines three independent sigmoid components:\n\n    * **Fit ratio** \u2013 how close the item size is to the remaining capacity.\n      A ratio above *target_fit* is rewarded.\n    * **Waste** \u2013 the leftover free space after the item is placed.\n      Smaller waste is preferred; waste values below *waste_target* are\n      rewarded strongly.\n    * **Used fraction** \u2013 how much of the bin is already occupied.\n      Partially filled bins are favored, encouraging reuse before opening\n      new bins.\n\n    The three scores are multiplied to form the final priority.  A small\n    uniform noise is added to break ties and an \u03b5\u2011greedy policy can replace\n    the deterministic ranking with a random one with probability *epsilon*.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (0 < item \u2264 bin capacity).\n    bins_remain_cap : array_like\n        1\u2011D array of remaining capacities of the currently open bins.\n    epsilon : float, optional\n        Probability of picking a random feasible bin instead of using the\n        computed priorities.\n    noise_scale : float, optional\n        Scale of the additive noise used to break ties.\n    alpha_fit, target_fit, alpha_waste, waste_target,\n    alpha_used, used_target : float, optional\n        Hyper\u2011parameters of the sigmoid transforms.\n    Returns\n    -------\n    np.ndarray\n        Priority scores; higher is better.  Bins that cannot accommodate\n        the item receive ``-np.inf``.\n    \"\"\"\n    # Convert to a NumPy array of float64 for consistency\n    bins = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Handle the empty\u2011bin case immediately\n    if bins.size == 0:\n        return np.array([], dtype=np.float64)\n\n    # Feasibility mask: bins that can hold the item\n    feasible = bins >= item\n    if not np.any(feasible):\n        # No bin can fit the item\n        return np.full_like(bins, -np.inf, dtype=np.float64)\n\n    # Estimate the true bin capacity from the largest remaining capacity\n    # observed.  This is robust when we have no explicit capacity value.\n    est_capacity = float(np.max(bins))\n    if est_capacity <= 0:\n        est_capacity = 1.0  # Fallback to avoid division by zero\n\n    # ---------- 1) Fit\u2011ratio component ----------\n    fit_ratio = np.empty_like(bins)\n    np.divide(item, bins, out=fit_ratio, where=feasible)\n    fit_ratio[~feasible] = 0.0  # dummy value for infeasible bins\n    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))\n\n    # ---------- 2) Waste component ----------\n    waste = bins - item\n    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)  # Normalised waste [0,1]\n    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))\n\n    # ---------- 3) Used\u2011fraction component ----------\n    used_fraction = (est_capacity - bins) / est_capacity\n    used_fraction[~feasible] = 0.0  # dummy for infeasible bins\n    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))\n\n    # ---------- Combine signals ----------\n    combined_score = fit_score * waste_score * used_score\n\n    # ---------- Add exploration noise ----------\n    rng = np.random.default_rng()\n    if noise_scale > 0.0:\n        noise = rng.random(bins.shape) * noise_scale\n        combined_score += noise\n\n    # ---------- \u03b5\u2011greedy exploration ----------\n    if epsilon > 0.0 and rng.random() < epsilon:\n        random_score = rng.random(bins.shape)\n        random_score[~feasible] = -np.inf\n        return random_score\n\n    # Mark infeasible bins explicitly\n    combined_score[~feasible] = -np.inf\n    return combined_score",
    "response_id": 4,
    "obj": 3.9788591942560925,
    "SLOC": 43.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    epsilon: float = 1e-6,\n    exact_fit_bonus: float = 1e9,\n) -> np.ndarray:\n    \"\"\"\n    Deterministic priority function for the online Bin Packing Problem.\n\n    The heuristic prefers bins that will be left with the smallest remaining\n    capacity after the item is placed. Bins that become (almost) perfectly full\n    receive a very large bonus to strongly encourage exact fits. Infeasible\n    bins are assigned ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (0 < item \u2264 bin capacity).\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacities of each currently open bin.\n    epsilon : float, optional\n        Tolerance for treating a leftover as an exact fit (default 1e-6).\n    exact_fit_bonus : float, optional\n        Large positive boost for bins that achieve an exact fit\n        (default 1e9).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) with the same shape as\n        ``bins_remain_cap``. Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Ensure a NumPy array of floats.\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Edge case: no bins.\n    if caps.size == 0:\n        return np.array([], dtype=float)\n\n    # Remaining capacity after hypothetically placing the item.\n    leftover = caps - item\n\n    # Feasibility mask: True where the item fits.\n    feasible = leftover >= 0\n\n    # Initialise all priorities with a heavy penalty for infeasibility.\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # Base priority: the smaller the leftover, the larger the priority.\n    # Using the negative leftover converts a minimisation objective into a\n    # maximisation one.\n    priorities[feasible] = -leftover[feasible]\n\n    # Reward bins that become (almost) perfectly full.\n    exact_fit = feasible & (leftover <= epsilon)\n    priorities[exact_fit] = exact_fit_bonus\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    temperature: float = 1.0,\n    next_item_estimate: float | None = None,\n    weight_fit: float = 1.0,\n    weight_future: float = 1.0,\n    weight_balance: float = 0.5,\n    weight_exact: float = 1.0,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem (BPP).\n\n    The function combines three signals:\n\n    1. **Tight fit** \u2013 a negative score proportional to the leftover capacity.\n       Smaller leftover gives a higher score.\n    2. **Future\u2011item feasibility** \u2013 if an estimate of the next item size is\n       provided, bins that will still be able to accommodate that item after\n       placing the current one receive a bonus.\n    3. **Bin balance** \u2013 bins whose remaining capacity is close to the average\n       remaining capacity get a positive score, encouraging a balanced packing.\n\n    The raw scores are transformed into a probability\u2011like priority vector\n    using a temperature\u2011controlled softmax. Bins that cannot accommodate the\n    current item receive a score of zero.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacities of the bins.\n    temperature : float, optional\n        Positive temperature controlling the softness of the softmax.\n        Smaller values make the selection more deterministic.\n    next_item_estimate : float or None, optional\n        Estimated size of the next item. If given, bins that will still have\n        enough capacity for that next item after placing the current one get\n        a bonus.\n    weight_fit : float, optional\n        Weight for the tight\u2011fit component.\n    weight_future : float, optional\n        Weight for the future\u2011item feasibility component.\n    weight_balance : float, optional\n        Weight for the bin\u2011balance component.\n    weight_exact : float, optional\n        Bonus weight for bins that become exactly empty after placing the\n        current item.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (sum to 1 over feasible bins, zero for infeasible\n        bins).\n    \"\"\"\n    # Normalise input\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64).ravel()\n\n    # Feasibility mask\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=np.float64)\n\n    # Remaining capacity after placing the item\n    leftover = bins_remain_cap - item  # >= 0 for feasible bins\n\n    # 1\ufe0f\u20e3 Tight\u2011fit component: smaller leftover -> higher score\n    fit_score = -leftover * weight_fit\n\n    # 2\ufe0f\u20e3 Future\u2011item feasibility component\n    if next_item_estimate is not None:\n        future_feasibility = (leftover >= next_item_estimate).astype(np.float64)\n        future_score = weight_future * future_feasibility\n    else:\n        future_score = 0.0\n\n    # 3\ufe0f\u20e3 Bin\u2011balance component: prefer capacities close to the average\n    avg_remain = np.mean(bins_remain_cap)\n    balance_score = -np.abs(bins_remain_cap - avg_remain) * weight_balance\n\n    # Combine raw components\n    raw_score = fit_score + future_score + balance_score\n\n    # Exact\u2011fit bonus\n    exact_fit_mask = feasible & (leftover <= 1e-9)\n    raw_score[exact_fit_mask] += weight_exact\n\n    # Infeasible bins: set to -inf so that exp(-inf) = 0\n    raw_score[~feasible] = -np.inf\n\n    # Temperature\u2011controlled softmax\n    eps = 1e-12\n    temp = max(temperature, eps)\n    max_raw = np.max(raw_score)  # finite because at least one feasible bin\n    exp_scores = np.exp((raw_score - max_raw) / temp)\n    sum_exp = np.sum(exp_scores)\n    if sum_exp == 0.0:\n        # All feasible bins were set to -inf due to some numeric issue\n        return np.zeros_like(bins_remain_cap, dtype=np.float64)\n\n    priorities = exp_scores / sum_exp\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 36.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    epsilon: float = 0.05,\n    noise_scale: float = 1e-4,\n    alpha_fit: float = 12.0,\n    target_fit: float = 0.80,\n    alpha_waste: float = 12.0,\n    waste_target: float = 0.07,\n    alpha_used: float = 10.0,\n    used_target: float = 0.40,\n) -> np.ndarray:\n    \"\"\"\n    Multi\u2011sigmoid priority function for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacity of each currently open bin.\n    epsilon : float, optional\n        Probability of replacing the deterministic score with a random ranking.\n    noise_scale : float, optional\n        Scale of the additive uniform noise applied before the \u03b5\u2011greedy decision.\n    alpha_fit, target_fit : float, optional\n        Sigmoid parameters for the fit\u2011ratio component.\n    alpha_waste, waste_target : float, optional\n        Sigmoid parameters for the waste component.\n    alpha_used, used_target : float, optional\n        Sigmoid parameters for the used\u2011fraction component.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.  Infeasible\n        bins receive ``-np.inf``.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Empty array handling\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        # No bin can accommodate the item\n        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Estimate the true bin capacity from the current open bins\n    est_capacity = float(np.max(bins_remain_cap))\n    if est_capacity <= 0:\n        # All bins are full \u2013 impossible to pack\n        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    rng = np.random.default_rng()\n\n    # 1) Fit\u2011ratio component (item size relative to remaining capacity)\n    fit_ratio = np.empty_like(bins_remain_cap, dtype=np.float64)\n    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)\n    fit_ratio[~feasible] = 0.0  # dummy for infeasible bins\n    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))\n\n    # 2) Waste component (leftover capacity after placement)\n    waste_norm = np.clip((bins_remain_cap - item) / est_capacity, 0.0, 1.0)\n    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))\n\n    # 3) Used\u2011fraction component (how much of the bin is already occupied)\n    used_fraction = (est_capacity - bins_remain_cap) / est_capacity\n    # After placement\n    used_fraction_after = np.clip(used_fraction + item / est_capacity, 0.0, 1.0)\n    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction_after - used_target)))\n\n    # Combine the three signals multiplicatively\n    combined_score = fit_score * waste_score * used_score\n    combined_score[~feasible] = -np.inf\n\n    # Add small exploration noise\n    if noise_scale > 0.0:\n        noise = rng.random(bins_remain_cap.shape) * noise_scale\n        combined_score[feasible] += noise[feasible]\n\n    # \u03b5\u2011greedy exploration\n    if epsilon > 0.0 and rng.random() < epsilon:\n        random_score = np.where(feasible, rng.random(bins_remain_cap.shape), -np.inf)\n        combined_score = random_score\n\n    return combined_score",
    "response_id": 7,
    "obj": 4.068607897885915,
    "SLOC": 41.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\nfrom typing import Union\n\ndef priority_v2(item: float, bins_remain_cap: Union[np.ndarray, list, tuple]) -> np.ndarray:\n    \"\"\"\n    Deterministic priority function for the online Bin Packing Problem.\n\n    For each currently open bin we compute a score that rewards:\n      * a tight fit \u2013 the item occupies a large fraction of the free space;\n      * little waste \u2013 the leftover capacity after placement is small.\n\n    Both criteria are transformed by logistic (sigmoid) functions and combined\n    multiplicatively.  Bins that cannot accommodate the item receive ``-np.inf``\n    so they are never selected.  A tiny deterministic tie\u2011breaker favours lower\u2011\n    index bins when scores are otherwise identical.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (0 < item \u2264 bin capacity).\n    bins_remain_remain_cap : array\u2011like\n        1\u2011D array of remaining capacities of each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (higher is better) with the same shape as\n        ``bins_remain_cap``. Infeasible bins are assigned ``-np.inf``.\n    \"\"\"\n    # Convert to NumPy array of float64.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    n_bins = bins_remain_cap.shape[0]\n\n    # Initialise all priorities as infeasible.\n    priorities = np.full(n_bins, -np.inf, dtype=np.float64)\n\n    # No bins \u2192 return empty array.\n    if n_bins == 0:\n        return priorities\n\n    # Feasibility mask.\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities\n\n    # ----------------------------------------------------------------------\n    # 1) Fit\u2011ratio component \u2013 fraction of free space used by the item.\n    # ----------------------------------------------------------------------\n    fit_ratio = np.zeros_like(bins_remain_cap)\n    # Safe division only where feasible.\n    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)\n\n    # Sigmoid for fit ratio (steep transition around target_fit).\n    alpha_fit = 12.0          # steepness\n    target_fit = 0.75         # ratio where score \u2248 0.5\n    # Clamp argument to avoid overflow in exp.\n    fit_arg = -alpha_fit * (fit_ratio - target_fit)\n    fit_arg = np.clip(fit_arg, -700, 700)\n    fit_score = 1.0 / (1.0 + np.exp(fit_arg))\n\n    # ----------------------------------------------------------------------\n    # 2) Waste component \u2013 encourage small leftover space.\n    # ----------------------------------------------------------------------\n    # Estimate true bin capacity.  The largest remaining capacity among open\n    # bins is a good proxy; fall back to ``item`` if all bins are smaller.\n    est_capacity = max(np.max(bins_remain_cap), item)\n\n    waste = bins_remain_cap - item          # may be negative for infeasibles\n    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)  # \u2208 [0,1]\n\n    # Sigmoid for waste (high score when waste \u2264 waste_target).\n    alpha_waste = 10.0\n    waste_arg = alpha_waste * (waste_norm - 0.10)  # waste_target = 0.10\n    waste_arg = np.clip(waste_arg, -700, 700)\n    waste_score = 1.0 / (1.0 + np.exp(waste_arg))\n\n    # ----------------------------------------------------------------------\n    # 3) Combine components multiplicatively.\n    # ----------------------------------------------------------------------\n    combined = fit_score * waste_score\n\n    # Assign combined scores to feasible bins.\n    priorities[feasible] = combined[feasible]\n\n    # ----------------------------------------------------------------------\n    # 4) Deterministic tie\u2011breaker \u2013 favour lower\u2011index bins.\n    # ----------------------------------------------------------------------\n    epsilon = 1e-9\n    indices = np.arange(n_bins, dtype=np.float64)\n    priorities[feasible] -= epsilon * indices[feasible]\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 29.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Deterministic priority for online bin packing.\n\n    The function assigns a higher priority to bins that will be left with\n    less remaining capacity after the item is placed.  Bins that become\n    (almost) perfectly full receive a huge bonus to force an exact fit.\n    Infeasible bins are given a negative infinity priority to exclude\n    them from consideration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacities of the currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        An array of the same shape as ``bins_remain_cap`` containing\n        priority scores.  Higher scores indicate more preferable bins.\n    \"\"\"\n    # Ensure a NumPy array (handles list inputs, etc.)\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute leftover capacity after hypothetically placing the item.\n    leftover = caps - item\n\n    # Feasibility mask: True where the item fits.\n    feasible = leftover >= 0\n\n    # Start with a very low priority for all bins.\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # For feasible bins, use the negative leftover as the base priority\n    # (smaller leftover \u2192 higher priority).\n    priorities[feasible] = -leftover[feasible]\n\n    # Reward bins that become (almost) perfectly full.\n    epsilon = 1e-9                     # tolerance for an \u201cexact\u201d fit\n    exact_fit_bonus = 1e12              # huge positive boost\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=epsilon)\n    priorities[exact_fit] = exact_fit_bonus\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]