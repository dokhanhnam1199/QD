{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n                epsilon0: float = 0.1,\n                reuse_factor: float = 0.1,\n                noise_scale: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin for an online bin\u2011packing item.\n\n    The priority takes into account:\n    * Exact\u2011fit preference \u2013 bins that would leave zero leftover get the\n      highest score.\n    * Best\u2011fit principle \u2013 among non\u2011exact fits the bin with the smallest\n      remaining capacity after placement is favored.\n    * Dynamic exploration \u2013 an epsilon\u2011greedy policy where epsilon decreases\n      as the bins become fuller.  This encourages exploration when bins\n      have plenty of space and exploitation when the packing is tight.\n    * Tie\u2011breaking noise \u2013 a tiny random noise is added to break ties.\n    * Reuse penalty \u2013 bins that are already partially filled receive a\n      small penalty to discourage using heavily occupied bins.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    epsilon0 : float, optional\n        Base exploration probability (default 0.1).  The actual exploration\n        probability is scaled by how full the bins are.\n    reuse_factor : float, optional\n        Strength of the reuse penalty (default 0.1).\n    noise_scale : float, optional\n        Scale of the tiny random noise added when exploiting (default 1e\u20116).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores; higher values mean higher preference.  Bins that\n        cannot hold the item receive ``-np.inf``.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n\n    max_remain = bins_remain_cap.max()\n    avg_remaining = bins_remain_cap.mean()\n    # Compute a fill ratio: 0 when bins are empty, 1 when they are full.\n    fill_ratio = 0.0\n    if max_remain > 0:\n        fill_ratio = 1.0 - (avg_remaining / max_remain)\n    # Dynamic epsilon: more exploration when bins are loosely filled.\n    epsilon = epsilon0 * (1.0 - fill_ratio)\n    epsilon = np.clip(epsilon, 0.0, 1.0)\n\n    feasible = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n\n    # Reuse penalty: penalize bins that already have a large used fraction.\n    if max_remain > 0:\n        used_fraction = (max_remain - bins_remain_cap) / max_remain\n    else:\n        used_fraction = np.zeros_like(bins_remain_cap)\n    penalty = reuse_factor * used_fraction\n    # Do not penalize exact\u2011fit bins \u2013 they are the best choice.\n    penalty = np.where(leftover > 0, penalty, 0.0)\n\n    base_score = np.where(feasible, -leftover - penalty, -np.inf)\n\n    # Random scores for exploration\n    random_score = np.where(feasible, np.random.rand(n), -np.inf)\n\n    # Tiny noise to break ties during exploitation\n    noise = np.random.rand(n) * noise_scale\n\n    if np.random.rand() < epsilon:\n        priorities = random_score\n    else:\n        priorities = base_score + noise\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    epsilon: float = 0.05,\n    noise_scale: float = 1e-4,\n    # sigmoid hyper\u2011parameters\n    alpha_fit: float = 12.0,\n    target_fit: float = 0.80,\n    alpha_waste: float = 12.0,\n    waste_target: float = 0.07,\n    alpha_used: float = 10.0,\n    used_target: float = 0.40,\n) -> np.ndarray:\n    \"\"\"\n    Multi\u2011sigmoid priority function for the online Bin Packing Problem.\n\n    The function evaluates each open bin with three sigmoid\u2011based criteria\n    and multiplies the resulting scores:\n\n    1. **Fit\u2011ratio** \u2013 item size relative to the remaining capacity.\n       A ratio close to ``target_fit`` (default 0.80) yields a score around 0.5;\n       larger ratios (tighter fits) are rewarded.\n\n    2. **Waste** \u2013 leftover capacity after placing the item.\n       Small waste (\u2264 ``waste_target`` of the bin capacity) receives a high score.\n\n    3. **Used\u2011fraction** \u2013 how much of the bin is already occupied.\n       Bins that are already partially filled (\u2248 ``used_target``) are favoured,\n       encouraging the algorithm to fill existing bins before opening new ones.\n\n    Random exploration noise is added to break ties, and an \u03b5\u2011greedy\n    mechanism can replace the deterministic score with a pure random\n    ranking with probability ``epsilon``.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (0 < item \u2264 bin capacity).\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining free capacity of each currently open bin.\n    epsilon : float, optional\n        Probability of choosing a completely random feasible bin (default 0.05).\n    noise_scale : float, optional\n        Scale of the additive uniform noise (default 1e\u20114).  Noise is added\n        after the deterministic score and before the \u03b5\u2011greedy decision.\n    alpha_fit, target_fit, alpha_waste, waste_target, alpha_used, used_target :\n        Hyper\u2011parameters of the sigmoid transforms.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) with the same shape as\n        ``bins_remain_cap``.  Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Ensure a NumPy array of float64.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Edge case: no bins at all.\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n\n    # Initialise all priorities with -inf (infeasible).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Feasibility mask: bins that can accommodate the item.\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        # Nothing fits \u2013 return all -inf.\n        return priorities\n\n    # Estimate the true bin capacity.\n    # When an empty bin exists its remaining capacity equals the capacity.\n    # Otherwise we use the maximum observed remaining capacity as an estimate.\n    eps = 1e-12\n    est_capacity = float(np.max(bins_remain_cap)) if bins_remain_cap.size else 1.0\n    est_capacity = max(est_capacity, eps)\n\n    # --------------------------------------------------------------\n    # 1) Fit\u2011ratio component\n    # --------------------------------------------------------------\n    # Ratio of item size to remaining capacity (only defined for feasible bins).\n    fit_ratio = np.empty_like(bins_remain_cap, dtype=np.float64)\n    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)\n    fit_ratio[~feasible] = 0.0  # dummy value for infeasible bins\n\n    # Sigmoid: high score when fit_ratio > target_fit.\n    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))\n\n    # --------------------------------------------------------------\n    # 2) Waste component\n    # --------------------------------------------------------------\n    waste = bins_remain_cap - item               # may be negative for infeasibles.\n    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)  # normalised waste \u2208 [0,1].\n\n    # Sigmoid decreasing with waste.\n    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))\n\n    # --------------------------------------------------------------\n    # 3) Used\u2011fraction component\n    # --------------------------------------------------------------\n    used_fraction = (est_capacity - bins_remain_cap) / est_capacity\n    used_fraction[~feasible] = 0.0  # dummy for infeasibles\n\n    # Sigmoid rewarding bins that are already partially filled.\n    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))\n\n    # --------------------------------------------------------------\n    # Combine the three signals multiplicatively.\n    # --------------------------------------------------------------\n    combined_score = fit_score * waste_score * used_score\n    priorities[feasible] = combined_score[feasible]\n\n    # --------------------------------------------------------------\n    # Exploration noise (always added before \u03b5\u2011greedy decision).\n    # --------------------------------------------------------------\n    if noise_scale > 0.0:\n        rng = np.random.default_rng()\n        noise = rng.random(bins_remain_cap.shape) * noise_scale\n        priorities[feasible] += noise[feasible]\n\n    # --------------------------------------------------------------\n    # \u03b5\u2011greedy: with probability epsilon replace with a random ranking.\n    # --------------------------------------------------------------\n    if epsilon > 0.0 and np.random.rand() < epsilon:\n        rng = np.random.default_rng()\n        random_score = np.where(feasible, rng.random(bins_remain_cap.shape), -np.inf)\n        priorities = random_score\n\n    return priorities\n\n[Reflection]\nUse sigmoid transforms for fit, waste, usage; combine multiplicatively; add small noise; tune hyper\u2011parameters.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}