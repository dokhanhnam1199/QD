```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority scores for each bin in an online Bin Packing Problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of each bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; higher scores indicate more desirable bins.
    """
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)
    leftover = bins_remain_cap - item
    feasible = leftover >= 0

    # If no bin can accommodate the item, return zeros (caller may open a new bin)
    if not np.any(feasible):
        return np.zeros_like(bins_remain_cap)

    # Normalized leftover: fraction of bin remaining after placing the item
    normalized_leftover = np.where(feasible, leftover / (bins_remain_cap + 1e-12), np.nan)

    # Sigmoid transform with variance‑adapted steepness
    var = np.var(normalized_leftover[feasible]) if np.any(feasible) else 0.0
    base_steepness = 10.0
    steepness = base_steepness / (1.0 + var)
    mu = 0.3  # pivot for the sigmoid
    sigmoid_score = np.where(
        feasible,
        1.0 / (1.0 + np.exp(steepness * (normalized_leftover - mu))),
        0.0,
    )

    # Fit score: tighter fits get higher value
    fit_score = np.where(feasible, 1.0 - normalized_leftover, 0.0)

    # Usage score: fraction of the bin's remaining capacity that will be used
    usage_score = np.where(
        feasible, item / (bins_remain_cap + item + 1e-12), 0.0
    )

    # Combine scores
    alpha_fit = 0.5
    alpha_sig = 0.3
    alpha_use = 0.2
    raw_score = alpha_fit * fit_score + alpha_sig * sigmoid_score + alpha_use * usage_score

    # Exact‑fit bonus
    exact_fit_bonus = 1e6
    raw_score = np.where(
        (feasible) & np.isclose(leftover, 0.0, atol=1e-9),
        raw_score + exact_fit_bonus,
        raw_score,
    )

    # Forecast next item (assume same size as current)
    next_item_estimate = item
    forecast_leftover = leftover - next_item_estimate
    forecast_feasible = forecast_leftover >= 0
    alpha_forecast = 0.2
    forecast_score = np.where(
        forecast_feasible,
        1.0 - (forecast_leftover / (bins_remain_cap + 1e-12)),
        0.0,
    )
    big_penalty = 1e5
    raw_score = np.where(
        feasible,
        np.where(
            forecast_feasible,
            raw_score - alpha_forecast * forecast_score,
            raw_score - big_penalty,
        ),
        raw_score,
    )

    # Convert raw scores to probabilities via softmax (low temperature)
    raw_score = np.where(feasible, raw_score, -np.inf)
    max_raw = np.max(raw_score)
    # Temperature T
    T = 0.1
    exp_shift = np.exp((raw_score - max_raw) / T)
    sum_exp = np.sum(exp_shift)
    probs = np.where(sum_exp > 0, exp_shift / sum_exp, np.zeros_like(exp_shift))

    # Tiny deterministic tie‑breaker
    tie_breaker = np.arange(len(bins_remain_cap), dtype=float) * 1e-9
    probs += tie_breaker

    # ε‑greedy component
    epsilon = 0.15
    rng = np.random.default_rng()
    random_component = rng.random(len(bins_remain_cap))
    # Ensure infeasible bins are not selected via randomness
    random_component = np.where(feasible, random_component, 0.0)

    final_priority = (1.0 - epsilon) * probs + epsilon * random_component

    return final_priority
```
