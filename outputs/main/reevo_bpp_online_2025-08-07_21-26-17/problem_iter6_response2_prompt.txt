{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Compute priority scores for each bin in an online Bin Packing Problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; higher scores indicate more desirable bins.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    leftover = bins_remain_cap - item\n    feasible = leftover >= 0\n\n    # If no bin can accommodate the item, return zeros (caller may open a new bin)\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap)\n\n    # Normalized leftover: fraction of bin remaining after placing the item\n    normalized_leftover = np.where(feasible, leftover / (bins_remain_cap + 1e-12), np.nan)\n\n    # Sigmoid transform with variance\u2011adapted steepness\n    var = np.var(normalized_leftover[feasible]) if np.any(feasible) else 0.0\n    base_steepness = 10.0\n    steepness = base_steepness / (1.0 + var)\n    mu = 0.3  # pivot for the sigmoid\n    sigmoid_score = np.where(\n        feasible,\n        1.0 / (1.0 + np.exp(steepness * (normalized_leftover - mu))),\n        0.0,\n    )\n\n    # Fit score: tighter fits get higher value\n    fit_score = np.where(feasible, 1.0 - normalized_leftover, 0.0)\n\n    # Usage score: fraction of the bin's remaining capacity that will be used\n    usage_score = np.where(\n        feasible, item / (bins_remain_cap + item + 1e-12), 0.0\n    )\n\n    # Combine scores\n    alpha_fit = 0.5\n    alpha_sig = 0.3\n    alpha_use = 0.2\n    raw_score = alpha_fit * fit_score + alpha_sig * sigmoid_score + alpha_use * usage_score\n\n    # Exact\u2011fit bonus\n    exact_fit_bonus = 1e6\n    raw_score = np.where(\n        (feasible) & np.isclose(leftover, 0.0, atol=1e-9),\n        raw_score + exact_fit_bonus,\n        raw_score,\n    )\n\n    # Forecast next item (assume same size as current)\n    next_item_estimate = item\n    forecast_leftover = leftover - next_item_estimate\n    forecast_feasible = forecast_leftover >= 0\n    alpha_forecast = 0.2\n    forecast_score = np.where(\n        forecast_feasible,\n        1.0 - (forecast_leftover / (bins_remain_cap + 1e-12)),\n        0.0,\n    )\n    big_penalty = 1e5\n    raw_score = np.where(\n        feasible,\n        np.where(\n            forecast_feasible,\n            raw_score - alpha_forecast * forecast_score,\n            raw_score - big_penalty,\n        ),\n        raw_score,\n    )\n\n    # Convert raw scores to probabilities via softmax (low temperature)\n    raw_score = np.where(feasible, raw_score, -np.inf)\n    max_raw = np.max(raw_score)\n    # Temperature T\n    T = 0.1\n    exp_shift = np.exp((raw_score - max_raw) / T)\n    sum_exp = np.sum(exp_shift)\n    probs = np.where(sum_exp > 0, exp_shift / sum_exp, np.zeros_like(exp_shift))\n\n    # Tiny deterministic tie\u2011breaker\n    tie_breaker = np.arange(len(bins_remain_cap), dtype=float) * 1e-9\n    probs += tie_breaker\n\n    # \u03b5\u2011greedy component\n    epsilon = 0.15\n    rng = np.random.default_rng()\n    random_component = rng.random(len(bins_remain_cap))\n    # Ensure infeasible bins are not selected via randomness\n    random_component = np.where(feasible, random_component, 0.0)\n\n    final_priority = (1.0 - epsilon) * probs + epsilon * random_component\n\n    return final_priority\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    epsilon: float = 0.05,\n    noise_scale: float = 1e-4,\n    alpha_fit: float = 12.0,\n    target_fit: float = 0.80,\n    alpha_waste: float = 12.0,\n    waste_target: float = 0.07,\n    alpha_used: float = 10.0,\n    used_target: float = 0.40,\n) -> np.ndarray:\n    \"\"\"\n    Multi\u2011sigmoid priority function for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacity of each currently open bin.\n    epsilon : float, optional\n        Probability of replacing the deterministic score with a random ranking.\n    noise_scale : float, optional\n        Scale of the additive uniform noise applied before the \u03b5\u2011greedy decision.\n    alpha_fit, target_fit : float, optional\n        Sigmoid parameters for the fit\u2011ratio component.\n    alpha_waste, waste_target : float, optional\n        Sigmoid parameters for the waste component.\n    alpha_used, used_target : float, optional\n        Sigmoid parameters for the used\u2011fraction component.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.  Infeasible\n        bins receive ``-np.inf``.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Empty array handling\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        # No bin can accommodate the item\n        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Estimate the true bin capacity from the current open bins\n    est_capacity = float(np.max(bins_remain_cap))\n    if est_capacity <= 0:\n        # All bins are full \u2013 impossible to pack\n        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    rng = np.random.default_rng()\n\n    # 1) Fit\u2011ratio component (item size relative to remaining capacity)\n    fit_ratio = np.empty_like(bins_remain_cap, dtype=np.float64)\n    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)\n    fit_ratio[~feasible] = 0.0  # dummy for infeasible bins\n    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))\n\n    # 2) Waste component (leftover capacity after placement)\n    waste_norm = np.clip((bins_remain_cap - item) / est_capacity, 0.0, 1.0)\n    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))\n\n    # 3) Used\u2011fraction component (how much of the bin is already occupied)\n    used_fraction = (est_capacity - bins_remain_cap) / est_capacity\n    # After placement\n    used_fraction_after = np.clip(used_fraction + item / est_capacity, 0.0, 1.0)\n    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction_after - used_target)))\n\n    # Combine the three signals multiplicatively\n    combined_score = fit_score * waste_score * used_score\n    combined_score[~feasible] = -np.inf\n\n    # Add small exploration noise\n    if noise_scale > 0.0:\n        noise = rng.random(bins_remain_cap.shape) * noise_scale\n        combined_score[feasible] += noise[feasible]\n\n    # \u03b5\u2011greedy exploration\n    if epsilon > 0.0 and rng.random() < epsilon:\n        random_score = np.where(feasible, rng.random(bins_remain_cap.shape), -np.inf)\n        combined_score = random_score\n\n    return combined_score\n\n[Reflection]\nUse few well\u2011tuned sigmoid components, static capacity estimate, vectorized ops, low epsilon, avoid softmax, assign -inf to infeasibles.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}