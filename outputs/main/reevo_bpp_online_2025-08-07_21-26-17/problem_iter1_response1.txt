```python
import numpy as np

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Trivial placeholder priority (all zeros)."""
    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)
    return priorities

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Best‑Fit priority for online bin packing.

    For each bin we compute the leftover capacity after placing the item.
    Bins that can accommodate the item receive a higher priority the tighter
    the fit (i.e., the smaller the leftover capacity). Infeasible bins receive
    a priority of -inf to guarantee they are never chosen.

    Tie‑breaking among equally tight bins is performed by adding a vanishingly
    small bias that favors bins with lower indices.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: Array of remaining capacities of existing bins.

    Returns:
        An array of priority scores, one per bin.
    """
    # Ensure floating point arithmetic (necessary for -inf handling)
    caps = bins_remain_cap.astype(np.float64, copy=False)

    # Compute the leftover capacity if the item were placed in each bin
    leftover = caps - item

    # Determine which bins can actually accommodate the item
    feasible = leftover >= 0

    # Base priority: tighter fit (smaller leftover) => larger priority.
    # Use negative leftover so that a smaller leftover yields a higher score.
    base_priority = -leftover

    # Initialise priorities: -inf for infeasible bins, base priority otherwise
    priorities = np.where(feasible, base_priority, -np.inf)

    # Deterministic tie‑breaker: add a minuscule bias based on bin index
    epsilon = 1e-12  # far below any realistic leftover magnitude
    idx = np.arange(caps.shape[0])
    # Larger bias for earlier bins (preferring lower indices on ties)
    tie_bias = epsilon * (caps.shape[0] - idx)
    priorities = np.where(feasible, priorities + tie_bias, priorities)

    return priorities
```
