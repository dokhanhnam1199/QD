```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 0.05) -> np.ndarray:
    """
    Softmax‐Based Fit priority function for the online Bin Packing Problem.

    The function assigns a probability‑like priority to each bin based on how
    tightly the item would fit into the remaining capacity. Bins that cannot
    accommodate the item receive a priority of 0. Among feasible bins,
    ``softmax`` is applied to the negative leftover space (i.e. the tighter
    the fit, the larger the unnormalized score) which yields a smooth,
    temperature‑controlled ranking.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array with the remaining capacity of each bin.
        temperature: Positive scaling factor that controls the sharpness of
                     the softmax. Small values make the selection more
                     deterministic (near‑greedy), larger values promote
                     exploration.

    Returns:
        An array of the same shape as ``bins_remain_cap`` containing priority
        scores that sum to 1 over feasible bins (zeros for infeasible ones).
    """
    # Ensure float dtype for subsequent calculations
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)

    # Feasibility mask: only bins that can hold the item
    feasible = bins_remain_cap >= item

    # Initialise scores with -inf so that infeasible bins get zero after softmax
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    # Compute leftover capacity after placing the item
    leftover = bins_remain_cap - item  # >= 0 for feasible bins

    # Better fit => smaller leftover => larger (less negative) score
    # Using -leftover / temperature mirrors a Boltzmann distribution.
    scores[feasible] = -leftover[feasible] / max(temperature, 1e-12)

    # Numerical stability: subtract the max score before exponentiation
    max_score = np.max(scores)  # will be -inf if no feasible bin
    if np.isneginf(max_score):
        # No bin can accept the item – return a zero vector
        return np.zeros_like(bins_remain_cap, dtype=np.float64)

    exp_scores = np.exp(scores - max_score)

    # Softmax normalization (sum of exponentials over feasible bins)
    priorities = exp_scores / np.sum(exp_scores)

    # Enforce zero for infeasible bins (already zero, but explicit for clarity)
    priorities[~feasible] = 0.0

    return priorities
```
