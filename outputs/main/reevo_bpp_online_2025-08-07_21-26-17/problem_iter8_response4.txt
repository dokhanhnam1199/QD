```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    capacity: float | None = None,
    epsilon: float = 0.05,
    noise_scale: float = 1e-6,
    base_k_fit: float = 12.0,
    base_k_waste: float = 12.0,
    base_k_used: float = 10.0,
    var_max: float = 0.25,
    target_fit: float = 0.80,
    waste_target: float = 0.07,
    used_target: float = 0.40,
    weight_fit: float = 1.0,
    weight_waste: float = 1.0,
    weight_used: float = 1.0,
    exact_fit_bonus: float = 1e6,
) -> np.ndarray:
    """
    Compute a priority score for each open bin in an online bin‑packing
    setting. Higher scores indicate more desirable bins for placing the
    incoming ``item``. Infeasible bins receive ``-np.inf`` so they are
    never selected.

    The function combines three sigmoid‑based components:
    * fit‑ratio (item / bin capacity),
    * waste (remaining capacity after placement),
    * used‑fraction (how full the bin already is).

    The steepness of each sigmoid is adapted to the variance of the
    underlying component over the feasible bins, providing more decisive
    preferences when the data is concentrated.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item ≤ bin capacity).
    bins_remain_cap : array_like
        Remaining capacities of the currently open bins.
    capacity : float, optional
        Bin capacity. If ``None`` it is inferred as the maximum observed
        remaining capacity.
    epsilon : float, optional
        Probability of performing pure exploration (random feasible bin).
    noise_scale : float, optional
        Scale of a small Gaussian perturbation added to break ties.
    base_k_fit, base_k_waste, base_k_used : float, optional
        Base steepness for the three sigmoid components.
    var_max : float, optional
        Maximum variance used for normalising the adaptive steepness.
    target_fit, waste_target, used_target : float, optional
        Target values for the three components; the sigmoid is centred
        around each target.
    weight_fit, weight_waste, weight_used : float, optional
        Exponential weights applied to each component when combining them.
    exact_fit_bonus : float, optional
        Large additive bonus for bins that fit the item exactly.

    Returns
    -------
    np.ndarray
        Priority scores (higher = more desirable). Infeasible bins are
        marked with ``-np.inf``.
    """
    # ----------------------------------------------------------------------
    # Normalise inputs
    # ----------------------------------------------------------------------
    bins = np.asarray(bins_remain_cap, dtype=np.float64)

    if bins.size == 0:
        return np.array([], dtype=np.float64)

    # Feasibility mask
    feasible = (bins >= item) & (bins >= 0.0)

    # Early exit if nothing fits
    if not np.any(feasible):
        return np.full_like(bins, -np.inf, dtype=np.float64)

    # Estimate capacity if not provided
    if capacity is None:
        capacity = float(np.max(bins))
        if capacity <= 0.0:
            capacity = 1.0  # fallback to avoid division by zero

    # ----------------------------------------------------------------------
    # Component 1: Fit ratio (item / bin_capacity)
    # ----------------------------------------------------------------------
    fit_ratio = np.zeros_like(bins)
    np.divide(item, bins, out=fit_ratio, where=feasible)

    var_fit = np.var(fit_ratio[feasible]) if np.any(feasible) else 0.0
    k_fit = base_k_fit * (1.0 - min(var_fit / var_max, 1.0))
    k_fit = max(k_fit, 1e-3)  # avoid zero steepness

    fit_score = 1.0 / (1.0 + np.exp(-k_fit * (fit_ratio - target_fit)))

    # ----------------------------------------------------------------------
    # Component 2: Waste (leftover capacity after placement)
    # ----------------------------------------------------------------------
    leftover = bins - item
    waste_norm = np.clip(leftover / capacity, 0.0, 1.0)

    var_waste = np.var(waste_norm[feasible]) if np.any(feasible) else 0.0
    k_waste = base_k_waste * (1.0 - min(var_waste / var_max, 1.0))
    k_waste = max(k_waste, 1e-3)

    # Want low waste; sigmoid decreasing with waste
    waste_score = 1.0 / (1.0 + np.exp(k_waste * (waste_norm - waste_target)))

    # ----------------------------------------------------------------------
    # Component 3: Used fraction (how full the bin already is)
    # ----------------------------------------------------------------------
    used_frac = (capacity - bins) / capacity

    var_used = np.var(used_frac[feasible]) if np.any(feasible) else 0.0
    k_used = base_k_used * (1.0 - min(var_used / var_max, 1.0))
    k_used = max(k_used, 1e-3)

    used_score = 1.0 / (1.0 + np.exp(-k_used * (used_frac - used_target)))

    # ----------------------------------------------------------------------
    # Combine components
    # ----------------------------------------------------------------------
    combined = (fit_score ** weight_fit) * \
               (waste_score ** weight_waste) * \
               (used_score ** weight_used)

    # Exact‑fit bonus
    exact_fit = feasible & np.isclose(leftover, 0.0, atol=1e-9)
    combined[exact_fit] += exact_fit_bonus

    # Small Gaussian noise for tie‑breaking
    if noise_scale > 0.0:
        rng = np.random.default_rng()
        combined += rng.normal(scale=noise_scale, size=combined.shape)

    # ----------------------------------------------------------------------
    # ε‑greedy exploration
    # ----------------------------------------------------------------------
    if epsilon > 0.0:
        rng = np.random.default_rng()
        if rng.random() < epsilon:
            rand_scores = rng.random(bins.shape)
            rand_scores[~feasible] = -np.inf
            return rand_scores

    # Mask infeasible bins
    combined[~feasible] = -np.inf

    return combined
```
