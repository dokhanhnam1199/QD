```python
import numpy as np
from typing import Optional

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    epsilon: float = 0.02,
    noise_scale: float = 1e-5,
    alpha_fit: float = 10.0,
    target_fit: float = 0.75,
    alpha_waste: float = 12.0,
    waste_target: float = 0.05,
    tie_breaker_scale: float = 1e-12,
    random_state: Optional[int] = None,
) -> np.ndarray:
    """
    Compute a priority score for each open bin in an online bin‑packing
    problem. The bin with the highest score is selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining free capacity of each currently open bin.
    epsilon : float, default 0.02
        Probability of performing ε‑greedy exploration.
    noise_scale : float, default 1e-5
        Scale of uniform additive noise added to each feasible bin's score.
    alpha_fit : float, default 10.0
        Logistic steepness for the *fit‑ratio* component.
    target_fit : float, default 0.75
        Desired fit ratio (item / remaining capacity) where the fit component
        reaches 0.5.
    alpha_waste : float, default 12.0
        Logistic steepness for the *waste* component.
    waste_target : float, default 0.05
        Desired waste fraction (relative to bin capacity) where the waste
        component reaches 0.5.
    tie_breaker_scale : float, default 1e-12
        Small multiplier for bin index to break exact ties deterministically.
    random_state : int or None, default None
        Seed for the internal RNG (useful for reproducibility).

    Returns
    -------
    np.ndarray
        Priority scores (higher = better) for each bin. Infeasible bins receive
        ``-np.inf`` so they will never be selected by ``np.argmax``.
    """
    # Ensure a NumPy array of floats
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)
    n_bins = bins_remain_cap.size
    if n_bins == 0:
        return np.empty(0, dtype=np.float64)

    # Feasibility mask
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    # Estimate bin capacity (assume all bins share the same capacity)
    bin_capacity = float(np.max(bins_remain_cap))
    if bin_capacity <= 0.0:
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    rng = np.random.default_rng(random_state)

    # --- 1) Fit‑ratio component -------------------------------------------
    fit_ratio = np.zeros_like(bins_remain_cap)
    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)

    max_exp = 700.0  # limit to avoid overflow
    exp_fit = np.exp(
        -np.clip(alpha_fit * (fit_ratio - target_fit), -max_exp, max_exp)
    )
    fit_score = 1.0 / (1.0 + exp_fit)

    # --- 2) Waste component -----------------------------------------------
    waste_norm = np.clip((bins_remain_cap - item) / bin_capacity, 0.0, 1.0)
    exp_waste = np.exp(
        np.clip(alpha_waste * (waste_norm - waste_target), -max_exp, max_exp)
    )
    waste_score = 1.0 / (1.0 + exp_waste)

    # --- 3) Combine multiplicatively --------------------------------------
    combined_score = fit_score * waste_score
    combined_score[~feasible] = -np.inf

    # --- 4) Deterministic tie‑breaker ------------------------------------
    combined_score += np.arange(n_bins, dtype=np.float64) * tie_breaker_scale

    # --- 5) Small random noise for stochastic tie‑breaking ----------------
    if noise_scale > 0.0:
        noise = rng.random(n_bins) * noise_scale
        combined_score[feasible] += noise[feasible]

    # --- 6) ε‑greedy exploration -----------------------------------------
    if epsilon > 0.0 and rng.random() < epsilon:
        random_scores = np.full_like(combined_score, -np.inf, dtype=np.float64)
        random_scores[feasible] = rng.random(np.count_nonzero(feasible))
        combined_score = random_scores

    return combined_score
```
