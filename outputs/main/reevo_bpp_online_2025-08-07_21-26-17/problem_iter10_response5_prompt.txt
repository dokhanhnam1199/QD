{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n                bins_remain_cap: np.ndarray,\n                *,\n                random_state: Optional[int] = None,\n                epsilon_min: float = 0.05,\n                epsilon_max: float = 0.25) -> np.ndarray:\n    \"\"\"\n    Adaptive priority for online bin packing using a variance\u2011aware sigmoid\n    and epsilon\u2011greedy exploration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    random_state : int or None, optional\n        Seed for reproducibility.\n    epsilon_min, epsilon_max : float, optional\n        Bounds for the exploration probability epsilon.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores; infeasible bins receive -np.inf.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility mask\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Remaining capacity after placing the item\n    leftover = bins_remain_cap - item\n\n    # Statistics on the leftover space of feasible bins\n    lo = leftover[feasible]\n    L = np.max(lo) if lo.size > 0 else 0.0\n    var = np.var(lo)\n    var_norm = var / ((L**2) / 4.0) if L > 0 else 0.0\n    var_norm = np.clip(var_norm, 0.0, 1.0)\n\n    # Temperature / steepness of the sigmoid\n    k_min, k_max = 1.0, 10.0\n    k = k_min + (k_max - k_min) * (1.0 - var_norm)\n\n    # Center of the sigmoid at half of the maximal leftover\n    c = L / 2.0\n\n    # Base score: tighter fits (smaller leftover) get higher scores\n    base = np.zeros_like(bins_remain_cap)\n    base[feasible] = 1.0 / (1.0 + np.exp(k * (leftover[feasible] - c)))\n\n    # Exploration probability (epsilon\u2011greedy)\n    epsilon = epsilon_min + (epsilon_max - epsilon_min) * (1.0 - var_norm)\n    rng = np.random.default_rng(random_state)\n    random_score = rng.random(bins_remain_cap.shape)\n\n    # Combine exploitation and exploration\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    priorities[feasible] = (1.0 - epsilon) * base[feasible] + epsilon * random_score[feasible]\n\n    # Deterministic tie\u2011breaker: very small incremental value\n    priorities += np.arange(bins_remain_cap.size, dtype=np.float64) * 1e-12\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    capacity: Optional[float] = None,\n    epsilon: float = 0.05,\n    noise_scale: float = 1e-4,\n    alpha_fit: float = 12.0,\n    target_fit: float = 0.80,\n    alpha_waste: float = 12.0,\n    waste_target: float = 0.07,\n    alpha_used: float = 10.0,\n    used_target: float = 0.40,\n    temperature: Optional[float] = None,\n    rng: Optional[np.random.Generator] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each open bin in an online bin\u2011packing\n    setting.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (must be positive).\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    capacity : float | None, optional\n        Fixed bin capacity.  If ``None`` the maximum remaining capacity\n        among the current bins is used as an estimate.\n    epsilon : float, default 0.05\n        Probability of performing \u03b5\u2011greedy random selection among the\n        feasible bins.\n    noise_scale : float, default 1e-4\n        Uniform noise magnitude added to the raw scores.  The noise_scale\n        is damped by ``(1 - fit_ratio)`` so that near\u2011perfect fits are\n        perturbed less.\n    alpha_fit, target_fit : float, default 12.0, 0.80\n        Sigmoid parameters for the *fit\u2011ratio* component\n        (``item / remaining_capacity``).\n    alpha_waste, waste_target : float, default 12.0, 0.07\n        Sigmoid parameters for the *waste* component\n        (``remaining_capacity - item`` normalised by ``capacity``).\n    alpha_used, used_target : float, default 10.0, 0.40\n        Sigmoid parameters for the *used\u2011fraction* component\n        (``(capacity - remaining_capacity) / capacity``).\n    temperature : float | None, optional\n        If provided, the final scores are transformed into a probability\n        distribution using a temperature\u2011scaled softmax.\n    rng : np.random.Generator | None, optional\n        Random number generator for reproducibility.  If ``None`` a new\n        default generator is created.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin.  Feasible bins receive a finite\n        value (or a probability when ``temperature`` is set); infeasible\n        bins receive ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # RNG setup\n    # ------------------------------------------------------------------\n    if rng is None:\n        rng = np.random.default_rng()\n\n    # ------------------------------------------------------------------\n    # Input handling & validation\n    # ------------------------------------------------------------------\n    bins = np.asarray(bins_remain_cap, dtype=np.float64).ravel()\n    if bins.ndim != 1:\n        raise ValueError(\"bins_remain_cap must be a one\u2011dimensional array\")\n    if item <= 0.0:\n        raise ValueError(\"item size must be positive\")\n    if not (0.0 <= epsilon <= 1.0):\n        raise ValueError(\"epsilon must be in [0, 1]\")\n    if noise_scale < 0.0:\n        raise ValueError(\"noise_scale must be non\u2011negative\")\n    if temperature is not None and temperature <= 0.0:\n        raise ValueError(\"temperature must be positive when provided\")\n\n    # Early exit for an empty bin list\n    if bins.size == 0:\n        return np.array([], dtype=np.float64)\n\n    # ------------------------------------------------------------------\n    # Feasibility mask\n    # ------------------------------------------------------------------\n    # A bin is feasible if it can accommodate the item.\n    feasible = bins >= item\n    if not np.any(feasible):\n        return np.full_like(bins, -np.inf, dtype=np.float64)\n\n    # ------------------------------------------------------------------\n    # Bin capacity (fixed size) handling\n    # ------------------------------------------------------------------\n    if capacity is None:\n        # Estimate from the largest remaining capacity seen so far.\n        cap_est = float(bins.max())\n        capacity = cap_est if cap_est > 0.0 else 1.0\n    else:\n        if capacity <= 0.0:\n            raise ValueError(\"capacity must be positive\")\n\n    # ------------------------------------------------------------------\n    # Component 1 \u2013 Fit ratio (item / remaining capacity)\n    # ------------------------------------------------------------------\n    fit_ratio = np.zeros_like(bins, dtype=np.float64)\n    np.divide(item, bins, out=fit_ratio, where=feasible)\n    np.clip(fit_ratio, 0.0, 1.0, out=fit_ratio)\n    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))\n    fit_score[~feasible] = 0.0\n\n    # ------------------------------------------------------------------\n    # Component 2.0 \u2013 Waste (remaining capacity after placement)\n    # ------------------------------------------------------------------\n    waste = bins - item\n    waste_norm = waste / capacity\n    np.clip(waste_norm, 0.0, 1.0, out=waste_norm)\n    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))\n    waste_score[~feasible] = 0.0\n\n    # ------------------------------------------------------------------\n    # Component 3 \u2013 Used fraction (how full the bin already is)\n    # ------------------------------------------------------------------\n    used_fraction = (capacity - bins) / capacity\n    np.clip(used_fraction, 0.0, 1.0, out=used_fraction)\n    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))\n    used_score[~feasible] = 0.0\n\n    # ------------------------------------------------------------------\n    # Combine the three components multiplicatively\n    # ------------------------------------------------------------------\n    priorities = fit_score * waste_score * used_score\n\n    # ------------------------------------------------------------------\n    # Add exploration noise, damped by (1 - fit_ratio)\n    # ------------------------------------------------------------------\n    if noise_scale > 0.0:\n        noise_scale = float(noise_scale)  # ensure python float for rng\n        noise = rng.uniform(-noise_scale, noise_scale, size=priorities.shape)\n        # Dampen noise for bins that already fit well\n        noise *= (1.0 - fit_ratio) * feasible\n        priorities += noise\n\n    # ------------------------------------------------------------------\n    # \u03b5\u2011greedy random exploration\n    # ------------------------------------------------------------------\n    if rng.random() < epsilon:\n        rand_scores = rng.random(size=priorities.shape)\n        rand_scores[~feasible] = -np.inf\n        priorities = rand_scores\n\n    # ------------------------------------------------------------------\n    # Explicitly mark infeasible bins\n    # ------------------------------------------------------------------\n    priorities[~feasible] = -np.inf\n\n    # ------------------------------------------------------------------\n    # Optional temperature\u2011scaled softmax \u2192 probability distribution\n    # ------------------------------------------------------------------\n    if temperature is not None:\n        feasible_scores = priorities[feasible]\n        if feasible_scores.size > 0:\n            # Stabilise exponentiation by subtracting the max\n            max_score = feasible_scores.max()\n            exp_vals = np.exp((feasible_scores - max_score) / temperature)\n            probs = exp_vals / exp_vals.sum()\n            out = np.full_like(priorities, -np.inf, dtype=np.float64)\n            out[feasible] = probs\n            priorities = out\n\n    return priorities\n\n[Reflection]\nWeight fit, waste, usage; tune sigmoid centers; add noise scaled by fit; use \u03b5\u2011greedy; optionally softmax with temperature.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}