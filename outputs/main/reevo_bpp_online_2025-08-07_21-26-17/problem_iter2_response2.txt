```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    epsilon: float = 0.05,
    noise_scale: float = 1e-4,
    # sigmoid hyper‑parameters
    alpha_fit: float = 12.0,
    target_fit: float = 0.80,
    alpha_waste: float = 12.0,
    waste_target: float = 0.07,
    alpha_used: float = 10.0,
    used_target: float = 0.40,
) -> np.ndarray:
    """
    Multi‑sigmoid priority function for the online Bin Packing Problem.

    The function evaluates each open bin with three sigmoid‑based criteria
    and multiplies the resulting scores:

    1. **Fit‑ratio** – item size relative to the remaining capacity.
       A ratio close to ``target_fit`` (default 0.80) yields a score around 0.5;
       larger ratios (tighter fits) are rewarded.

    2. **Waste** – leftover capacity after placing the item.
       Small waste (≤ ``waste_target`` of the bin capacity) receives a high score.

    3. **Used‑fraction** – how much of the bin is already occupied.
       Bins that are already partially filled (≈ ``used_target``) are favoured,
       encouraging the algorithm to fill existing bins before opening new ones.

    Random exploration noise is added to break ties, and an ε‑greedy
    mechanism can replace the deterministic score with a pure random
    ranking with probability ``epsilon``.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item ≤ bin capacity).
    bins_remain_cap : np.ndarray
        1‑D array with the remaining free capacity of each currently open bin.
    epsilon : float, optional
        Probability of choosing a completely random feasible bin (default 0.05).
    noise_scale : float, optional
        Scale of the additive uniform noise (default 1e‑4).  Noise is added
        after the deterministic score and before the ε‑greedy decision.
    alpha_fit, target_fit, alpha_waste, waste_target, alpha_used, used_target :
        Hyper‑parameters of the sigmoid transforms.

    Returns
    -------
    np.ndarray
        Priority scores (higher is better) with the same shape as
        ``bins_remain_cap``.  Infeasible bins receive ``-np.inf``.
    """
    # Ensure a NumPy array of float64.
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)

    # Edge case: no bins at all.
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)

    # Initialise all priorities with -inf (infeasible).
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    # Feasibility mask: bins that can accommodate the item.
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        # Nothing fits – return all -inf.
        return priorities

    # Estimate the true bin capacity.
    # When an empty bin exists its remaining capacity equals the capacity.
    # Otherwise we use the maximum observed remaining capacity as an estimate.
    eps = 1e-12
    est_capacity = float(np.max(bins_remain_cap)) if bins_remain_cap.size else 1.0
    est_capacity = max(est_capacity, eps)

    # --------------------------------------------------------------
    # 1) Fit‑ratio component
    # --------------------------------------------------------------
    # Ratio of item size to remaining capacity (only defined for feasible bins).
    fit_ratio = np.empty_like(bins_remain_cap, dtype=np.float64)
    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)
    fit_ratio[~feasible] = 0.0  # dummy value for infeasible bins

    # Sigmoid: high score when fit_ratio > target_fit.
    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))

    # --------------------------------------------------------------
    # 2) Waste component
    # --------------------------------------------------------------
    waste = bins_remain_cap - item               # may be negative for infeasibles.
    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)  # normalised waste ∈ [0,1].

    # Sigmoid decreasing with waste.
    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))

    # --------------------------------------------------------------
    # 3) Used‑fraction component
    # --------------------------------------------------------------
    used_fraction = (est_capacity - bins_remain_cap) / est_capacity
    used_fraction[~feasible] = 0.0  # dummy for infeasibles

    # Sigmoid rewarding bins that are already partially filled.
    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))

    # --------------------------------------------------------------
    # Combine the three signals multiplicatively.
    # --------------------------------------------------------------
    combined_score = fit_score * waste_score * used_score
    priorities[feasible] = combined_score[feasible]

    # --------------------------------------------------------------
    # Exploration noise (always added before ε‑greedy decision).
    # --------------------------------------------------------------
    if noise_scale > 0.0:
        rng = np.random.default_rng()
        noise = rng.random(bins_remain_cap.shape) * noise_scale
        priorities[feasible] += noise[feasible]

    # --------------------------------------------------------------
    # ε‑greedy: with probability epsilon replace with a random ranking.
    # --------------------------------------------------------------
    if epsilon > 0.0 and np.random.rand() < epsilon:
        rng = np.random.default_rng()
        random_score = np.where(feasible, rng.random(bins_remain_cap.shape), -np.inf)
        priorities = random_score

    return priorities
```
