```python
import numpy as np

# Global RNG to avoid re‑creating it on every call
_GLOBAL_RNG = np.random.default_rng()


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    epsilon: float = 0.02,
    noise_scale: float = 1e-5,
    alpha_fit: float = 12.0,
    target_fit: float = 0.80,
    alpha_waste: float = 12.0,
    waste_target: float = 0.07,
    alpha_used: float = 10.0,
    used_target: float = 0.40,
) -> np.ndarray:
    """
    Compute a priority score for each open bin in an online bin‑packing setting.

    The score combines three sigmoid‑shaped components:
    * **Fit‑ratio** – how close the item size is to the remaining capacity.
    * **Waste** – normalised leftover capacity after placement.
    * **Used fraction** – how much of the bin is already occupied.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item ≤ bin capacity).
    bins_remain_cap : array_like
        1‑D array with the remaining capacities of currently open bins.
    epsilon : float, optional
        Probability of choosing a random feasible bin (ε‑greedy exploration).
    noise_scale : float, optional
        Uniform noise magnitude added to break ties.
    alpha_fit, target_fit, alpha_waste, waste_target,
    alpha_used, used_target : float, optional
        Hyper‑parameters shaping the sigmoid components.

    Returns
    -------
    np.ndarray
        Priority scores (higher is better).  Bins that cannot accommodate the
        item receive ``-np.inf``.
    """
    # --------------------------------------------------------------
    # 1. Normalise input & early exits
    # --------------------------------------------------------------
    bins = np.asarray(bins_remain_cap, dtype=np.float64)

    if bins.size == 0:
        # No open bins – nothing to score
        return np.empty(0, dtype=np.float64)

    feasible = bins >= item
    if not np.any(feasible):
        # No bin can hold the item
        return np.full_like(bins, -np.inf, dtype=np.float64)

    # Estimate true bin capacity from the largest remaining capacity observed.
    # This avoids a hard‑coded capacity and works even if bins are partially filled.
    est_capacity = float(bins[feasible].max())
    if est_capacity <= 0.0:
        # Defensive fallback – should not happen in well‑formed inputs
        est_capacity = 1.0

    # --------------------------------------------------------------
    # 2. Compute component scores (vectorised)
    # --------------------------------------------------------------
    # Fit‑ratio component
    fit_ratio = np.empty_like item= item, bins=bins
    fit_ratio = np.empty_like(bins)
    fit_ratio[feasible] = item / bins[feasible]
    fit_ratio[~feasible] = 0.0  # dummy, will be masked later
    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))

    # Waste component (normalised leftover space)
    waste_norm = np.empty_like(bins)
    waste_norm[feasible] = (bins[feasible] - item) / est_capacity
    waste_norm[~feasible] = 0.0
    waste_norm = np.clip(waste_norm, 0.0, 1.0)
    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))

    # Used‑fraction component (how filled the bin already is)
    used_fraction = (est_capacity - bins) / est_capacity
    used_fraction[~feasible] = 0.0  # dummy for infeasible bins
    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))

    # --------------------------------------------------------------
    # 3. Combine components
    # --------------------------------------------------------------
    combined = fit_score * waste_score * used_score

    # --------------------------------------------------------------
    # 4. Add tiny exploration noise (only to feasible bins)
    # --------------------------------------------------------------
    if noise_scale > 0.0:
        noise = _GLOBAL_RNG.random(bins.shape) * noise_scale
        combined[feasible] += noise[feasible]

    # --------------------------------------------------------------
    # 5. ε‑greedy randomisation (limited to feasible bins)
    # --------------------------------------------------------------
    if epsilon > 0.0 and _GLOBAL_RNG.random() < epsilon:
        rand_scores = _GLOBAL_RNG.random(bins.shape)
        rand_scores[~feasible] = -np.inf
        return rand_scores

    # --------------------------------------------------------------
    # 6. Mask infeasible bins and return
    # --------------------------------------------------------------
    combined[~feasible] = -np.inf
    return combined
```
