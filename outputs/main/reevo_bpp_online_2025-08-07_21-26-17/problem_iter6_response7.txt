```python
import numpy as np

def priority_v2(item: float,
                bins_remain_cap,
                *,
                capacity: float | None = None,
                epsilon: float = 0.05,
                noise_scale: float = 1e-4,
                alpha_fit: float = 12.0,
                target_fit: float = 0.80,
                alpha_waste: float = 12.0,
                waste_target: float = 0.07,
                alpha_used: float = 10.0,
                used_target: float = 0.40,
                weight_fit: float = 1.0,
                weight_waste: float = 1.0,
                weight_used: float = 1.0) -> np.ndarray:
    """
    Compute a priority score for each open bin in online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item ≤ bin capacity).
    bins_remain_cap : array_like
        1‑D array of remaining capacities of the currently open bins.
    capacity : float, optional
        Explicit bin capacity.  If None, it is estimated from the
        maximum remaining capacity observed among open bins.
    epsilon : float, optional
        Probability of selecting a random feasible bin instead of the
        deterministic ranking.
    noise_scale : float, optional
        Standard deviation of a small uniform noise added to the scores
        to break ties.
    alpha_fit, target_fit : float, optional
        Sigmoid parameters for the *fit ratio* component.
    alpha_waste, waste_target : float, optional
        Sigmoid parameters for the *waste* component.
    alpha_used, used_target : float, optional
        Sigmoid parameters for the *used‑fraction* component.
    weight_fit, weight_waste, weight_used : float, optional
        Exponential weights applied to the three components when
        combining them into the final score.

    Returns
    -------
    np.ndarray
        Priority scores; higher is better.  Bins that cannot accommodate
        the item receive ``-np.inf``.
    """
    # Ensure numpy array
    bins = np.asarray(bins_remain_cap, dtype=np.float64)

    if bins.size == 0:
        return np.array([], dtype=np.float64)

    # Feasible bins: capacity must be >= item and non‑negative
    feasible = (bins >= item) & (bins >= 0.0)
    if not np.any(feasible):
        # No bin can fit the item
        return np.full_like(bins, -np.inf, dtype=np.float64)

    # Estimate the bin capacity if not provided
    if capacity is None:
        capacity = float(np.max(bins))
        if capacity <= 0.0:
            capacity = 1.0  # fallback to avoid division by zero

    # 1) Fit‑ratio component
    fit_ratio = np.zeros_like(bins)
    np.divide(item, bins, out=fit_ratio, where=feasible)
    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))

    # 2) Waste component
    waste = bins - item
    waste_norm = np.clip(waste / capacity, 0.0, 1.0)
    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))

    # 3) Used‑fraction component
    used_fraction = (capacity - bins) / capacity
    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))

    # Combine with weighted product
    combined_score = (fit_score ** weight_fit) * \
                     (waste_score ** weight_waste) * \
                     (used_score ** weight_used)

    # Add exploration noise
    rng = np.random.default_rng()
    if noise_scale > 0.0:
        noise = rng.random(bins.shape) * noise_scale
        combined_score += noise

    # ε‑greedy exploration
    if epsilon > 0.0 and rng.random() < epsilon:
        random_score = rng.random(bins.shape)
        random_score[~feasible] = -np.inf
        return random_score

    # Mask infeasible bins
    combined_score[~feasible] = -np.inf
    return combined_score
```
