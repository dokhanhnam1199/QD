```python
import numpy as np
from typing import Optional

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                *,
                random_state: Optional[int] = None,
                epsilon_min: float = 0.05,
                epsilon_max: float = 0.25) -> np.ndarray:
    """
    Adaptive priority for online bin packing using a variance‑aware sigmoid
    and epsilon‑greedy exploration.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    random_state : int or None, optional
        Seed for reproducibility.
    epsilon_min, epsilon_max : float, optional
        Bounds for the exploration probability epsilon.

    Returns
    -------
    np.ndarray
        Priority scores; infeasible bins receive -np.inf.
    """
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)

    # Feasibility mask
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    # Remaining capacity after placing the item
    leftover = bins_remain_cap - item

    # Statistics on the leftover space of feasible bins
    lo = leftover[feasible]
    L = np.max(lo) if lo.size > 0 else 0.0
    var = np.var(lo)
    var_norm = var / ((L**2) / 4.0) if L > 0 else 0.0
    var_norm = np.clip(var_norm, 0.0, 1.0)

    # Temperature / steepness of the sigmoid
    k_min, k_max = 1.0, 10.0
    k = k_min + (k_max - k_min) * (1.0 - var_norm)

    # Center of the sigmoid at half of the maximal leftover
    c = L / 2.0

    # Base score: tighter fits (smaller leftover) get higher scores
    base = np.zeros_like(bins_remain_cap)
    base[feasible] = 1.0 / (1.0 + np.exp(k * (leftover[feasible] - c)))

    # Exploration probability (epsilon‑greedy)
    epsilon = epsilon_min + (epsilon_max - epsilon_min) * (1.0 - var_norm)
    rng = np.random.default_rng(random_state)
    random_score = rng.random(bins_remain_cap.shape)

    # Combine exploitation and exploration
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    priorities[feasible] = (1.0 - epsilon) * base[feasible] + epsilon * random_score[feasible]

    # Deterministic tie‑breaker: very small incremental value
    priorities += np.arange(bins_remain_cap.size, dtype=np.float64) * 1e-12

    return priorities
```
