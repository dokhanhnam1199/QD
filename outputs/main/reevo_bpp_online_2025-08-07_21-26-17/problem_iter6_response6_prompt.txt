{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Deterministic priority for online bin packing.\n\n    The function assigns a higher priority to bins that will be left with\n    less remaining capacity after the item is placed.  Bins that become\n    (almost) perfectly full receive a huge bonus to force an exact fit.\n    Infeasible bins are given a negative infinity priority to exclude\n    them from consideration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacities of the currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        An array of the same shape as ``bins_remain_cap`` containing\n        priority scores.  Higher scores indicate more preferable bins.\n    \"\"\"\n    # Ensure a NumPy array (handles list inputs, etc.)\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute leftover capacity after hypothetically placing the item.\n    leftover = caps - item\n\n    # Feasibility mask: True where the item fits.\n    feasible = leftover >= 0\n\n    # Start with a very low priority for all bins.\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # For feasible bins, use the negative leftover as the base priority\n    # (smaller leftover \u2192 higher priority).\n    priorities[feasible] = -leftover[feasible]\n\n    # Reward bins that become (almost) perfectly full.\n    epsilon = 1e-9                     # tolerance for an \u201cexact\u201d fit\n    exact_fit_bonus = 1e12              # huge positive boost\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=epsilon)\n    priorities[exact_fit] = exact_fit_bonus\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n# Global epsilon controlling the exploration vs. exploitation balance.\n_EPSILON = 0.15  # Typical values: 0.0 (pure greedy) to 1.0 (pure random).\n\n    \"\"\"\n    Compute a priority score for each bin using an epsilon\u2011greedy strategy.\n\n    The function prefers bins that fit the item tightly (exploitation) while\n    preserving a chance of exploring sub\u2011optimal bins (exploration) by blending\n    a random component weighted by epsilon.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; higher scores indicate more desirable bins.\n    \"\"\"\n    # Ensure input is a NumPy array of floats.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item.\n    can_fit = bins_remain_cap >= item\n\n    # --- Exploitation component ------------------------------------------------\n    # Preference for tighter fits: smaller leftover space => larger priority.\n    # Inverse of leftover space is used; a tiny epsilon avoids division by zero.\n    leftover = bins_remain_cap - item\n    base_priority = np.where(\n        can_fit,\n        1.0 / (leftover + 1e-12),\n        0.0\n    )\n\n    # --- Exploration component -------------------------------------------------\n    # Random scores to enable exploration of less obvious bins.\n    rng = np.random.default_rng()\n    random_priority = rng.random(bins_remain_cap.shape)\n\n    # --- Blend the two components -----------------------------------------------\n    # (1 - epsilon) weight for exploitation, epsilon weight for exploration.\n    blended_priority = (1.0 - _EPSILON) * base_priority + _EPSILON * random_priority\n\n    # Bins that cannot fit the item should be assigned zero priority to never be selected.\n    priorities = np.where(can_fit, blended_priority, 0.0)\n\n    return priorities\n\n[Reflection]\nBlend tight-fit bias with adaptive epsilon, scale exact\u2011fit bonuses, penalize waste, and consider limited lookahead.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}