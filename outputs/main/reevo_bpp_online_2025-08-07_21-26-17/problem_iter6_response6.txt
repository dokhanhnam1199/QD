```python
import numpy as np

# Hyperparameters
_BASE_EPSILON = 0.15      # Base exploration weight (0 = pure greedy, 1 = pure random)
_EXACT_FIT_BONUS = 1e4    # Bonus for bins that become exactly full
_WASTE_PENALTY = 0.5      # Penalty per unit of leftover capacity
_LOOKAHEAD_BONUS = 10.0   # Bonus for bins that can still fit another item of the same size

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for each bin for online bin packing.

    The priority combines:
    1. Tight‑fit bias: bins that leave less leftover space after placing the item receive a higher base priority.
    2. Adaptive exploration: the amount of random exploration is scaled by the proportion of bins that can accommodate the item.
    3. Exact‑fit bonus: bins that become exactly full after placement receive a large bonus.
    4. Waste penalty: bins with a larger remaining capacity after placement are penalized proportionally to the waste.
    5. Limited lookahead: a small bonus is added to bins that can still accommodate another item of the same size
       (an approximate lookahead).

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array containing the remaining capacity of each bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; the bin with the highest score will be selected to place the item.
    """
    # Ensure a NumPy array and compute basic variables
    caps = np.asarray(bins_remain_cap, dtype=float)
    n_bins = caps.size
    feasible = caps >= item

    # Compute leftover capacity if the item is placed
    eps = 1e-12
    leftover = caps - item

    # Base priority: tighter fit => higher priority
    base_priority = np.full_like(caps, -np.inf, dtype=float)
    base_priority[feasible] = 1.0 / (leftover[feasible] + eps)

    # Adaptive exploration weight based on the fraction of feasible bins
    feasible_count = np.count_nonzero(feasible)
    exploration_weight = min(1.0, _BASE_EPSILON * feasible_count / n_bins) if n_bins > 0 else 0.0

    # Random exploration component
    rng = np.random.default_rng()
    random_component = rng.random(n_bins)

    # Blend exploitation and exploration
    priority = (1.0 - exploration_weight) * base_priority + exploration_weight * random_component

    # Exact‑fit bonus
    exact_fit = feasible & np.isclose(leftover, 0.0, atol=eps)
    priority[exact_fit] += _EXACT_FIT_BONUS

    # Waste penalty (only for feasible bins)
    priority[feasible] -= _WASTE_PENALTY * leftover[feasible]

    # Limited lookahead: bonus for bins that can still fit another item of the same size
    leftover_next = leftover - item  # space after placing another similar item
    can_fit_next = leftover_next >= 0
    priority[can_fit_next] += _LOOKAHEAD_BONUS

    # Ensure infeasible bins have very low priority
    priority[~feasible] = -np.inf

    return priority
```
