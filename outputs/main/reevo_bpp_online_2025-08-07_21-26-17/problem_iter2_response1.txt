```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute deterministic priority scores for an online bin‑packing decision.

    The heuristic prefers bins that will be left with the smallest remaining
    capacity after the item is placed. Bins that become (almost) perfectly full
    receive a huge bonus to encourage exact fits. Infeasible bins are assigned
    a very low (negative‑infinite) priority, effectively removing them from
    consideration.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of each currently open bin.

    Returns
    -------
    np.ndarray
        An array of the same shape as ``bins_remain_cap`` containing priority
        scores. Higher scores indicate a more preferred bin.
    """
    # Ensure a NumPy float array (handles list inputs, etc.).
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Remaining capacity after hypothetically placing the item.
    leftover = caps - item

    # Feasibility mask: True where the item fits.
    feasible = leftover >= 0

    # Initialise all priorities to a very low value (heavy penalty for infeasibility).
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Base priority: the smaller the leftover, the larger the priority.
    # Using the negative leftover converts a minimisation objective into a
    # maximisation one.
    priorities[feasible] = -leftover[feasible]

    # Reward bins that become (almost) perfectly full.
    epsilon = 1e-6                # tolerance for an “exact” fit
    exact_fit_bonus = 1e9         # large positive boost
    exact_fit = feasible & (leftover <= epsilon)
    priorities[exact_fit] = exact_fit_bonus

    return priorities
```
