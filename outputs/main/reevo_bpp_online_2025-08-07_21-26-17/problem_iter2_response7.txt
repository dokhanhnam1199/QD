```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    temperature: float = 1.0,
    fit_weight: float = 0.5,
    randomness: float = 1e-4,
) -> np.ndarray:
    """
    Priority function for online bin packing that blends leftover minimization
    with a softmax temperature, includes fit ratio weighting, and adds
    tie-breaking randomness.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the current free capacity in each bin.
    temperature : float, optional
        Temperature parameter for the softmax term. A small value
        concentrates the probability mass on bins with the smallest
        leftover, while a large value yields a more uniform distribution.
        Must be positive.
    fit_weight : float, optional
        Exponent applied to the fit ratio (item / remaining capacity)
        to weight bins where the item fits well relative to the remaining
        space.  Default is 0.5.
    randomness : float, optional
        Scale of the tie‑breaking random noise added to each score.
        Small values preserve the ordering induced by the deterministic
        part of the score. Default is 1e-4.

    Returns
    -------
    np.ndarray
        Array of priority scores, same shape as ``bins_remain_cap``.
        Bins that cannot accommodate ``item`` receive a score of
        ``-np.inf`` and will never be selected.

    Notes
    -----
    The priority score is computed as

        score = exp(-leftover / temperature) * (fit_ratio ** fit_weight)

    where

        leftover  = bins_remain_cap - item  (for feasible bins)
        fit_ratio = item / bins_remain_cap

    A small random perturbation is added to ``score`` to break ties
    deterministically.  The function is vectorised for efficiency.
    """
    # Ensure we work with a float array
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Empty array handling
    if bins_remain_cap.size == 0:
        return np.full_like(bins_remain_cap, -np.inf, dtype=float)

    if temperature <= 0.0:
        raise ValueError("temperature must be a positive number")

    # Identify bins that can accept the item
    feasible = bins_remain_cap >= item

    # Initialize all priorities to -inf (infeasible bins)
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    if not feasible.any():
        # No bin can accommodate the item; return -inf for all bins
        return priorities

    # Compute leftover and fit ratio only for feasible bins
    leftover = bins_remain_cap[feasible] - item
    fit_ratio = item / bins_remain_cap[feasible]

    # Compute the deterministic part of the score
    deterministic_score = np.exp(-leftover / temperature) * (fit_ratio ** fit_weight)

    # Add tiny random noise for tie-breaking
    noise = np.random.uniform(-randomness, randomness, size=deterministic_score.shape)

    scores = deterministic_score + noise

    # Assign scores to feasible bins
    priorities[feasible] = scores

    return priorities
```
