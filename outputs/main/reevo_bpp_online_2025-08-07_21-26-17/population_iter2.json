[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    a: float = 5.0,\n    b: float = 10.0,\n    adaptive: bool = True,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin for the online Bin Packing Problem.\n\n    The priority is based on a sigmoid of the *normalized leftover* after\n    hypothetically placing the item in each bin.  A tight fit (small leftover)\n    yields a high score, while a loose fit yields a lower score.  Infeasible\n    bins (where the item does not fit) receive ``-np.inf`` so they are never\n    selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins (non\u2011negative).\n    a : float, optional\n        Offset of the sigmoid.  Larger ``a`` shifts the curve upward,\n        increasing scores overall. Default is 5.0.\n    b : float, optional\n        Base steepness of the sigmoid.  Larger ``b`` makes the score drop\n        faster as the leftover fraction grows. Default is 10.0.\n    adaptive : bool, optional\n        If ``True``, the steepness ``b`` is scaled by the standard deviation of\n        the normalized leftovers among feasible bins.  This makes the heuristic\n        adapt to the current distribution of bin utilizations.  If ``False``,\n        the raw ``b`` is used.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores with the same shape as ``bins_remain_cap``.\n        Feasible bins have finite scores; infeasible bins have ``-np.inf``.\n    \"\"\"\n    # Ensure a NumPy array of floats for safe arithmetic\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute leftover capacity after placing the item\n    leftover = caps - item\n\n    # Determine which bins can accommodate the item\n    feasible = leftover >= 0\n\n    # Initialise all priorities to -inf (infeasible)\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No bin can accept the item \u2013 return all -inf\n        return priorities\n\n    # Normalized leftover fraction: 0 \u2192 perfect fit, 1 \u2192 empty bin\n    norm_leftover = np.empty_like(caps, dtype=float)\n    # Avoid division by zero (should not occur for feasible bins with cap>0)\n    norm_leftover[feasible] = leftover[feasible] / caps[feasible]\n    # For completeness set zero for infeasible entries (won't be used)\n    norm_leftover[~feasible] = 0.0\n\n    # Adaptive scaling of steepness (optional)\n    if adaptive:\n        # Compute standard deviation of normalized leftovers among feasible bins\n        std = np.std(norm_leftover[feasible])\n        # Guard against zero std (all leftovers identical) \u2192 use 1.0 scaling\n        scale = std if std > 1e-6 else 1.0\n    else:\n        scale = 1.0\n\n    # Sigmoid logits: high when norm_leftover is small (tight fit)\n    logits = a - (b / scale) * norm_leftover[feasible]\n\n    # Logistic function (sigmoid) producing values in (0, 1)\n    scores = 1.0 / (1.0 + np.exp(-logits))\n\n    # Assign computed scores to feasible bins\n    priorities[feasible] = scores\n\n    return priorities",
    "response_id": 0,
    "obj": 4.0885520542481055,
    "SLOC": 25.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute deterministic priority scores for an online bin\u2011packing decision.\n\n    The heuristic prefers bins that will be left with the smallest remaining\n    capacity after the item is placed. Bins that become (almost) perfectly full\n    receive a huge bonus to encourage exact fits. Infeasible bins are assigned\n    a very low (negative\u2011infinite) priority, effectively removing them from\n    consideration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacities of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        An array of the same shape as ``bins_remain_cap`` containing priority\n        scores. Higher scores indicate a more preferred bin.\n    \"\"\"\n    # Ensure a NumPy float array (handles list inputs, etc.).\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Remaining capacity after hypothetically placing the item.\n    leftover = caps - item\n\n    # Feasibility mask: True where the item fits.\n    feasible = leftover >= 0\n\n    # Initialise all priorities to a very low value (heavy penalty for infeasibility).\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # Base priority: the smaller the leftover, the larger the priority.\n    # Using the negative leftover converts a minimisation objective into a\n    # maximisation one.\n    priorities[feasible] = -leftover[feasible]\n\n    # Reward bins that become (almost) perfectly full.\n    epsilon = 1e-6                # tolerance for an \u201cexact\u201d fit\n    exact_fit_bonus = 1e9         # large positive boost\n    exact_fit = feasible & (leftover <= epsilon)\n    priorities[exact_fit] = exact_fit_bonus\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    epsilon: float = 0.05,\n    noise_scale: float = 1e-4,\n    # sigmoid hyper\u2011parameters\n    alpha_fit: float = 12.0,\n    target_fit: float = 0.80,\n    alpha_waste: float = 12.0,\n    waste_target: float = 0.07,\n    alpha_used: float = 10.0,\n    used_target: float = 0.40,\n) -> np.ndarray:\n    \"\"\"\n    Multi\u2011sigmoid priority function for the online Bin Packing Problem.\n\n    The function evaluates each open bin with three sigmoid\u2011based criteria\n    and multiplies the resulting scores:\n\n    1. **Fit\u2011ratio** \u2013 item size relative to the remaining capacity.\n       A ratio close to ``target_fit`` (default 0.80) yields a score around 0.5;\n       larger ratios (tighter fits) are rewarded.\n\n    2. **Waste** \u2013 leftover capacity after placing the item.\n       Small waste (\u2264 ``waste_target`` of the bin capacity) receives a high score.\n\n    3. **Used\u2011fraction** \u2013 how much of the bin is already occupied.\n       Bins that are already partially filled (\u2248 ``used_target``) are favoured,\n       encouraging the algorithm to fill existing bins before opening new ones.\n\n    Random exploration noise is added to break ties, and an \u03b5\u2011greedy\n    mechanism can replace the deterministic score with a pure random\n    ranking with probability ``epsilon``.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (0 < item \u2264 bin capacity).\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining free capacity of each currently open bin.\n    epsilon : float, optional\n        Probability of choosing a completely random feasible bin (default 0.05).\n    noise_scale : float, optional\n        Scale of the additive uniform noise (default 1e\u20114).  Noise is added\n        after the deterministic score and before the \u03b5\u2011greedy decision.\n    alpha_fit, target_fit, alpha_waste, waste_target, alpha_used, used_target :\n        Hyper\u2011parameters of the sigmoid transforms.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) with the same shape as\n        ``bins_remain_cap``.  Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Ensure a NumPy array of float64.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Edge case: no bins at all.\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n\n    # Initialise all priorities with -inf (infeasible).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Feasibility mask: bins that can accommodate the item.\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        # Nothing fits \u2013 return all -inf.\n        return priorities\n\n    # Estimate the true bin capacity.\n    # When an empty bin exists its remaining capacity equals the capacity.\n    # Otherwise we use the maximum observed remaining capacity as an estimate.\n    eps = 1e-12\n    est_capacity = float(np.max(bins_remain_cap)) if bins_remain_cap.size else 1.0\n    est_capacity = max(est_capacity, eps)\n\n    # --------------------------------------------------------------\n    # 1) Fit\u2011ratio component\n    # --------------------------------------------------------------\n    # Ratio of item size to remaining capacity (only defined for feasible bins).\n    fit_ratio = np.empty_like(bins_remain_cap, dtype=np.float64)\n    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)\n    fit_ratio[~feasible] = 0.0  # dummy value for infeasible bins\n\n    # Sigmoid: high score when fit_ratio > target_fit.\n    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))\n\n    # --------------------------------------------------------------\n    # 2) Waste component\n    # --------------------------------------------------------------\n    waste = bins_remain_cap - item               # may be negative for infeasibles.\n    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)  # normalised waste \u2208 [0,1].\n\n    # Sigmoid decreasing with waste.\n    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))\n\n    # --------------------------------------------------------------\n    # 3) Used\u2011fraction component\n    # --------------------------------------------------------------\n    used_fraction = (est_capacity - bins_remain_cap) / est_capacity\n    used_fraction[~feasible] = 0.0  # dummy for infeasibles\n\n    # Sigmoid rewarding bins that are already partially filled.\n    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))\n\n    # --------------------------------------------------------------\n    # Combine the three signals multiplicatively.\n    # --------------------------------------------------------------\n    combined_score = fit_score * waste_score * used_score\n    priorities[feasible] = combined_score[feasible]\n\n    # --------------------------------------------------------------\n    # Exploration noise (always added before \u03b5\u2011greedy decision).\n    # --------------------------------------------------------------\n    if noise_scale > 0.0:\n        rng = np.random.default_rng()\n        noise = rng.random(bins_remain_cap.shape) * noise_scale\n        priorities[feasible] += noise[feasible]\n\n    # --------------------------------------------------------------\n    # \u03b5\u2011greedy: with probability epsilon replace with a random ranking.\n    # --------------------------------------------------------------\n    if epsilon > 0.0 and np.random.rand() < epsilon:\n        rng = np.random.default_rng()\n        random_score = np.where(feasible, rng.random(bins_remain_cap.shape), -np.inf)\n        priorities = random_score\n\n    return priorities",
    "response_id": 2,
    "obj": 4.078579976067022,
    "SLOC": 45.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    steepness: float = 12.0,\n    midpoint: float = 0.5,\n    eps: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Deterministic, fit\u2011aware priority for online Bin Packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of currently open bins.\n    steepness : float, optional\n        Controls the sharpness of the sigmoid. Larger values give a\n        stronger preference for bins that are almost full.\n    midpoint : float, optional\n        The ratio (item/cap) at which the sigmoid output equals 0.5.\n        Default 0.5 gives a balanced bias between tight and loose fits.\n    eps : float, optional\n        Small constant added to denominators to avoid division by zero.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores with the same shape as ``bins_remain_cap``.\n        Feasible bins receive a smooth sigmoid\u2011based score in (0, 1].\n        Infeasible bins receive ``-np.inf`` so they are never chosen.\n    \"\"\"\n    # Ensure we work with a NumPy array of floats for vectorised operations\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item\n    feasible = caps >= item\n\n    # Initialise all priorities as -inf (worst possible)\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # If no bin can fit the item, return the -inf array\n    if not np.any(feasible):\n        return priorities\n\n    # Compute the fit ratio only for feasible bins\n    ratio = item / (caps[feasible] + eps)\n\n    # Apply a sigmoid transformation:\n    #   s(r) = 1 / (1 + exp(-steepness * (r - midpoint)))\n    # This yields values in (0, 1), close to 1 when r \u2248 1 (tight fit)\n    # and close to 0 when r is small (poor fit).\n    sigmoid = 1.0 / (1.0 + np.exp(-steepness * (ratio - midpoint)))\n\n    # Assign the computed scores to the feasible bins\n    priorities[feasible] = sigmoid\n\n    # Clip to the [0, 1] interval for numerical robustness\n    np.clip(priorities, 0.0, 1.0, out=priorities)\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Smooth\u2011sigmoid priority for the online Bin Packing Problem.\n\n    For each currently open bin we compute a score that rewards:\n      * a tight fit \u2013 the item occupies a large fraction of the free space;\n      * little waste \u2013 the leftover capacity after placement is small.\n\n    Both criteria are transformed by logistic (sigmoid) functions and combined\n    multiplicatively.  Bins that cannot accommodate the item receive ``-np.inf``\n    so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (0 < item \u2264 bin capacity).\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (higher is better) with the same shape as\n        ``bins_remain_cap``.  Infeasible bins are assigned ``-np.inf``.\n    \"\"\"\n    # Ensure a NumPy array of floats.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    n_bins = bins_remain_cap.shape[0]\n\n    # Default: infeasible -> -inf.\n    priorities = np.full(n_bins, -np.inf, dtype=np.float64)\n\n    # No bins at all \u2192 return empty priority vector.\n    if n_bins == 0:\n        return priorities\n\n    # Feasibility mask.\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities\n\n    # ----------------------------------------------------------------------\n    # 1) Fit\u2011ratio component \u2013 fraction of free space used by the item.\n    # ----------------------------------------------------------------------\n    # Ratio in (0, 1] for feasible bins, 0 elsewhere (value irrelevant there).\n    fit_ratio = np.zeros_like(bins_remain_cap)\n    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)\n\n    # Sigmoid parameters (tuned for a steep transition around 0.75).\n    alpha_fit = 12.0          # steepness\n    target_fit = 0.75         # ratio where score \u2248 0.5\n    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))\n\n    # ----------------------------------------------------------------------\n    #  : Waste component \u2013 encourage small leftover space.\n    # ----------------------------------------------------------------------\n    # Estimate the true bin capacity.  The maximum remaining capacity among\n    # open bins is a good proxy (an empty bin would have full capacity).\n    # If even the largest remaining capacity is smaller than the item,\n    # fall back to the item size itself to avoid division by zero.\n    est_capacity = max(np.max(bins_remain_cap), item)\n\n    waste = bins_remain_cap - item                # may be negative for infeasibles\n    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)  # normalised waste \u2208 [0,1]\n\n    # Sigmoid parameters for waste (high score for waste \u2264 10\u202f% of capacity).\n    alpha_waste = 10.0\n    waste_target = 0.10\n    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))\n\n    # ----------------------------------------------------------------------\n    # 2) Combine the two signals multiplicatively.\n    # ----------------------------------------------------------------------\n    combined_score = fit_score * waste_score\n\n    # Assign scores only to feasible bins.\n    priorities[feasible] = combined_score[feasible]\n\n    # ----------------------------------------------------------------------\n    # 3) Tiny deterministic tie\u2011breaker \u2013 favour lower\u2011index bins when scores\n    #    are numerically identical.\n    # ----------------------------------------------------------------------\n    epsilon = 1e-9\n    indices = np.arange(n_bins, dtype=np.float64)\n    priorities[feasible] -= epsilon * indices[feasible]\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                epsilon0: float = 0.1,\n                reuse_factor: float = 0.1,\n                noise_scale: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin for an online bin\u2011packing item.\n\n    The priority takes into account:\n    * Exact\u2011fit preference \u2013 bins that would leave zero leftover get the\n      highest score.\n    * Best\u2011fit principle \u2013 among non\u2011exact fits the bin with the smallest\n      remaining capacity after placement is favored.\n    * Dynamic exploration \u2013 an epsilon\u2011greedy policy where epsilon decreases\n      as the bins become fuller.  This encourages exploration when bins\n      have plenty of space and exploitation when the packing is tight.\n    * Tie\u2011breaking noise \u2013 a tiny random noise is added to break ties.\n    * Reuse penalty \u2013 bins that are already partially filled receive a\n      small penalty to discourage using heavily occupied bins.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    epsilon0 : float, optional\n        Base exploration probability (default 0.1).  The actual exploration\n        probability is scaled by how full the bins are.\n    reuse_factor : float, optional\n        Strength of the reuse penalty (default 0.1).\n    noise_scale : float, optional\n        Scale of the tiny random noise added when exploiting (default 1e\u20116).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores; higher values mean higher preference.  Bins that\n        cannot hold the item receive ``-np.inf``.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n\n    max_remain = bins_remain_cap.max()\n    avg_remaining = bins_remain_cap.mean()\n    # Compute a fill ratio: 0 when bins are empty, 1 when they are full.\n    fill_ratio = 0.0\n    if max_remain > 0:\n        fill_ratio = 1.0 - (avg_remaining / max_remain)\n    # Dynamic epsilon: more exploration when bins are loosely filled.\n    epsilon = epsilon0 * (1.0 - fill_ratio)\n    epsilon = np.clip(epsilon, 0.0, 1.0)\n\n    feasible = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n\n    # Reuse penalty: penalize bins that already have a large used fraction.\n    if max_remain > 0:\n        used_fraction = (max_remain - bins_remain_cap) / max_remain\n    else:\n        used_fraction = np.zeros_like(bins_remain_cap)\n    penalty = reuse_factor * used_fraction\n    # Do not penalize exact\u2011fit bins \u2013 they are the best choice.\n    penalty = np.where(leftover > 0, penalty, 0.0)\n\n    base_score = np.where(feasible, -leftover - penalty, -np.inf)\n\n    # Random scores for exploration\n    random_score = np.where(feasible, np.random.rand(n), -np.inf)\n\n    # Tiny noise to break ties during exploitation\n    noise = np.random.rand(n) * noise_scale\n\n    if np.random.rand() < epsilon:\n        priorities = random_score\n    else:\n        priorities = base_score + noise\n\n    return priorities",
    "response_id": 5,
    "obj": 4.198244914240141,
    "SLOC": 31.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                temperature: float = 1.0,\n                next_item_estimate: float | None = None,\n                weight_fit: float = 1.0,\n                weight_future: float = 1.0,\n                weight_balance: float = 0.5) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem (BPP).\n\n    This heuristic combines several signals:\n    * **Tight fit** \u2013 prefers bins where the leftover capacity after placing\n      the current item is small.\n    * **Future\u2011item feasibility** \u2013 if an estimate of the next item's size is\n      provided, bins that will still be able to accommodate that item receive\n      a bonus.\n    * **Bin\u2011balance** \u2013 encourages the remaining capacities of bins to stay\n      close to the average, avoiding a situation where some bins are almost\n      empty while others are nearly full.\n\n    The raw scores are transformed into a probability\u2011like priority vector\n    using a temperature\u2011controlled softmax. Bins that cannot accommodate the\n    current item receive a priority of zero.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacities of the bins.\n    temperature : float, optional\n        Positive temperature controlling the softness of the softmax.\n        Smaller values make the selection more deterministic.\n    next_item_estimate : float or None, optional\n        Estimated size of the next item. If given, bins that will still have\n        enough capacity for that next item after placing the current one get\n        a bonus.\n    weight_fit : float, optional\n        Weight for the tight\u2011fit component.\n    weight_future : float, optional\n        Weight for the future\u2011item feasibility component.\n    weight_balance : float, optional\n        Weight for the bin\u2011balance component.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (sum to 1 over feasible bins, zero for infeasible\n        bins).\n    \"\"\"\n    # Ensure a 1\u2011D float array.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64).ravel()\n\n    # Feasibility mask: bins that can accommodate the current item.\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        # No bin can accept the item.\n        return np.zeros_like(bins_remain_cap, dtype=np.float64)\n\n    # Remaining capacity after placing the item.\n    leftover = bins_remain_cap - item  # >= 0 for feasible bins.\n\n    # ---- Component 1: Tight fit (smaller leftover -> higher score) ----\n    # Using negative leftover so that a smaller leftover yields a larger value.\n    fit_score = -leftover * weight_fit\n\n    # ---- Component 2: Future\u2011item feasibility (optional) ----\n    if next_item_estimate is not None:\n        # Binary bonus for bins that would still be able to host the next item.\n        future_feasibility = (leftover >= next_item_estimate).astype(np.float64)\n        future_score = weight_future * future_feasibility\n    else:\n        future_score = 0.0\n\n    # ---- Component 3: Bin balance ----\n    # Encourage bins whose remaining capacity is close to the mean remaining.\n    avg_remain = np.mean(bins_remain_cap)\n    balance_score = -np.abs(bins_remain_cap - avg_remain) * weight_balance\n\n    # Combine components into a raw score.\n    raw_score = fit_score + future_score + balance_score\n\n    # Infeasible bins should never be selected \u2192 assign -inf before softmax.\n    raw_score = np.where(feasible, raw_score, -np.inf)\n\n    # ---- Temperature\u2011controlled softmax ----\n    eps = 1e-12\n    temp = max(temperature, eps)  # avoid division by zero.\n    max_raw = np.max(raw_score)   # finite because at least one feasible bin.\n    # Subtract max for numerical stability.\n    exp_scores = np.exp((raw_score - max_raw) / temp)\n    # exp(-inf) = 0, so infeasible bins contribute nothing.\n    sum_exp = np.sum(exp_scores)\n    if sum_exp == 0.0:\n        # Guard against pathological cases.\n        priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    else:\n        priorities = exp_scores / sum_exp\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 32.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    temperature: float = 1.0,\n    fit_weight: float = 0.5,\n    randomness: float = 1e-4,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing that blends leftover minimization\n    with a softmax temperature, includes fit ratio weighting, and adds\n    tie-breaking randomness.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the current free capacity in each bin.\n    temperature : float, optional\n        Temperature parameter for the softmax term. A small value\n        concentrates the probability mass on bins with the smallest\n        leftover, while a large value yields a more uniform distribution.\n        Must be positive.\n    fit_weight : float, optional\n        Exponent applied to the fit ratio (item / remaining capacity)\n        to weight bins where the item fits well relative to the remaining\n        space.  Default is 0.5.\n    randomness : float, optional\n        Scale of the tie\u2011breaking random noise added to each score.\n        Small values preserve the ordering induced by the deterministic\n        part of the score. Default is 1e-4.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores, same shape as ``bins_remain_cap``.\n        Bins that cannot accommodate ``item`` receive a score of\n        ``-np.inf`` and will never be selected.\n\n    Notes\n    -----\n    The priority score is computed as\n\n        score = exp(-leftover / temperature) * (fit_ratio ** fit_weight)\n\n    where\n\n        leftover  = bins_remain_cap - item  (for feasible bins)\n        fit_ratio = item / bins_remain_cap\n\n    A small random perturbation is added to ``score`` to break ties\n    deterministically.  The function is vectorised for efficiency.\n    \"\"\"\n    # Ensure we work with a float array\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Empty array handling\n    if bins_remain_cap.size == 0:\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if temperature <= 0.0:\n        raise ValueError(\"temperature must be a positive number\")\n\n    # Identify bins that can accept the item\n    feasible = bins_remain_cap >= item\n\n    # Initialize all priorities to -inf (infeasible bins)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if not feasible.any():\n        # No bin can accommodate the item; return -inf for all bins\n        return priorities\n\n    # Compute leftover and fit ratio only for feasible bins\n    leftover = bins_remain_cap[feasible] - item\n    fit_ratio = item / bins_remain_cap[feasible]\n\n    # Compute the deterministic part of the score\n    deterministic_score = np.exp(-leftover / temperature) * (fit_ratio ** fit_weight)\n\n    # Add tiny random noise for tie-breaking\n    noise = np.random.uniform(-randomness, randomness, size=deterministic_score.shape)\n\n    scores = deterministic_score + noise\n\n    # Assign scores to feasible bins\n    priorities[feasible] = scores\n\n    return priorities",
    "response_id": 7,
    "obj": 30.853609892301563,
    "SLOC": 23.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Adaptive priority for the online Bin Packing Problem.\n\n    This heuristic blends a First\u2011Fit style index preference with a\n    Worst\u2011Fit style remaining\u2011capacity preference.  The relative weight of\n    the two components changes smoothly with the current load of the\n    bin set: when bins are largely empty the algorithm behaves like\n    First\u2011Fit; as the bins become increasingly full it gradually turns\n    into a Worst\u2011Fit strategy.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.  Must be\n        non\u2011negative.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; the highest score corresponds to\n        the bin that will receive the item.  Infeasible bins receive\n        ``-np.inf``.\n    \"\"\"\n    # Ensure float type to avoid integer overflow when computing differences\n    bins_remain_cap = bins_remain_cap.astype(float, copy=False)\n\n    # Feasible bins: those that can accommodate the item\n    feasible = bins_remain_cap >= item\n\n    # Initialise all priorities to -inf (unfeasible)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # If no bin can hold the item, return immediately\n    if not np.any(feasible):\n        return priorities\n\n    # Indices of bins\n    indices = np.arange(bins_remain_cap.shape[0])\n\n    # Remaining capacities of feasible bins\n    remaining = bins_remain_cap[feasible]\n\n    # Avoid division by zero in the load calculation\n    eps = 1e-12\n    max_remain = np.max(remaining)\n\n    # Load factor: 0 when a bin has almost the maximum remaining capacity\n    # (bins are empty), 1 when the bin has almost zero remaining capacity\n    # (bins are almost full).  It is computed element\u2011wise.\n    load_factor = 1.0 - remaining / (max_remain + eps)\n    load_factor = np.clip(load_factor, 0.0, 1.0)\n\n    # Weight given to the index term (First\u2011Fit) and to the remaining capacity\n    # term (Worst\u2011Fit)\n    index_weight = 1.0 - load_factor\n\n    # Combine the two components into a single priority score\n    #  * index term favours lower indices (First\u2011Fit)\n    #  * remaining term favours bins with more space (Worst\u2011Fit)\n    priorities[feasible] = (\n        -indices[feasible] * index_weight\n        + remaining * load_factor\n    )\n\n    # Tiny tie\u2011breaker: a very small addition proportional to the remaining\n    # capacity.  This ensures deterministic selection when priorities are\n    # numerically identical.\n    priorities[feasible] += 1e-6 * remaining\n\n    return priorities",
    "response_id": 8,
    "obj": 6.082967690466694,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Softmax\u2011based priority for online bin packing that balances tight packing\n    (small leftover) with load\u2011balancing across bins.\n\n    The score for each feasible bin i is:\n        s_i = - (remaining capacity after placement)\n              - \u03b1 * variance_of_remaining_capacities_after_placement\n\n    The scores are transformed with a softmax (exp) so that the highest score\n    corresponds to the highest priority. Infeasible bins receive a priority of 0.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority values for each bin (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Ensure input is a NumPy array of floats\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item\n    feasible = bins_remain_cap >= item\n\n    # If no bin can accommodate the item, return zeros (no feasible bin)\n    if not feasible.any():\n        return np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Remaining capacity after placing the item in each bin\n    leftover = bins_remain_cap - item\n\n    # Weight for the variance term (tunable)\n    alpha = 0.5\n\n    # Number of bins\n    n_bins = bins_remain_cap.shape[0]\n\n    # Pre\u2011compute aggregate statistics of the current remaining capacities\n    total_sum = bins_remain_cap.sum()\n    total_sq_sum = np.square(bins_remain_cap).sum()\n\n    # After placing the item, total remaining capacity is reduced by `item`\n    new_total_sum = total_sum - item\n\n    # Variance of the remaining capacities if the item were placed in bin i.\n    # Computed without copying the array:\n    #   var_i = (total_sq_sum - 2*item*bins_remain_cap[i] + item**2) / n_bins\n    #           - (new_total_sum / n_bins)**2\n    var_after = (total_sq_sum - 2 * item * bins_remain_cap + item ** 2) / n_bins \\\n                - (new_total_sum / n_bins) ** 2\n\n    # Raw scores: penalize leftover and penalize variance (to promote load balance)\n    raw_scores = -leftover - alpha * var_after\n\n    # Infeasible bins should not be selected: assign -inf (exp(-inf)=0)\n    raw_scores = np.where(feasible, raw_scores, -np.inf)\n\n    # Softmax transformation for numerical stability\n    max_score = np.max(raw_scores[feasible])\n    shifted = raw_scores - max_score\n    priorities = np.exp(shifted)  # infeasible bins become 0\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]