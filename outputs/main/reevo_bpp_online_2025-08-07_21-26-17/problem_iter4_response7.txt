```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    epsilon: float = 0.05,
    noise_scale: float = 1e-4,
    alpha_fit: float = 12.0,
    target_fit: float = 0.80,
    alpha_waste: float = 12.0,
    waste_target: float = 0.07,
    alpha_used: float = 10.0,
    used_target: float = 0.40,
) -> np.ndarray:
    """
    Multi‑sigmoid priority function for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacity of each currently open bin.
    epsilon : float, optional
        Probability of replacing the deterministic score with a random ranking.
    noise_scale : float, optional
        Scale of the additive uniform noise applied before the ε‑greedy decision.
    alpha_fit, target_fit : float, optional
        Sigmoid parameters for the fit‑ratio component.
    alpha_waste, waste_target : float, optional
        Sigmoid parameters for the waste component.
    alpha_used, used_target : float, optional
        Sigmoid parameters for the used‑fraction component.

    Returns
    -------
    np.ndarray
        Priority scores (higher is better) for each bin.  Infeasible
        bins receive ``-np.inf``.
    """
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)

    # Empty array handling
    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)

    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        # No bin can accommodate the item
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    # Estimate the true bin capacity from the current open bins
    est_capacity = float(np.max(bins_remain_cap))
    if est_capacity <= 0:
        # All bins are full – impossible to pack
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    rng = np.random.default_rng()

    # 1) Fit‑ratio component (item size relative to remaining capacity)
    fit_ratio = np.empty_like(bins_remain_cap, dtype=np.float64)
    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)
    fit_ratio[~feasible] = 0.0  # dummy for infeasible bins
    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))

    # 2) Waste component (leftover capacity after placement)
    waste_norm = np.clip((bins_remain_cap - item) / est_capacity, 0.0, 1.0)
    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))

    # 3) Used‑fraction component (how much of the bin is already occupied)
    used_fraction = (est_capacity - bins_remain_cap) / est_capacity
    # After placement
    used_fraction_after = np.clip(used_fraction + item / est_capacity, 0.0, 1.0)
    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction_after - used_target)))

    # Combine the three signals multiplicatively
    combined_score = fit_score * waste_score * used_score
    combined_score[~feasible] = -np.inf

    # Add small exploration noise
    if noise_scale > 0.0:
        noise = rng.random(bins_remain_cap.shape) * noise_scale
        combined_score[feasible] += noise[feasible]

    # ε‑greedy exploration
    if epsilon > 0.0 and rng.random() < epsilon:
        random_score = np.where(feasible, rng.random(bins_remain_cap.shape), -np.inf)
        combined_score = random_score

    return combined_score
```
