```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    steepness: float = 12.0,
    midpoint: float = 0.5,
    eps: float = 1e-12,
) -> np.ndarray:
    """
    Sigmoid Fit Score priority for online Bin Packing.

    For each bin we compute a score based on how well the incoming `item`
    fits into the remaining capacity of the bin. The ratio `r = item / cap`
    (where `cap` is the remaining capacity) lies in (0, 1] for feasible bins.
    A logistic (sigmoid) transformation of this ratio emphasizes bins that
    would be filled tightly (ratio close to 1) and de‑emphasizes bins that
    would leave a large amount of waste.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array with the remaining capacity of each bin.
    steepness : float, optional
        Controls the steepness of the sigmoid. Larger values make the function
        more aggressive (i.e., more strongly prefer bins that almost fill up).
    midpoint : float, optional
        The ratio at which the sigmoid outputs 0.5. Typically 0.5,
        but can be tuned to bias towards tighter or looser fits.
    eps : float, optional
        Small constant to avoid division by zero.

    Returns
    -------
    np.ndarray
        Priority scores (same shape as ``bins_remain_cap``). Infeasible bins
        (where ``item`` does not fit) receive a score of 0.0.
    """
    # Ensure a NumPy array of floats for vectorised operations
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    feasible = caps + eps >= item  # +eps guards against floating‑point noise

    # Early exit: if nothing fits, return an array of zeros
    if not np.any(feasible):
        return np.zeros_like(caps, dtype=float)

    # Compute the fit ratio only for feasible bins
    # Ratio = item size divided by the bin's remaining capacity
    ratio = np.empty_like(caps, dtype=float)
    ratio[:] = 0.0                     # initialise with zeros for safety
    ratio[feasible] = item / caps[feasible]

    # Apply a sigmoid transformation:
    #   s(r) = 1 / (1 + exp(-steepness * (r - midpoint)))
    # This yields values in (0, 1), close to 1 when r ≈ 1 (tight fit)
    # and close to 0 when r is small (poor fit).
    sigmoid = 1.0 / (1.0 + np.exp(-steepness * (ratio[feasible] - midpoint)))

    # Assemble the final priority array: feasible bins get the sigmoid score,
    # infeasible bins retain 0.0 (lowest possible priority).
    priorities = np.zeros_like(caps, dtype=float)
    priorities[feasible] = sigmoid

    # Clip to the [0, 1] interval for numerical robustness
    np.clip(priorities, 0.0, 1.0, out=priorities)

    return priorities
```
