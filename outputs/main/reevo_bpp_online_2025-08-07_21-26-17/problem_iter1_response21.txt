```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Best‑Fit priority function for the online Bin Packing Problem.

    The function scores each bin such that the bin leaving the *least*
    remaining capacity after the item is placed receives the highest score.
    Infeasible bins (those that cannot accommodate the item) are assigned
    a priority of ``-np.inf`` so they are never selected.

    A tiny deterministic tie‑breaker based on bin index is added to avoid
    exact ties when two bins would leave the same waste.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array containing the remaining capacity of each open bin.

    Returns
    -------
    np.ndarray
        Priority scores (float) for each bin, same shape as ``bins_remain_cap``.
    """
    # Compute the remaining capacity *after* the item would be placed.
    remaining = bins_remain_cap - item

    # Feasibility mask: True where the item actually fits.
    feasible = remaining >= 0

    # Initialise all priorities to -inf (infeasible).
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # For feasible bins, priority = -waste (i.e., negative remaining capacity).
    # Larger priority => tighter fit (less waste).
    priorities[feasible] = -remaining[feasible]

    # Deterministic tie‑breaker: give a minuscule boost to bins with lower index.
    # This boost is far smaller than the smallest possible difference in waste
    # (bounded by the granularity of the problem data) and therefore does not
    # affect the best‑fit ordering, but it removes exact ties.
    epsilon = 1e-12
    tie_boost = epsilon * (bins_remain_cap.size - np.arange(bins_remain_cap.size))
    priorities[feasible] += tie_boost[feasible]

    return priorities
```
