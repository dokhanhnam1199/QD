{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"First\u2011Fit inspired priority for online Bin Packing.\n\n    The function assigns the highest priority to the *first* bin (lowest\n    index) that can accommodate the incoming `item`. Bins that do not have\n    enough remaining capacity receive a penalty of ``-np.inf`` so they will\n    never be chosen.\n\n    The priority score for a feasible bin `i` is:\n        priority[i] = N - i\n    where `N` is the total number of bins. This ensures that:\n        * bins with lower indices have larger scores,\n        * the ordering of scores mirrors the First\u2011Fit order,\n        * ties (which cannot happen) are avoided.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array where each entry is the remaining capacity\n                         of a bin.\n\n    Returns:\n        A NumPy array of the same shape as ``bins_remain_cap`` containing the\n        priority score for each bin.\n    \"\"\"\n    # Ensure the input is a 1\u2011D NumPy array of floats.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float).ravel()\n\n    # Boolean mask of bins that can fit the item.\n    feasible = bins_remain_cap >= item\n\n    # Total number of bins (used to give larger values to early bins).\n    n_bins = bins_remain_cap.shape[0]\n\n    # Base priority decreasing with bin index: first bin gets n_bins, last gets 1.\n    index_priorities = n_bins - np.arange(n_bins, dtype=float)\n\n    # Assign priorities: feasible bins keep the index\u2011based priority,\n    # infeasible bins get -inf so they are never selected.\n    priorities = np.where(feasible, index_priorities, -np.inf)\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Softmax\u2010Based Fit priority function for the online Bin Packing Problem.\n\n    The function assigns a probability\u2011like priority to each bin based on how\n    tightly the item would fit into the remaining capacity. Bins that cannot\n    accommodate the item receive a priority of 0. Among feasible bins,\n    ``softmax`` is applied to the negative leftover space (i.e. the tighter\n    the fit, the larger the unnormalized score) which yields a smooth,\n    temperature\u2011controlled ranking.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array with the remaining capacity of each bin.\n        temperature: Positive scaling factor that controls the sharpness of\n                     the softmax. Small values make the selection more\n                     deterministic (near\u2011greedy), larger values promote\n                     exploration.\n\n    Returns:\n        An array of the same shape as ``bins_remain_cap`` containing priority\n        scores that sum to 1 over feasible bins (zeros for infeasible ones).\n    \"\"\"\n    # Ensure float dtype for subsequent calculations\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility mask: only bins that can hold the item\n    feasible = bins_remain_cap >= item\n\n    # Initialise scores with -inf so that infeasible bins get zero after softmax\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Compute leftover capacity after placing the item\n    leftover = bins_remain_cap - item  # >= 0 for feasible bins\n\n    # Better fit => smaller leftover => larger (less negative) score\n    # Using -leftover / temperature mirrors a Boltzmann distribution.\n    scores[feasible] = -leftover[feasible] / max(temperature, 1e-12)\n\n    # Numerical stability: subtract the max score before exponentiation\n    max_score = np.max(scores)  # will be -inf if no feasible bin\n    if np.isneginf(max_score):\n        # No bin can accept the item \u2013 return a zero vector\n        return np.zeros_like(bins_remain_cap, dtype=np.float64)\n\n    exp_scores = np.exp(scores - max_score)\n\n    # Softmax normalization (sum of exponentials over feasible bins)\n    priorities = exp_scores / np.sum(exp_scores)\n\n    # Enforce zero for infeasible bins (already zero, but explicit for clarity)\n    priorities[~feasible] = 0.0\n\n    return priorities\n\n[Reflection]\nWeight by negative leftover, adjust temperature, combine fit and waste, forecast next item size, balance bin occupancy.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}