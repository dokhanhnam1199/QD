```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Exact Fit First priority.

    For an incoming item of size `item`, this function evaluates each bin
    in `bins_remain_cap` and returns a priority score.  
    The logic is:

        1. Bins that cannot accommodate the item receive a score of
           `-inf` (never selected).
        2. If a bin's remaining capacity equals the item's size (exact
           fit), it gets the maximum possible score, `0`.
        3. Otherwise, bins that leave less remaining space after the
           item is packed are preferred.  The priority is defined as
           `- (remaining_capacity - item)`, so a smaller leftover
           yields a larger score (less negative).

    This strategy ensures that bins that fit the item exactly are
    always chosen first, and if no exact fit exists, the bin that
    results in the smallest waste is selected.

    Parameters
    ----------
    item : float
        Size of the item to pack.
    bins_remain_cap : np.ndarray
        1â€‘D array of remaining capacities for each bin.

    Returns
    -------
    np.ndarray
        Array of priority scores; the bin with the largest score is the
        candidate for packing the item.
    """
    # Only bins that can hold the item are considered.
    can_fit = bins_remain_cap >= item

    # Default score for bins that cannot accommodate the item.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    if np.any(can_fit):
        # Remaining space after placing the item.
        remaining = bins_remain_cap[can_fit] - item
        # Exact fit => remaining == 0 -> score 0.
        # Larger remaining => more negative score.
        priorities[can_fit] = -remaining

    return priorities
```
