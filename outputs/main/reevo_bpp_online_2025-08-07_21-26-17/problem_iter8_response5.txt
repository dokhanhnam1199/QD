```python
import numpy as np
from typing import Optional


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    epsilon: float = 0.05,
    noise_scale: float = 1e-4,
    alpha_fit: float = 12.0,
    target_fit: float = 0.80,
    alpha_waste: float = 12.0,
    waste_target: float = 0.07,
    alpha_used: float = 10.0,
    used_target: float = 0.40,
    temperature: Optional[float] = None,
) -> np.ndarray:
    """
    Priority function for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item (assumed positive).
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    epsilon : float, default 0.05
        Mixing weight for ε‑greedy exploration (0 → deterministic,
        1 → pure random).
    noise_scale : float, default 1e-4
        Amplitude of uniform noise added to raw scores.
    alpha_fit, target_fit : float, default 12.0, 0.80
        Sigmoid steepness and target for the fit‑ratio
        (item / remaining_capacity).
    alpha_waste, waste_target : float, default 12.0, 0.07
        Sigmoid steepness and target for the waste
        ((remaining_capacity - item) / max_capacity).
    alpha_used, used_target : float, default 10.0, 0.40
        Sigmoid steepness and target for the used‑fraction
        ((max_capacity - remaining_capacity) / max_capacity).
    temperature : float | None, default None
        If provided, applies a temperature‑scaled softmax to the
        feasible scores, turning them into a probability distribution.
        ``temperature`` must be positive.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher = more desirable).  Infeasible
        bins receive ``-np.inf``.  If ``temperature`` is set, feasible scores
        sum to one.
    """
    # ------------------------------------------------------------------
    # 1. Input validation and preprocessing
    # ------------------------------------------------------------------
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)
    if bins_remain_cap.ndim != 1:
        raise ValueError("bins_remain_cap must be a 1‑D array")
    if item <= 0:
        raise ValueError("item size must be positive")
    if not (0.0 <= epsilon <= 1.0):
        raise ValueError("epsilon must be in the interval [0, 1]")
    if noise_scale < 0.0:
        raise ValueError("noise_scale must be non‑negative")
    if temperature is not None and temperature <= 0.0:
        raise ValueError("temperature must be positive when provided")

    n_bins = bins_remain_cap.shape[0]
    if n_bins == 0:
        return np.array([], dtype=np.float64)

    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        # No bin can accommodate the item
        return np.full(n_bins, -np.inf, dtype=np.float64)

    # Estimate the (normalized) bin capacity – assuming all bins share the same max.
    max_capacity = bins_remain_cap.max()

    # ------------------------------------------------------------------
    # 2. Component scores (sigmoid‑based)
    # ------------------------------------------------------------------
    # Fit ratio: item size relative to remaining capacity
    fit_ratio = np.zeros_like(bins_remain_cap)
    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)
    fit_ratio = np.clip(fit_ratio, 0.0, 1.0)
    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))
    fit_score[~feasible] = 0.0

    # Waste: remaining space after placing the item
    waste = bins_remain_cap - item
    waste_norm = np.clip(waste / max_capacity, 0.0, 1.0)
    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))
    waste_score[~feasible] = 0.0

    # Used fraction: how much of the bin is already filled
    used_fraction = (max_capacity - bins_remain_cap) / max_capacity
    used_fraction = np.clip(used_capacity if (used_capacity := used_fraction) else used_fraction, 0.0, 1.0)
    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))
    used_score[~feasible] = 0.0

    # Combined raw priority (product of components)
    raw_priority = fit_score * waste_score * used_score

    # Small exact‑fit bump (moderate, not huge)
    exact_fit_mask = feasible & np.isclose(waste, 0.0, atol=1e-9)
    raw_priority[exact_fit_mask] += 1e-3

    # ------------------------------------------------------------------
    # 3. Add stochastic perturbations
    # ------------------------------------------------------------------
    rng = np.random.default_rng()
    if noise_scale > 0.0:
        noise = rng.uniform(-noise_scale, noise_scale, size=n_bins)
        # Dampen noise for bins already scoring high on fit
        noise *= (1.0 - fit_score)
        raw_priority += noise

    # ε‑greedy mixing: blend raw scores with uniform random scores
    if epsilon > 0.0:
        random_scores = rng.random(size=n_bins)  # uniform [0,1)
        combined = (1.0 - epsilon) * raw_priority + epsilon * random_scores
    else:
        combined = raw_priority

    # Infeasible bins must never be selected
    combined[~feasible] = -np.inf

    # ------------------------------------------------------------------
    # 4. Optional temperature‑scaled softmax
    # ------------------------------------------------------------------
    if temperature is not None:
        feasible_scores = combined[feasible]
        if feasible_scores.size > 0:
            max_score = feasible_scores.max()
            exp_vals = np.exp((feasible_scores - max_score) / temperature)
            probs = exp_vals / exp_vals.sum()
            combined[feasible] = probs
        else:
            combined[feasible] = -np.inf

    return combined
```
