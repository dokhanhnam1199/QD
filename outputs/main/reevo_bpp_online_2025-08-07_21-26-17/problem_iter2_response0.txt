```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    a: float = 5.0,
    b: float = 10.0,
    adaptive: bool = True,
) -> np.ndarray:
    """
    Compute a priority score for each bin for the online Bin Packing Problem.

    The priority is based on a sigmoid of the *normalized leftover* after
    hypothetically placing the item in each bin.  A tight fit (small leftover)
    yields a high score, while a loose fit yields a lower score.  Infeasible
    bins (where the item does not fit) receive ``-np.inf`` so they are never
    selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the current bins (non‑negative).
    a : float, optional
        Offset of the sigmoid.  Larger ``a`` shifts the curve upward,
        increasing scores overall. Default is 5.0.
    b : float, optional
        Base steepness of the sigmoid.  Larger ``b`` makes the score drop
        faster as the leftover fraction grows. Default is 10.0.
    adaptive : bool, optional
        If ``True``, the steepness ``b`` is scaled by the standard deviation of
        the normalized leftovers among feasible bins.  This makes the heuristic
        adapt to the current distribution of bin utilizations.  If ``False``,
        the raw ``b`` is used.

    Returns
    -------
    np.ndarray
        Array of priority scores with the same shape as ``bins_remain_cap``.
        Feasible bins have finite scores; infeasible bins have ``-np.inf``.
    """
    # Ensure a NumPy array of floats for safe arithmetic
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Compute leftover capacity after placing the item
    leftover = caps - item

    # Determine which bins can accommodate the item
    feasible = leftover >= 0

    # Initialise all priorities to -inf (infeasible)
    priorities = np.full_like(caps, -np.inf, dtype=float)

    if not np.any(feasible):
        # No bin can accept the item – return all -inf
        return priorities

    # Normalized leftover fraction: 0 → perfect fit, 1 → empty bin
    norm_leftover = np.empty_like(caps, dtype=float)
    # Avoid division by zero (should not occur for feasible bins with cap>0)
    norm_leftover[feasible] = leftover[feasible] / caps[feasible]
    # For completeness set zero for infeasible entries (won't be used)
    norm_leftover[~feasible] = 0.0

    # Adaptive scaling of steepness (optional)
    if adaptive:
        # Compute standard deviation of normalized leftovers among feasible bins
        std = np.std(norm_leftover[feasible])
        # Guard against zero std (all leftovers identical) → use 1.0 scaling
        scale = std if std > 1e-6 else 1.0
    else:
        scale = 1.0

    # Sigmoid logits: high when norm_leftover is small (tight fit)
    logits = a - (b / scale) * norm_leftover[feasible]

    # Logistic function (sigmoid) producing values in (0, 1)
    scores = 1.0 / (1.0 + np.exp(-logits))

    # Assign computed scores to feasible bins
    priorities[feasible] = scores

    return priorities
```
