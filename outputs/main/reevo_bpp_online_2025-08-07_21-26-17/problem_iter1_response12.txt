```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority scores for the Worst‑Fit online bin packing heuristic.

    The Worst‑Fit rule selects the bin with the largest *remaining* capacity
    that can still accommodate the incoming ``item``.  Bins that cannot hold the
    item receive a very low (``-inf``) priority so they are never chosen.
    Among feasible bins the slack ``(remaining capacity – item)`` is used as
    the main priority, with a tiny deterministic tie‑breaker based on the bin
    index to avoid ties.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each bin.

    Returns
    -------
    np.ndarray
        Array of the same shape as ``bins_remain_cap`` containing the priority
        score for each bin.  The bin with the highest value should be selected.
    """
    # Initialise all priorities to -inf (ensuring infeasible bins are never chosen)
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    # Identify bins that can accommodate the item
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        # No bin can fit the item – caller may open a new bin.
        return priorities

    # Slack = remaining capacity after placing the item
    slack = bins_remain_cap[feasible] - item

    # Deterministic tie‑breaker: a vanishing epsilon proportional to the bin index.
    # This preserves the ordering by slack while guaranteeing unique values.
    feasible_indices = np.where(feasible)[0:
        # caution about direct parameter?

    idx = np.where(feasible)[0]
    epsilon = (idx.astype(np.float64) / (bins_remain_cap.size + 1)) * 1e-9

    # Assign priorities: larger slack → higher priority
    priorities[feasible] = slack + epsilon

    return priorities
```
