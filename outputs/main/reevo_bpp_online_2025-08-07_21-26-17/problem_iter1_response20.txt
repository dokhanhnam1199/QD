```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """First‑Fit inspired priority for online Bin Packing.

    The function assigns the highest priority to the *first* bin (lowest
    index) that can accommodate the incoming `item`. Bins that do not have
    enough remaining capacity receive a penalty of ``-np.inf`` so they will
    never be chosen.

    The priority score for a feasible bin `i` is:
        priority[i] = N - i
    where `N` is the total number of bins. This ensures that:
        * bins with lower indices have larger scores,
        * the ordering of scores mirrors the First‑Fit order,
        * ties (which cannot happen) are avoided.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array where each entry is the remaining capacity
                         of a bin.

    Returns:
        A NumPy array of the same shape as ``bins_remain_cap`` containing the
        priority score for each bin.
    """
    # Ensure the input is a 1‑D NumPy array of floats.
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float).ravel()

    # Boolean mask of bins that can fit the item.
    feasible = bins_remain_cap >= item

    # Total number of bins (used to give larger values to early bins).
    n_bins = bins_remain_cap.shape[0]

    # Base priority decreasing with bin index: first bin gets n_bins, last gets 1.
    index_priorities = n_bins - np.arange(n_bins, dtype=float)

    # Assign priorities: feasible bins keep the index‑based priority,
    # infeasible bins get -inf so they are never selected.
    priorities = np.where(feasible, index_priorities, -np.inf)

    return priorities
```
