```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive priority for the online Bin Packing Problem.

    Uses an inverse-leftover (tight‑fit) score blended with random exploration.
    The exploration weight ε adapts to the variance of leftover capacities
    among feasible bins.  An exact‑fit bonus is added for zero leftover.
    """
    # Constants
    EPSILON_MIN = 0.05
    EPSILON_MAX = 0.25
    HUGE_BONUS = 1e6
    eps = 1e-12  # avoid division by zero

    caps = np.asarray(bins_remain_cap, dtype=float)
    feasible = caps >= item

    # No feasible bin
    if not np.any(feasible):
        return np.full(caps.shape, -np.inf, dtype=float)

    # Remaining capacity if the item is placed
    leftover = caps - item

    # Base priority: inverse leftover (tight fits get larger scores)
    base = np.where(feasible, 1.0 / (leftover + eps), 0.0)

    # Adaptive ε based on leftover variance among feasible bins
    lo = leftover[feasible]
    var = np.var(lo)
    L = np.max(lo)
    var_max = (L * L) / 4.0 if L > 0 else 0.0
    var_norm = var / var_max if var_max > 0 else 0.0
    var_norm = np.clip(var_norm, 0.0, 1.0)
    epsilon = EPSILON_MIN + (EPSILON_MAX - EPSILON_MIN) * (1.0 - var_norm)

    # Random exploration component
    rng = np.random.default_rng()
    random_score = rng.random(caps.shape)

    # Blend exploitation (tight‑fit) and exploration (random)
    blended = (1.0 - epsilon) * base + epsilon * random_score

    # Add exact‑fit bonus
    exact_fit_mask = feasible & np.isclose(leftover, 0.0, atol=1e-9)
    blended[exact_fit_mask] += HUGE_BONUS

    # Infeasible bins should never be chosen
    priorities = np.where(feasible, blended, -np.inf)
    return priorities
```
