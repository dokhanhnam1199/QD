```python
import numpy as np
from typing import Optional

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    epsilon: float = 0.05,
    noise_scale: float = 1e-4,
    alpha_fit: float = 20.0,
    target_fit: float = 0.80,
    alpha_waste: float = 20.0,
    waste_target: float = 0.07,
    alpha_used: float = 15.0,
    used_target: float = 0.40,
    temperature: Optional[float] = None,
    tie_breaker_scale: float = 1e-12,
    exact_fit_bonus: float = 1e6,
    random_state: Optional[int] = None,
) -> np.ndarray:
    """Priority function for online bin‑packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    epsilon : float, default 0.05
        Probability of selecting a completely random feasible bin (ε‑greedy exploration).
    noise_scale : float, default 1e-4
        Scale of the uniform noise added to the raw scores. The noise magnitude
        is attenuated by (1‑fit_ratio) so that bins that almost perfectly fit
        the item receive less random perturbation.
    alpha_fit, target_fit : float, default 20.0, 0.80
        Parameters of the sigmoid used to score the fit‑ratio
        (item / remaining_capacity).
    alpha_waste, waste_target : float, default 20.0, 0.07
        Parameters of the sigmoid used to score the waste
        (remaining_capacity - item).
    alpha_used, used_target : float, default 15.0, 0.40
        Parameters of the sigmoid used to score the used‑fraction
        ((max_capacity - remaining_capacity) / max_capacity).
    temperature : float or None, default None
        If provided, the final scores are passed through a
        temperature‑scaled softmax so that they sum to one.
        If ``None`` the raw scores are returned.
    tie_breaker_scale : float, default 1e-12
        Tiny multiplier for bin index to break exact ties deterministically.
    exact_fit_bonus : float, default 1e6
        Bonus added to a bin that fits the item exactly (remaining_capacity == item).
    random_state : int or None, default None
        Seed for the internal RNG (useful for reproducibility).

    Returns
    -------
    np.ndarray
        Priority scores (higher is better) for each bin.  Feasible
        bins receive a value in [0,1] (or a probability when
        ``temperature`` is set).  Infeasible bins receive ``-np.inf``.
    """
    # ----- Input validation -----
    if not isinstance(item, (int, float)):
        raise TypeError("item must be a numeric type")
    if item <= 0.0:
        raise ValueError("item must be positive")
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)
    if bins_remain_cap.ndim != 1:
        raise ValueError("bins_remain_cap must be a 1‑D array")
    if np.any(np.isnan(bins_remain_cap)):
        bins_remain_cap = np.where(np.isnan(bins_remain_cap), -np.inf, bins_remain_cap)
    if np.any(bins_remain_cap < 0):
        bins_remain_cap = np.where(bins_remain_cap < 0, -np.inf, bins_remain_cap)
    if not 0.0 <= epsilon <= 1.0:
        raise ValueError("epsilon must be between 0 and 1")
    if noise_scale < 0.0:
        raise ValueError("noise_scale must be non‑negative")
    if temperature is not None and temperature <= 0.0:
        raise ValueError("temperature must be positive if provided")
    if tie_breaker_scale < 0.0:
        raise ValueError("tie_breaker_scale must be non‑negative")
    if exact_fit_bonus < 0.0:
        raise ValueError("exact_fit_bonus must be non‑negative")
    if random_state is not None and not isinstance(random_state, (int, np.integer)):
        raise TypeError("random_state must be an int or None")

    n_bins = bins_remain_cap.size
    if n_bins == 0:
        return np.array([], dtype=np.float64)

    # ----- Feasibility mask -----
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        return np.full(n_bins, -np.inf, dtype=np.float64)

    # ----- RNG -----
    rng = np.random.default_rng(random_state)

    # ----- Max capacity estimate -----
    max_capacity = float(bins_remain_cap.max())
    if max_capacity <= 0.0:
        max_capacity = 1.0

    # ----- Logistic helper (numerically stable) -----
    def _logistic(z: np.ndarray) -> np.ndarray:
        z = np.clip(z, -700.0, 700.0)
        return 1.0 / (1.0 + np.exp(-z))

    # ----- Fit ratio component -----
    fit_ratio = np.empty_like(bins_remain_cap)
    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)
    fit_ratio = np.clip(fit_ratio, 0.0, 1.0)
    fit_z = alpha_fit * (fit_ratio - target_fit)
    fit_score = _logistic(fit_z)

    # ----- Waste component -----
    waste = bins_remain_cap - item
    waste_norm = np.clip(waste / max_capacity, 0.0, 1.0)
    waste_z = -alpha_waste * (waste_norm - waste_target)
    waste_score = _logistic(waste_z)

    # ----- Used fraction component -----
    used_fraction = np.clip((max_capacity - bins_remain_cap) / max_capacity, 0.0, 1.0)
    used_z = alpha_used * (used_fraction - used_target)
    used_score = _logistic(used_z)

    # ----- Raw priority -----
    priorities = fit_score * waste_score * used_score
    priorities[~feasible] = 0.0

    # ----- Tie‑breaker -----
    priorities += np.arange(n_bins, dtype=np.float64) * tie_breaker_scale

    # ----- Proportional noise -----
    if noise_scale > 0.0:
        noise_factor = np.where(feasible, 1.0 - fit_ratio, 0.0)
        noise = rng.uniform(-noise_scale, noise_scale, size=n_bins) * noise_factor
        priorities += noise

    # ----- Exact fit bonus -----
    exact_fit_mask = feasible & np.isclose(waste, 0.0, atol=1e-9)
    priorities[exact_fit_mask] += exact_fit_bonus

    # ----- ε‑greedy exploration -----
    if rng.random() < epsilon:
        priorities = np.full(n_bins, -np.inf, dtype=np.float64)
        priorities[feasible] = rng.random(np.count_nonzero(feasible))
    else:
        priorities[~feasible] = -np.inf

    # ----- Temperature‑scaled softmax -----
    if temperature is not None:
        feasible_scores = priorities[feasible]
        if feasible_scores.size > 0:
            max_score = feasible_scores.max()
            exp_scores = np.exp((feasible_scores - max_score) / temperature)
            probs = exp_scores / exp_scores.sum()
            priorities[feasible] = probs
        priorities[~feasible] = 0.0

    return priorities
```
