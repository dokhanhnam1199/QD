```python
import numpy as np

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                *,
                epsilon: float = 0.05,
                noise_scale: float = 1e-4,
                alpha_fit: float = 12.0,
                target_fit: float = 0.80,
                alpha_waste: float = 12.0,
                waste_target: float = 0.07,
                alpha_used: float = 10.0,
                used_target: float = 0.40) -> np.ndarray:
    """
    Priority function for online bin packing based on a multiplicative
    combination of three sigmoid‑based criteria (fit, waste, usage)
    with adaptive noise and optional ε‑greedy exploration.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacity in each currently open bin.
    epsilon : float, optional
        Probability of choosing a completely random feasible bin.
    noise_scale : float, optional
        Base scale of the additive uniform noise.
    alpha_fit, target_fit : float, optional
        Sigmoid hyper‑parameters for the fit‑ratio component.
    alpha_waste, waste_target : float, optional
        Sigmoid hyper‑parameters for the waste component.
    alpha_used, used_target : float, optional
        Sigmoid hyper‑parameters for the used‑fraction component.

    Returns
    -------
    np.ndarray
        Priority scores (higher is better); infeasible bins receive
        ``-np.inf``.  The returned array has the same shape as
        ``bins_remain_cap``.
    """
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)

    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)

    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    est_capacity = float(np.max(bins_remain_cap))

    # Fit‑ratio component
    fit_ratio = np.zeros_like(bins_remain_cap)
    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)
    fit_ratio = np.clip(fit_ratio, 0.0, 1.0)
    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))
    fit_score[~feasible] = 0.0

    # Waste component
    waste = bins_remain_cap - item
    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)
    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))
    waste_score[~feasible] = 0.0

    # Used‑fraction component
    used_fraction = (est_capacity - bins_remain_cap) / est_capacity
    used_fraction[~feasible] = 0.0
    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))
    used_score[~feasible] = 0.0

    priorities = fit_score * waste_score * used_score

    rng = np.random.default_rng()

    if noise_scale > 0.0:
        noise = rng.uniform(-noise_scale, noise_scale, size=bins_remain_cap.shape)
        noise *= (1.0 - fit_ratio)
        priorities += noise

    if epsilon > 0.0 and rng.random() < epsilon:
        random_scores = rng.random(bins_remain_cap.shape)
        random_scores[~feasible] = -np.inf
        priorities = random_scores

    priorities[~feasible] = -np.inf
    return priorities
```
