{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Compute a priority score for each bin for online bin packing.\n    Bins with higher scores are more desirable for the incoming item.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; higher scores indicate more desirable bins.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item\n    can_fit = bins_remain_cap >= item\n    if not np.any(can_fit):\n        return np.zeros_like(bins_remain_cap)\n\n    # Approximate original bin capacity from the largest remaining capacity\n    bin_capacity = np.max(bins_remain_cap[can_fit])\n\n    # Remaining capacity after placing the item\n    leftover = bins_remain_cap - item\n\n    # Normalized leftover fraction for feasible bins\n    leftover_frac = leftover[can_fit] / bin_capacity\n\n    # Sigmoid function to score waste (small leftover \u2192 high score)\n    k_waste = 12.0\n    waste_sigmoid = 1.0 / (1.0 + np.exp(k_waste * (leftover_frac - 0.5)))\n\n    # Fit ratio: how much of the bin's remaining capacity the item consumes\n    fit_ratio = item / (bins_remain_cap[can_fit] + 1e-12)\n\n    # Base priority for feasible bins\n    base_priority = np.zeros_like(bins_remain_cap)\n    base_priority[can_fit] = fit_ratio * waste_sigmoid\n\n    # Forecast next item size (heuristic: 80\u202f% of the current item)\n    next_item_est = item * 0.8\n\n    # Penalize bins that leave too much leftover compared to the forecast\n    future_penalty = 1.0 / (1.0 + np.exp(10.0 * (leftover[can_fit] - next_item_est)))\n    base_priority[can_fit] *= future_penalty\n\n    # Boost exact\u2011fit bins\n    exact_fit = np.logical_and(can_fit, np.isclose(leftover, 0.0, atol=1e-8))\n    base_priority[exact_fit] *= 1.5\n\n    # Dynamic exploration\u2013exploitation trade\u2011off\n    min_left = np.min(leftover[can_fit])\n    max_left = np.max(leftover[can_fit])\n    dynamic_eps = np.clip(\n        0.05 + 0.85 * (max_left - min_left) / (max_left + 1e-12),\n        0.05,\n        0.9,\n    )\n\n    rng = np.random.default_rng()\n    noise = rng.normal(scale=1e-6, size=bins_remain_cap.shape)\n\n    # Softmax with temperature to bias low waste\n    temperature = 0.3\n    raw_scores = base_priority + noise\n    exp_scores = np.exp(raw_scores / temperature)\n    exp_scores[~can_fit] = 0.0\n    softmax_scores = exp_scores / np.sum(exp_scores)\n\n    # Random exploration component\n    random_scores = rng.random(bins_remain_cap.shape)\n\n    final_scores = (1.0 - dynamic_eps) * softmax_scores + dynamic_eps * random_scores\n    final_scores[~can_fit] = 0.0\n\n    return final_scores\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Smooth\u2011sigmoid priority for the online Bin Packing Problem.\n\n    For each currently open bin we compute a score that rewards:\n      * a tight fit \u2013 the item occupies a large fraction of the free space;\n      * little waste \u2013 the leftover capacity after placement is small.\n\n    Both criteria are transformed by logistic (sigmoid) functions and combined\n    multiplicatively.  Bins that cannot accommodate the item receive ``-np.inf``\n    so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (0 < item \u2264 bin capacity).\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (higher is better) with the same shape as\n        ``bins_remain_cap``.  Infeasible bins are assigned ``-np.inf``.\n    \"\"\"\n    # Ensure a NumPy array of floats.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    n_bins = bins_remain_cap.shape[0]\n\n    # Default: infeasible -> -inf.\n    priorities = np.full(n_bins, -np.inf, dtype=np.float64)\n\n    # No bins at all \u2192 return empty priority vector.\n    if n_bins == 0:\n        return priorities\n\n    # Feasibility mask.\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities\n\n    # ----------------------------------------------------------------------\n    # 1) Fit\u2011ratio component \u2013 fraction of free space used by the item.\n    # ----------------------------------------------------------------------\n    # Ratio in (0, 1] for feasible bins, 0 elsewhere (value irrelevant there).\n    fit_ratio = np.zeros_like(bins_remain_cap)\n    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)\n\n    # Sigmoid parameters (tuned for a steep transition around 0.75).\n    alpha_fit = 12.0          # steepness\n    target_fit = 0.75         # ratio where score \u2248 0.5\n    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))\n\n    # ----------------------------------------------------------------------\n    #  : Waste component \u2013 encourage small leftover space.\n    # ----------------------------------------------------------------------\n    # Estimate the true bin capacity.  The maximum remaining capacity among\n    # open bins is a good proxy (an empty bin would have full capacity).\n    # If even the largest remaining capacity is smaller than the item,\n    # fall back to the item size itself to avoid division by zero.\n    est_capacity = max(np.max(bins_remain_cap), item)\n\n    waste = bins_remain_cap - item                # may be negative for infeasibles\n    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)  # normalised waste \u2208 [0,1]\n\n    # Sigmoid parameters for waste (high score for waste \u2264 10\u202f% of capacity).\n    alpha_waste = 10.0\n    waste_target = 0.10\n    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))\n\n    # ----------------------------------------------------------------------\n    # 2) Combine the two signals multiplicatively.\n    # ----------------------------------------------------------------------\n    combined_score = fit_score * waste_score\n\n    # Assign scores only to feasible bins.\n    priorities[feasible] = combined_score[feasible]\n\n    # ----------------------------------------------------------------------\n    # 3) Tiny deterministic tie\u2011breaker \u2013 favour lower\u2011index bins when scores\n    #    are numerically identical.\n    # ----------------------------------------------------------------------\n    epsilon = 1e-9\n    indices = np.arange(n_bins, dtype=np.float64)\n    priorities[feasible] -= epsilon * indices[feasible]\n\n    return priorities\n\n[Reflection]\nPrefer deterministic sigmoids, combine fit and waste multiplicatively, avoid random noise, use -inf for infeasible, add tiny tie\u2011breaker.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}