```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    temperature: float = 1.0,
    next_item_estimate: float | None = None,
    weight_fit: float = 1.0,
    weight_future: float = 1.0,
    weight_balance: float = 0.5,
    weight_exact: float = 1.0,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem (BPP).

    The function combines three signals:

    1. **Tight fit** – a negative score proportional to the leftover capacity.
       Smaller leftover gives a higher score.
    2. **Future‑item feasibility** – if an estimate of the next item size is
       provided, bins that will still be able to accommodate that item after
       placing the current one receive a bonus.
    3. **Bin balance** – bins whose remaining capacity is close to the average
       remaining capacity get a positive score, encouraging a balanced packing.

    The raw scores are transformed into a probability‑like priority vector
    using a temperature‑controlled softmax. Bins that cannot accommodate the
    current item receive a score of zero.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of the bins.
    temperature : float, optional
        Positive temperature controlling the softness of the softmax.
        Smaller values make the selection more deterministic.
    next_item_estimate : float or None, optional
        Estimated size of the next item. If given, bins that will still have
        enough capacity for that next item after placing the current one get
        a bonus.
    weight_fit : float, optional
        Weight for the tight‑fit component.
    weight_future : float, optional
        Weight for the future‑item feasibility component.
    weight_balance : float, optional
        Weight for the bin‑balance component.
    weight_exact : float, optional
        Bonus weight for bins that become exactly empty after placing the
        current item.

    Returns
    -------
    np.ndarray
        Priority scores (sum to 1 over feasible bins, zero for infeasible
        bins).
    """
    # Normalise input
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64).ravel()

    # Feasibility mask
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        return np.zeros_like(bins_remain_cap, dtype=np.float64)

    # Remaining capacity after placing the item
    leftover = bins_remain_cap - item  # >= 0 for feasible bins

    # 1️⃣ Tight‑fit component: smaller leftover -> higher score
    fit_score = -leftover * weight_fit

    # 2️⃣ Future‑item feasibility component
    if next_item_estimate is not None:
        future_feasibility = (leftover >= next_item_estimate).astype(np.float64)
        future_score = weight_future * future_feasibility
    else:
        future_score = 0.0

    # 3️⃣ Bin‑balance component: prefer capacities close to the average
    avg_remain = np.mean(bins_remain_cap)
    balance_score = -np.abs(bins_remain_cap - avg_remain) * weight_balance

    # Combine raw components
    raw_score = fit_score + future_score + balance_score

    # Exact‑fit bonus
    exact_fit_mask = feasible & (leftover <= 1e-9)
    raw_score[exact_fit_mask] += weight_exact

    # Infeasible bins: set to -inf so that exp(-inf) = 0
    raw_score[~feasible] = -np.inf

    # Temperature‑controlled softmax
    eps = 1e-12
    temp = max(temperature, eps)
    max_raw = np.max(raw_score)  # finite because at least one feasible bin
    exp_scores = np.exp((raw_score - max_raw) / temp)
    sum_exp = np.sum(exp_scores)
    if sum_exp == 0.0:
        # All feasible bins were set to -inf due to some numeric issue
        return np.zeros_like(bins_remain_cap, dtype=np.float64)

    priorities = exp_scores / sum_exp
    return priorities
```
