```python
import numpy as np
from typing import Optional

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    weight_leftover: float = 1.0,
    weight_fit: float = 1.0,
    weight_variance: float = 0.5,
    temperature: float = 0.1,
    epsilon: float = 0.05,
    noise_scale: float = 1e-4,
    random_state: Optional[int] = None
) -> np.ndarray:
    """
    Compute a priority score for each open bin when an item arrives in an online
    bin‑packing problem.

    The raw priority is a weighted combination of three intuitive criteria:

    * **Leftover capacity** after placing the item.  Smaller leftover
      (i.e. tighter fit) is preferred – contributes with a negative weight.
    * **Fit ratio** – the ratio of the item size to the bin capacity
      (``item / bins``).  Larger ratio indicates a tighter fit relative to
      the bin size – contributes with a positive weight.
    * **Post‑placement variance** of the remaining capacities of all bins.
      Lower variance is preferred – contributes with a negative weight.

    The raw scores are optionally perturbed with a small uniform noise
    (``noise_scale``) and, with probability ``epsilon``, replaced by a
    uniformly random value to encourage exploration.

    Finally a temperature‑scaled softmax turns the scores into a probability
    distribution; the bin with the highest probability is chosen by the
    calling routine.  If no bin can accommodate the item, a vector of zeros
    is returned.

    Parameters
    ----------
    item : float
        Size of the incoming item (must be positive).
    bins_remain_cap : np.ndarray
        1‑D array containing the remaining capacity of each currently open
        bin.
    weight_leftover : float, default=1.0
        Weight for the leftover capacity term (negative contribution).
    weight_fit : float, default=1.0
        Weight for the fit‑ratio term (positive contribution).
    weight_variance : float, default=0.5
        Weight for the variance penalty term (negative contribution).
    temperature : float, default=0.1
        Temperature for the softmax; lower values sharpen the distribution.
    epsilon : float, default=0.05
        Probability of performing ε‑greedy exploration (random feasible
        bin).  Set to 0 to disable.
    noise_scale : float, default=1e-4
        Scale of uniform noise added to the raw scores before the softmax.
    random_state : int or None, optional
        Seed for reproducibility.

    Returns
    -------
    np.ndarray
        Probability of selecting each bin.  Infeasible bins receive a
        probability of zero.  If no bin can accommodate the item, the
        returned array consists entirely of zeros.
    """
    bins = np.asarray(bins_remain_cap, dtype=np.float64).ravel()
    n_bins = bins.size

    if n_bins == 0:
        return np.array([], dtype=np.float64)

    if item <= 0:
        raise ValueError("Item size must be positive.")
    if temperature <= 0:
        raise ValueError("Temperature must be positive.")
    if not (0 <= epsilon <= 1):
        raise ValueError("Epsilon must be in [0, 1].")

    rng = np.random.default_rng(random_state)

    # Feasibility mask
    feasible = bins >= item
    if not np.any(feasible):
        return np.zeros_like(bins, dtype=np.float64)

    # Leftover capacity after placement
    leftover = bins - item

    # Fit ratio: item / bin capacity (valid only for feasible bins)
    fit_ratio = np.empty_like(bins)
    np.divide(item, bins, out=fit_ratio, where=feasible)
    fit_ratio[~feasible] = 0.0

    # Variance of remaining capacities after placing the item into each bin
    total_sum = bins.sum()
    total_sq = np.square(bins).sum()
    sum_x = total_sum - item                    # Σ all capacities after placement
    sum_sq = total_sq - 2 * item * bins + item**2  # Σ squares after placement
    mean = sum_x / n_bins
    var = sum_sq / n_bins - mean**2
    var[~feasible] = 0.0

    # Raw priority: weighted sum of the three criteria
    raw_score = (
        -weight_leftover * leftover
        + weight_fit * fit_ratio
        - weight_variance * var
    )
    raw_score[~feasible] = -np.inf  # infeasible bins cannot be chosen

    # Optional exploration noise
    if noise_scale > 0.0:
        noise = rng.uniform(-noise_scale, noise_scale, size=feasible.sum())
        raw_score[feasible] += noise

    # ε‑greedy exploration
    if epsilon > 0.0 and rng.random() < epsilon:
        random_vals = rng.uniform(0.0, 1.0, size=feasible.sum())
        raw_score[feasible] = random_vals

    # Temperature‑scaled softmax to obtain probabilities
    max_feasible = raw_score[feasible].max()
    # Shift to avoid overflow
    shifted = (raw_score - max_feasible) / temperature
    exp_vals = np.exp(shifted)
    exp_vals[~feasible] = 0.0
    total = exp_vals.sum()
    if total == 0.0:
        # Should not happen, but keep robust
        return np.zeros_like(bins, dtype=np.float64)
    priorities = exp_vals / total

    return priorities
```
