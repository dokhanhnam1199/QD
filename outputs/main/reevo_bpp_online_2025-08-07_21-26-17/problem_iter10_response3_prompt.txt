{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    epsilon: float = 0.02,\n    noise_scale: float = 1e-5,\n    alpha_fit: float = 10.0,\n    target_fit: float = 0.75,\n    alpha_waste: float = 12.0,\n    waste_target: float = 0.05,\n    tie_breaker_scale: float = 1e-12,\n    random_state: Optional[int] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each open bin in an online Bin Packing problem.\n\n    The score is higher for bins that:\n      * fit the item well (fit ratio near ``target_fit``),\n      * leave little waste after placement (waste below ``waste_target``),\n      * break ties deterministically by bin index,\n      * optionally explore via random noise or \u03b5\u2011greedy exploration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining free capacity of each currently open bin.\n    epsilon : float, default 0.02\n        Probability of replacing the deterministic scores with random scores\n        (\u03b5\u2011greedy exploration).\n    noise_scale : float, default 1e-5\n        Scale of uniform additive noise added to each feasible bin's score.\n    alpha_fit : float, default 10.0\n        Logistic steepness for the *fit\u2011ratio* component.\n    target_fit : float, default 0.75\n        Desired fit ratio (item / remaining capacity) where the fit component\n        reaches 0.5.\n    alpha_waste : float, default 12.0\n        Logistic steepness for the *waste* component.\n    waste_target : float, default 0.05\n        Desired waste fraction (relative to bin capacity) where the waste\n        component reaches 0.5.\n    tie_breaker_scale : float, default 1e-12\n        Small multiplier for bin index to break exact ties deterministically.\n    random_state : int or None, default None\n        Seed for the internal RNG (useful for reproducibility).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher = better) for each bin. Infeasible bins receive\n        ``-np.inf`` so they will never be selected by ``np.argmax``.\n    \"\"\"\n    # Ensure proper NumPy array\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n    n_bins = bins_remain_cap.size\n\n    if n_bins == 0:\n        return np.array([], dtype=np.float64)\n\n    # Feasibility mask: can the item fit?\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        # No feasible bin \u2192 all scores -inf\n        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Estimate static bin capacity (assume all bins share the same capacity)\n    bin_capacity = float(np.max(bins_remain_cap))\n    if bin_capacity <= 0.0:\n        # Defensive: capacity non\u2011positive, treat as infeasible\n        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    rng = np.random.default_rng(random_state)\n\n    # ------------------------------------------------------------------\n    # 1) Fit\u2011ratio component (item size relative to remaining capacity)\n    # ------------------------------------------------------------------\n    fit_ratio = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    # Compute ratio only for feasible bins to avoid divide\u2011by\u2011zero warnings\n    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)\n\n    # Logistic: high when fit_ratio \u2248 target_fit\n    # Clip exponent to avoid overflow\n    exp_fit = np.exp(-np.clip(alpha_fit * (fit_ratio - target_fit), -500, 500))\n    fit_score = 1.0 / (1.0 + exp_fit)\n\n    # ------------------------------------------------------------------\n    # 2) Waste component (leftover capacity after placement)\n    # ------------------------------------------------------------------\n    waste_norm = np.clip((bins_remain_cap - item) / bin_capacity, 0.0, 1.0)\n    # Logistic decreasing: small waste \u2192 high score\n    exp_waste = np.exp(np.clip(alpha_waste * (waste_norm - waste_target), -500, 500))\n    waste_score = 1.0 / (1.0 + exp_waste)\n\n    # ------------------------------------------------------------------\n    # Combine components multiplicatively\n    # ------------------------------------------------------------------\n    combined_score = fit_score * waste_score\n\n    # Infeasible bins must be penalised with -inf\n    combined_score[~feasible] = -np.inf\n\n    # ------------------------------------------------------------------\n    # Deterministic tie\u2011breaker (tiny index\u2011based bias)\n    # ------------------------------------------------------------------\n    combined_score += np.arange(n_bins, dtype=np.float64) * tie_breaker_scale\n\n    # ------------------------------------------------------------------\n    # Add small random noise for stochastic tie\u2011breaking\n    # ------------------------------------------------------------------\n    if noise_scale > 0.0:\n        noise = rng.random(n_bins) * noise_scale\n        combined_score[feasible] += noise[feasible]\n\n    # ------------------------------------------------------------------\n    # \u03b5\u2011greedy exploration: occasionally replace scores with random ranks\n    # ------------------------------------------------------------------\n    if epsilon > 0.0 and rng.random() < epsilon:\n        random_scores = np.full_like(combined_score, -np.inf, dtype=np.float64)\n        random_scores[feasible] = rng.random(np.count_nonzero(feasible))\n        combined_score = random_scores\n\n    return combined_score\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n                *, random_state: Optional[int] = None,\n                epsilon_min: float = 0.05,\n                epsilon_max: float = 0.25) -> np.ndarray:\n    \"\"\"\n    Adaptive priority for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    random_state : int or None, optional\n        Seed for reproducibility.\n    epsilon_min, epsilon_max : float, optional\n        Bounds for the exploration probability epsilon.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores; infeasible bins receive -np.inf.\n    \"\"\"\n    # Ensure array\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility mask\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Leftover after placing the item\n    leftover = bins_remain_cap - item\n\n    # Base score: tight fits get higher values\n    eps = 1e-12  # avoid division by zero\n    base = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    base[feasible] = 1.0 / (leftover[feasible] + eps)\n\n    # Adaptive exploration rate based on variance of leftover space\n    lo = leftover[feasible]\n    var = np.var(lo)\n    L = np.max(lo)\n    var_norm = 0.0\n    if L > 0:\n        var_max = (L ** 2) / 4.0  # max variance in [0, L]\n        var_norm = np.clip(var / var_max, 0.0, 1.0)\n\n    epsilon = epsilon_min + (epsilon_max - epsilon_min) * (1.0 - var_norm)\n\n    # Random exploration component\n    rng = np.random.default_rng(random_state)\n    random_score = rng.random(bins_remain_cap.shape)\n\n    # Combine exploitation (tight\u2011fit) and exploration (random)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    priorities[feasible] = (1.0 - epsilon) * base[feasible] + epsilon * random_score[feasible]\n\n    # Deterministic tie\u2011breaker: very small incremental value\n    priorities += np.arange(bins_remain_cap.size, dtype=np.float64) * 1e-12\n\n    return priorities\n\n[Reflection]\nAdapt epsilon using leftover variance, rank bins by\u202f1/(remaining+\u03b5), use tiny deterministic tie\u2011breaker, avoid heavy logistic ops.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}