```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Best‑Fit priority for online Bin Packing.

    For each bin we compute a score that is highest for the bin that will
    leave the smallest leftover capacity after the item is placed.
    Bins that cannot accommodate the item receive a score of -inf
    so they are never chosen.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: Remaining free capacity of each bin.

    Returns:
        np.ndarray of priority scores (same shape as `bins_remain_cap`).
        The bin with the maximal score will be selected.
    """
    # Mask of bins that can actually hold the item
    can_fit = bins_remain_cap >= item

    # Remaining capacity after the item would be placed
    leftover = bins_remain_cap - item

    # Use the negative leftover as priority: smaller leftover → higher (less negative) score
    priorities = np.where(can_fit, -leftover, -np.inf)

    # Optional: break ties with an infinitesimal random jitter (does not affect ordering)
    # This avoids deterministic tie‑breaking which could bias later decisions.
    if np.any(priorities != -np.inf):
        jitter = np.random.rand(*priorities.shape) * 1e-12
        priorities = np.where(priorities != -np.inf, priorities + jitter, priorities)

    return priorities
```
