```python
import numpy as np

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                *,
                epsilon: float = 0.05,
                noise_scale: float = 1e-4,
                alpha_fit: float = 12.0,
                target_fit: float = 0.80,
                alpha_waste: float = 12.0,
                waste_target: float = 0.07,
                alpha_used: float = 10.0,
                used_target: float = 0.40,
                temperature: float | None = None) -> np.ndarray:
    """
    Priority function for online bin packing that combines multiple
    sigmoid‑based criteria, optional noise, ε‑greedy exploration and an
    optional temperature‑scaled softmax.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities in the currently open bins.
    epsilon : float, default 0.05
        Probability of selecting a completely random feasible bin
        (ε‑greedy exploration).
    noise_scale : float, default 1e-4
        Scale of the uniform noise added to the raw scores. The noise
        magnitude is attenuated by (1‑fit_ratio) so that bins that
        almost perfectly fit the item receive less random perturbation.
    alpha_fit, target_fit : float, default 12.0, 0.80
        Parameters of the sigmoid used to score the fit‑ratio
        (item / remaining_capacity).
    alpha_waste, waste_target : float, default 12.0, 0.07
        Parameters of the sigmoid used to score the waste
        (remaining_capacity - item).
    alpha_used, used_target : float, default 10.0, 0.40
        Parameters of the sigmoid used to score the used‑fraction
        ((max_capacity - remaining_capacity) / max_capacity).
    temperature : float or None, default None
        If provided, the final scores are passed through a
        temperature‑scaled softmax so that they sum to one.
        If ``None`` the raw scores are returned.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better).  Feasible
        bins receive a value in [0,1] (or a probability when
        ``temperature`` is set).  Infeasible bins receive ``-np.inf``.
    """
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)

    # Input validation
    if bins_remain_cap.ndim != 1:
        raise ValueError("bins_remain_cap must be a 1‑D array")
    if item <= 0:
        raise ValueError("item size must be positive")
    if not 0 <= epsilon <= 1:
        raise ValueError("epsilon must be between 0 and 1")
    if noise_scale < 0:
        raise ValueError("noise_scale must be non‑negative")
    if temperature is not None and temperature <= 0:
        raise ValueError("temperature must be positive if provided")

    if bins_remain_cap.size == 0:
        return np.array([], dtype=np.float64)

    # Feasible bins mask
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        # No bin can accommodate the item
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    # Estimate of the maximum capacity among current bins
    max_capacity = bins_remain_cap.max()

    # Compute individual components
    # 1. Fit ratio
    fit_ratio = np.empty_like(bins_remain_cap)
    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)
    fit_ratio = np.clip(fit_ratio, 0.0, 1.0)
    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))
    fit_score[~feasible] = 0.0

    # 2. Waste component
    waste = bins_remain_cap - item
    waste_norm = np.clip(waste / max_capacity, 0.0, 1.0)
    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))
    waste_score[~feasible] = 0.0

    # 3. Used‑fraction component
    used_fraction = (max_capacity - bins_remain_cap) / max_capacity
    used_fraction = np.clip(used_fraction, 0.0, 1.0)
    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))
    used_score[~feasible] = 0.0

    # Combined raw priority
    priorities = fit_score * waste_score * used_score

    # Add random noise to break ties and add exploration
    rng = np.random.default_rng()
    if noise_scale > 0.0:
        noise = rng.uniform(-noise_scale, noise_scale, size=priorities.shape)
        # Dampen noise for bins that already have a good fit
        noise *= (1.0 - fit_ratio)
        priorities += noise

    # ε‑greedy: with probability epsilon, choose a random feasible bin
    if rng.random() < epsilon:
        random_scores = rng.random(size=priorities.shape)
        random_scores[~feasible] = -np.inf
        priorities = random_scores

    # Set infeasible bins to -inf
    priorities[~feasible] = -np.inf

    # Optional temperature‑scaled softmax
    if temperature is not None:
        feasible_scores = priorities[feasible]
        if feasible_scores.size > 0:
            max_score = feasible_scores.max()
            exp_scores = np.exp((feasible_scores - max_score) / temperature)
            prob_scores = exp_scores / exp_scores.sum()
            priorities[feasible] = prob_scores

    return priorities
```
