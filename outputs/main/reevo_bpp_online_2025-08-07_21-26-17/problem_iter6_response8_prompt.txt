{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    epsilon: float = 0.05,\n    noise_scale: float = 1e-4,\n    alpha_fit: float = 12.0,\n    target_fit: float = 0.80,\n    alpha_waste: float = 12.0,\n    waste_target: float = 0.07,\n    alpha_used: float = 10.0,\n    used_target: float = 0.40,\n) -> np.ndarray:\n    \"\"\"\n    Multi\u2011sigmoid priority function for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacity of each currently open bin.\n    epsilon : float, optional\n        Probability of replacing the deterministic score with a random ranking.\n    noise_scale : float, optional\n        Scale of the additive uniform noise applied before the \u03b5\u2011greedy decision.\n    alpha_fit, target_fit : float, optional\n        Sigmoid parameters for the fit\u2011ratio component.\n    alpha_waste, waste_target : float, optional\n        Sigmoid parameters for the waste component.\n    alpha_used, used_target : float, optional\n        Sigmoid parameters for the used\u2011fraction component.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.  Infeasible\n        bins receive ``-np.inf``.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Empty array handling\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        # No bin can accommodate the item\n        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Estimate the true bin capacity from the current open bins\n    est_capacity = float(np.max(bins_remain_cap))\n    if est_capacity <= 0:\n        # All bins are full \u2013 impossible to pack\n        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    rng = np.random.default_rng()\n\n    # 1) Fit\u2011ratio component (item size relative to remaining capacity)\n    fit_ratio = np.empty_like(bins_remain_cap, dtype=np.float64)\n    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)\n    fit_ratio[~feasible] = 0.0  # dummy for infeasible bins\n    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))\n\n    # 2) Waste component (leftover capacity after placement)\n    waste_norm = np.clip((bins_remain_cap - item) / est_capacity, 0.0, 1.0)\n    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))\n\n    # 3) Used\u2011fraction component (how much of the bin is already occupied)\n    used_fraction = (est_capacity - bins_remain_cap) / est_capacity\n    # After placement\n    used_fraction_after = np.clip(used_fraction + item / est_capacity, 0.0, 1.0)\n    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction_after - used_target)))\n\n    # Combine the three signals multiplicatively\n    combined_score = fit_score * waste_score * used_score\n    combined_score[~feasible] = -np.inf\n\n    # Add small exploration noise\n    if noise_scale > 0.0:\n        noise = rng.random(bins_remain_cap.shape) * noise_scale\n        combined_score[feasible] += noise[feasible]\n\n    # \u03b5\u2011greedy exploration\n    if epsilon > 0.0 and rng.random() < epsilon:\n        random_score = np.where(feasible, rng.random(bins_remain_cap.shape), -np.inf)\n        combined_score = random_score\n\n    return combined_score\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    epsilon: float = 0.05,\n    noise_scale: float = 1e-4,\n    alpha_fit: float = 12.0,\n    target_fit: float = 0.80,\n    alpha_waste: float = 12.0,\n    waste_target: float = 0.07,\n    alpha_used: float = 10.0,\n    used_target: float = 0.40,\n) -> np.ndarray:\n    \"\"\"\n    Multi\u2011sigmoid priority function for online bin packing.\n\n    For each currently open bin the function returns a priority score that\n    combines three independent sigmoid components:\n\n    * **Fit ratio** \u2013 how close the item size is to the remaining capacity.\n      A ratio above *target_fit* is rewarded.\n    * **Waste** \u2013 the leftover free space after the item is placed.\n      Smaller waste is preferred; waste values below *waste_target* are\n      rewarded strongly.\n    * **Used fraction** \u2013 how much of the bin is already occupied.\n      Partially filled bins are favored, encouraging reuse before opening\n      new bins.\n\n    The three scores are multiplied to form the final priority.  A small\n    uniform noise is added to break ties and an \u03b5\u2011greedy policy can replace\n    the deterministic ranking with a random one with probability *epsilon*.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (0 < item \u2264 bin capacity).\n    bins_remain_cap : array_like\n        1\u2011D array of remaining capacities of the currently open bins.\n    epsilon : float, optional\n        Probability of picking a random feasible bin instead of using the\n        computed priorities.\n    noise_scale : float, optional\n        Scale of the additive noise used to break ties.\n    alpha_fit, target_fit, alpha_waste, waste_target,\n    alpha_used, used_target : float, optional\n        Hyper\u2011parameters of the sigmoid transforms.\n    Returns\n    -------\n    np.ndarray\n        Priority scores; higher is better.  Bins that cannot accommodate\n        the item receive ``-np.inf``.\n    \"\"\"\n    # Convert to a NumPy array of float64 for consistency\n    bins = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Handle the empty\u2011bin case immediately\n    if bins.size == 0:\n        return np.array([], dtype=np.float64)\n\n    # Feasibility mask: bins that can hold the item\n    feasible = bins >= item\n    if not np.any(feasible):\n        # No bin can fit the item\n        return np.full_like(bins, -np.inf, dtype=np.float64)\n\n    # Estimate the true bin capacity from the largest remaining capacity\n    # observed.  This is robust when we have no explicit capacity value.\n    est_capacity = float(np.max(bins))\n    if est_capacity <= 0:\n        est_capacity = 1.0  # Fallback to avoid division by zero\n\n    # ---------- 1) Fit\u2011ratio component ----------\n    fit_ratio = np.empty_like(bins)\n    np.divide(item, bins, out=fit_ratio, where=feasible)\n    fit_ratio[~feasible] = 0.0  # dummy value for infeasible bins\n    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))\n\n    # ---------- 2) Waste component ----------\n    waste = bins - item\n    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)  # Normalised waste [0,1]\n    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))\n\n    # ---------- 3) Used\u2011fraction component ----------\n    used_fraction = (est_capacity - bins) / est_capacity\n    used_fraction[~feasible] = 0.0  # dummy for infeasible bins\n    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))\n\n    # ---------- Combine signals ----------\n    combined_score = fit_score * waste_score * used_score\n\n    # ---------- Add exploration noise ----------\n    rng = np.random.default_rng()\n    if noise_scale > 0.0:\n        noise = rng.random(bins.shape) * noise_scale\n        combined_score += noise\n\n    # ---------- \u03b5\u2011greedy exploration ----------\n    if epsilon > 0.0 and rng.random() < epsilon:\n        random_score = rng.random(bins.shape)\n        random_score[~feasible] = -np.inf\n        return random_score\n\n    # Mark infeasible bins explicitly\n    combined_score[~feasible] = -np.inf\n    return combined_score\n\n[Reflection]\nCache capacity, pre\u2011compute feasibility mask, vectorize sigmoid calculations, minimize noise, limit \u03b5\u2011greedy, handle edge cases early.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}