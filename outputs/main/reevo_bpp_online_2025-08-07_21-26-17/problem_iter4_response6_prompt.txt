{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Compute a priority score for each bin for online bin packing.\n    Bins with higher scores are more desirable for the incoming item.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; higher scores indicate more desirable bins.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item\n    can_fit = bins_remain_cap >= item\n    if not np.any(can_fit):\n        return np.zeros_like(bins_remain_cap)\n\n    # Approximate original bin capacity from the largest remaining capacity\n    bin_capacity = np.max(bins_remain_cap[can_fit])\n\n    # Remaining capacity after placing the item\n    leftover = bins_remain_cap - item\n\n    # Normalized leftover fraction for feasible bins\n    leftover_frac = leftover[can_fit] / bin_capacity\n\n    # Sigmoid function to score waste (small leftover \u2192 high score)\n    k_waste = 12.0\n    waste_sigmoid = 1.0 / (1.0 + np.exp(k_waste * (leftover_frac - 0.5)))\n\n    # Fit ratio: how much of the bin's remaining capacity the item consumes\n    fit_ratio = item / (bins_remain_cap[can_fit] + 1e-12)\n\n    # Base priority for feasible bins\n    base_priority = np.zeros_like(bins_remain_cap)\n    base_priority[can_fit] = fit_ratio * waste_sigmoid\n\n    # Forecast next item size (heuristic: 80\u202f% of the current item)\n    next_item_est = item * 0.8\n\n    # Penalize bins that leave too much leftover compared to the forecast\n    future_penalty = 1.0 / (1.0 + np.exp(10.0 * (leftover[can_fit] - next_item_est)))\n    base_priority[can_fit] *= future_penalty\n\n    # Boost exact\u2011fit bins\n    exact_fit = np.logical_and(can_fit, np.isclose(leftover, 0.0, atol=1e-8))\n    base_priority[exact_fit] *= 1.5\n\n    # Dynamic exploration\u2013exploitation trade\u2011off\n    min_left = np.min(leftover[can_fit])\n    max_left = np.max(leftover[can_fit])\n    dynamic_eps = np.clip(\n        0.05 + 0.85 * (max_left - min_left) / (max_left + 1e-12),\n        0.05,\n        0.9,\n    )\n\n    rng = np.random.default_rng()\n    noise = rng.normal(scale=1e-6, size=bins_remain_cap.shape)\n\n    # Softmax with temperature to bias low waste\n    temperature = 0.3\n    raw_scores = base_priority + noise\n    exp_scores = np.exp(raw_scores / temperature)\n    exp_scores[~can_fit] = 0.0\n    softmax_scores = exp_scores / np.sum(exp_scores)\n\n    # Random exploration component\n    random_scores = rng.random(bins_remain_cap.shape)\n\n    final_scores = (1.0 - dynamic_eps) * softmax_scores + dynamic_eps * random_scores\n    final_scores[~can_fit] = 0.0\n\n    return final_scores\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n                bins_remain_cap: np.ndarray,\n                temperature: float = 1.0,\n                next_item_estimate: float | None = None,\n                weight_fit: float = 1.0,\n                weight_future: float = 1.0,\n                weight_balance: float = 0.5) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem (BPP).\n\n    This heuristic combines several signals:\n    * **Tight fit** \u2013 prefers bins where the leftover capacity after placing\n      the current item is small.\n    * **Future\u2011item feasibility** \u2013 if an estimate of the next item's size is\n      provided, bins that will still be able to accommodate that item receive\n      a bonus.\n    * **Bin\u2011balance** \u2013 encourages the remaining capacities of bins to stay\n      close to the average, avoiding a situation where some bins are almost\n      empty while others are nearly full.\n\n    The raw scores are transformed into a probability\u2011like priority vector\n    using a temperature\u2011controlled softmax. Bins that cannot accommodate the\n    current item receive a priority of zero.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacities of the bins.\n    temperature : float, optional\n        Positive temperature controlling the softness of the softmax.\n        Smaller values make the selection more deterministic.\n    next_item_estimate : float or None, optional\n        Estimated size of the next item. If given, bins that will still have\n        enough capacity for that next item after placing the current one get\n        a bonus.\n    weight_fit : float, optional\n        Weight for the tight\u2011fit component.\n    weight_future : float, optional\n        Weight for the future\u2011item feasibility component.\n    weight_balance : float, optional\n        Weight for the bin\u2011balance component.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (sum to 1 over feasible bins, zero for infeasible\n        bins).\n    \"\"\"\n    # Ensure a 1\u2011D float array.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64).ravel()\n\n    # Feasibility mask: bins that can accommodate the current item.\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        # No bin can accept the item.\n        return np.zeros_like(bins_remain_cap, dtype=np.float64)\n\n    # Remaining capacity after placing the item.\n    leftover = bins_remain_cap - item  # >= 0 for feasible bins.\n\n    # ---- Component 1: Tight fit (smaller leftover -> higher score) ----\n    # Using negative leftover so that a smaller leftover yields a larger value.\n    fit_score = -leftover * weight_fit\n\n    # ---- Component 2: Future\u2011item feasibility (optional) ----\n    if next_item_estimate is not None:\n        # Binary bonus for bins that would still be able to host the next item.\n        future_feasibility = (leftover >= next_item_estimate).astype(np.float64)\n        future_score = weight_future * future_feasibility\n    else:\n        future_score = 0.0\n\n    # ---- Component 3: Bin balance ----\n    # Encourage bins whose remaining capacity is close to the mean remaining.\n    avg_remain = np.mean(bins_remain_cap)\n    balance_score = -np.abs(bins_remain_cap - avg_remain) * weight_balance\n\n    # Combine components into a raw score.\n    raw_score = fit_score + future_score + balance_score\n\n    # Infeasible bins should never be selected \u2192 assign -inf before softmax.\n    raw_score = np.where(feasible, raw_score, -np.inf)\n\n    # ---- Temperature\u2011controlled softmax ----\n    eps = 1e-12\n    temp = max(temperature, eps)  # avoid division by zero.\n    max_raw = np.max(raw_score)   # finite because at least one feasible bin.\n    # Subtract max for numerical stability.\n    exp_scores = np.exp((raw_score - max_raw) / temp)\n    # exp(-inf) = 0, so infeasible bins contribute nothing.\n    sum_exp = np.sum(exp_scores)\n    if sum_exp == 0.0:\n        # Guard against pathological cases.\n        priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    else:\n        priorities = exp_scores / sum_exp\n\n    return priorities\n\n[Reflection]\nCombine tight\u2011fit, future feasibility, and balance terms; weight them; apply temperature\u2011softmax; avoid random noise.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}