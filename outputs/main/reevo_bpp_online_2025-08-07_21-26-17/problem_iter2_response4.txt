```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Smooth‑sigmoid priority for the online Bin Packing Problem.

    For each currently open bin we compute a score that rewards:
      * a tight fit – the item occupies a large fraction of the free space;
      * little waste – the leftover capacity after placement is small.

    Both criteria are transformed by logistic (sigmoid) functions and combined
    multiplicatively.  Bins that cannot accommodate the item receive ``-np.inf``
    so they are never selected.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item ≤ bin capacity).
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of each open bin.

    Returns
    -------
    np.ndarray
        Array of priority scores (higher is better) with the same shape as
        ``bins_remain_cap``.  Infeasible bins are assigned ``-np.inf``.
    """
    # Ensure a NumPy array of floats.
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)

    n_bins = bins_remain_cap.shape[0]

    # Default: infeasible -> -inf.
    priorities = np.full(n_bins, -np.inf, dtype=np.float64)

    # No bins at all → return empty priority vector.
    if n_bins == 0:
        return priorities

    # Feasibility mask.
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        return priorities

    # ----------------------------------------------------------------------
    # 1) Fit‑ratio component – fraction of free space used by the item.
    # ----------------------------------------------------------------------
    # Ratio in (0, 1] for feasible bins, 0 elsewhere (value irrelevant there).
    fit_ratio = np.zeros_like(bins_remain_cap)
    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)

    # Sigmoid parameters (tuned for a steep transition around 0.75).
    alpha_fit = 12.0          # steepness
    target_fit = 0.75         # ratio where score ≈ 0.5
    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))

    # ----------------------------------------------------------------------
    #  : Waste component – encourage small leftover space.
    # ----------------------------------------------------------------------
    # Estimate the true bin capacity.  The maximum remaining capacity among
    # open bins is a good proxy (an empty bin would have full capacity).
    # If even the largest remaining capacity is smaller than the item,
    # fall back to the item size itself to avoid division by zero.
    est_capacity = max(np.max(bins_remain_cap), item)

    waste = bins_remain_cap - item                # may be negative for infeasibles
    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)  # normalised waste ∈ [0,1]

    # Sigmoid parameters for waste (high score for waste ≤ 10 % of capacity).
    alpha_waste = 10.0
    waste_target = 0.10
    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))

    # ----------------------------------------------------------------------
    # 2) Combine the two signals multiplicatively.
    # ----------------------------------------------------------------------
    combined_score = fit_score * waste_score

    # Assign scores only to feasible bins.
    priorities[feasible] = combined_score[feasible]

    # ----------------------------------------------------------------------
    # 3) Tiny deterministic tie‑breaker – favour lower‑index bins when scores
    #    are numerically identical.
    # ----------------------------------------------------------------------
    epsilon = 1e-9
    indices = np.arange(n_bins, dtype=np.float64)
    priorities[feasible] -= epsilon * indices[feasible]

    return priorities
```
