{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    temperature: float = 1.0,\n    fit_weight: float = 0.5,\n    randomness: float = 1e-4,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing that blends leftover minimization\n    with a softmax temperature, includes fit ratio weighting, and adds\n    tie-breaking randomness.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the current free capacity in each bin.\n    temperature : float, optional\n        Temperature parameter for the softmax term. A small value\n        concentrates the probability mass on bins with the smallest\n        leftover, while a large value yields a more uniform distribution.\n        Must be positive.\n    fit_weight : float, optional\n        Exponent applied to the fit ratio (item / remaining capacity)\n        to weight bins where the item fits well relative to the remaining\n        space.  Default is 0.5.\n    randomness : float, optional\n        Scale of the tie\u2011breaking random noise added to each score.\n        Small values preserve the ordering induced by the deterministic\n        part of the score. Default is 1e-4.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores, same shape as ``bins_remain_cap``.\n        Bins that cannot accommodate ``item`` receive a score of\n        ``-np.inf`` and will never be selected.\n\n    Notes\n    -----\n    The priority score is computed as\n\n        score = exp(-leftover / temperature) * (fit_ratio ** fit_weight)\n\n    where\n\n        leftover  = bins_remain_cap - item  (for feasible bins)\n        fit_ratio = item / bins_remain_cap\n\n    A small random perturbation is added to ``score`` to break ties\n    deterministically.  The function is vectorised for efficiency.\n    \"\"\"\n    # Ensure we work with a float array\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Empty array handling\n    if bins_remain_cap.size == 0:\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if temperature <= 0.0:\n        raise ValueError(\"temperature must be a positive number\")\n\n    # Identify bins that can accept the item\n    feasible = bins_remain_cap >= item\n\n    # Initialize all priorities to -inf (infeasible bins)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if not feasible.any():\n        # No bin can accommodate the item; return -inf for all bins\n        return priorities\n\n    # Compute leftover and fit ratio only for feasible bins\n    leftover = bins_remain_cap[feasible] - item\n    fit_ratio = item / bins_remain_cap[feasible]\n\n    # Compute the deterministic part of the score\n    deterministic_score = np.exp(-leftover / temperature) * (fit_ratio ** fit_weight)\n\n    # Add tiny random noise for tie-breaking\n    noise = np.random.uniform(-randomness, randomness, size=deterministic_score.shape)\n\n    scores = deterministic_score + noise\n\n    # Assign scores to feasible bins\n    priorities[feasible] = scores\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    epsilon: float = 0.05,\n    noise_scale: float = 1e-4,\n    # sigmoid hyper\u2011parameters\n    alpha_fit: float = 12.0,\n    target_fit: float = 0.80,\n    alpha_waste: float = 12.0,\n    waste_target: float = 0.07,\n    alpha_used: float = 10.0,\n    used_target: float = 0.40,\n) -> np.ndarray:\n    \"\"\"\n    Multi\u2011sigmoid priority function for the online Bin Packing Problem.\n\n    The function evaluates each open bin with three sigmoid\u2011based criteria\n    and multiplies the resulting scores:\n\n    1. **Fit\u2011ratio** \u2013 item size relative to the remaining capacity.\n       A ratio close to ``target_fit`` (default 0.80) yields a score around 0.5;\n       larger ratios (tighter fits) are rewarded.\n\n    2. **Waste** \u2013 leftover capacity after placing the item.\n       Small waste (\u2264 ``waste_target`` of the bin capacity) receives a high score.\n\n    3. **Used\u2011fraction** \u2013 how much of the bin is already occupied.\n       Bins that are already partially filled (\u2248 ``used_target``) are favoured,\n       encouraging the algorithm to fill existing bins before opening new ones.\n\n    Random exploration noise is added to break ties, and an \u03b5\u2011greedy\n    mechanism can replace the deterministic score with a pure random\n    ranking with probability ``epsilon``.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (0 < item \u2264 bin capacity).\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining free capacity of each currently open bin.\n    epsilon : float, optional\n        Probability of choosing a completely random feasible bin (default 0.05).\n    noise_scale : float, optional\n        Scale of the additive uniform noise (default 1e\u20114).  Noise is added\n        after the deterministic score and before the \u03b5\u2011greedy decision.\n    alpha_fit, target_fit, alpha_waste, waste_target, alpha_used, used_target :\n        Hyper\u2011parameters of the sigmoid transforms.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) with the same shape as\n        ``bins_remain_cap``.  Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Ensure a NumPy array of float64.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Edge case: no bins at all.\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n\n    # Initialise all priorities with -inf (infeasible).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Feasibility mask: bins that can accommodate the item.\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        # Nothing fits \u2013 return all -inf.\n        return priorities\n\n    # Estimate the true bin capacity.\n    # When an empty bin exists its remaining capacity equals the capacity.\n    # Otherwise we use the maximum observed remaining capacity as an estimate.\n    eps = 1e-12\n    est_capacity = float(np.max(bins_remain_cap)) if bins_remain_cap.size else 1.0\n    est_capacity = max(est_capacity, eps)\n\n    # --------------------------------------------------------------\n    # 1) Fit\u2011ratio component\n    # --------------------------------------------------------------\n    # Ratio of item size to remaining capacity (only defined for feasible bins).\n    fit_ratio = np.empty_like(bins_remain_cap, dtype=np.float64)\n    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)\n    fit_ratio[~feasible] = 0.0  # dummy value for infeasible bins\n\n    # Sigmoid: high score when fit_ratio > target_fit.\n    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))\n\n    # --------------------------------------------------------------\n    # 2) Waste component\n    # --------------------------------------------------------------\n    waste = bins_remain_cap - item               # may be negative for infeasibles.\n    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)  # normalised waste \u2208 [0,1].\n\n    # Sigmoid decreasing with waste.\n    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))\n\n    # --------------------------------------------------------------\n    # 3) Used\u2011fraction component\n    # --------------------------------------------------------------\n    used_fraction = (est_capacity - bins_remain_cap) / est_capacity\n    used_fraction[~feasible] = 0.0  # dummy for infeasibles\n\n    # Sigmoid rewarding bins that are already partially filled.\n    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))\n\n    # --------------------------------------------------------------\n    # Combine the three signals multiplicatively.\n    # --------------------------------------------------------------\n    combined_score = fit_score * waste_score * used_score\n    priorities[feasible] = combined_score[feasible]\n\n    # --------------------------------------------------------------\n    # Exploration noise (always added before \u03b5\u2011greedy decision).\n    # --------------------------------------------------------------\n    if noise_scale > 0.0:\n        rng = np.random.default_rng()\n        noise = rng.random(bins_remain_cap.shape) * noise_scale\n        priorities[feasible] += noise[feasible]\n\n    # --------------------------------------------------------------\n    # \u03b5\u2011greedy: with probability epsilon replace with a random ranking.\n    # --------------------------------------------------------------\n    if epsilon > 0.0 and np.random.rand() < epsilon:\n        rng = np.random.default_rng()\n        random_score = np.where(feasible, rng.random(bins_remain_cap.shape), -np.inf)\n        priorities = random_score\n\n    return priorities\n\n[Reflection]\nUse multi\u2011sigmoid features, estimate capacity, combine multiplicatively, add \u03b5\u2011greedy exploration and tiny noise, tune alphas.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}