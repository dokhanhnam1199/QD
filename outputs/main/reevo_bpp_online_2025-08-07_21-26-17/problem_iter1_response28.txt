```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    epsilon: float = 0.1,
    noise_scale: float = 1e-6,
) -> np.ndarray:
    """
    Epsilon‑greedy priority function for the online Bin Packing Problem.

    The function prefers the *Best‑Fit* bin (the feasible bin that will have the
    smallest remaining capacity after the item is placed). With probability
    ``epsilon`` it explores by assigning a random score to each feasible bin.
    A tiny random ``noise`` term is added in the exploitation case to break ties.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array containing the remaining free capacity of each currently open bin.
    epsilon : float, optional
        Exploration probability (default 0.1). ``epsilon = 0`` disables exploration,
        ``epsilon = 1`` selects a completely random feasible bin.
    noise_scale : float, optional
        Scale of the tie‑breaking noise added in exploitation mode (default 1e-6).

    Returns
    -------
    np.ndarray
        Array of the same shape as ``bins_remain_cap`` with a priority score for
        each bin. Higher scores indicate higher preference. Bins that cannot hold
        the item receive ``-np.inf`` (so they will never be selected unless all
        bins are infeasible).
    """
    # Identify bins that can actually accommodate the item.
    feasible = bins_remain_cap >= item

    # ----------------- Exploitation (Best‑Fit) -----------------
    # Compute leftover capacity if the item were placed in each feasible bin.
    leftover = bins_remain_cap - item
    # Best‑Fit prefers the smallest leftover (i.e. largest negative leftover).
    best_fit_score = np.where(feasible, -leftover, -np.inf)

    # ------------------- Exploration -------------------------
    # Assign a uniform random score to each feasible bin.
    random_score = np.where(feasible, np.random.rand(bins_remain_cap.shape[0]), -np.inf)

    # Decide whether to explore or exploit.
    if np.random.rand() < epsilon:
        # Exploration: use random scores.
        priorities = random_score
    else:
        # Exploitation: use best‑fit scores, adding tiny noise to break ties.
        noise = np.random.rand(bins_remain_cap.shape[0]) * noise_scale
        priorities = best_fit_score + noise

    return priorities
```
