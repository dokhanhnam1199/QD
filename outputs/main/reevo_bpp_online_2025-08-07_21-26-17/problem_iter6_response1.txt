```python
import numpy as np

# Minimum and maximum exploration probabilities.
_EPSILON_MIN = 0.05
_EPSILON_MAX = 0.25

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive priority for the online Bin Packing Problem.

    A tight‑fit score (inverse leftover space) is blended with a random
    exploration term.  The blending weight (epsilon) adapts to the variance
    of the leftover space among bins that can accommodate the item:
    low variance ⇒ higher epsilon (more exploration), high variance ⇒ lower
    epsilon (more exploitation).

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the current bins.

    Returns
    -------
    np.ndarray
        Priority scores (higher = more desirable).  Infeasible bins receive
        ``-np.inf`` so they are never selected.
    """
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item.
    feasible = caps >= item
    if not np.any(feasible):
        return np.full_like(caps, -np.inf, dtype=float)

    # Compute leftover capacity if the item were placed.
    leftover = caps - item

    # Base priority: inverse leftover (tight fits get larger scores).
    eps = 1e-12  # avoids division by zero.
    base = np.where(feasible, 1.0 / (leftover + eps), 0.0)

    # --- Adaptive epsilon ----------------------------------------------------
    # Variance of the leftover among feasible bins.
    lo = leftover[feasible]
    var = np.var(lo)

    # Upper bound for variance of a bounded interval [0, L] is L^2 / 4.
    L = np.max(lo)
    if L > 0:
        var_max = (L * L) / 4.0
        var_norm = np.clip(var / var_max, 0.0, 1.0)
    else:
        var_norm = 0.0

    # More variance → smaller epsilon (more exploitation).
    epsilon = _EPSILON_MIN + (_EPSILON_MAX - _EPSILON_MIN) * (1.0 - var_norm)

    # --- Exploration component -----------------------------------------------
    rng = np.random.default_rng()
    random_score = rng.random(caps.shape)

    # Blend exploitation (tight‑fit) and exploration (random).
    blended = (1.0 - epsilon) * base + epsilon * random_score

    # Infeasible bins get -inf to guarantee they are never chosen.
    priorities = np.where(feasible, blended, -np.inf)
    return priorities
```
