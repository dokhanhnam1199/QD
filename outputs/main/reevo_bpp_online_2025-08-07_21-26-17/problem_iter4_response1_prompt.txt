{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    temperature: float = 1.0,\n    fit_weight: float = 0.5,\n    randomness: float = 1e-4,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing that blends leftover minimization\n    with a softmax temperature, includes fit ratio weighting, and adds\n    tie-breaking randomness.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the current free capacity in each bin.\n    temperature : float, optional\n        Temperature parameter for the softmax term. A small value\n        concentrates the probability mass on bins with the smallest\n        leftover, while a large value yields a more uniform distribution.\n        Must be positive.\n    fit_weight : float, optional\n        Exponent applied to the fit ratio (item / remaining capacity)\n        to weight bins where the item fits well relative to the remaining\n        space.  Default is 0.5.\n    randomness : float, optional\n        Scale of the tie\u2011breaking random noise added to each score.\n        Small values preserve the ordering induced by the deterministic\n        part of the score. Default is 1e-4.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores, same shape as ``bins_remain_cap``.\n        Bins that cannot accommodate ``item`` receive a score of\n        ``-np.inf`` and will never be selected.\n\n    Notes\n    -----\n    The priority score is computed as\n\n        score = exp(-leftover / temperature) * (fit_ratio ** fit_weight)\n\n    where\n\n        leftover  = bins_remain_cap - item  (for feasible bins)\n        fit_ratio = item / bins_remain_cap\n\n    A small random perturbation is added to ``score`` to break ties\n    deterministically.  The function is vectorised for efficiency.\n    \"\"\"\n    # Ensure we work with a float array\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Empty array handling\n    if bins_remain_cap.size == 0:\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if temperature <= 0.0:\n        raise ValueError(\"temperature must be a positive number\")\n\n    # Identify bins that can accept the item\n    feasible = bins_remain_cap >= item\n\n    # Initialize all priorities to -inf (infeasible bins)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if not feasible.any():\n        # No bin can accommodate the item; return -inf for all bins\n        return priorities\n\n    # Compute leftover and fit ratio only for feasible bins\n    leftover = bins_remain_cap[feasible] - item\n    fit_ratio = item / bins_remain_cap[feasible]\n\n    # Compute the deterministic part of the score\n    deterministic_score = np.exp(-leftover / temperature) * (fit_ratio ** fit_weight)\n\n    # Add tiny random noise for tie-breaking\n    noise = np.random.uniform(-randomness, randomness, size=deterministic_score.shape)\n\n    scores = deterministic_score + noise\n\n    # Assign scores to feasible bins\n    priorities[feasible] = scores\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Softmax\u2011based priority for online bin packing that balances tight packing\n    (small leftover) with load\u2011balancing across bins.\n\n    The score for each feasible bin i is:\n        s_i = - (remaining capacity after placement)\n              - \u03b1 * variance_of_remaining_capacities_after_placement\n\n    The scores are transformed with a softmax (exp) so that the highest score\n    corresponds to the highest priority. Infeasible bins receive a priority of 0.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority values for each bin (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Ensure input is a NumPy array of floats\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item\n    feasible = bins_remain_cap >= item\n\n    # If no bin can accommodate the item, return zeros (no feasible bin)\n    if not feasible.any():\n        return np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Remaining capacity after placing the item in each bin\n    leftover = bins_remain_cap - item\n\n    # Weight for the variance term (tunable)\n    alpha = 0.5\n\n    # Number of bins\n    n_bins = bins_remain_cap.shape[0]\n\n    # Pre\u2011compute aggregate statistics of the current remaining capacities\n    total_sum = bins_remain_cap.sum()\n    total_sq_sum = np.square(bins_remain_cap).sum()\n\n    # After placing the item, total remaining capacity is reduced by `item`\n    new_total_sum = total_sum - item\n\n    # Variance of the remaining capacities if the item were placed in bin i.\n    # Computed without copying the array:\n    #   var_i = (total_sq_sum - 2*item*bins_remain_cap[i] + item**2) / n_bins\n    #           - (new_total_sum / n_bins)**2\n    var_after = (total_sq_sum - 2 * item * bins_remain_cap + item ** 2) / n_bins \\\n                - (new_total_sum / n_bins) ** 2\n\n    # Raw scores: penalize leftover and penalize variance (to promote load balance)\n    raw_scores = -leftover - alpha * var_after\n\n    # Infeasible bins should not be selected: assign -inf (exp(-inf)=0)\n    raw_scores = np.where(feasible, raw_scores, -np.inf)\n\n    # Softmax transformation for numerical stability\n    max_score = np.max(raw_scores[feasible])\n    shifted = raw_scores - max_score\n    priorities = np.exp(shifted)  # infeasible bins become 0\n\n    return priorities\n\n[Reflection]\nBlend leftover minimization, fit ratio, and variance; tune temperature and alpha; use softmax; avoid random tie\u2011break.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}