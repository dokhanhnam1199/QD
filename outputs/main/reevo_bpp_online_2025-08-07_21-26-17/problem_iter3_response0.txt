```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for each bin for online bin packing.
    Bins with higher scores are more desirable for the incoming item.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacity of each bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; higher scores indicate more desirable bins.
    """
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
        return np.zeros_like(bins_remain_cap)

    # Approximate original bin capacity from the largest remaining capacity
    bin_capacity = np.max(bins_remain_cap[can_fit])

    # Remaining capacity after placing the item
    leftover = bins_remain_cap - item

    # Normalized leftover fraction for feasible bins
    leftover_frac = leftover[can_fit] / bin_capacity

    # Sigmoid function to score waste (small leftover → high score)
    k_waste = 12.0
    waste_sigmoid = 1.0 / (1.0 + np.exp(k_waste * (leftover_frac - 0.5)))

    # Fit ratio: how much of the bin's remaining capacity the item consumes
    fit_ratio = item / (bins_remain_cap[can_fit] + 1e-12)

    # Base priority for feasible bins
    base_priority = np.zeros_like(bins_remain_cap)
    base_priority[can_fit] = fit_ratio * waste_sigmoid

    # Forecast next item size (heuristic: 80 % of the current item)
    next_item_est = item * 0.8

    # Penalize bins that leave too much leftover compared to the forecast
    future_penalty = 1.0 / (1.0 + np.exp(10.0 * (leftover[can_fit] - next_item_est)))
    base_priority[can_fit] *= future_penalty

    # Boost exact‑fit bins
    exact_fit = np.logical_and(can_fit, np.isclose(leftover, 0.0, atol=1e-8))
    base_priority[exact_fit] *= 1.5

    # Dynamic exploration–exploitation trade‑off
    min_left = np.min(leftover[can_fit])
    max_left = np.max(leftover[can_fit])
    dynamic_eps = np.clip(
        0.05 + 0.85 * (max_left - min_left) / (max_left + 1e-12),
        0.05,
        0.9,
    )

    rng = np.random.default_rng()
    noise = rng.normal(scale=1e-6, size=bins_remain_cap.shape)

    # Softmax with temperature to bias low waste
    temperature = 0.3
    raw_scores = base_priority + noise
    exp_scores = np.exp(raw_scores / temperature)
    exp_scores[~can_fit] = 0.0
    softmax_scores = exp_scores / np.sum(exp_scores)

    # Random exploration component
    random_scores = rng.random(bins_remain_cap.shape)

    final_scores = (1.0 - dynamic_eps) * softmax_scores + dynamic_eps * random_scores
    final_scores[~can_fit] = 0.0

    return final_scores
```
