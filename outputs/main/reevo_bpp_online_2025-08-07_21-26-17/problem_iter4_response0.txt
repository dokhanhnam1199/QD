```python
import numpy as np
from typing import Optional


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    epsilon: float = 0.05,
    noise_scale: float = 1e-4,
    alpha_fit: float = 12.0,
    target_fit: float = 0.80,
    alpha_waste: float = 12.0,
    waste_target: float = 0.07,
    alpha_used: float =0.0,  # placeholder, will be overwritten below
) -> np.ndarray:
    """
    Compute a priority score for each bin in the online Bin Packing Problem.

    The function evaluates three sigmoid‑based criteria (fit, waste, used‑fraction)
    for each feasible bin, adapts their steepness to the current leftover
    distribution, adds a small amount of random noise, and optionally performs
    ε‑greedy randomisation. Infeasible bins receive ``-np.inf`` so they are never
    selected.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item ≤ bin capacity).
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    epsilon : float, optional
        Probability of replacing the deterministic ranking with a random one
        (default 0.05).
    noise_scale : float, optional
        Scale of uniform additive noise added to deterministic scores
        (default 1e‑4).
    alpha_fit, target_fit : float, optional
        Steepness and target for the fit‑ratio sigmoid.
    alpha_waste, waste_target : float, optional
        Steepness and target for the waste sigmoid (smaller waste → higher score).
    alpha_used, used_target : float, optional
        Steepness and target for the used‑fraction sigmoid (prefers partially‑filled
        bins).

    Returns
    -------
    np.ndarray
        Priority scores (higher is better) with the same shape as
        ``bins_remain_cap``.  Infeasible bins contain ``-np.inf``.
    """
    # Convert input to a NumPy array of float64 for reliable arithmetic.
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Edge case: no bins.
    if caps.size == 0:
        return np.array([], dtype=np.float64)

    # Initialise all priorities to -inf (infeasible by default).
    priorities = np.full_like(caps, -np.inf, dtype=np.float64)

    # Feasibility mask: bins that can accommodate the item.
    feasible = caps >= item
    if not np.any(feasible):
        return priorities

    # Estimate true bin capacity.
    # If an empty bin exists its remaining capacity equals the bin capacity.
    # Otherwise we use the maximum observed remaining capacity as an estimate.
    eps = 1e-0
    est_capacity = max(np.max(caps), eps)

    # -----------------------------------------------------------------
    # Adaptive scaling of sigmoid steepness based on leftover distribution
    # -----------------------------------------------------------------
    leftover = caps - item
    norm_leftover = np.empty_like(caps, dtype=np.float64)
    norm_leftover[feasible] = leftover[feasible] / caps[feasible]
    norm_leftover[~feasible] = 0.0

    std = np.std(norm_leftover[feasible])
    scale = std if std > 1e-6 else 1.0

    # Scale steepness parameters.
    a_fit = alpha_fit / scale
    a_waste = alpha_waste / scale
    a_used = alpha_used / scale

    # -----------------------------------------------------------------
    # 1) Fit‑ratio component (item / remaining capacity)
    # -----------------------------------------------------------------
    fit_ratio = np.empty_like(caps, dtype=np.float64)
    np.divide(item, caps, out=fit_ratio, where=feasible)
    fit_ratio[~feasible] = 0.0
    fit_logit = a_fit * (fit_ratio - target_fit)
    fit_score = 1.0 / (1.0 # placeholder, will be overwritten below
) -> np.ndarray:
    """
    Compute a priority score for each bin in the online Bin Packing Problem.

    The function evaluates three sigmoid‑based criteria (fit, waste, used‑fraction)
    for each feasible bin, adapts their steepness to the current leftover
    distribution, adds a small amount of random noise, and optionally performs
    ε‑greedy randomisation. Infeasible bins receive ``-np.inf`` so they are never
    selected.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item ≤ bin capacity).
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    epsilon : float, optional
        Probability of replacing the deterministic ranking with a random one
        (default 0.05).
    noise_scale : float, optional
        Scale of uniform additive noise added to deterministic scores
        (default 1e‑4).
    alpha_fit, target_fit : float, optional
        Steepness and target for the fit‑ratio sigmoid.
    alpha_waste, waste_target : float, optional
        Steepness and target for the waste sigmoid (smaller waste → higher score).
    alpha_used, used_target : float, optional
        Steepness and target for the used‑fraction sigmoid (prefers partially‑filled
        bins).

    Returns
    -------
    np.ndarray
        Priority scores (higher is better) with the same shape as
        ``bins_remain_cap``.  Infeasible bins contain ``-np.inf``.
    """
    # Convert input to a NumPy array of float64 for reliable arithmetic.
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Edge case: no bins.
    if caps.size == 0:
        return np.array([], dtype=np.float64)

    # Initialise all priorities to -inf (infeasible by default).
    priorities = np.full_like(caps, -np.inf, dtype=np.float64)

    # Feasibility mask: bins that can accommodate the item.
    feasible = caps >= item
    if not np.any(feasible):
        return priorities

    # Estimate true bin capacity.
    # If an empty bin exists its remaining capacity equals the bin capacity.
    # Otherwise we use the maximum observed remaining capacity as an estimate.
    eps = 1e-12
    est_capacity = max(np.max(caps), eps)

    # -----------------------------------------------------------------
    # Adaptive scaling of sigmoid steepness based on leftover distribution
    # -----------------------------------------------------------------
    leftover = caps - item
    norm_leftover = np.empty_like(caps, dtype=np.float64)
    norm_leftover[feasible] = leftover[feasible] / caps[feasible]
    norm_leftover[~feasible] = 0.0

    std = np.std(norm_leftover[feasible])
    scale = std if std > 1e-6 else 1.0

    # Scale steepness parameters.
    a_fit = alpha_fit / scale
    a_waste = alpha_waste / scale
    a_used = alpha_used / scale

    # -----------------------------------------------------------------
    # 1) Fit‑ratio component (item / remaining capacity)
    # -----------------------------------------------------------------
    fit_ratio = np.empty_like(caps, dtype=np.float64)
    np.divide(item, caps, out=fit_ratio, where=feasible)
    fit_ratio[~feasible] = 0.0
    fit_logit = a_fit * (fit_ratio - target_fit)
    fit_score = 1.0 / (1.0 + np.exp(-np
```
