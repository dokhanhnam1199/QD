```python
import numpy as np
from typing import Optional

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    random_state: Optional[int] = None,
    epsilon_min: float = 0.05,
    epsilon_max: float = 0.25,
    tie_breaker_scale: float = 1e-12,
    eps: float = 1e-12,
) -> np.ndarray:
    """
    Adaptive priority for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    random_state : int or None, optional
        Seed for reproducibility of the random exploration component.
    epsilon_min, epsilon_max : float, optional
        Minimum and maximum exploration probability. The actual epsilon is
        adapted based on the variance of leftover space among feasible bins.
    tie_breaker_scale : float, optional
        Tiny coefficient to break exact ties deterministically by bin index.
    eps : float, optional
        Small constant to avoid division by zero when computing the base score.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; infeasible bins receive ``-np.inf``.
    """
    # Ensure numpy array
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)

    # Feasibility mask: can the item fit into the bin?
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    # Compute leftover capacity after placing the item
    leftover = bins_remain_cap - item

    # Base exploitation score: tighter fits get higher scores
    base_score = np.zeros_like(bins_remain_cap, dtype=np.float64)
    base_score[feasible] = 1.0 / (leftover[feasible] + eps)

    # Adaptive epsilon based on variance of leftover space among feasible bins
    lo = leftover[feasible]
    var = np.var(lo)  # population variance (ddof=0)
    max_lo = np.max(lo)
    if max_lo > 0.0:
        # Max possible variance for values in [0, max_lo] is (max_lo^2)/4
        var_max = (max_lo ** 2) / 4.0
        var_norm = np.clip(var / var_max, 0.0, 1.0)
    else:
        var_norm = 0.0
    epsilon = epsilon_min + (epsilon_max - epsilon_min) * (1.0 - var_norm)

    # Random exploration component
    rng = np.random.default_rng(random_state)
    random_score = rng.random(bins_remain_cap.shape)

    # Combine exploitation and exploration
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    priorities[feasible] = (
        (1.0 - epsilon) * base_score[feasible] + epsilon * random_score[feasible]
    )

    # Deterministic tie‑breaker (tiny index‑based bias)
    priorities += np.arange(bins_remain_cap.size, dtype=np.float64) * tie_breaker_scale

    return priorities
```
