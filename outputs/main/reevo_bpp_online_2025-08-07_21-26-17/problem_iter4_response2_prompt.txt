{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Adaptive priority for the online Bin Packing Problem.\n\n    This heuristic blends a First\u2011Fit style index preference with a\n    Worst\u2011Fit style remaining\u2011capacity preference.  The relative weight of\n    the two components changes smoothly with the current load of the\n    bin set: when bins are largely empty the algorithm behaves like\n    First\u2011Fit; as the bins become increasingly full it gradually turns\n    into a Worst\u2011Fit strategy.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.  Must be\n        non\u2011negative.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; the highest score corresponds to\n        the bin that will receive the item.  Infeasible bins receive\n        ``-np.inf``.\n    \"\"\"\n    # Ensure float type to avoid integer overflow when computing differences\n    bins_remain_cap = bins_remain_cap.astype(float, copy=False)\n\n    # Feasible bins: those that can accommodate the item\n    feasible = bins_remain_cap >= item\n\n    # Initialise all priorities to -inf (unfeasible)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # If no bin can hold the item, return immediately\n    if not np.any(feasible):\n        return priorities\n\n    # Indices of bins\n    indices = np.arange(bins_remain_cap.shape[0])\n\n    # Remaining capacities of feasible bins\n    remaining = bins_remain_cap[feasible]\n\n    # Avoid division by zero in the load calculation\n    eps = 1e-12\n    max_remain = np.max(remaining)\n\n    # Load factor: 0 when a bin has almost the maximum remaining capacity\n    # (bins are empty), 1 when the bin has almost zero remaining capacity\n    # (bins are almost full).  It is computed element\u2011wise.\n    load_factor = 1.0 - remaining / (max_remain + eps)\n    load_factor = np.clip(load_factor, 0.0, 1.0)\n\n    # Weight given to the index term (First\u2011Fit) and to the remaining capacity\n    # term (Worst\u2011Fit)\n    index_weight = 1.0 - load_factor\n\n    # Combine the two components into a single priority score\n    #  * index term favours lower indices (First\u2011Fit)\n    #  * remaining term favours bins with more space (Worst\u2011Fit)\n    priorities[feasible] = (\n        -indices[feasible] * index_weight\n        + remaining * load_factor\n    )\n\n    # Tiny tie\u2011breaker: a very small addition proportional to the remaining\n    # capacity.  This ensures deterministic selection when priorities are\n    # numerically identical.\n    priorities[feasible] += 1e-6 * remaining\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    a: float = 5.0,\n    b: float = 10.0,\n    adaptive: bool = True,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin for the online Bin Packing Problem.\n\n    The priority is based on a sigmoid of the *normalized leftover* after\n    hypothetically placing the item in each bin.  A tight fit (small leftover)\n    yields a high score, while a loose fit yields a lower score.  Infeasible\n    bins (where the item does not fit) receive ``-np.inf`` so they are never\n    selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins (non\u2011negative).\n    a : float, optional\n        Offset of the sigmoid.  Larger ``a`` shifts the curve upward,\n        increasing scores overall. Default is 5.0.\n    b : float, optional\n        Base steepness of the sigmoid.  Larger ``b`` makes the score drop\n        faster as the leftover fraction grows. Default is 10.0.\n    adaptive : bool, optional\n        If ``True``, the steepness ``b`` is scaled by the standard deviation of\n        the normalized leftovers among feasible bins.  This makes the heuristic\n        adapt to the current distribution of bin utilizations.  If ``False``,\n        the raw ``b`` is used.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores with the same shape as ``bins_remain_cap``.\n        Feasible bins have finite scores; infeasible bins have ``-np.inf``.\n    \"\"\"\n    # Ensure a NumPy array of floats for safe arithmetic\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute leftover capacity after placing the item\n    leftover = caps - item\n\n    # Determine which bins can accommodate the item\n    feasible = leftover >= 0\n\n    # Initialise all priorities to -inf (infeasible)\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No bin can accept the item \u2013 return all -inf\n        return priorities\n\n    # Normalized leftover fraction: 0 \u2192 perfect fit, 1 \u2192 empty bin\n    norm_leftover = np.empty_like(caps, dtype=float)\n    # Avoid division by zero (should not occur for feasible bins with cap>0)\n    norm_leftover[feasible] = leftover[feasible] / caps[feasible]\n    # For completeness set zero for infeasible entries (won't be used)\n    norm_leftover[~feasible] = 0.0\n\n    # Adaptive scaling of steepness (optional)\n    if adaptive:\n        # Compute standard deviation of normalized leftovers among feasible bins\n        std = np.std(norm_leftover[feasible])\n        # Guard against zero std (all leftovers identical) \u2192 use 1.0 scaling\n        scale = std if std > 1e-6 else 1.0\n    else:\n        scale = 1.0\n\n    # Sigmoid logits: high when norm_leftover is small (tight fit)\n    logits = a - (b / scale) * norm_leftover[feasible]\n\n    # Logistic function (sigmoid) producing values in (0, 1)\n    scores = 1.0 / (1.0 + np.exp(-logits))\n\n    # Assign computed scores to feasible bins\n    priorities[feasible] = scores\n\n    return priorities\n\n[Reflection]\nNormalize leftovers, use sigmoid scoring, adapt steepness via variance, prioritize tight fits, add deterministic tie\u2011breaker.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}