{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    a: float = 5.0,\n    b: float = 10.0,\n    adaptive: bool = True,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin for the online Bin Packing Problem.\n\n    The priority is based on a sigmoid of the *normalized leftover* after\n    hypothetically placing the item in each bin.  A tight fit (small leftover)\n    yields a high score, while a loose fit yields a lower score.  Infeasible\n    bins (where the item does not fit) receive ``-np.inf`` so they are never\n    selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins (non\u2011negative).\n    a : float, optional\n        Offset of the sigmoid.  Larger ``a`` shifts the curve upward,\n        increasing scores overall. Default is 5.0.\n    b : float, optional\n        Base steepness of the sigmoid.  Larger ``b`` makes the score drop\n        faster as the leftover fraction grows. Default is 10.0.\n    adaptive : bool, optional\n        If ``True``, the steepness ``b`` is scaled by the standard deviation of\n        the normalized leftovers among feasible bins.  This makes the heuristic\n        adapt to the current distribution of bin utilizations.  If ``False``,\n        the raw ``b`` is used.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores with the same shape as ``bins_remain_cap``.\n        Feasible bins have finite scores; infeasible bins have ``-np.inf``.\n    \"\"\"\n    # Ensure a NumPy array of floats for safe arithmetic\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute leftover capacity after placing the item\n    leftover = caps - item\n\n    # Determine which bins can accommodate the item\n    feasible = leftover >= 0\n\n    # Initialise all priorities to -inf (infeasible)\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No bin can accept the item \u2013 return all -inf\n        return priorities\n\n    # Normalized leftover fraction: 0 \u2192 perfect fit, 1 \u2192 empty bin\n    norm_leftover = np.empty_like(caps, dtype=float)\n    # Avoid division by zero (should not occur for feasible bins with cap>0)\n    norm_leftover[feasible] = leftover[feasible] / caps[feasible]\n    # For completeness set zero for infeasible entries (won't be used)\n    norm_leftover[~feasible] = 0.0\n\n    # Adaptive scaling of steepness (optional)\n    if adaptive:\n        # Compute standard deviation of normalized leftovers among feasible bins\n        std = np.std(norm_leftover[feasible])\n        # Guard against zero std (all leftovers identical) \u2192 use 1.0 scaling\n        scale = std if std > 1e-6 else 1.0\n    else:\n        scale = 1.0\n\n    # Sigmoid logits: high when norm_leftover is small (tight fit)\n    logits = a - (b / scale) * norm_leftover[feasible]\n\n    # Logistic function (sigmoid) producing values in (0, 1)\n    scores = 1.0 / (1.0 + np.exp(-logits))\n\n    # Assign computed scores to feasible bins\n    priorities[feasible] = scores\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    epsilon: float = 0.05,\n    noise_scale: float = 1e-4,\n    # sigmoid hyper\u2011parameters\n    alpha_fit: float = 12.0,\n    target_fit: float = 0.80,\n    alpha_waste: float = 12.0,\n    waste_target: float = 0.07,\n    alpha_used: float = 10.0,\n    used_target: float = 0.40,\n) -> np.ndarray:\n    \"\"\"\n    Multi\u2011sigmoid priority function for the online Bin Packing Problem.\n\n    The function evaluates each open bin with three sigmoid\u2011based criteria\n    and multiplies the resulting scores:\n\n    1. **Fit\u2011ratio** \u2013 item size relative to the remaining capacity.\n       A ratio close to ``target_fit`` (default 0.80) yields a score around 0.5;\n       larger ratios (tighter fits) are rewarded.\n\n    2. **Waste** \u2013 leftover capacity after placing the item.\n       Small waste (\u2264 ``waste_target`` of the bin capacity) receives a high score.\n\n    3. **Used\u2011fraction** \u2013 how much of the bin is already occupied.\n       Bins that are already partially filled (\u2248 ``used_target``) are favoured,\n       encouraging the algorithm to fill existing bins before opening new ones.\n\n    Random exploration noise is added to break ties, and an \u03b5\u2011greedy\n    mechanism can replace the deterministic score with a pure random\n    ranking with probability ``epsilon``.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (0 < item \u2264 bin capacity).\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining free capacity of each currently open bin.\n    epsilon : float, optional\n        Probability of choosing a completely random feasible bin (default 0.05).\n    noise_scale : float, optional\n        Scale of the additive uniform noise (default 1e\u20114).  Noise is added\n        after the deterministic score and before the \u03b5\u2011greedy decision.\n    alpha_fit, target_fit, alpha_waste, waste_target, alpha_used, used_target :\n        Hyper\u2011parameters of the sigmoid transforms.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) with the same shape as\n        ``bins_remain_cap``.  Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Ensure a NumPy array of float64.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Edge case: no bins at all.\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n\n    # Initialise all priorities with -inf (infeasible).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Feasibility mask: bins that can accommodate the item.\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        # Nothing fits \u2013 return all -inf.\n        return priorities\n\n    # Estimate the true bin capacity.\n    # When an empty bin exists its remaining capacity equals the capacity.\n    # Otherwise we use the maximum observed remaining capacity as an estimate.\n    eps = 1e-12\n    est_capacity = float(np.max(bins_remain_cap)) if bins_remain_cap.size else 1.0\n    est_capacity = max(est_capacity, eps)\n\n    # --------------------------------------------------------------\n    # 1) Fit\u2011ratio component\n    # --------------------------------------------------------------\n    # Ratio of item size to remaining capacity (only defined for feasible bins).\n    fit_ratio = np.empty_like(bins_remain_cap, dtype=np.float64)\n    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)\n    fit_ratio[~feasible] = 0.0  # dummy value for infeasible bins\n\n    # Sigmoid: high score when fit_ratio > target_fit.\n    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))\n\n    # --------------------------------------------------------------\n    # 2) Waste component\n    # --------------------------------------------------------------\n    waste = bins_remain_cap - item               # may be negative for infeasibles.\n    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)  # normalised waste \u2208 [0,1].\n\n    # Sigmoid decreasing with waste.\n    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))\n\n    # --------------------------------------------------------------\n    # 3) Used\u2011fraction component\n    # --------------------------------------------------------------\n    used_fraction = (est_capacity - bins_remain_cap) / est_capacity\n    used_fraction[~feasible] = 0.0  # dummy for infeasibles\n\n    # Sigmoid rewarding bins that are already partially filled.\n    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))\n\n    # --------------------------------------------------------------\n    # Combine the three signals multiplicatively.\n    # --------------------------------------------------------------\n    combined_score = fit_score * waste_score * used_score\n    priorities[feasible] = combined_score[feasible]\n\n    # --------------------------------------------------------------\n    # Exploration noise (always added before \u03b5\u2011greedy decision).\n    # --------------------------------------------------------------\n    if noise_scale > 0.0:\n        rng = np.random.default_rng()\n        noise = rng.random(bins_remain_cap.shape) * noise_scale\n        priorities[feasible] += noise[feasible]\n\n    # --------------------------------------------------------------\n    # \u03b5\u2011greedy: with probability epsilon replace with a random ranking.\n    # --------------------------------------------------------------\n    if epsilon > 0.0 and np.random.rand() < epsilon:\n        rng = np.random.default_rng()\n        random_score = np.where(feasible, rng.random(bins_remain_cap.shape), -np.inf)\n        priorities = random_score\n\n    return priorities\n\n[Reflection]\nUse multi\u2011sigmoid fit, waste, usage; adapt steepness; estimate true capacity; combine multiplicatively; add noise/\u03b5\u2011greedy.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}