```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    epsilon: float = 0.05,
    noise_scale: float = 1e-4,
    alpha_fit: float = 12.0,
    target_fit: float = 0.80,
    alpha_waste: float = 12.0,
    waste_target: float = 0.07,
    alpha_used: float = 10.0,
    used_target: float = 0.40,
) -> np.ndarray:
    """
    Multi‑sigmoid priority function for online bin packing.

    For each currently open bin the function returns a priority score that
    combines three independent sigmoid components:

    * **Fit ratio** – how close the item size is to the remaining capacity.
      A ratio above *target_fit* is rewarded.
    * **Waste** – the leftover free space after the item is placed.
      Smaller waste is preferred; waste values below *waste_target* are
      rewarded strongly.
    * **Used fraction** – how much of the bin is already occupied.
      Partially filled bins are favored, encouraging reuse before opening
      new bins.

    The three scores are multiplied to form the final priority.  A small
    uniform noise is added to break ties and an ε‑greedy policy can replace
    the deterministic ranking with a random one with probability *epsilon*.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item ≤ bin capacity).
    bins_remain_cap : array_like
        1‑D array of remaining capacities of the currently open bins.
    epsilon : float, optional
        Probability of picking a random feasible bin instead of using the
        computed priorities.
    noise_scale : float, optional
        Scale of the additive noise used to break ties.
    alpha_fit, target_fit, alpha_waste, waste_target,
    alpha_used, used_target : float, optional
        Hyper‑parameters of the sigmoid transforms.
    Returns
    -------
    np.ndarray
        Priority scores; higher is better.  Bins that cannot accommodate
        the item receive ``-np.inf``.
    """
    # Convert to a NumPy array of float64 for consistency
    bins = np.asarray(bins_remain_cap, dtype=np.float64)

    # Handle the empty‑bin case immediately
    if bins.size == 0:
        return np.array([], dtype=np.float64)

    # Feasibility mask: bins that can hold the item
    feasible = bins >= item
    if not np.any(feasible):
        # No bin can fit the item
        return np.full_like(bins, -np.inf, dtype=np.float64)

    # Estimate the true bin capacity from the largest remaining capacity
    # observed.  This is robust when we have no explicit capacity value.
    est_capacity = float(np.max(bins))
    if est_capacity <= 0:
        est_capacity = 1.0  # Fallback to avoid division by zero

    # ---------- 1) Fit‑ratio component ----------
    fit_ratio = np.empty_like(bins)
    np.divide(item, bins, out=fit_ratio, where=feasible)
    fit_ratio[~feasible] = 0.0  # dummy value for infeasible bins
    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))

    # ---------- 2) Waste component ----------
    waste = bins - item
    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)  # Normalised waste [0,1]
    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))

    # ---------- 3) Used‑fraction component ----------
    used_fraction = (est_capacity - bins) / est_capacity
    used_fraction[~feasible] = 0.0  # dummy for infeasible bins
    used_score = 1.0 / (1.0 + np.exp(-alpha_used * (used_fraction - used_target)))

    # ---------- Combine signals ----------
    combined_score = fit_score * waste_score * used_score

    # ---------- Add exploration noise ----------
    rng = np.random.default_rng()
    if noise_scale > 0.0:
        noise = rng.random(bins.shape) * noise_scale
        combined_score += noise

    # ---------- ε‑greedy exploration ----------
    if epsilon > 0.0 and rng.random() < epsilon:
        random_score = rng.random(bins.shape)
        random_score[~feasible] = -np.inf
        return random_score

    # Mark infeasible bins explicitly
    combined_score[~feasible] = -np.inf
    return combined_score
```
