{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n# Global epsilon for the epsilon\u2011greedy policy.\n# With probability EPSILON we favour exploration (random choice);\n# with probability (1\u2011EPSILON) we follow the greedy heuristic.\nEPSILON = 0.1\n\n\n    \"\"\"\n    Epsilon\u2011greedy priority scores for online bin packing.\n\n    The greedy component prefers bins that will leave the smallest waste\n    after placing the item (i.e., bins with minimal remaining capacity\n    - item). The exploration component adds uniform random noise to the\n    priority of feasible bins, encouraging occasional exploration of non\u2011optimal\n    bins.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of the remaining capacities of all bins.\n\n    Returns:\n        1\u2011D array of priority scores, same length as ``bins_remain_cap``.\n        Higher scores indicate a more desirable bin for the item.\n    \"\"\"\n    # Ensure we work with floats.\n    caps = bins_remain_cap.astype(float)\n\n    # Feasibility mask: bins that can accommodate the item.\n    feasible = caps >= item\n\n    # If no bin can hold the item, return zeros (caller may open a new bin).\n    if not np.any(feasible):\n        return np.zeros_like(caps)\n\n    # ---------- Greedy component ----------\n    # Waste after placing the item.\n    waste = caps - item\n    # Tiny constant avoids division by zero for perfect fits.\n    delta = 1e-9\n    greedy_score = np.zeros_like(caps)\n    # Higher score for smaller waste \u2192 1 / (waste + delta).\n    greedy_score[feasible] = 1.0 / (waste[feasible] + delta)\n\n    # ---------- Exploration component ----------\n    # Uniform random scores for feasible bins, zero for infeasible ones.\n    random_score = np.zeros_like(caps)\n    random_score[feasible] = np.random.rand(np.sum(feasible))\n\n    # ---------- Combine ----------\n    # Linear interpolation yields the classic epsilon\u2011greedy mixture.\n    priorities = (1.0 - EPSILON) * greedy_score + EPSILON * random_score\n\n    # Ensure infeasible bins stay at zero (or could be set to -inf).\n    priorities[~feasible] = 0.0\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Compute priority scores for each bin according to the **Almost Full Fit**\n    heuristic.\n\n    The idea of Almost Full Fit is to place the item into the bin that will be\n    left with the *smallest* remaining capacity after the insertion \u2013 i.e., the\n    bin that becomes as full as possible without overflowing. Bins that cannot\n    accommodate the item receive a very low priority. Additionally, bins that\n    would be *exactly* filled (within a tiny epsilon) get a huge bonus to\n    encourage perfect fits and avoid floating\u2011point round\u2011off issues.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacities of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        An array of the same shape as ``bins_remain_cap`` containing the\n        priority score for each bin. Higher scores indicate a more preferred\n        bin for placing the item.\n    \"\"\"\n    # Convert to a NumPy array of floats (in case a list is passed)\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute the leftover capacity if the item were placed in each bin\n    leftover = bins_remain_cap - item\n\n    # Feasibility mask: True where the item fits\n    feasible = leftover >= 0\n\n    # Very low priority for infeasible bins\n    NEG_INF = -1e12\n    priorities = np.full_like(bins_remain_cap, NEG_INF, dtype=float)\n\n    # Base priority: the smaller the leftover, the larger the priority.\n    # We use the negative leftover to turn minimisation (of slack) into\n    # maximisation (of priority).\n    priorities[feasible] = -leftover[feasible]\n\n    # Bonus for bins that become (almost) perfectly full.\n    # This helps push the algorithm toward exact fits and reduces the\n    # sensitivity to tiny floating\u2011point errors.\n    epsilon = 1e-6          # tolerance for \u201cexact\u201d fit\n    exact_fit_bonus = 1e9  # large positive boost\n    exact_fit = feasible & (leftover <= epsilon)\n    priorities[exact_fit] = exact_fit_bonus\n\n    return priorities\n\n[Reflection]\nMinimize leftover, reward near\u2011zero waste heavily, heavily penalize infeasible bins, avoid stochastic noise.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}