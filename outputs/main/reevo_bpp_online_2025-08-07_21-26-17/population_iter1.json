[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority for First\u2011Fit bin selection.\n\n    The First\u2011Fit heuristic selects the first (i.e., lowest\u2011index) bin that can\n    accommodate the incoming ``item``. This function encodes that rule as a\n    priority vector: bins that can hold the item receive a decreasing score\n    based on their index (the earliest bin gets the highest score). Bins that\n    cannot accommodate the item receive ``-inf`` so they are never chosen.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be placed.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` containing a priority\n        score for each bin. The bin with the maximal score should be selected.\n    \"\"\"\n    # Flatten just in case a higher\u2011dimensional array is passed.\n    caps = np.ravel(bins_remain_cap)\n\n    # Identify bins where the item fits.\n    can_fit = caps >= item\n\n    # Primary First\u2011Fit ranking: earlier bins get larger base scores.\n    # -np.arange yields 0 for index 0, -1 for index 1, \u2026\n    base_score = -np.arange(caps.size, dtype=float)\n\n    # Assign scores: fitting bins get their base_score, others get -inf.\n    priorities = np.where(can_fit, base_score, -np.inf)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Trivial placeholder priority (all zeros).\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best\u2011Fit priority for online bin packing.\n\n    For each bin we compute the leftover capacity after placing the item.\n    Bins that can accommodate the item receive a higher priority the tighter\n    the fit (i.e., the smaller the leftover capacity). Infeasible bins receive\n    a priority of -inf to guarantee they are never chosen.\n\n    Tie\u2011breaking among equally tight bins is performed by adding a vanishingly\n    small bias that favors bins with lower indices.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: Array of remaining capacities of existing bins.\n\n    Returns:\n        An array of priority scores, one per bin.\n    \"\"\"\n    # Ensure floating point arithmetic (necessary for -inf handling)\n    caps = bins_remain_cap.astype(np.float64, copy=False)\n\n    # Compute the leftover capacity if the item were placed in each bin\n    leftover = caps - item\n\n    # Determine which bins can actually accommodate the item\n    feasible = leftover >= 0\n\n    # Base priority: tighter fit (smaller leftover) => larger priority.\n    # Use negative leftover so that a smaller leftover yields a higher score.\n    base_priority = -leftover\n\n    # Initialise priorities: -inf for infeasible bins, base priority otherwise\n    priorities = np.where(feasible, base_priority, -np.inf)\n\n    # Deterministic tie\u2011breaker: add a minuscule bias based on bin index\n    epsilon = 1e-12  # far below any realistic leftover magnitude\n    idx = np.arange(caps.shape[0])\n    # Larger bias for earlier bins (preferring lower indices on ties)\n    tie_bias = epsilon * (caps.shape[0] - idx)\n    priorities = np.where(feasible, priorities + tie_bias, priorities)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return a priority array for each bin following the Worst\u2011Fit strategy.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be inserted.\n    bins_remain_cap : np.ndarray\n        Remaining capacities for each bin. Expected to be non\u2011negative numeric values.\n\n    Returns\n    -------\n    np.ndarray\n        Array of scores with the same shape as ``bins_remain_cap``. The bin with\n        the maximum score will be chosen. Bins that cannot hold the item are\n        assigned a priority of -\u221e, effectively removing them from consideration.\n\n    Notes\n    -----\n    The priority is simply the amount of space that will remain after the\n    item is placed in each bin. The index with the largest residual space\n    gets the highest priority \u2013 the hallmark of the Worst\u2011Fit heuristic.\n    \"\"\"\n    # Convert to float to avoid integer overflow/underflow when subtracting\n    remain = bins_remain_cap.astype(float, copy=False) - item\n    # Bins that can't accept the item get -infinity priority\n    return np.where(remain >= 0, remain, -np.inf)",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Almost Full Fit priority function for online Bin Packing.\n\n    The function assigns a high score to bins where the item fits and leaves\n    the smallest possible remaining capacity after placement (i.e., the bin\n    becomes \"almost full\"). Bins that cannot accommodate the item receive a\n    very low priority.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array with the remaining capacity of each bin.\n\n    Returns:\n        np.ndarray: Priority scores (higher = more preferable) for each bin.\n    \"\"\"\n    # Compute the capacity that would remain after placing the item in each bin\n    remaining_after = bins_remain_cap - item\n\n    # Determine which bins can actually host the item\n    can_fit = remaining_after >= 0\n\n    # Small epsilon to avoid division by zero when remaining_after is exactly 0\n    eps = np.finfo(bins_remain_cap.dtype).eps\n\n    # Priority for fitting bins:\n    #   - Exact fits (remaining_after \u2248 0) receive an extremely high priority.\n    #   - Otherwise priority grows as the leftover space shrinks:\n    #       priority = 1 / (remaining_after + eps)\n    #   This makes bins that would be \"almost full\" the most attractive.\n    # Bins that cannot fit the item get -inf (lowest possible priority).\n    exact_fit = np.isclose(remaining_after, 0.0, atol=eps)\n    priority = np.where(\n        can_fit,\n        np.where(\n            exact_fit,\n            np.inf,                         # perfect fit -> highest possible priority\n            1.0 / (remaining_after + eps)   # smaller leftover -> larger priority\n        ),\n        -np.inf                           # cannot fit -> lowest priority\n    )\n\n    # Optional random tie\u2011breaker to avoid deterministic bias when priorities are equal.\n    # This adds a tiny uniform noise only to the bins that are viable.\n    # The noise magnitude is far smaller than the smallest possible difference\n    # created by the 1/(remaining_after) term.\n    tie_break_noise = np.random.uniform(0, eps, size=bins_remain_cap.shape)\n    priority = np.where(can_fit, priority + tie_break_noise, priority)\n\n    return priority",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 25, in priority_v2\n    can_fit = bins_remain_cap >= item\n  File \"/home/dokhanhnam1199/.local/lib/python3.10/site-packages/numpy/_core/getlimits.py\", line 525, in __new__\n    raise ValueError(\"data type %r not inexact\" % (dtype))\nValueError: data type <class 'numpy.int64'> not inexact\n17\n1\n"
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Exact Fit First priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array holding the remaining capacity of each existing bin.\n\n    Returns\n    -------\n    np.ndarray\n        Same shape as *bins_remain_cap*.  Bin indices with the largest value\n        receive the item.  Bins that cannot accommodate *item* are marked\n        with `-inf`.\n    \"\"\"\n    # Start with an impossible low score; only bins that can accommodate the item\n    # will be considered.\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n\n    # Bins that have enough space for the item\n    can_fit = bins_remain_cap >= item\n\n    # Exact fit gets the highest possible score.\n    exact = can_fit & (bins_remain_cap == item)\n    priorities[exact] = 1.0  # any positive value is fine\n\n    # For the remaining fitting bins, favor the one that leaves the least\n    # residual space after placing the item (i.e., \u201cbest fit\u201d).\n    other = can_fit & (~exact)\n    priorities[other] = -(bins_remain_cap[other] - item)\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    power: float = 1.0,\n    epsilon: float = 1e-12,\n    normalize: bool = False,\n) -> np.ndarray:\n    \"\"\"Inverse\u2011Distance (Proximity Fit) priority for online bin packing.\n\n    For each bin we compute the slack (remaining capacity after placing the\n    item).  Bins that cannot accommodate the item receive a priority of 0.\n    For feasible bins the priority is the inverse of the slack raised to ``power``,\n    i.e. ``1 / (slack + epsilon)**power``.  This yields the highest score for a\n    perfect fit (slack\u22480) and rapidly decreases as the bin becomes more under\u2011filled.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array with the remaining capacity of each bin.\n        power: Exponent controlling the steepness of the decay.  ``power=1`` gives a\n            simple inverse distance; larger values make the function more\n            aggressive in preferring tight fits.\n        epsilon: Small constant to avoid division by zero when slack \u2248 0.\n        normalize: If True, the priorities are scaled to sum to 1 across all\n            feasible bins (useful when turning priorities into a probability\n            distribution).\n\n    Returns:\n        An array of the same shape as ``bins_remain_cap`` containing the priority\n        score for each bin.\n    \"\"\"\n    # Compute slack (how much space would be left after inserting the item)\n    slack = bins_remain_cap - item\n\n    # Identify bins that can actually host the item\n    feasible = slack >= 0\n\n    # Initialise priority vector\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Inverse distance priority for feasible bins\n    # Adding epsilon prevents division\u2011by\u2011zero and yields a very large priority for a perfect fit.\n    priorities[feasible] = 1.0 / np.power(slack[feasible] + epsilon, power)\n\n    # Optional normalization to turn raw scores into a probability distribution\n    if normalize:\n        total = priorities.sum()\n        if total > 0:\n            priorities = priorities / total\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    steepness: float = 12.0,\n    midpoint: float = 0.5,\n    eps: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Sigmoid Fit Score priority for online Bin Packing.\n\n    For each bin we compute a score based on how well the incoming `item`\n    fits into the remaining capacity of the bin. The ratio `r = item / cap`\n    (where `cap` is the remaining capacity) lies in (0, 1] for feasible bins.\n    A logistic (sigmoid) transformation of this ratio emphasizes bins that\n    would be filled tightly (ratio close to 1) and de\u2011emphasizes bins that\n    would leave a large amount of waste.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining capacity of each bin.\n    steepness : float, optional\n        Controls the steepness of the sigmoid. Larger values make the function\n        more aggressive (i.e., more strongly prefer bins that almost fill up).\n    midpoint : float, optional\n        The ratio at which the sigmoid outputs 0.5. Typically 0.5,\n        but can be tuned to bias towards tighter or looser fits.\n    eps : float, optional\n        Small constant to avoid division by zero.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``). Infeasible bins\n        (where ``item`` does not fit) receive a score of 0.0.\n    \"\"\"\n    # Ensure a NumPy array of floats for vectorised operations\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item\n    feasible = caps + eps >= item  # +eps guards against floating\u2011point noise\n\n    # Early exit: if nothing fits, return an array of zeros\n    if not np.any(feasible):\n        return np.zeros_like(caps, dtype=float)\n\n    # Compute the fit ratio only for feasible bins\n    # Ratio = item size divided by the bin's remaining capacity\n    ratio = np.empty_like(caps, dtype=float)\n    ratio[:] = 0.0                     # initialise with zeros for safety\n    ratio[feasible] = item / caps[feasible]\n\n    # Apply a sigmoid transformation:\n    #   s(r) = 1 / (1 + exp(-steepness * (r - midpoint)))\n    # This yields values in (0, 1), close to 1 when r \u2248 1 (tight fit)\n    # and close to 0 when r is small (poor fit).\n    sigmoid = 1.0 / (1.0 + np.exp(-steepness * (ratio[feasible] - midpoint)))\n\n    # Assemble the final priority array: feasible bins get the sigmoid score,\n    # infeasible bins retain 0.0 (lowest possible priority).\n    priorities = np.zeros_like(caps, dtype=float)\n    priorities[feasible] = sigmoid\n\n    # Clip to the [0, 1] interval for numerical robustness\n    np.clip(priorities, 0.0, 1.0, out=priorities)\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Random Fit priority for online Bin Packing.\n\n    Each bin that can accommodate ``item`` receives a random score drawn\n    from a uniform distribution on [0, 1). Bins that cannot fit the item are\n    assigned ``-np.inf`` so they will never be selected as the highest priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of all current bins.\n\n    Returns\n    -------\n    np.ndarray\n        Array of same shape as ``bins_remain_cap`` with a priority score for\n        each bin. The bin with the largest value will be chosen.\n    \"\"\"\n    # Identify bins that can host the item.\n    viable = bins_remain_cap >= item\n\n    # Initialize all priorities to -inf (i.e., infeasible bins).\n    priorities = np.full_like(bins_remain_cap, fill_value=-np.inf, dtype=float)\n\n    # Assign a random priority to each feasible bin.\n    # Using np.random.random ensures a fresh random draw each call.\n    priorities[viable] = np.random.random(size=viable.sum())\n\n    return priorities",
    "response_id": 7,
    "obj": 73.26485839648984,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\n# Global epsilon controlling the exploration vs. exploitation balance.\n_EPSILON = 0.15  # Typical values: 0.0 (pure greedy) to 1.0 (pure random).\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin using an epsilon\u2011greedy strategy.\n\n    The function prefers bins that fit the item tightly (exploitation) while\n    preserving a chance of exploring sub\u2011optimal bins (exploration) by blending\n    a random component weighted by epsilon.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; higher scores indicate more desirable bins.\n    \"\"\"\n    # Ensure input is a NumPy array of floats.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item.\n    can_fit = bins_remain_cap >= item\n\n    # --- Exploitation component ------------------------------------------------\n    # Preference for tighter fits: smaller leftover space => larger priority.\n    # Inverse of leftover space is used; a tiny epsilon avoids division by zero.\n    leftover = bins_remain_cap - item\n    base_priority = np.where(\n        can_fit,\n        1.0 / (leftover + 1e-12),\n        0.0\n    )\n\n    # --- Exploration component -------------------------------------------------\n    # Random scores to enable exploration of less obvious bins.\n    rng = np.random.default_rng()\n    random_priority = rng.random(bins_remain_cap.shape)\n\n    # --- Blend the two components -----------------------------------------------\n    # (1 - epsilon) weight for exploitation, epsilon weight for exploration.\n    blended_priority = (1.0 - _EPSILON) * base_priority + _EPSILON * random_priority\n\n    # Bins that cannot fit the item should be assigned zero priority to never be selected.\n    priorities = np.where(can_fit, blended_priority, 0.0)\n\n    return priorities",
    "response_id": 8,
    "obj": 3.7893897088153174,
    "SLOC": 14.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\n# scaling factor (larger \u2192 greedier selection)\n_SBF_ALPHA = 10.0\n_SBF_EPS = 1e-12\n\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Softmax\u2011Based Fit priority for online bin packing.\n\n    Computes a probability\u2011like priority for each existing bin based on how\n    tightly the ``item`` would fit.  Bins that cannot accommodate the item receive\n    a priority of zero.  Among feasible bins, the priority is the softmax of\n    ``\u2011\u03b1\u00b7(remaining_capacity_after_item)`` where ``\u03b1`` controls the greediness.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of the remaining capacities of the current bins.\n\n    Returns:\n        A 1\u2011D ``np.ndarray`` of the same shape as ``bins_remain_cap`` containing\n        non\u2011negative priority scores that sum to one across all feasible bins.\n        If no bin can host the item, an array of zeros is returned.\n    \"\"\"\n    # Ensure float array for -inf handling\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Feas mask: only bins with enough room are considered\n    feasible = caps >= item\n\n    # No feasible bin \u2192 all priorities zero (external logic may open a new bin)\n    if not np.any(feasible):\n        return np.zeros_like(caps)\n\n    # Compute residual capacity after placing the item (\u22650 for feasible bins)\n    residual = caps[feasible] - item\n\n    # Raw score: tighter fit (smaller residual) \u2192 higher (less negative) score.\n    # Using -\u03b1\u00b7residual; larger \u03b1 makes distribution sharper.\n    raw_feasible = -_SBF_ALPHA * residual\n\n    # Fill full raw score array; infeasible bins get -inf \u2192 exp = 0\n    raw_scores = np.full_like(caps, -np.inf, dtype=float)\n    raw_scores[feasible] = raw_feasible\n\n    # Numerically stable softmax (shift by max)\n    max_raw = raw_scores.max()  # finite because at least one feasible bin exists\n    exp_scores = np.exp(raw_scores - max_raw)  # exp(-inf) = 0 for infeasibles\n\n    sum_exp = exp_scores.sum()\n    if sum_exp < _SBF_EPS:  # safeguard (should be unreachable)\n        return np.zeros_like(caps)\n\n    priorities = exp_scores / sum_exp\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    First\u2011Fit priority for the online Bin Packing Problem.\n\n    The function assigns a higher score to bins with smaller indices that can\n    accommodate the incoming item, mimicking the classic First\u2011Fit rule:\n    the first (i.e., lowest\u2011index) feasible bin is preferred. Infeasible bins\n    receive a score of -inf so they are never selected.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities of the current bins.\n\n    Returns:\n        A 1\u2011D array of priority scores \u2013 the bin with the largest score will be\n        chosen for the item.\n    \"\"\"\n    # Number of existing bins\n    n_bins = bins_remain_cap.shape[0]\n\n    # Initialise all priorities as -inf (unfeasible)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Mask of bins that can actually hold the item\n    feasible = bins_remain_cap >= item\n\n    # Preference strictly follows the bin index: smaller index \u2192 higher priority.\n    # Using -index gives 0 for the first bin, -1 for the second, etc.\n    # This ordering guarantees First\u2011Fit behaviour.\n    indices = np.arange(n_bins)\n    priorities[feasible] = -indices[feasible]\n\n    # Optional tiny tie\u2011breaker based on leftover space (does not affect the\n    # strict First\u2011Fit order but prefers tighter fits when indices are equal).\n    # slack = bins_remain_cap[feasible] - item\n    # priorities[feasible] -= 1e-6 * slack\n\n    return priorities",
    "response_id": 10,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011Fit priority for online Bin Packing.\n\n    For each bin we compute a score that is highest for the bin that will\n    leave the smallest leftover capacity after the item is placed.\n    Bins that cannot accommodate the item receive a score of -inf\n    so they are never chosen.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: Remaining free capacity of each bin.\n\n    Returns:\n        np.ndarray of priority scores (same shape as `bins_remain_cap`).\n        The bin with the maximal score will be selected.\n    \"\"\"\n    # Mask of bins that can actually hold the item\n    can_fit = bins_remain_cap >= item\n\n    # Remaining capacity after the item would be placed\n    leftover = bins_remain_cap - item\n\n    # Use the negative leftover as priority: smaller leftover \u2192 higher (less negative) score\n    priorities = np.where(can_fit, -leftover, -np.inf)\n\n    # Optional: break ties with an infinitesimal random jitter (does not affect ordering)\n    # This avoids deterministic tie\u2011breaking which could bias later decisions.\n    if np.any(priorities != -np.inf):\n        jitter = np.random.rand(*priorities.shape) * 1e-12\n        priorities = np.where(priorities != -np.inf, priorities + jitter, priorities)\n\n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority scores for the Worst\u2011Fit online bin packing heuristic.\n\n    The Worst\u2011Fit rule selects the bin with the largest *remaining* capacity\n    that can still accommodate the incoming ``item``.  Bins that cannot hold the\n    item receive a very low (``-inf``) priority so they are never chosen.\n    Among feasible bins the slack ``(remaining capacity \u2013 item)`` is used as\n    the main priority, with a tiny deterministic tie\u2011breaker based on the bin\n    index to avoid ties.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` containing the priority\n        score for each bin.  The bin with the highest value should be selected.\n    \"\"\"\n    # Initialise all priorities to -inf (ensuring infeasible bins are never chosen)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Identify bins that can accommodate the item\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        # No bin can fit the item \u2013 caller may open a new bin.\n        return priorities\n\n    # Slack = remaining capacity after placing the item\n    slack = bins_remain_cap[feasible] - item\n\n    # Deterministic tie\u2011breaker: a vanishing epsilon proportional to the bin index.\n    # This preserves the ordering by slack while guaranteeing unique values.\n    feasible_indices = np.where(feasible)[0:\n        # caution about direct parameter?\n\n    idx = np.where(feasible)[0]\n    epsilon = (idx.astype(np.float64) / (bins_remain_cap.size + 1)) * 1e-9\n\n    # Assign priorities: larger slack \u2192 higher priority\n    priorities[feasible] = slack + epsilon\n\n    return priorities",
    "response_id": 12,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 40\n    feasible_indices = np.where(feasible)[0:\n                                         ^\nSyntaxError: '[' was never closed\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 40\n    feasible_indices = np.where(feasible)[0:\n                                         ^\nSyntaxError: '[' was never closed\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 40\n    feasible_indices = np.where(feasible)[0:\n                                         ^\nSyntaxError: '[' was never closed\n"
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin according to the **Almost Full Fit**\n    heuristic.\n\n    The idea of Almost Full Fit is to place the item into the bin that will be\n    left with the *smallest* remaining capacity after the insertion \u2013 i.e., the\n    bin that becomes as full as possible without overflowing. Bins that cannot\n    accommodate the item receive a very low priority. Additionally, bins that\n    would be *exactly* filled (within a tiny epsilon) get a huge bonus to\n    encourage perfect fits and avoid floating\u2011point round\u2011off issues.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacities of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        An array of the same shape as ``bins_remain_cap`` containing the\n        priority score for each bin. Higher scores indicate a more preferred\n        bin for placing the item.\n    \"\"\"\n    # Convert to a NumPy array of floats (in case a list is passed)\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute the leftover capacity if the item were placed in each bin\n    leftover = bins_remain_cap - item\n\n    # Feasibility mask: True where the item fits\n    feasible = leftover >= 0\n\n    # Very low priority for infeasible bins\n    NEG_INF = -1e12\n    priorities = np.full_like(bins_remain_cap, NEG_INF, dtype=float)\n\n    # Base priority: the smaller the leftover, the larger the priority.\n    # We use the negative leftover to turn minimisation (of slack) into\n    # maximisation (of priority).\n    priorities[feasible] = -leftover[feasible]\n\n    # Bonus for bins that become (almost) perfectly full.\n    # This helps push the algorithm toward exact fits and reduces the\n    # sensitivity to tiny floating\u2011point errors.\n    epsilon = 1e-6          # tolerance for \u201cexact\u201d fit\n    exact_fit_bonus = 1e9  # large positive boost\n    exact_fit = feasible & (leftover <= epsilon)\n    priorities[exact_fit] = exact_fit_bonus\n\n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Exact Fit First priority.\n\n    For an incoming item of size `item`, this function evaluates each bin\n    in `bins_remain_cap` and returns a priority score.  \n    The logic is:\n\n        1. Bins that cannot accommodate the item receive a score of\n           `-inf` (never selected).\n        2. If a bin's remaining capacity equals the item's size (exact\n           fit), it gets the maximum possible score, `0`.\n        3. Otherwise, bins that leave less remaining space after the\n           item is packed are preferred.  The priority is defined as\n           `- (remaining_capacity - item)`, so a smaller leftover\n           yields a larger score (less negative).\n\n    This strategy ensures that bins that fit the item exactly are\n    always chosen first, and if no exact fit exists, the bin that\n    results in the smallest waste is selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to pack.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores; the bin with the largest score is the\n        candidate for packing the item.\n    \"\"\"\n    # Only bins that can hold the item are considered.\n    can_fit = bins_remain_cap >= item\n\n    # Default score for bins that cannot accommodate the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if np.any(can_fit):\n        # Remaining space after placing the item.\n        remaining = bins_remain_cap[can_fit] - item\n        # Exact fit => remaining == 0 -> score 0.\n        # Larger remaining => more negative score.\n        priorities[can_fit] = -remaining\n\n    return priorities",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse Distance (Proximity Fit) priority for online Bin Packing.\n\n    For each bin we compute how tightly the item would fit:\n        - If the item fits (remaining capacity \u2265 item), priority = 1 / (remaining\u2011after + \u03b5)\n          where *remaining\u2011after* is the free space left after placing the item.\n          Smaller leftover \u21d2 larger priority, i.e. a tighter fit.\n        - If the item does **not** fit, the bin receives a very low priority so it\n          will never be selected.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities of the current bins.\n\n    Returns:\n        A NumPy array of the same shape as ``bins_remain_cap`` containing the\n        priority score for each bin.\n    \"\"\"\n    eps = 1e-12                     # avoid division by zero for perfect fits\n    remaining_after = bins_remain_cap - item\n\n    # Feasibility mask (True where the item fits)\n    feasible = remaining_after >= 0\n\n    # Inverse distance priority for feasible bins; -inf for infeasible bins\n    priorities = np.where(\n        feasible,\n        1.0 / (remaining_after + eps),\n        -np.inf\n    )\n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Sigmoid Fit Score priority for online Bin Packing.\n\n    For each currently open bin we compute a priority that rewards:\n      * a tight fit (item occupies a large fraction of the free space), and\n      * a small amount of waste left after the item is placed.\n\n    The two criteria are transformed by logistic (sigmoid) functions and\n    combined multiplicatively.  Bins that cannot accommodate the item receive\n    ``-np.inf`` so they will never be chosen.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (0 < item \u2264 bin capacity).\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (higher is better) with the same shape as\n        ``bins_remain_cap``.  Infeasible bins are assigned ``-np.inf``.\n    \"\"\"\n    # Ensure we are working with floats.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Edge case: no bins are currently open.\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=np.float64)\n\n    # Initialise all priorities to the worst possible value.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Feasibility mask: bins with enough space for the item.\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return priorities  # nothing fits; all remain -inf.\n\n    # ----------------------------------------------------------------------\n    # 1) Fit\u2011ratio component \u2013 how much of the free space the item would use.\n    #    ratio = item / remaining_capacity \u2208 (0, 1].\n    # ----------------------------------------------------------------------\n    fit_ratio = np.empty_like(bins_remain_cap, dtype=np.float64)\n    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)\n    fit_ratio[~feasible] = 0.0  # value irrelevant for infeasible bins.\n\n    # Sigmoid parameters for the fit\u2011ratio.\n    alpha_fit = 15.0          # steepness of the transition.\n    target_fit = 0.85         # ratio where score = 0.5 (\u224885\u202f% fill is neutral).\n\n    fit_score = 1.0 / (1.0 + np.exp(-alpha_fit * (fit_ratio - target_fit)))\n\n    # ----------------------------------------------------------------------\n    # 2) Waste component \u2013 encourage small leftover space after placement.\n    # ----------------------------------------------------------------------\n    # Estimate the true bin capacity.  If an empty bin exists,\n    # the maximum remaining capacity equals the true capacity.\n    eps = 1e-12\n    est_capacity = float(np.max(bins_remain_cap)) if bins_remain_cap.size else 1.0\n    est_capacity = max(est_capacity, eps)\n\n    waste = bins_remain_cap - item                     # may be negative for infeasibles.\n    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)  # normalised waste \u2208 [0,1].\n\n    # Sigmoid parameters for the waste.\n    alpha_waste = 12.0\n    waste_target = 0.05       # waste \u2264 5\u202f% of capacity yields score >\u202f0.5.\n\n    waste_score = 1.0 / (1.0 + np.exp(alpha_waste * (waste_norm - waste_target)))\n\n    # ----------------------------------------------------------------------\n    # 3) Combine the two signals.\n    # ----------------------------------------------------------------------\n    # Multiplicative combination heavily penalises a bin that fails either\n    # criterion while rewarding bins that are good on both.\n    combined_score = fit_score * waste_score\n\n    # Assign scores only to feasible bins.\n    priorities[feasible] = combined_score[feasible]\n\n    return priorities",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 25.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Random Fit priority function for online Bin Packing.\n    Returns a random priority for each bin that can accommodate the item.\n    Infeasible bins receive ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` where each entry holds\n        a random priority if the item fits, otherwise ``-np.inf``.\n    \"\"\"\n    # Ensure we work with a NumPy array (copy on view, not modify caller).\n    # This also allows support for Python lists or other sequences.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Identify bins that have enough free space for the item.\n    feasible = bins_remain_cap >= item\n\n    # Initialise all priorities as -inf (worst possible).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Assign a uniform random priority to each feasible bin.\n    if np.any(feasible):\n        # Using a local Generator isolates the RNG state from global NumPy RNG.\n        rng = np.random.default_rng()\n        priorities[feasible] = rng.random(feasible.sum())\n\n    return priorities",
    "response_id": 17,
    "obj": 73.83326685281214,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\n# Global epsilon for the epsilon\u2011greedy policy.\n# With probability EPSILON we favour exploration (random choice);\n# with probability (1\u2011EPSILON) we follow the greedy heuristic.\nEPSILON = 0.1\n\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Epsilon\u2011greedy priority scores for online bin packing.\n\n    The greedy component prefers bins that will leave the smallest waste\n    after placing the item (i.e., bins with minimal remaining capacity\n    - item). The exploration component adds uniform random noise to the\n    priority of feasible bins, encouraging occasional exploration of non\u2011optimal\n    bins.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of the remaining capacities of all bins.\n\n    Returns:\n        1\u2011D array of priority scores, same length as ``bins_remain_cap``.\n        Higher scores indicate a more desirable bin for the item.\n    \"\"\"\n    # Ensure we work with floats.\n    caps = bins_remain_cap.astype(float)\n\n    # Feasibility mask: bins that can accommodate the item.\n    feasible = caps >= item\n\n    # If no bin can hold the item, return zeros (caller may open a new bin).\n    if not np.any(feasible):\n        return np.zeros_like(caps)\n\n    # ---------- Greedy component ----------\n    # Waste after placing the item.\n    waste = caps - item\n    # Tiny constant avoids division by zero for perfect fits.\n    delta = 1e-9\n    greedy_score = np.zeros_like(caps)\n    # Higher score for smaller waste \u2192 1 / (waste + delta).\n    greedy_score[feasible] = 1.0 / (waste[feasible] + delta)\n\n    # ---------- Exploration component ----------\n    # Uniform random scores for feasible bins, zero for infeasible ones.\n    random_score = np.zeros_like(caps)\n    random_score[feasible] = np.random.rand(np.sum(feasible))\n\n    # ---------- Combine ----------\n    # Linear interpolation yields the classic epsilon\u2011greedy mixture.\n    priorities = (1.0 - EPSILON) * greedy_score + EPSILON * random_score\n\n    # Ensure infeasible bins stay at zero (or could be set to -inf).\n    priorities[~feasible] = 0.0\n\n    return priorities",
    "response_id": 18,
    "obj": 4.11846828879138,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Softmax\u2011Based priority for online bin packing.\n    \n    If the item fits into a bin, we compute the remaining free space after placing\n    the item and use a negative sign to prefer bins with small leftover.\n    The final priority is the exponential of these scores (softmax style);\n    bins that cannot accommodate the item receive a score of zero.\n    \n    Parameters\n    ----------\n    item : float\n        Size of the item to be packed.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the current free capacity in each bin.\n    \n    Returns\n    -------\n    np.ndarray\n        Same shape as ``bins_remain_cap`` with a priority value for each bin.\n        The highest priority bin will be chosen.\n    \"\"\"\n    # Bins that can accept the item\n    can_fit = bins_remain_cap >= item\n    \n    # Remaining free space if the item were placed\n    leftover = bins_remain_cap - item\n    \n    # Create scores: use -leftover for bins that can fit, -inf otherwise\n    scores = np.where(can_fit, -leftover, -np.inf)\n    \n    # Shift scores for numerical stability and apply exp\n    finite = np.isfinite(scores)\n    if finite.any():\n        max_score = np.max(scores[finite])\n        shifted = np.where(finite, scores - max_score, scores)\n        priorities = np.where(finite, np.exp(shifted), 0.0)\n    else:\n        # No bin can fit: give zero priority to all bins\n        priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"First\u2011Fit inspired priority for online Bin Packing.\n\n    The function assigns the highest priority to the *first* bin (lowest\n    index) that can accommodate the incoming `item`. Bins that do not have\n    enough remaining capacity receive a penalty of ``-np.inf`` so they will\n    never be chosen.\n\n    The priority score for a feasible bin `i` is:\n        priority[i] = N - i\n    where `N` is the total number of bins. This ensures that:\n        * bins with lower indices have larger scores,\n        * the ordering of scores mirrors the First\u2011Fit order,\n        * ties (which cannot happen) are avoided.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array where each entry is the remaining capacity\n                         of a bin.\n\n    Returns:\n        A NumPy array of the same shape as ``bins_remain_cap`` containing the\n        priority score for each bin.\n    \"\"\"\n    # Ensure the input is a 1\u2011D NumPy array of floats.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float).ravel()\n\n    # Boolean mask of bins that can fit the item.\n    feasible = bins_remain_cap >= item\n\n    # Total number of bins (used to give larger values to early bins).\n    n_bins = bins_remain_cap.shape[0]\n\n    # Base priority decreasing with bin index: first bin gets n_bins, last gets 1.\n    index_priorities = n_bins - np.arange(n_bins, dtype=float)\n\n    # Assign priorities: feasible bins keep the index\u2011based priority,\n    # infeasible bins get -inf so they are never selected.\n    priorities = np.where(feasible, index_priorities, -np.inf)\n\n    return priorities",
    "response_id": 20,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best\u2011Fit priority function for the online Bin Packing Problem.\n\n    The function scores each bin such that the bin leaving the *least*\n    remaining capacity after the item is placed receives the highest score.\n    Infeasible bins (those that cannot accommodate the item) are assigned\n    a priority of ``-np.inf`` so they are never selected.\n\n    A tiny deterministic tie\u2011breaker based on bin index is added to avoid\n    exact ties when two bins would leave the same waste.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (float) for each bin, same shape as ``bins_remain_cap``.\n    \"\"\"\n    # Compute the remaining capacity *after* the item would be placed.\n    remaining = bins_remain_cap - item\n\n    # Feasibility mask: True where the item actually fits.\n    feasible = remaining >= 0\n\n    # Initialise all priorities to -inf (infeasible).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # For feasible bins, priority = -waste (i.e., negative remaining capacity).\n    # Larger priority => tighter fit (less waste).\n    priorities[feasible] = -remaining[feasible]\n\n    # Deterministic tie\u2011breaker: give a minuscule boost to bins with lower index.\n    # This boost is far smaller than the smallest possible difference in waste\n    # (bounded by the granularity of the problem data) and therefore does not\n    # affect the best\u2011fit ordering, but it removes exact ties.\n    epsilon = 1e-12\n    tie_boost = epsilon * (bins_remain_cap.size - np.arange(bins_remain_cap.size))\n    priorities[feasible] += tie_boost[feasible]\n\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority for the Worst-Fit online bin packing strategy.\n\n    For each bin that can accommodate the current item, the priority score is\n    the remaining capacity after the item is placed (i.e., the residual space).\n    Bins that cannot fit the item are given a priority of -inf so they will never\n    be selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores, one for each bin.\n    \"\"\"\n    # Identify bins that can still fit the item\n    can_fit = bins_remain_cap >= item\n\n    # Remaining capacity after insertion (only for bins that can fit)\n    residuals = bins_remain_cap - item\n\n    # Assign -inf priority to bins that cannot fit the item\n    priorities = np.where(can_fit, residuals, -np.inf)\n\n    return priorities",
    "response_id": 22,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Almost Full Fit priority.\n\n    We want to put the item into the bin that will be almost full after the\n    placement, while still being able to accommodate it.  Therefore we\n    rank bins by the remaining slack after insertion: smaller slack \u2192 higher\n    priority.  Bins that cannot fit receive a very low priority (negative\n    infinity) so they will never be chosen unless no feasible bin exists.\n\n    Parameters\n    ----------\n    item : float\n        The size of the incoming item.\n    bins_remain_cap : np.ndarray\n        One\u2011dimensional array containing the remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Float array of priority scores.  The index of the largest value is the\n        preferred bin for the item.\n    \"\"\"\n    # Ensure we work in float arithmetic and avoid division by zero.\n    eps = 1e-9\n\n    # Remaining space after placing the item in each bin.\n    slack = bins_remain_cap - item\n\n    # Start with the lowest possible priority for every bin.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Bins that can actually fit the item get a priority inversely\n    # proportional to the slack they would have left \u2013 the smaller the\n    # slack, the higher the priority.\n    fit_mask = slack >= 0\n    if np.any(fit_mask):\n        priorities[fit_mask] = 1.0 / (slack[fit_mask] + eps)\n\n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function using the Exact Fit First strategy.\n\n    The strategy first looks for a bin that can accommodate the item with zero\n    leftover capacity (exact fit).  If such a bin exists it will receive the\n    highest priority.  If no exact fit exists, the bin with the smallest\n    remaining leftover after placement is preferred.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array containing the remaining capacity of each bin.\n\n    Returns:\n        An array of the same shape as bins_remain_cap containing the\n        priority scores for each bin.  Larger values correspond to higher\n        priority.  Bins that cannot accommodate the item are assigned a very\n        low (negative infinite) score.\n    \"\"\"\n    # Compute space that would remain if the item were placed into each bin\n    # Bins that can't hold the item get a score of -\u221e so they are never selected.\n    remaining_after = bins_remain_cap - item\n    fits = remaining_after >= 0\n\n    # The priority is higher for smaller remaining capacity:\n    #  - 0  -> priority 0 (exact fit)\n    #  > 0 -> priority negative (but less negative is better)\n    priority_scores = np.where(\n        fits,\n        -remaining_after,   # exact fit gives 0, looser fit gives negative values\n        -np.inf             # cannot fit -> discard\n    )\n\n    return priority_scores",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse Distance (Proximity Fit) priority function for online BPP.\n\n    The heuristic favours bins that would have the smallest leftover slack\n    after receiving the item, i.e., the tightest possible fit.  For each\n    bin we compute the slack (remaining capacity minus the item size).  If\n    the slack is negative the bin cannot accommodate the item and receives a\n    priority of zero.  Otherwise the priority is proportional to the inverse\n    of the slack raised to a configurable exponent, sharpening the preference\n    for near\u2011perfect fits.  Finally the scores are normalised to ``[0, 1]`` so\n    that they can be compared across different problem instances.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the current remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority values for each bin. Higher values indicate more desirable\n        bins for the current item.\n    \"\"\"\n    # Convert input to a NumPy float array for safe vectorised ops.\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Slack after (hypothetically) placing the item into each bin.\n    slack = caps - item\n\n    # Feasibility mask: only bins with non\u2011negative slack can host the item.\n    feasible = slack >= 0.0\n\n    # Tiny epsilon to avoid division by zero when slack is exactly zero.\n    eps = np.finfo(np.float64).eps\n\n    # Exponent > 1 accentuates the advantage of tighter fits.\n    exponent = 1.5\n\n    # Initialise priorities with zeros (infeasible bins stay zero).\n    priorities = np.zeros_like(caps, dtype=np.float64)\n\n    # Inverse\u2011distance weighting for feasible bins.\n    priorities[feasible] = (1.0 / (slack[feasible] + eps)) ** exponent\n\n    # Normalise to the interval [0, 1] for interpretability.\n    max_prio = priorities.max()\n    if max_prio > 0:\n        priorities /= max_prio\n\n    return priorities",
    "response_id": 25,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Return a priority for each bin based on a Sigmoid Fit Score.\n\n    The score is high for bins where the item will leave very little residual\n    capacity, i.e., where the item tightly fits.  Infeasible bins\n    (item > remaining capacity) receive -np.inf so they are never chosen.\n\n    Args:\n        item: Size of the item to pack.\n        bins_remain_cap: 1\u2011D array of remaining capacities of each bin.\n\n    Returns:\n        Array of the same shape as bins_remain_cap with a floating priority\n        for each bin.\n    \"\"\"\n    item = float(item)\n\n    # Compute leftover capacity after placing the item\n    leftover = bins_remain_cap - item\n    # Which bins can accept the item?\n    feasible = leftover >= 0\n\n    # Initialize priorities to -\u221e for infeasible bins\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        # Normalised leftover fraction: 0 -> tight fit, 1 -> empty bin\n        norm_leftover = leftover[feasible] / bins_remain_cap[feasible]\n\n        # Sigmoid Fit Score: Sigmoid( a - b * (norm_leftover) )\n        # Parameters a, b tune the steepness and offset.\n        a, b = 5.0, 10.0\n        logits = a - b * norm_leftover\n        # Logistic function\n        priorities[feasible] = 1.0 / (1.0 + np.exp(-logits))\n\n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns a priority score for each bin based on the Random Fit strategy.\n\n    In Random Fit we select uniformly at random among all bins that can accommodate\n    the new item. This function assigns each eligible bin a random score in [0,1)\n    and assigns a very low score to all ineligible bins, ensuring they are never\n    chosen.  The stochastic priority values guarantee a random choice when the\n    selection routine picks the maximum score.\n\n    Args:\n        item: Size of the item to be added to a bin.\n        bins_remain_cap: Array containing the remaining capacity of each bin.\n\n    Returns:\n        numpy.ndarray of floats with the same shape as `bins_remain_cap`.  All\n        entries corresponding to bins that can hold the item receive a random\n        priority in [0, 1); entries for bins that cannot hold the item receive\n        `-inf`.\n    \"\"\"\n    # Start with a default very-low priority\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n\n    # Mask of bins that have enough capacity for the item\n    fit_mask = bins_remain_cap >= item\n\n    # Assign a random priority between 0 and 1 to each eligible bin\n    if np.any(fit_mask):\n        priorities[fit_mask] = np.random.rand(np.count_nonzero(fit_mask))\n\n    return priorities",
    "response_id": 27,
    "obj": 73.46429996011169,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    epsilon: float = 0.1,\n    noise_scale: float = 1e-6,\n) -> np.ndarray:\n    \"\"\"\n    Epsilon\u2011greedy priority function for the online Bin Packing Problem.\n\n    The function prefers the *Best\u2011Fit* bin (the feasible bin that will have the\n    smallest remaining capacity after the item is placed). With probability\n    ``epsilon`` it explores by assigning a random score to each feasible bin.\n    A tiny random ``noise`` term is added in the exploitation case to break ties.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining free capacity of each currently open bin.\n    epsilon : float, optional\n        Exploration probability (default 0.1). ``epsilon = 0`` disables exploration,\n        ``epsilon = 1`` selects a completely random feasible bin.\n    noise_scale : float, optional\n        Scale of the tie\u2011breaking noise added in exploitation mode (default 1e-6).\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` with a priority score for\n        each bin. Higher scores indicate higher preference. Bins that cannot hold\n        the item receive ``-np.inf`` (so they will never be selected unless all\n        bins are infeasible).\n    \"\"\"\n    # Identify bins that can actually accommodate the item.\n    feasible = bins_remain_cap >= item\n\n    # ----------------- Exploitation (Best\u2011Fit) -----------------\n    # Compute leftover capacity if the item were placed in each feasible bin.\n    leftover = bins_remain_cap - item\n    # Best\u2011Fit prefers the smallest leftover (i.e. largest negative leftover).\n    best_fit_score = np.where(feasible, -leftover, -np.inf)\n\n    # ------------------- Exploration -------------------------\n    # Assign a uniform random score to each feasible bin.\n    random_score = np.where(feasible, np.random.rand(bins_remain_cap.shape[0]), -np.inf)\n\n    # Decide whether to explore or exploit.\n    if np.random.rand() < epsilon:\n        # Exploration: use random scores.\n        priorities = random_score\n    else:\n        # Exploitation: use best\u2011fit scores, adding tiny noise to break ties.\n        noise = np.random.rand(bins_remain_cap.shape[0]) * noise_scale\n        priorities = best_fit_score + noise\n\n    return priorities",
    "response_id": 28,
    "obj": 4.178300757877951,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 0.05) -> np.ndarray:\n    \"\"\"\n    Softmax\u2010Based Fit priority function for the online Bin Packing Problem.\n\n    The function assigns a probability\u2011like priority to each bin based on how\n    tightly the item would fit into the remaining capacity. Bins that cannot\n    accommodate the item receive a priority of 0. Among feasible bins,\n    ``softmax`` is applied to the negative leftover space (i.e. the tighter\n    the fit, the larger the unnormalized score) which yields a smooth,\n    temperature\u2011controlled ranking.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array with the remaining capacity of each bin.\n        temperature: Positive scaling factor that controls the sharpness of\n                     the softmax. Small values make the selection more\n                     deterministic (near\u2011greedy), larger values promote\n                     exploration.\n\n    Returns:\n        An array of the same shape as ``bins_remain_cap`` containing priority\n        scores that sum to 1 over feasible bins (zeros for infeasible ones).\n    \"\"\"\n    # Ensure float dtype for subsequent calculations\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility mask: only bins that can hold the item\n    feasible = bins_remain_cap >= item\n\n    # Initialise scores with -inf so that infeasible bins get zero after softmax\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Compute leftover capacity after placing the item\n    leftover = bins_remain_cap - item  # >= 0 for feasible bins\n\n    # Better fit => smaller leftover => larger (less negative) score\n    # Using -leftover / temperature mirrors a Boltzmann distribution.\n    scores[feasible] = -leftover[feasible] / max(temperature, 1e-12)\n\n    # Numerical stability: subtract the max score before exponentiation\n    max_score = np.max(scores)  # will be -inf if no feasible bin\n    if np.isneginf(max_score):\n        # No bin can accept the item \u2013 return a zero vector\n        return np.zeros_like(bins_remain_cap, dtype=np.float64)\n\n    exp_scores = np.exp(scores - max_score)\n\n    # Softmax normalization (sum of exponentials over feasible bins)\n    priorities = exp_scores / np.sum(exp_scores)\n\n    # Enforce zero for infeasible bins (already zero, but explicit for clarity)\n    priorities[~feasible] = 0.0\n\n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]