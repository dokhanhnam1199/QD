```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    weight_leftover: float = 1.0,
    weight_fit: float = 1.0,
    weight_variance: float = 0.5,
    temperature: float = 0.1,
    epsilon: float = 0.05,
    noise_scale: float = 1e-4,
) -> np.ndarray:
    """
    Compute a priority (probability) for each currently open bin for an
    incoming item in the online bin‑packing problem.

    The raw score for a feasible bin *i* is a linear combination of three
    intuitive components:

    * **Leftover capacity** after placement (negative weight; smaller is
      better).
    * **Fit ratio** = item / remaining_capacity (positive weight; larger
      is better).
    * **Variance penalty** – variance of the remaining capacities after
      placement (negative weight; lower variance is better).

    The raw scores are transformed into a probability distribution using
    a temperature‑scaled softmax.  Infeasible bins (remaining capacity <
    item) receive a priority of ``0``.  Optional ε‑greedy exploration and a
    tiny random noise can be enabled to break ties and encourage
    exploration.

    Parameters
    ----------
    item : float
        Size of the incoming item (must be positive).
    bins_remain_cap : array‑like of shape (n_bins,)
        Remaining capacity of each open bin.
    weight_leftover : float, default=1.0
        Linear weight for the leftover‑capacity term.
    weight_fit : float, default=1.0
        Linear weight for the fit‑ratio term.
    weight_variance : float, default=0.5
        Linear weight for the variance‑penalty term.
    temperature : float, default=0.1
        Softmax temperature; lower values make the distribution sharper.
    epsilon : float, default=0.05
        Probability of performing ε‑greedy exploration (choose a random
        feasible bin).  Set to ``0`` to disable.
    noise_scale : float, default=1e-4
        Scale of uniform random noise added to raw scores before the
        softmax.  Set to ``0`` to disable.

    Returns
    -------
    priorities : ndarray of shape (n_bins,)
        Probability for selecting each bin.  Infeasible bins have priority
        ``0``.  If no bin can accommodate the item, all priorities are
        ``0``.
    """
    # ------------------------------------------------------------------
    # Input validation and conversion
    # ------------------------------------------------------------------
    if item <= 0:
        raise ValueError("Item size must be positive.")
    if temperature <= 0:
        raise ValueError("Temperature must be positive.")
    bins = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = bins.size
    if n_bins == 0:
        return np.array([], dtype=float)

    rng = np.random.default_rng()

    # ------------------------------------------------------------------
    # Feasibility mask
    # ------------------------------------------------------------------
    feasible = bins >= item
    if not np.any(feasible):
        # No bin can hold the item – return zeros
        return np.zeros_like(bins, dtype=float)

    # ------------------------------------------------------------------
    # Component calculations (vectorised)
    # ------------------------------------------------------------------
    # Leftover capacity after placement
    leftover = bins - item

    # Fit ratio (item / remaining capacity)
    fit_ratio = np.empty_like(bins)
    with np.errstate(divide="ignore", invalid="ignore"):
        np.divide(item, bins, out=fit_ratio, where=feasible)
    fit_ratio[~feasible] = 0.0

    # Variance of remaining capacities after placing the item into each bin
    total_sum = bins.sum()
    total_sq = np.square(bins).sum()
    mean_new = (total_sum - item) / n_bins
    sq_new = total_sq - 2.0 * item * bins + item ** 2
    var_after = sq_new / n_bins - mean_new ** 2
    var_after[~feasible] = 0.0

    # ------------------------------------------------------------------
    # Linear combination → raw score
    # ------------------------------------------------------------------
    raw_score = (
        -weight_leftover * leftover
        + weight_fit * fit_ratio
        - weight_variance * var_after
    )
    raw_score = np.where(feasible, raw_score, -np.inf)

    # ------------------------------------------------------------------
    # Optional exploration noise
    # ------------------------------------------------------------------
    if noise_scale > 0.0:
        noise = rng.random(n_bins) * noise_scale
        raw_score[feasible] += noise[feasible]

    # ------------------------------------------------------------------
    # ε‑greedy exploration
    # ------------------------------------------------------------------
    if epsilon > 0.0 and rng.random() < epsilon:
        rand_scores = np.full_like(bins, -np.inf)
        rand_scores[feasible] = rng.random(np.count_nonzero(feasible))
        raw_score = rand_scores

    # ------------------------------------------------------------------
    # Softmax with temperature → probability distribution
    # ------------------------------------------------------------------
    max_feas = raw_score[feasible].max()
    shifted = (raw_score - max_feas) / temperature
    exp_vals = np.exp(shifted)
    exp_vals[~feasible] = 0.0
    total = exp_vals.sum()
    if total == 0.0:
        return np.zeros_like(bins, dtype=float)
    priorities = exp_vals / total
    return priorities
```
