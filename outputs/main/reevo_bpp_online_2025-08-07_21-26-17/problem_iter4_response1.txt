```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    temperature: float = 1.0,
    alpha: float = 0.5,
    fit_weight: float = 1.0,
) -> np.ndarray:
    """
    Softmax‑based priority for online bin packing.

    The score for each *feasible* bin i combines three criteria:
        • leftover capacity after placement (smaller is better)
        • fit ratio   = item / remaining_capacity (larger is better)
        • variance of the remaining capacities after placement
          (smaller variance promotes load‑balancing)

    The raw score for bin i is
        s_i = - (remaining_i - item)
              + fit_weight * (item / remaining_i)
              - alpha * var_i

    where var_i is the variance of the capacities after hypothetically
    placing the item into bin i.

    The scores are transformed with a temperature‑scaled softmax:
        priority_i = exp((s_i - max(s)) / temperature)
                     / Σ_j exp((s_j - max(s)) / temperature)

    Infeasible bins (remaining capacity < item) receive priority 0.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the current bins.
    temperature : float, optional
        Softmax temperature (>0). Small values make the selection
        more deterministic; larger values yield a flatter distribution.
    alpha : float, optional
        Weight of the variance penalty. Larger values favour a more
        balanced load across bins.
    fit_weight : float, optional
        Weight of the fit‑ratio term. Larger values give preference to
        bins that fit the item tightly.

    Returns
    -------
    np.ndarray
        Priority values for each bin (same shape as ``bins_remain_cap``).
        The values sum to 1 across feasible bins; infeasible bins have
        priority 0.
    """
    # Convert input to a float array and handle empty input
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)
    n_bins = bins_remain_cap.size
    if n_bins == 0:
        return np.array([], dtype=float)

    if temperature <= 0.0:
        raise ValueError("temperature must be a positive number")

    # Feasibility mask
    feasible = bins_remain_cap >= item

    # If no bin can accommodate the item, return all zeros
    if not feasible.any():
        return np.zeros_like(bins_remain_cap, dtype=float)

    # --- Component 1: leftover capacity after placement ---
    leftover = bins_remain_cap - item                     # shape (n_bins,)

    # --- Component 2: fit ratio ---
    # item / capacity; safe because bins_remain_cap > 0 (feasible implies >= item > 0)
    fit_ratio = np.empty_like(bins_remain_cap)
    # Avoid division by zero for zero-capacity bins (should be infeasible anyway)
    with np.errstate(divide='ignore', invalid='ignore'):
        fit_ratio[:] = item / bins_remain_cap
    fit_ratio[~feasible] = 0.0  # irrelevant for infeasible bins

    # --- Component 3: variance after placement ---
    # Compute total sum and sum of squares once
    total_sum = bins_remain_cap.sum()
    total_sq_sum = np.square(bins_remain_cap).sum()
    new_sum = total_sum - item  # total remaining capacity after placing the item

    # Variance after placing the item into each bin i:
    # var_i = (total_sq_sum - 2*item*cap_i + item**2) / n_bins - (new_sum / n_bins)**2
    var_after = (
        (total_sq_sum - 2.0 * item * bins_remain_cap + item ** 2) / n_bins
        - (new_sum / n_bins) ** 2
    )
    var_after[~feasible] = 0.0  # irrelevant for infeasible bins

    # --- Raw score ---
    # We want high score for good bins, so combine with signs accordingly
    raw_score = -leftover + fit_weight * fit_ratio - alpha * var_after

    # Infeasible bins should never be selected: assign -inf before softmax
    raw_score = np.where(feasible, raw_score, -np.inf)

    # --- Softmax transformation ---
    # Numerical stability: subtract the max of feasible scores
    max_feas = raw_score[feasible].max()
    scaled = (raw_score - max_feas) / temperature

    # Exponentiate; exp(-inf) -> 0 automatically
    exp_scaled = np.exp(scaled)

    # Normalise to obtain probabilities (priorities)
    total_exp = exp_scaled[feasible].sum()
    if total_exp == 0.0:
        # Edge case: all feasible scores were -inf (should not happen)
        priorities = np.zeros_like(bins_remain_cap, dtype=float)
    else:
        priorities = exp_scaled / total_exp

    return priorities
```
