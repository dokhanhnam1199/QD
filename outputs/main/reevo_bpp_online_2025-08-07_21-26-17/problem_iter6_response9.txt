```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    temperature: float = 1.0,
    alpha: float = 0.5,
    fit_weight: float = 1.0
) -> np.ndarray:
    """
    Compute priority scores for bins in an online bin‑packing problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of existing bins.
    temperature : float, optional
        Softmax temperature (>0). Small values make the selection more
        deterministic; larger values yield a flatter distribution.
    alpha : float, optional
        Weight for the variance penalty. Larger values favour a more
        balanced load across bins.
    fit_weight : float, optional
        Weight for the fit‑ratio term. Larger values give preference to
        bins that fit the item tightly.

    Returns
    -------
    np.ndarray
        Priority values for each bin (same shape as ``bins_remain_cap``).
        The values sum to 1 across feasible bins; infeasible bins have
        priority 0.
    """
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)
    n_bins = bins_remain_cap.size

    if n_bins == 0:
        return np.array([], dtype=float)

    if temperature <= 0.0:
        raise ValueError("temperature must be positive")

    # Feasibility mask
    feasible = bins_remain_cap >= item

    # No feasible bin -> zero priorities
    if not feasible.any():
        return np.zeros_like(bins_remain_cap)

    # --- Component 1: leftover after placement ---
    leftover = bins_remain_cap - item

    # --- Component 2: fit ratio (larger is better) ---
    with np.errstate(divide='ignore', invalid='ignore'):
        fit_ratio = np.where(feasible, item / bins_remain_cap, 0.0)

    # --- Component 3: variance after placement ---
    total_sum = bins_remain_cap.sum()
    total_sq_sum = np.square(bins_remain_cap).sum()
    new_sum = total_sum - item  # total remaining capacity after placement

    var_after = (
        (total_sq_sum - 2.0 * item * bins_remain_cap + item ** 2) / n_bins
        - (new_sum / n_bins) ** 2
    )
    var_after[~feasible] = 0.0

    # --- Raw score: higher is better ---
    raw = -leftover + fit_weight * fit_ratio - alpha * var_after
    raw[~feasible] = -np.inf

    # --- Softmax transformation ---
    max_raw = raw[feasible].max()
    exp_vals = np.exp((raw - max_raw) / temperature)
    total_exp = exp_vals[feasible].sum()

    if total_exp == 0.0:
        # Fallback: uniform distribution over feasible bins
        probs = np.zeros_like(bins_remain_cap)
        probs[feasible] = 1.0 / feasible.sum()
        return probs

    probs = np.where(feasible, exp_vals / total_exp, 0.0)

    return probs
```
