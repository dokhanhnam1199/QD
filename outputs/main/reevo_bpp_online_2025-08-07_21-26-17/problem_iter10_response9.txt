```python
import numpy as np
from typing import Optional


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    random_state: Optional[int] = None,
    epsilon_min: float = 0.05,
    epsilon_max: float = 0.25,
) -> np.ndarray:
    """
    Compute a priority score for each bin when packing an online Bin Packing
    Problem (BPP) item.

    The priority is higher for bins that would leave less leftover space after
    placing the item (tight‑fit). An epsilon‑greedy exploration component is
    adapted based on the normalized variance of the leftover space among
    feasible bins.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    random_state : int or None, optional
        Seed for reproducibility of the random exploration component.
    epsilon_min, epsilon_max : float, optional
        Minimum and maximum exploration probabilities. The actual epsilon is
        interpolated based on the normalized variance of leftover space.

    Returns
    -------
    np.ndarray
        Priority scores for each bin. Infeasible bins (capacity < item) receive
        ``-np.inf``. The bin with the highest score should be selected for the
        item.
    """
    # Ensure we work with a NumPy float64 array.
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Feasibility mask: bins that can accommodate the item.
    feasible = caps >= item
    if not np.any(feasible):
        # No bin can hold the item – all scores are -inf.
        return np.full_like(caps, -np.inf, dtype=np.float64)

    # Leftover capacity after (hypothetically) placing the item.
    leftover = caps - item

    # Base exploitation score: tighter fits (smaller leftover) get higher scores.
    eps = 1e-12  # avoid division by zero.
    base = np.zeros_like(caps, dtype=np.float64)
    base[feasible] = 1.0 / (leftover[feasible] + eps)

    # --- Adaptive epsilon based on variance of leftover space ---
    lo = leftover[feasible]
    L = np.max(lo) if lo.size > 0 else 0.0
    var = np.var(lo) if lo.size > 0 else 0.0

    # Normalized variance in [0, 1]; max variance for a uniform distribution on [0, L] is L^2/12,
    # but a tighter bound L^2/4 is used to keep the scaling simple.
    var_norm = 0.0
    if L > 0.0:
        var_max = (L ** 2) / 4.0
        var_norm = np.clip(var / var_max, 0.0, 1.0)

    # Higher variance → higher exploration (epsilon closer to epsilon_max).
    epsilon = epsilon_min + (epsilon_max - epsilon_min) * var_norm

    # Random exploration component (uniform in [0, 1]).
    rng = np.random.default_rng(random_state)
    random_score = rng.random(caps.shape)

    # Combine exploitation and exploration.
    priorities = np.full_like(caps, -np.inf, dtype=np.float64)
    priorities[feasible] = (1.0 - epsilon) * base[feasible] + epsilon * random_score[feasible]

    # Deterministic tie‑breaker: add a vanishingly small unique offset to each bin.
    priorities += np.arange(caps.size, dtype=np.float64) * 1e-12

    return priorities
```
