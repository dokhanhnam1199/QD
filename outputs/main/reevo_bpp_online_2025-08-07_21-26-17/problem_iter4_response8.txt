```python
import numpy as np
from typing import Union

def priority_v2(item: float, bins_remain_cap: Union[np.ndarray, list, tuple]) -> np.ndarray:
    """
    Deterministic priority function for the online Bin Packing Problem.

    For each currently open bin we compute a score that rewards:
      * a tight fit – the item occupies a large fraction of the free space;
      * little waste – the leftover capacity after placement is small.

    Both criteria are transformed by logistic (sigmoid) functions and combined
    multiplicatively.  Bins that cannot accommodate the item receive ``-np.inf``
    so they are never selected.  A tiny deterministic tie‑breaker favours lower‑
    index bins when scores are otherwise identical.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item ≤ bin capacity).
    bins_remain_remain_cap : array‑like
        1‑D array of remaining capacities of each open bin.

    Returns
    -------
    np.ndarray
        Array of priority scores (higher is better) with the same shape as
        ``bins_remain_cap``. Infeasible bins are assigned ``-np.inf``.
    """
    # Convert to NumPy array of float64.
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)

    n_bins = bins_remain_cap.shape[0]

    # Initialise all priorities as infeasible.
    priorities = np.full(n_bins, -np.inf, dtype=np.float64)

    # No bins → return empty array.
    if n_bins == 0:
        return priorities

    # Feasibility mask.
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        return priorities

    # ----------------------------------------------------------------------
    # 1) Fit‑ratio component – fraction of free space used by the item.
    # ----------------------------------------------------------------------
    fit_ratio = np.zeros_like(bins_remain_cap)
    # Safe division only where feasible.
    np.divide(item, bins_remain_cap, out=fit_ratio, where=feasible)

    # Sigmoid for fit ratio (steep transition around target_fit).
    alpha_fit = 12.0          # steepness
    target_fit = 0.75         # ratio where score ≈ 0.5
    # Clamp argument to avoid overflow in exp.
    fit_arg = -alpha_fit * (fit_ratio - target_fit)
    fit_arg = np.clip(fit_arg, -700, 700)
    fit_score = 1.0 / (1.0 + np.exp(fit_arg))

    # ----------------------------------------------------------------------
    # 2) Waste component – encourage small leftover space.
    # ----------------------------------------------------------------------
    # Estimate true bin capacity.  The largest remaining capacity among open
    # bins is a good proxy; fall back to ``item`` if all bins are smaller.
    est_capacity = max(np.max(bins_remain_cap), item)

    waste = bins_remain_cap - item          # may be negative for infeasibles
    waste_norm = np.clip(waste / est_capacity, 0.0, 1.0)  # ∈ [0,1]

    # Sigmoid for waste (high score when waste ≤ waste_target).
    alpha_waste = 10.0
    waste_arg = alpha_waste * (waste_norm - 0.10)  # waste_target = 0.10
    waste_arg = np.clip(waste_arg, -700, 700)
    waste_score = 1.0 / (1.0 + np.exp(waste_arg))

    # ----------------------------------------------------------------------
    # 3) Combine components multiplicatively.
    # ----------------------------------------------------------------------
    combined = fit_score * waste_score

    # Assign combined scores to feasible bins.
    priorities[feasible] = combined[feasible]

    # ----------------------------------------------------------------------
    # 4) Deterministic tie‑breaker – favour lower‑index bins.
    # ----------------------------------------------------------------------
    epsilon = 1e-9
    indices = np.arange(n_bins, dtype=np.float64)
    priorities[feasible] -= epsilon * indices[feasible]

    return priorities
```
