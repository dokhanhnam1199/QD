{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Random Fit priority function for online Bin Packing.\n    Returns a random priority for each bin that can accommodate the item.\n    Infeasible bins receive ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` where each entry holds\n        a random priority if the item fits, otherwise ``-np.inf``.\n    \"\"\"\n    # Ensure we work with a NumPy array (copy on view, not modify caller).\n    # This also allows support for Python lists or other sequences.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Identify bins that have enough free space for the item.\n    feasible = bins_remain_cap >= item\n\n    # Initialise all priorities as -inf (worst possible).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Assign a uniform random priority to each feasible bin.\n    if np.any(feasible):\n        # Using a local Generator isolates the RNG state from global NumPy RNG.\n        rng = np.random.default_rng()\n        priorities[feasible] = rng.random(feasible.sum())\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    steepness: float = 12.0,\n    midpoint: float = 0.5,\n    eps: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Sigmoid Fit Score priority for online Bin Packing.\n\n    For each bin we compute a score based on how well the incoming `item`\n    fits into the remaining capacity of the bin. The ratio `r = item / cap`\n    (where `cap` is the remaining capacity) lies in (0, 1] for feasible bins.\n    A logistic (sigmoid) transformation of this ratio emphasizes bins that\n    would be filled tightly (ratio close to 1) and de\u2011emphasizes bins that\n    would leave a large amount of waste.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining capacity of each bin.\n    steepness : float, optional\n        Controls the steepness of the sigmoid. Larger values make the function\n        more aggressive (i.e., more strongly prefer bins that almost fill up).\n    midpoint : float, optional\n        The ratio at which the sigmoid outputs 0.5. Typically 0.5,\n        but can be tuned to bias towards tighter or looser fits.\n    eps : float, optional\n        Small constant to avoid division by zero.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``). Infeasible bins\n        (where ``item`` does not fit) receive a score of 0.0.\n    \"\"\"\n    # Ensure a NumPy array of floats for vectorised operations\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item\n    feasible = caps + eps >= item  # +eps guards against floating\u2011point noise\n\n    # Early exit: if nothing fits, return an array of zeros\n    if not np.any(feasible):\n        return np.zeros_like(caps, dtype=float)\n\n    # Compute the fit ratio only for feasible bins\n    # Ratio = item size divided by the bin's remaining capacity\n    ratio = np.empty_like(caps, dtype=float)\n    ratio[:] = 0.0                     # initialise with zeros for safety\n    ratio[feasible] = item / caps[feasible]\n\n    # Apply a sigmoid transformation:\n    #   s(r) = 1 / (1 + exp(-steepness * (r - midpoint)))\n    # This yields values in (0, 1), close to 1 when r \u2248 1 (tight fit)\n    # and close to 0 when r is small (poor fit).\n    sigmoid = 1.0 / (1.0 + np.exp(-steepness * (ratio[feasible] - midpoint)))\n\n    # Assemble the final priority array: feasible bins get the sigmoid score,\n    # infeasible bins retain 0.0 (lowest possible priority).\n    priorities = np.zeros_like(caps, dtype=float)\n    priorities[feasible] = sigmoid\n\n    # Clip to the [0, 1] interval for numerical robustness\n    np.clip(priorities, 0.0, 1.0, out=priorities)\n\n    return priorities\n\n[Reflection]\nPrefer deterministic, fit\u2011aware scores; use smooth monotonic functions; penalize waste; vectorize; treat infeasible bins as minimal priority.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}