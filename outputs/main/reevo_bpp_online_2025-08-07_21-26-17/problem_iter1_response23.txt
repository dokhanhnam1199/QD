```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Almost Full Fit priority.

    We want to put the item into the bin that will be almost full after the
    placement, while still being able to accommodate it.  Therefore we
    rank bins by the remaining slack after insertion: smaller slack → higher
    priority.  Bins that cannot fit receive a very low priority (negative
    infinity) so they will never be chosen unless no feasible bin exists.

    Parameters
    ----------
    item : float
        The size of the incoming item.
    bins_remain_cap : np.ndarray
        One‑dimensional array containing the remaining capacity of each bin.

    Returns
    -------
    np.ndarray
        Float array of priority scores.  The index of the largest value is the
        preferred bin for the item.
    """
    # Ensure we work in float arithmetic and avoid division by zero.
    eps = 1e-9

    # Remaining space after placing the item in each bin.
    slack = bins_remain_cap - item

    # Start with the lowest possible priority for every bin.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Bins that can actually fit the item get a priority inversely
    # proportional to the slack they would have left – the smaller the
    # slack, the higher the priority.
    fit_mask = slack >= 0
    if np.any(fit_mask):
        priorities[fit_mask] = 1.0 / (slack[fit_mask] + eps)

    return priorities
```
