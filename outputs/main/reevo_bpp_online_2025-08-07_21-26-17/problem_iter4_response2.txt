```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for each bin in the online Bin Packing Problem.

    The heuristic normalises the leftover capacity after hypothetically placing the
    item, then feeds this value into a sigmoid that rewards tight fits.  When
    ``adaptive`` behaviour is enabled (hard‑coded to True), the steepness of the
    sigmoid is scaled by the standard deviation of the normalised leftovers among
    feasible bins, allowing the method to react to the current distribution of
    bin utilizations.  A tiny deterministic tie‑breaker proportional to the tightness
    of the fit ensures a unique selection when scores are otherwise equal.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the current bins (non‑negative).

    Returns
    -------
    np.ndarray
        Array of priority scores with the same shape as ``bins_remain_cap``.
        Infeasible bins (where the item does not fit) receive ``-np.inf``.
    """
    # Ensure a NumPy array of floats for safe vectorised operations
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Compute leftover capacity after (hypothetically) placing the item
    leftover = caps - item

    # Feasibility mask: True where the item fits
    feasible = leftover >= 0

    # Initialise all priorities to -inf (infeasible)
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # If no bin can accommodate the item, return early
    if not np.any(feasible):
        return priorities

    # Normalised leftover fraction: 0 → perfect fit, 1 → empty bin
    # Guard division by zero (possible only when caps == 0 and item == 0)
    norm_leftover = np.empty_like(caps, dtype=float)
    caps_feas = caps[feasible]
    leftover_feas = leftover[feasible]
    with np.errstate(divide='ignore', invalid='ignore'):
        norm_leftover[feasible] = np.where(
            caps_feas > 0,
            leftover_feas / caps_feas,
            0.0
        )
    # Infeasible entries are irrelevant; set to zero for completeness
    norm_leftover[~feasible] = 0.0

    # Adaptive steepness scaling based on variance of normalised leftovers
    adaptive = True  # hard‑coded as per reflection
    if adaptive:
        std = np.std(norm_leftover[feasible])
        scale = std if std > 1e-12 else 1.0  # avoid division by zero
    else:
        scale = 1.0

    # Sigmoid parameters (tuned for typical bin‑packing ranges)
    a = 5.0   # offset – shifts the curve upward
    b = 10.0  # base steepness – larger → sharper drop for looser fits

    # Logits for the sigmoid: larger when norm_leftover is small (tight fit)
    logits = a - (b / scale) * norm_leftover[feasible]

    # Numerically stable sigmoid using tanh formulation:
    # sigmoid(x) = 0.5 * (1 + tanh(x/2))
    scores = 0.5 * (1.0 + np.tanh(logits / 2.0))

    # Deterministic tie‑breaker: favour tighter fits (smaller norm_leftover)
    eps_tie = 1e-8
    tie = eps_tie * (1.0 - norm_leftover[feasible])

    # Assign final priority scores to feasible bins
    priorities[feasible] = scores + tie

    return priorities
```
