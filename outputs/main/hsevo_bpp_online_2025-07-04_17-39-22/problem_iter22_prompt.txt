{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins balancing utilization, fragmentation, exploration, and item size.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    feasible_mask = ~infeasible_mask\n    feasible_bins_remain_cap = bins_remain_cap[feasible_mask]\n\n    if np.sum(feasible_mask) > 0:\n        remaining_capacity_after_fit = feasible_bins_remain_cap - item\n        capacity_ratio = item / feasible_bins_remain_cap\n\n        priorities[feasible_mask] = capacity_ratio**2.0 #Bin Utilization, tuned exponent\n\n        #Small Fragments.\n        small_fragment_threshold = 0.2 * item\n        small_fragment_mask = remaining_capacity_after_fit > 0  & (remaining_capacity_after_fit < small_fragment_threshold)\n        priorities[feasible_mask][small_fragment_mask] *= 0.3  #Small Fragment Penalty\n\n        #Large capacity bonus\n        large_capacity_threshold = 1.5 * item\n        large_capacity_mask = remaining_capacity_after_fit > large_capacity_threshold\n        priorities[feasible_mask][large_capacity_mask] *= 1.2 #Large Capacity Bonus\n\n        #Adaptive exploration\n        num_feasible = np.sum(feasible_mask)\n        if num_feasible > 4:\n            priorities[feasible_mask] *= (1 + 0.05 * capacity_ratio) #Exploitation\n        else:\n            priorities += np.random.normal(0, 0.1, size=len(priorities)) #Exploration\n\n        #Dynamic fragment penalty\n        fragment_penalty_threshold = 0.3 * item\n        fragment_penalty_mask = (remaining_capacity_after_fit > 0) & (remaining_capacity_after_fit < fragment_penalty_threshold)\n        priorities[feasible_mask][fragment_penalty_mask] *= (1 - (remaining_capacity_after_fit[fragment_penalty_mask] / fragment_penalty_threshold) * 0.7)\n\n        #Large item bonus\n        if item > bins_remain_cap.max() * 0.6:\n            well_utilized_mask = capacity_ratio > 0.7\n            priorities[feasible_mask][well_utilized_mask] *= (1 + 0.15) #Large item placed in well-utilized bin\n\n        #Almost full bonus\n        almost_full_threshold = bins_remain_cap.max() * 0.1\n        almost_full_mask = remaining_capacity_after_fit < almost_full_threshold #using rem_cap after fit\n        priorities[feasible_mask][almost_full_mask] *= (1 + 0.2) #Almost full bonus\n        \n        priorities += np.random.normal(0, 0.05, size=len(priorities)) #Base exploration noise\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}