[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First, consider only bins that can actually fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    if not np.any(valid_bins):\n        # If no bin can fit the item, prioritize the fullest bin (least remaining capacity)\n        priorities = -bins_remain_cap\n        return priorities\n    \n    \n    # Calculate remaining space AFTER packing the item (for valid bins)\n    remaining_after_pack = bins_remain_cap[valid_bins] - item\n    \n    # Prioritize bins with smaller remaining space after packing (First Fit Decreasing inspired)\n    priorities[valid_bins] = -remaining_after_pack\n    \n    # Add a bonus for bins that are close to full before packing (avoid fragmentation).\n    priorities[valid_bins] += (bins_remain_cap[valid_bins] / np.sum(bins_remain_cap))  #Scale by sum of bin capacities\n    \n    \n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Einstein's Field Equation Inspired Term: Curvature of Bin Space\n    #  The 'curvature' is high when bins are nearly full (close to item size).\n    #  This incentivizes using bins that are 'bent' towards capacity.\n    curvature = np.exp(-np.abs(bins_remain_cap - item))\n\n    # Cosmological Constant Inspired Term: A universal pressure to fill all bins, but modulated.\n    #   This ensures that even bins with less-than-ideal fit still get a chance, preventing premature new bin creation.\n    cosmological_constant = np.where(bins_remain_cap >= item, 0.1, -np.inf) # Give slight encouragement, large discouragement\n\n    # Relative Remaining Capacity: Encourage bins with suitable space.\n    relative_capacity = (bins_remain_cap - item) / bins_remain_cap\n    relative_capacity = np.where(bins_remain_cap >= item, np.clip(relative_capacity, 0, 1), -np.inf) #valid only if bin has space for item. Negative inf. otherwise\n\n    # Stability Term: Prevent filling nearly full bins at the expense of slightly larger bins\n    stability = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n\n    # Combine all terms with some scaling factors.\n    priorities = 0.5 * curvature + 0.2 * cosmological_constant + 0.4 * relative_capacity + 0.1 * stability\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 149.2919824491424,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., 0).\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item.\n    valid_bins = bins_remain_cap >= item\n\n    # If no bin can accommodate the item, return a low priority for all bins.\n    if not np.any(valid_bins):\n        return priorities - 1e9  # Very low priority for all\n\n    # Calculate fill ratios for valid bins: (capacity - item_size) / original capacity\n    # However, we don't have original capacity readily available. So, we use this approximation.\n    fill_ratios = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n\n    # Apply Newton's inverse square law-inspired priority: Priority increases as fill ratio increases, but decreases inversely proportional to the remaining space.\n    priorities[valid_bins] = fill_ratios / (bins_remain_cap[valid_bins] + 1e-6) # Small constant to avoid division by zero\n\n    # Boosting bins with smaller remaining capacity after placing item.\n    # Encourage filling up bins more completely.\n\n    remaining_after_placement = bins_remain_cap[valid_bins] - item\n    # Ensure that the bin is not overfilled\n    remaining_after_placement = np.clip(remaining_after_placement, a_min=0, a_max=None)\n    priority_boost = np.exp(-remaining_after_placement)\n\n    priorities[valid_bins] *= priority_boost\n\n    #Add some noise to the priority score to handle degeneracy (Equal priority scores). This will break ties in random.\n    noise = np.random.normal(0, 1e-6, len(priorities))\n    priorities += noise\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 34.4734742720383,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins where the item fits reasonably well,\n    avoiding both bins that are too full (small remaining capacity)\n    and bins that are too empty (large remaining capacity compared to item size).\n    It also penalizes bins where the item almost perfectly fills the bin (leaving very little space),\n    encouraging a more balanced fill across bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give a high priority to bins where the item fits (positive remaining capacity).\n    # Penalize bins where item doesn't fit by assigning a very low priority.\n    fits = bins_remain_cap >= item\n    priorities[~fits] = -np.inf # Very Low Priority: Cannot fit\n\n    valid_bins = bins_remain_cap[fits]\n\n    if len(valid_bins) > 0:\n\n      # Calculate the fill ratio after adding the item to valid bins.\n      fill_ratio = item / valid_bins\n      remaining_space = valid_bins - item\n\n      # 1. Encourage bins where the item uses a substantial portion of the bin's capacity,\n      # but doesn't fill it up almost entirely.  Avoid almost perfect fits\n\n      priorities[fits] = np.exp(-5*np.abs(fill_ratio - 0.7))  # centered on 0.7 filling percentage with exponential drop off\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 10.041882728360594,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic 1: Fill bins as much as possible but avoid overfilling\n    fit_score = bins_remain_cap - item\n    fit_priority = np.where(fit_score >= 0, np.exp(-np.abs(fit_score)), -np.inf)  # Higher priority to closer fit, negative infinity if doesn't fit\n\n    # Heuristic 2: Consider the remaining capacity after placement. Lower remaining capacity is better. Avoid tiny gaps.\n    remaining_cap_penalty = np.where(fit_score >= 0, np.exp(-5 * fit_score), 0)  # Penalize larger remaining gaps. The factor of 5 is tuned. Zero if item doesn't fit\n    # Heuristic 3: Prefer bins with greater initial utilization, less likely to open a new bin\n    utilization_priority = np.zeros_like(bins_remain_cap)\n    initial_capacity = bins_remain_cap + item # initial capacity = current cap + the item size only if the bin can accomodate the item\n    utilization_priority[fit_score>=0] = 1 / initial_capacity[fit_score>=0] # smaller initial capacity is better\n\n    # Combine heuristics using weighted sum. Experiment with weights\n    priorities = 0.7 * fit_priority + 0.2 * remaining_cap_penalty + 0.1 * utilization_priority\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    A more sophisticated heuristic considering multiple factors.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Can the item fit in the bin?\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        # If no bin can fit the item, prioritize nearly full bins. This\n        # forces creation of new bins quicker, preventing scenarios where\n        # many bins are left slightly under-utilized. Note: Should be impossible in theory unless floating point issue exists, but useful in practise.\n\n        # In this unusual edge case, we give near empty bins a penalty.\n        # we want to force using them.\n        priorities = bins_remain_cap # Smallest value (least capacity) have lower prioritiy.\n\n        return priorities\n\n\n    # 2. Prioritize bins where the remaining capacity is closest to item size (Best Fit) within only the feasible bins\n    capacity_diff = bins_remain_cap - item\n    capacity_diff[~feasible_bins] = np.inf  # Ignore infeasible bins in best-fit calculation\n\n    best_fit_priority = -np.abs(capacity_diff) # Closer is better so the negative of absolute difference to remaining is highest.\n    best_fit_priority[~feasible_bins] = -np.inf  # Zero-out priorities outside feasible solutions\n    priorities += best_fit_priority # Add contribution to total priority.\n    #3. Add a tie breaker for scenarios when 2 or more bins are equally optimal (i.e., almost fully utilized or same remaining).\n    # We want to use an existing bin that is already relatively empty more (i.e., least recently added, for example)\n    # Add a slight penalty for fuller bins if there's a tie (breaks tie in favour of less empty bins\n    priorities[feasible_bins] += bins_remain_cap[feasible_bins] * 0.0001 # very small.\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version introduces a few improvements:\n    1.  It strongly discourages exceeding capacity.  Bins that cannot fit the\n        item get a very negative priority.\n    2.  It prefers bins that have capacity close to the item size, but with\n        a bias towards using bins that are already partially full.  This is\n        achieved by considering both the absolute difference between item size\n        and remaining capacity, and the initial capacity of each bin.\n    3.  Prioritizes completely empty bins *less* to allow partially filled bins to be utilized before starting new bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very negative priority if the item doesn't fit\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Heuristic based on how well the item fits and encourages utilizing partially-filled bins\n    fit_score = np.exp(-np.abs(bins_remain_cap - item) / item)\n\n    # Add bonus if the bin is already used\n    is_used_bonus = (bins_remain_cap < 1).astype(float) #Bins with remaining cap < 1 are considered used\n\n    priorities = fit_score + is_used_bonus\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Employing a probabilistic packing strategy inspired by quantum mechanics,\n    prioritizing bins based on a 'potential well' analogy.  The fuller the\n    bin (smaller remaining capacity), the steeper the potential, and hence\n    the higher the probability (priority) of attracting the item. A touch of\n    uncertainty is added to avoid getting stuck in local minima.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-6  # Small constant to avoid division by zero and log(0)\n    potential_energy = -np.log(bins_remain_cap + epsilon)  # Inverted log function simulates a potential well\n\n    # A large negative potential means lower remaining capacity i.e. a 'steeper' well, hence, high priority.\n    # Normalize by item size, so large items are less likely to get crammed into barely fitting bins,\n    # but rather into bins with room to spare.  This mitigates fragmentation to a degree.\n    priority = potential_energy / (item + epsilon) # Divide by Item, so that smaller items can fill almost-full-bins\n\n    # introduce some quantum noise: This perturbs the priority so we explore other packings sometimes.\n    noise = np.random.normal(0, 0.1, size=bins_remain_cap.shape) # Gaussian random noise with stdev 0.1\n    priority += noise  # Adds \"quantum fluctuations\" to the bin priorities\n\n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 56.102911846828896,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities to a very low value.\n    priorities = np.full(bins_remain_cap.shape, -np.inf)\n\n    # Iterate through bins and calculate priority, prioritizing bins that\n    # can accommodate the item.\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate the fill ratio after adding the item. A higher fill\n            # ratio (closer to 1) is generally better, but we want to\n            # avoid bins that are *too* full (e.g., > 0.95), as that leaves\n            # little room for future items.\n\n            fill_ratio_after = (item + (bins_remain_cap[i] - cap)) / (bins_remain_cap[i] + (bins_remain_cap[i] - cap) ) if (bins_remain_cap[i] + (bins_remain_cap[i] - cap) ) > 0 else 0\n\n            # Heuristic: Prioritize bins with remaining capacity slightly larger than the item.\n            # This aims to reduce fragmentation. Also, a small penalty for near full bins.\n            priority =  1.0/(cap - item + 1e-6)  - (fill_ratio_after > 0.95) * 100 # Avoid almost full bins, big penalty\n            priority += fill_ratio_after\n\n            priorities[i] = priority\n        else:\n            priorities[i] = -np.inf  # Cannot fit the item\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999992308999936 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Aims for a balance between filling bins well and avoiding excessive fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if item <= remaining_capacity:\n            # Base priority on how well the item fills the bin (higher is better).\n            fill_ratio = item / remaining_capacity\n            priorities[i] = fill_ratio\n\n            # Add a bonus for leaving a \"useful\" amount of space.\n            # This heuristic tries to avoid small fragments by rewarding bins that will have enough space remaining for another medium-sized item.\n            # \"Useful\" is defined here as somewhere around 20-50% of bin capacity, but adjust accordingly.\n            remaining_after_fit = remaining_capacity - item\n            if 0.2 <= remaining_after_fit <= 0.5:\n                priorities[i] += 0.5  # Boost for leaving a useful fragment\n\n            # Add a penalty for leaving a very small remainder, indicating fragmentation.\n            elif remaining_after_fit < 0.1:\n                priorities[i] -= 0.3  # Small penalty for tiny fragments\n\n        else:\n            priorities[i] = -np.inf  # Cannot fit, so very low priority\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.836457917830076,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the remaining capacity after placing the item\n    new_remain_cap = bins_remain_cap - item\n    \n    # Give high priority to bins that can accommodate the item\n    can_accommodate = new_remain_cap >= 0\n    priorities[can_accommodate] += 1  # Basic priority\n\n    # Further prioritize bins where the remaining capacity is small but non-negative (minimize wasted space)\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf # Set bins that cannot accommodate to infinite waste.\n    \n    priorities[can_accommodate] += (1 / (waste[can_accommodate] + 0.00001))  #avoid division by zero\n    \n\n    # Optionally, penalize bins that are already very full to encourage spreading items\n    #fullness = 1 - (bins_remain_cap / bins_remain_cap.max())  # Normalize to between 0 and 1\n\n    # Penalize bins where this item is close to half of its capacity.\n    # Prioritize bin that is closest to current item size\n    diff = np.abs(bins_remain_cap - item)\n    priorities += 1.0 / (diff + 0.00001)\n\n    return priorities",
    "response_id": 10,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 26, in priority_v2\n    remaining_capacities_can_fit = bins_remain_cap[can_fit]\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers several factors:\n    1. Remaining capacity compared to item size (closeness to perfect fit).\n    2. Penalty for bins where the item doesn't fit.\n    3. A bonus for bins that were almost full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very important: Handle the case where the item doesn't fit!\n    cannot_fit = item > bins_remain_cap\n    priorities[cannot_fit] = -np.inf  # Definitely avoid these bins\n\n    # Now handle bins where the item *can* fit\n    can_fit = ~cannot_fit\n    remaining_capacities_can_fit = bins_remain_cap[can_fit]\n\n    if len(remaining_capacities_can_fit) > 0:  # Only calculate when needed\n        # Proximity to \"perfect fit\" - smaller waste is better\n        waste = remaining_capacities_can_fit - item\n        waste_normalized = waste / remaining_capacities_can_fit # Smaller number means smaller waste as a portion.\n\n        # Encourage packing into bins that were already quite full.  A bit of relative fullness before adding item.\n        relative_fullness = 1 - remaining_capacities_can_fit #Assume bin capacity is 1.\n        priorities[can_fit] = -waste_normalized + relative_fullness\n    return priorities",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, only consider bins that can actually fit the item.\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n        # If no bin can fit the item, return lowest priority for all. This shouldn't happen in a typical problem instance, but adding this as failsafe.\n        return priorities\n\n    # Calculate the \"waste\" if the item were placed in each bin. Waste is defined as remaining capicity in a bin, AFTER item placement\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Set waste to infinity for bins that can't fit.\n\n    # 1. Prioritize bins where the item fills them up nicely. That is, min waste.\n    priorities = 1 / (waste + 1e-9) # Adding small constant to avoid division by zero\n\n    # 2. Add a term that rewards utilizing more space relative to initial capacity\n    # but scaled down appropriately so it doesn't dominate waste prioritization.\n\n    #We don't want it to dominate. I consider that adding the inverse of wasted volume, it means that we are also prioritizing a fuller pack in terms of ratio of capacity that is used\n    priorities += 0.1 * (item / bins_remain_cap) * feasible_bins\n\n    #3. A small nudge to completely filled bins, if any, helps towards the end of run\n    perfect_fit = waste == 0\n    priorities[perfect_fit] += 1\n    \n    return priorities",
    "response_id": 12,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item with minimal wasted space.\n    Bins that cannot accommodate the item receive a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give a large negative priority if the item doesn't fit\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -1e9  # Very low priority\n\n    # Prioritize based on how well the item fits (remaining capacity)\n    feasible = ~infeasible\n    remaining_after_fit = bins_remain_cap[feasible] - item\n    priorities[feasible] = -np.abs(remaining_after_fit) # Prioritize small remaining capacity\n    #Prioritize bins that are almost full after adding item. The smaller the remaining capacity the higher the priority.\n\n    #Add some randomness to break ties, in case lots of bins have similar remaining capacity:\n    priorities[feasible] += np.random.normal(scale=1e-6, size=np.sum(feasible))\n\n    return priorities",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities  # No suitable bins, return zero priorities.\n\n    # Calculate fill ratio, but only for valid bins\n    fill_ratio = np.zeros_like(bins_remain_cap, dtype=float)\n    fill_ratio[valid_bins] = item / bins_remain_cap[valid_bins]\n\n    # Prioritize bins that will be filled more completely, but not excessively.\n    priorities[valid_bins] = np.exp(-np.abs(fill_ratio[valid_bins] - 1.0)) # Favor bins close to full after packing\n\n    # Add a bonus for bins that have more remaining capacity (avoid fragmentation)\n    priorities[valid_bins] += 0.1 * (bins_remain_cap[valid_bins] / np.max(bins_remain_cap))\n\n    # If we are left with a few bins which provide close packing, choose the emptiest one.\n    nearly_full_mask = np.isclose(fill_ratio, 1.0, atol=0.1) & valid_bins\n    if np.any(nearly_full_mask):\n        priorities[nearly_full_mask] += 0.2*(bins_remain_cap[nearly_full_mask] / np.max(bins_remain_cap))\n\n    return priorities",
    "response_id": 14,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 27, in priority_v2\n    remaining_space[~valid_bins] = np.inf  # Penalize invalid bins\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item with minimal wasted space,\n    but also introduces a slight preference for bins that are already somewhat filled.\n    This aims to balance efficiency with exploration of potentially better-fitting arrangements\n    later on. We are simulating a celestial dance, favoring both nearness (good fit) and\n    the pre-existing motions (current fill level) of the bins. The \"squaring\" of avail_space_ratio\n    emphasizes the importance of near-perfect fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities  # No valid bins, all priorities remain zero\n\n    # Calculate remaining space if item were placed in each bin\n    remaining_space = bins_remain_cap - item\n    remaining_space[~valid_bins] = np.inf  # Penalize invalid bins\n\n    # Calculate ratio of available space in bin to original capacity\n    avail_space_ratio = remaining_space / np.max(bins_remain_cap) # Assuming bins have same max capacity\n    avail_space_ratio = np.clip(avail_space_ratio, 0, 1) # Ensure valid range (0-1)\n    avail_space_ratio[~valid_bins] = 1 # setting the ratios of invalid bins to max val\n\n    #Give larger penalty to invalid bins\n    priorities = 1 / (0.001 + avail_space_ratio**2) # lower avail_space_ratio is given high priority\n\n\n    # Add a bonus for bins that are already partially filled.\n    # This encourages filling bins that are already in use. We are mimicing gravity, favoring bigger mass.\n    fill_ratio = (np.max(bins_remain_cap) - bins_remain_cap) / np.max(bins_remain_cap)\n    priorities = priorities + fill_ratio * 0.5 # weighning it with 0.5, since avail_space_ratio should have higher weight\n    priorities[~valid_bins] = 0 # zero out for invalid bins again\n\n\n    return priorities",
    "response_id": 15,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    A more sophisticated priority function, considering both space utilization\n    and a penalty for excessive fragmentation. We also introduce a small random\n    element to help escape local optima. Inspired by the chaotic nature\n    of black hole singularities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # 1. Feasibility check: Only consider bins that can accommodate the item.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[~feasible_bins] = -np.inf  # Give infeasible bins lowest priority\n\n    # 2. Space utilization: Prefer bins with tighter fit (higher utilization).\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    utilization = item / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] = utilization\n\n    # 3. Fragmentation penalty: Penalize creating bins with small remaining space.\n    #    This is analogous to preventing information loss by encouraging filling the bins\n    #    more fully (avoiding small \"event horizons\" of unused space).\n    fragmentation_penalty = np.exp(-5 * remaining_after_fit)\n    priorities[feasible_bins] -= fragmentation_penalty\n\n    # 4. Introduce a small random element: Analogous to Hawking radiation,\n    #    this random factor helps to escape local optima and explore different\n    #    bin configurations. The intensity is scaled down to a small number to keep it subtle.\n    random_factor = 0.01 * np.random.rand(np.sum(feasible_bins))\n    priorities[feasible_bins] += random_factor\n\n    # 5. A slight preference for almost full bins\n    almost_full_bonus = np.exp(-10*np.abs(remaining_after_fit-0.1))\n    priorities[feasible_bins] += 0.1*almost_full_bonus\n\n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "obj": 5.195452732349436,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates a stochastic element and a consideration for bin fragmentation.\n    It also introduces a 'quantum tunneling' effect to occasionally explore less obvious choices.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9  # Small constant to avoid division by zero and log(0)\n    bins_remain_cap = np.clip(bins_remain_cap, epsilon, None) # Ensure no bin has zero capacity or negative\n\n    # Heuristic 1: Remaining capacity after packing (higher is better, less fragmentation)\n    remaining_after_pack = bins_remain_cap - item\n    remaining_after_pack = np.clip(remaining_after_pack, 0, None)  # Negative capacity is meaningless\n    priority_remaining = remaining_after_pack\n\n    # Heuristic 2: Percentage of bin filled (closer to full, better - reduces total bins)\n    fill_percentage = item / bins_remain_cap\n    priority_fill = 1 - np.abs(fill_percentage - 0.9)  # Target around 90% full\n\n    # Heuristic 3: Penalize bins too close in size to the item (avoid exact fit, better long term)\n    proximity = np.abs(bins_remain_cap - item)\n    priority_proximity = -proximity\n\n    # Heuristic 4: Stochastic element (quantum tunneling - introduce some randomness)\n    random_noise = np.random.normal(0, 0.1, size=bins_remain_cap.shape)\n\n    # Combine the heuristics\n    priorities = 0.4 * priority_remaining + 0.3 * priority_fill + 0.2 * priority_proximity + 0.1 * random_noise\n\n    return priorities",
    "response_id": 17,
    "tryHS": false,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First Fit Decreasing inspired: prioritize bins that can fit the item closely\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n      capacities_that_fit = bins_remain_cap[fit_mask]\n      priorities[fit_mask] = capacities_that_fit - item\n      priorities[fit_mask] = -priorities[fit_mask]  #Smaller remaining capacity = higher priority\n      #Prioritize almost-full bins more. We want to fill bins completelly\n      priorities[fit_mask] = priorities[fit_mask] / bins_remain_cap[fit_mask] #Normalizing it\n\n    else: #If nothing fits, try to find a bin to make the overfill as little as possible. This is a last ditch effort\n        priorities = item - bins_remain_cap\n        priorities = -priorities  #minimize wasted space\n        priorities = priorities / np.max(np.abs(priorities)) #Normalize so bins are somewhat close\n\n    return priorities",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.487435181491823,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item\n    with minimal remaining capacity, aiming for better space utilization.\n    If a bin cannot accommodate the item, it receives a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            remaining_after_fit = cap - item\n            # Prioritize bins where the item fits snugly.\n            # Invert the remaining capacity to give higher priority to smaller remainders.\n            priorities[i] = 1.0 / (remaining_after_fit + 0.0001)  # Adding a small value to avoid division by zero.\n\n            #Further prioritize bins with close to perfect fit\n            if remaining_after_fit < 0.1:\n              priorities[i] *= 2 # Boost priority for very tight fits\n\n        else:\n            # Very low priority if item doesn't fit.\n            priorities[i] = -1000  # A significantly low value\n    return priorities",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            priorities[i] = (cap - item) / cap  # Remaining capacity after placing item divided by original capacity\n        else:\n            priorities[i] = -1  # Impossible to fit, assign lowest priority\n\n    return priorities",
    "response_id": 20,
    "tryHS": false,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins where the item fills a substantial portion\n    of the remaining capacity, while also discouraging bins that are\n    almost full but still can't accommodate the item (avoiding near misses).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Calculate the fill ratio:  How much of the remaining capacity will the item fill?\n            fill_ratio = item / cap\n\n            # Give higher priority to bins that are filled reasonably well,\n            # but not perfectly (to leave room for future items).  A sigmoid-like function\n            # might be useful for a more refined version.\n            priority = fill_ratio #Simple starting point based on fill ratio\n\n            # Add a bonus if the fill ratio is above a certain threshold (e.g., 0.5)\n            # Encourages using bins where the item \"fits well\"\n            if fill_ratio > 0.5:\n                priority += 0.2\n\n            # Penalize near misses: If the bin is almost full but the item *still* doesn't fit,\n            # strongly discourage using it. This prevents wasting bins with tiny unusable slivers.\n            # Since the if condition at the beginning already covers the \"doesn't fit\" scenario, \n            # no penalty here is needed\n            priorities[i] = priority\n        else:\n            # If the item doesn't fit, give a very low (negative) priority\n            priorities[i] = -100  # Discourage these bins\n\n    return priorities",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    A more sophisticated priority function inspired by physics. It considers:\n    1. Waste: Bins with less waste after adding the item get higher priority.\n    2. Potential Energy: A lower potential energy after adding is favored.\n       (Imagine the item \"falling\" into the bin; lower fall = better fit).\n    3. Avoidance of Trivial Fits: Discourages putting tiny items in huge bins early.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    potential_bins = bins_remain_cap >= item\n    if not np.any(potential_bins):\n        return np.zeros_like(bins_remain_cap) - np.inf  # No fit, very low priority\n\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Assign infinite waste to infeasible bins\n    waste_normalized = np.clip(1 - (waste / bins_remain_cap), a_min=0, a_max=1) # Higher when less waste after placing item in bin. Between 0-1. Inf. waste = 0.\n\n    # Potential energy is the \"drop\" of the item, smaller drop = higher priority\n    potential_energy = item / bins_remain_cap # If close to zero, tiny item inside huge bin\n\n    # Avoid filling bins with too big items. Add some buffer to increase priority as approaching bin capacity\n    bin_utilization = (bins_remain_cap - waste) / bins_remain_cap\n    buffer_boost = np.exp(-2 * np.abs(bin_utilization - 0.9)) # Prefer 90 % util\n\n    # Priority is a combination of these factors:\n    priorities = waste_normalized * (1 - potential_energy) * buffer_boost\n    priorities[~potential_bins] = -np.inf  # Ensure infeasible bins get lowest priority.\n\n    return priorities",
    "response_id": 22,
    "tryHS": false,
    "obj": 11.816912644595135,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers several factors:\n    1. Whether the item fits in the bin.  Bins that cannot fit the item receive the lowest priority.\n    2. The amount of wasted space if the item is placed in the bin. Less wasted space = higher priority.\n    3. A slight preference for bins that are already somewhat full.  This can help consolidate items and reduce fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap < item:\n            priorities[i] = -np.inf  # Cannot fit, lowest priority.  Important: Must be -inf to avoid comparison issues\n        else:\n            waste = cap - item\n            priorities[i] = -waste + 0.1 * (1 - cap / np.max(bins_remain_cap))  # Minimize waste, prefer somewhat full bins\n\n    return priorities",
    "response_id": 23,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999990770000295 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can fit the item snugly,\n    but also considers avoiding bins that are almost completely full\n    to leave space for potentially larger future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate remaining space after placing the item (if it fits)\n    remaining_after_fit = bins_remain_cap - item\n\n    # Initialize a very small value to avoid division by zero.\n    epsilon = 1e-9\n\n    # Give high priority to bins where the item fits with minimal waste\n    fit_indices = remaining_after_fit >= 0\n    if np.any(fit_indices):\n      priorities[fit_indices] = 1.0 / (remaining_after_fit[fit_indices] + epsilon)  # Lower remaining -> Higher priority\n\n    # Penalize bins which are very close to full even if the item fits.\n    # This helps preserve space for larger future items, preventing fragmentation.\n    almost_full_threshold = 0.1 # A bin is considered almost full if its remaining capacity is less than 10% of the bin size\n\n    # Calculate fraction of bin used if item is placed\n    fraction_used_if_placed = (bins_remain_cap - remaining_after_fit) / (bins_remain_cap + epsilon) #Avoid division by zero\n\n    #Reduce priority for bins that will be almost full\n    almost_full_indices = (fraction_used_if_placed > (1 - almost_full_threshold)) & fit_indices\n\n    priorities[almost_full_indices] *= 0.5  #Reduce priority for those bins. Adjust factor if needed.\n\n    return priorities",
    "response_id": 24,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 40, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'multiply' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that have enough capacity for the item,\n    giving preference to those that are filled closest to a certain\n    percentage (e.g., 90%) after adding the item. Bins that cannot\n    fit the item receive a very low priority (negative infinity).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full(bins_remain_cap.shape, -np.inf)\n    feasible_bins = bins_remain_cap >= item\n\n    if np.any(feasible_bins):\n        remaining_after_fit = bins_remain_cap[feasible_bins] - item\n        fill_percentage = 1 - remaining_after_fit / 1.0  # Assuming bin capacity is 1.0\n        target_fill = 0.9  # Target fill percentage, can be adjusted\n\n        # Calculate a score based on how close we are to the target fill.\n        # Closer is better, so we use a negative squared difference.\n        proximity_score = -np.square(fill_percentage - target_fill)\n\n        priorities[feasible_bins] = proximity_score\n\n        # Add a small bonus for bins that are already relatively full,\n        # to encourage filling them up first (without strongly penalizing\n        # other feasible bins).\n        initial_fill = 1 - bins_remain_cap[feasible_bins]\n        priorities[feasible_bins] += initial_fill * 0.1\n\n\n    return priorities",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Encourage bins that can fit the item. Near fit gives highest priority\n            priorities[i] = (cap - item + 1e-9) / (cap + 1e-9)  # Normalized remaining space after fit\n\n            # Further refine based on fullness of bin\n            fullness = 1 - (cap / np.max(bins_remain_cap)) if np.max(bins_remain_cap) > 0 else 0.0\n\n            #Prefer fuller bins that can still fit the item\n            priorities[i] += fullness * 0.5  #Weight this factor somewhat less\n\n        else:\n            #Penalty for bins that cannot fit the item\n            priorities[i] = -np.inf\n    return priorities",
    "response_id": 26,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996925100004 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A bin must have enough capacity to accommodate the item. Otherwise the priority should be very low.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Make infeasible bins have the lowest priority.\n\n    # Encourage bins that fit the item *relatively* well (but not too perfectly, to avoid small remaining spaces).\n\n    feasible_mask = ~infeasible_mask\n    remaining_capacity_after_fit = bins_remain_cap[feasible_mask] - item\n    capacity_ratio = item / bins_remain_cap[feasible_mask]  # ratio of item size to bin capacity\n\n    # Priority is high if the capacity ratio is high AND the remaining space is small *relative* to the item\n    # This favors using most of the bin's space without creating *very* small fragments.\n\n    priorities[feasible_mask] = capacity_ratio * np.exp(-remaining_capacity_after_fit / (item + 1e-9))\n\n    # Introduce some randomness to break ties and explore the search space more effectively.\n    priorities += np.random.normal(0, 0.01, size=len(priorities))\n\n    return priorities",
    "response_id": 27,
    "tryHS": false,
    "obj": 4.038691663342641,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version prioritizes bins that can accommodate the item closely (minimize wasted space)\n    but also penalizes bins that are almost full (to avoid overfilling). It uses a combination of\n    remaining capacity and the ratio of item size to remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Priority based on how closely the item fits, and remaining capacity\n            # A smaller remaining capacity (after packing) is better.\n            remaining_after_pack = cap - item\n            # Using a scaled inverse of wasted space\n            priorities[i] =  1.0 / (0.0001 + remaining_after_pack) # Avoid division by zero\n\n            # Ratio to prioritize bins where the item fills a significant portion\n            fill_ratio = item / cap\n            priorities[i] += fill_ratio  #Encourage bins that fill most of the bin\n\n            # A bit of penalty for large bins to prevent packing small items into large bins right away\n            priorities[i] -= 0.1 * (cap/np.max(bins_remain_cap))\n\n        else:\n            priorities[i] = -np.inf # Item does not fit\n\n    return priorities",
    "response_id": 28,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.9999915999997 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers the waste created and the relative fullness of the bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap[0] + item #Assuming bins have same capacity, after the addition of current item (if feasible), the bin size would represent original capacity\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = cap - item\n            # Prioritize bins that result in less waste (higher priority)\n            # AND prefer bins which are already relatively full (lower waste relative to full size of bin)\n            priorities[i] = (bin_size - waste)/bin_size #Ratio of item being added\n            priorities[i] += (1 - waste / bin_size)**2 #Also factor how much waste there will be\n\n    return priorities",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.9760670123653865,
    "exec_success": true
  }
]