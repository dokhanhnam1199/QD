{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers several factors:\n    1. Remaining capacity compared to item size (closeness to perfect fit).\n    2. Penalty for bins where the item doesn't fit.\n    3. A bonus for bins that were almost full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very important: Handle the case where the item doesn't fit!\n    cannot_fit = item > bins_remain_cap\n    priorities[cannot_fit] = -np.inf  # Definitely avoid these bins\n\n    # Now handle bins where the item *can* fit\n    can_fit = ~cannot_fit\n    remaining_capacities_can_fit = bins_remain_cap[can_fit]\n\n    if len(remaining_capacities_can_fit) > 0:  # Only calculate when needed\n        # Proximity to \"perfect fit\" - smaller waste is better\n        waste = remaining_capacities_can_fit - item\n        waste_normalized = waste / remaining_capacities_can_fit # Smaller number means smaller waste as a portion.\n\n        # Encourage packing into bins that were already quite full.  A bit of relative fullness before adding item.\n        relative_fullness = 1 - remaining_capacities_can_fit #Assume bin capacity is 1.\n        priorities[can_fit] = -waste_normalized + relative_fullness\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version introduces a few improvements:\n    1.  It strongly discourages exceeding capacity.  Bins that cannot fit the\n        item get a very negative priority.\n    2.  It prefers bins that have capacity close to the item size, but with\n        a bias towards using bins that are already partially full.  This is\n        achieved by considering both the absolute difference between item size\n        and remaining capacity, and the initial capacity of each bin.\n    3.  Prioritizes completely empty bins *less* to allow partially filled bins to be utilized before starting new bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very negative priority if the item doesn't fit\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Heuristic based on how well the item fits and encourages utilizing partially-filled bins\n    fit_score = np.exp(-np.abs(bins_remain_cap - item) / item)\n\n    # Add bonus if the bin is already used\n    is_used_bonus = (bins_remain_cap < 1).astype(float) #Bins with remaining cap < 1 are considered used\n\n    priorities = fit_score + is_used_bonus\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item\n    with minimal remaining capacity, aiming for better space utilization.\n    If a bin cannot accommodate the item, it receives a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            remaining_after_fit = cap - item\n            # Prioritize bins where the item fits snugly.\n            # Invert the remaining capacity to give higher priority to smaller remainders.\n            priorities[i] = 1.0 / (remaining_after_fit + 0.0001)  # Adding a small value to avoid division by zero.\n\n            #Further prioritize bins with close to perfect fit\n            if remaining_after_fit < 0.1:\n              priorities[i] *= 2 # Boost priority for very tight fits\n\n        else:\n            # Very low priority if item doesn't fit.\n            priorities[i] = -1000  # A significantly low value\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers several factors:\n    1. Remaining capacity compared to item size (closeness to perfect fit).\n    2. Penalty for bins where the item doesn't fit.\n    3. A bonus for bins that were almost full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very important: Handle the case where the item doesn't fit!\n    cannot_fit = item > bins_remain_cap\n    priorities[cannot_fit] = -np.inf  # Definitely avoid these bins\n\n    # Now handle bins where the item *can* fit\n    can_fit = ~cannot_fit\n    remaining_capacities_can_fit = bins_remain_cap[can_fit]\n\n    if len(remaining_capacities_can_fit) > 0:  # Only calculate when needed\n        # Proximity to \"perfect fit\" - smaller waste is better\n        waste = remaining_capacities_can_fit - item\n        waste_normalized = waste / remaining_capacities_can_fit # Smaller number means smaller waste as a portion.\n\n        # Encourage packing into bins that were already quite full.  A bit of relative fullness before adding item.\n        relative_fullness = 1 - remaining_capacities_can_fit #Assume bin capacity is 1.\n        priorities[can_fit] = -waste_normalized + relative_fullness\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic 1: Fill bins as much as possible but avoid overfilling\n    fit_score = bins_remain_cap - item\n    fit_priority = np.where(fit_score >= 0, np.exp(-np.abs(fit_score)), -np.inf)  # Higher priority to closer fit, negative infinity if doesn't fit\n\n    # Heuristic 2: Consider the remaining capacity after placement. Lower remaining capacity is better. Avoid tiny gaps.\n    remaining_cap_penalty = np.where(fit_score >= 0, np.exp(-5 * fit_score), 0)  # Penalize larger remaining gaps. The factor of 5 is tuned. Zero if item doesn't fit\n    # Heuristic 3: Prefer bins with greater initial utilization, less likely to open a new bin\n    utilization_priority = np.zeros_like(bins_remain_cap)\n    initial_capacity = bins_remain_cap + item # initial capacity = current cap + the item size only if the bin can accomodate the item\n    utilization_priority[fit_score>=0] = 1 / initial_capacity[fit_score>=0] # smaller initial capacity is better\n\n    # Combine heuristics using weighted sum. Experiment with weights\n    priorities = 0.7 * fit_priority + 0.2 * remaining_cap_penalty + 0.1 * utilization_priority\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers several factors:\n    1. Remaining capacity compared to item size (closeness to perfect fit).\n    2. Penalty for bins where the item doesn't fit.\n    3. A bonus for bins that were almost full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very important: Handle the case where the item doesn't fit!\n    cannot_fit = item > bins_remain_cap\n    priorities[cannot_fit] = -np.inf  # Definitely avoid these bins\n\n    # Now handle bins where the item *can* fit\n    can_fit = ~cannot_fit\n    remaining_capacities_can_fit = bins_remain_cap[can_fit]\n\n    if len(remaining_capacities_can_fit) > 0:  # Only calculate when needed\n        # Proximity to \"perfect fit\" - smaller waste is better\n        waste = remaining_capacities_can_fit - item\n        waste_normalized = waste / remaining_capacities_can_fit # Smaller number means smaller waste as a portion.\n\n        # Encourage packing into bins that were already quite full.  A bit of relative fullness before adding item.\n        relative_fullness = 1 - remaining_capacities_can_fit #Assume bin capacity is 1.\n        priorities[can_fit] = -waste_normalized + relative_fullness\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version introduces a few improvements:\n    1.  It strongly discourages exceeding capacity.  Bins that cannot fit the\n        item get a very negative priority.\n    2.  It prefers bins that have capacity close to the item size, but with\n        a bias towards using bins that are already partially full.  This is\n        achieved by considering both the absolute difference between item size\n        and remaining capacity, and the initial capacity of each bin.\n    3.  Prioritizes completely empty bins *less* to allow partially filled bins to be utilized before starting new bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very negative priority if the item doesn't fit\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Heuristic based on how well the item fits and encourages utilizing partially-filled bins\n    fit_score = np.exp(-np.abs(bins_remain_cap - item) / item)\n\n    # Add bonus if the bin is already used\n    is_used_bonus = (bins_remain_cap < 1).astype(float) #Bins with remaining cap < 1 are considered used\n\n    priorities = fit_score + is_used_bonus\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic 1: Fill bins as much as possible but avoid overfilling\n    fit_score = bins_remain_cap - item\n    fit_priority = np.where(fit_score >= 0, np.exp(-np.abs(fit_score)), -np.inf)  # Higher priority to closer fit, negative infinity if doesn't fit\n\n    # Heuristic 2: Consider the remaining capacity after placement. Lower remaining capacity is better. Avoid tiny gaps.\n    remaining_cap_penalty = np.where(fit_score >= 0, np.exp(-5 * fit_score), 0)  # Penalize larger remaining gaps. The factor of 5 is tuned. Zero if item doesn't fit\n    # Heuristic 3: Prefer bins with greater initial utilization, less likely to open a new bin\n    utilization_priority = np.zeros_like(bins_remain_cap)\n    initial_capacity = bins_remain_cap + item # initial capacity = current cap + the item size only if the bin can accomodate the item\n    utilization_priority[fit_score>=0] = 1 / initial_capacity[fit_score>=0] # smaller initial capacity is better\n\n    # Combine heuristics using weighted sum. Experiment with weights\n    priorities = 0.7 * fit_priority + 0.2 * remaining_cap_penalty + 0.1 * utilization_priority\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First Fit Decreasing inspired: prioritize bins that can fit the item closely\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n      capacities_that_fit = bins_remain_cap[fit_mask]\n      priorities[fit_mask] = capacities_that_fit - item\n      priorities[fit_mask] = -priorities[fit_mask]  #Smaller remaining capacity = higher priority\n      #Prioritize almost-full bins more. We want to fill bins completelly\n      priorities[fit_mask] = priorities[fit_mask] / bins_remain_cap[fit_mask] #Normalizing it\n\n    else: #If nothing fits, try to find a bin to make the overfill as little as possible. This is a last ditch effort\n        priorities = item - bins_remain_cap\n        priorities = -priorities  #minimize wasted space\n        priorities = priorities / np.max(np.abs(priorities)) #Normalize so bins are somewhat close\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First Fit Decreasing inspired: prioritize bins that can fit the item closely\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n      capacities_that_fit = bins_remain_cap[fit_mask]\n      priorities[fit_mask] = capacities_that_fit - item\n      priorities[fit_mask] = -priorities[fit_mask]  #Smaller remaining capacity = higher priority\n      #Prioritize almost-full bins more. We want to fill bins completelly\n      priorities[fit_mask] = priorities[fit_mask] / bins_remain_cap[fit_mask] #Normalizing it\n\n    else: #If nothing fits, try to find a bin to make the overfill as little as possible. This is a last ditch effort\n        priorities = item - bins_remain_cap\n        priorities = -priorities  #minimize wasted space\n        priorities = priorities / np.max(np.abs(priorities)) #Normalize so bins are somewhat close\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First Fit Decreasing inspired: prioritize bins that can fit the item closely\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n      capacities_that_fit = bins_remain_cap[fit_mask]\n      priorities[fit_mask] = capacities_that_fit - item\n      priorities[fit_mask] = -priorities[fit_mask]  #Smaller remaining capacity = higher priority\n      #Prioritize almost-full bins more. We want to fill bins completelly\n      priorities[fit_mask] = priorities[fit_mask] / bins_remain_cap[fit_mask] #Normalizing it\n\n    else: #If nothing fits, try to find a bin to make the overfill as little as possible. This is a last ditch effort\n        priorities = item - bins_remain_cap\n        priorities = -priorities  #minimize wasted space\n        priorities = priorities / np.max(np.abs(priorities)) #Normalize so bins are somewhat close\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First Fit Decreasing inspired: prioritize bins that can fit the item closely\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n      capacities_that_fit = bins_remain_cap[fit_mask]\n      priorities[fit_mask] = capacities_that_fit - item\n      priorities[fit_mask] = -priorities[fit_mask]  #Smaller remaining capacity = higher priority\n      #Prioritize almost-full bins more. We want to fill bins completelly\n      priorities[fit_mask] = priorities[fit_mask] / bins_remain_cap[fit_mask] #Normalizing it\n\n    else: #If nothing fits, try to find a bin to make the overfill as little as possible. This is a last ditch effort\n        priorities = item - bins_remain_cap\n        priorities = -priorities  #minimize wasted space\n        priorities = priorities / np.max(np.abs(priorities)) #Normalize so bins are somewhat close\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers the waste created and the relative fullness of the bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = bins_remain_cap[0] + item #Assuming bins have same capacity, after the addition of current item (if feasible), the bin size would represent original capacity\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = cap - item\n            # Prioritize bins that result in less waste (higher priority)\n            # AND prefer bins which are already relatively full (lower waste relative to full size of bin)\n            priorities[i] = (bin_size - waste)/bin_size #Ratio of item being added\n            priorities[i] += (1 - waste / bin_size)**2 #Also factor how much waste there will be\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    A more sophisticated priority function, considering both space utilization\n    and a penalty for excessive fragmentation. We also introduce a small random\n    element to help escape local optima. Inspired by the chaotic nature\n    of black hole singularities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # 1. Feasibility check: Only consider bins that can accommodate the item.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[~feasible_bins] = -np.inf  # Give infeasible bins lowest priority\n\n    # 2. Space utilization: Prefer bins with tighter fit (higher utilization).\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    utilization = item / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] = utilization\n\n    # 3. Fragmentation penalty: Penalize creating bins with small remaining space.\n    #    This is analogous to preventing information loss by encouraging filling the bins\n    #    more fully (avoiding small \"event horizons\" of unused space).\n    fragmentation_penalty = np.exp(-5 * remaining_after_fit)\n    priorities[feasible_bins] -= fragmentation_penalty\n\n    # 4. Introduce a small random element: Analogous to Hawking radiation,\n    #    this random factor helps to escape local optima and explore different\n    #    bin configurations. The intensity is scaled down to a small number to keep it subtle.\n    random_factor = 0.01 * np.random.rand(np.sum(feasible_bins))\n    priorities[feasible_bins] += random_factor\n\n    # 5. A slight preference for almost full bins\n    almost_full_bonus = np.exp(-10*np.abs(remaining_after_fit-0.1))\n    priorities[feasible_bins] += 0.1*almost_full_bonus\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    A more sophisticated priority function, considering both space utilization\n    and a penalty for excessive fragmentation. We also introduce a small random\n    element to help escape local optima. Inspired by the chaotic nature\n    of black hole singularities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # 1. Feasibility check: Only consider bins that can accommodate the item.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[~feasible_bins] = -np.inf  # Give infeasible bins lowest priority\n\n    # 2. Space utilization: Prefer bins with tighter fit (higher utilization).\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    utilization = item / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] = utilization\n\n    # 3. Fragmentation penalty: Penalize creating bins with small remaining space.\n    #    This is analogous to preventing information loss by encouraging filling the bins\n    #    more fully (avoiding small \"event horizons\" of unused space).\n    fragmentation_penalty = np.exp(-5 * remaining_after_fit)\n    priorities[feasible_bins] -= fragmentation_penalty\n\n    # 4. Introduce a small random element: Analogous to Hawking radiation,\n    #    this random factor helps to escape local optima and explore different\n    #    bin configurations. The intensity is scaled down to a small number to keep it subtle.\n    random_factor = 0.01 * np.random.rand(np.sum(feasible_bins))\n    priorities[feasible_bins] += random_factor\n\n    # 5. A slight preference for almost full bins\n    almost_full_bonus = np.exp(-10*np.abs(remaining_after_fit-0.1))\n    priorities[feasible_bins] += 0.1*almost_full_bonus\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    A more sophisticated priority function inspired by physics. It considers:\n    1. Waste: Bins with less waste after adding the item get higher priority.\n    2. Potential Energy: A lower potential energy after adding is favored.\n       (Imagine the item \"falling\" into the bin; lower fall = better fit).\n    3. Avoidance of Trivial Fits: Discourages putting tiny items in huge bins early.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    potential_bins = bins_remain_cap >= item\n    if not np.any(potential_bins):\n        return np.zeros_like(bins_remain_cap) - np.inf  # No fit, very low priority\n\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Assign infinite waste to infeasible bins\n    waste_normalized = np.clip(1 - (waste / bins_remain_cap), a_min=0, a_max=1) # Higher when less waste after placing item in bin. Between 0-1. Inf. waste = 0.\n\n    # Potential energy is the \"drop\" of the item, smaller drop = higher priority\n    potential_energy = item / bins_remain_cap # If close to zero, tiny item inside huge bin\n\n    # Avoid filling bins with too big items. Add some buffer to increase priority as approaching bin capacity\n    bin_utilization = (bins_remain_cap - waste) / bins_remain_cap\n    buffer_boost = np.exp(-2 * np.abs(bin_utilization - 0.9)) # Prefer 90 % util\n\n    # Priority is a combination of these factors:\n    priorities = waste_normalized * (1 - potential_energy) * buffer_boost\n    priorities[~potential_bins] = -np.inf  # Ensure infeasible bins get lowest priority.\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., 0).\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item.\n    valid_bins = bins_remain_cap >= item\n\n    # If no bin can accommodate the item, return a low priority for all bins.\n    if not np.any(valid_bins):\n        return priorities - 1e9  # Very low priority for all\n\n    # Calculate fill ratios for valid bins: (capacity - item_size) / original capacity\n    # However, we don't have original capacity readily available. So, we use this approximation.\n    fill_ratios = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n\n    # Apply Newton's inverse square law-inspired priority: Priority increases as fill ratio increases, but decreases inversely proportional to the remaining space.\n    priorities[valid_bins] = fill_ratios / (bins_remain_cap[valid_bins] + 1e-6) # Small constant to avoid division by zero\n\n    # Boosting bins with smaller remaining capacity after placing item.\n    # Encourage filling up bins more completely.\n\n    remaining_after_placement = bins_remain_cap[valid_bins] - item\n    # Ensure that the bin is not overfilled\n    remaining_after_placement = np.clip(remaining_after_placement, a_min=0, a_max=None)\n    priority_boost = np.exp(-remaining_after_placement)\n\n    priorities[valid_bins] *= priority_boost\n\n    #Add some noise to the priority score to handle degeneracy (Equal priority scores). This will break ties in random.\n    noise = np.random.normal(0, 1e-6, len(priorities))\n    priorities += noise\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., 0).\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item.\n    valid_bins = bins_remain_cap >= item\n\n    # If no bin can accommodate the item, return a low priority for all bins.\n    if not np.any(valid_bins):\n        return priorities - 1e9  # Very low priority for all\n\n    # Calculate fill ratios for valid bins: (capacity - item_size) / original capacity\n    # However, we don't have original capacity readily available. So, we use this approximation.\n    fill_ratios = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n\n    # Apply Newton's inverse square law-inspired priority: Priority increases as fill ratio increases, but decreases inversely proportional to the remaining space.\n    priorities[valid_bins] = fill_ratios / (bins_remain_cap[valid_bins] + 1e-6) # Small constant to avoid division by zero\n\n    # Boosting bins with smaller remaining capacity after placing item.\n    # Encourage filling up bins more completely.\n\n    remaining_after_placement = bins_remain_cap[valid_bins] - item\n    # Ensure that the bin is not overfilled\n    remaining_after_placement = np.clip(remaining_after_placement, a_min=0, a_max=None)\n    priority_boost = np.exp(-remaining_after_placement)\n\n    priorities[valid_bins] *= priority_boost\n\n    #Add some noise to the priority score to handle degeneracy (Equal priority scores). This will break ties in random.\n    noise = np.random.normal(0, 1e-6, len(priorities))\n    priorities += noise\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Einstein's Field Equation Inspired Term: Curvature of Bin Space\n    #  The 'curvature' is high when bins are nearly full (close to item size).\n    #  This incentivizes using bins that are 'bent' towards capacity.\n    curvature = np.exp(-np.abs(bins_remain_cap - item))\n\n    # Cosmological Constant Inspired Term: A universal pressure to fill all bins, but modulated.\n    #   This ensures that even bins with less-than-ideal fit still get a chance, preventing premature new bin creation.\n    cosmological_constant = np.where(bins_remain_cap >= item, 0.1, -np.inf) # Give slight encouragement, large discouragement\n\n    # Relative Remaining Capacity: Encourage bins with suitable space.\n    relative_capacity = (bins_remain_cap - item) / bins_remain_cap\n    relative_capacity = np.where(bins_remain_cap >= item, np.clip(relative_capacity, 0, 1), -np.inf) #valid only if bin has space for item. Negative inf. otherwise\n\n    # Stability Term: Prevent filling nearly full bins at the expense of slightly larger bins\n    stability = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n\n    # Combine all terms with some scaling factors.\n    priorities = 0.5 * curvature + 0.2 * cosmological_constant + 0.4 * relative_capacity + 0.1 * stability\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Einstein's Field Equation Inspired Term: Curvature of Bin Space\n    #  The 'curvature' is high when bins are nearly full (close to item size).\n    #  This incentivizes using bins that are 'bent' towards capacity.\n    curvature = np.exp(-np.abs(bins_remain_cap - item))\n\n    # Cosmological Constant Inspired Term: A universal pressure to fill all bins, but modulated.\n    #   This ensures that even bins with less-than-ideal fit still get a chance, preventing premature new bin creation.\n    cosmological_constant = np.where(bins_remain_cap >= item, 0.1, -np.inf) # Give slight encouragement, large discouragement\n\n    # Relative Remaining Capacity: Encourage bins with suitable space.\n    relative_capacity = (bins_remain_cap - item) / bins_remain_cap\n    relative_capacity = np.where(bins_remain_cap >= item, np.clip(relative_capacity, 0, 1), -np.inf) #valid only if bin has space for item. Negative inf. otherwise\n\n    # Stability Term: Prevent filling nearly full bins at the expense of slightly larger bins\n    stability = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n\n    # Combine all terms with some scaling factors.\n    priorities = 0.5 * curvature + 0.2 * cosmological_constant + 0.4 * relative_capacity + 0.1 * stability\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}