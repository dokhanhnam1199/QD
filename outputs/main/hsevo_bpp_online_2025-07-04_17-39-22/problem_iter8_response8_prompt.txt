{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Adaptive priority: Combines waste normalization, fullness, and randomness.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    potential_bins = bins_remain_cap >= item\n    priorities[~potential_bins] = -np.inf\n\n    waste = bins_remain_cap - item\n    waste = np.clip(waste, a_min=0, a_max=None)\n    waste_normalized = 1 - (waste / bins_remain_cap)\n    waste_normalized = np.clip(waste_normalized, a_min=0, a_max=1)\n\n    bin_utilization = (bins_remain_cap - waste) / bins_remain_cap\n    is_used_bonus = (bin_utilization > 0).astype(float)\n\n    priorities = 0.7 * waste_normalized + 0.3 * is_used_bonus\n    priorities += np.random.normal(0, 0.005, size=len(priorities))\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates several improvements:\n    1.  Adaptive capacity ratio weighting.\n    2.  A penalty term for bins that become too full.\n    3.  Dynamic exploration/exploitation balance.\n    4.  Constraint anticipation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasibility mask\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Feasible bins\n    feasible_mask = ~infeasible_mask\n    feasible_caps = bins_remain_cap[feasible_mask]\n\n    if np.any(feasible_mask):  # Only proceed if there are feasible bins\n        remaining_capacity_after_fit = feasible_caps - item\n        capacity_ratio = item / feasible_caps\n\n        # Adaptive Capacity Ratio Weighting: Adjust importance based on average cap.\n        avg_cap = np.mean(bins_remain_cap[bins_remain_cap > 0]) if np.any(bins_remain_cap > 0) else 1.0 # Avoid ZeroDivisionError, handle edge case\n        adaptive_weight = np.clip(avg_cap / (item + 1e-9), 0.1, 10) # Clip to avoid extreme weights\n        capacity_ratio_weighted = capacity_ratio * adaptive_weight\n\n        # Penalty for nearly full bins.  Higher penalty for smaller remaining space.\n        fullness_penalty = np.exp(-5 * remaining_capacity_after_fit / (item + 1e-9)) # Higher exponent for stronger penalty\n        priorities[feasible_mask] = capacity_ratio_weighted * (1 - fullness_penalty)  # Subtract penalty\n\n        # Dynamic Exploration/Exploitation:  Adjust randomness based on remaining bins.\n        num_empty_bins = np.sum(bins_remain_cap > 0.99) # Count bins that are almost empty (>.99 full capacity)\n        exploration_factor = np.clip(num_empty_bins / len(bins_remain_cap), 0.01, 0.1) # Avoid zero division, clip range\n\n        priorities += np.random.normal(0, exploration_factor, size=len(priorities))\n\n        # Constraint anticipation: Prefer bins that can accommodate at least a small *future* item\n        small_item_size = np.mean(bins_remain_cap[bins_remain_cap>0])/10 if np.any(bins_remain_cap > 0) else 0.1\n        future_fit_penalty = np.where(remaining_capacity_after_fit < small_item_size, -0.1 , 0)\n        priorities[feasible_mask] += future_fit_penalty # Apply slight penalty if doesn't fit small_item.\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first prioritizes capacity ratio, small fragment avoidance, and large capacity bonus, along with adaptive exploration/exploitation based on the number of feasible bins. The last one combines fit score, normalized waste, and randomness. Comparing (2nd) vs (19th), the second allows for fine-grained control over various aspects like fragment thresholds and penalties, and adaptive randomness. The last function in the list is rather basic, only looking at waste, fit, and a bit of noise. Comparing (1st) vs (2nd), the 1st uses hardcoded values while the 2nd exposes hyperparameters for tuning, allowing for more flexibility. (3rd) vs (4th) shows that the 3rd version incorporates an adaptive penalty for near-full bins, encourages packing items of similar sizes, dynamic noise injection. (second worst) vs (worst) indicates the second worst approach attempts waste normalization and bin utilization; the worst approach focuses on fit, remaining capacity, and randomness in a more direct manner. Overall: The better heuristics have more adaptive strategies (adaptive exploration/exploitation, dynamic penalties/bonuses based on bin utilization, remaining capacity, or item size). They also try to balance multiple factors (fit, waste, fullness) and introduce randomness for exploration. The poorer heuristics often use simpler combinations of fit, waste, and randomness, without adapting to the state of the bins.\n- \nOkay, let's redefine \"Current Self-Reflection\" to focus on designing better heuristics, avoiding the pitfalls of \"Ineffective Self-Reflection,\" and building on the provided ideas.\n\nHere's a revised approach, aimed at generating more actionable advice:\n\n*   **Keywords:** Adaptive parameters, exploration-exploitation balance, edge case handling, hyperparameter tuning, problem state awareness.\n\n*   **Advice:** Design heuristics that dynamically adjust their behavior based on real-time problem characteristics. Focus on creating tunable parameters that influence the balance between exploration and exploitation.\n\n*   **Avoid:** Overly complex formulas that obscure interpretability, neglecting edge cases.\n\n*   **Explanation:** Prioritize heuristics that \"sense\" the problem state (e.g., bin fill levels) and respond accordingly. This allows for tailored behavior, avoiding rigid rules that perform poorly in certain scenarios.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}