{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate bin priorities, balancing bin utilization, fragmentation, and exploration.\"\"\"\n\n    small_fragment_threshold_ratio: float = 0.2\n    small_fragment_penalty: float = 0.3\n    large_capacity_threshold_ratio: float = 1.8\n    large_capacity_bonus: float = 1.5\n    base_exploration_noise: float = 0.04\n    num_feasible_bins_threshold: int = 5\n    exploitation_bonus: float = 0.04\n    exploration_noise: float = 0.06\n    fragment_penalty_threshold_ratio: float = 0.3\n    fragment_penalty_factor: float = 0.6\n    bin_utilization_exponent: float = 2.0\n    item_size_threshold_ratio: float = 0.5\n    large_item_bonus: float = 0.1\n    bin_fullness_threshold: float = 0.8\n    full_bin_bonus: float = 0.1\n\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    feasible_mask = ~infeasible_mask\n    feasible_bins_remain_cap = bins_remain_cap[feasible_mask]\n\n    if np.sum(feasible_mask) > 0:\n        remaining_capacity_after_fit = feasible_bins_remain_cap - item\n        capacity_ratio = item / feasible_bins_remain_cap\n\n        priorities[feasible_mask] = capacity_ratio**bin_utilization_exponent\n\n        small_fragment_mask = remaining_capacity_after_fit < (item * small_fragment_threshold_ratio)\n        priorities[feasible_mask][small_fragment_mask] *= small_fragment_penalty\n\n        large_capacity_mask = remaining_capacity_after_fit > (item * large_capacity_threshold_ratio)\n        priorities[feasible_mask][large_capacity_mask] *= large_capacity_bonus\n\n        priorities += np.random.normal(0, base_exploration_noise, size=len(priorities))\n\n        num_feasible = np.sum(feasible_mask)\n        if num_feasible > num_feasible_bins_threshold:\n            priorities[feasible_mask] *= (1 + exploitation_bonus * capacity_ratio)\n        else:\n            priorities += np.random.normal(0, exploration_noise, size=len(priorities))\n\n        fragment_penalty_threshold = item * fragment_penalty_threshold_ratio\n        fragment_penalty_mask = (remaining_capacity_after_fit > 0) & (remaining_capacity_after_fit < fragment_penalty_threshold)\n        priorities[feasible_mask][fragment_penalty_mask] *= (1 - (remaining_capacity_after_fit[fragment_penalty_mask] / fragment_penalty_threshold) * fragment_penalty_factor)\n\n\n        bin_fullness = 1 - (feasible_bins_remain_cap / (bins_remain_cap[feasible_mask]))\n\n        full_bin_mask = bin_fullness > bin_fullness_threshold\n        priorities[feasible_mask][full_bin_mask] *= (1 + full_bin_bonus)\n\n        if item > bins_remain_cap.max() * item_size_threshold_ratio:\n            well_utilized_mask = capacity_ratio > 0.7\n            priorities[feasible_mask][well_utilized_mask] *= (1 + large_item_bonus)\n\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}