[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 0.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = (bins_remain_cap == item)\n    priorities[exact_fit] = 1.0\n\n    # Then, prioritize bins where the item fits with minimal remaining capacity\n    remaining_capacity = bins_remain_cap - item\n    valid_bins = remaining_capacity >= 0\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1.0 / (remaining_capacity[valid_bins] + 1e-9)  # Avoid division by zero\n\n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Best Fit strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between item size and remaining capacity\n    diffs = bins_remain_cap - item\n\n    # Assign priority: higher priority to bins with smaller difference (best fit)\n    # Avoid using bins that are too small (negative difference) by assigning them a very low priority\n    for i in range(len(bins_remain_cap)):\n        if diffs[i] >= 0:\n            priorities[i] = diffs[i]  # Smaller difference = higher priority\n        else:\n            priorities[i] = -1e9  # Very low priority for bins that are too small\n\n    return priorities",
    "response_id": 1,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 24.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Worst Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities  # No bin can fit the item\n\n    # Calculate the remaining capacity after adding the item to each valid bin\n    remaining_after_add = bins_remain_cap[valid_bins] - item\n\n    # Assign priority based on the remaining capacity after adding the item.\n    # Worst Fit prioritizes bins that will have the *most* remaining capacity after the item is added.\n    priorities[valid_bins] = remaining_after_add\n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 22.458839376460833,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the ratio of item size to remaining capacity for each bin.\n    # Higher ratio means the bin is almost full and better fit for the item.\n    \n    valid_bins = bins_remain_cap >= item\n    \n    if np.sum(valid_bins) == 0:\n        return priorities\n\n    ratios = item / bins_remain_cap[valid_bins]\n    \n    # Use 1 - ratio as priority, so smaller remaining capacity results in higher priority\n    priorities[valid_bins] = 1 - ratios\n\n    return priorities",
    "response_id": 3,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Exact fit gets highest priority\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1000  # High priority for exact fit\n\n    # Remaining bins are prioritized based on how close they are to fitting the item\n    remaining_indices = np.where(bins_remain_cap >= item)[0]\n    if len(remaining_indices) > 0:\n        diffs = bins_remain_cap[remaining_indices] - item\n        priorities[remaining_indices] = 1 / (diffs + 1e-6)  # Lower difference = higher priority\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 70.32403072095333,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Inverse Distance (Proximity Fit).\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero\n    valid_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(valid_bins):\n        distances = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (distances + 1e-6)  # Add small value to avoid division by zero\n    return priorities",
    "response_id": 5,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin\n    fit_scores = item / bins_remain_cap\n    # Apply a sigmoid function to the fit scores to get priority\n    # This ensures that bins with a better fit (closer to 1) get higher priority,\n    # but also penalizes bins that are too full (fit score > 1).\n    # The sigmoid function parameters can be adjusted to fine-tune the behavior.\n    priorities = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Random Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    num_feasible_bins = np.sum(feasible_bins)\n\n    if num_feasible_bins > 0:\n        # Assign equal priority to all feasible bins.  This implements\n        # the \"random\" part of Random Fit.\n        priorities[feasible_bins] = 1.0\n    return priorities",
    "response_id": 7,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 15.509775004326936,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Probability of exploration.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the \"greedy\" priority (best fit)\n    for i in range(n_bins):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-6)  # Smaller waste is better\n        else:\n            priorities[i] = 0.0\n\n    # Exploration: Add a small random value to each bin with probability epsilon\n    if np.random.rand() < epsilon:\n        priorities += np.random.rand(n_bins) * 0.1  # Add a small random bonus\n\n    return priorities",
    "response_id": 8,
    "obj": 4.098524132429212,
    "SLOC": 11.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 89.20647778231529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, -1)\n\n    # Normalize the fit scores using softmax\n    if np.sum(fit_scores > 0) > 0:\n        exp_fit_scores = np.exp(fit_scores)\n        sum_exp_fit_scores = np.sum(exp_fit_scores[fit_scores > 0])\n        probabilities = exp_fit_scores / sum_exp_fit_scores\n    else:\n        probabilities = np.zeros_like(bins_remain_cap)\n\n    return probabilities",
    "response_id": 9,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 74.00879436282185,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 100  # High priority for exact fits\n\n    # Next, prioritize bins where the item fits and leaves the least space.\n    # This is the First Fit Decreasing strategy, trying to fill bins as much as possible.\n    fitting_bins = bins_remain_cap >= item\n    priorities[fitting_bins] = 1.0 / (bins_remain_cap[fitting_bins] - item + 1e-6) # Avoid division by zero. Adding a very small value.\n    return priorities",
    "response_id": 10,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Best Fit: Prioritize bins where the item fits and leaves the least remaining space.\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (remaining_space + 1e-6)  # Add small value to avoid division by zero\n    return priorities",
    "response_id": 11,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Worst Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities  # No bin can accommodate the item\n\n    priorities[valid_bins] = bins_remain_cap[valid_bins]\n    return priorities",
    "response_id": 12,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the ratio of item size to remaining capacity.  Lower is better.\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = (item / bins_remain_cap[i])\n        else:\n            priorities[i] = np.inf  # Very low priority if item doesn't fit\n\n    # Invert the priorities so that higher priority is a larger number.  Also add\n    # a small value to prevent division by zero and ensure even slightly\n    # preferable bins receive a higher score.\n    priorities = 1 / (priorities + 1e-6)\n    \n    return priorities",
    "response_id": 13,
    "obj": 5.534503390506582,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 39.863137138648355,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Give highest priority to bins where the item fits exactly\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1.0  # Highest priority\n\n    # If no exact fit, prioritize bins where the item can fit\n    fitting_bins = np.where(bins_remain_cap >= item)[0]\n    if len(fitting_bins) > 0 and len(exact_fit_bins) == 0:\n        priorities[fitting_bins] = 0.5 # Medium priority\n\n    return priorities",
    "response_id": 14,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 51.89147427955947,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative capacities\n    valid_bins = bins_remain_cap > 0\n    bins_remain_cap_valid = bins_remain_cap[valid_bins]\n\n    # Calculate the fit ratio: item size / remaining capacity\n    fit_ratios = item / bins_remain_cap_valid\n    \n    # Use a sigmoid function to map the fit ratio to a priority score.\n    # The sigmoid function maps values to the range (0, 1), with lower fit ratios (better fit)\n    # resulting in higher scores.\n    # We use a scaling factor (e.g., 10) to control the steepness of the sigmoid.\n    priorities_valid = 1 / (1 + np.exp(10 * (fit_ratios - 0.5))) \n\n    # Create an array of priorities with the same size as bins_remain_cap\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = priorities_valid\n    \n    return priorities",
    "response_id": 16,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Random Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities  # No bin can fit the item\n\n    # Assign a random priority score to the valid bins. In Random Fit, the bins\n    # are typically chosen randomly from the feasible bins. Here, we represent\n    # this by assigning uniformly random scores.\n    num_valid_bins = np.sum(valid_bins)\n    random_priorities = np.random.rand(num_valid_bins)\n    bin_index = 0\n    for i in range(len(bins_remain_cap)):\n        if valid_bins[i]:\n            priorities[i] = random_priorities[bin_index]\n            bin_index += 1\n    return priorities",
    "response_id": 17,
    "obj": 4.487435181491823,
    "SLOC": 13.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 28.529325012980813,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate (probability of choosing a random bin).\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate greedy priority (best fit)\n    suitable_bins = bins_remain_cap >= item\n    if np.any(suitable_bins):\n        best_bin_index = np.argmin(bins_remain_cap[suitable_bins] - item)\n        best_bin_index = np.where(suitable_bins)[0][best_bin_index]\n        priorities[best_bin_index] = 1.0\n\n    # Add exploration with probability epsilon\n    if np.random.rand() < epsilon:\n        # Assign random priorities to all bins\n        priorities = np.random.rand(n_bins)\n\n    return priorities",
    "response_id": 18,
    "obj": 4.208216992421225,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit of the item into each bin.  Bins that are too small get 0 fit.\n    fit = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0.0)\n\n    # Normalize the fit values using softmax.\n    if np.sum(fit) > 0:  # handle all fits being 0\n        probabilities = np.exp(fit) / np.sum(np.exp(fit))\n    else:\n        probabilities = np.zeros_like(bins_remain_cap)\n\n    return probabilities",
    "response_id": 19,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 39.863137138648355,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    using First Fit Decreasing (FFD) inspired heuristic.  Prioritizes bins\n    that can accommodate the item with the least wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities  # No bins can fit the item\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (waste + 1e-6)  # Add a small epsilon to avoid division by zero\n    return priorities",
    "response_id": 20,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Best Fit: Prioritize bins where the item fits snugly (smallest remaining capacity)\n    for i, remain_cap in enumerate(bins_remain_cap):\n        if item <= remain_cap:\n            priorities[i] = remain_cap - item  # Lower difference is better\n        else:\n            priorities[i] = -1  # Not a valid bin\n\n    return priorities",
    "response_id": 21,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 20.67970000576925,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on Exact Fit First.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Exact fit first: Highest priority to bins where item fits exactly\n    exact_fit_mask = (bins_remain_cap == item)\n    priorities[exact_fit_mask] = 1.0\n\n    # Then, prioritize bins where the item fits with the least remaining space.\n    # This is to minimize fragmentation.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1.0 / (remaining_space + 1e-6)  # Add a small constant to avoid division by zero\n\n    return priorities",
    "response_id": 24,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate fit score for each bin\n    fit_scores = item / bins_remain_cap\n    \n    # Apply sigmoid function to the fit scores\n    # A higher sigmoid value indicates a better fit\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))  # Adjust parameters as needed\n\n    # Penalize bins that are almost full to encourage spreading items\n    # Prevents all items being placed in the first few bins.\n    almost_full_penalty = np.exp(-10 * (bins_remain_cap / 1.0))\n\n    priorities = sigmoid_scores * almost_full_penalty\n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 121.01398665684616,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the 'greedy' priority:  how well the item fits\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, -1)\n\n    # Epsilon-greedy exploration\n    if np.random.rand() < epsilon:\n        # Randomly assign priorities (exploration)\n        priorities = np.random.rand(len(bins_remain_cap))\n    else:\n        # Use fit scores as priorities (exploitation)\n        priorities = fit_scores\n\n    return priorities",
    "response_id": 28,
    "obj": 138.67171918627844,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 34.86917501586544,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap > 0\n\n    if not np.any(valid_bins):\n        return priorities\n\n    bins_remain_cap_valid = bins_remain_cap[valid_bins]\n    fit_ratios = item / bins_remain_cap_valid\n    fullness = 1 - (bins_remain_cap_valid / np.max(bins_remain_cap))\n\n    # Combine fit and fullness.  Higher fullness *and* good fit are preferred.\n    combined_score = (1 - fit_ratios) * fullness\n\n    # Use sigmoid to scale\n    priorities_valid = 1 / (1 + np.exp(-10 * (combined_score - 0.5)))\n\n    priorities[valid_bins] = priorities_valid\n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 157.89111045234063,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = (bins_remain_cap == item)\n    priorities[exact_fit] = 2.0  # Highest priority\n\n    # Then, prioritize bins where the item fits with minimal remaining capacity\n    remaining_capacity = bins_remain_cap - item\n    valid_bins = remaining_capacity >= 0\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1.0 / (remaining_capacity[valid_bins] + 1e-9)  # Higher priority for smaller remaining capacity\n\n    # Give a small priority to bins where the item does not fit, but the capacity is sufficient\n    insufficient_capacity = (bins_remain_cap < item)\n    priorities[insufficient_capacity] = 0.0 #lowest priority, will not be picked\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 68.53238859703687,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using a heuristic that prioritizes minimizing waste and bin fullness.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities  # No bins can fit the item\n\n    waste = bins_remain_cap[valid_bins] - item\n    fullness = 1.0 - (bins_remain_cap[valid_bins] / np.max(bins_remain_cap))\n    priorities[valid_bins] = fullness * (1.0 / (waste + 1e-6))\n\n    return priorities",
    "response_id": 2,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 97.70233280920246,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Exact fit gets highest priority\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1000  # High priority for exact fit\n\n    # Remaining bins are prioritized based on how close they are to fitting the item\n    remaining_indices = np.where(bins_remain_cap >= item)[0]\n    if len(remaining_indices) > 0:\n        diffs = bins_remain_cap[remaining_indices] - item\n        priorities[remaining_indices] = 1 / (diffs + 1e-6)  # Lower difference = higher priority\n\n    return priorities",
    "response_id": 3,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 70.32403072095333,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (remaining_space + 1e-9)  # More robust zero-division handling\n    return priorities",
    "response_id": 4,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate fit score (lower is better)\n    fit_scores = item / bins_remain_cap\n    fit_scores = np.where(bins_remain_cap == 0, np.inf, fit_scores)  # Avoid division by zero\n\n    # Apply sigmoid to fit scores\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n\n    # Penalize bins that are almost full (higher penalty for nearly full bins)\n    almost_full_penalty = np.exp(-10 * (bins_remain_cap / 1.0))\n\n    # Encourage distribution by penalizing bins that already have a lot of items\n    # (e.g., low remaining capacity). This helps avoid early saturation.\n    distribution_penalty = bins_remain_cap / np.max(bins_remain_cap)\n    distribution_penalty = 1 - distribution_penalty\n\n    # Combine the scores\n    priorities = sigmoid_scores * almost_full_penalty * distribution_penalty\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 185.75424759098897,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Probability of exploration.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the \"greedy\" priority (best fit)\n    for i in range(n_bins):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-6)  # Smaller waste is better\n        else:\n            priorities[i] = 0.0\n\n    # Exploration: Add a small random value to each bin with probability epsilon\n    if np.random.rand() < epsilon:\n        priorities += np.random.rand(n_bins) * 0.1  # Add a small random bonus\n\n    return priorities",
    "response_id": 4,
    "obj": 4.0885520542481055,
    "SLOC": 11.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 89.20647778231529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin. Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return: Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Exact fit gets highest priority\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1000  # High priority for exact fit\n\n    # Remaining bins are prioritized based on how close they are to fitting the item\n    remaining_indices = np.where(bins_remain_cap >= item)[0]\n    if len(remaining_indices) > 0:\n        fit_scores = item / bins_remain_cap[remaining_indices]\n        # Apply a sigmoid function to the fit scores to get priority\n        # This ensures that bins with a better fit (closer to 1) get higher priority,\n        # but also penalizes bins that are too full (fit score > 1).\n        # The sigmoid function parameters can be adjusted to fine-tune the behavior.\n        priorities[remaining_indices] = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n\n    return priorities",
    "response_id": 8,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 114.20025299224778,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize bins where the item fits exactly\n    exact_fit = (bins_remain_cap == item)\n    priorities[exact_fit] = 1.0\n\n    # Then, prioritize bins where the item fits with minimal remaining capacity\n    remaining_capacity = bins_remain_cap - item\n    valid_bins = remaining_capacity >= 0\n\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1.0 / (remaining_capacity[valid_bins] + 1e-9)\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and bins with no capacity\n    valid_bins = bins_remain_cap > 0\n    bins_remain_cap_valid = bins_remain_cap[valid_bins]\n\n    # Calculate the fit score for each valid bin\n    fit_scores = item / bins_remain_cap_valid\n\n    # Apply a sigmoid function to the fit scores to get priority\n    # This ensures that bins with a better fit (closer to 1) get higher priority,\n    # but also penalizes bins that are too full (fit score > 1).\n    # The sigmoid function parameters can be adjusted to fine-tune the behavior.\n    priorities = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n\n    # Create an array of priorities with the same size as bins_remain_cap\n    result_priorities = np.zeros_like(bins_remain_cap)\n    result_priorities[valid_bins] = priorities\n\n    return result_priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 83.39850002884624,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, incorporating reflections.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and prioritize bins with some remaining capacity\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    # Calculate fit score, penalizing overfull bins.\n    fit_scores = np.where(valid_bins, item / bins_remain_cap, -1)\n\n    # Sigmoid scaling with dynamic adjustment.  Larger item -> more aggressive scaling\n    scale_factor = 5 + item * 2  # Adjust as needed\n    priorities = 1 / (1 + np.exp(-scale_factor * (fit_scores - 0.5)))\n\n    # Boost bins that are already somewhat full, encouraging consolidation\n    fullness = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    priorities = priorities * (0.5 + 0.5 * fullness) # Scale priorities to between 0-1, with higher score for fuller bins\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 216.33097149259217,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and bins with no remaining capacity\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    # Calculate the fit score for each valid bin\n    fit_scores = item / bins_remain_cap[valid_bins]\n\n    # Apply a sigmoid function to the fit scores to get priority\n    # This ensures that bins with a better fit (closer to 1) get higher priority,\n    # but also penalizes bins that are too full (fit score > 1).\n    # The sigmoid function parameters can be adjusted to fine-tune the behavior.\n    priorities = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n\n    # Create an array to store the priorities for all bins\n    all_priorities = np.zeros_like(bins_remain_cap)\n\n    # Assign the priorities to the valid bins\n    all_priorities[valid_bins] = priorities\n\n    return all_priorities",
    "response_id": 3,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 95.08241808752197,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and prioritize bins with some capacity\n    valid_bins = bins_remain_cap > 0\n    bins_remain_cap_valid = bins_remain_cap[valid_bins]\n    \n    # Calculate fit score.  Higher is better, but penalize near-full bins\n    fit_scores = item / bins_remain_cap_valid\n    \n    # Sigmoid scaling to smooth fit scores and prevent saturation.  Adjust parameters as needed\n    priorities = 1 / (1 + np.exp(-5 * (fit_scores - 0.7)))\n\n    # Apply a fullness bonus to bins that have been partially used\n    fullness_bonus = (bins_remain_cap_valid - item) / bins_remain_cap_valid\n    priorities = priorities * (1 + 0.2 * fullness_bonus)\n    \n    # Pad the priorities array with zeros for invalid bins.\n    result = np.zeros_like(bins_remain_cap)\n    result[valid_bins] = priorities\n\n    return result",
    "response_id": 4,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 160.4736875252405,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using a heuristic that prioritizes minimizing waste and bin fullness.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities  # No bins can fit the item\n\n    waste = bins_remain_cap[valid_bins] - item\n    fullness = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n    utilization = 1.0 - fullness\n\n    # Combine waste and fullness to create a priority score.\n    # Prioritize bins with low waste and high fullness (low utilization).\n    priorities[valid_bins] = (1.0 / (waste + 1e-6)) * utilization\n\n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 97.70233280920246,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Probability of exploration.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the fit ratio (exploitation)\n    valid_bins = bins_remain_cap > 0\n    bins_remain_cap_valid = bins_remain_cap[valid_bins]\n    fit_ratios = item / bins_remain_cap_valid\n    fit_scores = 1 / (1 + np.exp(10 * (fit_ratios - 0.5)))  # Sigmoid fit\n\n    priorities[valid_bins] = fit_scores\n\n    # Exploration: Add a small random value to each bin with probability epsilon\n    if np.random.rand() < epsilon:\n        priorities += np.random.rand(n_bins) * 0.1  # Add a small random bonus\n\n    return priorities",
    "response_id": 1,
    "obj": 149.2919824491424,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 122.13617281353935,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the fit score for each bin\n    fit_scores = np.where(bins_remain_cap > 0, item / bins_remain_cap, 0)\n\n    # Apply a sigmoid function to the fit scores to get priority\n    # This ensures that bins with a better fit (closer to 1) get higher priority,\n    # but also penalizes bins that are too full (fit score > 1).\n    # The sigmoid function parameters can be adjusted to fine-tune the behavior.\n    priorities = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 81.7492568250068,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if np.sum(valid_bins) == 0:\n        return priorities\n\n    # Calculate fit score for each bin\n    fit_scores = item / bins_remain_cap[valid_bins]\n\n    # Apply sigmoid function to the fit scores\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n\n    # Adjust parameters as needed\n    # Penalize bins that are almost full to encourage spreading items\n    almost_full_penalty = np.exp(-10 * ((1.0 - bins_remain_cap[valid_bins]) / 1.0))\n\n    # Item-specific adjustment: smaller items get a boost to bin spreading\n    item_spread_boost = np.exp(-5 * item)\n\n    priorities[valid_bins] = sigmoid_scores * almost_full_penalty * item_spread_boost\n\n    return priorities",
    "response_id": 5,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.81007680238335,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    # Fit score: how well the item fits in the bin\n    fit_score = item / bins_remain_cap\n    fit_score[~valid_bins] = 0  # Set to 0 for invalid bins\n\n    # Utilization score: how full the bin is after adding the item\n    utilization_score = (bins_remain_cap - item) / bins_remain_cap\n    utilization_score[~valid_bins] = 0\n\n    # Combine fit and utilization scores\n    combined_score = 0.7 * fit_score + 0.3 * utilization_score\n\n    # Penalty for almost full bins (discourage putting items in bins that are already very full)\n    almost_full_penalty = np.exp(-5 * (bins_remain_cap / 1.0))\n    \n    # Apply penalty\n    priorities = combined_score * almost_full_penalty\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 176.46653521143952,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin\n    fit_scores = item / bins_remain_cap\n\n    # Exact fit bonus\n    exact_fit = np.where(np.isclose(fit_scores, 1.0), 1.0, 0.0)\n\n    # Waste score (1 - fit_score) - penalize waste\n    waste_scores = 1 - fit_scores\n\n    # Bin fullness scaling using sigmoid\n    priorities = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n\n    # Combine scores - prioritize exact fits, minimal waste, and fullness\n    priorities = priorities + 0.5 * exact_fit - 0.2 * waste_scores\n\n    # Avoid zero-capacity bins\n    priorities[bins_remain_cap == 0] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 171.8226790216648,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin\n    fit_scores = item / bins_remain_cap\n\n    # Exact fit gets a huge bonus\n    exact_fit_bonus = np.where(np.isclose(fit_scores, 1.0), 100.0, 0.0)\n\n    # Calculate waste\n    waste = bins_remain_cap - item\n\n    # Prioritize minimal waste and bin fullness\n    priorities = (waste / bins_remain_cap) + exact_fit_bonus\n\n    # Apply sigmoid scaling for better balance\n    priorities = 1 / (1 + np.exp(-5 * (priorities - 0.5)))\n\n    # Penalize bins with zero remaining capacity (avoid division by zero)\n    priorities[bins_remain_cap <= 0] = 0.0\n\n    return priorities",
    "response_id": 1,
    "obj": 86.58755484643,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 125.33591475173351,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin\n    fit_scores = item / bins_remain_cap\n\n    # Exact fit gets a huge boost\n    exact_fit_mask = np.isclose(fit_scores, 1.0)\n    fit_scores[exact_fit_mask] = 2.0  # Significantly higher score for exact fit\n\n    # Apply a sigmoid function to the fit scores to get priority\n    # This ensures that bins with a better fit (closer to 1) get higher priority,\n    # but also penalizes bins that are too full (fit score > 1).\n    # The sigmoid function parameters can be adjusted to fine-tune the behavior.\n    priorities = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n\n    # Penalize bins that are almost empty to encourage filling them up first\n    very_empty_mask = bins_remain_cap > 0.95\n    priorities[very_empty_mask] *= 0.8\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 97.70233280920246,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin\n    fit_scores = item / bins_remain_cap\n\n    # Exact fit gets highest priority\n    exact_fit_mask = (fit_scores == 1)\n    priorities = np.where(exact_fit_mask, 1000, 0)  # High priority for exact fit\n\n    # For bins without exact fit, prioritize minimal waste and fullness\n    remaining_bins = bins_remain_cap[~exact_fit_mask]\n    fit_scores_remaining = fit_scores[~exact_fit_mask]\n\n    # Apply a sigmoid function to the fit scores to get priority\n    # This ensures that bins with a better fit (closer to 1) get higher priority,\n    # but also penalizes bins that are too full (fit score > 1).\n    # The sigmoid function parameters can be adjusted to fine-tune the behavior.\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (fit_scores_remaining - 0.5)))\n\n    priorities[~exact_fit_mask] = sigmoid_scores\n\n    # Penalize bins that are nearly empty to avoid creating many partially filled bins\n    priorities = np.where(bins_remain_cap < item * 0.1, priorities - 10, priorities)\n\n    return priorities",
    "response_id": 3,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 160.4736875252405,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1.0 / (bins_remain_cap[valid_bins] - item + 1e-6)\n    return priorities",
    "response_id": 3,
    "obj": 4.198244914240141,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response9.txt_stdout.txt",
    "code_path": "problem_iter6_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    # Fit score: how well the item fits in the bin\n    fit_score = item / bins_remain_cap\n    fit_score[~valid_bins] = 0\n\n    # Utilization score: how full the bin is after adding the item\n    utilization_score = (bins_remain_cap - item) / bins_remain_cap\n    utilization_score[~valid_bins] = 0\n\n    # Combine fit and utilization scores\n    combined_score = 0.6 * fit_score + 0.4 * utilization_score\n\n    # Penalty for almost full bins (discourage putting items in bins that are already very full)\n    almost_full_penalty = np.exp(-5 * (1 - (bins_remain_cap - item) / bins_remain_cap))\n    almost_full_penalty[~valid_bins] = 0\n\n    # Boost for empty or nearly empty bins.\n    empty_boost = np.exp(-10 * (1 - bins_remain_cap / 1.0))\n    empty_boost[~valid_bins] = 0\n\n    priorities = combined_score * almost_full_penalty * empty_boost\n    return priorities",
    "response_id": 9,
    "obj": 103.10131631431992,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 312.7524354002241,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Exact fit gets highest priority\n    exact_fit_priority = np.where(bins_remain_cap == item, 1000, 0)\n\n    # Best fit (minimal waste)\n    waste = bins_remain_cap - item\n    best_fit_priority = 1 / (waste + 1e-6)  # Adding a small value to avoid division by zero\n\n    # Penalize nearly full bins\n    fullness_penalty = np.exp(-bins_remain_cap / item)  # Exponential decay\n\n    # Combine priorities\n    priorities = exact_fit_priority + best_fit_priority - 0.1 * fullness_penalty\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 110.44611534953322,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response2.txt_stdout.txt",
    "code_path": "problem_iter7_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Exact fit gets highest priority\n    exact_fit_mask = (bins_remain_cap == item)\n    priorities = np.where(exact_fit_mask, 1000.0, 0.0)\n\n    # Next, best fit (minimal waste)\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Penalize bins that are too small\n    priorities = np.where(priorities == 0, 1.0 / (waste + 1e-6), priorities)\n\n    # Penalize nearly full bins (avoid fragmentation)\n    fullness = bins_remain_cap / np.max(bins_remain_cap)\n    priorities = priorities * (1.0 - fullness * 0.5)\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 127.43782540330756,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response4.txt_stdout.txt",
    "code_path": "problem_iter7_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between item size and remaining capacity\n    diff = bins_remain_cap - item\n\n    # Prioritize exact fits (diff == 0)\n    exact_fit = (diff == 0).astype(float) * 1000  # High priority for exact fits\n\n    # Prioritize tight fits (small positive difference)\n    tight_fit = np.where(diff > 0, 1 / diff, 0)  # Higher priority for smaller differences\n\n    # Penalize nearly full bins (small remaining capacity)\n    fullness_penalty = np.where(bins_remain_cap < item * 1.1, 1 / (item * 1.1 - bins_remain_cap), 0) #Small penalty for near full bins\n\n    # Combine the scores\n    priorities = exact_fit + tight_fit - fullness_penalty\n\n    return priorities",
    "response_id": 4,
    "obj": 4.567211806940562,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 160.5395382709427,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    fit_scores = item / bins_remain_cap\n    priorities = 1 / (1 + np.exp(-5 * (fit_scores - 0.5)))\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Exact fit gets highest priority\n    exact_fit_priority = np.where(bins_remain_cap == item, 1000, 0)\n\n    # Best fit (minimal waste)\n    waste = bins_remain_cap - item\n    best_fit_priority = np.where(waste >= 0, 1 / (waste + 1e-6), 0)  # Only consider bins that can fit the item\n\n    # Penalize nearly full bins (exponential decay) - more aggressive penalty\n    fullness_penalty = np.exp(-bins_remain_cap / item)\n\n    # Reward bins that are not empty\n    not_empty_reward = np.where(bins_remain_cap > 0, 1, 0)\n\n    # Combine priorities with weights.  Adjust weights as needed.\n    priorities = (\n        0.6 * exact_fit_priority +\n        0.3 * best_fit_priority +\n        0.1 * not_empty_reward -\n        0.2 * fullness_penalty\n    )\n    return priorities",
    "response_id": 2,
    "obj": 60.949341842840056,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 215.90318620677482,
    "exec_success": true
  }
]