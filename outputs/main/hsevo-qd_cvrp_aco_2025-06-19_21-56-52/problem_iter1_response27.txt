```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates distance, demand, and angular proximity into the heuristic.

    Args:
        distance_matrix: Distance matrix between nodes (n x n).
        coordinates: Euclidean coordinates of nodes (n x 2).
        demands: Demand of each node (n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of the same shape as distance_matrix, indicating the desirability of each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to tune the importance of different factors.  Adjust these to observe their effects.
    distance_factor = 1.0
    demand_factor = 1.0
    angle_factor = 0.5 # Reduced as it sometimes over-constrains

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # 1. Distance heuristic: Inverse of distance
            distance_heuristic = distance_factor / distance_matrix[i, j]

            # 2. Demand heuristic: Favor edges connecting to nodes with demands that, when combined,
            # are not too close to the capacity, avoiding prematurely filling up the vehicle.

            # Scale and shift demand to prevent division by zero errors and make it a penalty.
            # A small value (e.g., 0.001) is added so it never evaluates to precisely zero.
            demand_sum = demands[i] + demands[j]
            demand_heuristic = 1.0 / (0.001 + abs(capacity / 2 - demand_sum)) if demand_sum != 0 else 0.0

            # 3. Angle heuristic: Encourages connections between nodes that are relatively close angularly
            # relative to the depot. This promotes more spatially coherent routes.

            # Calculate angles relative to the depot (node 0)
            angle_i = np.arctan2(coordinates[i, 1] - coordinates[0, 1], coordinates[i, 0] - coordinates[0, 0])
            angle_j = np.arctan2(coordinates[j, 1] - coordinates[0, 1], coordinates[j, 0] - coordinates[0, 0])
            angle_diff = min(abs(angle_i - angle_j), 2 * np.pi - abs(angle_i - angle_j))  # Ensure smaller angle is chosen

            # Angular proximity heuristic. Smaller angle difference means greater desirability
            angle_heuristic = 1.0 / (0.001 + angle_diff)  # Inverse of the angle difference to the depot.

            # Combine the heuristics.  Careful consideration needed for weights.
            heuristic_matrix[i, j] = (distance_heuristic * distance_factor +
                                       demand_heuristic * demand_factor +
                                       angle_heuristic * angle_factor)
    return heuristic_matrix
```
