```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP using a combination of distance, demand, and angle considerations.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes.
        coordinates (np.ndarray): Euclidean coordinates of nodes.
        demands (np.ndarray): Demand of each node.
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Heuristic values for each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Adjust for division by zero
    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance component: Shorter distance is better
                distance_component = 1 / distance_matrix[i, j]

                # Demand component: Penalize edges connecting nodes with high total demand.
                # Try to balance loads across routes.
                demand_penalty = (demands[i] + demands[j]) / (2 * capacity)
                demand_component = np.exp(-demand_penalty)  # Exponential decay

                # Angle component:  Encourage smoother routes by penalizing sharp turns.
                # Measure angle between edge i->j and the average position
                # or some other point like the depot (node 0).
                depot_coord = coordinates[0]  # Depot is node 0.

                vector_ij = coordinates[j] - coordinates[i]
                vector_i_depot = depot_coord - coordinates[i]

                #Calculate angle between i->j and i->depot
                norm_ij = np.linalg.norm(vector_ij)
                norm_i_depot = np.linalg.norm(vector_i_depot)

                if norm_ij == 0 or norm_i_depot == 0:
                   angle_penalty = 1.0
                else:
                    cos_angle = np.dot(vector_ij, vector_i_depot) / (norm_ij * norm_i_depot)
                    cos_angle = np.clip(cos_angle, -1.0, 1.0)
                    angle = np.arccos(cos_angle) # radians
                    angle_penalty = np.exp(-angle**2)  # Prefer edges closer to pointing towards the depot (smoother path towards depot)

                heuristic_matrix[i, j] = distance_component * demand_component * angle_penalty

    return heuristic_matrix
```
