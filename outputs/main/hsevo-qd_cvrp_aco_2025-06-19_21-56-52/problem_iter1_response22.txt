```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP) based on a combination of distance, demand,
    and angle considerations.

    Args:
        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes.
        coordinates (np.ndarray): A matrix of node coordinates (x, y).
        demands (np.ndarray): A vector of customer demands.
        capacity (int): The capacity of each vehicle.

    Returns:
        np.ndarray: A matrix of heuristic scores, with higher values indicating more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Avoid division by zero. Adds a small number to the denominator.
    epsilon = 1e-6

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
            else:
                # Distance component: Shorter distances are more desirable
                distance_score = 1 / (distance_matrix[i, j] + epsilon)

                # Demand component: Consider the demands of the nodes. Lower is better.
                demand_score = 1 / (demands[i] + demands[j] + epsilon)  # Normalize by the sum of both demands

                # Angle component: Penalize sharp turns.
                # Consider angles formed by i -> j -> depot. If small angle (close to straight line)
                # then a higher heuristic is preferred
                # Formula angle between vectors a and b:  cos(theta) = (a.b) / (||a||*||b||)

                a = coordinates[i] - coordinates[j]
                b = coordinates[0] - coordinates[j] # Depot coordinates as 0
                norm_a = np.linalg.norm(a) + epsilon
                norm_b = np.linalg.norm(b) + epsilon

                cos_angle = np.dot(a, b) / (norm_a * norm_b)
                # Clip to handle possible numerical issues.
                cos_angle = np.clip(cos_angle, -1.0, 1.0)

                angle_score = (1 + cos_angle) / 2 # Scale to 0 to 1

                # Combine the components.  Experiment with weights
                heuristic_matrix[i, j] = (0.6 * distance_score + 0.2 * demand_score + 0.2 * angle_score)

    return heuristic_matrix
```
