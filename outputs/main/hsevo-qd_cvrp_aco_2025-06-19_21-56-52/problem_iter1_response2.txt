```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic for the Capacitated Vehicle Routing Problem (CVRP) based on a combination of distance,
    demand, and spatial relationships.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Vector of customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Heuristic matrix (n x n) indicating the desirability of each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to control the influence of each component. Can be tuned.
    distance_weight = 1.0
    demand_weight = 1.0
    angle_weight = 0.5

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Component 1: Inverse distance (closer is better)
            distance_heuristic = distance_weight / (distance_matrix[i, j] + 1e-6)  # Adding a small value to avoid division by zero

            # Component 2: Demand consideration (avoid overloading vehicles early)
            demand_heuristic = 1.0
            if i != 0 and j != 0:  # Not related to the depot
                demand_heuristic = demand_weight / (demands[j] + 1e-6) #Lower demand node is better, avoid overloading.

            # Component 3: Angle from depot
            angle_heuristic = 1.0
            if i != 0 and j != 0: #Both are not the depot
                depot_coord = coordinates[0]
                coord_i = coordinates[i]
                coord_j = coordinates[j]

                # Calculate angles with respect to the depot
                angle_i = np.arctan2(coord_i[1] - depot_coord[1], coord_i[0] - depot_coord[0])
                angle_j = np.arctan2(coord_j[1] - depot_coord[1], coord_j[0] - depot_coord[0])

                angle_diff = np.abs(angle_i - angle_j)
                angle_diff = np.minimum(angle_diff, 2 * np.pi - angle_diff)  # Ensure smaller angle difference

                angle_heuristic = angle_weight / (angle_diff + 1e-6) #Prefer smaller angle difference

            heuristic_matrix[i, j] = distance_heuristic * demand_heuristic * angle_heuristic

    return heuristic_matrix
```
