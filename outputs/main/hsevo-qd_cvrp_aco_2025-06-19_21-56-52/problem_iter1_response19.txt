```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling principles.

    This version prioritizes edges connecting nodes with complementary demands
    and incorporates a depot-distance penalty.
    """

    n = distance_matrix.shape[0]
    h = np.zeros((n, n))

    # Demand-based heuristic: Nodes with complementary demands are favored.
    # This encourages vehicles to fill up their capacity efficiently.
    normalized_demands = demands / capacity  # Scale demands to [0, 1]
    demand_compatibility = np.abs(normalized_demands[:, None] + normalized_demands[None, :] - 1)
    demand_component = 1 - demand_compatibility # Ranges from 0 to 1, higher is better

    # Distance-based heuristic: Shorter distances are favored, but with adjustment.
    distance_component = 1 / (distance_matrix + 1e-9)  # Avoid division by zero

    # Depot proximity penalty: discourage long routes to/from the depot.
    depot_penalty = np.zeros((n, n))
    for i in range(1, n):  # Skip depot (node 0)
        depot_penalty[0, i] = np.exp(-distance_matrix[0, i] / np.mean(distance_matrix[0, 1:]))  # Penalize far nodes
        depot_penalty[i, 0] = np.exp(-distance_matrix[i, 0] / np.mean(distance_matrix[0, 1:]))

    # Combination of heuristics with weights. Experiment with these!
    h = 0.6 * distance_component + 0.3 * demand_component + 0.1 * depot_penalty

    # Ensure depot connections are always present but penalized for longer distances.
    for i in range(1, n):
        h[0, i] = max(h[0, i], 0.5 * distance_component[0, i] + 0.3) # always has non-zero value
        h[i, 0] = max(h[i, 0], 0.5 * distance_component[i, 0] + 0.3)

    # Removing diagonal elements since we don't want node -> same node
    for i in range(n):
        h[i,i] = 0

    return h
```
