```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for CVRP using a combination of distance, angle, and demand considerations.

    Args:
        distance_matrix: Distance between each pair of nodes.
        coordinates: Coordinates of each node.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        A matrix of heuristic values for each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters for weighting different factors
    distance_weight = 0.6
    angle_weight = 0.3
    demand_weight = 0.1

    # Calculate angles relative to the depot (node 0)
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance component: Favor shorter distances
            distance_heuristic = 1 / (distance_matrix[i, j] + 1e-6) #adding a small constant to avoid zero division

            # Angle component: Favor nodes in similar directions from depot
            angle_difference = np.abs(angles[i] - angles[j])
            angle_heuristic = 1 / (np.sin(angle_difference/2)**2 + 1e-6) # Avoid 1/0 when angle_difference == 0 or 2pi. Small value in denominator for stability

            # Demand component: Penalize edges that would likely overload the vehicle
            demand_heuristic = 1 - min(1, (demands[i] + demands[j]) / capacity)

            # Combine the heuristics
            heuristic_matrix[i, j] = (
                distance_weight * distance_heuristic +
                angle_weight * angle_heuristic +
                demand_weight * demand_heuristic
            )
    return heuristic_matrix
```
