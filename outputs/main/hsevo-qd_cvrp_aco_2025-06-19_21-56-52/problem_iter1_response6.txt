```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Capacity of each vehicle.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Avoid division by zero in the distance matrix. Add small number when equal to zero.
    distance_matrix = np.where(distance_matrix == 0, 1e-6, distance_matrix)

    # 1. Distance-based heuristic (Inverse distance). More priority to smaller distance
    heuristics = 1 / distance_matrix

    # 2. Demand-based heuristic (Favor routes with high demand, balanced by capacity).
    for i in range(n):
        for j in range(n):
            if i != j:
                #if demands[i] + demands[j] <= capacity: # Consider combined demand constraint
                heuristics[i, j] *= (demands[i] + demands[j]) / capacity  # Scale by normalized demand

    # 3. Depot proximity heuristic (Favor connections closer to the depot).
    depot_index = 0
    for i in range(n):
        if i != depot_index:
            heuristics[depot_index, i] *= 1.5 # Boosts the weight
            heuristics[i, depot_index] *= 1.5

    # 4. Node Dispersion
    centroid = np.mean(coordinates[1:], axis=0) # Calculate center of mass excluding the depot
    distances_to_centroid = np.linalg.norm(coordinates - centroid, axis=1)

    for i in range(n):
        for j in range(n):
            if i!= j:
              heuristics[i,j] *= np.sqrt(distances_to_centroid[i] * distances_to_centroid[j]) # Penalize nodes too close to centre.

    # Make it symmetric to avoid direction bias.
    heuristics = (heuristics + heuristics.T) / 2

    # Setting diagonal elements to zero is crucial for CVRP.
    np.fill_diagonal(heuristics, 0)

    return heuristics
```
