```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and node proximity.

    This heuristic aims to provide a more informed prior for stochastic sampling
    in CVRP by considering:
    1.  Distance: Shorter distances are generally preferred.
    2.  Demand: Edges connecting nodes with high demand relative to vehicle
        capacity are penalized (less promising for direct connection). This
        is crucial for adhering to capacity constraints.
    3.  Angle: Nodes that are "ahead" relative to the depot are favored. This encourages exploration away from the depot before returning.
    4. Node proximity to depot: penalizing edges that connect node far from depot.

    Args:
        distance_matrix: Distance between nodes.
        coordinates: (x, y) coordinates of each node.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        A matrix of heuristic values (same shape as distance_matrix). Higher values
        indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    depot_x, depot_y = coordinates[0]  # Assuming depot is node 0

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue
            if i == 0 and j == 0:
                heuristic_matrix[i, j] = 0
                continue

            distance = distance_matrix[i, j]
            if distance == 0:
                heuristic_matrix[i,j] = 0 # Avoid division by zero when the distance is exactly 0

                continue


            # Distance-based component (favor shorter distances)
            distance_factor = 1 / distance

            # Demand-based component (penalize edges with high demand)
            demand_factor = 1 - (demands[i] + demands[j]) / (2 * capacity) # Normalized demand penalization.
            demand_factor = max(0.01, demand_factor)  # Ensure demand_factor is not too small (avoid division by zero risk and give at least some probability if the constraints are really hard to fulfill)

            # Angle-based component (encourage exploration away from depot)
            dx = coordinates[j, 0] - coordinates[i, 0]
            dy = coordinates[j, 1] - coordinates[i, 1]
            angle = np.arctan2(dy, dx)  # Angle in radians
            angle_factor = (np.cos(angle) + 1) / 2  # Normalize to [0, 1]

            # Depot Proximity component
            depot_proximity = 1/(distance_matrix[0,i] + distance_matrix[0,j])
            # Combine the factors
            heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor * depot_proximity

    return heuristic_matrix
```
