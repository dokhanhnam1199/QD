```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Generates heuristics for CVRP based on a combination of distance,
    demand, and geometric considerations.  Prioritizes shorter distances,
    penalizes connections that would likely overload vehicles, and
    incorporates a "gravitational" pull towards the depot for balancing loads.

    Args:
        distance_matrix: Distance between nodes (n x n).
        coordinates: Node coordinates (n x 2).
        demands: Node demands (n).
        capacity: Vehicle capacity.

    Returns:
        Heuristic matrix (n x n) representing the desirability of each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to control the influence of different factors
    distance_weight = 1.0
    demand_weight = 0.5
    depot_attraction_weight = 0.2
    capacity_threshold = 0.8  # Adjust as needed. Higher values penalize approaching max capacity

    # Calculate depot distances
    depot_distances = distance_matrix[0, :]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance component: shorter is better
            distance_heuristic = distance_weight / (distance_matrix[i, j] + 1e-6)  # Adding a small constant to avoid division by zero

            # Demand component: Penalize connections that likely overload vehicles
            # Estimate remaining capacity assuming i and j are in the same route
            estimated_load = demands[i] + demands[j] # Rough heuristic
            demand_heuristic = 1.0
            if estimated_load > capacity * capacity_threshold:
                demand_heuristic = 0.1  # Strong penalty

            # Depot attraction: Encourage returning to the depot to balance loads.
            depot_attraction = depot_attraction_weight * (
                1 / (min(depot_distances[i], depot_distances[j]) + 1e-6)  # Prefer returning near depot, but not required
            )


            heuristic_matrix[i, j] = distance_heuristic * demand_heuristic + depot_attraction

    return heuristic_matrix
```
