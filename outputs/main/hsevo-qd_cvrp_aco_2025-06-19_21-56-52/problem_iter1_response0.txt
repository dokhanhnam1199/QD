```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP) using a combination of distance,
    demand, and a stochastic element.  It prioritizes shorter distances, penalizes edges connecting to
    nodes that would likely overload a vehicle, and introduces some randomness to encourage exploration.

    Args:
        distance_matrix: A numpy array of shape (n, n) representing the distances between nodes.
        coordinates: A numpy array of shape (n, 2) representing the Euclidean coordinates of the nodes.
        demands: A numpy array of shape (n,) representing the demand of each node.
        capacity: The capacity of each vehicle.

    Returns:
        A numpy array of shape (n, n) representing the heuristic values for each edge.  Higher values
        indicate that the edge is more promising.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (can be tuned)
    distance_weight = 0.5
    demand_weight = 0.3
    random_weight = 0.2
    near_depot_bonus = 1.5

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance component: Favor shorter distances
                distance_heuristic = 1 / distance_matrix[i, j]

                # Demand component: Penalize edges that lead to overcapacity.
                #   The penalty is higher if either node has high demand.
                demand_heuristic = 1 - (demands[i] + demands[j]) / (2 * capacity)
                demand_heuristic = max(0.01, demand_heuristic) # ensure it is not zero

                #Near depot bonus for connections close to the depot
                depot_distance_i = distance_matrix[i,0]
                depot_distance_j = distance_matrix[j,0]
                near_depot = 1
                if depot_distance_i < np.mean(distance_matrix[i,:]) or depot_distance_j < np.mean(distance_matrix[j,:]):
                    near_depot = near_depot_bonus

                # Random component: Add some randomness to explore different solutions.
                random_heuristic = np.random.rand() * 0.1

                # Combine the components
                heuristic_matrix[i, j] = near_depot*(distance_weight * distance_heuristic +
                                               demand_weight * demand_heuristic +
                                               random_weight * random_heuristic)
            else:
                heuristic_matrix[i, j] = 0  # No self-loops

    return heuristic_matrix
```
