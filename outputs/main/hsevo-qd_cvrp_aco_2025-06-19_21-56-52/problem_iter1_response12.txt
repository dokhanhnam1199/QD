```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate a combined score based on distance, demand, and angle.
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # Avoid self-loops
                continue

            # Distance component (favor shorter distances)
            distance_component = 1 / (distance_matrix[i, j] + 1e-6)  # Add a small constant to avoid division by zero

            # Demand component (penalize edges leading to high-demand nodes if i is not the depot)
            demand_component = 1.0
            if i != 0:  #not starting at the depot
                demand_component = 1.0 / (demands[j] + 1e-6) #penalize for large demands.

            # Angle component (try to have small angles. A smaller angle means nodes i,j, depot form nearly a line)
            if i != 0 and j != 0:
                depot_x, depot_y = coordinates[0]
                i_x, i_y = coordinates[i]
                j_x, j_y = coordinates[j]
                
                # Calculate vectors
                vec_i = np.array([i_x - depot_x, i_y - depot_y])
                vec_j = np.array([j_x - depot_x, j_y - depot_y])
                
                # Calculate cosine of the angle
                norm_i = np.linalg.norm(vec_i)
                norm_j = np.linalg.norm(vec_j)
                if norm_i > 0 and norm_j > 0:
                  cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)
                  cos_angle = np.clip(cos_angle, -1, 1)
                  angle_component = (1 + cos_angle) / 2 # small angle is better - closer to 1 (since angles close to 180 degrees - anti-correlation is bad)
                else:
                  angle_component = 0.5 #set to average if norm = 0.

            else:
              angle_component = 1.0 # if starting from depot - allow.

            heuristic_matrix[i, j] = distance_component * demand_component * angle_component

    return heuristic_matrix
```
