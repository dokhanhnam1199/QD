```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP)
    using a combination of distance, demand, and angular considerations
    to create prior indicators for edge inclusion.

    Args:
        distance_matrix (np.ndarray): A square matrix of distances between nodes.
        coordinates (np.ndarray): Euclidean coordinates of the nodes.
        demands (np.ndarray): Demand of each node.
        capacity (int): Capacity of each vehicle.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing
                    prior indicators for edge inclusion. Higher values indicate
                    more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to tune the influence of each component
    distance_weight = 0.5
    demand_weight = 0.3
    angle_weight = 0.2

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance component: Inverse of distance. Shorter distances are preferred.
                distance_heuristic = 1 / distance_matrix[i, j]

                # Demand component:  Considers the demands of the nodes connected by the edge.
                # Penalizes edges connecting nodes with high combined demands relative to capacity,
                # especially when going to or from the depot (node 0).
                demand_heuristic = 1.0  # Default value

                if i == 0 or j == 0: #Penalize routes directly linking to the depot
                    demand_ratio = (demands[i] + demands[j]) / (2 * capacity)  #Penalize direct to depot links with high demands.
                else:
                     demand_ratio = (demands[i] + demands[j]) / (2 * capacity) # penalizes mid routes with high demands

                demand_heuristic = max(0, 1 - demand_ratio)

                # Angle component: Encourage routes that does not make sharp angle with depot.
                # Penalizes sharp turns, especially near the depot.  Calculates the angle
                # between the vectors (coordinates[i] - coordinates[0]) and (coordinates[j] - coordinates[0]),
                # if neither node is the depot. Otherwise, the angle component is neutral (1).
                angle_heuristic = 1.0 # neutral
                if i != 0 and j != 0:
                    v1 = coordinates[i] - coordinates[0]
                    v2 = coordinates[j] - coordinates[0]
                    norm_v1 = np.linalg.norm(v1)
                    norm_v2 = np.linalg.norm(v2)

                    if norm_v1 > 0 and norm_v2 > 0:

                      dot_product = np.dot(v1, v2)
                      cos_angle = dot_product / (norm_v1 * norm_v2)

                      angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))

                      angle_penalty = 1 - (abs(angle - np.pi/2)/(np.pi/2))
                      angle_heuristic = max(0, angle_penalty)  # Penalize based on angle deviating from right angle

                # Combine the components with weighted averages.
                heuristic_matrix[i, j] = (distance_weight * distance_heuristic +
                                            demand_weight * demand_heuristic +
                                            angle_weight * angle_heuristic)

    return heuristic_matrix
```
