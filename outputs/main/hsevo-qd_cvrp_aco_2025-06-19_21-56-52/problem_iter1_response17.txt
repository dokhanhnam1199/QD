```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    Combines distance, demand, and geometric considerations to estimate edge desirability.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Vector of customer demands (n). Depot demand is demands[0].
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of edge desirability (n x n).  Higher values indicate
                     more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Parameters (tune these!)
    distance_weight = 1.0       # Relative importance of distance
    demand_weight = 0.5         # Relative importance of demand considerations
    depot_proximity_weight = 0.7  # Encourages return trips to the depot for replenishment.
    geo_weight = 0.3            #Geometric weight
    capacity_utilization_weight = 0.2 #penalty for high vehicle utilization.

    # Calculate a capacity utilization factor based on total demand
    total_demand = np.sum(demands)
    expected_num_vehicles = np.ceil(total_demand / capacity) # Lower bound.
    avg_route_length_penalty = 1.0 / expected_num_vehicles if expected_num_vehicles > 0 else 1.0

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
                continue

            # Distance-based desirability (inverse distance)
            distance_heuristic = 1 / distance_matrix[i, j]

            # Demand-based desirability (encourage connections between nodes that will fill up the vehicle)
            demand_heuristic = 1 / (1 + abs(capacity / 2 - demands[i] - demands[j])) if i !=0 and j != 0 else 0  #Avoid dividing by zero. penalize combinations that deviate from half-capacity

            # Geometric heuristic. angle to depot

            vector_i = coordinates[i] - coordinates[0]
            vector_j = coordinates[j] - coordinates[0]

            norm_i = np.linalg.norm(vector_i)
            norm_j = np.linalg.norm(vector_j)

            if norm_i > 0 and norm_j > 0:
               cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)
               angle_heuristic = (1 - cos_angle)  #Smaller angle -> prefer (anti-correlated)
            else:
               angle_heuristic = 0

            #Depot proximity heuristic: encourage short tours from/to the depot

            depot_proximity = (1 / distance_matrix[0,i] + 1/distance_matrix[0,j]) if i != 0 and j != 0 else 0

            #Penalty based on vehicle capacity
            # Encourage better vehicle utilizations. Less penalty for shorter tours.
            capacity_utilization_penalty = (1 - min(demands[i] + demands[j], capacity) / capacity) if i !=0 and j!=0 else 0 #small penality if demand[i] + demand[j] is close to capacity

            # Combine the heuristics
            heuristics[i, j] = (
                distance_weight * distance_heuristic +
                demand_weight * demand_heuristic +
                depot_proximity_weight * depot_proximity +
                geo_weight * angle_heuristic +
                capacity_utilization_weight * capacity_utilization_penalty
            )

            #Symmetrize heuristic: Prefer shortest edge with larger desirability score
            heuristics[i,j] = max(heuristics[i,j], heuristics[j,i])
    return heuristics
```
