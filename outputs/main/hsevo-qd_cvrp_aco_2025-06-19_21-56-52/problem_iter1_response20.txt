```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP using distance, demand, and depot proximity.

    This version combines inverse distance with a demand-aware factor
    and a penalty for edges far from the depot.

    Args:
        distance_matrix: Distance between nodes.
        coordinates: Node coordinates.
        demands: Node demands.
        capacity: Vehicle capacity.

    Returns:
        Edge prior indicators.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Depot location
    depot_x, depot_y = coordinates[0]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
            else:
                # Base: inverse distance
                heuristic_value = 1 / distance_matrix[i, j]

                # Demand factor: Prefer edges connecting nodes with lower demands.
                # This encourages balanced routes. We add a small constant to
                # prevent division by zero.  We avoid incorporating the depot's demand in the routing considerations
                demand_factor = 1 / (np.sqrt(demands[i] * demands[j]) + 0.1)  # Geometric Mean

                heuristic_value *= demand_factor

                # Depot proximity penalty:  Edges far from the depot are penalized.
                #  Euclidean distance from the midpoint of the edge to the depot
                midpoint_x = (coordinates[i][0] + coordinates[j][0]) / 2
                midpoint_y = (coordinates[i][1] + coordinates[j][1]) / 2
                depot_distance = np.sqrt((midpoint_x - depot_x)**2 + (midpoint_y - depot_y)**2)

                # Penalize based on depot distance. Scale this, since the effect of distance matrix has
                # been taken into consideration.
                depot_penalty = 1 / (depot_distance + 1)  # Adding 1 to prevent division by zero and dampen impact
                heuristic_value *= depot_penalty**0.5

                heuristic_matrix[i, j] = heuristic_value

    return heuristic_matrix
```
