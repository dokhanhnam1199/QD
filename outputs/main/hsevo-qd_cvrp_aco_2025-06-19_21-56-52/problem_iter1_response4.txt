```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Improves upon the trivial heuristic by incorporating distance, demand, and node proximity.
    It prioritizes shorter distances, avoids connecting high-demand nodes directly unless necessary,
    and favors connecting nodes that are spatially clustered together.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Demand normalization factor (scale demands to be between 0 and 1)
    max_demand = np.max(demands)
    normalized_demands = demands / max_demand

    # Euclidean distance normalization factor
    max_distance = np.max(distance_matrix)

    # Calculate node density using inverse distance. This penalizes routes through sparsely connected areas.
    node_density = np.zeros(n)
    for i in range(n):
        node_density[i] = np.sum(1.0 / (distance_matrix[i, 1:] + 1e-6)) # Avoid division by zero. Depot excluded
        #+ 1e-6 ensures a positive divisor which guarantees that 0<node_density

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0.0  # No self-loops
                continue

            # Basic distance heuristic (shorter distances are better)
            distance_score = 1.0 / (distance_matrix[i, j] + 1e-6) # Avoid division by zero

            # Demand penalty: penalize routes between high-demand nodes
            demand_penalty = 1 - (normalized_demands[i] + normalized_demands[j]) / 2.0  # Ranges from 0 to 1

            # Node density component
            density_score = (node_density[i] + node_density[j]) / 2.0

            # Proximity score (Euclidean closeness encourages clusters)
            proximity = np.sqrt(np.sum((coordinates[i] - coordinates[j])**2))
            proximity_score = 1.0 / (proximity + 1e-6)


            #Combine all factors. Tune the weights to control the influence of each factor.
            heuristic_matrix[i, j] = (
                0.5 * distance_score +
                0.2 * demand_penalty +
                0.15 * density_score +
                0.15 * proximity_score
            )

    return heuristic_matrix
```
