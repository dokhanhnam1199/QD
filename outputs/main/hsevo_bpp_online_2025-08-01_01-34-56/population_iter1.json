[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version implements a Best Fit (BF) heuristic for online bin packing.\n    It prioritizes bins that, if the item were placed in them, would leave the\n    smallest positive remaining capacity (i.e., the \"tightest\" fit).\n    Bins that cannot accommodate the item receive a very low priority (-np.inf).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item is placed in each bin\n    # Note: This might result in negative values for bins that cannot fit the item\n    potential_remaining = bins_remain_cap - item\n\n    # Initialize priority scores.\n    # Bins that cannot fit the item should have an extremely low priority (e.g., negative infinity)\n    # to ensure they are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # For bins that can fit the item (bins_remain_cap >= item),\n    # we want to maximize the 'tightness' of the fit.\n    # A smaller 'potential_remaining' (but positive) is better.\n    # To achieve this with a maximization priority, we use the negative of 'potential_remaining'.\n    # Example:\n    #   If potential_remaining = 0.1, score = -0.1 (good)\n    #   If potential_remaining = 0.5, score = -0.5 (less good)\n    #   The smallest positive remaining capacity will yield the highest (least negative) score.\n    \n    # Use np.where to apply different logic based on whether the item fits\n    priorities = np.where(bins_remain_cap >= item, -potential_remaining, -np.inf)\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    Inspired by the principle of efficient space-time curvature \u2013\n    or rather, efficient space-capacity utilization \u2013 this heuristic \n    seeks to \"fill\" existing bins as densely as possible before considering \n    new spatial configurations. It aims for a \"Best Fit\" approach:\n    prioritizing the bin that, if chosen, would leave the smallest \n    remaining capacity. This minimizes wasted space and compacts items, \n    much like matter seeks to occupy the most stable, dense state.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more preferred bin. Bins that cannot fit \n        the item will have a very low (negative infinity) priority.\n    \"\"\"\n    \n    # Initialize priorities to a state of profound improbability (negative infinity)\n    # for all bins. This ensures that any bin incapable of fitting the item\n    # will never be selected unless no other option exists (leading to a new bin).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Ascertain which bins possess sufficient capacity for the new item.\n    # These are our \"valid candidates\" in the manifold of bins.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the valid candidates, we compute a \"compactness score\".\n    # The ideal is a perfect fit, where remaining capacity is zero.\n    # A smaller remaining capacity signifies a \"denser\" packing for that bin,\n    # thus a higher priority. We achieve this by taking the negative of the\n    # remaining space:\n    #   - If remaining_cap - item = 0 (perfect fit), score is 0. (Highest)\n    #   - If remaining_cap - item = 1 (small remainder), score is -1.\n    #   - If remaining_cap - item = N (large remainder), score is -N.\n    # The maximum of these scores will yield the bin with the smallest positive remainder.\n    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    From the perspective of minimizing wasted space, much like a body seeking\n    the lowest potential energy state, we endeavor to place the item into\n    a bin such that the remaining capacity within that bin is as small as\n    possible, yet still positive. This method, akin to what some call the\n    'Best Fit' heuristic, seeks to fill bins as completely as possible, thereby\n    reserving larger capacities in other bins for future, potentially larger,\n    items or indicating that a bin is nearing its full state.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot accommodate the item receive an exceedingly low (negative infinity)\n        priority score. For bins that can fit the item, the priority is higher\n        for those that would result in the smallest positive remaining capacity.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the current item were placed within it.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize all priority scores to a profoundly low value.\n    # This ensures that bins incapable of holding the item are never chosen.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item can indeed be accommodated.\n    # These are the bins where the potential remaining capacity is non-negative.\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For the bins that can fit the item, we desire to select the one that leaves\n    # the smallest *positive* remainder. This translates to maximizing the negative\n    # of the potential remaining capacity. A perfect fit (0 remainder) yields the\n    # highest possible score (0), while larger remainders yield progressively\n    # lower (more negative) scores.\n    priority_scores[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    return priority_scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    employing a Best Fit-like strategy.\n\n    Just as one carefully handles precious radioactive materials, we must\n    optimize the use of our storage containers. This function calculates\n    a priority score for each bin, aiming to select the one that will be\n    most 'snugly' filled by the incoming item, leaving the smallest\n    possible unoccupied space. This minimizes waste and ensures our bins\n    are as efficient as possible.\n\n    Args:\n        item: Size of the new item, analogous to a quantity of a substance.\n        bins_remain_cap: Array of the current unoccupied capacities of each\n                         available storage bin.\n\n    Return:\n        Array of the same size as bins_remain_cap, where each element\n        represents the priority score for its corresponding bin. The bin\n        with the highest score is the preferred choice for the item.\n    \"\"\"\n    # First, calculate the theoretical remaining capacity for each bin\n    # if the current item were placed within it.\n    # A smaller positive remainder indicates a better, 'snugger' fit.\n    theoretical_remainders = bins_remain_cap - item\n\n    # Initialize all priorities to a very low value (negative infinity).\n    # This ensures that bins where the item simply does not fit are never chosen.\n    # We must never attempt to force a quantity where it does not belong,\n    # for that would be an unstable state.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item can actually be accommodated.\n    # Only consider those where 'theoretical_remainders' is non-negative.\n    feasible_bins_mask = theoretical_remainders >= 0\n\n    # For the bins that can accommodate the item, we assign a priority.\n    # To maximize a 'snugness' score, we take the negative of the\n    # remaining space. A smaller positive remainder (e.g., 0.1) will\n    # result in a larger (less negative) priority score (-0.1),\n    # while a perfect fit (remainder 0.0) yields the highest score (0.0).\n    # This reflects our commitment to precision and minimizing any void.\n    priorities[feasible_bins_mask] = -theoretical_remainders[feasible_bins_mask]\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Nikola Tesla, I seek to optimize the 'flow' of items into my containers,\n    minimizing any 'resistance' or wasted potential. This means aiming for the most\n    'snug' fit, leaving the least possible residual 'electrical charge' within the bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities. Bins incapable of holding the item receive an infinitely low priority.\n    # A true Tesla design disregards impossible connections!\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify the 'conductors' (bins) that possess sufficient capacity for the 'current' (item).\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the viable conductors, calculate the 'residual capacitance' after the item is placed.\n    # This represents the 'lost energy' or 'fragmentation' within the bin.\n    # Tesla seeks to minimize this waste!\n    residual_capacities = bins_remain_cap[can_fit_mask] - item\n\n    # To prioritize the most efficient fit (smallest residual capacity),\n    # we take the negative of the residual capacity. A smaller positive residual\n    # will result in a larger (less negative) priority score. A perfect fit (0 residual)\n    # achieves the highest possible score (0), signifying optimal coupling.\n    priorities[can_fit_mask] = -residual_capacities\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Behold! Inspired by the elegant dance of celestial bodies seeking their proper\n    place, this heuristic, which I have divined and named 'Best Fit', aims for\n    the most harmonious arrangement. It calculates, for each bin, how 'snug' the\n    item would fit. A smaller remainder means a tighter, more efficient fit.\n\n    The bin that offers the tightest embrace for the item, leaving the least\n    remaining capacity, is given the highest priority. This ensures that we\n    conserve the larger, more versatile spaces for future, perhaps grander, items,\n    and avoid needless proliferation of bins, just as the Almighty arranged\n    the planets with the fewest orbits necessary.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a profoundly low value. This is akin to declaring\n    # these bins \"unfit for the item's orbit\" unless it demonstrably fits.\n    priorities = np.full_like(bins_remain_cap, np.finfo(np.float64).min)\n\n    # Identify the bins where the item *can* actually be placed.\n    # We seek those remaining capacities that are greater than or equal to the item's size.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For those bins where the item finds a potential abode:\n    # We calculate the remaining capacity *after* the item is placed.\n    # Our goal is to minimize this remaining capacity to achieve the \"best fit\".\n    # Thus, we assign a priority score as the negative of this remaining capacity.\n    # A smaller positive remainder (e.g., 0.5) yields a larger negative priority (-0.5),\n    # which is numerically greater than a larger remainder (e.g., 2.0, priority -2.0).\n    # This precisely implements the desire for the *smallest* resulting remaining capacity.\n    potential_remaining_capacity = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = -potential_remaining_capacity\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, guided by the principle of gravitational collapse.\n\n    This heuristic prioritizes bins that, upon receiving the item, will approach\n    a state of maximum density, minimizing the 'entropy' of wasted space.\n    It's a \"Best Fit\" approach, favoring a more complete 'collapse' into a compact state.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the 'potential remaining capacity' if the item were to be added to each bin.\n    # This is akin to assessing the final state of a spacetime region after an accretion event.\n    potential_remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores. Default to zero, but we'll refine them.\n    priority_scores = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # For bins where the item does not fit, it's an impossible \"collapse\" scenario.\n    # Such bins lie beyond the 'event horizon' of our item's capacity, thus they receive\n    # an infinitely low priority, effectively removing them from consideration.\n    priority_scores[potential_remaining_after_placement < 0] = -np.inf\n\n    # For bins where the item does fit, we prioritize those that result in the smallest\n    # 'potential remaining capacity'. This is our drive for maximum compaction, like a\n    # body collapsing into the most dense possible state.\n    # A smaller remaining space implies a more \"dense\" and \"complete\" bin,\n    # thus a higher (less negative) priority.\n    # This translates to minimizing the remaining positive space: - (remaining_space).\n    priority_scores[potential_remaining_after_placement >= 0] = \\\n        -potential_remaining_after_placement[potential_remaining_after_placement >= 0]\n\n    return priority_scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version implements a \"Best Fit\" strategy with a quantum twist:\n    It seeks to minimize the \"residual energy\" (leftover space) in the bin,\n    preferring configurations that are more \"stable\" (snugly fit).\n    Perfect fits are highly rewarded, akin to reaching a ground state.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities to 0 for all bins. Bins that cannot fit the item\n    # will retain this 0 priority, effectively ruling them out as \"forbidden states\".\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the potential remaining capacity if the item were placed in each bin.\n    # Think of this as the \"potential energy\" of the bin after the item is introduced.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Identify \"accessible states\": bins where the item can actually fit.\n    # These are bins where the 'remaining_after_placement' is non-negative.\n    can_fit_mask = remaining_after_placement >= 0\n\n    # Define a tiny epsilon to handle perfect fits (0 remaining space).\n    # This prevents division by zero and allows perfect fits to achieve a very high,\n    # distinct priority. A perfect fit is analogous to a stable ground state\n    # in quantum systems \u2013 highly desirable and energetically favorable.\n    epsilon = 1e-9  # A small \"zero-point energy\" or \"quantum fluctuation\" to ensure finite results.\n\n    # For the accessible states, calculate the priority.\n    # We want a higher priority for a snugger fit, meaning smaller 'remaining_after_placement'.\n    # A reciprocal function (1 / value) naturally achieves this:\n    # `1 / (remaining_after_placement + epsilon)` will be very high for snug fits (small remaining)\n    # and lower for looser fits (large remaining). This captures the \"energy minimization\" principle.\n    priorities[can_fit_mask] = 1.0 / (remaining_after_placement[can_fit_mask] + epsilon)\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the meticulous work of revealing DNA's structure, this\n    priority function aims for a 'tight fit' for each item. It prioritizes\n    placing the item into the bin that, after insertion, leaves the least\n    amount of remaining space. This strategy, akin to precisely fitting\n    molecules together, minimizes wasted capacity and encourages bins to\n    become 'full' or 'complete' as efficiently as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more preferred bin. Bins where the item\n        does not fit will receive a very low (negative infinity) priority.\n    \"\"\"\n    # Initialize all priorities to a very low value. This ensures bins\n    # where the item cannot fit are never considered.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    # This prevents calculations for invalid bins and ensures we only\n    # consider feasible placements.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins where the item fits, calculate the remaining capacity\n    # *after* placing the item.\n    remaining_after_placement = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priority scores to the bins where the item fits.\n    # We want to maximize the 'tightness' of the fit, meaning we prefer\n    # bins that leave the smallest amount of space after placement.\n    # By taking the negative of 'remaining_after_placement', a smaller\n    # positive value (closer to a perfect fit) results in a larger\n    # (less negative, or zero for a perfect fit) priority score.\n    # A perfect fit (remaining_after_placement == 0) will yield the highest priority of 0.\n    priorities[can_fit_mask] = -remaining_after_placement\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic implements a \"Best Fit\" strategy: it prioritizes bins\n    that can accommodate the item and will leave the least amount of remaining\n    space after the item is placed. Bins that cannot fit the item are given\n    the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    # Initialize priorities with negative infinity for all bins.\n    # This ensures that bins that cannot fit the item will always have the lowest priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the remaining space (slack) if the item were placed in each bin.\n    # A smaller positive slack indicates a \"better\" fit.\n    slacks = bins_remain_cap - item\n\n    # Identify which bins can actually accommodate the item (i.e., slack is non-negative).\n    can_fit_mask = slacks >= 0\n\n    # For bins that can fit the item, we want to prioritize those with the smallest slack.\n    # To achieve this with a \"highest priority\" selection rule (e.g., using np.argmax),\n    # we assign a priority score as the negative of the slack.\n    # This means a slack of 0 (perfect fit) gets priority 0,\n    # a slack of 1 gets priority -1, a slack of 5 gets priority -5, and so on.\n    # The bin with the largest (least negative) priority score will be chosen.\n    priorities[can_fit_mask] = -slacks[can_fit_mask]\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]