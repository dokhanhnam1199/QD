```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and depot proximity.

    Args:
        distance_matrix: Distance between nodes (n x n).
        coordinates: Node coordinates (n x 2).
        demands: Node demands (n).
        capacity: Vehicle capacity.

    Returns:
        A heuristic matrix (n x n) indicating the desirability of each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Heuristic 1: Inverse distance (as before)
    heuristic_matrix = 1 / (distance_matrix + 1e-9)  # Adding a small value to avoid division by zero

    # Heuristic 2: Demand consideration
    demand_penalty = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != 0 and j != 0: # Not for depot-depot edges. Otherwise, could become too small.
              demand_penalty[i, j] = (demands[i] + demands[j]) / (2 * capacity) if i !=j else demands[i] / capacity
              demand_penalty[i, j] = np.clip(demand_penalty[i, j], 0, 1) #Keep it between 0 and 1 to prevent blow up effect.
            else:
              demand_penalty[i, j] = 0

    heuristic_matrix = heuristic_matrix * (1 - demand_penalty) # Reduce desirability for edges connecting high demand nodes.

    # Heuristic 3: Depot proximity (encourage going back to depot if a node is far from depot)
    depot_distance_penalty = np.zeros((n, n))

    max_depot_dist = np.max(distance_matrix[0,:]) #Get max distance from depot to a customer

    for i in range(n):
        for j in range(n):

            depot_dist_i = distance_matrix[0, i] / max_depot_dist if max_depot_dist > 0 else 0 # Normalize to 0-1 range
            depot_dist_j = distance_matrix[0, j] / max_depot_dist if max_depot_dist > 0 else 0 # Normalize to 0-1 range


            depot_distance_penalty[i, j] = 0.5 * (depot_dist_i + depot_dist_j) #Average distance of the two nodes from the depot.
            depot_distance_penalty[i, j] = np.clip(depot_distance_penalty[i, j], 0, 1) #Limit the range to prevent blow-up

    heuristic_matrix = heuristic_matrix * (1 - 0.3 * depot_distance_penalty) # Further reduces desirability if BOTH nodes far from depot (weighted)

    # Heuristic 4: Node clustering
    # No clustering technique here, as it require additional functions and might not fit the basic heuristics framework.

    return heuristic_matrix
```
