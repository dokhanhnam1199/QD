```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    CVRP heuristic: Combines distance, demand, depot proximity, and angle.
    Sparsifies by setting low-probability edges to zero.
    """
    n_nodes = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Node Proximity to Depot
    depot_distances = distance_matrix[0, :]
    normalized_depot_distances = depot_distances / np.max(depot_distances) if np.max(depot_distances)>0 else np.zeros_like(depot_distances)
    
    # Demand Considerations
    normalized_demands = demands / capacity
    
    # Angle from Depot (prioritizes routes spreading out)
    depot_angles = np.zeros(n_nodes)
    for i in range(1, n_nodes):
        dx = coordinates[i, 0] - coordinates[0, 0]
        dy = coordinates[i, 1] - coordinates[0, 1]
        depot_angles[i] = np.arctan2(dy, dx)

    for i in range(n_nodes):
        for j in range(n_nodes):
            if i == j:
                continue

            distance = distance_matrix[i, j]
            if distance == 0:
                continue

            # Angle Difference (Encourage smoother turns, penalize sharp turns)
            angle_diff = abs(depot_angles[i] - depot_angles[j])
            angle_diff = min(angle_diff, 2 * np.pi - angle_diff)  # Ensure it's the smaller angle
            normalized_angle_diff = angle_diff / np.pi

            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angle_diff)

            heuristic_matrix[i, j] = heuristic_value

    # Sparsify the matrix using a more adaptive threshold
    mean_heuristic = np.mean(heuristic_matrix[heuristic_matrix > 0]) if np.any(heuristic_matrix > 0) else 0
    std_heuristic = np.std(heuristic_matrix[heuristic_matrix > 0]) if np.any(heuristic_matrix > 0) else 0

    threshold = mean_heuristic - 0.5 * std_heuristic  # Adaptive threshold based on distribution.  Reduced coefficient to allow more edges through.
    heuristic_matrix[heuristic_matrix < threshold] = 0 #set low probability edges to 0.

    return heuristic_matrix
```
