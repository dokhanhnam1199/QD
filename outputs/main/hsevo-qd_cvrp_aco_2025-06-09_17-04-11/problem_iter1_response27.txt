```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) based on distance,
    demand, and "pheromones" inspired by ant colony optimization.

    This version considers:
    1. Inverse distance: Closer nodes are preferred.
    2. Demand consideration: Edges connecting nodes with high demands
       relative to capacity are penalized, especially when linking from the depot.
    3. "Pheromone" trail: Simulate previous solutions' desirability via edge weight.

    Args:
        distance_matrix: Distance between nodes (n x n).
        coordinates: Node coordinates (n x 2).
        demands: Node demands (n).
        capacity: Vehicle capacity.

    Returns:
        Edge desirability matrix (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # 1. Inverse distance (Attractiveness)
    attractiveness = 1 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero

    # 2. Demand Penalty
    demand_penalty = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == 0:  # Penalize routes directly from the depot if they have large demands
                demand_penalty[i, j] = max(0.1, 1 - demands[j] / capacity)
            else: # Lighter penality for edges not starting from depot
                demand_penalty[i,j] = max(0.5, 1 - demands[j] / capacity / 2)

    # 3. Node proximity score (encourages connecting spatially clustered nodes)
    proximity_score = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                # Calculate average demand of neighbors of node j
                neighbor_demands = []
                for k in range(n):
                    if k != j and k != i and distance_matrix[j, k] < np.mean(distance_matrix):  # Consider relatively close neighbors only
                        neighbor_demands.append(demands[k])

                avg_neighbor_demand = np.mean(neighbor_demands) if neighbor_demands else 0

                # Give higher scores for neighbors of j with larger demands
                proximity_score[i, j] = 1 + (avg_neighbor_demand / capacity) * 0.5 # Normalize by capacity
            else:
                proximity_score[i,j] = 0 # To avoid any self connection in edge prob

    # Combine the factors
    heuristic_matrix = attractiveness * demand_penalty * proximity_score
    np.fill_diagonal(heuristic_matrix, 0)  # No self-loops

    return heuristic_matrix
```
