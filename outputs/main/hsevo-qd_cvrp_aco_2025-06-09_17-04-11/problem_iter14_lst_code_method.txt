{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, angle,\n    adaptive sparsification, and diversity to assess edge importance.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)\n\n    # Demand Considerations\n    normalized_demands = demands / capacity\n\n    # Angle to Depot\n    angles = np.zeros((n_nodes, n_nodes))\n    for i in range(1, n_nodes):\n        for j in range(1, n_nodes):\n            if i != j:\n                vec_i = coordinates[i] - coordinates[0]\n                vec_j = coordinates[j] - coordinates[0]\n\n                norm_i = np.linalg.norm(vec_i)\n                norm_j = np.linalg.norm(vec_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)\n                    angles[i, j] = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                else:\n                    angles[i, j] = np.pi\n    normalized_angles = angles / np.pi\n\n    # Edge Importance (Adaptive Sparsification)\n    edge_importance = np.zeros_like(distance_matrix)\n\n    # Edge Diversity Encouragement\n    diversity_bonus = np.ones_like(distance_matrix)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angles[i,j])\n\n            heuristic_matrix[i, j] = heuristic_value\n            edge_importance[i, j] = (1 / distance) * (demands[i] + demands[j])\n\n            # Edge Diversity: Penalize edges that are too similar to other high-value edges\n            # This can be improved with more sophisticated edge feature comparisons.\n            for k in range(1, n_nodes):\n                if k != i and k!=j:\n                    similarity = np.exp(-0.5 * ((distance_matrix[i,j] - distance_matrix[i,k])**2 + (distance_matrix[j,i] - distance_matrix[k,i])**2)) # Simplified distance similarity\n                    diversity_bonus[i,j] *= (1-0.1 * similarity) # Reduce bonus if too similar to other edges related to node i\n\n    # Adaptive Sparsification\n    mean_importance = np.mean(edge_importance[edge_importance > 0])\n    std_importance = np.std(edge_importance[edge_importance > 0])\n\n    threshold = mean_importance - 0.5 * std_importance\n\n    heuristic_matrix[edge_importance < threshold] = 0\n\n    # Additional Sparsification based on heuristic value itself\n    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1\n    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0\n\n    heuristic_matrix = heuristic_matrix * diversity_bonus #Apply diversity bonus\n\n    return heuristic_matrix\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, angle,\n    adaptive sparsification, and diversity to assess edge importance.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)\n\n    # Demand Considerations\n    normalized_demands = demands / capacity\n\n    # Angle to Depot\n    angles = np.zeros((n_nodes, n_nodes))\n    for i in range(1, n_nodes):\n        for j in range(1, n_nodes):\n            if i != j:\n                vec_i = coordinates[i] - coordinates[0]\n                vec_j = coordinates[j] - coordinates[0]\n\n                norm_i = np.linalg.norm(vec_i)\n                norm_j = np.linalg.norm(vec_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)\n                    angles[i, j] = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                else:\n                    angles[i, j] = np.pi\n    normalized_angles = angles / np.pi\n\n    # Edge Importance (Adaptive Sparsification)\n    edge_importance = np.zeros_like(distance_matrix)\n\n    # Edge Diversity Encouragement\n    diversity_bonus = np.ones_like(distance_matrix)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angles[i,j])\n\n            heuristic_matrix[i, j] = heuristic_value\n            edge_importance[i, j] = (1 / distance) * (demands[i] + demands[j])\n\n            # Edge Diversity: Penalize edges that are too similar to other high-value edges\n            # This can be improved with more sophisticated edge feature comparisons.\n            for k in range(1, n_nodes):\n                if k != i and k!=j:\n                    similarity = np.exp(-0.5 * ((distance_matrix[i,j] - distance_matrix[i,k])**2 + (distance_matrix[j,i] - distance_matrix[k,i])**2)) # Simplified distance similarity\n                    diversity_bonus[i,j] *= (1-0.1 * similarity) # Reduce bonus if too similar to other edges related to node i\n\n    # Adaptive Sparsification\n    mean_importance = np.mean(edge_importance[edge_importance > 0])\n    std_importance = np.std(edge_importance[edge_importance > 0])\n\n    threshold = mean_importance - 0.5 * std_importance\n\n    heuristic_matrix[edge_importance < threshold] = 0\n\n    # Additional Sparsification based on heuristic value itself\n    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1\n    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0\n\n    heuristic_matrix = heuristic_matrix * diversity_bonus #Apply diversity bonus\n\n    return heuristic_matrix\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, angle,\n    customer clustering, adaptive sparsification based on edge importance,\n    and edge diversity encouragement.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)\n\n    # Demand Considerations\n    normalized_demands = demands / capacity\n\n    # Angle to Depot\n    angles = np.zeros((n_nodes, n_nodes))\n    for i in range(1, n_nodes):\n        for j in range(1, n_nodes):\n            if i != j:\n                vec_i = coordinates[i] - coordinates[0]\n                vec_j = coordinates[j] - coordinates[0]\n\n                norm_i = np.linalg.norm(vec_i)\n                norm_j = np.linalg.norm(vec_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)\n                    angles[i, j] = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                else:\n                    angles[i, j] = np.pi\n    normalized_angles = angles / np.pi\n\n    # Customer Clustering (Simplified - can be enhanced)\n    cluster_assignments = np.zeros(n_nodes, dtype=int)\n    num_clusters = min(4, int(np.ceil(np.sum(demands) / capacity))) # Aim for a few clusters based on total demand\n\n    if num_clusters > 1:\n        angles_to_depot = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n        angles_to_depot = (angles_to_depot + np.pi) % (2 * np.pi)  # Normalize to 0-2pi\n        angle_increments = np.linspace(0, 2 * np.pi, num_clusters + 1)\n\n        for i in range(1, n_nodes):\n            for k in range(num_clusters):\n                if angle_increments[k] <= angles_to_depot[i-1] < angle_increments[k+1]:\n                    cluster_assignments[i] = k\n\n    # Edge Importance (Adaptive Sparsification)\n    edge_importance = np.zeros_like(distance_matrix)\n\n    # Edge Diversity Encouragement\n    diversity_bonus = np.ones_like(distance_matrix)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            # Cluster Awareness: Favor edges within the same cluster\n            cluster_bonus = 1.0\n            if num_clusters > 1 and cluster_assignments[i] != 0 and cluster_assignments[j] != 0 and cluster_assignments[i] == cluster_assignments[j]:\n                cluster_bonus = 1.2  # Increase weight if nodes are in the same cluster\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angles[i,j]) * cluster_bonus\n\n            heuristic_matrix[i, j] = heuristic_value\n            edge_importance[i, j] = (1 / distance) * (demands[i] + demands[j])\n\n            # Edge Diversity: Penalize edges that are too similar to other high-value edges\n            # This can be improved with more sophisticated edge feature comparisons.\n            for k in range(1, n_nodes):\n                if k != i and k!=j:\n                    similarity = np.exp(-0.5 * ((distance_matrix[i,j] - distance_matrix[i,k])**2 + (distance_matrix[j,i] - distance_matrix[k,i])**2)) # Simplified distance similarity\n                    diversity_bonus[i,j] *= (1-0.1 * similarity) # Reduce bonus if too similar to other edges related to node i\n\n    # Adaptive Sparsification\n    mean_importance = np.mean(edge_importance[edge_importance > 0])\n    std_importance = np.std(edge_importance[edge_importance > 0])\n\n    threshold = mean_importance - 0.5 * std_importance\n\n    heuristic_matrix[edge_importance < threshold] = 0\n\n    # Additional Sparsification based on heuristic value itself\n    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1\n    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0\n\n    heuristic_matrix = heuristic_matrix * diversity_bonus #Apply diversity bonus\n\n    return heuristic_matrix\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, angle,\n    customer clustering, adaptive sparsification based on edge importance,\n    and edge diversity encouragement.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)\n\n    # Demand Considerations\n    normalized_demands = demands / capacity\n\n    # Angle to Depot\n    angles = np.zeros((n_nodes, n_nodes))\n    for i in range(1, n_nodes):\n        for j in range(1, n_nodes):\n            if i != j:\n                vec_i = coordinates[i] - coordinates[0]\n                vec_j = coordinates[j] - coordinates[0]\n\n                norm_i = np.linalg.norm(vec_i)\n                norm_j = np.linalg.norm(vec_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)\n                    angles[i, j] = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                else:\n                    angles[i, j] = np.pi\n    normalized_angles = angles / np.pi\n\n    # Customer Clustering (Simplified - can be enhanced)\n    cluster_assignments = np.zeros(n_nodes, dtype=int)\n    num_clusters = min(4, int(np.ceil(np.sum(demands) / capacity))) # Aim for a few clusters based on total demand\n\n    if num_clusters > 1:\n        angles_to_depot = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n        angles_to_depot = (angles_to_depot + np.pi) % (2 * np.pi)  # Normalize to 0-2pi\n        angle_increments = np.linspace(0, 2 * np.pi, num_clusters + 1)\n\n        for i in range(1, n_nodes):\n            for k in range(num_clusters):\n                if angle_increments[k] <= angles_to_depot[i-1] < angle_increments[k+1]:\n                    cluster_assignments[i] = k\n\n    # Edge Importance (Adaptive Sparsification)\n    edge_importance = np.zeros_like(distance_matrix)\n\n    # Edge Diversity Encouragement\n    diversity_bonus = np.ones_like(distance_matrix)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            # Cluster Awareness: Favor edges within the same cluster\n            cluster_bonus = 1.0\n            if num_clusters > 1 and cluster_assignments[i] != 0 and cluster_assignments[j] != 0 and cluster_assignments[i] == cluster_assignments[j]:\n                cluster_bonus = 1.2  # Increase weight if nodes are in the same cluster\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angles[i,j]) * cluster_bonus\n\n            heuristic_matrix[i, j] = heuristic_value\n            edge_importance[i, j] = (1 / distance) * (demands[i] + demands[j])\n\n            # Edge Diversity: Penalize edges that are too similar to other high-value edges\n            # This can be improved with more sophisticated edge feature comparisons.\n            for k in range(1, n_nodes):\n                if k != i and k!=j:\n                    similarity = np.exp(-0.5 * ((distance_matrix[i,j] - distance_matrix[i,k])**2 + (distance_matrix[j,i] - distance_matrix[k,i])**2)) # Simplified distance similarity\n                    diversity_bonus[i,j] *= (1-0.1 * similarity) # Reduce bonus if too similar to other edges related to node i\n\n    # Adaptive Sparsification\n    mean_importance = np.mean(edge_importance[edge_importance > 0])\n    std_importance = np.std(edge_importance[edge_importance > 0])\n\n    threshold = mean_importance - 0.5 * std_importance\n\n    heuristic_matrix[edge_importance < threshold] = 0\n\n    # Additional Sparsification based on heuristic value itself\n    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1\n    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0\n\n    heuristic_matrix = heuristic_matrix * diversity_bonus #Apply diversity bonus\n\n    return heuristic_matrix\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, angle,\n    customer clustering, adaptive sparsification based on edge importance,\n    and edge diversity encouragement.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)\n\n    # Demand Considerations\n    normalized_demands = demands / capacity\n\n    # Angle to Depot\n    angles = np.zeros((n_nodes, n_nodes))\n    for i in range(1, n_nodes):\n        for j in range(1, n_nodes):\n            if i != j:\n                vec_i = coordinates[i] - coordinates[0]\n                vec_j = coordinates[j] - coordinates[0]\n\n                norm_i = np.linalg.norm(vec_i)\n                norm_j = np.linalg.norm(vec_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)\n                    angles[i, j] = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                else:\n                    angles[i, j] = np.pi\n    normalized_angles = angles / np.pi\n\n    # Customer Clustering (Simplified - can be enhanced)\n    cluster_assignments = np.zeros(n_nodes, dtype=int)\n    num_clusters = min(4, int(np.ceil(np.sum(demands) / capacity))) # Aim for a few clusters based on total demand\n\n    if num_clusters > 1:\n        angles_to_depot = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n        angles_to_depot = (angles_to_depot + np.pi) % (2 * np.pi)  # Normalize to 0-2pi\n        angle_increments = np.linspace(0, 2 * np.pi, num_clusters + 1)\n\n        for i in range(1, n_nodes):\n            for k in range(num_clusters):\n                if angle_increments[k] <= angles_to_depot[i-1] < angle_increments[k+1]:\n                    cluster_assignments[i] = k\n\n    # Edge Importance (Adaptive Sparsification)\n    edge_importance = np.zeros_like(distance_matrix)\n\n    # Edge Diversity Encouragement\n    diversity_bonus = np.ones_like(distance_matrix)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            # Cluster Awareness: Favor edges within the same cluster\n            cluster_bonus = 1.0\n            if num_clusters > 1 and cluster_assignments[i] != 0 and cluster_assignments[j] != 0 and cluster_assignments[i] == cluster_assignments[j]:\n                cluster_bonus = 1.2  # Increase weight if nodes are in the same cluster\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angles[i,j]) * cluster_bonus\n\n            heuristic_matrix[i, j] = heuristic_value\n            edge_importance[i, j] = (1 / distance) * (demands[i] + demands[j])\n\n            # Edge Diversity: Penalize edges that are too similar to other high-value edges\n            # This can be improved with more sophisticated edge feature comparisons.\n            for k in range(1, n_nodes):\n                if k != i and k!=j:\n                    similarity = np.exp(-0.5 * ((distance_matrix[i,j] - distance_matrix[i,k])**2 + (distance_matrix[j,i] - distance_matrix[k,i])**2)) # Simplified distance similarity\n                    diversity_bonus[i,j] *= (1-0.1 * similarity) # Reduce bonus if too similar to other edges related to node i\n\n    # Adaptive Sparsification\n    mean_importance = np.mean(edge_importance[edge_importance > 0])\n    std_importance = np.std(edge_importance[edge_importance > 0])\n\n    threshold = mean_importance - 0.5 * std_importance\n\n    heuristic_matrix[edge_importance < threshold] = 0\n\n    # Additional Sparsification based on heuristic value itself\n    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1\n    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0\n\n    heuristic_matrix = heuristic_matrix * diversity_bonus #Apply diversity bonus\n\n    return heuristic_matrix\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, angle,\n    adaptive sparsification, edge diversity, and clustering to assess edge importance.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)\n\n    # Demand Considerations\n    normalized_demands = demands / capacity\n\n    # Angle to Depot\n    angles = np.zeros((n_nodes, n_nodes))\n    for i in range(1, n_nodes):\n        for j in range(1, n_nodes):\n            if i != j:\n                vec_i = coordinates[i] - coordinates[0]\n                vec_j = coordinates[j] - coordinates[0]\n\n                norm_i = np.linalg.norm(vec_i)\n                norm_j = np.linalg.norm(vec_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)\n                    angles[i, j] = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                else:\n                    angles[i, j] = np.pi\n    normalized_angles = angles / np.pi\n\n    # Clustering (Simple k-means for initialization - can be improved)\n    from sklearn.cluster import KMeans\n    kmeans = KMeans(n_clusters=int(np.sqrt(n_nodes)), random_state=0, n_init = 'auto').fit(coordinates[1:])  # Exclude depot from clustering\n    cluster_labels = np.concatenate(([0], kmeans.labels_ + 1))  # Depot assigned to cluster 0\n\n    # Edge Importance (Adaptive Sparsification)\n    edge_importance = np.zeros_like(distance_matrix)\n\n    # Edge Diversity Encouragement\n    diversity_bonus = np.ones_like(distance_matrix)\n\n    # Cluster connection prior\n    cluster_connection_bonus = np.zeros_like(distance_matrix)\n    for i in range(n_nodes):\n      for j in range(n_nodes):\n        if i != j:\n          if cluster_labels[i] == cluster_labels[j] and cluster_labels[i] != 0:\n            cluster_connection_bonus[i,j] = 0.2 #Increase the likelihood of selecting edge in same cluster.\n          elif cluster_labels[i] != cluster_labels[j]:\n            cluster_connection_bonus[i,j] = 0.1 #Decrease likelihood of selecting edge connecting nodes across clusters\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angles[i,j])\n\n            heuristic_matrix[i, j] = heuristic_value\n            edge_importance[i, j] = (1 / distance) * (demands[i] + demands[j])\n\n            # Edge Diversity: Penalize edges that are too similar to other high-value edges\n            # This can be improved with more sophisticated edge feature comparisons.\n            for k in range(1, n_nodes):\n                if k != i and k!=j:\n                    similarity = np.exp(-0.5 * ((distance_matrix[i,j] - distance_matrix[i,k])**2 + (distance_matrix[j,i] - distance_matrix[k,i])**2)) # Simplified distance similarity\n                    diversity_bonus[i,j] *= (1-0.1 * similarity) # Reduce bonus if too similar to other edges related to node i\n\n    # Adaptive Sparsification\n    mean_importance = np.mean(edge_importance[edge_importance > 0])\n    std_importance = np.std(edge_importance[edge_importance > 0])\n\n    threshold = mean_importance - 0.5 * std_importance\n\n    heuristic_matrix[edge_importance < threshold] = 0\n\n    # Additional Sparsification based on heuristic value itself\n    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1\n    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0\n\n    heuristic_matrix = heuristic_matrix * diversity_bonus #Apply diversity bonus\n    heuristic_matrix = heuristic_matrix * (1+cluster_connection_bonus) #Apply cluster connection bonus\n\n    return heuristic_matrix\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, angle,\n    adaptive sparsification, edge diversity, and clustering to assess edge importance.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)\n\n    # Demand Considerations\n    normalized_demands = demands / capacity\n\n    # Angle to Depot\n    angles = np.zeros((n_nodes, n_nodes))\n    for i in range(1, n_nodes):\n        for j in range(1, n_nodes):\n            if i != j:\n                vec_i = coordinates[i] - coordinates[0]\n                vec_j = coordinates[j] - coordinates[0]\n\n                norm_i = np.linalg.norm(vec_i)\n                norm_j = np.linalg.norm(vec_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)\n                    angles[i, j] = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                else:\n                    angles[i, j] = np.pi\n    normalized_angles = angles / np.pi\n\n    # Clustering (Simple k-means for initialization - can be improved)\n    from sklearn.cluster import KMeans\n    kmeans = KMeans(n_clusters=int(np.sqrt(n_nodes)), random_state=0, n_init = 'auto').fit(coordinates[1:])  # Exclude depot from clustering\n    cluster_labels = np.concatenate(([0], kmeans.labels_ + 1))  # Depot assigned to cluster 0\n\n    # Edge Importance (Adaptive Sparsification)\n    edge_importance = np.zeros_like(distance_matrix)\n\n    # Edge Diversity Encouragement\n    diversity_bonus = np.ones_like(distance_matrix)\n\n    # Cluster connection prior\n    cluster_connection_bonus = np.zeros_like(distance_matrix)\n    for i in range(n_nodes):\n      for j in range(n_nodes):\n        if i != j:\n          if cluster_labels[i] == cluster_labels[j] and cluster_labels[i] != 0:\n            cluster_connection_bonus[i,j] = 0.2 #Increase the likelihood of selecting edge in same cluster.\n          elif cluster_labels[i] != cluster_labels[j]:\n            cluster_connection_bonus[i,j] = 0.1 #Decrease likelihood of selecting edge connecting nodes across clusters\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angles[i,j])\n\n            heuristic_matrix[i, j] = heuristic_value\n            edge_importance[i, j] = (1 / distance) * (demands[i] + demands[j])\n\n            # Edge Diversity: Penalize edges that are too similar to other high-value edges\n            # This can be improved with more sophisticated edge feature comparisons.\n            for k in range(1, n_nodes):\n                if k != i and k!=j:\n                    similarity = np.exp(-0.5 * ((distance_matrix[i,j] - distance_matrix[i,k])**2 + (distance_matrix[j,i] - distance_matrix[k,i])**2)) # Simplified distance similarity\n                    diversity_bonus[i,j] *= (1-0.1 * similarity) # Reduce bonus if too similar to other edges related to node i\n\n    # Adaptive Sparsification\n    mean_importance = np.mean(edge_importance[edge_importance > 0])\n    std_importance = np.std(edge_importance[edge_importance > 0])\n\n    threshold = mean_importance - 0.5 * std_importance\n\n    heuristic_matrix[edge_importance < threshold] = 0\n\n    # Additional Sparsification based on heuristic value itself\n    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1\n    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0\n\n    heuristic_matrix = heuristic_matrix * diversity_bonus #Apply diversity bonus\n    heuristic_matrix = heuristic_matrix * (1+cluster_connection_bonus) #Apply cluster connection bonus\n\n    return heuristic_matrix\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, angle,\n    and adaptive sparsification based on edge importance. Includes customer clustering\n    based on demand and location relative to the depot to focus search.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)\n\n    # Demand Considerations\n    normalized_demands = demands / capacity\n\n    # Angle to Depot\n    angles = np.zeros((n_nodes, n_nodes))\n    for i in range(1, n_nodes):\n        for j in range(1, n_nodes):\n            if i != j:\n                vec_i = coordinates[i] - coordinates[0]\n                vec_j = coordinates[j] - coordinates[0]\n\n                norm_i = np.linalg.norm(vec_i)\n                norm_j = np.linalg.norm(vec_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)\n                    angles[i, j] = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                else:\n                    angles[i, j] = np.pi\n    normalized_angles = angles / np.pi\n\n    # Customer Clustering (Simplified - can be enhanced)\n    # Assign customers to \"clusters\" based on demand and angular position\n    cluster_assignments = np.zeros(n_nodes, dtype=int)\n    num_clusters = min(4, int(np.ceil(np.sum(demands) / capacity))) # Aim for a few clusters based on total demand\n\n    if num_clusters > 1:\n        angles_to_depot = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n        angles_to_depot = (angles_to_depot + np.pi) % (2 * np.pi)  # Normalize to 0-2pi\n        angle_increments = np.linspace(0, 2 * np.pi, num_clusters + 1)\n\n        for i in range(1, n_nodes):\n            for k in range(num_clusters):\n                if angle_increments[k] <= angles_to_depot[i-1] < angle_increments[k+1]:\n                    cluster_assignments[i] = k\n\n    # Edge Importance (Adaptive Sparsification)\n    edge_importance = np.zeros_like(distance_matrix)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            # Cluster Awareness: Favor edges within the same cluster\n            cluster_bonus = 1.0\n            if num_clusters > 1 and cluster_assignments[i] != 0 and cluster_assignments[j] != 0 and cluster_assignments[i] == cluster_assignments[j]:\n                cluster_bonus = 1.2  # Increase weight if nodes are in the same cluster\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angles[i,j]) * cluster_bonus\n\n            heuristic_matrix[i, j] = heuristic_value\n            edge_importance[i, j] = (1 / distance) * (demands[i] + demands[j])\n\n    # Adaptive Sparsification\n    mean_importance = np.mean(edge_importance[edge_importance > 0])\n    std_importance = np.std(edge_importance[edge_importance > 0])\n\n    threshold = mean_importance - 0.5 * std_importance\n\n    heuristic_matrix[edge_importance < threshold] = 0\n\n    # Additional Sparsification based on heuristic value itself\n    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1\n    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0\n\n\n    return heuristic_matrix\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, angle,\n    and adaptive sparsification based on edge importance. Includes customer clustering\n    based on demand and location relative to the depot to focus search.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)\n\n    # Demand Considerations\n    normalized_demands = demands / capacity\n\n    # Angle to Depot\n    angles = np.zeros((n_nodes, n_nodes))\n    for i in range(1, n_nodes):\n        for j in range(1, n_nodes):\n            if i != j:\n                vec_i = coordinates[i] - coordinates[0]\n                vec_j = coordinates[j] - coordinates[0]\n\n                norm_i = np.linalg.norm(vec_i)\n                norm_j = np.linalg.norm(vec_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)\n                    angles[i, j] = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                else:\n                    angles[i, j] = np.pi\n    normalized_angles = angles / np.pi\n\n    # Customer Clustering (Simplified - can be enhanced)\n    # Assign customers to \"clusters\" based on demand and angular position\n    cluster_assignments = np.zeros(n_nodes, dtype=int)\n    num_clusters = min(4, int(np.ceil(np.sum(demands) / capacity))) # Aim for a few clusters based on total demand\n\n    if num_clusters > 1:\n        angles_to_depot = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n        angles_to_depot = (angles_to_depot + np.pi) % (2 * np.pi)  # Normalize to 0-2pi\n        angle_increments = np.linspace(0, 2 * np.pi, num_clusters + 1)\n\n        for i in range(1, n_nodes):\n            for k in range(num_clusters):\n                if angle_increments[k] <= angles_to_depot[i-1] < angle_increments[k+1]:\n                    cluster_assignments[i] = k\n\n    # Edge Importance (Adaptive Sparsification)\n    edge_importance = np.zeros_like(distance_matrix)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            # Cluster Awareness: Favor edges within the same cluster\n            cluster_bonus = 1.0\n            if num_clusters > 1 and cluster_assignments[i] != 0 and cluster_assignments[j] != 0 and cluster_assignments[i] == cluster_assignments[j]:\n                cluster_bonus = 1.2  # Increase weight if nodes are in the same cluster\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angles[i,j]) * cluster_bonus\n\n            heuristic_matrix[i, j] = heuristic_value\n            edge_importance[i, j] = (1 / distance) * (demands[i] + demands[j])\n\n    # Adaptive Sparsification\n    mean_importance = np.mean(edge_importance[edge_importance > 0])\n    std_importance = np.std(edge_importance[edge_importance > 0])\n\n    threshold = mean_importance - 0.5 * std_importance\n\n    heuristic_matrix[edge_importance < threshold] = 0\n\n    # Additional Sparsification based on heuristic value itself\n    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1\n    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0\n\n\n    return heuristic_matrix\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, angle,\n    and adaptive sparsification based on edge importance. Includes customer clustering\n    based on demand and location relative to the depot to focus search.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)\n\n    # Demand Considerations\n    normalized_demands = demands / capacity\n\n    # Angle to Depot\n    angles = np.zeros((n_nodes, n_nodes))\n    for i in range(1, n_nodes):\n        for j in range(1, n_nodes):\n            if i != j:\n                vec_i = coordinates[i] - coordinates[0]\n                vec_j = coordinates[j] - coordinates[0]\n\n                norm_i = np.linalg.norm(vec_i)\n                norm_j = np.linalg.norm(vec_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)\n                    angles[i, j] = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                else:\n                    angles[i, j] = np.pi\n    normalized_angles = angles / np.pi\n\n    # Customer Clustering (Simplified - can be enhanced)\n    # Assign customers to \"clusters\" based on demand and angular position\n    cluster_assignments = np.zeros(n_nodes, dtype=int)\n    num_clusters = min(4, int(np.ceil(np.sum(demands) / capacity))) # Aim for a few clusters based on total demand\n\n    if num_clusters > 1:\n        angles_to_depot = np.arctan2(coordinates[1:, 1] - coordinates[0, 1], coordinates[1:, 0] - coordinates[0, 0])\n        angles_to_depot = (angles_to_depot + np.pi) % (2 * np.pi)  # Normalize to 0-2pi\n        angle_increments = np.linspace(0, 2 * np.pi, num_clusters + 1)\n\n        for i in range(1, n_nodes):\n            for k in range(num_clusters):\n                if angle_increments[k] <= angles_to_depot[i-1] < angle_increments[k+1]:\n                    cluster_assignments[i] = k\n\n    # Edge Importance (Adaptive Sparsification)\n    edge_importance = np.zeros_like(distance_matrix)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            # Cluster Awareness: Favor edges within the same cluster\n            cluster_bonus = 1.0\n            if num_clusters > 1 and cluster_assignments[i] != 0 and cluster_assignments[j] != 0 and cluster_assignments[i] == cluster_assignments[j]:\n                cluster_bonus = 1.2  # Increase weight if nodes are in the same cluster\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angles[i,j]) * cluster_bonus\n\n            heuristic_matrix[i, j] = heuristic_value\n            edge_importance[i, j] = (1 / distance) * (demands[i] + demands[j])\n\n    # Adaptive Sparsification\n    mean_importance = np.mean(edge_importance[edge_importance > 0])\n    std_importance = np.std(edge_importance[edge_importance > 0])\n\n    threshold = mean_importance - 0.5 * std_importance\n\n    heuristic_matrix[edge_importance < threshold] = 0\n\n    # Additional Sparsification based on heuristic value itself\n    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1\n    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0\n\n\n    return heuristic_matrix\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, and angle to depot.\n    Sparsifies adaptively based on edge importance and instance characteristics.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot (Prioritized)\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)\n\n    # Demand Considerations (Prioritized)\n    normalized_demands = demands / capacity\n    \n    # Angle to Depot (Encourages radial routes)\n    angles = np.zeros((n_nodes, n_nodes))\n    for i in range(1, n_nodes):\n        for j in range(1, n_nodes):\n            if i != j:\n                vec_i = coordinates[i] - coordinates[0]\n                vec_j = coordinates[j] - coordinates[0]\n                \n                norm_i = np.linalg.norm(vec_i)\n                norm_j = np.linalg.norm(vec_j)\n                \n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)\n                    angles[i, j] = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Clip for numerical stability\n                else:\n                    angles[i, j] = np.pi  # Maximum angle if a node is at the depot\n    normalized_angles = angles / np.pi  # Normalize to [0, 1]\n\n    # Edge Importance (Adaptive Sparsification)\n    edge_importance = np.zeros_like(distance_matrix)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angles[i,j])\n\n            heuristic_matrix[i, j] = heuristic_value\n            edge_importance[i, j] = (1 / distance) * (demands[i] + demands[j])  # Example: inversely proportional to distance, proportional to combined demand\n\n    # Adaptive Sparsification\n    mean_importance = np.mean(edge_importance[edge_importance > 0])\n    std_importance = np.std(edge_importance[edge_importance > 0])\n\n    #Dynamic threshold based on importance\n    threshold = mean_importance - 0.5 * std_importance  # Tune the 0.5 factor based on performance\n\n    heuristic_matrix[edge_importance < threshold] = 0\n    \n    #Further sparsification based on the heuristic value to limit the search space\n    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1\n    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, and angle to depot.\n    Sparsifies adaptively based on edge importance and instance characteristics.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot (Prioritized)\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)\n\n    # Demand Considerations (Prioritized)\n    normalized_demands = demands / capacity\n    \n    # Angle to Depot (Encourages radial routes)\n    angles = np.zeros((n_nodes, n_nodes))\n    for i in range(1, n_nodes):\n        for j in range(1, n_nodes):\n            if i != j:\n                vec_i = coordinates[i] - coordinates[0]\n                vec_j = coordinates[j] - coordinates[0]\n                \n                norm_i = np.linalg.norm(vec_i)\n                norm_j = np.linalg.norm(vec_j)\n                \n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)\n                    angles[i, j] = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Clip for numerical stability\n                else:\n                    angles[i, j] = np.pi  # Maximum angle if a node is at the depot\n    normalized_angles = angles / np.pi  # Normalize to [0, 1]\n\n    # Edge Importance (Adaptive Sparsification)\n    edge_importance = np.zeros_like(distance_matrix)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angles[i,j])\n\n            heuristic_matrix[i, j] = heuristic_value\n            edge_importance[i, j] = (1 / distance) * (demands[i] + demands[j])  # Example: inversely proportional to distance, proportional to combined demand\n\n    # Adaptive Sparsification\n    mean_importance = np.mean(edge_importance[edge_importance > 0])\n    std_importance = np.std(edge_importance[edge_importance > 0])\n\n    #Dynamic threshold based on importance\n    threshold = mean_importance - 0.5 * std_importance  # Tune the 0.5 factor based on performance\n\n    heuristic_matrix[edge_importance < threshold] = 0\n    \n    #Further sparsification based on the heuristic value to limit the search space\n    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1\n    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, and angle to depot.\n    Sparsifies adaptively based on edge importance and instance characteristics.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot (Prioritized)\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)\n\n    # Demand Considerations (Prioritized)\n    normalized_demands = demands / capacity\n    \n    # Angle to Depot (Encourages radial routes)\n    angles = np.zeros((n_nodes, n_nodes))\n    for i in range(1, n_nodes):\n        for j in range(1, n_nodes):\n            if i != j:\n                vec_i = coordinates[i] - coordinates[0]\n                vec_j = coordinates[j] - coordinates[0]\n                \n                norm_i = np.linalg.norm(vec_i)\n                norm_j = np.linalg.norm(vec_j)\n                \n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)\n                    angles[i, j] = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Clip for numerical stability\n                else:\n                    angles[i, j] = np.pi  # Maximum angle if a node is at the depot\n    normalized_angles = angles / np.pi  # Normalize to [0, 1]\n\n    # Edge Importance (Adaptive Sparsification)\n    edge_importance = np.zeros_like(distance_matrix)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angles[i,j])\n\n            heuristic_matrix[i, j] = heuristic_value\n            edge_importance[i, j] = (1 / distance) * (demands[i] + demands[j])  # Example: inversely proportional to distance, proportional to combined demand\n\n    # Adaptive Sparsification\n    mean_importance = np.mean(edge_importance[edge_importance > 0])\n    std_importance = np.std(edge_importance[edge_importance > 0])\n\n    #Dynamic threshold based on importance\n    threshold = mean_importance - 0.5 * std_importance  # Tune the 0.5 factor based on performance\n\n    heuristic_matrix[edge_importance < threshold] = 0\n    \n    #Further sparsification based on the heuristic value to limit the search space\n    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1\n    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity.\n    Sparsifies by setting low-probability edges to zero.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    normalized_depot_distances = depot_distances / np.max(depot_distances) if np.max(depot_distances)>0 else np.zeros_like(depot_distances)\n    \n    # Demand Considerations\n    normalized_demands = demands / capacity\n    \n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j])\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsify the matrix\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1 #Dynamic threshold\n    heuristic_matrix[heuristic_matrix < threshold] = 0 #set low probability edges to 0.\n\n    return heuristic_matrix\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity.\n    Sparsifies by setting low-probability edges to zero.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    normalized_depot_distances = depot_distances / np.max(depot_distances) if np.max(depot_distances)>0 else np.zeros_like(depot_distances)\n    \n    # Demand Considerations\n    normalized_demands = demands / capacity\n    \n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j])\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsify the matrix\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1 #Dynamic threshold\n    heuristic_matrix[heuristic_matrix < threshold] = 0 #set low probability edges to 0.\n\n    return heuristic_matrix\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity.\n    Sparsifies by setting low-probability edges to zero.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    normalized_depot_distances = depot_distances / np.max(depot_distances) if np.max(depot_distances)>0 else np.zeros_like(depot_distances)\n    \n    # Demand Considerations\n    normalized_demands = demands / capacity\n    \n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j])\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsify the matrix\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1 #Dynamic threshold\n    heuristic_matrix[heuristic_matrix < threshold] = 0 #set low probability edges to 0.\n\n    return heuristic_matrix\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity.\n    Sparsifies by setting low-probability edges to zero.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    normalized_depot_distances = depot_distances / np.max(depot_distances) if np.max(depot_distances)>0 else np.zeros_like(depot_distances)\n    \n    # Demand Considerations\n    normalized_demands = demands / capacity\n    \n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j])\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsify the matrix\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1 #Dynamic threshold\n    heuristic_matrix[heuristic_matrix < threshold] = 0 #set low probability edges to 0.\n\n    return heuristic_matrix\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity.\n    Sparsifies by setting low-probability edges to zero.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    normalized_depot_distances = depot_distances / np.max(depot_distances) if np.max(depot_distances)>0 else np.zeros_like(depot_distances)\n    \n    # Demand Considerations\n    normalized_demands = demands / capacity\n    \n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j])\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsify the matrix\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1 #Dynamic threshold\n    heuristic_matrix[heuristic_matrix < threshold] = 0 #set low probability edges to 0.\n\n    return heuristic_matrix\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    return 1 / distance_matrix\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    return 1 / distance_matrix\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}