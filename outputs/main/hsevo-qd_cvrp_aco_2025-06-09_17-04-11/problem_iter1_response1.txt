```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for CVRP based on distance, demand, and angle.

    Args:
        distance_matrix: Distance between nodes (n x n).
        coordinates: Node coordinates (n x 2).
        demands: Node demands (n).
        capacity: Vehicle capacity.

    Returns:
        Heuristic values for each edge (n x n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to tune the heuristic
    alpha = 1.0  # Weight for distance
    beta = 1.0  # Weight for demand
    gamma = 1.0  # Weight for angle

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance component: Encourage shorter distances
                distance_heuristic = alpha / distance_matrix[i, j]

                # Demand component: Penalize edges that would lead to overload
                demand_heuristic = 1.0
                if i != 0 and j != 0:
                    demand_heuristic = np.exp(-beta * (demands[i] + demands[j]) / capacity)  # Reduce probability if going over capacity, exponential decay
                    # Alternative demand consideration: proximity to depot
                    depot_distance_penalty = np.exp(-beta * distance_matrix[i, 0] / np.mean(distance_matrix)) # Penalize paths that bypass the depot unnecessarily after accumulating demand
                    demand_heuristic = demand_heuristic * depot_distance_penalty # Combine demand considerations.

                # Angle component: Penalize sharp turns at the depot. Encourages direct paths
                angle_heuristic = 1.0
                if i == 0 and j!=0:
                  other_nodes = [k for k in range(n) if k!=j and k!=0]
                  angles = []

                  coord_j = coordinates[j]
                  coord_0 = coordinates[0]
                  vec_j0 = coord_0 - coord_j

                  for k in other_nodes:
                    coord_k = coordinates[k]
                    vec_jK = coord_k - coord_j
                    cosine_angle = np.dot(vec_j0, vec_jK) / (np.linalg.norm(vec_j0) * np.linalg.norm(vec_jK) + 1e-9)
                    cosine_angle = np.clip(cosine_angle, -1, 1)  # Ensure within valid range
                    angle = np.arccos(cosine_angle)

                    angles.append(angle)
                  if len(angles) > 0:
                    avg_angle = np.mean(angles)
                    angle_heuristic = np.exp(-gamma * abs(avg_angle - np.pi/2)) # Prefer angles closer to a straight line

                # Combine the heuristics
                heuristic_matrix[i, j] = distance_heuristic * demand_heuristic * angle_heuristic
    return heuristic_matrix
```
