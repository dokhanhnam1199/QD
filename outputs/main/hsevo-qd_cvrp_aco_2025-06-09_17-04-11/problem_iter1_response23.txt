```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and angle from depot.

    This heuristic prioritizes shorter distances, considers demand to prevent exceeding capacity,
    and introduces an angular component to encourage diverse route exploration from the depot.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Edge prior indicators (n x n).
    """

    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Heuristic Parameters (tunable)
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.2  # Increase to explore further initially

    # Angular component - penalize traveling "backwards" from the depot
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics_matrix[i, j] = 0  # No self-loops
                continue

            # Distance component (inverse distance)
            distance_component = 1 / distance_matrix[i, j] if distance_matrix[i, j] > 0 else 0

            # Demand component (penalize edges that quickly lead to over-capacity)
            demand_component = 1.0  # Start with neutral
            #If connecting to/from depot is important, penalize high demand
            if i==0 or j==0:
                demand_component = max(0, 1 - demands[i] / capacity - demands[j] / capacity)
                if demand_component ==0:
                    demand_component = 0.01 #minimum score

            # Angle component (encourages exploration away from the depot initially)
            angle_diff = abs(angles[i] - angles[j]) #small angle difference
            angle_component = np.cos(angle_diff)

            # Combine components
            heuristics_matrix[i, j] = (
                distance_weight * distance_component +
                demand_weight * demand_component +
                angle_weight * (1 - angle_component) # penalize angles closer to zero
            )

    return heuristics_matrix
```
