```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Generates heuristics for the Capacitated Vehicle Routing Problem (CVRP)
    based on a combination of distance, demand, and depot proximity.

    This version incorporates several factors:

    1.  Inverse Distance:  Shorter distances are generally preferred.
    2.  Demand Consideration: Edges connecting to nodes with high demand are penalized (slightly less desirable).
    3.  Depot Proximity: Edges connecting to the depot are encouraged, especially from distant nodes.
    4.  Capacity Scaling: Demand penalization is scaled by remaining capacity of a route if that is known (approx)

    Args:
        distance_matrix:  (n x n) matrix of distances between nodes.
        coordinates:  (n x 2) matrix of (x, y) coordinates for each node.
        demands:  (n) vector of demand for each customer (including depot).
        capacity:  Vehicle capacity.

    Returns:
        A (n x n) matrix of heuristics values.  Higher values indicate a more
        promising edge.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Avoid division by zero
    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)

    # Heuristic component based on inverse distance.
    inverse_distance = 1 / distance_matrix
    heuristics += inverse_distance

    # Demand based heuristic:  Penalize connections to nodes with high demand.
    # Heuristically account for vehicle cap constraints by adjusting demand factor
    demand_factor = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            # Adjust demand factor based on distance from depot, to avoid vehicle overload
            # Close depot gets a scaled value of 1, the farther the distance is, the lower the demand is scaled down.
            # This ensures vehicle near depot does not try to load all of it's capacity to nodes near depot.
            depot_distance_i = distance_matrix[0, i]  # distance from depot to i.
            depot_distance_j = distance_matrix[0, j]  # distance from depot to j.
            avg_depot_distance = (depot_distance_i + depot_distance_j) / 2
            scaling = 1.0 #Default No Scaling

            if avg_depot_distance > 0: # Distance of 0 is bad.
                scaling = max(0.1, 1 - (avg_depot_distance / (np.max(distance_matrix) + 1))) #Scale it Down. MinScaling of 0.1
            demand_factor[i, j] = (demands[i] + demands[j]) * scaling

    heuristics -= demand_factor / capacity # Divide to align with heuristics values

    # Depot heuristic:  Reward connections to and from the depot, particularly for more remote nodes
    for i in range(n):
        if i != 0:  # Don't want to over-emphasize depot -> depot
            heuristics[0, i] += (1 + (np.max(distance_matrix) / (distance_matrix[0, i] + 1))) / (n + 1)
            heuristics[i, 0] += (1 + (np.max(distance_matrix) / (distance_matrix[i, 0] + 1))) / (n+1)

    # Normalize to have values between 0 and 1.  This isn't strictly necessary
    # but can help with interpreting and tuning the heuristics.
    min_val = np.min(heuristics)
    max_val = np.max(heuristics)

    if max_val > min_val:
        heuristics = (heuristics - min_val) / (max_val - min_val)

    return heuristics
```
