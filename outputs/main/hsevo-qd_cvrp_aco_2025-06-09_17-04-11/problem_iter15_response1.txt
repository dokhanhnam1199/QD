```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    CVRP heuristic: Combines distance, demand, depot proximity, angle,
    adaptive sparsification, clustering, and edge diversity, with iterative refinement.
    """
    n_nodes = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Node Proximity to Depot (normalized)
    depot_distances = distance_matrix[0, :]
    max_depot_distance = np.max(depot_distances)
    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)

    # Demand Considerations (normalized)
    normalized_demands = demands / capacity

    # Angle to Depot (normalized) and between nodes
    angles_to_depot = np.zeros((n_nodes))
    angles_between_nodes = np.zeros((n_nodes, n_nodes))

    for i in range(1, n_nodes):
        vec_i = coordinates[i] - coordinates[0]
        angles_to_depot[i] = np.arctan2(vec_i[1], vec_i[0]) + np.pi  # Normalize to 0-2pi

        for j in range(1, n_nodes):
            if i != j:
                vec_j = coordinates[j] - coordinates[0]
                angles_between_nodes[i, j] = np.arctan2(vec_j[1], vec_j[0]) + np.pi

    normalized_angles_to_depot = angles_to_depot / (2 * np.pi)
    normalized_angles_between_nodes = angles_between_nodes / (2 * np.pi)

    # Customer Clustering (K-Means - can be enhanced with other methods)
    num_clusters = min(4, int(np.ceil(np.sum(demands) / capacity))) # Aim for a few clusters based on total demand

    cluster_assignments = np.zeros(n_nodes, dtype=int)
    if num_clusters > 1:
        from sklearn.cluster import KMeans
        kmeans = KMeans(n_clusters=num_clusters, random_state=0, n_init = 'auto') # Explicitly set n_init
        cluster_assignments[1:] = kmeans.fit_predict(coordinates[1:])

    # Edge Importance (Adaptive Sparsification and Demand-Distance Tradeoff)
    edge_importance = np.zeros_like(distance_matrix)

    # Edge Diversity Encouragement (Penalize similar edges more robustly)
    diversity_bonus = np.ones_like(distance_matrix)

    # Adaptive Sparsification parameters
    importance_scaling = 1.0
    heuristic_scaling = 0.5
    diversity_scaling = 0.1


    for i in range(n_nodes):
        for j in range(n_nodes):
            if i == j:
                continue

            distance = distance_matrix[i, j]
            if distance == 0:
                continue

            # Cluster Awareness: Favor edges within the same cluster
            cluster_bonus = 1.0
            if num_clusters > 1 and cluster_assignments[i] != 0 and cluster_assignments[j] != 0 and cluster_assignments[i] == cluster_assignments[j]:
                cluster_bonus = 1.3  # Increase weight if nodes are in the same cluster

            # Combined Heuristic Value (Distance, Demand, Depot Proximity, Angle)
            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - np.abs(normalized_angles_between_nodes[i, j] - normalized_angles_to_depot[i])) * cluster_bonus


            heuristic_matrix[i, j] = heuristic_value
            edge_importance[i, j] = (demands[i] + demands[j]) / distance  # Demand/Distance tradeoff

            # Edge Diversity: Penalize similar edges more strongly.
            for k in range(1, n_nodes):
                if k != i and k != j:
                    similarity = np.exp(-((distance_matrix[i,j] - distance_matrix[i,k])**2 + (distance_matrix[j,i] - distance_matrix[k,i])**2) / (2 * np.mean(distance_matrix)**2 + 1e-6) ) # Gaussian Similarity

                    diversity_bonus[i, j] *= (1 - diversity_scaling * similarity)  # Reduced bonus if too similar to other edges related to node i

    # Adaptive Sparsification
    mean_importance = np.mean(edge_importance[edge_importance > 0])
    std_importance = np.std(edge_importance[edge_importance > 0])

    threshold = mean_importance - importance_scaling * std_importance

    heuristic_matrix[edge_importance < threshold] = 0

    # Additional Sparsification based on heuristic value itself
    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * heuristic_scaling
    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0

    heuristic_matrix = heuristic_matrix * diversity_bonus # Apply diversity bonus
    return heuristic_matrix
```
