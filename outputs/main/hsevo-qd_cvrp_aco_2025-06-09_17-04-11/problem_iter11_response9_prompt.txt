{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\n### Better code\ndef heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, angle,\n    and adaptive sparsification based on edge importance.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)\n\n    # Demand Considerations\n    normalized_demands = demands / capacity\n    \n    # Angle to Depot\n    angles = np.zeros((n_nodes, n_nodes))\n    for i in range(1, n_nodes):\n        for j in range(1, n_nodes):\n            if i != j:\n                vec_i = coordinates[i] - coordinates[0]\n                vec_j = coordinates[j] - coordinates[0]\n                \n                norm_i = np.linalg.norm(vec_i)\n                norm_j = np.linalg.norm(vec_j)\n                \n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)\n                    angles[i, j] = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                else:\n                    angles[i, j] = np.pi\n    normalized_angles = angles / np.pi\n\n    # Edge Importance (Adaptive Sparsification)\n    edge_importance = np.zeros_like(distance_matrix)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angles[i,j])\n\n            heuristic_matrix[i, j] = heuristic_value\n            edge_importance[i, j] = (1 / distance) * (demands[i] + demands[j])\n\n    # Adaptive Sparsification\n    mean_importance = np.mean(edge_importance[edge_importance > 0])\n    std_importance = np.std(edge_importance[edge_importance > 0])\n\n    threshold = mean_importance - 0.5 * std_importance\n\n    heuristic_matrix[edge_importance < threshold] = 0\n    \n    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1\n    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0\n\n    return heuristic_matrix\n\n### Worse code\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity.\n    Sparsifies by setting low-probability edges to zero.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]\n    normalized_depot_distances = depot_distances / np.max(depot_distances) if np.max(depot_distances)>0 else np.zeros_like(depot_distances)\n    \n    # Demand Considerations\n    normalized_demands = demands / capacity\n    \n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j])\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    # Sparsify the matrix\n    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1 #Dynamic threshold\n    heuristic_matrix[heuristic_matrix < threshold] = 0 #set low probability edges to 0.\n\n    return heuristic_matrix\n\n### Analyze & experience\n- *   **Comparing (1st) vs (20th):** The best heuristic incorporates distance, demand, depot proximity, angle, customer clustering, adaptive sparsification, and edge diversity encouragement. The worst one only considers the inverse of the distance matrix.\n*   **Comparing (2nd) vs (19th):** The second-best heuristic is identical to the first, showing redundancy or a lack of diversity in the tested variations at the top. The 19th also just returns the inverse of the distance.\n*   **Comparing (1st) vs (2nd):** They are the same.\n*   **Comparing (3rd) vs (4th):** Heuristic 3 includes edge diversity encouragement, while heuristic 4 does not.\n*   **Comparing (2nd worst) vs (worst):** Both only return the inverse of the distance matrix.\n*   **Overall:** The better heuristics incorporate a wider range of factors, including demand, depot proximity, angles, clustering, and adaptive sparsification, to create a more nuanced evaluation of edge desirability. They also have more sophisticated sparsification methods. The worst heuristics consider only distance.\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, let's redefine \"Current Self-Reflection\" for designing better CVRP heuristics, focusing on actionable advice derived from the given examples, and explicitly avoiding pitfalls:\n\n*   **Keywords:** Multi-factor, adaptive sparsification, iterative refinement, edge diversity, clustering, normalization, edge importance.\n\n*   **Advice:** Design heuristics that combine normalized, multiple relevant factors (distance, demand, depot proximity, angles, location). Implement adaptive sparsification based on learned edge importance.\n\n*   **Avoid:** Relying on single-factor heuristics. Ignoring edge diversity and premature convergence. Overly complex initial designs.\n\n*   **Explanation:** Effective heuristics balance exploitation of promising areas (sparsification) with exploration (edge diversity, multi-factor analysis). Iterative refinement allows for data-driven improvement.\n\n\nYour task is to write an improved function `heuristics_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}