```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Improves upon v1 by incorporating capacity considerations and node proximity.
    Edges connecting nodes that would quickly violate capacity constraints
    are penalized, and edges connecting geographically close, high-demand nodes are favored.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Avoid division by zero by adding a small constant
    distance_matrix = distance_matrix + 1e-9

    # Initialize with inverse distance as in v1
    heuristic_matrix = 1 / distance_matrix

    # Adjust based on demand: Penalize edges leading to rapid capacity exhaustion.
    # Nodes closer to the depot have higher "replenishment" priority.

    depot_distances = distance_matrix[0, :] #distances from the depot to all nodes.

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Capacity considerations: Penalize high-demand edges for nodes far from the depot.
            # This encourages using higher-demand nodes early in routes close to the depot.
            capacity_penalty = (demands[i] + demands[j]) / (2*capacity)  # normalized
            heuristic_matrix[i, j] /= (1 + capacity_penalty * depot_distances[i]) #Penalize based on demand and depot distance

            # Proximity bonus for high-demand nodes
            # Give edges between high-demand, geographically close nodes a bonus.
            geo_proximity = 1 / distance_matrix[i, j] #Higher geo_proximity for smaller distances
            demand_incentive = (demands[i] * demands[j]) / (np.mean(demands[1:])**2 + 1e-6) #Avoid 0 division if all demand is the same. The mean demand from 1: onwards avoids including the depot.
            heuristic_matrix[i, j] *= (1 + geo_proximity * demand_incentive)

    # Further normalization and handling of depot connections
    # Favor direct connections to/from the depot for nodes far from the depot.

    for i in range(1,n): #Iterating from node 1, because the depot does not need adjustments.
        heuristic_matrix[0,i] *= (1 + depot_distances[i]/np.mean(depot_distances[1:])) #Increase the depot weights for more distant nodes.
        heuristic_matrix[i,0] *= (1 + depot_distances[i]/np.mean(depot_distances[1:])) #Increase the depot weights for more distant nodes.

    return heuristic_matrix
```
