```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A more sophisticated heuristic for the Capacitated Vehicle Routing Problem (CVRP).

    This version incorporates:
    1.  Distance: Shorter distances are preferred.
    2.  Demand: Edges connecting to nodes with lower demands are initially favored (encouraging earlier visits).
    3.  Angle: Uses angle to depot to disincentivize sharp turns away from the depot early in a route.
    4. Capacity awareness: Attempts to prevent vehicles exceeding capacity by considering remaining route demand.
    5. Depot proximity after high demand nodes. Edges that move back towards the depot after serving a high demand node are rewarded.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Heuristic values for each edge (n x n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Parameters to tune the heuristics
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.3
    capacity_weight = 0.2
    depot_proximity_weight = 0.4

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # 1. Distance: Basic inverse distance
            distance_heuristic = distance_weight / (distance_matrix[i, j] + 1e-6)  # Adding a small constant to avoid division by zero

            # 2. Demand: Favoring nodes with lower demand initially
            demand_heuristic = 1.0 - (demands[j] / (capacity + 1e-6)) * demand_weight
            demand_heuristic = np.clip(demand_heuristic, 0.1, 1.0)  # Ensure it's within a reasonable range

            # 3. Angle: Discourage sharp turns away from the depot
            # Calculate angle between the vectors i->j and i->depot
            vector_ij = coordinates[j] - coordinates[i]
            vector_i0 = coordinates[0] - coordinates[i]

            norm_ij = np.linalg.norm(vector_ij)
            norm_i0 = np.linalg.norm(vector_i0)

            if norm_ij > 0 and norm_i0 > 0:
                cos_angle = np.dot(vector_ij, vector_i0) / (norm_ij * norm_i0)
                angle_heuristic = (cos_angle + 1) / 2.0  # Scale to [0, 1]
                angle_heuristic = angle_heuristic * angle_weight
            else:
                angle_heuristic = 0

            # 4. Capacity awareness
            capacity_heuristic = 1 - abs(capacity - demands[j]) / (capacity + 1e-6) if demands[j] < capacity else 0

            # 5. Reward edges near the depot after a high demand node
            depot_proximity_bonus = 0.0
            if demands[i] > 0.7 * capacity:  # If leaving a node with high demand
                 depot_proximity_bonus = depot_proximity_weight * (1 / (distance_matrix[j, 0] + 1e-6))

            heuristic_matrix[i, j] = (
                    distance_heuristic +
                    demand_heuristic +
                    angle_heuristic +
                    capacity_heuristic * capacity_weight+
                depot_proximity_bonus
            )

    # Normalize the heuristic matrix to [0, 1] (optional but often helpful)
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        heuristic_matrix = heuristic_matrix / max_heuristic

    return heuristic_matrix
```
