```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Enhanced heuristics for CVRP using a combination of distance, demand,
    and spatial clustering considerations.

    Args:
        distance_matrix: n x n distance matrix.
        coordinates: n x 2 coordinates of nodes.
        demands: n customer demands.
        capacity: vehicle capacity.

    Returns:
        n x n matrix of edge inclusion probabilities.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # 1. Distance-based heuristic (inverse distance)
    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero

    # 2. Demand-based heuristic (penalize edges connecting nodes with high total demand)
    demand_penalty = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            demand_penalty[i, j] = np.exp(-(demands[i] + demands[j]) / capacity)

    # 3. Savings heuristic (Clark & Wright Savings)
    savings_matrix = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # 4. Spatial Clustering heuristic (favor edges within clusters)
    # A simple proxy for clustering can be achieved by looking at neighborhood density.
    # Edges connecting to denser neighborhoods should be favoured.

    density_penalty = np.zeros((n, n))
    for i in range(n):
        # Count the number of neighbors within a certain radius (adaptive to coordinates scale)
        neighbor_count_i = np.sum(np.linalg.norm(coordinates - coordinates[i], axis=1) < (np.max(coordinates) - np.min(coordinates))/10)
        for j in range(n):
            neighbor_count_j = np.sum(np.linalg.norm(coordinates - coordinates[j], axis=1) < (np.max(coordinates) - np.min(coordinates))/10)
            density_penalty[i,j] = (neighbor_count_i + neighbor_count_j)

    # Combine heuristics
    heuristic_matrix = (
        0.5 * distance_heuristic
        + 0.15 * demand_penalty
        + 0.25 * (savings_matrix / np.max(savings_matrix + 1e-6)) # Normalize savings
        + 0.1 * (density_penalty / np.max(density_penalty + 1e-6)) # Normalize density
    )


    # Ensure that the diagonal is zero (no self-loops)
    np.fill_diagonal(heuristic_matrix, 0)

    # Normalize to probabilities (optional, but might be helpful for stochastic sampling)
    heuristic_matrix = heuristic_matrix / np.sum(heuristic_matrix)

    return heuristic_matrix
```
