```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for the Capacitated Vehicle Routing Problem (CVRP) using a combination of distance,
    demand, and angular considerations, with stochasticity introduced to allow for exploration.

    Args:
        distance_matrix: A numpy array of shape (n, n) representing the distance between nodes.
        coordinates: A numpy array of shape (n, 2) representing the Euclidean coordinates of nodes.
        demands: A numpy array of shape (n,) representing the demand of each node.  demands[0] is depot.
        capacity: The capacity of each vehicle.

    Returns:
        A numpy array of shape (n, n) representing the prior indicators of how promising
        it is to include each edge in a solution.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to control the influence of different factors.  These are tunable!
    distance_weight = 1.0
    demand_weight = 0.5  # Reduced importance for immediate demand; indirectly accounts for total route demand
    angle_weight = 0.3
    capacity_penalty_multiplier = 1.5

    # Add small constant to demands to prevent division by zero issues.
    demands = demands + 0.001

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # Disallow self-loops
                continue

            # Base heuristic: inverse distance
            heuristic_value = distance_weight / distance_matrix[i, j]

            # Incorporate demand information. Nodes with larger demands should be considered
            # less frequently, particularly in proximity to the depot. This helps delay high-demand
            # nodes towards later in the routes, allowing the vehicles to carry small loads early.
            heuristic_value -= demand_weight * demands[j] / capacity

            # Angle penalty: discourage sharp turns by considering the angle formed by
            # (i -> j) and (j -> depot). Minimize total changes in turning direction.
            if i != 0 and j != 0: # Avoid division by zero at depot.
                depot_x, depot_y = coordinates[0]
                x_i, y_i = coordinates[i]
                x_j, y_j = coordinates[j]

                angle_ij = np.arctan2(y_j - y_i, x_j - x_i)
                angle_j_depot = np.arctan2(depot_y - y_j, depot_x - x_j)
                angle_diff = np.abs(angle_ij - angle_j_depot)
                heuristic_value -= angle_weight * angle_diff

            # Penalty for edges that may lead to capacity violation. Prioritize edges leading
            # from the depot to smaller demand nodes.  Also, prioritize edges leading TO smaller demand
            # nodes, as large remaining demand should go to depot more often.
            if i == 0:
                 heuristic_value += 0.5 * demands[j]/ capacity

            # Add stochasticity for exploration:
            heuristic_value += np.random.normal(0, 0.05) # Normal dist, tunable variance.
            heuristic_matrix[i, j] = heuristic_value

    # Ensure all values are non-negative and normalized to [0, 1]
    heuristic_matrix = np.clip(heuristic_matrix, 0, None)  # Ensure non-negative values
    max_val = np.max(heuristic_matrix)

    if max_val > 0:
        heuristic_matrix = heuristic_matrix / max_val

    return heuristic_matrix
```
