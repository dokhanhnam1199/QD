import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int, depot_proximity_weight: float = 0.4903921033039409, demand_penalty_weight: float = 0.08219121227253634, self_loop_heuristic: float = 0.6166919431038784, zero_distance_heuristic: float = -0.6675581057082105) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and node proximity to depot.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes.
        coordinates (np.ndarray): Coordinates of nodes (n x 2).
        demands (np.ndarray): Demand of each node.
        capacity (int): Vehicle capacity.
        depot_proximity_weight (float): Weight for node proximity to depot. Default is 1.0.
        demand_penalty_weight (float): Weight for penalizing higher demand nodes. Default is 1.0.
        self_loop_heuristic (float): Heuristic value for self-loops. Default is 0.0.
        zero_distance_heuristic (float): Heuristic value when distance is zero. Default is 0.0.

    Returns:
        np.ndarray: Heuristic values for each edge.
    """
    n_nodes = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Node Proximity to Depot
    depot_distances = distance_matrix[0, :]  # Distance from depot to each node
    normalized_depot_distances = depot_distances / np.max(depot_distances) if np.max(depot_distances)>0 else np.zeros_like(depot_distances) #Avoid division by zero.
    
    # Demand Considerations
    normalized_demands = demands / capacity
    
    # Edge Heuristic Calculation
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i == j:
                heuristic_matrix[i, j] = self_loop_heuristic  # No self-loops
                continue

            distance = distance_matrix[i, j]
            
            # Avoid division by zero when distance is zero
            if distance == 0:
                heuristic_matrix[i, j] = zero_distance_heuristic
                continue
                
            # Favor shorter distances and nodes closer to the depot
            # Penalize higher demand nodes, and those farther away from the depot

            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j])

            heuristic_matrix[i, j] = heuristic_value

    return heuristic_matrix
