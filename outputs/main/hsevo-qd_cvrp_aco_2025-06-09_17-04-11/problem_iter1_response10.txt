```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP).

    This version considers:
    1. Distance: Shorter distances are preferred.
    2. Demand: Edges connecting to nodes with high demand are penalized
       (making them less likely to be selected early in the search),
       especially if it risks exceeding capacity.
    3. Angle: Edges forming sharp turns are penalized. This encourages
       smoother routes.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes.
        coordinates (np.ndarray): Coordinates of nodes.
        demands (np.ndarray): Demands of each node.
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Heuristic values for each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters (adjust these to fine-tune the heuristic)
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.3  # Increased weight for the angle heuristic
    capacity_threshold = 0.8  # Penalize if demand is above this percentage of capacity

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0.0  # No self-loops
                continue

            # 1. Distance component (Higher is better)
            distance_heuristic = distance_weight / distance_matrix[i, j] if distance_matrix[i, j] > 0 else 0.0


            # 2. Demand component (Lower is better). Penalize high demand.
            demand_penalty = 0.0
            if demands[i] + demands[j] > capacity_threshold * capacity:
                demand_penalty = demand_weight * (demands[i] + demands[j]) / capacity  # Penalize if combined demand is large
            else:
                demand_penalty = demand_weight * demands[j] / capacity # Penalize for destination node demand.

            demand_heuristic = 1.0 - min(1.0, demand_penalty) #normalize and invert the penalty to yield a benefit.

            # 3. Angle component (Lower angle difference is better - smoother routes)
            angle_penalty = 0.0
            if i != 0 and j != 0:  # Avoid depot as central node in angle calculation
                angles = []
                for k in range(n):
                   if k != i and k != j:
                      v1 = coordinates[i] - coordinates[j]
                      v2 = coordinates[i] - coordinates[k]

                      if np.linalg.norm(v1) > 0 and np.linalg.norm(v2) > 0:
                         dot_product = np.dot(v1, v2)
                         cos_angle = dot_product / (np.linalg.norm(v1) * np.linalg.norm(v2))
                         angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))
                         angles.append(angle)

                if len(angles) > 0 :
                   angle_penalty = angle_weight * np.std(angles) #high std suggests sharp turning
                   # Normalize the angle penalty
                   angle_heuristic = 1.0 - min(1.0, angle_penalty)
                else:
                   angle_heuristic = 1.0
            else:
                angle_heuristic = 1.0

            # Combine the heuristics (weighted sum)
            heuristic_matrix[i, j] = distance_heuristic * demand_heuristic * angle_heuristic
            # Normalize to avoid numerical issues:
            # heuristic_matrix[i, j] = 1.0 / (1.0 + np.exp(-heuristic_matrix[i,j])) # Applying Sigmoid
    return heuristic_matrix
```
