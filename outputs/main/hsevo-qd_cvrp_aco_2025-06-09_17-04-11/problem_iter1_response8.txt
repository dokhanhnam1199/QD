```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Improved heuristics for CVRP based on distance, demand, and angle.

    Args:
        distance_matrix: Distance between nodes (n x n).
        coordinates: Euclidean coordinates of nodes (n x 2).
        demands: Demand of each node (n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of heuristic values for each edge (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Adjust the scaling factors according to how important each factor is.
    distance_factor = 1.0
    demand_factor = 1.0
    angle_factor = 0.5

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance component: Inverse of distance, penalizing large distances
                distance_heuristic = distance_factor / distance_matrix[i, j]

                # Demand component: Favor edges connecting nodes with demands that, together, stay far below the capacity.
                # Penalize links where either demand alone is a large percentage of capacity

                demand_heuristic = 1.0 - (abs(demands[i])/ capacity) - (abs(demands[j]) / capacity) if (demands[i] >= 0 and demands[j] >= 0) else 0.0 # zero values make the edge uninteresting

                if demand_heuristic < 0:
                    demand_heuristic = 0.0 # don't generate negative scores

                # Angle component: Favor edges that don't cause sharp turns.  Calculate angle at node i
                if i != 0 and j != 0:
                    vector_from_depot = coordinates[i] - coordinates[0]
                    vector_to_j = coordinates[j] - coordinates[i]
                    dot_product = np.dot(vector_from_depot, vector_to_j)
                    magnitudes = np.linalg.norm(vector_from_depot) * np.linalg.norm(vector_to_j)
                    if magnitudes == 0:
                        angle = 0.0 # handle case of identical coordinates, so we do not div by zero
                    else:
                        angle = np.arccos(np.clip(dot_product / magnitudes, -1.0, 1.0))
                        angle_heuristic = 1.0 - (angle / np.pi) # penalize large angles. Convert angle from 0..pi to 0..1 and reverse
                else:
                    angle_heuristic = 0.5 # neutral

                heuristic_matrix[i, j] = (
                    distance_heuristic * distance_factor +
                    demand_heuristic * demand_factor +
                    angle_heuristic * angle_factor
                )

    return heuristic_matrix
```
