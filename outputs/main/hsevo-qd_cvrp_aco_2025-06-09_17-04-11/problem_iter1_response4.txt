```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP)
    via stochastic solution sampling. This version considers distance,
    node demands, and depot proximity.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge
                  in a solution (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Adjustments for zero distances (prevent division by zero)
    distance_matrix = np.where(distance_matrix == 0, 1e-6, distance_matrix)

    # Calculate savings based on distance to depot
    savings = np.zeros((n, n))
    for i in range(1, n):  # Exclude depot (node 0)
        for j in range(1, n):
            if i != j:
                savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]

    # Normalize savings
    max_savings = np.max(savings)
    if max_savings > 0:
        normalized_savings = savings / max_savings
    else:
        normalized_savings = np.zeros_like(savings)

    # Incorporate demand considerations
    demand_penalty = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            # Prefer edges connecting nodes with manageable combined demand
            demand_penalty[i, j] = min(1, (demands[i] + demands[j]) / capacity)

    # Combine factors: distance, savings, and demand
    for i in range(n):
        for j in range(n):
            #Base heuristics on inverse distance
            heuristics[i, j] = (1 / distance_matrix[i, j])

            #Incorporate normalized savings
            heuristics[i, j] += 0.5 * normalized_savings[i, j] #Savings influence

            #Penalize edges that connect high-demand nodes
            heuristics[i, j] *= (1 - 0.25 * demand_penalty[i, j]) #Demand influence

            #Prioritize connections to/from the depot
            if i == 0 or j == 0:
                heuristics[i, j] *= 1.25 # Depot priority

    # Ensure depot connections exist for every node
    for i in range(1,n):
        heuristics[0, i] = max(heuristics[0,i], 1 / distance_matrix[0, i])
        heuristics[i, 0] = max(heuristics[i, 0], 1 / distance_matrix[i, 0])

    return heuristics
```
