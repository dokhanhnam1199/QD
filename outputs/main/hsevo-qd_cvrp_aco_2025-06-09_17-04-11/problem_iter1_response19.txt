```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Improved heuristics for CVRP considering distance, demand, and angular relationships.

    Args:
        distance_matrix: Distance matrix between nodes (n x n).
        coordinates: Euclidean coordinates of nodes (n x 2).
        demands: Vector of customer demands (n).
        capacity: Vehicle capacity.

    Returns:
        Heuristic matrix (n x n) indicating edge desirability.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to control the influence of different factors
    alpha = 1.0  # Distance factor
    beta = 1.5   # Demand factor (higher is better, since we're scaling down distances if this improves demand fill)
    gamma = 0.5  # Angle factor (lower is better, less turning)


    # Node similarity matrix. Higher score indicates more "central" nodes to connect.
    node_centrality = np.zeros(n)
    for i in range(1, n):
        node_centrality[i] = demands[i] / np.sum(distance_matrix[i, 1:])


    # Depot desirability. High values indicate a node close to the depot with smaller demands to start trips.
    depot_desirability = np.zeros(n)
    for i in range(1, n):
        depot_desirability[i] = (capacity - demands[i]) / distance_matrix[0,i]


    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Base heuristic: inverse of distance
            heuristic_value = alpha / distance_matrix[i, j]

            # Demand consideration: Adjust heuristic based on demands of connected nodes
            # Encourage linking nodes with small demand if close to exceeding capacity, and vice versa.
            # depot demand == 0; depot position makes it okay.

            demand_factor = 1.0

            if i != 0 and j != 0:  # Don't apply demand heuristic for depot connections.
               demand_factor = (1+ abs(demands[i] - demands[j])) #/ min(demands[i], demands[j], capacity)

            heuristic_value *= beta / demand_factor

            # Angle consideration: Discourage sharp turns (less sharp turning is more desirable).
            # Consider the angle between vectors (i -> j) and (j -> depot).  Prefer smaller angle, i.e., bigger cosine.
            if i != 0 and j != 0:
                vector_ij = coordinates[j] - coordinates[i]
                vector_j0 = coordinates[0] - coordinates[j]  #depot

                # Calculate cosine of the angle
                norm_ij = np.linalg.norm(vector_ij)
                norm_j0 = np.linalg.norm(vector_j0)

                if norm_ij > 0 and norm_j0 > 0:
                   cos_angle = np.dot(vector_ij, vector_j0) / (norm_ij * norm_j0)
                   heuristic_value *= (1 + gamma * max(cos_angle, 0)) # only penalize negative cosines
                else:
                    heuristic_value *= 1 + gamma # angle has no impact.

            if i == 0 and j != 0: # scaling depot connection:
                heuristic_value *= depot_desirability[j]
            if j == 0 and i!= 0: # when return-to-depot is considered
                heuristic_value *= (capacity- demands[i])/ distance_matrix[i,j]
            heuristic_matrix[i, j] = heuristic_value

    # Normalize the heuristic matrix (optional, but can be helpful)
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        heuristic_matrix /= max_heuristic
    return heuristic_matrix
```
