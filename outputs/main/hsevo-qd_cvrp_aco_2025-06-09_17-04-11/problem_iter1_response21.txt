```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for CVRP using a combination of distance, demand, and node proximity.

    This version prioritizes shorter distances, penalizes edges connecting nodes that would
    likely violate capacity constraints if directly linked (without returning to depot), and considers
    node centrality relative to the depot to avoid stranding remote customers.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n). depot has index 0.
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of edge inclusion (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Avoid division by zero: Add a small constant to distance
    distance_matrix = distance_matrix + 1e-9

    # Base heuristic: Inverse distance
    heuristic_matrix = 1 / distance_matrix

    # Demand-based penalty: If connecting two nodes would likely violate capacity, penalize.
    # Avoid connecting two customers directly whose demands exceed capacity.

    for i in range(1, n): #exclude the depot, since its artificial.
      for j in range(1, n):
        if i != j:
          if demands[i] + demands[j] > capacity:
              heuristic_matrix[i, j] *= 0.1  # Penalize heavily

    # Node Proximity to Depot
    # Give preference to connect nodes with large distances with the depot together.
    depot_distances = distance_matrix[0, :] #distance from depot to each node.
    # scale these distances so that we can subtract them from each element of the matrix.
    scale_factor = 0.1 * np.mean(distance_matrix) / np.mean(depot_distances) #some arbitrary mean normalization to avoid large changes.
    for i in range(1, n):
      for j in range(1, n):
        heuristic_matrix[i, j] *= (1- scale_factor * (abs(depot_distances[i] - depot_distances[j]) / (depot_distances[i] + depot_distances[j] + 1e-9))) #proximity in ratio.
        #nodes further away from the depot are assigned lower weight and this matrix cell (edge) will be given higher preference.
    # Mask diagonal elements to prevent self-loops
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
