```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Enhanced heuristics for CVRP, considering distance, demand, and angular proximity.

    Args:
        distance_matrix: Distance between nodes (n x n).
        coordinates: Euclidean coordinates of nodes (n x 2).
        demands: Demand of each node (n).
        capacity: Vehicle capacity.

    Returns:
        Edge desirability matrix (n x n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Scale distances to a range [0, 1]
    max_dist = np.max(distance_matrix[distance_matrix != np.inf])  #Avoid inf
    scaled_distances = distance_matrix / max_dist if max_dist > 0 else np.zeros_like(distance_matrix) #Avoid division by 0.
    scaled_distances[scaled_distances > 1] = 1 #Clamp the distances just in case of weird issues.
    # Demand considerations: prioritize edges connecting nodes with combined demand
    # that is not excessively high.
    demand_factor = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                combined_demand = demands[i] + demands[j] #Prioritize small demands.
                demand_factor[i, j] = np.clip(1 - (combined_demand / (2*capacity)), 0, 1)  # Scale to [0, 1]
            else:
                demand_factor[i,j] = 0 #Do not consider self loops.

    # Angular proximity: nodes close to the depot *line* are more promising for earlier inclusion.
    # This prioritizes creating tours that radiate outwards from the depot.
    depot_x, depot_y = coordinates[0]
    angular_proximity = np.zeros((n, n))
    for i in range(1,n):
        angle_i = np.arctan2(coordinates[i][1] - depot_y, coordinates[i][0] - depot_x)
        for j in range(1, n):
            if i != j:
                angle_j = np.arctan2(coordinates[j][1] - depot_y, coordinates[j][0] - depot_x)
                angle_diff = np.abs(angle_i - angle_j)
                angular_proximity[i, j] = np.exp(-angle_diff**2 / (2 * (np.pi/4)**2))  #Gaussian like distribution.


    # Combine the factors. Inverse distance, demand factor, and angular_proximity
    # Higher values in `heuristic_matrix` indicate more promising edges.
    heuristic_matrix = (
        (1 - scaled_distances) +
        0.7 * demand_factor +  # Weight demand a bit less
        0.3 * angular_proximity #Angular proximity is just a tie-breaker and initializer.
    )
    heuristic_matrix[np.isinf(distance_matrix)] = 0 #Handle inf distance

    return heuristic_matrix
```
