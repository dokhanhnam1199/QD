{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\n### Better code\ndef heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, and angle to depot.\n    Sparsifies adaptively based on edge importance and instance characteristics.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot (Prioritized)\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    normalized_depot_distances = depot_distances / max_depot_distance if max_depot_distance > 0 else np.zeros_like(depot_distances)\n\n    # Demand Considerations (Prioritized)\n    normalized_demands = demands / capacity\n    \n    # Angle to Depot (Encourages radial routes)\n    angles = np.zeros((n_nodes, n_nodes))\n    for i in range(1, n_nodes):\n        for j in range(1, n_nodes):\n            if i != j:\n                vec_i = coordinates[i] - coordinates[0]\n                vec_j = coordinates[j] - coordinates[0]\n                \n                norm_i = np.linalg.norm(vec_i)\n                norm_j = np.linalg.norm(vec_j)\n                \n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vec_i, vec_j) / (norm_i * norm_j)\n                    angles[i, j] = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Clip for numerical stability\n                else:\n                    angles[i, j] = np.pi  # Maximum angle if a node is at the depot\n    normalized_angles = angles / np.pi  # Normalize to [0, 1]\n\n    # Edge Importance (Adaptive Sparsification)\n    edge_importance = np.zeros_like(distance_matrix)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                continue\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j]) * (1 - normalized_angles[i,j])\n\n            heuristic_matrix[i, j] = heuristic_value\n            edge_importance[i, j] = (1 / distance) * (demands[i] + demands[j])  # Example: inversely proportional to distance, proportional to combined demand\n\n    # Adaptive Sparsification\n    mean_importance = np.mean(edge_importance[edge_importance > 0])\n    std_importance = np.std(edge_importance[edge_importance > 0])\n\n    #Dynamic threshold based on importance\n    threshold = mean_importance - 0.5 * std_importance  # Tune the 0.5 factor based on performance\n\n    heuristic_matrix[edge_importance < threshold] = 0\n    \n    #Further sparsification based on the heuristic value to limit the search space\n    heuristic_threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1\n    heuristic_matrix[heuristic_matrix < heuristic_threshold] = 0\n\n    return heuristic_matrix\n\n### Worse code\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics for CVRP based on distance, demand, and node proximity to depot.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes.\n        coordinates (np.ndarray): Coordinates of nodes (n x 2).\n        demands (np.ndarray): Demand of each node.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Heuristic values for each edge.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Node Proximity to Depot\n    depot_distances = distance_matrix[0, :]  # Distance from depot to each node\n    normalized_depot_distances = depot_distances / np.max(depot_distances) if np.max(depot_distances)>0 else np.zeros_like(depot_distances) #Avoid division by zero.\n    \n    # Demand Considerations\n    normalized_demands = demands / capacity\n    \n    # Edge Heuristic Calculation\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n\n            distance = distance_matrix[i, j]\n            \n            # Avoid division by zero when distance is zero\n            if distance == 0:\n                heuristic_matrix[i, j] = 0\n                continue\n                \n            # Favor shorter distances and nodes closer to the depot\n            # Penalize higher demand nodes, and those farther away from the depot\n\n            heuristic_value = (1 / distance) * (1 - normalized_demands[j]) * (1 - normalized_depot_distances[j])\n\n            heuristic_matrix[i, j] = heuristic_value\n\n    return heuristic_matrix\n\n### Analyze & experience\n- *   Comparing (1st) vs (20th), we see the best heuristic incorporates depot proximity, demand, angle to depot, and adaptive sparsification based on edge importance while the worst just returns the inverse of the distance matrix.\n*   Comparing (6th) vs (11th), the heuristic 6th sparsifies the matrix while 11th not.\n*   Comparing (1st) vs (6th), the best heuristic includes angle to depot and a more sophisticated adaptive sparsification strategy than the 6th. The adaptive sparsification involves calculating an edge importance and thresholding based on mean and standard deviation of edge importances. The best heuristic also normalizes the angles, while the 6th one doesn't consider angles.\n*   Comparing (2nd) vs (3rd), and (4th) vs (5th), we see no difference in the code.\n*   Comparing (second worst) vs (worst), there are no differences.\n*   Overall: The top heuristics prioritize a combination of factors: distance, demand, depot proximity, and sometimes angle. Adaptive sparsification plays a crucial role in the best-performing heuristics. Sparsification helps to reduce the search space by eliminating less promising edges.\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, let's refine \"Current Self-Reflection\" into a more actionable approach for designing better heuristics.\n\n*   **Keywords:** Multifactorial, Adaptive, Iterative, Normalization, Statistics-driven.\n*   **Advice:** Focus on blending diverse, normalized problem features (distance, demand, location) statistically. Iteratively refine heuristics based on edge importance and performance feedback.\n*   **Avoid:** Sole reliance on single factors, static approaches, neglecting normalization.\n*   **Explanation:** This emphasizes a dynamic, data-driven process using combined, relevant factors for improved heuristic design. Normalization ensures fair feature weighting.\n\n\nYour task is to write an improved function `heuristics_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}