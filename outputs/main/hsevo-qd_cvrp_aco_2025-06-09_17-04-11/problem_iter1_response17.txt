```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This heuristic combines distance, demand, and angular considerations to estimate the
    promisingness of each edge.  It attempts to balance proximity (short distances),
    demand satisfaction (pairing nodes with compatible demand profiles), and
    routing efficiency (avoiding sharp turns and promoting radial spread).

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge
                  in a solution.  Same shape as distance_matrix.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Parameters (tuned for demonstration - might need adjustment)
    alpha = 1.0   # Distance importance
    beta = 0.7    # Demand compatibility importance
    gamma = 0.5   # Angular penalty importance

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
                continue

            # 1. Distance component: Inverse distance (shorter is better)
            distance_component = 1 / distance_matrix[i, j]

            # 2. Demand compatibility component: Penalize incompatible demand pairs
            # Higher demand for a pair can also mean bigger penalty when sum > capacity
            demand_sum = demands[i] + demands[j]
            demand_component = np.exp(-beta * np.abs(demands[i] - demands[j]) / capacity)

            if demand_sum > capacity:
                demand_component /= (demand_sum / capacity)**2 # significant penalty


            # 3. Angular penalty component: discourage sharp turns.
            # Calculate angle between vector from depot to i and vector from i to j
            if i != 0: # If not from depot.
              depot_x = coordinates[0, 0]
              depot_y = coordinates[0, 1]
              ix = coordinates[i,0]
              iy = coordinates[i,1]
              jx = coordinates[j,0]
              jy = coordinates[j,1]

              vector_depot_to_i = np.array([ix - depot_x, iy - depot_y])
              vector_i_to_j = np.array([jx - ix, jy - iy])
              norm_depot_to_i = np.linalg.norm(vector_depot_to_i)
              norm_i_to_j = np.linalg.norm(vector_i_to_j)

              if norm_depot_to_i > 0 and norm_i_to_j > 0:
                  dot_product = np.dot(vector_depot_to_i, vector_i_to_j)
                  cos_angle = dot_product / (norm_depot_to_i * norm_i_to_j)

                  angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) # clip cos_angle for numerical stability.

                  angular_penalty = np.exp(-gamma * abs(angle - np.pi / 2)) # closer to 90 degrees, less penalty
              else:
                  angular_penalty = 1.0  # Handle zero-length vectors (no penalty)

            else:  # From depot, no penalty
                angular_penalty = 1.0


            # Combine components
            heuristics[i, j] = distance_component**alpha * demand_component * angular_penalty


    # Normalize to range [0, 1] - good practice
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:  # Check division by zero.
        heuristics /= max_heuristic

    return heuristics
```
