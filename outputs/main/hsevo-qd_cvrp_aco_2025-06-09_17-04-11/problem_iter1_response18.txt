```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Generates heuristic edge weights for the Capacitated Vehicle Routing Problem (CVRP).

    This version incorporates distance, demand considerations, and depot proximity to guide edge selection.

    Args:
        distance_matrix (np.ndarray):  Distance matrix between nodes (n x n).
        coordinates (np.ndarray):      Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray):         Customer demands (n).
        capacity (int):              Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators (edge weights) for inclusion in a solution (n x n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Calculate demand-weighted distances from each node to all others
    demand_weighted_distances = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            demand_weighted_distances[i, j] = distance_matrix[i, j] * (demands[i] + demands[j])

    # Calculate distances from each node to the depot (node 0)
    depot_distances = distance_matrix[:, 0]

    for i in range(n):
        for j in range(n):
            if i != j:
                # Prioritize shorter distances
                distance_term = 1 / distance_matrix[i, j]

                # Penalize edges that connect nodes with high total demand (compared to vehicle capacity)
                demand_term = max(0, 1 - (demands[i] + demands[j]) / (2*capacity))  #Scale between 0 and 1. Max to avoid negative values

                # Penalize connections that are far from the depot (encourage "radial" routes from depot)
                depot_proximity_term = 1 / (1 + depot_distances[i] + depot_distances[j])

                #Combine these factors
                heuristic_matrix[i, j] = distance_term * (0.5 * demand_term + 0.5 * depot_proximity_term) #Balance both term.

            else:
                heuristic_matrix[i, j] = 0  # No self-loops

    return heuristic_matrix
```
