```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version combines distance, demand, and spatial relationships to estimate the
    promise of including each edge in a solution.  It also sparsifies the matrix
    by setting less promising elements to zero.

    Args:
        distance_matrix: A NumPy array representing the distance matrix (shape: n x n).
        coordinates: A NumPy array representing the Euclidean coordinates of nodes (shape: n x 2).
        demands: A NumPy array representing the demands of each node (shape: n).
        capacity: The capacity of each vehicle.

    Returns:
        A NumPy array of the same shape as the distance_matrix, representing the prior
        indicators of how promising it is to include each edge in a solution.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Parameters (can be tuned)
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.2
    capacity_threshold = 0.8  # Fraction of capacity considered "high" demand
    sparsity_threshold = 0.1 # Threshold to determine sparsity

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics_matrix[i, j] = 0  # No self-loops
                continue

            # Distance factor (favor shorter distances)
            distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Adding a small constant to avoid division by zero

            # Demand factor (penalize edges that lead to high demand on a route)
            demand_factor = 1.0
            if i != 0 and j != 0:
                if demands[i] + demands[j] > capacity * capacity_threshold:  #Prioritizing return to depot
                   demand_factor = 0.1
                else:
                   demand_factor = 1 / (demands[i] + demands[j] + 1e-6)

            # Angle factor (favor connections that reduce sharp turns)
            angle_factor = 1.0
            if i != 0 and j != 0: #angle penalty when forming depot to node to node routes
              depot_x, depot_y = coordinates[0]
              node_i_x, node_i_y = coordinates[i]
              node_j_x, node_j_y = coordinates[j]

              vector_depot_i = np.array([node_i_x - depot_x, node_i_y - depot_y])
              vector_i_j = np.array([node_j_x - node_i_x, node_j_y - node_i_y])

              # Calculate cosine of the angle between the vectors
              dot_product = np.dot(vector_depot_i, vector_i_j)
              magnitudes = np.linalg.norm(vector_depot_i) * np.linalg.norm(vector_i_j)

              if magnitudes > 0:
                  cosine_angle = dot_product / magnitudes
                  # Convert cosine to angle in radians
                  angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0)) # Ensure the value is within the valid range
                  angle_factor = 1 - (angle / np.pi)  # Normalize angle factor. Closer to straight line is closer to 1.

              else:
                  angle_factor = 0.5

            # Combine factors
            heuristics_matrix[i, j] = (
                distance_weight * distance_factor +
                demand_weight * demand_factor +
                angle_weight * angle_factor
            )

    #Sparsify the matrix
    max_val = np.max(heuristics_matrix)
    threshold = max_val * sparsity_threshold
    heuristics_matrix[heuristics_matrix < threshold] = 0
    return heuristics_matrix
```
