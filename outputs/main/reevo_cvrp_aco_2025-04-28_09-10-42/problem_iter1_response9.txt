```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling.

    This function combines distance, demand, and angular considerations to estimate the desirability
    of including each edge in a solution.  It sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): A distance matrix (shape: n by n) representing distances between nodes.
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): A vector of customer demands (shape: n).
        capacity (int): The capacity of each vehicle.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing the desirability of including each edge in a solution.
                      Higher values indicate more promising edges.  Unpromising edges are set to 0.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to control the influence of each factor
    distance_weight = 1.0
    demand_weight = 1.0
    angle_weight = 1.0

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor: Favor shorter distances
                distance_factor = 1 / distance_matrix[i, j]

                # Demand factor: Penalize edges that connect nodes with large demands, especially if the total demand
                #                exceeds the vehicle capacity. Also encourage edges connected to the depot.
                demand_factor = 1.0
                if i == 0 or j == 0:
                    demand_factor = 1.0 # Give preference to connections to and from the depot.
                else:
                    demand_factor = max(0.0, 1.0 - (demands[i] + demands[j]) / (2 * capacity))

                # Angle factor: Penalize sharp turns. Calculate angle at node i if visiting from k and going to j.
                angle_factor = 1.0
                if i != 0:  # only if node i is a client node
                    angles = []
                    for k in range(n):
                        if k != i and k!=j:
                             # Compute angle between vectors ki and ij
                            vector_ki = coordinates[i] - coordinates[k]
                            vector_ij = coordinates[j] - coordinates[i]

                            # Normalize the vectors
                            vector_ki = vector_ki / np.linalg.norm(vector_ki)
                            vector_ij = vector_ij / np.linalg.norm(vector_ij)

                            # Compute the cosine of the angle
                            cos_angle = np.dot(vector_ki, vector_ij)
                            # Ensure cos_angle is within the valid range [-1, 1]
                            cos_angle = np.clip(cos_angle, -1.0, 1.0)

                            # Convert cosine to angle in radians
                            angle = np.arccos(cos_angle)
                            angles.append(angle)

                    if angles:
                        avg_angle = np.mean(angles) # compute the average of all possible angles
                        angle_factor = max(0.0, 1 - (abs(avg_angle - np.pi) / np.pi)) # prefer near straight line and avoid the reverse

                # Combine the factors
                heuristic_matrix[i, j] = (distance_weight * distance_factor +
                                            demand_weight * demand_factor +
                                            angle_weight * angle_factor)

    # Sparsify the matrix: Zero out less promising edges
    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 20)  # Keep top 80% of edges (adjust percentile as needed)
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
