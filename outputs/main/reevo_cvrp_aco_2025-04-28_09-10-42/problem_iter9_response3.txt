```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version prioritizes depot proximity and demand when selecting edges. Implements targeted, adaptive sparsification
    based on distance and heuristic scores. Normalizes inputs effectively and fine-tunes weights via experimentation
    for optimal performance.
    The depot node is indexed by 0.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Savings calculation (Clarke-Wright)
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Demand factor (normalized)
    demand_factor = demands / capacity
    demand_factor = np.clip(demand_factor, 0, 1)

    # Depot proximity factor (inverse distance to depot)
    depot_proximity = np.zeros(n)
    for i in range(1, n):  # Exclude depot itself
        depot_proximity[i] = 1 / (distance_matrix[0, i] + 1e-9)  # Avoid division by zero
    depot_proximity = depot_proximity / np.max(depot_proximity) if np.max(depot_proximity) > 0 else np.zeros(n)

    # Combine factors
    alpha, beta, gamma = 0.5, 0.3, 0.2  # Tunable weights
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_value = (
                    alpha * (savings_matrix[i, j] / (distance_matrix[i, j] + 1e-9))
                    - beta * (demand_factor[i] + demand_factor[j])
                    + gamma * (depot_proximity[i] + depot_proximity[j])
                )
                heuristics_matrix[i, j] = heuristic_value

    # Adaptive Sparsification
    heuristic_values = heuristics_matrix[np.triu_indices_from(heuristics_matrix, k=1)]
    cutoff_percentile = 40 # Adjusted percentile
    cutoff_value = np.percentile(heuristic_values, cutoff_percentile)
    heuristics_matrix[heuristics_matrix < cutoff_value] = 0.0

    distance_threshold = np.mean(distance_matrix) * 1.2 # Adjusted threshold
    heuristics_matrix[distance_matrix > distance_threshold] = 0.0

    # Normalization
    max_heuristic = np.max(heuristics_matrix)
    if max_heuristic > 0:
        heuristics_matrix = heuristics_matrix / max_heuristic

    return heuristics_matrix
```
