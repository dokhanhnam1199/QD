```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:


    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version prioritizes savings and inverse distance. It also incorporates adaptive sparsification based on percentile cutoffs.
    And normalizes the heuristic matrix. Includes a combined term for distance and demand, and adjusts sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Calculate savings matrix (Clarke-Wright Savings Algorithm)
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Demand factor
    demand_factor = demands / capacity  # Ratio of demand to capacity. Smaller is generally better
    demand_factor = np.clip(demand_factor, 0, 1)

    # Combine factors
    for i in range(n):
        for j in range(n):
            if i != j:
                # Primary factors: savings and inverse distance
                heuristics_matrix[i, j] = savings_matrix[i, j] / (distance_matrix[i, j] * (1 + demand_factor[i] + demand_factor[j])**0.5 + 1e-9) #avoid division by zero. Combined distance and demand penalty. Square root reduces the impact of high demand

    # Adaptive sparsification based on heuristic values and percentile cutoff
    heuristic_values = heuristics_matrix[np.triu_indices_from(heuristics_matrix, k=1)]  # Upper triangle values
    cutoff_percentile = 25  # dynamically adjusted. Further decreased percentile.
    cutoff_value = np.percentile(heuristic_values, cutoff_percentile)
    heuristics_matrix[heuristics_matrix < cutoff_value] = 0.0

    # Further sparsification based on distance
    distance_threshold = np.mean(distance_matrix) * 1.4  # dynamically adjusted.
    heuristics_matrix[distance_matrix > distance_threshold] = 0.0

   # Encourage connections to the depot
    for i in range(1, n):
        heuristics_matrix[0, i] *= 1.2
        heuristics_matrix[i, 0] *= 1.2
    
    # Normalize the heuristics matrix
    max_heuristic = np.max(heuristics_matrix)
    if max_heuristic > 0:
        heuristics_matrix = heuristics_matrix / max_heuristic

    return heuristics_matrix
```
