```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This function combines several factors to determine how promising it is to select an edge,
    including distance, demand, and proximity to the depot. It also sparsifies the matrix by
    setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                    (same shape as distance_matrix).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Parameters (can be tuned)
    distance_weight = 1.0
    demand_weight = 0.5
    depot_proximity_weight = 0.2
    sparsification_threshold = 0.1

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance factor (shorter distances are more promising)
            distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Add small constant to avoid division by zero

            # Demand factor (edges connecting to nodes with high demand might be less promising if near capacity already)
            demand_factor = 1 / (demands[i] + demands[j] + 1e-6)

            # Depot proximity factor (nodes far from the depot should be prioritized)
            depot_distance_i = distance_matrix[0, i]
            depot_distance_j = distance_matrix[0, j]
            depot_proximity_factor = 1 / (min(depot_distance_i, depot_distance_j) + 1e-6) #closest distance to the depot


            # Combine factors
            heuristic_matrix[i, j] = (
                distance_weight * distance_factor +
                demand_weight * demand_factor +
                depot_proximity_weight * depot_proximity_factor
            )

    # Normalize heuristic matrix (optional, but can improve performance)
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        heuristic_matrix = heuristic_matrix / max_heuristic


    # Sparsify the matrix (set unpromising edges to zero)
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], sparsification_threshold)  # Only consider positive elements for threshold

    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
