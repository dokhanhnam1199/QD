```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version refines the combination of distance and demand penalties, uses adaptive sparsification
    with distance thresholds and percentile-based filtering, emphasizes depot proximity, and balances savings
    calculations with demand ratios.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Calculate savings matrix (Clarke-Wright Savings Algorithm)
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Demand factor
    demand_factor = demands / capacity  # Ratio of demand to capacity. Smaller is generally better
    demand_factor = np.clip(demand_factor, 0, 1)

    # Depot proximity factor
    depot_proximity = np.zeros_like(distance_matrix)
    for i in range(1, n):
        depot_proximity[0, i] = 1 / (distance_matrix[0, i] + 1e-9)
        depot_proximity[i, 0] = 1 / (distance_matrix[i, 0] + 1e-9)

    # Combine factors
    for i in range(n):
        for j in range(n):
            if i != j:
                # Savings, inverse distance, and demand considerations
                heuristics_matrix[i, j] = (savings_matrix[i, j]**1.2) / ((distance_matrix[i, j]**0.8) * (1 + demand_factor[i] + demand_factor[j])**1.5 + 1e-9)

                # Incorporate depot proximity
                heuristics_matrix[i, j] += 0.1 * (depot_proximity[i, j] + depot_proximity[j, i]) #reduced factor

    # Adaptive sparsification based on heuristic values and percentile cutoff
    heuristic_values = heuristics_matrix[np.triu_indices_from(heuristics_matrix, k=1)]  # Upper triangle values
    cutoff_percentile = 40 # Increased percentile
    cutoff_value = np.percentile(heuristic_values, cutoff_percentile)
    heuristics_matrix[heuristics_matrix < cutoff_value] = 0.0

    # Further sparsification based on distance
    distance_threshold = np.mean(distance_matrix) * 1.3 # More restrictive threshold
    heuristics_matrix[distance_matrix > distance_threshold] = 0.0

    # Normalize the heuristics matrix
    max_heuristic = np.max(heuristics_matrix)
    if max_heuristic > 0:
        heuristics_matrix = heuristics_matrix / max_heuristic

    return heuristics_matrix
```
