```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version prioritizes savings, demand ratios, and depot proximity. It adapts sparsification based on
    distance and heuristic scores and normalizes the output. Simpler depot proximity calculation is used.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Savings matrix (Clarke-Wright Savings Algorithm)
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Demand factor
    demand_factor = demands / capacity
    demand_factor = np.clip(demand_factor, 0, 1)

    # Depot proximity (simpler calculation)
    depot_proximity = np.zeros_like(distance_matrix)
    for i in range(1, n):
        depot_proximity[0, i] = 1 / (distance_matrix[0, i] + 1e-9)
        depot_proximity[i, 0] = depot_proximity[0, i]

    # Combine factors
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_score = (
                    savings_matrix[i, j] / (distance_matrix[i, j] + 1e-9) *
                    (1 - (demand_factor[i] + demand_factor[j])/2)
                )
                heuristics_matrix[i, j] = heuristic_score

    # Adaptive sparsification
    heuristic_values = heuristics_matrix[np.triu_indices_from(heuristics_matrix, k=1)]
    cutoff_percentile = 40  # Adjust sparsification
    cutoff_value = np.percentile(heuristic_values, cutoff_percentile)
    heuristics_matrix[heuristics_matrix < cutoff_value] = 0.0

    # Further sparsification based on distance
    distance_threshold = np.mean(distance_matrix) * 1.2  # Adjust threshold
    heuristics_matrix[distance_matrix > distance_threshold] = 0.0

    # Normalize
    max_heuristic = np.max(heuristics_matrix)
    if max_heuristic > 0:
        heuristics_matrix = heuristics_matrix / max_heuristic

    return heuristics_matrix
```
