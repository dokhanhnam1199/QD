```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version prioritizes savings and inverse distance, simplifies depot proximity, and adjusts the sparsification threshold.
    It also incorporates adaptive sparsification based on percentile cutoffs. And normalizes the heuristic matrix.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Calculate savings matrix (Clarke-Wright Savings Algorithm)
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Demand factor
    demand_ratio = demands / capacity
    demand_factor = np.clip(demand_ratio, 0, 1)

    # Depot proximity factor (prioritize edges closer to depot)
    depot_proximity = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            depot_proximity[i, j] = 1 / (distance_matrix[0, i] + distance_matrix[0, j] + 1e-9)
            depot_proximity[j, i] = depot_proximity[i, j]

    # Combine factors
    for i in range(n):
        for j in range(n):
            if i != j:
                # Savings, Inverse Distance, Demand, Depot Proximity
                heuristics_matrix[i, j] = (
                    savings_matrix[i, j] / (distance_matrix[i, j] + 1e-9)
                    * depot_proximity[i, j]
                    / (1 + demand_factor[i] + demand_factor[j]) ** 0.5 # Reduced demand penalty
                )

    # Adaptive sparsification
    heuristic_values = heuristics_matrix[np.triu_indices_from(heuristics_matrix, k=1)]
    cutoff_percentile = 40  # Adjusted percentile for more aggressive sparsification
    cutoff_value = np.percentile(heuristic_values, cutoff_percentile)
    heuristics_matrix[heuristics_matrix < cutoff_value] = 0.0

    # Distance based sparsification (adaptive threshold)
    distance_threshold = np.mean(distance_matrix) * 1.2  # Further reduced threshold
    heuristics_matrix[distance_matrix > distance_threshold] = 0.0
    
    # Normalize
    max_heuristic = np.max(heuristics_matrix)
    if max_heuristic > 0:
        heuristics_matrix = heuristics_matrix / max_heuristic

    return heuristics_matrix
```
