```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    Heuristics for CVRP based on distance, demand, and angle considerations.

    Args:
        distance_matrix: Distance matrix between nodes.
        coordinates: Coordinates of the nodes.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        A matrix indicating the desirability of each edge.
    """

    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Parameters to control the influence of each factor
    alpha = 1.0   # Weight for distance
    beta = 0.5    # Weight for demand
    gamma = 0.2   # Weight for angle

    # Normalize demand to [0, 1]
    normalized_demands = demands / capacity

    # Calculate angles between nodes relative to the depot
    depot_x, depot_y = coordinates[0]
    angles = np.zeros(n)
    for i in range(1, n):
        x, y = coordinates[i]
        angles[i] = np.arctan2(y - depot_y, x - depot_x)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor: shorter distance is better
                distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Adding a small constant to avoid division by zero

                # Demand factor: Prefer edges connecting nodes with high demand (scaled down)
                demand_factor = (normalized_demands[i] + normalized_demands[j])

                # Angle factor: Penalize sharp turns relative to the depot.  Smaller angle difference is better
                angle_diff = np.abs(angles[i] - angles[j])
                angle_factor = np.exp(-angle_diff)  # Use exponential decay for angle difference


                # Combine the factors
                heuristics_matrix[i, j] = (alpha * distance_factor +
                                           beta * demand_factor +
                                           gamma * angle_factor)

    # Sparsify the matrix: Keep only top k connections per node
    k = int(np.sqrt(n))  # Number of connections to keep.  Dynamically scale based on the size of the graph

    for i in range(n):
        row = heuristics_matrix[i, :]
        indices = np.argsort(row)[-k:]  # Indices of the top k values
        mask = np.ones(n, dtype=bool)
        mask[indices] = False
        heuristics_matrix[i, mask] = 0  # Set non-top-k elements to zero

    return heuristics_matrix
```
