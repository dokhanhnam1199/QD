```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates multiple factors to determine the desirability of including an edge
    in a solution and sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                    (same shape as distance_matrix).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters to tune the heuristic
    alpha = 1.0   # Distance factor
    beta = 0.5    # Demand factor
    gamma = 0.2   # Angle factor
    delta = 0.1   # Sparsity factor
    epsilon = 0.01 # To avoid division by zero


    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
            else:
                # Distance factor: inversely proportional to distance
                distance_factor = 1 / (distance_matrix[i, j] + epsilon)

                # Demand factor: considers the demands of the two nodes.  Avoids connecting two large demand nodes far from depot
                demand_factor = np.exp(-beta * (demands[i] + demands[j]) / capacity)

                # Angle factor: prefers edges that don't create sharp turns away from depot (node 0)
                angle_factor = 1.0
                if i != 0 and j != 0: # no penalty if connect depot to node i or connect node i to depot
                    # vector from depot to i
                    vec_di = coordinates[i] - coordinates[0]
                    # vector from i to j
                    vec_ij = coordinates[j] - coordinates[i]

                    #cosine of the angle between the vectors. Dot Product and normalize
                    dot_product = np.dot(vec_di, vec_ij)
                    norm_di = np.linalg.norm(vec_di)
                    norm_ij = np.linalg.norm(vec_ij)

                    if norm_di > 0 and norm_ij > 0:
                        cosine_angle = dot_product / (norm_di * norm_ij)
                        #angle_factor = (1 + cosine_angle) / 2  # Scale cosine to [0, 1]
                        angle_factor = np.clip(cosine_angle, 0, 1) #prefer direction away from depot


                # Combine the factors
                heuristic_matrix[i, j] = (alpha * distance_factor +
                                           beta * demand_factor +
                                           gamma * angle_factor)

    # Sparsify the matrix: remove less promising edges based on a threshold
    threshold = np.mean(heuristic_matrix) * delta  # Dynamic threshold based on mean
    heuristic_matrix[heuristic_matrix < threshold] = 0.0


    # Normalize heuristic values to be between 0 and 1. Not essential but can help with some sampling methods.
    max_val = np.max(heuristic_matrix)
    if max_val > 0:  # Avoid division by zero
      heuristic_matrix = heuristic_matrix / max_val



    return heuristic_matrix
```
