```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters (can be tuned)
    alpha = 1.0  # Weight for distance
    beta = 0.5   # Weight for demand consideration (higher demand makes edge less attractive)
    gamma = 0.2  # Weight for angle to depot (edges pointing away from depot are less attractive)
    sparsity_threshold = 0.1 # Edges with a value less than this gets pruned

    depot_coords = coordinates[0]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
            else:
                # Distance factor: Shorter distances are more promising
                distance_factor = alpha / distance_matrix[i, j]

                # Demand factor:  Edges connecting nodes with high demand are penalized
                demand_factor = 1 / (1 + beta * (demands[i] + demands[j]))

                # Angle to depot factor: Edges connecting nodes far away from the depot might be suboptimal.
                # We calculate the angle between the edge (i, j) and the line connecting node i to the depot.
                # Larger angles (closer to 180 degrees) indicate the route is going away from the depot
                vector_ij = coordinates[j] - coordinates[i]
                vector_i_depot = depot_coords - coordinates[i]

                # Handle cases when node i is close to the depot to avoid division by zero error
                if np.linalg.norm(vector_i_depot) < 1e-6: # If i == depot, all outgoing edges have angle=0, avoid inf
                    angle_factor = 1.0
                else:
                    dot_product = np.dot(vector_ij, vector_i_depot)
                    magnitudes = np.linalg.norm(vector_ij) * np.linalg.norm(vector_i_depot)

                    #Avoid NaN if nodes are very close to each other.
                    if magnitudes < 1e-6:
                        angle_factor = 1.0 #Set to highest angle factor to allow exploring.
                    else:
                         cos_angle = dot_product / magnitudes
                         cos_angle = np.clip(cos_angle, -1.0, 1.0)
                         angle = np.arccos(cos_angle)

                         # Penalize edges with large angles
                         angle_factor = 1 - gamma * (angle / np.pi) # Normalise between 0 and 1

                # Combine the factors
                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor

    # Sparsify the matrix: Remove edges with low heuristic values
    max_val = np.max(heuristic_matrix)
    threshold = sparsity_threshold * max_val  # Dynamic threshold based on the max value

    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
