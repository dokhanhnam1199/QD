```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for the Capacitated Vehicle Routing Problem (CVRP) based on
    stochastic solution sampling, considering distance, demand ratio, and angle,
    with improved handling and depot prioritization.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge
                   in a solution (n x n).
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Heuristic 1: Inverse distance (more robust)
    distance_heuristic = 1 / (distance_matrix + np.mean(distance_matrix[distance_matrix > 0]))  # Avoids inf and normalizes

    # Heuristic 2: Demand ratio penalty (better scaling)
    demand_ratio_penalty = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                demand_ratio_penalty[i, j] = (demands[i] + demands[j]) / (2 * capacity)  # Ratio of combined demand to capacity

    # Heuristic 3: Angle penalty (more comprehensive)
    angle_penalty = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                # Try to find a suitable k for angle calculation
                k_candidates = [k for k in range(n) if k != i and k != j]
                if k_candidates:
                    best_k = None
                    min_distance_sum = float('inf')
                    for k in k_candidates:
                        distance_sum = distance_matrix[j, k] + distance_matrix[k, 0]
                        if distance_sum < min_distance_sum:
                            min_distance_sum = distance_sum
                            best_k = k

                    if best_k is not None:
                        vector_ij = coordinates[j] - coordinates[i]
                        vector_jk = coordinates[best_k] - coordinates[j]

                        # Normalize vectors to calculate angle correctly
                        norm_ij = np.linalg.norm(vector_ij)
                        norm_jk = np.linalg.norm(vector_jk)

                        if norm_ij > 0 and norm_jk > 0:  # Check for zero norms
                            vector_ij = vector_ij / norm_ij
                            vector_jk = vector_jk / norm_jk

                            dot_product = np.dot(vector_ij, vector_jk)
                            angle = np.arccos(np.clip(dot_product, -1.0, 1.0))  # Clip to avoid domain errors
                            angle_penalty[i, j] = angle / np.pi  # Normalize to [0,1]

    # Combine heuristics (refined)
    heuristics_matrix = distance_heuristic * (1 - demand_ratio_penalty) * (1 - angle_penalty)

    # Depot prioritization (stronger)
    for i in range(1, n):
        heuristics_matrix[0, i] *= 3.0  # Increased weight
        heuristics_matrix[i, 0] *= 3.0  # Increased weight

    # Sparsify the matrix (adaptive)
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], 30) # Adjusted percentile
    heuristics_matrix[heuristics_matrix < threshold] = 0

    # Remove self loops
    for i in range(n):
        heuristics_matrix[i, i] = 0

    return heuristics_matrix
```
