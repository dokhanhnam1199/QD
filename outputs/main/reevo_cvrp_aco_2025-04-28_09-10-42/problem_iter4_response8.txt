```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on normalized distance, demand, and angle, with dynamic sparsification.

    Args:
        distance_matrix: Distance matrix between nodes.
        coordinates: Coordinates of the nodes.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        A matrix indicating the desirability of each edge.
    """

    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Parameters to control the influence of each factor
    alpha = 0.6   # Weight for distance
    beta = 0.3    # Weight for demand
    gamma = 0.1   # Weight for angle

    # Normalize distance matrix
    max_distance = np.max(distance_matrix)
    normalized_distance = distance_matrix / max_distance if max_distance > 0 else np.zeros_like(distance_matrix)


    # Normalize demand to [0, 1]
    normalized_demands = demands / capacity

    # Calculate angles between nodes relative to the depot
    depot_x, depot_y = coordinates[0]
    angles = np.zeros(n)
    for i in range(1, n):
        x, y = coordinates[i]
        angles[i] = np.arctan2(y - depot_y, x - depot_x)

    # Normalize angles to [0, 1]
    max_angle = np.pi  # Maximum possible angle difference
    normalized_angles = np.abs(angles[:, None] - angles[None, :]) / max_angle  # Pairwise angle differences


    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor: shorter distance is better
                distance_factor = 1 - normalized_distance[i, j]

                # Demand factor: Prefer edges connecting nodes with high demand (scaled down)
                demand_factor = normalized_demands[i] + normalized_demands[j]

                # Angle factor: Penalize sharp turns relative to the depot.  Smaller normalized angle difference is better
                angle_factor = 1 - normalized_angles[i, j]


                # Combine the factors
                heuristics_matrix[i, j] = (alpha * distance_factor +
                                           beta * demand_factor +
                                           gamma * angle_factor)

    # Sparsify the matrix: Keep only top k connections per node
    k = max(2, int(np.sqrt(n)))  # Number of connections to keep.  Dynamically scale based on the size of the graph, min of 2
    for i in range(n):
        row = heuristics_matrix[i, :]
        indices = np.argsort(row)[-k:]  # Indices of the top k values
        mask = np.ones(n, dtype=bool)
        mask[indices] = False
        heuristics_matrix[i, mask] = 0  # Set non-top-k elements to zero

    return heuristics_matrix
```
