```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP)
    via stochastic solution sampling.

    This version incorporates distance, demand, and angular considerations
    to determine the desirability of including an edge in the solution.
    It also sparsifies the matrix.

    Args:
        distance_matrix: A numpy array of shape (n, n) representing the distance
                         between each pair of nodes.
        coordinates: A numpy array of shape (n, 2) representing the Euclidean
                     coordinates of each node.
        demands: A numpy array of shape (n,) representing the demand of each node.
        capacity: An integer representing the capacity of each vehicle.

    Returns:
        A numpy array of shape (n, n) representing the prior indicators of how
        promising it is to include each edge in a solution.  Higher values
        indicate more promising edges. Sparsified such that many entries are zero.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (tuned experimentally)
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.2
    sparsification_threshold = 0.1 # Remove edges below this fraction of max score
    depot_penalty = 2.0 # Higher penalty for returning to depot early.  Avoid very short subtours.

    max_demand = np.max(demands)


    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            distance = distance_matrix[i, j]

            # Incorporate demand: Penalize edges connecting nodes with very high demand.
            # Also penalize nodes with high demand that aren't close to the depot
            demand_factor = 1.0
            if i != 0 and j != 0: #not to or from depot
                demand_factor = 1.0 - (demands[i] + demands[j]) / (2*capacity)
                demand_factor = max(0.0, demand_factor) #bound at zero
            elif i ==0: #origin
                 demand_factor = 1.0 - (demands[j]) / (capacity * depot_penalty) # Less tolerant for short routes starting from depot
                 demand_factor = max(0.0, demand_factor)
            elif j == 0: #returning to depot
                 demand_factor = 1.0 - (demands[i]) / (capacity * depot_penalty) #Less tolerant for short routes returning to depot.
                 demand_factor = max(0.0, demand_factor)


            # Incorporate angle:  Favor edges that create less sharp turns (more direct routes)
            # This is a rough approximation and could be improved with more neighbor consideration.
            angle_factor = 1.0
            if i != 0 and j!=0: #only add penalty when neither are the depot
                vector_i_depot = coordinates[0] - coordinates[i]
                vector_i_j = coordinates[j] - coordinates[i]

                # Normalize vectors
                norm_i_depot = np.linalg.norm(vector_i_depot)
                norm_i_j = np.linalg.norm(vector_i_j)

                if norm_i_depot > 0 and norm_i_j > 0:  #avoid division by zero
                    vector_i_depot = vector_i_depot / norm_i_depot
                    vector_i_j = vector_i_j / norm_i_j

                    dot_product = np.dot(vector_i_depot, vector_i_j)
                    angle_factor = (1 + dot_product) / 2  # Scale to [0, 1], higher is better (smaller angle)

            # Combine factors
            heuristic_matrix[i, j] = (
                (distance_weight / (distance + 1e-6))  # Add a small constant to prevent division by zero
                * (demand_factor ** demand_weight)
                * (angle_factor ** angle_weight)
            )

    #Sparsify the matrix
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        threshold = sparsification_threshold * max_heuristic
        heuristic_matrix[heuristic_matrix < threshold] = 0


    return heuristic_matrix
```
