```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix: A distance matrix (shape: n by n).
        coordinates: Euclidean coordinates of nodes (shape: n by 2).
        demands: A vector of customer demands (shape: n).
        capacity: The integer capacity of vehicle capacity.

    Returns:
        A matrix of the same shape as the distance_matrix, indicating how promising it is to include each edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate savings for each pair of nodes
    savings_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Node proximity to the depot (0)
    depot_proximity = distance_matrix[0, :]

    # Normalize demands to range [0, 1]
    normalized_demands = demands / np.max(demands)

    # Combine factors to create the heuristic matrix
    for i in range(n):
        for j in range(n):
            if i != j:
                # Prioritize shorter distances and higher savings
                heuristic_value = (
                    (1 / (distance_matrix[i, j] + 1e-6))  # Avoid division by zero
                    + (savings_matrix[i, j] / np.max(savings_matrix + 1e-6))
                    - 0.5 * (normalized_demands[i] + normalized_demands[j]) # slightly penalize high demands
                    - 0.1 * (depot_proximity[i] / np.max(depot_proximity))
                    - 0.1 * (depot_proximity[j] / np.max(depot_proximity))


                )

                heuristic_matrix[i, j] = heuristic_value

    # Sparsify the matrix (remove less promising edges)
    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 20)  # Keep top 80%
    heuristic_matrix[heuristic_matrix < threshold] = 0  # Set edges below the threshold to zero


    return heuristic_matrix
```
