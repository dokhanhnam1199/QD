```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP) using a combination of factors
    and sparsification.

    Args:
        distance_matrix (np.ndarray): A distance matrix of shape (n x n) representing the distances between nodes.
        coordinates (np.ndarray): A matrix of shape (n x 2) representing the Euclidean coordinates of the nodes.
        demands (np.ndarray): A vector of shape (n) representing the demands of each node.
        capacity (int): The capacity of each vehicle.

    Returns:
        np.ndarray: A matrix of shape (n x n) representing prior indicators of how promising it is to include each edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Calculate a combined heuristic score for each edge
    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor (shorter distances are more promising)
                distance_factor = 1 / (distance_matrix[i, j] + 1e-9)  # Adding a small value to avoid division by zero

                # Demand factor:  Consider how large nodes are
                demand_i = demands[i] if i != 0 else 0
                demand_j = demands[j] if j != 0 else 0
                demand_factor = 1/(demand_i + demand_j + 1e-9) # If this is a high demand, its less promising to put together

                # Angle factor (edges that make smaller turns are more promising). Attempt to avoid self-intersecting solutions
                # Calculating angle between i -> j and the line connecting j to the depot.
                # Using Law of Cosines to approximate the angle
                a = distance_matrix[i, j]
                b = distance_matrix[j, 0]
                c = distance_matrix[i, 0]
                angle = np.arccos(np.clip((b**2 + a**2 - c**2) / (2 * a * b + 1e-9), -1.0, 1.0)) # Add clip to prevent Domain Error
                angle_factor = 1/(angle + 1e-9)  #Smaller angle == more promising.
                heuristics_matrix[i, j] = distance_factor * demand_factor * angle_factor
            else:
                heuristics_matrix[i, j] = 0

    # Sparsify the matrix by setting unpromising elements to zero
    # Only keep the top k edges for each node (parameter tuned)
    k = int(np.sqrt(n)) #Heuristic: k is proportional to the size of the graph
    for i in range(n):
        row = heuristics_matrix[i, :]
        indices = np.argsort(row)[::-1]  # Indices in descending order of heuristic value
        
        #Zeroing out everything past the kth index
        for j in range(n):
          if j not in indices[:k]:
            heuristics_matrix[i,j] = 0.0

    return heuristics_matrix
```
