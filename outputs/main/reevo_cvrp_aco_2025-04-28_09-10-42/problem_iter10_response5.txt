```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version prioritizes savings and inverse distance. It incorporates adaptive sparsification based on percentile cutoffs
    and distance thresholds, along with a combined distance/demand penalty. And normalizes the heuristic matrix.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Calculate savings matrix (Clarke-Wright Savings Algorithm)
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Demand factor
    demand_factor = demands / capacity  # Ratio of demand to capacity. Smaller is generally better
    demand_factor = np.clip(demand_factor, 0, 1)  # Ensure the demand factor is within [0, 1]

    # Combined Distance/Demand Penalty and Savings
    for i in range(n):
        for j in range(n):
            if i != j:
                # Combined distance and demand penalty.  Using savings matrix.
                heuristics_matrix[i, j] = savings_matrix[i, j] / (distance_matrix[i, j] * (1 + demand_factor[i] + demand_factor[j]) + 1e-9)

    # Adaptive sparsification based on heuristic values and percentile cutoff
    heuristic_values = heuristics_matrix[np.triu_indices_from(heuristics_matrix, k=1)]  # Upper triangle values
    cutoff_percentile = 40  # Dynamically adjusted sparsification
    cutoff_value = np.percentile(heuristic_values, cutoff_percentile)
    heuristics_matrix[heuristics_matrix < cutoff_value] = 0.0

    # Further sparsification based on distance - dynamic threshold
    distance_threshold = np.mean(distance_matrix) * 1.2  # Dynamic scaling
    heuristics_matrix[distance_matrix > distance_threshold] = 0.0

    # Depot connection encouragement - small bias towards connecting to the depot
    for i in range(1, n):
        heuristics_matrix[0, i] *= 1.05
        heuristics_matrix[i, 0] *= 1.05

    # Normalize the heuristics matrix
    max_heuristic = np.max(heuristics_matrix)
    if max_heuristic > 0:
        heuristics_matrix = heuristics_matrix / max_heuristic

    return heuristics_matrix
```
