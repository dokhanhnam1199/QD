```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP)
    via stochastic solution sampling.

    This version incorporates several factors to estimate the "promisingness" of an edge,
    including distance, demand, angle, and depot proximity.  It also sparsifies the matrix
    by zeroing out very unpromising edges.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Demand of each node (n).  demands[0] is the depot demand (usually 0).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Matrix of heuristic values, indicating the "promisingness" of each edge (n x n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (can be tuned)
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.3
    depot_proximity_weight = 0.7
    sparsity_threshold = 0.1 # adjust as needed

    # Calculate angles relative to the depot
    depot_angles = np.arctan2(coordinates[:, 1] - coordinates[0, 1], coordinates[:, 0] - coordinates[0, 0])

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance factor: Shorter distances are more promising
            distance_factor = 1 / (distance_matrix[i, j] + 1e-9) # Add a small number to prevent divide by zero

            # Demand factor: Penalize edges connecting nodes with high demands.
            demand_factor = 1 / (demands[i] + demands[j] + 1e-9)

            # Angle factor: Prefer nodes in a similar direction from the depot
            angle_diff = np.abs(depot_angles[i] - depot_angles[j])
            angle_factor = 1 / (np.sin(angle_diff / 2)**2 + 1e-9) # Ensure no divide by zero even at small angles

            # Depot proximity factor: Edges closer to the depot might be more important for routing
            depot_distance_i = distance_matrix[0, i]
            depot_distance_j = distance_matrix[0, j]
            depot_proximity_factor = 1 / (depot_distance_i + depot_distance_j + 1e-9)

            # Combine the factors
            heuristic_matrix[i, j] = (
                distance_weight * distance_factor +
                demand_weight * demand_factor +
                angle_weight * angle_factor +
                depot_proximity_weight * depot_proximity_factor
            )

    # Normalize heuristic values to [0, 1]
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
      heuristic_matrix = heuristic_matrix / max_heuristic
    
    # Sparsify the matrix: Zero out low-value edges
    threshold = sparsity_threshold * np.mean(heuristic_matrix) #Dynamic threshold
    heuristic_matrix[heuristic_matrix < threshold] = 0
    return heuristic_matrix
```
