```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version combines distance, demand, and angular proximity to estimate the desirability of each edge.
    It also sparsifies the matrix by setting values to zero for edges that are deemed unlikely to be in the optimal solution.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (same shape as distance_matrix).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters (can be tuned)
    alpha = 1.0  # Distance factor
    beta = 0.5  # Demand factor
    gamma = 0.5 # Angular proximity factor
    sparsity_threshold = 2.0 # Threshold for sparsifying the matrix


    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance component: Shorter distances are more desirable
                distance_factor = 1 / distance_matrix[i, j]

                # Demand component: Edges connecting to nodes with high demand are penalized if demand exceeds capacity.
                # It is desirable if combining two demands does not largely exceed capacity.
                demand_factor = min(1.0, (capacity / (demands[i] + demands[j]))) if (demands[i] + demands[j]) > 0 else 1.0

                # Angular proximity component: Encourage edges that make smaller turns.  Calculated using depot as origin
                if i == 0:
                    angle_i = 0
                else:
                    vector_i = coordinates[i] - coordinates[0]
                    angle_i = np.arctan2(vector_i[1], vector_i[0])

                if j == 0:
                    angle_j = 0
                else:
                    vector_j = coordinates[j] - coordinates[0]
                    angle_j = np.arctan2(vector_j[1], vector_j[0])

                angular_proximity = np.exp(-abs(angle_i-angle_j)) # Values between 0 and 1. Closer the angle, closer the number to 1

                heuristic_matrix[i, j] = (alpha * distance_factor + beta * demand_factor + gamma * angular_proximity)

    # Sparsify the matrix: remove edges with very low heuristic values
    mean_heuristic = np.mean(heuristic_matrix)
    heuristic_matrix[heuristic_matrix < (mean_heuristic / sparsity_threshold)] = 0

    # Ensure no division by zero
    heuristic_matrix[distance_matrix == 0] = 0


    return heuristic_matrix
```
