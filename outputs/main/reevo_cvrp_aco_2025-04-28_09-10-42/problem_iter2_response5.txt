```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix: A distance matrix (shape: n by n).
        coordinates: Euclidean coordinates of nodes (shape: n by 2).
        demands: A vector of customer demands (shape: n).
        capacity: The vehicle capacity.

    Returns:
        A matrix of the same shape as distance_matrix, indicating how promising it is to include each edge in a solution.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters for tuning the heuristics
    alpha = 1.0  # Weight for distance
    beta = 1.0   # Weight for demand consideration
    gamma = 0.5  # Weight for closeness to depot
    delta = 0.5 # Weight for savings

    # Calculate depot distances
    depot_distances = distance_matrix[0, :]

    # Calculate savings (Clarke-Wright savings heuristic)
    savings = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings[j, i] = savings[i, j]
    max_savings = np.max(savings) if np.max(savings) > 0 else 1 # Avoid division by zero

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor: Shorter distances are more promising
                distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Adding a small constant to avoid division by zero

                # Demand factor: Avoid edges that would likely lead to capacity violations early on
                demand_factor = 1.0
                if i != 0 and j !=0:
                    demand_factor =  np.exp(-demands[i]/capacity) * np.exp(-demands[j]/capacity) # Penalize edges with high demand nodes

                # Closeness to depot factor:
                depot_factor = np.exp(-gamma * (depot_distances[i] + depot_distances[j])/np.max(depot_distances))

                #Savings factor
                savings_factor = savings[i,j]/max_savings


                heuristic_matrix[i, j] = distance_factor**alpha * demand_factor**beta * depot_factor * savings_factor**delta

    # Sparsify the matrix: Keep only the most promising edges for each node
    sparsity_threshold = 0.2 # Only keep the top 20% of edges
    for i in range(n):
        row = heuristic_matrix[i, :]
        threshold = np.quantile(row[row > 0], 1 - sparsity_threshold)  # Ignore zero values when finding the quantile

        heuristic_matrix[i, row < threshold] = 0  # Remove edges with low promise

    return heuristic_matrix
```
