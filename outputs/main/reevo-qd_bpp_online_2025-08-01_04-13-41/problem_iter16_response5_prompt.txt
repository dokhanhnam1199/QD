{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements an enhanced \"Best Fit\" heuristic for online Bin Packing,\n    aiming to minimize the total number of bins used. It strategically evaluates\n    choices by:\n    1. Filtering out invalid options.\n    2. Prioritizing bins that minimize remaining waste.\n    3. Aggressively seeking perfect fits.\n    4. Introducing a nuanced tie-breaking rule for non-perfect fits.\n\n    Strategic Enhancements:\n    - **Filter Invalid Choices**: Bins where the item size `item` exceeds the\n      `bins_remain_cap` are assigned an extremely low priority (`-np.inf`),\n      effectively disqualifying them from selection.\n    - **Core Best Fit Logic**: For bins where the item fits, the base priority\n      is derived from the negative of the `potential_remaining_cap` (i.e.,\n      `bins_remain_cap - item`). This ensures that bins leaving the smallest\n      amount of free space receive a higher (less negative) priority,\n      aligning with the goal of compact bin utilization.\n    - **Strong Perfect Fit Bonus**: A significant bonus (`PERFECT_FIT_BONUS`)\n      is added to bins that achieve a perfectly zero `potential_remaining_cap`.\n      This strongly encourages \"finishing off\" bins, as a perfect fit maximally\n      utilizes space and reduces the need for new bins. This bonus is\n      calibrated to always make a perfect fit the top priority over any\n      non-perfect fit, regardless of its `potential_remaining_cap`.\n    - **Worst Fit Tie-Breaking for Non-Perfect Fits**: When multiple non-perfect\n      fitting bins result in the exact same best `potential_remaining_cap`\n      (and thus the same base priority score), a very small positive perturbation\n      is added based on the *original* `bins_remain_cap`. This subtly prefers\n      bins that initially had more capacity among equally 'best-fitting' options.\n      The rationale is to potentially keep bins with smaller initial capacities\n      available for future smaller items if multiple optimal choices exist for\n      the current item. This tie-breaking factor is set to be small enough\n      not to override the primary Best Fit ordering or the Perfect Fit Bonus.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value. Bins where the item does not fit\n    # will retain this value, making them unsuitable for selection.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For fitting bins, set the base priority according to Best Fit.\n    # A smaller positive `potential_remaining_cap` (meaning a fuller bin) results\n    # in a higher priority (less negative score).\n    priorities[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    # --- Strategic Enhancement 1: Strong Perfect Fit Bonus ---\n    # A bonus that ensures perfect fits are prioritized above all other fits.\n    # It must be greater than the maximum possible negative score (which is\n    # approximately -max_bin_capacity if all items fit).\n    # A value like 1.0 is sufficient if remaining capacities are non-negative.\n    PERFECT_FIT_BONUS = 1.0\n\n    # Identify bins that achieve a perfect fit (remaining capacity is effectively zero).\n    perfect_fit_mask = np.isclose(potential_remaining_cap, 0.0)\n\n    # Apply the bonus only to bins that result in a perfect fit.\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    # --- Strategic Enhancement 2: Worst Fit Tie-Breaking for Non-Perfect Fits ---\n    # This factor is used to break ties among non-perfect best-fit candidates.\n    # It's a very small value to ensure it only influences selection when primary\n    # scores are identical.\n    EPSILON_FOR_TIE_BREAKING = 1e-9\n\n    # Identify bins that fit but are NOT perfect fits.\n    non_perfect_fitting_bins_mask = fitting_bins_mask & (~perfect_fit_mask)\n\n    # Among these non-perfect, fitting bins, add a small bias proportional to their\n    # *original* remaining capacity. This means if two bins yield the exact same\n    # 'best fit' score (same potential_remaining_cap), the one that started\n    # with more room will be slightly preferred.\n    priorities[non_perfect_fitting_bins_mask] += \\\n        EPSILON_FOR_TIE_BREAKING * bins_remain_cap[non_perfect_fitting_bins_mask]\n\n    return priorities\n\n[Reflection]\nFilter invalid choices, minimize remaining space (Best Fit), reward perfect fits, use strategic tie-breaking.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}