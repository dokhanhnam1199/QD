{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function extends the \"Best Fit\" heuristic from priority_v1 by\n    incorporating specific rewards for perfect fits and penalties for\n    creating \"awkward\" small remaining gaps, aiming for better long-term\n    bin utilization as described in the reflection.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n\n    # --- Heuristic Constants ---\n    # A large bonus for perfect fits (remaining capacity is exactly zero)\n    # This value should be large enough to make a perfect fit significantly\n    # more desirable than any non-perfect fit.\n    PERFECT_FIT_BONUS = 100.0\n\n    # A threshold to define an \"awkward\" remaining gap.\n    # If the remaining capacity after placing the item is positive but\n    # falls within (0, AWKWARD_GAP_THRESHOLD], it's considered awkward.\n    # This value is heuristic and might need tuning based on the expected\n    # range of item sizes and bin capacities. For normalized capacities (e.g., 0-1), 0.1 is a reasonable start.\n    AWKWARD_GAP_THRESHOLD = 0.1\n\n    # A penalty applied to bins that would result in an \"awkward\" remaining gap.\n    # This penalty aims to discourage leaving small, hard-to-fill spaces.\n    AWKWARD_GAP_PENALTY = 10.0\n\n    # Epsilon for robust floating-point comparisons to zero (e.g., for perfect fit checks)\n    EPSILON_FLOAT_COMP = 1e-9\n\n    # Calculate the potential remaining capacity if the item were placed in each bin.\n    # A negative value strictly means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to an extremely low value for all bins.\n    # This ensures that bins where the item does not fit are never selected\n    # unless no bin can accommodate the item (in which case a new bin should be opened externally).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item conceptually fits (remaining capacity is non-negative,\n    # allowing for tiny negative values due to floating point inaccuracies if they are effectively zero).\n    fitting_bins_mask = potential_remaining_cap >= -EPSILON_FLOAT_COMP\n\n    # Apply the base \"Best Fit\" heuristic for fitting bins:\n    # Prioritize bins that would leave the smallest remaining capacity (least waste).\n    # Using the negative of potential_remaining_cap means smaller positive remainders yield\n    # larger (less negative) priority scores.\n    # For bins that fit but result in a tiny negative 'potential_remaining_cap' due to precision,\n    # this will result in a tiny positive priority, which is desirable (very close to perfect fit).\n    priorities[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    # --- Reward Perfect Fits ---\n    # Identify bins where the item fits perfectly (remaining capacity is effectively zero).\n    # We use np.abs for robustness with floating point numbers (e.g., -1e-17 is considered zero).\n    perfect_fit_mask = np.abs(potential_remaining_cap) < EPSILON_FLOAT_COMP\n    # Ensure this bonus is only applied to bins that were determined to be fitting.\n    perfect_fit_mask = perfect_fit_mask & fitting_bins_mask\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    # --- Penalize Awkward Future Gaps ---\n    # Identify bins where the item fits, and the resulting remaining capacity is positive\n    # but falls within the defined \"awkward\" range (e.g., too small to be generally useful,\n    # but not zero).\n    awkward_gap_mask = (potential_remaining_cap > EPSILON_FLOAT_COMP) & \\\n                       (potential_remaining_cap <= AWKWARD_GAP_THRESHOLD)\n    # Ensure this penalty is only applied to bins that were determined to be fitting.\n    awkward_gap_mask = awkward_gap_mask & fitting_bins_mask\n    priorities[awkward_gap_mask] -= AWKWARD_GAP_PENALTY\n\n    return priorities\n\n[Reflection]\nStrategically prioritize: minimize waste, reward perfect fits, avoid awkward gaps for better utilization.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}