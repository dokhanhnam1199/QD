{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function refines the Best Fit heuristic by explicitly rewarding perfect fits\n    and prioritizing snug, immediate fits. It addresses the \"Prior reflection\" points:\n    1.  Filter invalid: Bins where the item does not fit are assigned an extremely low priority.\n    2.  Reward perfect fits: Bins that result in zero remaining capacity are given a very high priority bonus.\n    3.  Prioritize snug, immediate ones: For non-perfect fits, bins leaving the smallest positive\n        remaining capacity are preferred (standard Best Fit).\n    4.  Penalize awkward future gaps: Implicitly addressed by strongly preferring perfect fits\n        (which eliminate awkward fragmentation for that bin) and minimizing remaining waste otherwise.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value indicates the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # This ensures bins where the item does not fit are never selected unless\n    # no bin can fit the item (in which case the calling logic should open a new bin).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # Apply priorities only to fitting bins.\n    if np.any(fitting_bins_mask):\n        # Extract potential remaining capacities for only the fitting bins.\n        fitting_potential_rem_cap = potential_remaining_cap[fitting_bins_mask]\n\n        # Identify perfect fits: where the remaining capacity would be exactly zero.\n        perfect_fit_mask = fitting_potential_rem_cap == 0\n\n        # Define a large bonus for perfect fits. This ensures they are always chosen\n        # over any other type of fit if available.\n        PERFECT_FIT_BONUS = 1e9  # A sufficiently large positive number\n\n        # Assign the high bonus to bins that are a perfect fit.\n        # We need to map the perfect_fit_mask (which applies to fitting_potential_rem_cap)\n        # back to the original `priorities` array using the `fitting_bins_mask`.\n        priorities[fitting_bins_mask & (potential_remaining_cap == 0)] = PERFECT_FIT_BONUS\n\n        # For non-perfect fits (snug fits), apply the Best Fit logic:\n        # Prioritize bins that leave the smallest positive remaining capacity.\n        # This means using the negative of the remaining capacity as the priority score.\n        # These scores will be negative (or zero for v1 logic for perfect fit, but v2 handles it separately),\n        # making them lower than the PERFECT_FIT_BONUS but higher than -np.inf.\n        snug_fit_mask = ~perfect_fit_mask\n        \n        # Apply the Best Fit logic to the remaining snug fitting bins.\n        # Again, ensure correct indexing back to the original `priorities` array.\n        priorities[fitting_bins_mask & (potential_remaining_cap > 0)] = \\\n            -potential_remaining_cap[fitting_bins_mask & (potential_remaining_cap > 0)]\n\n    return priorities\n\n[Reflection]\nFilter invalid options. Reward optimal fits. Minimize remaining capacity for other choices.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}