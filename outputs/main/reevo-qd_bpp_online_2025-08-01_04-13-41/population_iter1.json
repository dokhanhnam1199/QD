[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function implements a \"Best Fit\" like strategy:\n    It prioritizes bins that will have the least remaining capacity after the item is placed.\n    Bins that cannot fit the item are given a very low priority (negative infinity).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item were hypothetically placed in each bin\n    potential_remainders = bins_remain_cap - item\n\n    # Initialize priority scores\n    # If a bin can fit the item (potential_remainders >= 0):\n    #   The score is the negative of the potential remaining capacity.\n    #   This makes bins with less remaining capacity (smaller positive potential_remainders)\n    #   have higher (less negative or zero) scores, implementing a Best Fit strategy.\n    # If a bin cannot fit the item (potential_remainders < 0):\n    #   The score is set to negative infinity (np.NINF) to ensure it's never chosen\n    #   unless no other viable bins exist (at which point a new bin would typically be opened).\n    priorities = np.where(potential_remainders >= 0, -potential_remainders, np.NINF)\n\n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 29, in priority_v2\n    \n  File \"/home/dokhanhnam1199/.local/lib/python3.10/site-packages/numpy/__init__.py\", line 400, in __getattr__\n    raise AttributeError(\nAttributeError: `np.NINF` was removed in the NumPy 2.0 release. Use `-np.inf` instead.\n7\n1\n"
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a \"Best Fit\" like heuristic. It prioritizes\n    bins that, after the item is placed, would have the smallest remaining\n    capacity (i.e., leaving the least 'waste'). Bins where the item does\n    not fit are given an extremely low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score (least negative in this case) will be selected.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # Using -np.inf ensures that bins where the item does not fit will never\n    # be selected by argmax, unless no bin can fit the item (in which case\n    # all priorities would be -np.inf, and the first bin would be chosen,\n    # or an error handling mechanism for opening a new bin would be needed elsewhere).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For fitting bins, set the priority.\n    # We want to minimize the remaining capacity (potential_remaining_cap),\n    # so we use its negative as the priority score.\n    # A smaller positive remaining capacity (e.g., 1.0) will result in a\n    # larger (less negative) priority score (e.g., -1.0).\n    # A larger positive remaining capacity (e.g., 10.0) will result in a\n    # smaller (more negative) priority score (e.g., -10.0).\n    priorities[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit heuristic-like strategy.\n\n    This heuristic prioritizes bins that, after accommodating the item, would\n    have the smallest remaining capacity. The goal is to \"snugly fit\" the item\n    and potentially fill up bins quickly, thus reducing the total number of bins used.\n\n    Priority Logic:\n    1. For bins where the item fits: The priority is calculated as the negative\n       of the remaining capacity after placing the item. This means a smaller\n       positive remaining capacity (a tighter fit) will result in a larger\n       (closer to zero) priority score. A perfect fit will yield a priority of 0.\n    2. For bins where the item does not fit: A very low priority (e.g., negative\n       infinity) is assigned, effectively making these bins undesirable.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the item were placed in it.\n    # A negative value means the item does not fit.\n    remaining_after_fit = bins_remain_cap - item\n\n    # Initialize all priorities to a very low value. This ensures bins where the\n    # item doesn't fit are not selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Find the indices of bins where the item can actually fit (remaining capacity >= 0).\n    can_fit_indices = np.where(remaining_after_fit >= 0)\n\n    # For the bins where the item fits, calculate their priority.\n    # We want to minimize 'remaining_after_fit' among positive values.\n    # By taking the negative of 'remaining_after_fit', a smaller positive\n    # value results in a priority closer to zero (which is higher than negative values).\n    priorities[can_fit_indices] = -remaining_after_fit[can_fit_indices]\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic implements a variation of the \"Best Fit\" strategy for online bin packing.\n    It prioritizes bins that, if the item is placed, will leave the smallest amount of\n    remaining capacity (i.e., the item fits most \"snugly\"). Bins where the item does not\n    fit are assigned a very low (negative infinity) priority.\n\n    The score is calculated as `-(remaining_capacity - item_size)`.\n    A perfect fit (remaining_capacity - item_size = 0) yields a score of 0,\n    which is the highest possible score among bins that fit the item.\n    A looser fit (e.g., remaining_capacity - item_size = 5) yields a negative score (-5),\n    making it less preferred than a tighter fit (-2).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score is the most preferred.\n    \"\"\"\n    # Initialize priorities. Bins that cannot fit the item will retain a very low priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Find which bins the item can fit into\n    fits_mask = bins_remain_cap >= item\n\n    # For bins where the item fits, calculate the 'tightness' score.\n    # We want to minimize (bins_remain_cap - item) among fitting bins.\n    # By taking the negative of this difference, we convert the minimization\n    # problem into a maximization problem for the priority score.\n    # E.g., a perfect fit (diff=0) gets score 0.\n    # A tight fit (diff=2) gets score -2.\n    # A loose fit (diff=10) gets score -10.\n    # Maximize -> choose 0, then -2, then -10.\n    priorities[fits_mask] = -(bins_remain_cap[fits_mask] - item)\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version implements a Best-Fit (BF) inspired priority.\n    It prioritizes bins that, after accommodating the item, would have the\n    smallest remaining capacity. This encourages filling bins as much as\n    possible to leave larger empty bins for potentially larger future items.\n    Bins that cannot fit the item receive a very low (negative infinity) priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable bin.\n    \"\"\"\n    # Initialize priorities for all bins to a very low value (-infinity).\n    # This ensures that any bin that can accommodate the item will have a\n    # higher priority than those that cannot.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins that can accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit, calculate their priority score.\n    # The Best Fit strategy aims to minimize the remaining space after placement.\n    # This means we want to maximize `-(bins_remain_cap - item)`.\n    # Equivalently, we want to maximize `item - bins_remain_cap`.\n    # A perfect fit (bins_remain_cap == item) would result in a score of 0,\n    # which is the highest possible score. A score of -1 implies 1 unit of space\n    # left, -2 implies 2 units, etc. Higher values (closer to 0) are preferred.\n    fitting_bins_priorities = item - bins_remain_cap[can_fit_mask]\n\n    # Assign the calculated priorities back to the `priorities` array\n    # for the bins that can fit.\n    priorities[can_fit_mask] = fitting_bins_priorities\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This implementation uses a \"Target Fit\" heuristic. It aims to select\n    a bin such that, after placing the item, the remaining capacity is\n    as close as possible to a predefined 'target_remaining_capacity'.\n\n    This approach is \"creative\" in that it generalizes Best Fit (when\n    target_remaining_capacity is 0) and can be tuned to prefer leaving\n    a specific amount of space, potentially to accommodate items of a\n    certain size that might arrive later, or to avoid creating tiny,\n    unusable fragments of space.\n\n    Bins where the item does not fit are assigned a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, np.NINF, dtype=float)\n\n    # Define the target remaining capacity. This is a crucial parameter for this heuristic.\n    # It represents the ideal amount of space we want to leave in a bin after placing an item.\n    # For example:\n    # - If set to 0.0, this heuristic degenerates to a standard Best Fit.\n    # - If set to a small positive value (e.g., 0.1), it aims to leave space for a typical small item.\n    # - This value could ideally be determined by analyzing the distribution of item sizes,\n    #   but here it is set as a fixed heuristic parameter.\n    target_remaining_capacity = 0.1  # Example: aim to leave 0.1 units of space in a bin\n\n    # Calculate the hypothetical remaining capacity if the item were placed in each bin\n    hypothetical_remaining_after_placement = bins_remain_cap - item\n\n    # Create a mask for bins where the item actually fits (remaining capacity must be non-negative)\n    fits_mask = hypothetical_remaining_after_placement >= 0\n\n    # For bins where the item fits, calculate the priority score.\n    # We want to minimize the absolute difference between 'hypothetical_remaining_after_placement'\n    # and our 'target_remaining_capacity'.\n    # Therefore, the priority score is the negative of this absolute difference:\n    # A score closer to 0 (i.e., less negative) indicates a better fit towards the target.\n    # A perfect match to 'target_remaining_capacity' will yield a score of 0 (the highest possible).\n    \n    # Calculate scores only for bins where the item fits\n    valid_remaining = hypothetical_remaining_after_placement[fits_mask]\n    \n    # Calculate the priority score: negative absolute difference to the target\n    scores = -np.abs(valid_remaining - target_remaining_capacity)\n    \n    priorities[fits_mask] = scores\n\n    return priorities",
    "response_id": 5,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 24, in priority_v2\n    # Identify which bins currently have enough capacity to hold the item\n  File \"/home/dokhanhnam1199/.local/lib/python3.10/site-packages/numpy/__init__.py\", line 400, in __getattr__\n    raise AttributeError(\nAttributeError: `np.NINF` was removed in the NumPy 2.0 release. Use `-np.inf` instead.\n7\n1\n"
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This implementation prioritizes bins using a Best Fit strategy:\n    bins that will have the smallest remaining capacity after the item is placed\n    are given higher priority. A perfect fit receives the highest possible score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins where the item cannot fit will have a priority of 0.\n        Bins where the item fits will have a score inversely proportional\n        to the remaining capacity after placement, ensuring that smaller\n        remaining capacities yield higher scores.\n    \"\"\"\n    # Initialize all priorities to 0. Bins where the item cannot fit will retain this score,\n    # ensuring they are not chosen unless no bin can accommodate the item.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify which bins currently have enough capacity to hold the item\n    can_fit = bins_remain_cap >= item\n\n    # For only those bins where the item can fit, calculate the \"waste\" capacity\n    # that would remain if the item were placed in them.\n    remaining_after_placement = bins_remain_cap[can_fit] - item\n\n    # A small constant to prevent division by zero in case of a perfect fit (remaining_after_placement == 0).\n    # This also gives perfect fits (0 waste) an extremely high priority score, which is desirable.\n    epsilon = 1e-6 \n    \n    # Calculate the priority scores for the bins that can fit the item.\n    # The score is inversely proportional to the waste (remaining capacity + epsilon).\n    # This means less waste leads to a higher priority score.\n    scores_for_fitting_bins = 1.0 / (remaining_after_placement + epsilon)\n    \n    # Assign these calculated scores back to the corresponding bins in the priorities array\n    priorities[can_fit] = scores_for_fitting_bins\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Best-Fit-like strategy.\n\n    This heuristic aims to place the item into the bin where it fits \"most tightly\".\n    The priority score is calculated as the ratio of the item size to the bin's remaining capacity.\n    A higher ratio indicates a tighter fit (i.e., the bin's capacity is just slightly larger\n    than the item size), which is preferred. Bins where the item does not fit receive\n    a very low (negative infinity) priority.\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be non-negative.\n        bins_remain_cap: Array of remaining capacities for each bin. Assumed to be non-negative.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a very low value (-np.inf) for bins where the item cannot fit.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a mask for bins where the item can actually fit.\n    # An item fits if its size is less than or equal to the bin's remaining capacity.\n    # We also ensure bins have positive capacity when calculating the ratio for the denominator.\n    # If item is 0, it fits into any bin, and ratio will be 0/cap = 0, which is consistent.\n    can_fit_mask = (bins_remain_cap >= item) & (bins_remain_cap > 0)\n\n    # For bins where the item fits, calculate the priority score.\n    # The score is item / bin_capacity. A value closer to 1 indicates a tighter fit.\n    # This maximizes the \"fullness\" of the bin relative to the item size upon placement.\n    if np.any(can_fit_mask):\n        fitting_bins_capacities = bins_remain_cap[can_fit_mask]\n        \n        # Calculate the ratio for fitting bins.\n        # A smaller remaining capacity (closer to item size) yields a ratio closer to 1.\n        # This prioritizes bins that will be filled most completely by the current item.\n        scores_for_fitting_bins = item / fitting_bins_capacities\n        \n        priority_scores[can_fit_mask] = scores_for_fitting_bins\n\n    # Special handling for item = 0: if item is 0, it perfectly fits into any bin\n    # and fills none. All fitting bins would have a priority of 0.\n    # This is fine, as any fitting bin would be equally \"best\".\n    if item == 0:\n        # For item 0, it effectively \"fits\" into any bin with remaining capacity >= 0.\n        # The ratio item/capacity would be 0.\n        # So we update all bins that have non-negative capacity to priority 0.\n        # (Technically, bins_remain_cap should always be >= 0)\n        priority_scores[bins_remain_cap >= 0] = 0.0\n\n    return priority_scores",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on a \"Best Fit\" strategy.\n\n    This heuristic aims to place the item into the bin where it fits most tightly,\n    i.e., the bin that would have the smallest non-negative remaining capacity after\n    the item is placed. This strategy helps to leave larger contiguous spaces in\n    other bins for potentially larger future items and efficiently consolidate\n    items.\n\n    Bins that cannot accommodate the item are assigned a very low (negative infinity)\n    priority score, ensuring they are never chosen. For bins that can fit the item,\n    the priority is calculated as the negative of the remaining capacity after\n    the item is placed. A smaller positive remaining capacity (tighter fit) results\n    in a larger negative number (closer to zero), which corresponds to a higher\n    priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a very low value for bins that cannot fit the item.\n    # This ensures they are not chosen. Using -np.inf makes them strictly the lowest.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Identify which bins can accommodate the current item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity if the item were placed in suitable bins.\n    # This 'leftover' space is the key for the Best Fit heuristic.\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priorities for bins that can fit the item.\n    # The Best Fit strategy selects the bin that results in the smallest leftover space.\n    # To convert 'smallest leftover' to 'highest priority score', we take the negative\n    # of the leftover space.\n    # For example:\n    # - If leftover is 0.1, priority is -0.1.\n    # - If leftover is 0.5, priority is -0.5.\n    # - If leftover is 0.0 (perfect fit), priority is 0.0 (highest possible for a fit).\n    # Since 0.0 > -0.1 > -0.5, this correctly prioritizes tighter fits.\n    priorities[can_fit_mask] = -remaining_after_fit\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic implements a Best-Fit-like strategy, aiming to leave\n    the smallest possible positive remaining capacity in a bin after placing\n    the item. This minimizes fragmentation and makes efficient use of bin space.\n\n    The priority score is calculated as follows:\n    - For bins where the item fits (i.e., remaining_capacity >= item):\n        The priority is the negative of the remaining capacity after placing the item.\n        (priority = -(bins_remain_cap[i] - item)).\n        A perfect fit (remaining_capacity - item = 0) will yield a priority of 0,\n        which is the highest possible priority for a feasible bin, indicating it's\n        the 'best' fit. Larger positive remaining capacities will result in\n        more negative priority scores.\n    - For bins where the item does not fit (i.e., remaining_capacity < item):\n        A very low negative priority (negative infinity) is assigned, ensuring\n        these bins are never chosen unless no other bin is available.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Calculate the potential remaining capacity for each bin if the item were placed.\n    # This value can be negative if the item does not fit.\n    potential_remaining = bins_remain_cap - item\n    \n    # Initialize all priorities to a very low value (-infinity).\n    # This ensures bins where the item does not fit are effectively \"disqualified\"\n    # in an argmax operation.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    \n    # Define a small tolerance for floating point comparisons to handle\n    # cases where an item perfectly fits, but due to precision,\n    # `bins_remain_cap - item` might be slightly negative (e.g., -1e-17).\n    tolerance = 1e-9\n    \n    # Create a boolean mask for bins where the item can actually fit.\n    # A bin fits if its potential remaining capacity is non-negative,\n    # considering the small tolerance.\n    can_fit_mask = potential_remaining >= -tolerance\n    \n    # For bins where the item fits, calculate the priority score.\n    # We want to minimize the positive remaining space. By taking the negative\n    # of the potential remaining space, a smaller positive remaining space\n    # (e.g., 0.0 for a perfect fit) results in a larger priority score (0.0).\n    # A larger positive remaining space (e.g., 0.5) results in a smaller\n    # priority score (-0.5).\n    priorities[can_fit_mask] = -potential_remaining[can_fit_mask]\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]