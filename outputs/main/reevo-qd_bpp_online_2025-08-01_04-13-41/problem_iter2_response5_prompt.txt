{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version implements a Best-Fit (BF) inspired priority.\n    It prioritizes bins that, after accommodating the item, would have the\n    smallest remaining capacity. This encourages filling bins as much as\n    possible to leave larger empty bins for potentially larger future items.\n    Bins that cannot fit the item receive a very low (negative infinity) priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable bin.\n    \"\"\"\n    # Initialize priorities for all bins to a very low value (-infinity).\n    # This ensures that any bin that can accommodate the item will have a\n    # higher priority than those that cannot.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins that can accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit, calculate their priority score.\n    # The Best Fit strategy aims to minimize the remaining space after placement.\n    # This means we want to maximize `-(bins_remain_cap - item)`.\n    # Equivalently, we want to maximize `item - bins_remain_cap`.\n    # A perfect fit (bins_remain_cap == item) would result in a score of 0,\n    # which is the highest possible score. A score of -1 implies 1 unit of space\n    # left, -2 implies 2 units, etc. Higher values (closer to 0) are preferred.\n    fitting_bins_priorities = item - bins_remain_cap[can_fit_mask]\n\n    # Assign the calculated priorities back to the `priorities` array\n    # for the bins that can fit.\n    priorities[can_fit_mask] = fitting_bins_priorities\n\n    return priorities\n\n[Reflection]\nLeverage all available data. Define a clear strategic objective (e.g., Best-Fit) to intelligently prioritize bin choices, minimizing waste.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}