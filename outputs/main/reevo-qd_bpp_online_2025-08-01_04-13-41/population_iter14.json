[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a \"Best Fit\" like heuristic. It prioritizes\n    bins that, after the item is placed, would have the smallest remaining\n    capacity (i.e., leaving the least 'waste'). Bins where the item does\n    not fit are given an extremely low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score (least negative in this case) will be selected.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # Using -np.inf ensures that bins where the item does not fit will never\n    # be selected by argmax, unless no bin can fit the item (in which case\n    # all priorities would be -np.inf, and the first bin would be chosen,\n    # or an error handling mechanism for opening a new bin would be needed elsewhere).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For fitting bins, set the priority.\n    # We want to minimize the remaining capacity (potential_remaining_cap),\n    # so we use its negative as the priority score.\n    # A smaller positive remaining capacity (e.g., 1.0) will result in a\n    # larger (less negative) priority score (e.g., -1.0).\n    # A larger positive remaining capacity (e.g., 10.0) will result in a\n    # smaller (more negative) priority score (e.g., -10.0).\n    priorities[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic extends the \"Best Fit\" strategy by prioritizing bins that,\n    if the item is placed, will leave the smallest *fractional* amount of\n    remaining capacity relative to the size of the item itself. This aims to\n    minimize \"relative waste\" for each item placed, providing a more informed\n    decision based on the item's own magnitude (part of the problem state).\n\n    The score is calculated as `-(remaining_capacity_after_placement / item_size)`.\n\n    - Bins where the item does not fit are assigned a very low (negative infinity) priority.\n    - A perfect fit (remaining_capacity - item_size = 0) yields a score of 0,\n      as (0 / item_size) is 0. This is the highest possible score.\n    - A snug fit (e.g., remaining_capacity - item_size = 0.1 * item_size) yields\n      a score of -0.1.\n    - A loose fit (e.g., remaining_capacity - item_size = 1.0 * item_size) yields\n      a score of -1.0.\n\n    This approach is particularly effective when item sizes can vary significantly.\n    It normalizes the \"cost\" of the remaining space by the item's own magnitude,\n    making the heuristic more sensitive to waste proportions rather than just\n    absolute waste amounts.\n\n    Args:\n        item: Size of item to be added to the bin. Must be a non-negative float.\n              Typically, item sizes in Bin Packing are positive.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score is the most preferred.\n    \"\"\"\n    # Initialize priorities. Bins that cannot fit the item will retain a very low priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Find which bins the item can fit into\n    fits_mask = bins_remain_cap >= item\n\n    # Handle the edge case where item size is non-positive.\n    # Typically, item sizes in BPP are positive.\n    if item <= 0:\n        if item == 0:\n            # If item is zero, it occupies no space and creates no waste.\n            # It can conceptually fit into any bin that has non-negative capacity.\n            # Assign a perfect fit score (0) to all bins it \"fits\" into,\n            # indicating no relative waste.\n            priorities[fits_mask] = 0.0\n        else: # item < 0, which is typically invalid for bin packing\n            # All priorities remain -np.inf, effectively preventing placement.\n            pass\n        return priorities\n\n    # Calculate the remaining capacity after placing the item\n    remainder_after_placement = bins_remain_cap[fits_mask] - item\n\n    # For bins where the item fits, calculate the 'relative waste' score.\n    # We want to minimize (remainder_after_placement / item).\n    # By taking the negative of this ratio, we convert the minimization\n    # problem into a maximization problem for the priority score.\n    priorities[fits_mask] = -(remainder_after_placement / item)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a \"Best Fit\" like heuristic, similar to v1,\n    but re-scales the priority scores to be non-negative, where a higher\n    score indicates a better fit (i.e., less remaining capacity).\n\n    It prioritizes bins that, after the item is placed, would have the\n    smallest remaining capacity. Bins where the item does not fit are\n    given an extremely low (negative infinity) priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # Using -np.inf ensures that bins where the item does not fit will never\n    # be selected by argmax, unless no bin can fit the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For fitting bins, set the priority.\n    # We want to minimize the remaining capacity (potential_remaining_cap).\n    # To convert this into a positive score where higher is better:\n    # We find the maximum possible remaining capacity among the bins where the item fits.\n    # Then, we subtract the actual remaining capacity from this maximum.\n    # This ensures that a perfect fit (remaining_cap = 0) gets the highest score,\n    # and the \"worst\" fit among eligible bins (largest remaining_cap) gets a score of 0.\n    if np.any(fitting_bins_mask):\n        # Get remaining capacities for bins where the item fits\n        fitting_rem_caps = potential_remaining_cap[fitting_bins_mask]\n\n        # Find the maximum remaining capacity among these fitting bins.\n        # This serves as a baseline for scaling the priorities.\n        max_fitting_rem_cap = np.max(fitting_rem_caps)\n\n        # Calculate priority scores for fitting bins:\n        # A smaller `fitting_rem_caps` (tighter fit) results in a larger\n        # `max_fitting_rem_cap - fitting_rem_caps` value (higher priority).\n        # A perfect fit (fitting_rem_caps = 0) gets `max_fitting_rem_cap`.\n        # The worst fitting bin among the valid ones gets `0`.\n        priorities[fitting_bins_mask] = max_fitting_rem_cap - fitting_rem_caps\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a \"Best Fit\" strategy, augmented to\n    evaluate the 'impact' of the placement by applying a penalty if\n    the placement would result in a \"medium\" amount of remaining capacity\n    in the bin. This aims to minimize future waste by discouraging\n    the creation of awkwardly sized gaps that might be difficult to fill.\n    It prioritizes bins that would be nearly full (very small remainder)\n    or those that would still have a large remaining capacity after the item\n    is placed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score (least negative) will be selected.\n    \"\"\"\n    # In standard Bin Packing Problems, the bin capacity is fixed and known.\n    # If not provided as an explicit argument, a common approach is to assume 1.0\n    # for normalized problems, or infer it from the initial state if an empty bin\n    # (with full capacity) is guaranteed to be in bins_remain_cap.\n    # For a general solution, assuming 1.0 (typical for normalized problems) is reasonable.\n    # If item sizes are integers, BIN_CAPACITY would be an integer as well (e.g., 100).\n    BIN_CAPACITY = 1.0 # This should ideally be passed as an argument or global constant.\n                       # For demonstration, assuming a normalized bin capacity of 1.0.\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # -np.inf ensures that bins where the item does not fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For fitting bins, set the initial priority based on \"Best Fit\".\n    # We want to minimize the remaining capacity, so we use its negative as the priority score.\n    # A smaller positive remaining capacity (e.g., 0.05) will result in a\n    # larger (less negative) priority score (e.g., -0.05). A perfect fit (0 remaining)\n    # gets a score of 0, which is the highest.\n    priorities[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    # --- Augmentation based on \"Evaluate placement impact\" and \"minimizing future waste\" ---\n    # This part penalizes scenarios where placing the item leaves a 'medium' amount\n    # of remaining capacity. Such gaps can be considered \"waste\" because they are\n    # neither nearly full nor large enough to easily accommodate new large items.\n    # The thresholds for \"medium\" are relative to the BIN_CAPACITY and can be tuned.\n    medium_gap_lower_threshold = 0.1 * BIN_CAPACITY  # e.g., 10% of bin capacity\n    medium_gap_upper_threshold = 0.5 * BIN_CAPACITY  # e.g., 50% of bin capacity\n\n    # Define a penalty value. This should be significant enough to make a\n    # \"medium gap\" option less attractive than a non-penalized, less \"Best Fit\" option.\n    # A penalty proportional to the item size or a fixed large value can be used.\n    penalty_value = item * 2.0  # Example: 2 times the item size as penalty.\n                                 # This ensures the penalty scales with item magnitudes.\n\n    # Identify fitting bins that would result in a \"medium\" remaining capacity\n    medium_gap_mask = (potential_remaining_cap > medium_gap_lower_threshold) & \\\n                      (potential_remaining_cap < medium_gap_upper_threshold)\n\n    # Apply the penalty to the priorities of bins that fall into the \"medium gap\" range\n    # and where the item actually fits.\n    penalize_bins = fitting_bins_mask & medium_gap_mask\n    priorities[penalize_bins] -= penalty_value\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a \"Best Fit\" heuristic with a strategic enhancement\n    to strongly prioritize perfect fits. It aims to minimize waste by preferring\n    bins that, after the item is placed, would have the smallest remaining capacity.\n    Bins where the item does not fit are given an extremely low priority.\n    A significant bonus is awarded to bins that achieve a perfectly zero remaining\n    capacity, reflecting a more aggressive strategy to \"finish off\" bins completely\n    and optimally utilize space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score (least negative in this case) will be selected.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # This effectively filters out bins where the item does not fit.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For fitting bins, set the base priority. This is the core \"Best Fit\" logic:\n    # minimize the remaining capacity by using its negative as the priority.\n    # A smaller positive remaining capacity (e.g., 1.0) results in a larger\n    # (less negative) priority score (e.g., -1.0).\n    priorities[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    # Strategic Mutation: Introduce a significant bonus for perfect fits.\n    # This aligns with \"Strategically evaluate choices\" by explicitly valuing\n    # maximal bin utilization. A perfect fit means potential_remaining_cap is exactly 0.\n    # The bonus ensures that a bin achieving a perfect fit will always be preferred\n    # over any bin that has a non-zero remaining capacity, no matter how small.\n    # For example, if max possible remaining capacity is 100, then a general priority\n    # could be -100. A perfect fit is 0. A bonus of 1.0 ensures 0 + 1.0 = 1.0 is\n    # always greater than any negative priority resulting from a non-perfect fit.\n    PERFECT_FIT_BONUS = 1.0\n\n    # Identify bins where a perfect fit is achieved.\n    # We use np.isclose for float comparisons to account for potential floating point inaccuracies,\n    # though for typical BPP, exact zero might be common.\n    perfect_fit_mask = np.isclose(potential_remaining_cap, 0.0)\n\n    # Apply the bonus only to bins that achieve a perfect fit and also fit the item.\n    # The `perfect_fit_mask` implicitly means `potential_remaining_cap` is 0, which implies it fits.\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements an improved \"Best Fit\" like heuristic.\n    It prioritizes bins that, after the item is placed, would have the\n    smallest remaining capacity (i.e., leaving the least 'waste').\n    Beyond this Best-Fit base, it strategically rewards perfect fits\n    and penalizes the creation of awkward, small, non-zero gaps, aiming\n    for better long-term packing efficiency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score (least negative in this case) will be selected.\n    \"\"\"\n    # Define constants for strategic weighting. These values are heuristics\n    # and may need tuning based on the typical range of item sizes and bin capacities.\n    # A significant bonus for leaving exactly zero capacity, making it the highest priority.\n    PERFECT_FIT_BONUS = 100.0\n    # A penalty for creating small, non-zero gaps that might be difficult to fill later.\n    SMALL_GAP_PENALTY = -50.0\n    # The threshold below which a non-zero remaining capacity is considered \"small\" and awkward.\n    # For instance, if item/bin sizes are typically between 0 and 1, 0.1 represents 10% of capacity.\n    SMALL_GAP_THRESHOLD = 0.1\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # Bins where the item does not fit will remain at -np.inf, ensuring they are not selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # Extract potential remaining capacities only for the bins where the item fits.\n    fitting_rem_cap = potential_remaining_cap[fitting_bins_mask]\n\n    # 1. Base Best-Fit Score:\n    # We want to minimize the remaining capacity (fitting_rem_cap),\n    # so we use its negative as the priority score. A smaller positive\n    # remaining capacity (e.g., 1.0) results in a larger (less negative)\n    # priority score (e.g., -1.0).\n    fitting_priorities = -fitting_rem_cap\n\n    # 2. Apply Perfect Fit Bonus:\n    # Identify bins where the item fits exactly, leaving zero remaining capacity.\n    # These are highly rewarded to ensure they are picked over other \"Best Fit\" options.\n    perfect_fit_mask = (fitting_rem_cap == 0)\n    fitting_priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    # 3. Apply Small Gap Penalty:\n    # Identify bins that would be left with a small, non-zero remaining capacity.\n    # These gaps are penalized as they can be \"awkward\" or hard to utilize efficiently later.\n    # The condition `fitting_rem_cap > 0` ensures perfect fits are not penalized here.\n    small_gap_mask = (fitting_rem_cap > 0) & (fitting_rem_cap < SMALL_GAP_THRESHOLD)\n    fitting_priorities[small_gap_mask] += SMALL_GAP_PENALTY\n\n    # Assign the calculated priorities back to the main priorities array for fitting bins.\n    priorities[fitting_bins_mask] = fitting_priorities\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a refined \"Best Fit\" heuristic for online bin packing,\n    emphasizing optimal space utilization and strongly preferring perfect fits.\n    It assigns priority scores such that:\n    1. Bins where the item does not fit are given an extremely low priority.\n    2. For bins where the item fits, priority is inversely proportional to the\n       remaining capacity after placement, meaning smaller remaining capacity\n       yields higher priority (Best Fit principle). This maps priorities for\n       non-perfect fits to a range between 0 (for very large remaining capacity)\n       and 1 (for remaining capacity approaching zero).\n    3. Bins that achieve a perfectly zero remaining capacity are given the\n       highest possible distinct priority, ensuring they are always selected\n       over any non-perfect fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n    # Initialize priorities to a very low value. This effectively filters out\n    # bins where the item cannot be placed, ensuring they are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A positive value means the item fits, a negative value means it doesn't.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    can_fit_mask = remaining_after_placement >= 0\n\n    # Apply the core \"Best Fit\" logic for fitting bins:\n    # Prioritize bins that leave the least remaining space.\n    # Using 1.0 / (1.0 + x) maps smaller positive 'x' (remaining capacity) to\n    # higher priority values (closer to 1.0), and larger 'x' to lower values\n    # (closer to 0.0). This provides a positive and intuitive priority scale.\n    # We only apply this to bins where the item can fit.\n    priorities[can_fit_mask] = 1.0 / (1.0 + remaining_after_placement[can_fit_mask])\n\n    # Strategic enhancement: Assign a distinctly higher priority for perfect fits.\n    # This value must be greater than any priority achievable by non-perfect fits.\n    # Since the maximum priority for a non-perfect fit (when remaining_after_placement\n    # approaches 0) is 1.0, a value like 2.0 (or any value > 1.0) ensures this.\n    PERFECT_FIT_PRIORITY = 2.0\n\n    # Identify bins where a perfect fit is achieved.\n    # We use np.isclose for float comparisons to account for potential floating point inaccuracies.\n    perfect_fit_mask = np.isclose(remaining_after_placement, 0.0)\n\n    # For perfect fits, override their priority with the distinct highest score.\n    # This ensures that any bin resulting in a perfect fit will be chosen over\n    # any non-perfect fit, regardless of its 'best fit' score from the previous step.\n    # The `perfect_fit_mask` implicitly means `remaining_after_placement` is 0,\n    # which satisfies `can_fit_mask`.\n    priorities[perfect_fit_mask] = PERFECT_FIT_PRIORITY\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function extends the \"Best Fit\" heuristic from priority_v1 by\n    incorporating specific rewards for perfect fits and penalties for\n    creating \"awkward\" small remaining gaps, aiming for better long-term\n    bin utilization as described in the reflection.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n\n    # --- Heuristic Constants ---\n    # A large bonus for perfect fits (remaining capacity is exactly zero)\n    # This value should be large enough to make a perfect fit significantly\n    # more desirable than any non-perfect fit.\n    PERFECT_FIT_BONUS = 100.0\n\n    # A threshold to define an \"awkward\" remaining gap.\n    # If the remaining capacity after placing the item is positive but\n    # falls within (0, AWKWARD_GAP_THRESHOLD], it's considered awkward.\n    # This value is heuristic and might need tuning based on the expected\n    # range of item sizes and bin capacities. For normalized capacities (e.g., 0-1), 0.1 is a reasonable start.\n    AWKWARD_GAP_THRESHOLD = 0.1\n\n    # A penalty applied to bins that would result in an \"awkward\" remaining gap.\n    # This penalty aims to discourage leaving small, hard-to-fill spaces.\n    AWKWARD_GAP_PENALTY = 10.0\n\n    # Epsilon for robust floating-point comparisons to zero (e.g., for perfect fit checks)\n    EPSILON_FLOAT_COMP = 1e-9\n\n    # Calculate the potential remaining capacity if the item were placed in each bin.\n    # A negative value strictly means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to an extremely low value for all bins.\n    # This ensures that bins where the item does not fit are never selected\n    # unless no bin can accommodate the item (in which case a new bin should be opened externally).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item conceptually fits (remaining capacity is non-negative,\n    # allowing for tiny negative values due to floating point inaccuracies if they are effectively zero).\n    fitting_bins_mask = potential_remaining_cap >= -EPSILON_FLOAT_COMP\n\n    # Apply the base \"Best Fit\" heuristic for fitting bins:\n    # Prioritize bins that would leave the smallest remaining capacity (least waste).\n    # Using the negative of potential_remaining_cap means smaller positive remainders yield\n    # larger (less negative) priority scores.\n    # For bins that fit but result in a tiny negative 'potential_remaining_cap' due to precision,\n    # this will result in a tiny positive priority, which is desirable (very close to perfect fit).\n    priorities[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    # --- Reward Perfect Fits ---\n    # Identify bins where the item fits perfectly (remaining capacity is effectively zero).\n    # We use np.abs for robustness with floating point numbers (e.g., -1e-17 is considered zero).\n    perfect_fit_mask = np.abs(potential_remaining_cap) < EPSILON_FLOAT_COMP\n    # Ensure this bonus is only applied to bins that were determined to be fitting.\n    perfect_fit_mask = perfect_fit_mask & fitting_bins_mask\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    # --- Penalize Awkward Future Gaps ---\n    # Identify bins where the item fits, and the resulting remaining capacity is positive\n    # but falls within the defined \"awkward\" range (e.g., too small to be generally useful,\n    # but not zero).\n    awkward_gap_mask = (potential_remaining_cap > EPSILON_FLOAT_COMP) & \\\n                       (potential_remaining_cap <= AWKWARD_GAP_THRESHOLD)\n    # Ensure this penalty is only applied to bins that were determined to be fitting.\n    awkward_gap_mask = awkward_gap_mask & fitting_bins_mask\n    priorities[awkward_gap_mask] -= AWKWARD_GAP_PENALTY\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements an enhanced \"Best Fit\" heuristic for online Bin Packing,\n    aiming to minimize the total number of bins used. It strategically evaluates\n    choices by:\n    1. Filtering out invalid options.\n    2. Prioritizing bins that minimize remaining waste.\n    3. Aggressively seeking perfect fits.\n    4. Introducing a nuanced tie-breaking rule for non-perfect fits.\n\n    Strategic Enhancements:\n    - **Filter Invalid Choices**: Bins where the item size `item` exceeds the\n      `bins_remain_cap` are assigned an extremely low priority (`-np.inf`),\n      effectively disqualifying them from selection.\n    - **Core Best Fit Logic**: For bins where the item fits, the base priority\n      is derived from the negative of the `potential_remaining_cap` (i.e.,\n      `bins_remain_cap - item`). This ensures that bins leaving the smallest\n      amount of free space receive a higher (less negative) priority,\n      aligning with the goal of compact bin utilization.\n    - **Strong Perfect Fit Bonus**: A significant bonus (`PERFECT_FIT_BONUS`)\n      is added to bins that achieve a perfectly zero `potential_remaining_cap`.\n      This strongly encourages \"finishing off\" bins, as a perfect fit maximally\n      utilizes space and reduces the need for new bins. This bonus is\n      calibrated to always make a perfect fit the top priority over any\n      non-perfect fit, regardless of its `potential_remaining_cap`.\n    - **Worst Fit Tie-Breaking for Non-Perfect Fits**: When multiple non-perfect\n      fitting bins result in the exact same best `potential_remaining_cap`\n      (and thus the same base priority score), a very small positive perturbation\n      is added based on the *original* `bins_remain_cap`. This subtly prefers\n      bins that initially had more capacity among equally 'best-fitting' options.\n      The rationale is to potentially keep bins with smaller initial capacities\n      available for future smaller items if multiple optimal choices exist for\n      the current item. This tie-breaking factor is set to be small enough\n      not to override the primary Best Fit ordering or the Perfect Fit Bonus.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value. Bins where the item does not fit\n    # will retain this value, making them unsuitable for selection.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For fitting bins, set the base priority according to Best Fit.\n    # A smaller positive `potential_remaining_cap` (meaning a fuller bin) results\n    # in a higher priority (less negative score).\n    priorities[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    # --- Strategic Enhancement 1: Strong Perfect Fit Bonus ---\n    # A bonus that ensures perfect fits are prioritized above all other fits.\n    # It must be greater than the maximum possible negative score (which is\n    # approximately -max_bin_capacity if all items fit).\n    # A value like 1.0 is sufficient if remaining capacities are non-negative.\n    PERFECT_FIT_BONUS = 1.0\n\n    # Identify bins that achieve a perfect fit (remaining capacity is effectively zero).\n    perfect_fit_mask = np.isclose(potential_remaining_cap, 0.0)\n\n    # Apply the bonus only to bins that result in a perfect fit.\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    # --- Strategic Enhancement 2: Worst Fit Tie-Breaking for Non-Perfect Fits ---\n    # This factor is used to break ties among non-perfect best-fit candidates.\n    # It's a very small value to ensure it only influences selection when primary\n    # scores are identical.\n    EPSILON_FOR_TIE_BREAKING = 1e-9\n\n    # Identify bins that fit but are NOT perfect fits.\n    non_perfect_fitting_bins_mask = fitting_bins_mask & (~perfect_fit_mask)\n\n    # Among these non-perfect, fitting bins, add a small bias proportional to their\n    # *original* remaining capacity. This means if two bins yield the exact same\n    # 'best fit' score (same potential_remaining_cap), the one that started\n    # with more room will be slightly preferred.\n    priorities[non_perfect_fitting_bins_mask] += \\\n        EPSILON_FOR_TIE_BREAKING * bins_remain_cap[non_perfect_fitting_bins_mask]\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a \"Best Fit\" like heuristic, but with a crucial\n    modification: it strongly rewards perfect packing and penalizes choices\n    that result in \"awkward\" very small, non-zero remaining capacities.\n    The aim is to optimize long-term bin utilization by avoiding hard-to-fill gaps.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n                         It is assumed that bin capacities are on a similar scale\n                         (e.g., normalized, typically to 1.0) for the constant\n                         thresholds to be effective.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n    # Define constants for the heuristic. These values may need tuning\n    # depending on the typical scale of item sizes and bin capacities.\n    # We assume bin capacities are normalized, for example, between 0 and 1.0.\n\n    # This threshold defines what constitutes a \"very small, awkward gap\".\n    # For a bin with capacity 1.0, 0.05 means any remaining capacity less than 5%\n    # of the bin size (but greater than 0) will be penalized.\n    # This value could also be made relative to the item size (e.g., 0.1 * item)\n    # or the bin's total capacity if known.\n    threshold_awkward_gap = 0.05\n\n    # This is the additional penalty applied to bins that result in an\n    # \"awkward gap\". It must be sufficiently large to make an awkward gap\n    # less desirable than a slightly larger, non-awkward gap.\n    # For example, if R_awkward = 0.01 and R_better = 0.06 (just above threshold),\n    # we want score(-0.01 - penalty) < score(-0.06).\n    # A penalty of 0.5 is a significant reduction.\n    penalty_awkward_gap = 0.5\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # -np.inf ensures that bins where the item does not fit will never be selected,\n    # and a new bin would typically be opened if no bin has a priority > -inf.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For fitting bins, calculate the base priority (Best Fit: minimize waste)\n    # A smaller positive remaining capacity results in a larger (less negative) score.\n    # The negative of potential_remaining_cap serves this purpose.\n    base_scores = -potential_remaining_cap[fitting_bins_mask]\n\n    # Identify bins with perfect fit (remaining capacity == 0).\n    # These should have the highest possible priority.\n    perfect_fit_mask = potential_remaining_cap[fitting_bins_mask] == 0\n    base_scores[perfect_fit_mask] = np.finfo(float).max  # Effectively positive infinity\n\n    # Identify bins that would result in a \"very small, non-zero awkward gap\".\n    # These are gaps greater than 0 but less than the defined threshold.\n    awkward_gap_mask = (potential_remaining_cap[fitting_bins_mask] > 0) & \\\n                       (potential_remaining_cap[fitting_bins_mask] < threshold_awkward_gap)\n\n    # Apply the penalty to bins creating awkward gaps.\n    base_scores[awkward_gap_mask] -= penalty_awkward_gap\n\n    # Assign the calculated scores back to the main priorities array for fitting bins.\n    priorities[fitting_bins_mask] = base_scores\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic implements a sophisticated \"Best Fit\" strategy with a\n    deterministic tie-breaking mechanism, adhering to the 'minimize waste'\n    and 'avoid arbitrary choices' reflection.\n\n    Primary Goal (Best Fit - Minimize Absolute Waste):\n    - The main objective is to find a bin that, after placing the item,\n      leaves the smallest *absolute* amount of remaining capacity. This is\n      a classic and effective approach for Bin Packing.\n    - The score for a fitting bin is calculated as `-(remaining_capacity - item_size)`.\n      A perfect fit (where remaining_capacity - item_size = 0) yields a score of 0,\n      which is the highest possible priority. A bin leaving 0.1 units of space\n      gets a score of -0.1. This formulation naturally prioritizes tighter fits\n      by maximizing the score.\n\n    Secondary Goal (Tie-breaking - Prefer Lower Bin Index):\n    - When multiple bins yield the exact same primary score (e.g., several perfect fits,\n      or multiple bins leading to the same minimal non-zero waste), a deterministic\n      tie-breaking rule is applied to ensure the selection is not arbitrary.\n    - Bins with a lower index are slightly preferred. This is achieved by\n      subtracting a very small, index-dependent value from the primary score.\n      Specifically, `score_penalty = bin_index * EPSILON_FOR_TIE_BREAKING`.\n      This ensures that among equally good primary options, the bin with the\n      smallest index will receive a marginally higher overall priority score,\n      making the selection predictable.\n\n    This approach enhances the robustness and predictability of the online\n    bin packing decision-making process by combining a strong waste-minimization\n    strategy with a clear, non-arbitrary tie-breaking rule.\n\n    Args:\n        item: Size of item to be added to the bin. Must be a non-negative float.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score is the most preferred.\n    \"\"\"\n    # Initialize priorities. Bins that cannot fit the item will have a very low priority.\n    # Using -np.inf ensures they are never selected unless no other option exists (which\n    # implies no item can be placed).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle the edge case where item size is non-positive.\n    # Typically, item sizes in Bin Packing are positive.\n    if item <= 0:\n        if item == 0:\n            # If the item size is 0, it conceptually fits into any bin with non-negative capacity.\n            # It causes no waste, so assign a perfect fit score (0) to all such bins.\n            # Tie-breaking isn't strictly necessary here as all fitting bins get the same score,\n            # and `np.argmax` will naturally pick the lowest index in case of ties among these.\n            priorities[bins_remain_cap >= 0] = 0.0\n        else: # item < 0, which is an invalid scenario for bin packing\n            # No bin can fit a negative item, so all priorities remain -np.inf.\n            pass\n        return priorities\n\n    # Identify which bins the item can physically fit into.\n    fits_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity for the bins where the item fits.\n    remainder_after_placement = bins_remain_cap[fits_mask] - item\n\n    # Primary priority: Best Fit (minimize absolute remainder).\n    # We negate the remainder so that smaller remainders result in higher (less negative) scores.\n    # A perfect fit (remainder 0) yields a score of 0.\n    best_fit_scores = -remainder_after_placement\n\n    # Secondary priority: Tie-breaking by preferring bins with lower original indices.\n    # To implement this, we subtract a very small, index-dependent penalty from the score.\n    # The `EPSILON_FOR_TIE_BREAKING` must be sufficiently small so it does not\n    # alter the primary ordering based on `best_fit_scores` unless two or more\n    # primary scores are exactly identical. A value like 1e-12 is generally\n    # safe for typical float precision.\n    EPSILON_FOR_TIE_BREAKING = 1e-12\n\n    # Get the original indices of the bins that can fit the item.\n    original_fitting_indices = np.where(fits_mask)[0]\n\n    # Calculate the tie-breaking penalties: smaller index -> smaller penalty -> higher final score.\n    tie_breaker_penalties = original_fitting_indices * EPSILON_FOR_TIE_BREAKING\n\n    # Combine primary and secondary priorities.\n    # The penalties are subtracted from the best_fit_scores.\n    priorities[fits_mask] = best_fit_scores - tie_breaker_penalties\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function refines the Best Fit heuristic by explicitly rewarding perfect fits\n    and prioritizing snug, immediate fits. It addresses the \"Prior reflection\" points:\n    1.  Filter invalid: Bins where the item does not fit are assigned an extremely low priority.\n    2.  Reward perfect fits: Bins that result in zero remaining capacity are given a very high priority bonus.\n    3.  Prioritize snug, immediate ones: For non-perfect fits, bins leaving the smallest positive\n        remaining capacity are preferred (standard Best Fit).\n    4.  Penalize awkward future gaps: Implicitly addressed by strongly preferring perfect fits\n        (which eliminate awkward fragmentation for that bin) and minimizing remaining waste otherwise.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value indicates the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # This ensures bins where the item does not fit are never selected unless\n    # no bin can fit the item (in which case the calling logic should open a new bin).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # Apply priorities only to fitting bins.\n    if np.any(fitting_bins_mask):\n        # Extract potential remaining capacities for only the fitting bins.\n        fitting_potential_rem_cap = potential_remaining_cap[fitting_bins_mask]\n\n        # Identify perfect fits: where the remaining capacity would be exactly zero.\n        perfect_fit_mask = fitting_potential_rem_cap == 0\n\n        # Define a large bonus for perfect fits. This ensures they are always chosen\n        # over any other type of fit if available.\n        PERFECT_FIT_BONUS = 1e9  # A sufficiently large positive number\n\n        # Assign the high bonus to bins that are a perfect fit.\n        # We need to map the perfect_fit_mask (which applies to fitting_potential_rem_cap)\n        # back to the original `priorities` array using the `fitting_bins_mask`.\n        priorities[fitting_bins_mask & (potential_remaining_cap == 0)] = PERFECT_FIT_BONUS\n\n        # For non-perfect fits (snug fits), apply the Best Fit logic:\n        # Prioritize bins that leave the smallest positive remaining capacity.\n        # This means using the negative of the remaining capacity as the priority score.\n        # These scores will be negative (or zero for v1 logic for perfect fit, but v2 handles it separately),\n        # making them lower than the PERFECT_FIT_BONUS but higher than -np.inf.\n        snug_fit_mask = ~perfect_fit_mask\n        \n        # Apply the Best Fit logic to the remaining snug fitting bins.\n        # Again, ensure correct indexing back to the original `priorities` array.\n        priorities[fitting_bins_mask & (potential_remaining_cap > 0)] = \\\n            -potential_remaining_cap[fitting_bins_mask & (potential_remaining_cap > 0)]\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements an enhanced \"Best Fit\" heuristic with a unified\n    scoring mechanism. It prioritizes bins that, after the item is placed,\n    would have the smallest remaining capacity. This is achieved by using an\n    inverse relationship: 1 / (remaining_capacity + epsilon).\n    This design naturally assigns an extremely high priority score to bins\n    that achieve a perfectly zero remaining capacity (perfect fit), effectively\n    incorporating a strategic bonus for optimal bin utilization without a\n    separate constant. Bins where the item does not fit are effectively\n    filtered out by being assigned an extremely low (negative infinity) priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n    # Initialize priorities to a very low value for all bins.\n    # This acts as a filter: bins where the item does not fit will retain this\n    # -np.inf score, ensuring they are not chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can actually fit.\n    # A bin fits if its current remaining capacity is greater than or equal to the item size.\n    fitting_bins_mask = bins_remain_cap >= item\n\n    # Calculate the potential remaining capacity for the bins where the item fits.\n    potential_remaining_cap = bins_remain_cap[fitting_bins_mask] - item\n\n    # Define a small epsilon to prevent division by zero, especially when\n    # potential_remaining_cap is exactly 0. This also naturally boosts the\n    # priority for perfect fits (0 remaining capacity) to a very high value.\n    EPSILON = 1e-9  # A small positive value.\n\n    # For the fitting bins, calculate their priority score.\n    # The score is inversely proportional to the potential remaining capacity.\n    # A smaller remaining capacity results in a larger priority score.\n    # Perfect fits (potential_remaining_cap ~ 0) will yield extremely high scores\n    # due to division by a very small number (EPSILON).\n    priorities[fitting_bins_mask] = 1.0 / (potential_remaining_cap + EPSILON)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]