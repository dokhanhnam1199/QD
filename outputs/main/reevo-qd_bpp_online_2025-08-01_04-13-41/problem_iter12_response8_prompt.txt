{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a \"Best Fit\" like heuristic, but with a crucial\n    modification: it strongly rewards perfect packing and penalizes choices\n    that result in \"awkward\" very small, non-zero remaining capacities.\n    The aim is to optimize long-term bin utilization by avoiding hard-to-fill gaps.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n                         It is assumed that bin capacities are on a similar scale\n                         (e.g., normalized, typically to 1.0) for the constant\n                         thresholds to be effective.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n    # Define constants for the heuristic. These values may need tuning\n    # depending on the typical scale of item sizes and bin capacities.\n    # We assume bin capacities are normalized, for example, between 0 and 1.0.\n\n    # This threshold defines what constitutes a \"very small, awkward gap\".\n    # For a bin with capacity 1.0, 0.05 means any remaining capacity less than 5%\n    # of the bin size (but greater than 0) will be penalized.\n    # This value could also be made relative to the item size (e.g., 0.1 * item)\n    # or the bin's total capacity if known.\n    threshold_awkward_gap = 0.05\n\n    # This is the additional penalty applied to bins that result in an\n    # \"awkward gap\". It must be sufficiently large to make an awkward gap\n    # less desirable than a slightly larger, non-awkward gap.\n    # For example, if R_awkward = 0.01 and R_better = 0.06 (just above threshold),\n    # we want score(-0.01 - penalty) < score(-0.06).\n    # A penalty of 0.5 is a significant reduction.\n    penalty_awkward_gap = 0.5\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # -np.inf ensures that bins where the item does not fit will never be selected,\n    # and a new bin would typically be opened if no bin has a priority > -inf.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For fitting bins, calculate the base priority (Best Fit: minimize waste)\n    # A smaller positive remaining capacity results in a larger (less negative) score.\n    # The negative of potential_remaining_cap serves this purpose.\n    base_scores = -potential_remaining_cap[fitting_bins_mask]\n\n    # Identify bins with perfect fit (remaining capacity == 0).\n    # These should have the highest possible priority.\n    perfect_fit_mask = potential_remaining_cap[fitting_bins_mask] == 0\n    base_scores[perfect_fit_mask] = np.finfo(float).max  # Effectively positive infinity\n\n    # Identify bins that would result in a \"very small, non-zero awkward gap\".\n    # These are gaps greater than 0 but less than the defined threshold.\n    awkward_gap_mask = (potential_remaining_cap[fitting_bins_mask] > 0) & \\\n                       (potential_remaining_cap[fitting_bins_mask] < threshold_awkward_gap)\n\n    # Apply the penalty to bins creating awkward gaps.\n    base_scores[awkward_gap_mask] -= penalty_awkward_gap\n\n    # Assign the calculated scores back to the main priorities array for fitting bins.\n    priorities[fitting_bins_mask] = base_scores\n\n    return priorities\n\n[Reflection]\nPrioritize immediate fit, reward perfect fills, and penalize \"awkward\" remaining capacities to optimize long-term utilization.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}