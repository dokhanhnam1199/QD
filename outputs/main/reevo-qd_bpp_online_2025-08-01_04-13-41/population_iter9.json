[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a \"Best Fit\" like heuristic. It prioritizes\n    bins that, after the item is placed, would have the smallest remaining\n    capacity (i.e., leaving the least 'waste'). Bins where the item does\n    not fit are given an extremely low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score (least negative in this case) will be selected.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # Using -np.inf ensures that bins where the item does not fit will never\n    # be selected by argmax, unless no bin can fit the item (in which case\n    # all priorities would be -np.inf, and the first bin would be chosen,\n    # or an error handling mechanism for opening a new bin would be needed elsewhere).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For fitting bins, set the priority.\n    # We want to minimize the remaining capacity (potential_remaining_cap),\n    # so we use its negative as the priority score.\n    # A smaller positive remaining capacity (e.g., 1.0) will result in a\n    # larger (less negative) priority score (e.g., -1.0).\n    # A larger positive remaining capacity (e.g., 10.0) will result in a\n    # smaller (more negative) priority score (e.g., -10.0).\n    priorities[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic extends the \"Best Fit\" strategy by prioritizing bins that,\n    if the item is placed, will leave the smallest *fractional* amount of\n    remaining capacity relative to the size of the item itself. This aims to\n    minimize \"relative waste\" for each item placed, providing a more informed\n    decision based on the item's own magnitude (part of the problem state).\n\n    The score is calculated as `-(remaining_capacity_after_placement / item_size)`.\n\n    - Bins where the item does not fit are assigned a very low (negative infinity) priority.\n    - A perfect fit (remaining_capacity - item_size = 0) yields a score of 0,\n      as (0 / item_size) is 0. This is the highest possible score.\n    - A snug fit (e.g., remaining_capacity - item_size = 0.1 * item_size) yields\n      a score of -0.1.\n    - A loose fit (e.g., remaining_capacity - item_size = 1.0 * item_size) yields\n      a score of -1.0.\n\n    This approach is particularly effective when item sizes can vary significantly.\n    It normalizes the \"cost\" of the remaining space by the item's own magnitude,\n    making the heuristic more sensitive to waste proportions rather than just\n    absolute waste amounts.\n\n    Args:\n        item: Size of item to be added to the bin. Must be a non-negative float.\n              Typically, item sizes in Bin Packing are positive.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score is the most preferred.\n    \"\"\"\n    # Initialize priorities. Bins that cannot fit the item will retain a very low priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Find which bins the item can fit into\n    fits_mask = bins_remain_cap >= item\n\n    # Handle the edge case where item size is non-positive.\n    # Typically, item sizes in BPP are positive.\n    if item <= 0:\n        if item == 0:\n            # If item is zero, it occupies no space and creates no waste.\n            # It can conceptually fit into any bin that has non-negative capacity.\n            # Assign a perfect fit score (0) to all bins it \"fits\" into,\n            # indicating no relative waste.\n            priorities[fits_mask] = 0.0\n        else: # item < 0, which is typically invalid for bin packing\n            # All priorities remain -np.inf, effectively preventing placement.\n            pass\n        return priorities\n\n    # Calculate the remaining capacity after placing the item\n    remainder_after_placement = bins_remain_cap[fits_mask] - item\n\n    # For bins where the item fits, calculate the 'relative waste' score.\n    # We want to minimize (remainder_after_placement / item).\n    # By taking the negative of this ratio, we convert the minimization\n    # problem into a maximization problem for the priority score.\n    priorities[fits_mask] = -(remainder_after_placement / item)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a \"Best Fit\" like heuristic, similar to v1,\n    but re-scales the priority scores to be non-negative, where a higher\n    score indicates a better fit (i.e., less remaining capacity).\n\n    It prioritizes bins that, after the item is placed, would have the\n    smallest remaining capacity. Bins where the item does not fit are\n    given an extremely low (negative infinity) priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # Using -np.inf ensures that bins where the item does not fit will never\n    # be selected by argmax, unless no bin can fit the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For fitting bins, set the priority.\n    # We want to minimize the remaining capacity (potential_remaining_cap).\n    # To convert this into a positive score where higher is better:\n    # We find the maximum possible remaining capacity among the bins where the item fits.\n    # Then, we subtract the actual remaining capacity from this maximum.\n    # This ensures that a perfect fit (remaining_cap = 0) gets the highest score,\n    # and the \"worst\" fit among eligible bins (largest remaining_cap) gets a score of 0.\n    if np.any(fitting_bins_mask):\n        # Get remaining capacities for bins where the item fits\n        fitting_rem_caps = potential_remaining_cap[fitting_bins_mask]\n\n        # Find the maximum remaining capacity among these fitting bins.\n        # This serves as a baseline for scaling the priorities.\n        max_fitting_rem_cap = np.max(fitting_rem_caps)\n\n        # Calculate priority scores for fitting bins:\n        # A smaller `fitting_rem_caps` (tighter fit) results in a larger\n        # `max_fitting_rem_cap - fitting_rem_caps` value (higher priority).\n        # A perfect fit (fitting_rem_caps = 0) gets `max_fitting_rem_cap`.\n        # The worst fitting bin among the valid ones gets `0`.\n        priorities[fitting_bins_mask] = max_fitting_rem_cap - fitting_rem_caps\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a \"Best Fit\" strategy, augmented to\n    evaluate the 'impact' of the placement by applying a penalty if\n    the placement would result in a \"medium\" amount of remaining capacity\n    in the bin. This aims to minimize future waste by discouraging\n    the creation of awkwardly sized gaps that might be difficult to fill.\n    It prioritizes bins that would be nearly full (very small remainder)\n    or those that would still have a large remaining capacity after the item\n    is placed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score (least negative) will be selected.\n    \"\"\"\n    # In standard Bin Packing Problems, the bin capacity is fixed and known.\n    # If not provided as an explicit argument, a common approach is to assume 1.0\n    # for normalized problems, or infer it from the initial state if an empty bin\n    # (with full capacity) is guaranteed to be in bins_remain_cap.\n    # For a general solution, assuming 1.0 (typical for normalized problems) is reasonable.\n    # If item sizes are integers, BIN_CAPACITY would be an integer as well (e.g., 100).\n    BIN_CAPACITY = 1.0 # This should ideally be passed as an argument or global constant.\n                       # For demonstration, assuming a normalized bin capacity of 1.0.\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # -np.inf ensures that bins where the item does not fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For fitting bins, set the initial priority based on \"Best Fit\".\n    # We want to minimize the remaining capacity, so we use its negative as the priority score.\n    # A smaller positive remaining capacity (e.g., 0.05) will result in a\n    # larger (less negative) priority score (e.g., -0.05). A perfect fit (0 remaining)\n    # gets a score of 0, which is the highest.\n    priorities[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    # --- Augmentation based on \"Evaluate placement impact\" and \"minimizing future waste\" ---\n    # This part penalizes scenarios where placing the item leaves a 'medium' amount\n    # of remaining capacity. Such gaps can be considered \"waste\" because they are\n    # neither nearly full nor large enough to easily accommodate new large items.\n    # The thresholds for \"medium\" are relative to the BIN_CAPACITY and can be tuned.\n    medium_gap_lower_threshold = 0.1 * BIN_CAPACITY  # e.g., 10% of bin capacity\n    medium_gap_upper_threshold = 0.5 * BIN_CAPACITY  # e.g., 50% of bin capacity\n\n    # Define a penalty value. This should be significant enough to make a\n    # \"medium gap\" option less attractive than a non-penalized, less \"Best Fit\" option.\n    # A penalty proportional to the item size or a fixed large value can be used.\n    penalty_value = item * 2.0  # Example: 2 times the item size as penalty.\n                                 # This ensures the penalty scales with item magnitudes.\n\n    # Identify fitting bins that would result in a \"medium\" remaining capacity\n    medium_gap_mask = (potential_remaining_cap > medium_gap_lower_threshold) & \\\n                      (potential_remaining_cap < medium_gap_upper_threshold)\n\n    # Apply the penalty to the priorities of bins that fall into the \"medium gap\" range\n    # and where the item actually fits.\n    penalize_bins = fitting_bins_mask & medium_gap_mask\n    priorities[penalize_bins] -= penalty_value\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a \"Best Fit\" heuristic with a strategic enhancement\n    to strongly prioritize perfect fits. It aims to minimize waste by preferring\n    bins that, after the item is placed, would have the smallest remaining capacity.\n    Bins where the item does not fit are given an extremely low priority.\n    A significant bonus is awarded to bins that achieve a perfectly zero remaining\n    capacity, reflecting a more aggressive strategy to \"finish off\" bins completely\n    and optimally utilize space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score (least negative in this case) will be selected.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # This effectively filters out bins where the item does not fit.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For fitting bins, set the base priority. This is the core \"Best Fit\" logic:\n    # minimize the remaining capacity by using its negative as the priority.\n    # A smaller positive remaining capacity (e.g., 1.0) results in a larger\n    # (less negative) priority score (e.g., -1.0).\n    priorities[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    # Strategic Mutation: Introduce a significant bonus for perfect fits.\n    # This aligns with \"Strategically evaluate choices\" by explicitly valuing\n    # maximal bin utilization. A perfect fit means potential_remaining_cap is exactly 0.\n    # The bonus ensures that a bin achieving a perfect fit will always be preferred\n    # over any bin that has a non-zero remaining capacity, no matter how small.\n    # For example, if max possible remaining capacity is 100, then a general priority\n    # could be -100. A perfect fit is 0. A bonus of 1.0 ensures 0 + 1.0 = 1.0 is\n    # always greater than any negative priority resulting from a non-perfect fit.\n    PERFECT_FIT_BONUS = 1.0\n\n    # Identify bins where a perfect fit is achieved.\n    # We use np.isclose for float comparisons to account for potential floating point inaccuracies,\n    # though for typical BPP, exact zero might be common.\n    perfect_fit_mask = np.isclose(potential_remaining_cap, 0.0)\n\n    # Apply the bonus only to bins that achieve a perfect fit and also fit the item.\n    # The `perfect_fit_mask` implicitly means `potential_remaining_cap` is 0, which implies it fits.\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements an improved \"Best Fit\" like heuristic.\n    It prioritizes bins that, after the item is placed, would have the\n    smallest remaining capacity (i.e., leaving the least 'waste').\n    Beyond this Best-Fit base, it strategically rewards perfect fits\n    and penalizes the creation of awkward, small, non-zero gaps, aiming\n    for better long-term packing efficiency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score (least negative in this case) will be selected.\n    \"\"\"\n    # Define constants for strategic weighting. These values are heuristics\n    # and may need tuning based on the typical range of item sizes and bin capacities.\n    # A significant bonus for leaving exactly zero capacity, making it the highest priority.\n    PERFECT_FIT_BONUS = 100.0\n    # A penalty for creating small, non-zero gaps that might be difficult to fill later.\n    SMALL_GAP_PENALTY = -50.0\n    # The threshold below which a non-zero remaining capacity is considered \"small\" and awkward.\n    # For instance, if item/bin sizes are typically between 0 and 1, 0.1 represents 10% of capacity.\n    SMALL_GAP_THRESHOLD = 0.1\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # Bins where the item does not fit will remain at -np.inf, ensuring they are not selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # Extract potential remaining capacities only for the bins where the item fits.\n    fitting_rem_cap = potential_remaining_cap[fitting_bins_mask]\n\n    # 1. Base Best-Fit Score:\n    # We want to minimize the remaining capacity (fitting_rem_cap),\n    # so we use its negative as the priority score. A smaller positive\n    # remaining capacity (e.g., 1.0) results in a larger (less negative)\n    # priority score (e.g., -1.0).\n    fitting_priorities = -fitting_rem_cap\n\n    # 2. Apply Perfect Fit Bonus:\n    # Identify bins where the item fits exactly, leaving zero remaining capacity.\n    # These are highly rewarded to ensure they are picked over other \"Best Fit\" options.\n    perfect_fit_mask = (fitting_rem_cap == 0)\n    fitting_priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    # 3. Apply Small Gap Penalty:\n    # Identify bins that would be left with a small, non-zero remaining capacity.\n    # These gaps are penalized as they can be \"awkward\" or hard to utilize efficiently later.\n    # The condition `fitting_rem_cap > 0` ensures perfect fits are not penalized here.\n    small_gap_mask = (fitting_rem_cap > 0) & (fitting_rem_cap < SMALL_GAP_THRESHOLD)\n    fitting_priorities[small_gap_mask] += SMALL_GAP_PENALTY\n\n    # Assign the calculated priorities back to the main priorities array for fitting bins.\n    priorities[fitting_bins_mask] = fitting_priorities\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a refined \"Best Fit\" heuristic for online bin packing,\n    emphasizing optimal space utilization and strongly preferring perfect fits.\n    It assigns priority scores such that:\n    1. Bins where the item does not fit are given an extremely low priority.\n    2. For bins where the item fits, priority is inversely proportional to the\n       remaining capacity after placement, meaning smaller remaining capacity\n       yields higher priority (Best Fit principle). This maps priorities for\n       non-perfect fits to a range between 0 (for very large remaining capacity)\n       and 1 (for remaining capacity approaching zero).\n    3. Bins that achieve a perfectly zero remaining capacity are given the\n       highest possible distinct priority, ensuring they are always selected\n       over any non-perfect fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n    # Initialize priorities to a very low value. This effectively filters out\n    # bins where the item cannot be placed, ensuring they are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A positive value means the item fits, a negative value means it doesn't.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    can_fit_mask = remaining_after_placement >= 0\n\n    # Apply the core \"Best Fit\" logic for fitting bins:\n    # Prioritize bins that leave the least remaining space.\n    # Using 1.0 / (1.0 + x) maps smaller positive 'x' (remaining capacity) to\n    # higher priority values (closer to 1.0), and larger 'x' to lower values\n    # (closer to 0.0). This provides a positive and intuitive priority scale.\n    # We only apply this to bins where the item can fit.\n    priorities[can_fit_mask] = 1.0 / (1.0 + remaining_after_placement[can_fit_mask])\n\n    # Strategic enhancement: Assign a distinctly higher priority for perfect fits.\n    # This value must be greater than any priority achievable by non-perfect fits.\n    # Since the maximum priority for a non-perfect fit (when remaining_after_placement\n    # approaches 0) is 1.0, a value like 2.0 (or any value > 1.0) ensures this.\n    PERFECT_FIT_PRIORITY = 2.0\n\n    # Identify bins where a perfect fit is achieved.\n    # We use np.isclose for float comparisons to account for potential floating point inaccuracies.\n    perfect_fit_mask = np.isclose(remaining_after_placement, 0.0)\n\n    # For perfect fits, override their priority with the distinct highest score.\n    # This ensures that any bin resulting in a perfect fit will be chosen over\n    # any non-perfect fit, regardless of its 'best fit' score from the previous step.\n    # The `perfect_fit_mask` implicitly means `remaining_after_placement` is 0,\n    # which satisfies `can_fit_mask`.\n    priorities[perfect_fit_mask] = PERFECT_FIT_PRIORITY\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function extends the \"Best Fit\" heuristic from priority_v1 by\n    incorporating specific rewards for perfect fits and penalties for\n    creating \"awkward\" small remaining gaps, aiming for better long-term\n    bin utilization as described in the reflection.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n\n    # --- Heuristic Constants ---\n    # A large bonus for perfect fits (remaining capacity is exactly zero)\n    # This value should be large enough to make a perfect fit significantly\n    # more desirable than any non-perfect fit.\n    PERFECT_FIT_BONUS = 100.0\n\n    # A threshold to define an \"awkward\" remaining gap.\n    # If the remaining capacity after placing the item is positive but\n    # falls within (0, AWKWARD_GAP_THRESHOLD], it's considered awkward.\n    # This value is heuristic and might need tuning based on the expected\n    # range of item sizes and bin capacities. For normalized capacities (e.g., 0-1), 0.1 is a reasonable start.\n    AWKWARD_GAP_THRESHOLD = 0.1\n\n    # A penalty applied to bins that would result in an \"awkward\" remaining gap.\n    # This penalty aims to discourage leaving small, hard-to-fill spaces.\n    AWKWARD_GAP_PENALTY = 10.0\n\n    # Epsilon for robust floating-point comparisons to zero (e.g., for perfect fit checks)\n    EPSILON_FLOAT_COMP = 1e-9\n\n    # Calculate the potential remaining capacity if the item were placed in each bin.\n    # A negative value strictly means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to an extremely low value for all bins.\n    # This ensures that bins where the item does not fit are never selected\n    # unless no bin can accommodate the item (in which case a new bin should be opened externally).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item conceptually fits (remaining capacity is non-negative,\n    # allowing for tiny negative values due to floating point inaccuracies if they are effectively zero).\n    fitting_bins_mask = potential_remaining_cap >= -EPSILON_FLOAT_COMP\n\n    # Apply the base \"Best Fit\" heuristic for fitting bins:\n    # Prioritize bins that would leave the smallest remaining capacity (least waste).\n    # Using the negative of potential_remaining_cap means smaller positive remainders yield\n    # larger (less negative) priority scores.\n    # For bins that fit but result in a tiny negative 'potential_remaining_cap' due to precision,\n    # this will result in a tiny positive priority, which is desirable (very close to perfect fit).\n    priorities[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    # --- Reward Perfect Fits ---\n    # Identify bins where the item fits perfectly (remaining capacity is effectively zero).\n    # We use np.abs for robustness with floating point numbers (e.g., -1e-17 is considered zero).\n    perfect_fit_mask = np.abs(potential_remaining_cap) < EPSILON_FLOAT_COMP\n    # Ensure this bonus is only applied to bins that were determined to be fitting.\n    perfect_fit_mask = perfect_fit_mask & fitting_bins_mask\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    # --- Penalize Awkward Future Gaps ---\n    # Identify bins where the item fits, and the resulting remaining capacity is positive\n    # but falls within the defined \"awkward\" range (e.g., too small to be generally useful,\n    # but not zero).\n    awkward_gap_mask = (potential_remaining_cap > EPSILON_FLOAT_COMP) & \\\n                       (potential_remaining_cap <= AWKWARD_GAP_THRESHOLD)\n    # Ensure this penalty is only applied to bins that were determined to be fitting.\n    awkward_gap_mask = awkward_gap_mask & fitting_bins_mask\n    priorities[awkward_gap_mask] -= AWKWARD_GAP_PENALTY\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]