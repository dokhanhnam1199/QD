{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements an improved \"Best Fit\" like heuristic.\n    It prioritizes bins that, after the item is placed, would have the\n    smallest remaining capacity (i.e., leaving the least 'waste').\n    Beyond this Best-Fit base, it strategically rewards perfect fits\n    and penalizes the creation of awkward, small, non-zero gaps, aiming\n    for better long-term packing efficiency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score (least negative in this case) will be selected.\n    \"\"\"\n    # Define constants for strategic weighting. These values are heuristics\n    # and may need tuning based on the typical range of item sizes and bin capacities.\n    # A significant bonus for leaving exactly zero capacity, making it the highest priority.\n    PERFECT_FIT_BONUS = 100.0\n    # A penalty for creating small, non-zero gaps that might be difficult to fill later.\n    SMALL_GAP_PENALTY = -50.0\n    # The threshold below which a non-zero remaining capacity is considered \"small\" and awkward.\n    # For instance, if item/bin sizes are typically between 0 and 1, 0.1 represents 10% of capacity.\n    SMALL_GAP_THRESHOLD = 0.1\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # Bins where the item does not fit will remain at -np.inf, ensuring they are not selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # Extract potential remaining capacities only for the bins where the item fits.\n    fitting_rem_cap = potential_remaining_cap[fitting_bins_mask]\n\n    # 1. Base Best-Fit Score:\n    # We want to minimize the remaining capacity (fitting_rem_cap),\n    # so we use its negative as the priority score. A smaller positive\n    # remaining capacity (e.g., 1.0) results in a larger (less negative)\n    # priority score (e.g., -1.0).\n    fitting_priorities = -fitting_rem_cap\n\n    # 2. Apply Perfect Fit Bonus:\n    # Identify bins where the item fits exactly, leaving zero remaining capacity.\n    # These are highly rewarded to ensure they are picked over other \"Best Fit\" options.\n    perfect_fit_mask = (fitting_rem_cap == 0)\n    fitting_priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    # 3. Apply Small Gap Penalty:\n    # Identify bins that would be left with a small, non-zero remaining capacity.\n    # These gaps are penalized as they can be \"awkward\" or hard to utilize efficiently later.\n    # The condition `fitting_rem_cap > 0` ensures perfect fits are not penalized here.\n    small_gap_mask = (fitting_rem_cap > 0) & (fitting_rem_cap < SMALL_GAP_THRESHOLD)\n    fitting_priorities[small_gap_mask] += SMALL_GAP_PENALTY\n\n    # Assign the calculated priorities back to the main priorities array for fitting bins.\n    priorities[fitting_bins_mask] = fitting_priorities\n\n    return priorities\n\n[Reflection]\nMinimize immediate waste; strategically reward perfect fits, penalize awkward small gaps using domain knowledge.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}