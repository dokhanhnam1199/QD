{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic extends the \"Best Fit\" strategy by prioritizing bins that,\n    if the item is placed, will leave the smallest *fractional* amount of\n    remaining capacity relative to the size of the item itself. This aims to\n    minimize \"relative waste\" for each item placed, providing a more informed\n    decision based on the item's own magnitude (part of the problem state).\n\n    The score is calculated as `-(remaining_capacity_after_placement / item_size)`.\n\n    - Bins where the item does not fit are assigned a very low (negative infinity) priority.\n    - A perfect fit (remaining_capacity - item_size = 0) yields a score of 0,\n      as (0 / item_size) is 0. This is the highest possible score.\n    - A snug fit (e.g., remaining_capacity - item_size = 0.1 * item_size) yields\n      a score of -0.1.\n    - A loose fit (e.g., remaining_capacity - item_size = 1.0 * item_size) yields\n      a score of -1.0.\n\n    This approach is particularly effective when item sizes can vary significantly.\n    It normalizes the \"cost\" of the remaining space by the item's own magnitude,\n    making the heuristic more sensitive to waste proportions rather than just\n    absolute waste amounts.\n\n    Args:\n        item: Size of item to be added to the bin. Must be a non-negative float.\n              Typically, item sizes in Bin Packing are positive.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score is the most preferred.\n    \"\"\"\n    # Initialize priorities. Bins that cannot fit the item will retain a very low priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Find which bins the item can fit into\n    fits_mask = bins_remain_cap >= item\n\n    # Handle the edge case where item size is non-positive.\n    # Typically, item sizes in BPP are positive.\n    if item <= 0:\n        if item == 0:\n            # If item is zero, it occupies no space and creates no waste.\n            # It can conceptually fit into any bin that has non-negative capacity.\n            # Assign a perfect fit score (0) to all bins it \"fits\" into,\n            # indicating no relative waste.\n            priorities[fits_mask] = 0.0\n        else: # item < 0, which is typically invalid for bin packing\n            # All priorities remain -np.inf, effectively preventing placement.\n            pass\n        return priorities\n\n    # Calculate the remaining capacity after placing the item\n    remainder_after_placement = bins_remain_cap[fits_mask] - item\n\n    # For bins where the item fits, calculate the 'relative waste' score.\n    # We want to minimize (remainder_after_placement / item).\n    # By taking the negative of this ratio, we convert the minimization\n    # problem into a maximization problem for the priority score.\n    priorities[fits_mask] = -(remainder_after_placement / item)\n\n    return priorities\n\n[Reflection]\nLeverage item and bin properties to minimize waste and optimize future bin utilization.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}