{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic implements a Best-Fit-like strategy, aiming to leave\n    the smallest possible positive remaining capacity in a bin after placing\n    the item. This minimizes fragmentation and makes efficient use of bin space.\n\n    The priority score is calculated as follows:\n    - For bins where the item fits (i.e., remaining_capacity >= item):\n        The priority is the negative of the remaining capacity after placing the item.\n        (priority = -(bins_remain_cap[i] - item)).\n        A perfect fit (remaining_capacity - item = 0) will yield a priority of 0,\n        which is the highest possible priority for a feasible bin, indicating it's\n        the 'best' fit. Larger positive remaining capacities will result in\n        more negative priority scores.\n    - For bins where the item does not fit (i.e., remaining_capacity < item):\n        A very low negative priority (negative infinity) is assigned, ensuring\n        these bins are never chosen unless no other bin is available.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Calculate the potential remaining capacity for each bin if the item were placed.\n    # This value can be negative if the item does not fit.\n    potential_remaining = bins_remain_cap - item\n    \n    # Initialize all priorities to a very low value (-infinity).\n    # This ensures bins where the item does not fit are effectively \"disqualified\"\n    # in an argmax operation.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    \n    # Define a small tolerance for floating point comparisons to handle\n    # cases where an item perfectly fits, but due to precision,\n    # `bins_remain_cap - item` might be slightly negative (e.g., -1e-17).\n    tolerance = 1e-9\n    \n    # Create a boolean mask for bins where the item can actually fit.\n    # A bin fits if its potential remaining capacity is non-negative,\n    # considering the small tolerance.\n    can_fit_mask = potential_remaining >= -tolerance\n    \n    # For bins where the item fits, calculate the priority score.\n    # We want to minimize the positive remaining space. By taking the negative\n    # of the potential remaining space, a smaller positive remaining space\n    # (e.g., 0.0 for a perfect fit) results in a larger priority score (0.0).\n    # A larger positive remaining space (e.g., 0.5) results in a smaller\n    # priority score (-0.5).\n    priorities[can_fit_mask] = -potential_remaining[can_fit_mask]\n    \n    return priorities\n\n[Reflection]\nUtilize item and bin state to strategically prioritize fits, minimizing wasted space for efficiency.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}