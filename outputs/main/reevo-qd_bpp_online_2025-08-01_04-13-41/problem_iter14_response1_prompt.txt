{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic implements a sophisticated \"Best Fit\" strategy with a\n    deterministic tie-breaking mechanism, adhering to the 'minimize waste'\n    and 'avoid arbitrary choices' reflection.\n\n    Primary Goal (Best Fit - Minimize Absolute Waste):\n    - The main objective is to find a bin that, after placing the item,\n      leaves the smallest *absolute* amount of remaining capacity. This is\n      a classic and effective approach for Bin Packing.\n    - The score for a fitting bin is calculated as `-(remaining_capacity - item_size)`.\n      A perfect fit (where remaining_capacity - item_size = 0) yields a score of 0,\n      which is the highest possible priority. A bin leaving 0.1 units of space\n      gets a score of -0.1. This formulation naturally prioritizes tighter fits\n      by maximizing the score.\n\n    Secondary Goal (Tie-breaking - Prefer Lower Bin Index):\n    - When multiple bins yield the exact same primary score (e.g., several perfect fits,\n      or multiple bins leading to the same minimal non-zero waste), a deterministic\n      tie-breaking rule is applied to ensure the selection is not arbitrary.\n    - Bins with a lower index are slightly preferred. This is achieved by\n      subtracting a very small, index-dependent value from the primary score.\n      Specifically, `score_penalty = bin_index * EPSILON_FOR_TIE_BREAKING`.\n      This ensures that among equally good primary options, the bin with the\n      smallest index will receive a marginally higher overall priority score,\n      making the selection predictable.\n\n    This approach enhances the robustness and predictability of the online\n    bin packing decision-making process by combining a strong waste-minimization\n    strategy with a clear, non-arbitrary tie-breaking rule.\n\n    Args:\n        item: Size of item to be added to the bin. Must be a non-negative float.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score is the most preferred.\n    \"\"\"\n    # Initialize priorities. Bins that cannot fit the item will have a very low priority.\n    # Using -np.inf ensures they are never selected unless no other option exists (which\n    # implies no item can be placed).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle the edge case where item size is non-positive.\n    # Typically, item sizes in Bin Packing are positive.\n    if item <= 0:\n        if item == 0:\n            # If the item size is 0, it conceptually fits into any bin with non-negative capacity.\n            # It causes no waste, so assign a perfect fit score (0) to all such bins.\n            # Tie-breaking isn't strictly necessary here as all fitting bins get the same score,\n            # and `np.argmax` will naturally pick the lowest index in case of ties among these.\n            priorities[bins_remain_cap >= 0] = 0.0\n        else: # item < 0, which is an invalid scenario for bin packing\n            # No bin can fit a negative item, so all priorities remain -np.inf.\n            pass\n        return priorities\n\n    # Identify which bins the item can physically fit into.\n    fits_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity for the bins where the item fits.\n    remainder_after_placement = bins_remain_cap[fits_mask] - item\n\n    # Primary priority: Best Fit (minimize absolute remainder).\n    # We negate the remainder so that smaller remainders result in higher (less negative) scores.\n    # A perfect fit (remainder 0) yields a score of 0.\n    best_fit_scores = -remainder_after_placement\n\n    # Secondary priority: Tie-breaking by preferring bins with lower original indices.\n    # To implement this, we subtract a very small, index-dependent penalty from the score.\n    # The `EPSILON_FOR_TIE_BREAKING` must be sufficiently small so it does not\n    # alter the primary ordering based on `best_fit_scores` unless two or more\n    # primary scores are exactly identical. A value like 1e-12 is generally\n    # safe for typical float precision.\n    EPSILON_FOR_TIE_BREAKING = 1e-12\n\n    # Get the original indices of the bins that can fit the item.\n    original_fitting_indices = np.where(fits_mask)[0]\n\n    # Calculate the tie-breaking penalties: smaller index -> smaller penalty -> higher final score.\n    tie_breaker_penalties = original_fitting_indices * EPSILON_FOR_TIE_BREAKING\n\n    # Combine primary and secondary priorities.\n    # The penalties are subtracted from the best_fit_scores.\n    priorities[fits_mask] = best_fit_scores - tie_breaker_penalties\n\n    return priorities\n\n[Reflection]\nUtilize specific heuristics (e.g., Best Fit) to minimize waste, considering item/bin properties, with deterministic tie-breaking.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}