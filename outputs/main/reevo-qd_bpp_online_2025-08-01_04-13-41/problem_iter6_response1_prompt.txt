{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a \"Best Fit\" heuristic with a strategic enhancement\n    to strongly prioritize perfect fits. It aims to minimize waste by preferring\n    bins that, after the item is placed, would have the smallest remaining capacity.\n    Bins where the item does not fit are given an extremely low priority.\n    A significant bonus is awarded to bins that achieve a perfectly zero remaining\n    capacity, reflecting a more aggressive strategy to \"finish off\" bins completely\n    and optimally utilize space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score (least negative in this case) will be selected.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value means the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priorities to a very low value for all bins.\n    # This effectively filters out bins where the item does not fit.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For fitting bins, set the base priority. This is the core \"Best Fit\" logic:\n    # minimize the remaining capacity by using its negative as the priority.\n    # A smaller positive remaining capacity (e.g., 1.0) results in a larger\n    # (less negative) priority score (e.g., -1.0).\n    priorities[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    # Strategic Mutation: Introduce a significant bonus for perfect fits.\n    # This aligns with \"Strategically evaluate choices\" by explicitly valuing\n    # maximal bin utilization. A perfect fit means potential_remaining_cap is exactly 0.\n    # The bonus ensures that a bin achieving a perfect fit will always be preferred\n    # over any bin that has a non-zero remaining capacity, no matter how small.\n    # For example, if max possible remaining capacity is 100, then a general priority\n    # could be -100. A perfect fit is 0. A bonus of 1.0 ensures 0 + 1.0 = 1.0 is\n    # always greater than any negative priority resulting from a non-perfect fit.\n    PERFECT_FIT_BONUS = 1.0\n\n    # Identify bins where a perfect fit is achieved.\n    # We use np.isclose for float comparisons to account for potential floating point inaccuracies,\n    # though for typical BPP, exact zero might be common.\n    perfect_fit_mask = np.isclose(potential_remaining_cap, 0.0)\n\n    # Apply the bonus only to bins that achieve a perfect fit and also fit the item.\n    # The `perfect_fit_mask` implicitly means `potential_remaining_cap` is 0, which implies it fits.\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    return priorities\n\n[Reflection]\nValidate choices. Optimize locally (e.g., Best Fit). Strategically reward ideal outcomes (e.g., perfect fits).\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}