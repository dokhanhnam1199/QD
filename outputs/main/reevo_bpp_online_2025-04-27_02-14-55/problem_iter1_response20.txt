```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Calculate remaining space after placing the item
    remaining_space = bins_remain_cap - item
    
    # Give high priority to bins where the item fits
    fit_mask = remaining_space >= 0
    
    if np.any(fit_mask):
      # Prioritize bins where the item fits best (smallest remaining space after placing item)
      priorities[fit_mask] = 1 / (remaining_space[fit_mask] + 1e-6) # Adding a small number to avoid division by zero
      
      # Boost priority for bins that are close to being full after adding the item (to consolidate items)
      almost_full_mask = (remaining_space >= 0) & (remaining_space <= 0.2 * np.max(bins_remain_cap))
      priorities[almost_full_mask] *= 2 # Increase priority
    else:
        # If item doesn't fit into any bins, then give very low score so new bin is made (best fit decreasing). Also add very small noise so the score for each bin will be distinct when the value are all negative.
      priorities = bins_remain_cap - item # the more space bins lack of, the lower score it get
      priorities = priorities + np.random.normal(0,1e-9,size=len(bins_remain_cap))
      
    return priorities
```
