```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # 1. Feasibility: Can the item fit in the bin?  Infeasible bins get -inf priority.
    feasible = bins_remain_cap >= item
    priorities[~feasible] = -np.inf  # Mark infeasible bins

    # 2. Best Fit Criterion (among feasible bins): Prioritize bins with minimal waste.
    waste = bins_remain_cap - item
    priorities[feasible] = -waste[feasible] # Smaller waste is better (higher priority)

    # 3. Near-Full Bins:  Slightly boost the priority of bins that are almost full AFTER adding the item. This encourages filling nearly full bins, even if the waste is not minimal. Add epsilon for stable sort, preventing random selection when waste is exactly the same.
    epsilon = 1e-9
    almost_full = (bins_remain_cap - item) <= 0.1  # Tolerance of 0.1, adjust as needed
    priorities[almost_full & feasible] += 1 + epsilon # extra weight to prefer almost full bins

    # 4. Avoid excessive fragmentation: Penalize bins that would leave very small space. If bin is already almost empty, better not to add an item. Add an epsilon for stable sort, preventing random selection when waste is exactly the same.
    fragmented = (bins_remain_cap - item) <= 0.2 & (bins_remain_cap - item) > 0
    priorities[fragmented & feasible] -= 0.5 + epsilon  # penalize fragmented bins, but not as much as infeasibility.

    return priorities
```
