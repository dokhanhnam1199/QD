```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Exact Fit: Highest Priority
    exact_fit = (bins_remain_cap == item)
    priorities[exact_fit] = 10000.0

    # 2. Near Fit: Very High Priority (scaled)
    near_fit_threshold = 0.02  # Tighter threshold for near fit
    near_fit = (bins_remain_cap >= item) & (bins_remain_cap <= item * (1 + near_fit_threshold))
    priorities[near_fit] = 9000.0 - (bins_remain_cap[near_fit] - item) / item * 2000  # Aggressive scaling

    # 3. Infeasibility: Severe Penalty
    infeasible = bins_remain_cap < item
    priorities[infeasible] = -1e12

    # 4. Fragmentation Penalty: Very High Penalty for creating small spaces
    small_space_threshold = 0.15  # Reduced threshold to be stricter
    fragmentation = (bins_remain_cap >= item) & ((bins_remain_cap - item) <= small_space_threshold * np.max(bins_remain_cap))
    if np.any(fragmentation):
        waste = bins_remain_cap[fragmentation] - item
        penalty = (waste / (small_space_threshold * np.max(bins_remain_cap))) * 5000  # Increased penalty
        priorities[fragmentation] -= penalty

    # 5. Reward Similarity: Reward bins with similar existing content (proxy: remaining capacity)
    similarity_threshold = 0.25 # Slightly tighter threshold
    similar_size = np.abs(bins_remain_cap - item) <= similarity_threshold * item
    priorities[similar_size] += 2000.0

    # 6. Encourage Using Existing Bins: High Reward
    non_empty = bins_remain_cap < np.max(bins_remain_cap)
    priorities[non_empty] += 1500.0

    # 7. Discourage Large Waste: Moderate Penalty for bins with much larger capacity
    large_waste_factor = 2.0 #Consider bins with capacity larger than 2x item size
    large_waste = (bins_remain_cap >= item) & (bins_remain_cap > large_waste_factor * item)
    priorities[large_waste] -= 500.0

    # 8. Gaussian Reward around optimal fill ratio
    can_accommodate = (bins_remain_cap >= item)
    if np.any(can_accommodate):
        fill_ratio = item / bins_remain_cap[can_accommodate]
        gaussian_std = 0.08 # Adjust std for the gaussian curve, widened
        gaussian_reward = np.exp(-0.5 * ((fill_ratio - 1.0) / gaussian_std) ** 2)
        priorities[can_accommodate] += gaussian_reward * 3000.0 # Scale Gaussian reward aggressively, reduced scaling

    # 9. Further incentivize filling nearly full bins
    nearly_full_threshold = 1.15
    nearly_full = (bins_remain_cap > item) & (bins_remain_cap < item * nearly_full_threshold)
    priorities[nearly_full] += 750

    return priorities
```
