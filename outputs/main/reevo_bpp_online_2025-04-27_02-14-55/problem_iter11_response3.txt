```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Discrete Priority Levels with Emphasis on Exact/Near Fits
    exact_fit = (bins_remain_cap == item)
    priorities[exact_fit] = 1000.0

    near_fit_threshold = 0.05  # Tighter threshold for near fit
    near_fit = (bins_remain_cap >= item) & (bins_remain_cap <= item * (1 + near_fit_threshold))
    priorities[near_fit] = 950.0 # slightly reduce reward

    # Infeasibility Penalty
    infeasible = bins_remain_cap < item
    priorities[infeasible] = -1e10

    # Penalize Fragmentation Relative to Item Size
    frag_threshold = 0.2  # Fragmentation threshold relative to ITEM size
    fragmented = (bins_remain_cap >= item) & ((bins_remain_cap - item) <= frag_threshold * item)
    if np.any(fragmented):
        waste = bins_remain_cap[fragmented] - item
        penalty = (waste / (frag_threshold * item)) * 600 # Tune scaling
        priorities[fragmented] -= penalty

    # Discourage Near-Full Bins (creating very small space)
    nearly_full_threshold = 0.1 # Threshold relative to total bin size (implicit in bins_remain_cap)
    nearly_full = (bins_remain_cap >= item) & ((bins_remain_cap / np.max(bins_remain_cap)) <= nearly_full_threshold) # Correct calculation
    priorities[nearly_full] -= 500

    # Reward Similarity (Placeholder - Requires Bin Content Tracking) - Removed from v1
    # In a real implementation, this would compare 'item' to the *sizes* of items already in the bin

    # Dynamic Fill Ratio Reward: Gaussian around optimal fill, scaled heavily
    can_accommodate = (bins_remain_cap >= item)
    if np.any(can_accommodate):
        fill_ratio = item / bins_remain_cap[can_accommodate]
        gaussian_std = 0.1 # Adjust std for the gaussian curve - wider spread
        gaussian_reward = np.exp(-0.5 * ((fill_ratio - 1.0) / gaussian_std) ** 2)
        priorities[can_accommodate] += gaussian_reward * 700.0 # Slightly reduce Gaussian reward

    # Encourage using existing bins, more heavily
    non_empty = bins_remain_cap < np.max(bins_remain_cap)
    priorities[non_empty] += 100.0  # Increased bonus

    # Discourage bins with way more capacity than the item size, more aggressive penalty
    large_capacity = (bins_remain_cap >= item) & (bins_remain_cap > 2 * item) # Increased factor
    priorities[large_capacity] -= 90  # Increase the penalty

    return priorities
```
