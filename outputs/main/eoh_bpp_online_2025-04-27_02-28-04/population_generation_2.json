[
     {
          "algorithm": "This algorithm prioritizes bins based on a weighted sum of remaining capacity and the square of utilization, favoring bins that are both reasonably full and have sufficient space for the item.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on a weighted sum of remaining capacity and the square of utilization, favoring bins that are both reasonably full and have sufficient space for the item.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      utilization = item / cap\n      priority_score = (0.7 * utilization**2) + (0.3 * (cap / 100)) # Weighted score\n    else:\n      priority_score = -1\n    priority.append(priority_score)\n  return priority",
          "objective": 3.87914,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on the remaining capacity after packing the item, penalizing bins that become too empty or cannot fit the item.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on the remaining capacity after packing the item, penalizing bins that become too empty or cannot fit the item.}\"\"\"\n  priority = []\n  bin_capacity = 100 #Assume bin capacity is 100\n\n  for cap in bins_remain_cap:\n    if cap >= item:\n      remaining_after_packing = cap - item\n      # Prioritize bins that leave a moderate amount of space\n      priority_score = 1 - (remaining_after_packing / bin_capacity)\n      # Penalize if the remaining cap is too small, we are filling it too much\n      if remaining_after_packing < (0.2 * bin_capacity):\n          priority_score -= 0.1 \n      # Penalize if the remaining cap is too large, we are not filling it much\n      if remaining_after_packing > (0.8 * bin_capacity):\n          priority_score -= 0.1    \n\n    else:\n      priority_score = -1  # Item doesn't fit\n\n    priority.append(priority_score)\n  return priority",
          "objective": 3.90905,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates priority scores for each bin based on a combination of remaining capacity and wasted space, aiming to balance bin utilization and minimize fragmentation.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates priority scores for each bin based on a combination of remaining capacity and wasted space, aiming to balance bin utilization and minimize fragmentation.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      wasted_space = cap - item\n      utilization = item / (cap + item)\n      priority_score = utilization - (wasted_space / 1000)  # Minor penalty for wasted space\n    else:\n      priority_score = -1  # Assign a very low priority if the item doesn't fit\n\n    priority.append(priority_score)\n  return priority",
          "objective": 4.04866,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm assigns a priority to each bin based on a combination of remaining capacity and the wasted space if the item is placed in the bin, favoring bins that can accommodate the item with minimal wasted space.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm assigns a priority to each bin based on a combination of remaining capacity and the wasted space if the item is placed in the bin, favoring bins that can accommodate the item with minimal wasted space.}\"\"\"\n  priorities = []\n  for remain_cap in bins_remain_cap:\n    if remain_cap >= item:\n      wasted_space = remain_cap - item\n      priority = remain_cap + (1.0 / (wasted_space + 0.00001)) # Avoid division by zero\n    else:\n      priority = -1  # Assign a very low priority if the item doesn't fit\n    priorities.append(priority)\n  return priority",
          "objective": 4.48744,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on the ratio of the item size to the remaining bin capacity, favoring bins where the item fills a significant but not excessive portion of the remaining space.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin based on the ratio of the item size to the remaining bin capacity, favoring bins where the item fills a significant but not excessive portion of the remaining space.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      ratio = item / cap\n      priority.append(ratio * (1 - abs(ratio - 0.75))) #Favors ratio around 0.75 (item utilizes 75% of remaining cap).\n    else:\n      priority.append(-1)\n  return priority",
          "objective": 5.33506,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on how close its remaining capacity is to a target capacity derived from the item size, penalizing bins that are too full or too empty relative to this target.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin based on how close its remaining capacity is to a target capacity derived from the item size, penalizing bins that are too full or too empty relative to this target.}\"\"\"\n  priority = []\n  target_capacity = item * 1.2 # Target capacity is slightly larger than the item.\n  for cap in bins_remain_cap:\n    if cap >= item:\n      diff = abs(cap - target_capacity)\n      priority.append(1 / (1 + diff))  # Higher priority for closer to target.\n    else:\n      priority.append(-1)\n  return priority",
          "objective": 5.84364,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combined score that considers both the remaining capacity of the bin and how well the item's size aligns with a target ideal capacity level, discouraging excessive fragmentation and promoting filling bins to a desirable level.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on a combined score that considers both the remaining capacity of the bin and how well the item's size aligns with a target ideal capacity level, discouraging excessive fragmentation and promoting filling bins to a desirable level.}\"\"\"\n  priority = []\n  ideal_capacity = item * 1.33  #item should occupy 75% capacity\n  for cap in bins_remain_cap:\n    if cap >= item:\n      capacity_diff = abs(cap - ideal_capacity)\n      priority_score = 1 / (1 + capacity_diff)  # Higher priority for bins closer to the ideal capacity\n    else:\n      priority_score = -1\n    priority.append(priority_score)\n  return priority",
          "objective": 7.1799,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on how well the item fills the remaining capacity, considering both the filled percentage and a penalty for exceeding a target fill percentage to encourage more balanced packing.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on how well the item fills the remaining capacity, considering both the filled percentage and a penalty for exceeding a target fill percentage to encourage more balanced packing.}\"\"\"\n  priority = []\n  target_fill = 0.75  # Aim for 75% fill rate after placing the item\n\n  for cap in bins_remain_cap:\n    if cap >= item:\n      fill_percentage = item / cap\n      if fill_percentage <= target_fill:\n        priority_score = fill_percentage\n      else:\n        # Penalize exceeding the target fill percentage\n        penalty = (fill_percentage - target_fill) * 2  # Increase penalty factor as needed\n        priority_score = fill_percentage - penalty\n    else:\n      priority_score = -1  # Item doesn't fit\n\n    priority.append(priority_score)\n  return priority",
          "objective": 7.94775,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on how close the item size is to half of the bin's remaining capacity, encouraging balanced fill levels and avoiding overly full or empty bins.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on how close the item size is to half of the bin's remaining capacity, encouraging balanced fill levels and avoiding overly full or empty bins.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      diff_from_half = abs(cap / 2 - item)\n      priority_score = 1 / (diff_from_half + 0.001) # Avoid division by zero\n    else:\n      priority_score = -1 \n    priority.append(priority_score)\n  return priority",
          "objective": 30.94336,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm assigns priority based on a combination of remaining capacity and wasted space if the item is placed in the bin, favoring bins with sufficient capacity and minimal waste.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm assigns priority based on a combination of remaining capacity and wasted space if the item is placed in the bin, favoring bins with sufficient capacity and minimal waste.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            priority.append(cap + 1.0/(waste + 0.0001)) #Adding remaining capacity to waste to create the priority score\n        else:\n            priority.append(-1)  # Assign -1 if the item doesn't fit\n    return priority",
          "objective": 86.58755,
          "other_inf": null
     }
]