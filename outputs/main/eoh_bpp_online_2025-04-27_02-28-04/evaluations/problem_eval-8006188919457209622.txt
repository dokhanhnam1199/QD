def priority_v2(item, bins_remain_cap):
  """{This algorithm prioritizes bins based on a weighted score that emphasizes remaining capacity while still considering the fit with a target capacity level, aiming for a balance between space utilization and fragmentation avoidance.}"""
  priority = []
  ideal_capacity = item * 1.1 #item should occupy about 90%
  capacity_weight = 0.7  # Weight for remaining capacity
  fit_weight = 0.3 #weight for fitness to the ideal capacity
  for cap in bins_remain_cap:
    if cap >= item:
      capacity_diff = abs(cap - ideal_capacity)
      capacity_score = cap / (sum(bins_remain_cap) + 1e-9) #Normalized remaining capacity, avoid dividing by zero
      fit_score = 1 / (1 + capacity_diff)
      priority_score = capacity_weight * capacity_score + fit_weight * fit_score
    else:
      priority_score = -1
    priority.append(priority_score)
  return priority
