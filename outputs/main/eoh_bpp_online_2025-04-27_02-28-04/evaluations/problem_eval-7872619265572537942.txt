def priority_v2(item, bins_remain_cap):
  """{This algorithm prioritizes bins by considering both the item's fit within the bin's remaining capacity and the relative entropy of the resulting bin utilization, favoring bins where the item contributes most to a balanced fill.}"""
  priority = []
  bin_capacity = 100 

  for cap in bins_remain_cap:
    if cap >= item:
      remaining_after_packing = cap - item
      
      # Calculate bin utilization
      utilization_before = (bin_capacity - cap) / bin_capacity if bin_capacity > 0 else 0
      utilization_after = (bin_capacity - remaining_after_packing) / bin_capacity if bin_capacity > 0 else 0
      
      # Calculate relative entropy (Kullback-Leibler divergence)
      expected_utilization = 0.7  # Target utilization (e.g., 70%)
      
      # Avoid log(0) errors
      utilization_before = max(utilization_before, 0.0001)
      utilization_before = min(utilization_before, 0.9999)
      utilization_after = max(utilization_after, 0.0001)
      utilization_after = min(utilization_after, 0.9999)
      expected_utilization = max(expected_utilization, 0.0001)
      expected_utilization = min(expected_utilization, 0.9999)
      
      kl_divergence_before = utilization_before * (math.log(utilization_before / expected_utilization)) + (1 - utilization_before) * math.log((1 - utilization_before) / (1 - expected_utilization)) if (utilization_before >0 and expected_utilization >0) else 0
      kl_divergence_after = utilization_after * (math.log(utilization_after / expected_utilization)) + (1 - utilization_after) * math.log((1 - utilization_after) / (1 - expected_utilization)) if (utilization_after >0 and expected_utilization >0) else 0
      
      # Prioritize bins where adding the item decreases the KL divergence (brings utilization closer to target)
      priority_score = kl_divergence_before - kl_divergence_after

    else:
      priority_score = -1  # Item doesn't fit

    priority.append(priority_score)
  return priority
