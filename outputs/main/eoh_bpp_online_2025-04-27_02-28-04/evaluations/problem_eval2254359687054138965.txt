def priority_v2(item, bins_remain_cap):
  """{This algorithm prioritizes bins based on the wasted space after placing the item, aiming to minimize waste while also considering a penalty for bins that are already too full.}"""
  priority = []
  bin_capacity = 1  # Assuming bin capacity is 1; can be parameterized

  for cap in bins_remain_cap:
    if cap >= item:
      wasted_space = cap - item
      # Normalize wasted space to bin capacity. Smaller wasted space means higher priority.
      normalized_waste = wasted_space / bin_capacity
      # Invert the normalized waste to get a priority score; subtract a penalty based on current fill level
      current_fill = (bin_capacity - cap) / bin_capacity
      # Penalize if the bin is already more than half full to encourage use of emptier bins first.
      if current_fill > 0.5:
        penalty = current_fill - 0.5
      else:
        penalty = 0
      priority_score = 1 - normalized_waste - penalty

    else:
      priority_score = -1  # Item doesn't fit

    priority.append(priority_score)
  return priority
