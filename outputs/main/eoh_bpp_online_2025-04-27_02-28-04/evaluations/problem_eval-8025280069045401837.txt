def priority_v3(item, bins_remain_cap):
  """{This algorithm prioritizes bins based on the remaining capacity after packing the item, rewarding bins that are neither too full nor too empty, with a stronger emphasis on avoiding bins that are almost full.}"""
  priority = []
  bin_capacity = 100 #Assume bin capacity is 100

  for cap in bins_remain_cap:
    if cap >= item:
      remaining_after_packing = cap - item
      # Prioritize bins that leave a moderate amount of space
      priority_score = 1 - abs(remaining_after_packing - 0.5 * bin_capacity) / (0.5 * bin_capacity)

      # Stronger penalty if the remaining cap is too small, we are filling it too much
      if remaining_after_packing < (0.2 * bin_capacity):
          priority_score -= 0.3
      # Slightly Penalize if the remaining cap is too large, we are not filling it much
      if remaining_after_packing > (0.8 * bin_capacity):
          priority_score -= 0.05

    else:
      priority_score = -1  # Item doesn't fit

    priority.append(priority_score)
  return priority
