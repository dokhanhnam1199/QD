def priority_v3(item, bins_remain_cap):
  """{This algorithm prioritizes bins based on how close the item's size is to filling the bin completely, with penalties for bins that can't fit the item or would be left nearly empty.}"""
  priority = []
  bin_capacity = 100

  for cap in bins_remain_cap:
    if cap >= item:
      remaining_after_packing = cap - item
      #Prioritize bins where the item fits well, i.e. remaining_after_packing is low but non-zero.
      priority_score = 1 - (abs(item - cap) / bin_capacity)

      # Penalize if the remaining capacity is too small after packing.
      if remaining_after_packing < (0.1 * bin_capacity):
        priority_score -= 0.2

      # Penalize if the remaining capacity is too large, meaning the item is very small.
      if remaining_after_packing > (0.9 * bin_capacity):
          priority_score -= 0.1

    else:
      priority_score = -1  # Item doesn't fit

    priority.append(priority_score)
  return priority
