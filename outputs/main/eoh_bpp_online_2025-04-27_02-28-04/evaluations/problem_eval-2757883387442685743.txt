def priority_v3(item, bins_remain_cap):
  """{This algorithm prioritizes bins that can accommodate the item and have remaining capacity close to half the bin capacity, with penalties for being too full or too empty and an added bonus for almost filling a bin.}"""
  priority = []
  bin_capacity = 100 #Assume bin capacity is 100

  for cap in bins_remain_cap:
    if cap >= item:
      remaining_after_packing = cap - item
      # Prioritize bins that leave a moderate amount of space
      priority_score = 1 - abs(remaining_after_packing - (0.5 * bin_capacity)) / bin_capacity
      # Penalize if the remaining cap is too small, we are filling it too much
      if remaining_after_packing < (0.1 * bin_capacity):
          priority_score -= 0.2
      # Penalize if the remaining cap is too large, we are not filling it much
      if remaining_after_packing > (0.9 * bin_capacity):
          priority_score -= 0.2
      # Bonus for almost filling a bin
      if remaining_after_packing < (0.05 * bin_capacity):
          priority_score += 0.1

    else:
      priority_score = -1  # Item doesn't fit

    priority.append(priority_score)
  return priority
