def priority_v3(item, bins_remain_cap):
  """{This algorithm prioritizes bins based on how closely the item's size matches a 'sweet spot' range of remaining capacities, and also considers the raw remaining capacity, favoring bins that are neither too full nor too empty.}"""
  priority = []
  sweet_spot_lower = item * 1.1
  sweet_spot_upper = item * 1.5
  for cap in bins_remain_cap:
    if cap >= item:
      if sweet_spot_lower <= cap <= sweet_spot_upper:
        priority_score = 2 # High priority if within sweet spot
      else:
        capacity_diff_lower = abs(cap - sweet_spot_lower)
        capacity_diff_upper = abs(cap - sweet_spot_upper)
        capacity_diff = min(capacity_diff_lower, capacity_diff_upper)
        priority_score = 1 / (1 + capacity_diff) # Moderate priority, inversely proportional to distance from sweet spot
    else:
      priority_score = -1
    priority.append(priority_score)
  return priority
