def priority_v3(item, bins_remain_cap):
  """{This algorithm prioritizes bins based on how fully they can be filled by the item, rewarding near-full packing and penalizing both insufficient and excessive remaining capacity, while also considering bin usage.}"""
  priority = []
  bin_capacity = 100

  for cap in bins_remain_cap:
    if cap >= item:
      remaining_after_packing = cap - item
      # Prioritize bins based on how well they are filled.
      fill_ratio = item / bin_capacity
      priority_score = fill_ratio

      # Reward packing close to full capacity
      if remaining_after_packing < (0.1 * bin_capacity):
        priority_score += 0.2

      #Penalize if the remaining cap is too small
      if remaining_after_packing < (0.2 * bin_capacity):
        priority_score -= 0.05
      # Penalize if the remaining cap is too large
      if remaining_after_packing > (0.7 * bin_capacity):
          priority_score -= 0.05


    else:
      priority_score = -1  # Item doesn't fit

    priority.append(priority_score)
  return priority
