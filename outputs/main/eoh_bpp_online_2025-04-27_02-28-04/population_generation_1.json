[
     {
          "algorithm": "This algorithm calculates priority scores for each bin based on a combination of remaining capacity and wasted space, aiming to balance bin utilization and minimize fragmentation.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates priority scores for each bin based on a combination of remaining capacity and wasted space, aiming to balance bin utilization and minimize fragmentation.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      wasted_space = cap - item\n      utilization = item / (cap + item)\n      priority_score = utilization - (wasted_space / 1000)  # Minor penalty for wasted space\n    else:\n      priority_score = -1  # Assign a very low priority if the item doesn't fit\n\n    priority.append(priority_score)\n  return priority",
          "objective": 4.04866,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm assigns a priority to each bin based on a combination of remaining capacity and the wasted space if the item is placed in the bin, favoring bins that can accommodate the item with minimal wasted space.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm assigns a priority to each bin based on a combination of remaining capacity and the wasted space if the item is placed in the bin, favoring bins that can accommodate the item with minimal wasted space.}\"\"\"\n  priorities = []\n  for remain_cap in bins_remain_cap:\n    if remain_cap >= item:\n      wasted_space = remain_cap - item\n      priority = remain_cap + (1.0 / (wasted_space + 0.00001)) # Avoid division by zero\n    else:\n      priority = -1  # Assign a very low priority if the item doesn't fit\n    priorities.append(priority)\n  return priority",
          "objective": 4.48744,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on the ratio of the item size to the remaining bin capacity, favoring bins where the item fills a significant but not excessive portion of the remaining space.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin based on the ratio of the item size to the remaining bin capacity, favoring bins where the item fills a significant but not excessive portion of the remaining space.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      ratio = item / cap\n      priority.append(ratio * (1 - abs(ratio - 0.75))) #Favors ratio around 0.75 (item utilizes 75% of remaining cap).\n    else:\n      priority.append(-1)\n  return priority",
          "objective": 5.33506,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on how close its remaining capacity is to a target capacity derived from the item size, penalizing bins that are too full or too empty relative to this target.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin based on how close its remaining capacity is to a target capacity derived from the item size, penalizing bins that are too full or too empty relative to this target.}\"\"\"\n  priority = []\n  target_capacity = item * 1.2 # Target capacity is slightly larger than the item.\n  for cap in bins_remain_cap:\n    if cap >= item:\n      diff = abs(cap - target_capacity)\n      priority.append(1 / (1 + diff))  # Higher priority for closer to target.\n    else:\n      priority.append(-1)\n  return priority",
          "objective": 5.84364,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on how well the item fills the remaining capacity, considering both the filled percentage and a penalty for exceeding a target fill percentage to encourage more balanced packing.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on how well the item fills the remaining capacity, considering both the filled percentage and a penalty for exceeding a target fill percentage to encourage more balanced packing.}\"\"\"\n  priority = []\n  target_fill = 0.75  # Aim for 75% fill rate after placing the item\n\n  for cap in bins_remain_cap:\n    if cap >= item:\n      fill_percentage = item / cap\n      if fill_percentage <= target_fill:\n        priority_score = fill_percentage\n      else:\n        # Penalize exceeding the target fill percentage\n        penalty = (fill_percentage - target_fill) * 2  # Increase penalty factor as needed\n        priority_score = fill_percentage - penalty\n    else:\n      priority_score = -1  # Item doesn't fit\n\n    priority.append(priority_score)\n  return priority",
          "objective": 7.94775,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm assigns priority based on a combination of remaining capacity and wasted space if the item is placed in the bin, favoring bins with sufficient capacity and minimal waste.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm assigns priority based on a combination of remaining capacity and wasted space if the item is placed in the bin, favoring bins with sufficient capacity and minimal waste.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            priority.append(cap + 1.0/(waste + 0.0001)) #Adding remaining capacity to waste to create the priority score\n        else:\n            priority.append(-1)  # Assign -1 if the item doesn't fit\n    return priority",
          "objective": 86.58755,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin by considering both remaining capacity and a penalty for bins that are too full or too empty, preferring bins that can accommodate the item without excessive leftover space.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"\n    {This algorithm calculates the priority of each bin by considering both remaining capacity and a penalty for bins that are too full or too empty, preferring bins that can accommodate the item without excessive leftover space.}\n    \"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            # Calculate the wasted space if the item is placed in this bin\n            wasted_space = cap - item\n            # Penalize bins that are too full (small wasted space) or too empty (large wasted space)\n            priority_score = cap - (wasted_space * 0.5) # Higher score for bins that fit the item well\n            priority.append(priority_score)\n        else:\n            priority.append(-1)  # Assign a low priority if the item doesn't fit\n\n    return priority",
          "objective": 149.30195,
          "other_inf": null
     },
     {
          "algorithm": "Assign a priority score to each bin based on a combination of remaining capacity and wasted space if the item is placed in the bin, favoring bins with tighter fits and avoiding excessive wasted space.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{Assign a priority score to each bin based on a combination of remaining capacity and wasted space if the item is placed in the bin, favoring bins with tighter fits and avoiding excessive wasted space.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            wasted_space = cap - item\n            if wasted_space == 0:\n                priority.append(float('inf'))  # Perfect fit is highest priority\n            else:\n                priority.append(1 / (wasted_space * (1 + (cap > item * 1.5))))  # Prioritize tighter fits, penalize large gaps\n        else:\n            priority.append(-1)  # Cannot fit\n    return priority",
          "objective": Infinity,
          "other_inf": null
     }
]