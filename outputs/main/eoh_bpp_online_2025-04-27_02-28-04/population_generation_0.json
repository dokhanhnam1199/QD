[
     {
          "algorithm": "This algorithm calculates priority scores for each bin based on a combination of remaining capacity and wasted space, aiming to balance bin utilization and minimize fragmentation.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates priority scores for each bin based on a combination of remaining capacity and wasted space, aiming to balance bin utilization and minimize fragmentation.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      wasted_space = cap - item\n      utilization = item / (cap + item)\n      priority_score = utilization - (wasted_space / 1000)  # Minor penalty for wasted space\n    else:\n      priority_score = -1  # Assign a very low priority if the item doesn't fit\n\n    priority.append(priority_score)\n  return priority",
          "objective": 4.04866,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm assigns a priority to each bin based on a combination of remaining capacity and the wasted space if the item is placed in the bin, favoring bins that can accommodate the item with minimal wasted space.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm assigns a priority to each bin based on a combination of remaining capacity and the wasted space if the item is placed in the bin, favoring bins that can accommodate the item with minimal wasted space.}\"\"\"\n  priorities = []\n  for remain_cap in bins_remain_cap:\n    if remain_cap >= item:\n      wasted_space = remain_cap - item\n      priority = remain_cap + (1.0 / (wasted_space + 0.00001)) # Avoid division by zero\n    else:\n      priority = -1  # Assign a very low priority if the item doesn't fit\n    priorities.append(priority)\n  return priority",
          "objective": 4.48744,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm assigns priority based on a combination of remaining capacity and wasted space if the item is placed in the bin, favoring bins with sufficient capacity and minimal waste.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm assigns priority based on a combination of remaining capacity and wasted space if the item is placed in the bin, favoring bins with sufficient capacity and minimal waste.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            priority.append(cap + 1.0/(waste + 0.0001)) #Adding remaining capacity to waste to create the priority score\n        else:\n            priority.append(-1)  # Assign -1 if the item doesn't fit\n    return priority",
          "objective": 86.58755,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin by considering both remaining capacity and a penalty for bins that are too full or too empty, preferring bins that can accommodate the item without excessive leftover space.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"\n    {This algorithm calculates the priority of each bin by considering both remaining capacity and a penalty for bins that are too full or too empty, preferring bins that can accommodate the item without excessive leftover space.}\n    \"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            # Calculate the wasted space if the item is placed in this bin\n            wasted_space = cap - item\n            # Penalize bins that are too full (small wasted space) or too empty (large wasted space)\n            priority_score = cap - (wasted_space * 0.5) # Higher score for bins that fit the item well\n            priority.append(priority_score)\n        else:\n            priority.append(-1)  # Assign a low priority if the item doesn't fit\n\n    return priority",
          "objective": 149.30195,
          "other_inf": null
     },
     {
          "algorithm": "Assign a priority score to each bin based on a combination of remaining capacity and wasted space if the item is placed in the bin, favoring bins with tighter fits and avoiding excessive wasted space.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{Assign a priority score to each bin based on a combination of remaining capacity and wasted space if the item is placed in the bin, favoring bins with tighter fits and avoiding excessive wasted space.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            wasted_space = cap - item\n            if wasted_space == 0:\n                priority.append(float('inf'))  # Perfect fit is highest priority\n            else:\n                priority.append(1 / (wasted_space * (1 + (cap > item * 1.5))))  # Prioritize tighter fits, penalize large gaps\n        else:\n            priority.append(-1)  # Cannot fit\n    return priority",
          "objective": Infinity,
          "other_inf": null
     }
]