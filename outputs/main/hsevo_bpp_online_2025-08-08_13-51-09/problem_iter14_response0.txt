```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines a refined best-fit metric that penalizes both extreme remaining capacities
    with a dynamic weighting strategy that adapts to item size relative to bin availability.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    
    # Metric 1: Refined Best Fit (using log of inverse residual)
    # Penalizes bins that are too full (small residual) or too empty (large residual) after placement.
    remaining_after_placement = suitable_bins_caps - item
    # Use log1p of the inverse of remaining capacity + epsilon. Higher score for residuals closer to 0.
    # Adding 1 to the denominator ensures that even for perfect fits (residual=0), we don't get division by zero.
    # A small epsilon is added to the denominator to prevent division by zero if remaining_after_placement is 0.
    best_fit_scores = np.log1p(1.0 / (remaining_after_placement + 1e-6))

    # Metric 2: Exploration/Spread (using log of current remaining capacity)
    # Favors bins with larger initial remaining capacities, promoting spreading items.
    # Use log1p of remaining capacity. Higher score for larger remaining capacities.
    exploration_scores = np.log1p(suitable_bins_caps)

    # Normalize scores to be in a comparable range [0, 1] for combining.
    # Avoid division by zero if all scores for a metric are zero.
    max_best_fit = np.max(best_fit_scores)
    normalized_best_fit = best_fit_scores / max_best_fit if max_best_fit > 1e-6 else np.zeros_like(best_fit_scores)

    max_exploration = np.max(exploration_scores)
    normalized_exploration = exploration_scores / max_exploration if max_exploration > 1e-6 else np.zeros_like(exploration_scores)

    # Dynamic Weighting: Adjust weights based on item size relative to the maximum remaining capacity of suitable bins.
    # This aims to balance "best fit" for larger items with "exploration" for smaller items.
    max_suitable_cap = np.max(suitable_bins_caps)
    relative_item_size = item / (max_suitable_cap + 1e-6)

    # Weight for Best Fit: Higher for larger items, lower for smaller items.
    # This ensures that for large items, we prioritize a tight fit.
    weight_best_fit = 0.5 + 0.4 * relative_item_size
    weight_best_fit = np.clip(weight_best_fit, 0.5, 0.9)

    # Weight for Exploration: Lower for larger items, higher for smaller items.
    # This encourages spreading smaller items into less utilized bins.
    weight_exploration = 0.5 - 0.4 * relative_item_size
    weight_exploration = np.clip(weight_exploration, 0.1, 0.5)

    # Ensure weights sum to 1
    total_weight = weight_best_fit + weight_exploration
    if total_weight < 1e-6:
        total_weight = 1.0
    
    weight_best_fit /= total_weight
    weight_exploration /= total_weight

    combined_scores = (weight_best_fit * normalized_best_fit +
                       weight_exploration * normalized_exploration)

    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
