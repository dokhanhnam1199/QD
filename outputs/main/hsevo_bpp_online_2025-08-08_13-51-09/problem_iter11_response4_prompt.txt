{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Prioritizes bins by balancing a tight fit (minimal residual space)\n    with an exploration bonus (favoring less utilized bins) using a\n    logarithmic transformation for better distribution.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n\n    # Metric 1: Tight Fit (minimize remaining space after packing)\n    # Use inverse of remaining capacity after packing, add epsilon for stability.\n    # Higher score for smaller remaining space.\n    tightness_score = 1.0 / (suitable_bins_remain_cap - item + 1e-9)\n\n    # Metric 2: Exploration Bonus (favor less utilized bins)\n    # Use log of remaining capacity. Higher score for bins with more remaining capacity.\n    # This encourages using less full bins to potentially improve overall packing.\n    exploration_score = np.log(suitable_bins_remain_cap + 1e-9)\n\n    # Combine scores with weights. Prioritize tightness slightly more.\n    # Weights can be tuned.\n    combined_scores = 0.6 * tightness_score + 0.4 * exploration_score\n\n    # Normalize scores to a [0, 1] range to ensure comparable priorities.\n    # Handle cases where all scores are identical to avoid division by zero.\n    min_score = np.min(combined_scores)\n    max_score = np.max(combined_scores)\n    if max_score - min_score > 1e-9:\n        normalized_scores = (combined_scores - min_score) / (max_score - min_score)\n    else:\n        normalized_scores = np.ones_like(combined_scores) * 0.5 # Mid-range if all equal\n\n    priorities[suitable_bins_mask] = normalized_scores\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]\n\n    # Metric 1: First Fit Decreasing Inspired - Prioritize bins that have enough capacity\n    # but are not excessively large compared to the item. This aims for a balance\n    # between fitting the item and leaving sufficient space for future items.\n    # We use the ratio of bin capacity to item size as a proxy for \"good fit\".\n    # A higher ratio means the bin is \"just enough\" or slightly larger.\n    fit_quality_scores = suitable_bins_caps / item\n    \n    # Metric 2: Remaining Capacity Variance - Prioritize bins that reduce the variance\n    # of remaining capacities among suitable bins. This encourages a more uniform\n    # distribution of remaining capacities, potentially leading to better overall packing.\n    # We want to favor bins that, after placing the item, result in remaining capacities\n    # that are closer to the average remaining capacity.\n    remaining_after_placement = suitable_bins_caps - item\n    \n    if remaining_after_placement.size > 0:\n        mean_remaining = np.mean(remaining_after_placement)\n        # We want bins that result in remaining capacity closer to the mean.\n        # So, the score is inversely proportional to the absolute difference from the mean.\n        variance_reduction_scores = 1.0 / (np.abs(remaining_after_placement - mean_remaining) + 1e-6)\n        \n        # Normalize variance reduction scores to [0, 1]\n        max_vr_score = np.max(variance_reduction_scores)\n        if max_vr_score > 1e-6:\n            normalized_variance_reduction = variance_reduction_scores / max_vr_score\n        else:\n            normalized_variance_reduction = np.ones_like(variance_reduction_scores) * 0.5\n    else:\n        normalized_variance_reduction = np.array([])\n\n    # Normalize fit quality scores to [0, 1]\n    min_fq = np.min(fit_quality_scores)\n    max_fq = np.max(fit_quality_scores)\n    if max_fq - min_fq > 1e-6:\n        normalized_fit_quality = (fit_quality_scores - min_fq) / (max_fq - min_fq)\n    else:\n        normalized_fit_quality = np.ones_like(fit_quality_scores) * 0.5\n\n    # Combine scores with weights.\n    # Giving more weight to fit quality (0.6) as it directly relates to how well\n    # the item fits. The variance reduction (0.4) acts as a secondary objective\n    # to promote better long-term packing.\n    combined_scores = 0.6 * normalized_fit_quality + 0.4 * normalized_variance_reduction\n\n    priorities[suitable_bins_mask] = combined_scores\n\n    return priorities\n\n### Analyze & experience\n- Comparing Heuristics 1st and 2nd: They are identical, indicating no difference in performance.\n\nComparing Heuristics 3rd, 4th, and 5th: These three heuristics are identical, suggesting they represent a single approach with consistent performance. They focus on a weighted sum of \"Best Fit\" and \"Favor Larger Bins\" using min-max scaling for the latter.\n\nComparing Heuristics 6th with 3rd/4th/5th: Heuristic 6th uses a different approach for exploration (less utilized bins) by directly using the difference from min/max suitable bin capacities for its score, and combines it with a negative best-fit score. This suggests a variation in how \"exploration\" is defined and combined.\n\nComparing Heuristics 9th with 1st/2nd: Heuristic 9th introduces a \"Modified Best Fit\" using a quadratic function around a target residual, and a refined \"Exploration Bonus\" with a sigmoid-like function, plus a \"Bin Age/Usage\" proxy. This is a more complex multi-metric approach compared to the simpler linear combinations in 1st/2nd.\n\nComparing Heuristics 10th/11th with 1st/2nd: Heuristics 10th and 11th are identical. They combine a \"tightness_scores\" (inverse of remaining space) with an \"emptiness_bonus\" (log of remaining capacity). This is a different combination than the more complex metrics in Heuristic 1.\n\nComparing Heuristics 12th/13th/14th with 10th/11th: These three heuristics are identical. They are very similar to Heuristics 10th/11th, using inverse of remaining space for tightness, and a normalized remaining capacity (min-max scaled) for exploration. The key difference is the normalization method for exploration and the weighting.\n\nComparing Heuristics 15th with 12th/13th/14th: Heuristic 15th is identical to Heuristics 16th and 17th. It uses inverse of remaining space for Best Fit and log1p of remaining capacity for exploration, then normalizes the exploration score and combines them.\n\nComparing Heuristics 18th/19th with 15th/16th/17th: Heuristics 18th and 19th are identical. They are similar to 15th/16th/17th by using inverse remaining space for tightness and log of remaining capacity for exploration, but normalize the *combined* scores instead of just the exploration component.\n\nComparing Heuristics 20th with others: Heuristic 20th introduces \"Fit Quality\" (ratio of bin capacity to item size) and \"Remaining Capacity Variance\" reduction. This is a distinct approach that doesn't directly use \"Best Fit\" in the same way.\n\nOverall: The heuristics generally explore variations of \"Best Fit\" (minimizing remaining space) and \"Exploration\" (favoring less full bins, or bins with specific properties). Normalization techniques and weighting schemes are varied. The complexity of metrics and their combination seems to loosely correlate with rank, with simpler combinations often appearing higher. Heuristics 7th and 8th are truncated and thus not fully comparable.\n- \nHere's a redefined approach to self-reflection for designing better heuristics:\n\n*   **Keywords:** Balance, Nuance, Justification, Adaptability, Simplicity (with purpose).\n*   **Advice:** Focus on *why* metrics are combined and *how* they interact. Justify normalization and weighting choices. Design heuristics that can adapt to different problem instances or stages of the search.\n*   **Avoid:** Arbitrary metric combinations, overly complex mathematical transformations without clear performance benefits, neglecting the *interpretability* of the heuristic's decisions, and assuming a single \"best\" metric.\n*   **Explanation:** True self-reflection goes beyond listing techniques. It requires critically assessing the *causal link* between a heuristic's design choices and its observed performance, aiming for elegant, well-reasoned solutions rather than just technically complex ones.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}