```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit's tightest fit with a fill ratio consideration,
    prioritizing bins where the item creates a small residual gap relative to
    the bin's capacity, and also considering the item's fill percentage.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    remaining_after_placement = suitable_bins_caps - item

    # Metric 1: Tightest Fit (inverse of remaining capacity after placement)
    # Favors bins with minimal residual space. High score for small residual.
    tight_fit_score = 1.0 / (remaining_after_placement + 1e-9)

    # Metric 2: Fill Ratio (item size relative to current bin capacity)
    # Favors bins where the item takes up a larger proportion of available space.
    # High score for larger item/bin ratio.
    fill_ratio_score = item / (suitable_bins_caps + 1e-9)

    # Combine metrics: Weighted sum.
    # The fill ratio acts as a multiplier for the tight fit score,
    # giving higher priority to tight fits of larger items relative to bin size.
    # This implicitly balances 'tightness' with 'impact'.
    combined_score = tight_fit_score * fill_ratio_score
    
    priorities[suitable_bins_mask] = combined_score
    
    return priorities
```
