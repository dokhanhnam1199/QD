```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit (inverse residual) with a normalized exploration bonus
    (log-transformed remaining capacity), balancing efficiency and spread.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]

    # Metric 1: Best Fit - inverse of remaining space after placement.
    best_fit_scores = 1.0 / (suitable_bins_caps - item + 1e-9)

    # Metric 2: Exploration - log-transformed remaining capacity to favor less utilized bins.
    # Add 1 to avoid log(0) and provide a smoother bonus.
    exploration_scores = np.log1p(suitable_bins_caps)

    # Normalize exploration scores using min-max scaling.
    min_exp_score = np.min(exploration_scores)
    max_exp_score = np.max(exploration_scores)
    if max_exp_score - min_exp_score > 1e-9:
        normalized_exploration_scores = (exploration_scores - min_exp_score) / (max_exp_score - min_exp_score)
    else:
        normalized_exploration_scores = np.zeros_like(exploration_scores)

    # Combine scores with a focus on Best Fit (0.7) and balanced exploration (0.3).
    # This combination aims for efficient packing while encouraging better bin distribution.
    combined_scores = 0.7 * best_fit_scores + 0.3 * normalized_exploration_scores

    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
