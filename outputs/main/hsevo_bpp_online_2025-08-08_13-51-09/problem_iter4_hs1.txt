import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.00036370479989213345, sigmoid_k: float = 1.8603580050459216, sigmoid_center_offset: float = 0.3074885813322803) -> np.ndarray:
    """
    Combines the 'tight fit' prioritization of inverse difference with a sigmoid
    function to normalize priorities, favoring bins that are a near-perfect fit
    while maintaining a reasonable range.

    Args:
        item (float): The item size to fit.
        bins_remain_cap (np.ndarray): A numpy array representing the remaining capacity of each bin.
        epsilon (float): A small value added to the denominator to prevent division by zero.
        sigmoid_k (float): The steepness parameter for the sigmoid function.
        sigmoid_center_offset (float): The offset to center the sigmoid curve.

    Returns:
        np.ndarray: An array of priorities for each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins_mask = bins_remain_cap >= item
    
    if not np.any(valid_bins_mask):
        return priorities

    valid_bins_cap = bins_remain_cap[valid_bins_mask]
    
    # Calculate inverse difference for valid bins: smaller difference is better
    inverse_diff = 1.0 / (valid_bins_cap - item + epsilon)
    
    min_inv_diff = np.min(inverse_diff)
    max_inv_diff = np.max(inverse_diff)
    
    # Normalize inverse_diff to [0, 1] before applying sigmoid for more stable results
    if max_inv_diff - min_inv_diff > 1e-9:
        normalized_inv_diff = (inverse_diff - min_inv_diff) / (max_inv_diff - min_inv_diff)
    else:
        normalized_inv_diff = np.zeros_like(inverse_diff)

    # Apply sigmoid. A sigmoid centered around 0.5 (e.g., 2 * x - 1 for normalized input)
    # will map [0, 1] to roughly [0, 1], with a steep rise in the middle.
    scaled_priorities = 1 / (1 + np.exp(-sigmoid_k * (normalized_inv_diff - sigmoid_center_offset)))

    priorities[valid_bins_mask] = scaled_priorities
    
    return priorities
