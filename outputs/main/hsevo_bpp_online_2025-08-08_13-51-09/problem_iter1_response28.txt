```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap)
    
    # Prioritize bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    # Heuristic: Prioritize bins with least remaining capacity that can still fit the item
    # This is a "best fit" approach.
    fitting_bins_capacity = bins_remain_cap[can_fit_mask]
    if fitting_bins_capacity.size > 0:
        # Calculate the "waste" if the item is placed in these bins
        waste = fitting_bins_capacity - item
        # Higher priority for bins with less waste (i.e., tighter fit)
        # We invert the waste because we want the smallest waste to have the highest priority
        # Add a small epsilon to avoid division by zero or very large negative numbers if waste is 0
        priorities[can_fit_mask] = 1.0 / (waste + 1e-9)
    
    # A small random component can be added for exploration (epsilon-greedy like behavior)
    # For simplicity in this priority function, we are directly implementing the greedy part.
    # The epsilon-greedy strategy would then decide whether to pick the best fit (greedy)
    # or a random bin. This priority function is solely for the greedy selection.
    
    return priorities
```
