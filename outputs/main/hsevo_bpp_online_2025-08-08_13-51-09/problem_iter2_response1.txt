```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best Fit with a Sigmoid-based preference for tighter fits.

    Prioritizes bins that fit the item, favoring those with minimal remaining capacity.
    A sigmoid function is used to smooth the priority for bins with very close fits.
    """
    available_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if np.any(available_bins_mask):
        valid_capacities = bins_remain_cap[available_bins_mask]
        
        # Calculate the difference between capacity and item size
        differences = valid_capacities - item
        
        # Use a sigmoid function on the negative differences. 
        # Smaller differences (tighter fits) will result in values closer to 1.
        # We invert the difference to make smaller differences yield higher sigmoid outputs.
        # Adding a small epsilon to avoid division by zero if differences are very close to zero.
        # Scaling factor can be tuned for sensitivity.
        scaling_factor = 10.0  # More aggressive preference for tight fits
        # Using negative differences as input for sigmoid to map smaller differences to higher outputs.
        sigmoided_priorities = 1 / (1 + np.exp(scaling_factor * differences)) 
        
        priorities[available_bins_mask] = sigmoided_priorities

    return priorities
```
