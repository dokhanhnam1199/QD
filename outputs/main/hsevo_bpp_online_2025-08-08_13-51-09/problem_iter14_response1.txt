```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A hybrid heuristic combining Best Fit (tightness) with dynamic exploration,
    adapting weights based on item size to balance packing efficiency and bin utilization.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    remaining_after_placement = suitable_bins_caps - item

    # Metric 1: Refined Best Fit - favors bins with smallest remaining capacity after placement.
    # Logarithmic scaling to compress larger gaps and emphasize smaller ones. Add epsilon for stability.
    best_fit_scores = np.log1p(1.0 / (remaining_after_placement + 1e-6))

    # Metric 2: Exploration Bonus - favors bins with more remaining capacity.
    # Min-max scaling to normalize the exploration score between 0 and 1.
    min_rem_after = np.min(remaining_after_placement)
    max_rem_after = np.max(remaining_after_placement)
    
    exploration_scores = np.zeros_like(remaining_after_placement)
    if max_rem_after > min_rem_after:
        exploration_scores = (remaining_after_placement - min_rem_after) / (max_rem_after - min_rem_after)
    elif suitable_bins_caps.size > 0: # If all suitable bins have same remaining space, give equal exploration bonus if any
        exploration_scores = np.ones_like(remaining_after_placement) * 0.5

    # Dynamic Weighting based on item size relative to a conceptual bin capacity of 1.0.
    # This aims to use Best Fit more for larger items and Exploration for smaller ones.
    # A smoother transition using a sigmoid-like approach or clipping.
    # Assume item size is already normalized or scaled appropriately.
    
    # Define a soft transition point (e.g., 0.5 for half-full bins)
    transition_point = 0.5
    
    # Calculate weights: higher weight for best_fit for larger items, higher for exploration for smaller items.
    # Use clipping to ensure weights stay within a reasonable range and sum approximately to 1.
    weight_best_fit = np.clip(item / transition_point, 0.2, 0.9)
    weight_exploration = 1.0 - weight_best_fit

    # Ensure weights are sensible and sum to 1
    total_weight = weight_best_fit + weight_exploration
    if total_weight > 1e-6:
        weight_best_fit /= total_weight
        weight_exploration /= total_weight
    else: # Fallback if weights are zero
        weight_best_fit = 0.5
        weight_exploration = 0.5

    # Combine scores using dynamic weights
    combined_scores = (weight_best_fit * best_fit_scores +
                       weight_exploration * exploration_scores)

    # Assign combined scores to the priorities array
    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
