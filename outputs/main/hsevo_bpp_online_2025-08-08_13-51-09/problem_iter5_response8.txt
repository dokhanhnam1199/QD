```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a normalized exploration bonus based on remaining capacity.
    Prioritizes tight fits and encourages exploring less utilized bins.
    """
    epsilon = 0.1
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    suitable_bins_mask = bins_remain_cap >= item

    if np.any(suitable_bins_mask):
        suitable_bins_cap = bins_remain_cap[suitable_bins_mask]

        # Best Fit component: Inverse of remaining capacity after placement.
        # Higher score for bins with less remaining space after fitting the item.
        best_fit_score = 1.0 / (suitable_bins_cap - item + 1e-9)

        # Exploration component: Normalized bonus for larger remaining capacity.
        # Uses min-max scaling to provide a bonus to bins with more free space,
        # relative to other suitable bins. This encourages diversification.
        exploration_bonus = np.zeros_like(suitable_bins_cap, dtype=float)
        if suitable_bins_cap.size > 1:
            min_cap_suitable = np.min(suitable_bins_cap)
            max_cap_suitable = np.max(suitable_bins_cap)
            range_cap_suitable = max_cap_suitable - min_cap_suitable
            if range_cap_suitable > 1e-9:
                exploration_bonus = epsilon * (suitable_bins_cap - min_cap_suitable) / range_cap_suitable
            else:
                exploration_bonus = np.zeros_like(suitable_bins_cap) # All suitable bins have same capacity

        # Combine scores: Weighted sum of Best Fit and Exploration Bonus.
        # This balances the preference for tight fits with the need to explore.
        combined_score = best_fit_score + exploration_bonus
        priorities[suitable_bins_mask] = combined_score

    return priorities
```
