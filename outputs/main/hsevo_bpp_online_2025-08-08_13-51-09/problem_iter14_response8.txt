```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines a refined Best Fit with a dynamic Exploration bonus,
    balancing tightness and spreading load based on item size.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    remaining_after_placement = suitable_bins_caps - item

    # Metric 1: Refined Best Fit - favors bins with smallest remaining capacity after placement.
    # Logarithmic scaling emphasizes smaller remaining capacities. Add epsilon for stability.
    best_fit_scores = np.log1p(1.0 / (remaining_after_placement + 1e-6))

    # Metric 2: Exploration Bonus - favors bins that have significantly more remaining capacity.
    # Min-max scaling of remaining capacity after placement creates a [0, 1] score.
    min_rem_after = np.min(remaining_after_placement)
    max_rem_after = np.max(remaining_after_placement)

    exploration_scores = np.zeros_like(remaining_after_placement)
    if max_rem_after > min_rem_after:
        exploration_scores = (remaining_after_placement - min_rem_after) / (max_rem_after - min_rem_after)
    else:
        # If all suitable bins leave the same remaining capacity, exploration score is uniform.
        exploration_scores = np.ones_like(remaining_after_placement) * 0.5 # Neutral exploration

    # Dynamic Weighting based on item size.
    # Larger items benefit more from a precise fit (Best Fit).
    # Smaller items can afford to explore less utilized bins (Exploration Bonus).
    # Assumes 'item' is scaled relative to typical bin capacity (e.g., 0 to 1).
    
    # Threshold for item size to switch weighting strategy.
    threshold_medium = 0.5 
    
    # Calculate weights smoothly based on item size relative to threshold.
    # For small items (item < threshold), exploration weight is higher.
    # For large items (item > threshold), best_fit weight is higher.
    weight_best_fit = np.clip(item / threshold_medium, 0.1, 1.0) 
    weight_exploration = np.clip((threshold_medium - item) / threshold_medium, 0.1, 1.0) 

    # Normalize weights to ensure they sum to 1, preventing issues if they fall outside intended ranges.
    total_weight = weight_best_fit + weight_exploration
    if total_weight > 1e-6:
        weight_best_fit /= total_weight
        weight_exploration /= total_weight
    else: 
        # Fallback to equal weights if calculation results in near-zero total weight.
        weight_best_fit = 0.5
        weight_exploration = 0.5

    # Combine scores using the dynamically determined weights.
    combined_scores = (weight_best_fit * best_fit_scores +
                       weight_exploration * exploration_scores)

    # Assign the calculated combined scores to the priorities array for suitable bins.
    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
