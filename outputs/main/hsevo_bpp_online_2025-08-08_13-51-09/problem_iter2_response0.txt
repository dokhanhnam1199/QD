```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines the 'tight fit' prioritization of inverse difference with a sigmoid
    function to normalize priorities, favoring bins that are a near-perfect fit
    while maintaining a reasonable range.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins_mask = bins_remain_cap >= item
    
    if not np.any(valid_bins_mask):
        return priorities

    valid_bins_cap = bins_remain_cap[valid_bins_mask]
    
    # Calculate inverse difference for valid bins: smaller difference is better
    # Adding a small epsilon to avoid division by zero and extreme values
    inverse_diff = 1.0 / (valid_bins_cap - item + 1e-9)
    
    # Use sigmoid to normalize and shape the priorities.
    # The sigmoid will map the inverse differences to a [0, 1] range.
    # We can center the sigmoid around a typical "good fit" or use the min/max
    # of the calculated inverse differences to create a more adaptive scaling.
    
    min_inv_diff = np.min(inverse_diff)
    max_inv_diff = np.max(inverse_diff)
    
    # Normalize inverse_diff to [0, 1] before applying sigmoid for more stable results
    if max_inv_diff - min_inv_diff > 1e-9:
        normalized_inv_diff = (inverse_diff - min_inv_diff) / (max_inv_diff - min_inv_diff)
    else:
        normalized_inv_diff = np.zeros_like(inverse_diff)

    # Apply sigmoid. A sigmoid centered around 0.5 (e.g., 2 * x - 1 for normalized input)
    # will map [0, 1] to roughly [0, 1], with a steep rise in the middle.
    # Here, we use a simple sigmoid form that maps values to [0, 1].
    # A common sigmoid form: 1 / (1 + exp(-k * (x - x0)))
    # Let's use a simpler form for demonstration, similar to a normalized inverse:
    # We want smaller differences (larger inverse_diff) to have higher priority.
    # A high inverse_diff should map to a high sigmoid output.
    # Using normalized_inv_diff, a higher value means a tighter fit.
    # Let's use a sigmoid that emphasizes the middle range.
    
    # Option 1: Simple sigmoid on normalized inverse difference
    # This will give higher priority to bins that are "moderately" good fits
    # relative to the best fits.
    scaled_priorities = 1 / (1 + np.exp(-10 * (normalized_inv_diff - 0.5))) # steep sigmoid

    # Option 2: Direct sigmoid on inverse difference, scaled and shifted.
    # This approach might be more sensitive to extreme inverse_diff values.
    # We can scale inverse_diff to a reasonable range for sigmoid.
    # Let's use the inverse difference directly, but clip extreme values or scale carefully.
    # For simplicity and robustness, sticking with normalized inverse difference.

    priorities[valid_bins_mask] = scaled_priorities
    
    return priorities
```
