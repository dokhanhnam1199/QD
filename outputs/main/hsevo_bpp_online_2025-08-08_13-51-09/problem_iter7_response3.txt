import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, 
                  fit_weight: float = 0.6981269792333498, 
                  diversification_weight: float = 0.4051856347535071,
                  epsilon: float = 0.00027915816359466863) -> np.ndarray:
    """
    Combines tight fit with diversified exploration using scaled inverse remaining capacity
    and a weighted sum.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]
    
    if valid_bins_remain_cap.size > 0:
        # Metric 1: Tight Fit Score (inverse of remaining capacity after fitting)
        # Favors bins that will have less space left after item is placed.
        fit_scores = 1.0 / (valid_bins_remain_cap - item + epsilon)
        
        # Metric 2: Diversification Bonus (inverse of current remaining capacity)
        # Favors less utilized bins to prevent premature concentration.
        # Use original remaining capacity for this, scaled.
        diversification_scores = 1.0 / (bins_remain_cap[valid_bins_mask] + epsilon)
        
        # Combine using a weighted sum.
        combined_priorities = fit_weight * fit_scores + diversification_weight * diversification_scores
        
        # Assign priorities back to the original array
        priorities[valid_bins_mask] = combined_priorities
        
        # Normalize priorities to ensure the highest score is clearly dominant
        max_priority = np.max(priorities[valid_bins_mask])
        if max_priority > 0:
            priorities[valid_bins_mask] /= max_priority
            
    return priorities
