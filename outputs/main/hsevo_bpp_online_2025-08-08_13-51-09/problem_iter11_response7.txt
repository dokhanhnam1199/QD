The goal is to create a `priority_v2` heuristic that combines the strengths of previously analyzed heuristics. Based on the analysis, heuristics that balance "Best Fit" with a nuanced "Exploration" strategy often perform well. Heuristic 1 (now `priority_v0`) offers a sophisticated multi-metric approach with dynamic weighting based on item size. Heuristics like 10th/11th and 12th/13th/14th/15th/16th/17th show promise in combining inverse remaining space with log-based or normalized remaining capacity scores.

Let's aim to create `priority_v2` by:
1.  **Best Fit Component:** Similar to `priority_v0` and others, using the inverse of remaining capacity (`1 / (remaining_after_placement + epsilon)`) to strongly favor bins where an item fits snugly. This captures the core of Best Fit.
2.  **Exploration/Uniformity Component:** Instead of a complex sigmoid as in `priority_v0`, let's use a simpler but effective approach inspired by the log-based scores in 10th/11th and the normalized capacity in 12th/13th/14th. We'll use `log1p(remaining_capacity)` to reward bins that have more open space, but in a way that tapers off, preventing extremely large scores for very empty bins. This subtly encourages spreading items.
3.  **Combined Strategy:** A weighted sum of these two components. The weights should provide a tunable balance. A slight bias towards Best Fit seems reasonable for BPP, but exploration is also important for longer-term performance. We can use fixed weights for simplicity, or introduce dynamic weighting if complexity is manageable. For `priority_v2`, let's use fixed weights for clarity.

Specifically, we'll combine:
*   `1.0 / (remaining_after_placement + epsilon)` for "Best Fit".
*   `np.log1p(remaining_after_placement)` for "Exploration/Uniformity".

The combination will be a weighted sum, prioritizing Best Fit slightly more.

```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines a strong 'Best Fit' strategy with a 'Logarithmic Exploration' bonus.
    Prioritizes snugly fitting items while also giving a slight preference
    to bins with more remaining capacity to encourage spread.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    remaining_after_placement = suitable_bins_caps - item

    # Metric 1: Best Fit - favors bins with minimum remaining space after placement.
    # Using reciprocal emphasizes smaller remaining capacities.
    # Add epsilon to avoid division by zero.
    best_fit_scores = 1.0 / (remaining_after_placement + 1e-6)

    # Metric 2: Exploration/Uniformity - favors bins with more open space.
    # Using log1p compresses the range of remaining capacities, giving a boost
    # to moderately open bins without overly favoring extremely empty ones.
    exploration_scores = np.log1p(suitable_bins_caps)

    # Combine scores with weights.
    # Weighting: Give more importance to Best Fit, but include Exploration.
    # A weight of 0.7 for Best Fit and 0.3 for Exploration offers a good balance.
    weight_best_fit = 0.7
    weight_exploration = 0.3

    combined_scores = (weight_best_fit * best_fit_scores +
                       weight_exploration * exploration_scores)

    # Apply combined scores to the priorities array
    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
