```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tight fit with diversified exploration using scaled inverse remaining capacity
    and a sigmoid-based penalty for bins that are too full.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]
    
    if valid_bins_remain_cap.size > 0:
        # Metric 1: Tight Fit Score (inverse of remaining capacity after fitting)
        # Favors bins that will have less space left after item is placed.
        fit_scores = 1.0 / (valid_bins_remain_cap - item + 1e-9)
        
        # Metric 2: Diversification Bonus (inverse of current remaining capacity)
        # Favors less utilized bins to prevent premature concentration.
        # Use original remaining capacity for this, scaled.
        diversification_scores = 1.0 / (bins_remain_cap[valid_bins_mask] + 1e-9)
        
        # Combine using a weighted sum. Heuristic 19/20's balanced approach inspires this.
        # We give slightly more weight to the tight fit, but diversification is significant.
        combined_priorities = 0.6 * fit_scores + 0.4 * diversification_scores
        
        # Assign priorities back to the original array
        priorities[valid_bins_mask] = combined_priorities
        
        # Normalize priorities to ensure the highest score is clearly dominant
        max_priority = np.max(priorities[valid_bins_mask])
        if max_priority > 0:
            priorities[valid_bins_mask] /= max_priority
            
    return priorities
```
