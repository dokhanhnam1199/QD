```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit (tightest residual space) with a preference for bins
    that have more remaining capacity after placement, using normalized scores.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    
    # Metric 1: Best Fit - prioritize bins with minimal remaining capacity after placement.
    # Higher score for smaller remaining capacity.
    remaining_after_placement = suitable_bins_caps - item
    best_fit_scores = 1.0 / (remaining_after_placement + 1e-6)
    
    # Metric 2: Favor bins with more remaining capacity *after* placement.
    # This encourages spreading items out rather than packing too tightly if possible.
    # Using the remaining capacity *after* placement as a diversification metric.
    large_remaining_bin_scores = suitable_bins_caps - item

    # Normalize Best Fit scores
    max_bf = np.max(best_fit_scores)
    if max_bf > 1e-6:
        normalized_best_fit = best_fit_scores / max_bf
    else:
        normalized_best_fit = np.zeros_like(best_fit_scores)

    # Normalize Large Remaining Bin scores (higher is better for diversification)
    max_lrb = np.max(large_remaining_bin_scores)
    if max_lrb > 1e-6:
        normalized_large_remaining = large_remaining_bin_scores / max_lrb
    else:
        normalized_large_remaining = np.zeros_like(large_remaining_bin_scores)

    # Combine normalized scores: A weighted sum.
    # We slightly favor Best Fit (0.7) but also consider diversification (0.3).
    combined_scores = 0.7 * normalized_best_fit + 0.3 * normalized_large_remaining
    
    priorities[suitable_bins_mask] = combined_scores
    
    return priorities
```
