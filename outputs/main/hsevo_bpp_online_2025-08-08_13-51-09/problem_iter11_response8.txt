```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with a normalized bonus for larger remaining capacity,
    using a weighted sum for balanced decision-making. Favors bins that are
    nearly full but can still accommodate the item.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    
    # Metric 1: Best Fit - prioritize bins with minimal remaining capacity after placement.
    # Add a small epsilon to avoid division by zero and ensure non-zero scores for tight fits.
    remaining_after_placement = suitable_bins_caps - item
    best_fit_scores = 1.0 / (remaining_after_placement + 1e-6)
    
    # Metric 2: Exploration/Emptiness Bonus - reward bins that are less utilized initially.
    # Using log1p to handle zero capacities gracefully and provide diminishing returns.
    emptiness_bonus_scores = np.log1p(suitable_bins_caps)
    
    # Normalize Best Fit scores using min-max scaling.
    if suitable_bins_caps.size > 1:
        min_bf = np.min(best_fit_scores)
        max_bf = np.max(best_fit_scores)
        range_bf = max_bf - min_bf
        if range_bf > 1e-6:
            normalized_best_fit = (best_fit_scores - min_bf) / range_bf
        else:
            normalized_best_fit = np.zeros_like(best_fit_scores) # All suitable bins offer same tightness
    elif suitable_bins_caps.size == 1:
        normalized_best_fit = np.array([1.0]) # Only one suitable bin, highest possible score
    else:
        normalized_best_fit = np.zeros_like(best_fit_scores)

    # Normalize Emptiness Bonus scores using min-max scaling.
    if suitable_bins_caps.size > 1:
        min_eb = np.min(emptiness_bonus_scores)
        max_eb = np.max(emptiness_bonus_scores)
        range_eb = max_eb - min_eb
        if range_eb > 1e-6:
            normalized_emptiness_bonus = (emptiness_bonus_scores - min_eb) / range_eb
        else:
            normalized_emptiness_bonus = np.zeros_like(emptiness_bonus_scores) # All suitable bins have same emptiness
    elif suitable_bins_caps.size == 1:
        normalized_emptiness_bonus = np.array([1.0]) # Only one suitable bin, highest possible score
    else:
        normalized_emptiness_bonus = np.zeros_like(emptiness_bonus_scores)

    # Combine normalized scores using a weighted sum.
    # Increased weight on best fit, while still providing a bonus for less full bins.
    # Weights are tuned to balance immediate fit with longer-term space utilization.
    combined_scores = 0.7 * normalized_best_fit + 0.3 * normalized_emptiness_bonus
    
    priorities[suitable_bins_mask] = combined_scores
    
    return priorities
```
