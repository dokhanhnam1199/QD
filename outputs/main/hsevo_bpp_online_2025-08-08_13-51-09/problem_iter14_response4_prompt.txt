{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines Best Fit's tightness with an exploration bonus favoring less utilized bins,\n    using a balanced approach to combine these factors.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return np.zeros_like(bins_remain_cap)\n\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n\n    # Best Fit Component: Prioritize bins with minimal remaining capacity after placement.\n    # Negative of remaining capacity to favor smaller (more negative) values for minimization.\n    best_fit_scores = -(suitable_bins_remain_cap - item)\n\n    # Exploration Component: Favor bins that are less utilized (larger original capacity).\n    # Normalize remaining capacities of suitable bins using min-max scaling.\n    min_cap = np.min(suitable_bins_remain_cap)\n    max_cap = np.max(suitable_bins_remain_cap)\n    if max_cap - min_cap > 1e-9:\n        exploration_scores = (suitable_bins_remain_cap - min_cap) / (max_cap - min_cap)\n    else:\n        exploration_scores = np.zeros_like(suitable_bins_remain_cap)\n\n    # Combined Score: Balance Best Fit and Exploration.\n    # A weighted sum is used. We give a slightly higher weight to Best Fit (tightness)\n    # as it's generally a primary goal in BPP, while exploration acts as a tie-breaker\n    # or secondary optimization.\n    # We add exploration_scores to best_fit_scores. Higher values (closer to zero for BF) are better.\n    # Exploration scores are positive and higher is better.\n    combined_scores = best_fit_scores + 0.7 * exploration_scores # Weight for exploration\n\n    priorities[suitable_bins_mask] = combined_scores\n\n    # If all suitable bins are identical in terms of combined score, argmin will pick the first.\n    # This heuristic aims to find a good balance, leaning towards tight fits but\n    # considering bin utilization as a secondary factor.\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines tightest fit (inverse residual) with a normalized exploration bonus\n    (log-transformed remaining capacity), balancing efficiency and spread.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]\n\n    # Metric 1: Best Fit - inverse of remaining space after placement.\n    best_fit_scores = 1.0 / (suitable_bins_caps - item + 1e-9)\n\n    # Metric 2: Exploration - log-transformed remaining capacity to favor less utilized bins.\n    # Add 1 to avoid log(0) and provide a smoother bonus.\n    exploration_scores = np.log1p(suitable_bins_caps)\n\n    # Normalize exploration scores using min-max scaling.\n    min_exp_score = np.min(exploration_scores)\n    max_exp_score = np.max(exploration_scores)\n    if max_exp_score - min_exp_score > 1e-9:\n        normalized_exploration_scores = (exploration_scores - min_exp_score) / (max_exp_score - min_exp_score)\n    else:\n        normalized_exploration_scores = np.zeros_like(exploration_scores)\n\n    # Combine scores with a focus on Best Fit (0.7) and balanced exploration (0.3).\n    # This combination aims for efficient packing while encouraging better bin distribution.\n    combined_scores = 0.7 * best_fit_scores + 0.3 * normalized_exploration_scores\n\n    priorities[suitable_bins_mask] = combined_scores\n\n    return priorities\n\n### Analyze & experience\n- Comparing Heuristics 1 and 2 (identical): They implement three metrics: Best Fit, Gap Exploitation, and Bin Fill Similarity, with dynamic weighting based on item size relative to max suitable capacity. The weights adapt to prioritize Best Fit for larger items and Gap Exploitation/Fill Similarity for smaller ones. Normalization is applied to each metric before combining.\n\nComparing Heuristics 3 and 4: Heuristic 3 combines Best Fit (tightness) with Exploration (larger initial capacity) using a fixed weighted sum. Heuristic 4 combines Best Fit (negative remaining capacity) with Exploration (normalized remaining capacity) using a weighted sum, favoring Best Fit. Heuristic 3 normalizes component scores via min-max scaling, while Heuristic 4 uses direct combination.\n\nComparing Heuristics 5, 6, 7, 8 (identical): These heuristics also use Best Fit (relative remaining capacity), Bin Fullness (inverse of remaining capacity), and Item Size Ratio. They employ dynamic weighting based on the item's size relative to the average suitable bin capacity. The weights adapt to prioritize Best Fit and Fullness for larger items, and Item Ratio/Fullness for smaller items. Normalization is applied to each metric before weighted combination.\n\nComparing Heuristics 9 and 10, 11, 12 (identical): Heuristic 9 combines Best Fit (tightness) with a fairness penalty (deviation from average remaining capacity). Heuristics 10-12 combine Modified Best Fit (sweet spot residual), Exploration (normalized remaining capacity after placement), and Usage Proxy (normalized current remaining capacity) with fixed weights.\n\nComparing Heuristics 13, 14, 15 (identical): These combine Refined Best Fit (log1p of inverse residual) with Exploration (min-max scaled remaining capacity after placement), using dynamic weights based on item size relative to a threshold.\n\nComparing Heuristics 16, 17, 18, 19, 20 (identical): These combine Best Fit (inverse residual) with Exploration (log1p or log of remaining capacity). They use fixed weights and normalize the combined score. Heuristics 17-18 have slightly different weights (0.55/0.45) than 19-20 (0.55/0.45) and 16 (0.7/0.3) for Best Fit vs. Exploration.\n\nOverall: The best heuristics (1-8) tend to use multiple metrics and adapt their weighting dynamically based on item characteristics or bin states, often involving normalization of individual metrics or the final combined score. Simpler fixed-weight combinations of Best Fit and Exploration (like 16-20) are less sophisticated but might be more robust. The use of logarithmic or Gaussian-like functions for scoring can provide smoother preference curves.\n- \nHere's a redefined approach to self-reflection for designing better heuristics:\n\n*   **Keywords:** Metric selection, dynamic weighting, normalization, balance, robustness, simplicity.\n*   **Advice:** Focus on a core set of well-defined, interpretable metrics. Systematically explore dynamic weighting and robust normalization techniques. Aim for a balance between primary objectives and secondary goals like diversification or exploration.\n*   **Avoid:** Overly complex or opaque mathematical transformations, unstable calculations, and prioritizing single, overly simplistic metrics.\n*   **Explanation:** Effective self-reflection identifies *how* and *why* certain metric combinations and adjustments lead to improved performance by understanding their impact on the problem's core objectives.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}