```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Almost Full Fit strategy for Online Bin Packing Problem.
    Prioritizes bins that are "almost full" and can accommodate the item.
    A bin is considered "almost full" if its remaining capacity is
    just enough to fit the item, plus a small tolerance.
    """
    bin_capacity = 1.0  # Assuming standard bin capacity of 1.0
    tolerance = 0.05   # A small tolerance for "almost full"

    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can accommodate the item
    fitting_bins_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate priority based on "almost full" criteria
    # Higher priority for bins that are closer to being full (but still fit the item)
    almost_full_priority_values = np.where(
        fitting_bins_mask,
        bin_capacity - (bins_remain_cap - item),
        0  # Bins that cannot fit the item get zero priority
    )

    # Adjust priorities to favor bins that are "almost full"
    # A bin is "almost full" if its remaining capacity after adding the item is small
    # The formula bin_capacity - (bins_remain_cap - item) effectively penalizes
    # bins that have a lot of remaining capacity after the item is placed.
    # A smaller (bins_remain_cap - item) means the bin is "more full".

    # Let's refine the "almost full" definition:
    # We want to pick a bin such that after placing the item, the remaining capacity
    # is as small as possible, but still positive.
    # Remaining capacity after placing item: `bins_remain_cap - item`
    # We want to minimize this value for fitting bins.
    # So, for fitting bins, priority can be inversely related to `bins_remain_cap - item`.
    # Or directly related to `item - (bin_capacity - bins_remain_cap)` which is the space utilized.
    # To make it "almost full", we want the `bins_remain_cap - item` to be close to 0.
    # A simple way is to maximize `item` that fits. But that's best fit.
    # For Almost Full Fit, we want the `bins_remain_cap` to be *just* above `item`.

    # Let's try a priority that is high if `bins_remain_cap` is slightly larger than `item`.
    # A good heuristic might be to prioritize bins where `bins_remain_cap - item` is minimal,
    # but still non-negative.
    # We can use the negative of the remaining capacity after fitting the item as priority.
    # This way, the smallest positive remaining capacity (most "full" bin) gets the highest negative value (largest magnitude).
    # Or, we can use the absolute difference from a target "almost full" state.
    # Target "almost full" state: remaining capacity is `tolerance`.
    # So, priority is high when `bins_remain_cap - item` is close to `tolerance`.
    # This means `bins_remain_cap` is close to `item + tolerance`.

    priorities = np.zeros_like(bins_remain_cap)
    for i in range(len(bins_remain_cap)):
        if bins_remain_cap[i] >= item:
            # Higher priority for bins where remaining capacity is close to `item + tolerance`
            # We want to maximize the "closeness" to this target.
            # Let's define closeness as `abs((bins_remain_cap[i] - item) - tolerance)`
            # And we want to minimize this closeness. So priority is `-abs(...)`
            # Or, we want `bins_remain_cap[i]` to be close to `item + tolerance`.
            # A higher value for `bins_remain_cap[i]` that is still acceptable (e.g., slightly larger than item)
            # might be less preferred than a tighter fit.
            #
            # The "Almost Full Fit" strategy aims to fill bins as much as possible,
            # but prefers bins that are *just* able to fit the item without much slack.
            # So, we want `bins_remain_cap[i]` to be *just* greater than `item`.
            # A good measure is `bins_remain_cap[i] - item`. We want this to be small and positive.
            #
            # Let's consider `bins_remain_cap[i] - item` as the "slack".
            # We want to minimize slack.
            # Priority can be the negative of the slack: `- (bins_remain_cap[i] - item)`
            # However, this doesn't distinguish between "almost full" and simply fitting.
            #
            # "Almost full" implies we are looking for a bin whose current remaining capacity
            # is just slightly more than the item's size.
            #
            # Let's consider the *target remaining capacity* to be `item + epsilon` where epsilon is small.
            # If `bins_remain_cap[i]` is greater than `item + tolerance`, it's less "almost full"
            # than a bin where `item <= bins_remain_cap[i] <= item + tolerance`.
            #
            # Strategy:
            # 1. Prioritize bins that can fit the item.
            # 2. Among fitting bins, prioritize those where the remaining capacity after placing
            #    the item is small (i.e., `bins_remain_cap[i] - item` is small and positive).
            #
            # A simple priority could be to maximize `bins_remain_cap[i]`. This is First Fit.
            # Best Fit is to minimize `bins_remain_cap[i]` among fitting bins.
            #
            # For "Almost Full Fit", we are looking for a bin that's already quite full,
            # but still has space for the current item.
            #
            # Let's define a "near fit" condition: `item <= bins_remain_cap[i] < item + tolerance`.
            # Among these, pick the one with the smallest `bins_remain_cap[i]`.
            # If no such bin exists, fall back to something else.

            # Revised approach for "Almost Full Fit":
            # Prioritize bins that have a remaining capacity `r` such that `r - item` is minimized and non-negative.
            # However, this is Best Fit.
            # For "Almost Full", we are looking for bins that have a remaining capacity `r`
            # such that `r` is small, and `r >= item`.
            #
            # Let's assign a higher priority to bins whose remaining capacity is just slightly
            # larger than the item size.
            #
            # If `bins_remain_cap[i]` is very close to `item` (e.g., `bins_remain_cap[i] - item` is small),
            # that bin is considered "almost full" for this item.

            # A direct measure of "almost full" for a bin with capacity `c` to fit an item `i`:
            # Consider the slack `s = c - i`. We want to find a bin where `s` is small and non-negative.
            # This is Best Fit.
            #
            # The "Almost Full Fit" (or FFD-like) heuristics often prioritize bins that *are* almost full,
            # meaning their current `bins_remain_cap` is high, but not excessively high.
            #
            # Let's try to define priority as a score that is higher for bins that are
            # "nearly full" AND can fit the item.
            #
            # Consider the available space *after* placing the item: `bins_remain_cap[i] - item`.
            # We want this to be small.
            #
            # Perhaps a simpler interpretation of "Almost Full Fit":
            # Prioritize bins that are more filled, but can still accommodate the item.
            # This means picking a bin `i` that minimizes `bins_remain_cap[i]` *among those that fit*.
            # This is the Best Fit strategy.

            # If we strictly follow "Almost Full Fit" as filling bins that are already quite full:
            # It means bins with large `bins_remain_cap` are generally preferred if they can fit the item.
            # But "almost full" implies not *too* much remaining space.
            #
            # Let's try to capture the idea that the remaining capacity is substantial, but not excessive.
            #
            # Consider the space *utilized* by the item in a bin with `bins_remain_cap[i]`.
            # The percentage of the bin utilized by the *item* is `item / (bin_capacity - bins_remain_cap[i] + item)`
            # No, that's not quite right.
            #
            # The concept is that we have a set of bins that are already quite full.
            # We want to pick one that is "almost full" to put the item into.
            #
            # Let's assign a priority that is high if `bins_remain_cap[i]` is large,
            # but not so large that it leaves excessive empty space.
            #
            # Try this: priority is high if `bins_remain_cap[i]` is large,
            # but we want to penalize bins that leave a large *residual capacity* after the item is placed.
            #
            # Let's revisit the idea: find bins where `bins_remain_cap[i]` is just enough for the item,
            # plus some small amount of slack.
            #
            # Consider a target `bins_remain_cap` for a bin to be "almost full" relative to the item.
            # If `bins_remain_cap[i] >= item`, it fits.
            # We want `bins_remain_cap[i]` to be close to `item` but not less than `item`.
            #
            # A higher priority should be given to bins that are "more full" but still accommodate.
            # The metric `bins_remain_cap[i]` directly measures how full a bin is.
            # We want to pick from bins where `bins_remain_cap[i] >= item`.
            # Among these, we want to pick the one that is "most full".
            #
            # This implies we want to minimize `bins_remain_cap[i]` among fitting bins. This is Best Fit.
            #
            # However, "Almost Full Fit" as typically implemented in contexts like FFD
            # means we consider bins that *are* already mostly full.
            #
            # Let's think about the bins that are already nearly full, say `bins_remain_cap[i] < threshold`.
            # Then within those, pick the best.
            #
            # Alternative interpretation of "Almost Full Fit":
            # Prioritize bins that have a high remaining capacity, but are NOT fully empty,
            # and can fit the item. The priority increases with remaining capacity, up to a point.
            #
            # Let's try a scoring function that favors bins with a large remaining capacity,
            # but gives diminishing returns or even a penalty if the remaining capacity is too large.
            #
            # If `bins_remain_cap[i] >= item`:
            #   Priority could be `bins_remain_cap[i]`. This is greedy.
            #   Priority could be `-bins_remain_cap[i]`. This favors less full bins. (Worst Fit)
            #
            # "Almost Full Fit": we want to pick a bin that is already substantially filled,
            # but can still fit the current item.
            #
            # Let's try a function that is higher when `bins_remain_cap[i]` is large,
            # and the gap `bins_remain_cap[i] - item` is small.
            #
            # Consider `bins_remain_cap[i]`.
            # If it's very large (e.g., close to bin_capacity), it's not "almost full".
            # If it's small (e.g., less than `item`), it cannot fit.
            # We want `bins_remain_cap[i]` to be large, but not excessively large, and `>= item`.
            #
            # Let's try to reward bins whose remaining capacity is high.
            # And penalize those where the residual space after placing the item is too large.
            #
            # For fitting bins: `bins_remain_cap[i] >= item`
            # We want to maximize `bins_remain_cap[i]`, but cap the benefit.
            #
            # Let `slack = bins_remain_cap[i] - item`.
            # We want `slack` to be small and non-negative.
            # If `slack` is very small (near 0), priority is high.
            # If `slack` is moderately small, priority is also high.
            # If `slack` is large, priority is low.
            #
            # Let's define the priority based on the available space *after* fitting.
            # We want to MINIMIZE `bins_remain_cap[i] - item`.
            # So, priority is `- (bins_remain_cap[i] - item)`. This is Best Fit.
            #
            # Let's use a priority that captures the "almost full" nature directly.
            # The priority should be higher for bins that have a remaining capacity `r`
            # such that `item <= r < some_threshold`.
            # And within that threshold, we prefer smaller `r`.
            #
            # Let's try to maximize `bins_remain_cap[i]`. This is Greedy.
            # Let's try to minimize `bins_remain_cap[i]` given it fits. This is Best Fit.
            #
            # "Almost Full Fit":
            # Prioritize bins that are already substantially filled, and can fit the item.
            # A simple heuristic for "almost full" might be that the bin is *more than half full*,
            # and can still fit the item.
            #
            # If `bins_remain_cap[i] >= item`:
            #   If `bins_remain_cap[i] > bin_capacity / 2`: # Bin is more than half full
            #     Priority = `bins_remain_cap[i]` # Favor more full bins
            #   Else:
            #     Priority = 0 # Not "almost full" enough

            # Let's refine this. The notion of "almost full" is relative to the item.
            # We want bins where `bins_remain_cap[i]` is large, but `bins_remain_cap[i] - item` is small.
            #
            # Priority function:
            # For a bin `i` where `bins_remain_cap[i] >= item`:
            #   Let `slack = bins_remain_cap[i] - item`.
            #   We want to give higher priority as `slack` gets smaller (towards 0).
            #   But also, the initial `bins_remain_cap[i]` should be relatively large.
            #
            # This implies a preference for bins that are:
            # 1. Can fit the item (`bins_remain_cap[i] >= item`)
            # 2. Are substantially filled (e.g., `bins_remain_cap[i]` is not close to `bin_capacity`)
            # 3. Do not leave excessive slack after the item is placed (`bins_remain_cap[i] - item` is small)
            #
            # Let's consider `bins_remain_cap[i]`.
            # If `bins_remain_cap[i] >= item`, it's a candidate.
            # Among candidates, we want to find one that is "almost full".
            #
            # Let's try this definition: a bin is "almost full" if its remaining capacity
            # is between `item` and `item + alpha`, where alpha is small.
            # Among such bins, we prefer the ones with smaller `bins_remain_cap[i]`.
            #
            # If `item <= bins_remain_cap[i] < item + tolerance`:
            #   Priority = `-(bins_remain_cap[i] - item)`  (favors smaller `bins_remain_cap[i]`)
            # Else if `bins_remain_cap[i] >= item + tolerance`:
            #   Priority = `-(tolerance)` # Less priority, but still usable if no "almost full" bin exists.
            # Else:
            #   Priority = -infinity (or a very small number)

            # A simpler approach might be to prioritize bins that have *just enough* space.
            # Let's try a priority that rewards bins where `bins_remain_cap[i]` is large,
            # but penalizes bins that would leave a lot of space after the item is placed.
            #
            # If `bins_remain_cap[i] >= item`:
            #   priority = `bins_remain_cap[i]`  # Favors fuller bins
            #   # But we don't want it to be *too* full such that the gap is enormous.
            #   # Let's say if `bins_remain_cap[i] > some_high_threshold`, priority is reduced.
            #
            # The common understanding of "Almost Full Fit" in heuristics like "Almost Full First Fit"
            # is to select from bins that are *already* mostly full.
            #
            # Let's try to prioritize bins with higher remaining capacity, but with a slight preference for
            # bins that will have less remaining space after the item is placed.
            #
            # If `bins_remain_cap[i] >= item`:
            #   Priority = `bins_remain_cap[i]` - (a small penalty if `bins_remain_cap[i] - item` is large)
            #
            # Let's try a heuristic where we want to find a bin such that the *remaining space* after fitting
            # is minimized, but also, the *original remaining space* was substantial.
            #
            # For bins that fit: `bins_remain_cap[i] >= item`
            # We want to MINIMIZE `bins_remain_cap[i] - item`.
            # Priority should be a decreasing function of `bins_remain_cap[i] - item`.
            #
            # Let's consider this: We want to fill bins. If a bin is almost full, it means
            # it has substantial space but not excessive.
            #
            # Consider a bin's fill level *before* item: `1 - bins_remain_cap[i] / bin_capacity`.
            # We want this to be high.
            #
            # A common "Almost Full" heuristic is related to fitting into bins that are already "nearly full".
            # For an item of size `s`, a bin `j` with remaining capacity `r_j` is "nearly full" if `r_j` is not much larger than `s`.
            #
            # Let's try to score bins based on how "close" their remaining capacity is to the item size.
            #
            # For fitting bins (`bins_remain_cap[i] >= item`):
            #   We want to reward bins where `bins_remain_cap[i]` is small.
            #   This is Best Fit.
            #
            # If "Almost Full Fit" means we prioritize bins that are already largely filled,
            # and we want to put the item into one of them, such that the resulting
            # remaining space is minimized:
            #
            # Let `residual_capacity = bins_remain_cap[i] - item`
            # We want to maximize `1.0 / (residual_capacity + epsilon)` for fitting bins.
            # This rewards smaller residuals.

            # Let's use the concept of "desired gap".
            # For an item `item`, a bin with `bins_remain_cap[i]` is a candidate if `bins_remain_cap[i] >= item`.
            # We want to find a bin where `bins_remain_cap[i]` is as close as possible to `item`,
            # but not less than `item`.
            # This means we want to minimize `bins_remain_cap[i] - item`.
            #
            # So, priority could be `- (bins_remain_cap[i] - item)` for fitting bins.
            # This is equivalent to prioritizing the smallest remaining capacity after fitting.

            # Let's try a priority that's higher for bins that have a good amount of remaining capacity,
            # but not too much.
            # A bin is "almost full" if its remaining capacity `r` satisfies:
            # `item <= r < item + alpha`
            # Among these, pick the one with the smallest `r`.

            # Let's score a bin `i` if `bins_remain_cap[i] >= item`:
            # Priority = `bins_remain_cap[i]` # Prioritize larger remaining capacities (less full bins) - THIS IS NOT ALMOST FULL
            # Priority = `-bins_remain_cap[i]` # Prioritize smaller remaining capacities (more full bins) - THIS IS BEST FIT
            #
            # "Almost Full Fit": We want to find a bin that is already quite full, and the item *just* fits.
            #
            # Consider the value `bins_remain_cap[i]`.
            # If `bins_remain_cap[i]` is very large (e.g., `> bin_capacity - some_small_value`), it's too empty.
            # If `bins_remain_cap[i]` is small (e.g., `< item`), it doesn't fit.
            #
            # Let's define a range for "almost full": `[item, item + tolerance]`.
            # If `bins_remain_cap[i]` is in this range, give it a high priority.
            # And within this range, favor smaller `bins_remain_cap[i]`.
            #
            # Example: Bin capacity = 1.0, Item = 0.4. Tolerance = 0.1.
            # Target range for remaining capacity: `[0.4, 0.5]`.
            #
            # Bin A: `bins_remain_cap[i]` = 0.7 (fits, but too much slack)
            # Bin B: `bins_remain_cap[i]` = 0.45 (fits, in target range)
            # Bin C: `bins_remain_cap[i]` = 0.4 (fits, in target range, smallest slack)
            # Bin D: `bins_remain_cap[i]` = 0.3 (doesn't fit)
            # Bin E: `bins_remain_cap[i]` = 0.6 (fits, but slack > tolerance)
            #
            # We want Bin C to have the highest priority, then Bin B, then perhaps Bin A or E.
            #
            # Priority function:
            # If `bins_remain_cap[i] >= item`:
            #   slack = bins_remain_cap[i] - item
            #   If `slack <= tolerance`:
            #     # "Almost full" bin - penalize larger slack within tolerance
            #     priority = 1.0 - slack / tolerance # Higher priority for smaller slack
            #   Else:
            #     # Bin fits but has more slack than ideal "almost full"
            #     # Give a lower priority. Maybe based on how much larger slack is.
            #     # Let's give it a priority proportional to its remaining capacity, but less than "almost full".
            #     priority = 0.5 * (1.0 - slack / (bin_capacity - item)) # Lower scale, favors larger remaining capacity if not "almost full"
            # Else:
            #   priority = 0.0 # Cannot fit

            # Let's simplify.
            # "Almost Full Fit": Prioritize bins that have the least remaining capacity *after* fitting the item,
            # but ensuring this remaining capacity is not too small (i.e., not forcing an immediate overflow later).
            # The key is that the bin is already *substantially* filled.
            #
            # A bin `i` is "almost full" if `bins_remain_cap[i]` is close to `item` and positive.
            # The strategy aims to find bins that are already significantly filled.
            #
            # Consider the remaining capacity: `r = bins_remain_cap[i]`.
            # If `r >= item`, it's a candidate.
            # We want to select a candidate `i` that is "most full".
            # This means `r` should be minimized. This is Best Fit.
            #
            # However, "Almost Full Fit" often implies a preference for bins that have a decent amount of remaining capacity,
            # but not so much that they are nearly empty.
            #
            # Let's define "almost full" as `bins_remain_cap[i]` being between `item` and `bin_capacity * alpha`,
            # where `alpha` is some fraction (e.g., 0.5 or 0.7).
            #
            # Let's consider priority based on how "tight" the fit is, given that it's a fit.
            #
            # If `bins_remain_cap[i] >= item`:
            #   slack = bins_remain_cap[i] - item
            #   # We want to maximize priority for small non-negative slack.
            #   # Priority = 1 / (slack + epsilon)
            #   # To make it "almost full", we also want `bins_remain_cap[i]` to be large.
            #   # This is a trade-off.
            #
            # "Almost Full Fit": Pick the bin `j` that minimizes `bins_remain_cap[j]` among those that fit.
            # This is Best Fit.
            # The term "almost full" suggests that the bins themselves are already close to capacity.
            #
            # Let's try to implement a priority that favors bins which, after placing the item,
            # leave a small but positive remaining capacity.
            #
            # If `bins_remain_cap[i] >= item`:
            #   Priority = `1.0 / (bins_remain_cap[i] - item + 0.0001)` # Maximize inverse of slack
            #
            # This is essentially Best Fit if we just take the max.
            #
            # For "Almost Full Fit", the strategy is about selecting from bins that are already *mostly full*.
            # So, bins with `bins_remain_cap[i]` closer to `0` are more "almost full".
            # However, we also need `bins_remain_cap[i] >= item`.
            #
            # Let's assign a high priority to bins `i` where `bins_remain_cap[i]` is small, but still `>= item`.
            # So, prioritize smaller `bins_remain_cap[i]`. This is Best Fit.
            #
            # Let's rethink the prompt's emphasis on "Almost Full".
            # It's not just about fitting the item tightly, but about filling bins that are already *close to full*.
            #
            # Let's consider bins that have a substantial remaining capacity, but not an excessive one.
            #
            # If `bins_remain_cap[i] >= item`:
            #   residual_after_fit = bins_remain_cap[i] - item
            #   # We want `bins_remain_cap[i]` to be large.
            #   # And we want `residual_after_fit` to be small.
            #   # Let's try to score `bins_remain_cap[i] / (residual_after_fit + epsilon)`
            #   # This rewards large `bins_remain_cap[i]` and small `residual_after_fit`.
            #
            #
            # A simple approach that captures "almost full" might be:
            # Prioritize bins with higher remaining capacity, but penalize those that are *too* empty.
            #
            # If `bins_remain_cap[i] >= item`:
            #   # Priority = bins_remain_cap[i]
            #   # This favors bins with more space.
            #   # To make it "almost full", maybe we want to cap the `bins_remain_cap[i]` benefit.
            #
            # Let's consider a function that is high for values of `bins_remain_cap[i]` that are
            # large, but not extremely large, and importantly, can fit the item.
            #
            # Final attempt at interpretation for "Almost Full Fit":
            # Prioritize bins that have a remaining capacity that is just enough for the item,
            # AND whose current state of "fullness" is high.
            #
            # For a bin `i` where `bins_remain_cap[i] >= item`:
            #   We want to minimize `bins_remain_cap[i] - item`.
            #   So, priority should be high for small non-negative `bins_remain_cap[i] - item`.
            #   This makes the priority inversely proportional to the slack.
            #
            # Consider the percentage of the *remaining capacity* that the item will occupy.
            # `item / bins_remain_cap[i]` (if `bins_remain_cap[i] > 0`).
            # We want this to be high.
            #
            # Let's focus on `bins_remain_cap[i]`.
            # A bin is "almost full" if its remaining capacity is small.
            # However, it must be able to fit the item.
            # So, we are looking for bins `i` such that `item <= bins_remain_cap[i] < some_threshold`.
            # Among these, we want to pick the one that is *most* full, meaning smallest `bins_remain_cap[i]`.
            #
            # So, priority is highest for `bins_remain_cap[i]` that is minimal among fitting bins.
            # This is Best Fit.
            #
            # Perhaps "Almost Full Fit" implies a preference for bins that are already *mostly full*,
            # but not completely full.
            #
            # Let's try a priority that's higher for bins with a moderate-to-high remaining capacity,
            # AND where the slack after fitting is small.
            #
            # Let `slack = bins_remain_cap[i] - item`.
            #
            # If `slack >= 0`:
            #   # We want to reward smaller slacks AND larger `bins_remain_cap[i]`.
            #   # Let's combine these.
            #   # Priority proportional to `bins_remain_cap[i]` and inversely to `slack`.
            #   # e.g., `bins_remain_cap[i] / (slack + epsilon)`
            #   # This would mean: a bin with 0.8 capacity fitting a 0.7 item (slack 0.1) gives 8.0.
            #   # A bin with 0.3 capacity fitting a 0.2 item (slack 0.1) gives 3.0.
            #   # This still seems to favor larger `bins_remain_cap[i]`.
            #
            # Let's try to prioritize bins that are "nearly full" without being "too empty".
            # Consider the "waste" after fitting the item: `bins_remain_cap[i] - item`.
            # We want to minimize this waste. This is Best Fit.
            #
            # The term "Almost Full Fit" might be about preferring bins that are already substantially occupied,
            # and this item fits neatly into it.
            #
            # Let's consider a penalty for being too empty.
            # If `bins_remain_cap[i]` is very large (e.g., `> bin_capacity / 2` or some such threshold),
            # then the priority is lower.
            #
            # Priority = `bins_remain_cap[i]` (favors more empty bins, First Fit-like if not capping)
            # Priority = `-bins_remain_cap[i]` (favors fuller bins, Best Fit)
            #
            # Let's use a composite score:
            # Prioritize bins that are "full" but not "too full".
            #
            # If `bins_remain_cap[i] >= item`:
            #   priority = `bins_remain_cap[i]` * (1.0 - (bins_remain_cap[i] - item) / bin_capacity)
            #   This tries to balance having more space with leaving less space after fit.

            # Let's consider the common heuristics:
            # First Fit: Iterate through bins, pick the first that fits.
            # Best Fit: Iterate through bins, pick the one that fits with least remaining space.
            # Worst Fit: Iterate through bins, pick the one that fits with most remaining space.
            #
            # "Almost Full Fit" often implies a strategy that tries to avoid leaving small gaps.
            # Or it's about filling bins that are already *close to full*.
            #
            # Consider this interpretation:
            # Prioritize bins `i` where `bins_remain_cap[i]` is large, but not excessively large.
            # And the item fits.
            #
            # Let's define a threshold for "almost full": e.g., `bins_remain_cap[i] < 0.8 * bin_capacity`.
            # If `item <= bins_remain_cap[i] < 0.8 * bin_capacity`:
            #   priority = `bins_remain_cap[i]` (prioritize those with more space within this bound)
            #
            # A more direct approach for "Almost Full Fit":
            # We want to find a bin that is already significantly full, and can accommodate the item.
            # The priority should be high for bins that are close to full but can still fit the item.
            #
            # Let `desired_remaining_capacity = item + epsilon` (where epsilon is small).
            # We are looking for bins where `bins_remain_cap[i]` is close to this `desired_remaining_capacity`.
            #
            # If `bins_remain_cap[i] >= item`:
            #   slack = bins_remain_cap[i] - item
            #   # We want small slack.
            #   # Priority should increase as slack decreases.
            #   # This is effectively maximizing `-slack`.
            #   #
            #   # For "Almost Full", the initial state of the bin matters.
            #   # So, we want bins that are already full.
            #   # This means `bins_remain_cap[i]` should be small.
            #   #
            #   # If we want bins that are "almost full" and the item fits:
            #   # Small `bins_remain_cap[i]` that is still `>= item`.
            #   # This is Best Fit.
            #   #
            #   # Let's try a different interpretation.
            #   # Prioritize bins that have substantial remaining capacity, but *not* so much that it feels wasteful.
            #   #
            #   # For fitting bins (`bins_remain_cap[i] >= item`):
            #   #   Let's penalize bins that are "too empty" OR "too full (leaving large slack)".
            #   #   Define "too empty" threshold: `bins_remain_cap[i] < item` (already handled) or `bins_remain_cap[i] < some_lower_bound`
            #   #   Define "too much slack": `bins_remain_cap[i] - item > some_upper_bound_on_slack`
            #
            #   # A common implementation for "Almost Full Fit" is to simply use Best Fit.
            #   # However, if we need to be creative:
            #   # Let's try to reward bins that are "nearly filled" with the item.
            #   # This means `bins_remain_cap[i]` is close to `item`.
            #   #
            #   # If `item <= bins_remain_cap[i] < item + tolerance`:
            #   #   Priority = 1.0 - (bins_remain_cap[i] - item) / tolerance
            #   #   This gives higher priority to bins closer to `item`.
            #   #
            #   # What if no such bins exist?
            #   # If `bins_remain_cap[i] >= item + tolerance`:
            #   #   Then the bin is "almost full" in the sense that it has capacity, but not "almost full" relative to the item.
            #   #   Let's give these a lower priority.
            #   #   Maybe priority = 0.5 * (1.0 - (bins_remain_cap[i] - item) / bin_capacity) # scaled down priority
            #
            # Let's go with the interpretation that we want bins which, after placing the item, have a minimal but positive remaining capacity.
            # This means minimizing `bins_remain_cap[i] - item`.
            #
            # Priority for fitting bins (`bins_remain_cap[i] >= item`):
            #   `-(bins_remain_cap[i] - item)`
            # This maximizes the negative slack, thus minimizing the positive slack.

            # Let's refine: the "almost full" aspect suggests that the bin *itself* is already substantially filled.
            # So, `bins_remain_cap[i]` should not be too large.
            #
            # Consider the total capacity used: `bin_capacity - bins_remain_cap[i]`.
            # We want this to be large.
            # AND `bins_remain_cap[i] >= item`.
            #
            # Let's score based on a combination:
            # Higher priority if `bins_remain_cap[i]` is large AND `bins_remain_cap[i] - item` is small.
            # This is inherently contradictory to some extent.
            #
            # Let's focus on making the bin *almost full after fitting the item*.
            # This means `bins_remain_cap[i]` should be just a bit larger than `item`.
            #
            # If `bins_remain_cap[i] >= item`:
            #   # We want to maximize the value of `bins_remain_cap[i]` such that `bins_remain_cap[i] - item` is minimal.
            #   # Consider the "fill level" after the item is placed:
            #   # `fill_level = (bin_capacity - (bins_remain_cap[i] - item)) / bin_capacity`
            #   # We want to maximize this.
            #   # Maximizing `bin_capacity - bins_remain_cap[i] + item`
            #   # Which is maximizing `item - bins_remain_cap[i]` but this can be negative.
            #   #
            #   # If `bins_remain_cap[i] >= item`:
            #   #   Maximize `item / (bins_remain_cap[i] - item + epsilon)`  -- This prioritizes small slack.
            #
            # This is becoming Best Fit.
            #
            # Let's use a priority that encourages placing items into bins that are already considerably full.
            #
            # If `bins_remain_cap[i] >= item`:
            #   # Give higher priority to bins that have a smaller remaining capacity *overall*,
            #   # as they are considered more "full".
            #   # But also, we want the item to fit well.
            #   #
            #   # Priority = `bins_remain_cap[i]`  -> Favors bins with more empty space. (First Fit)
            #   # Priority = `-bins_remain_cap[i]` -> Favors bins with less empty space. (Best Fit)
            #   #
            #   # For "Almost Full Fit", the goal is often to achieve a good packing density quickly.
            #   # A common strategy related to this is to prefer bins that have a certain amount of remaining capacity,
            #   # but not too much.
            #   #
            #   # Let's define priority based on the "goodness" of the fit.
            #   # A good fit leaves little room for waste.
            #   # `bins_remain_cap[i] - item` is the waste. We want to minimize this.
            #   #
            #   # Priority = `- (bins_remain_cap[i] - item)` is the inverse of waste.
            #   # This is Best Fit.
            #
            # Let's interpret "Almost Full Fit" as preferring bins that are already quite full,
            # and this item fits nicely into the remaining space without leaving a large gap.
            #
            # Priority = `bins_remain_cap[i]` - `(bins_remain_cap[i] - item)`
            # This simplifies to `item`. This is constant for all fitting bins. Not useful.
            #
            # How about we give a bonus for being "nearly full"?
            #
            # If `bins_remain_cap[i] >= item`:
            #   slack = bins_remain_cap[i] - item
            #   # Reward small slack
            #   priority = 1.0 - slack
            #
            # Let's refine "almost full": we want the bin's remaining capacity
            # to be close to the item's size.
            #
            # If `bins_remain_cap[i] >= item`:
            #   # We want `bins_remain_cap[i]` to be small. This is Best Fit.
            #   #
            #   # To be creative:
            #   # Prioritize bins where `bins_remain_cap[i]` is large, but the amount of space *left over* after placing the item (`bins_remain_cap[i] - item`) is small.
            #   #
            #   # Let's try `priority = bins_remain_cap[i] - (bins_remain_cap[i] - item)`. This is `item`.
            #   #
            #   # What if we prioritize bins that are "full enough" such that putting the item makes it "almost full"?
            #   #
            #   # Final attempt: Prioritize bins that have a moderate-to-high remaining capacity,
            #   # and importantly, leave minimal residual space after the item is placed.
            #   #
            #   # Let `remaining_after_fit = bins_remain_cap[i] - item`.
            #   # We want to prioritize bins with larger `bins_remain_cap[i]`, but smaller `remaining_after_fit`.
            #   #
            #   # Score = `bins_remain_cap[i]` / (`remaining_after_fit` + epsilon)
            #   # Example: BinCap=1.0, Item=0.3
            #   # Bin A: rem=0.8. slack=0.5. Score = 0.8 / (0.5 + e) ~ 1.6
            #   # Bin B: rem=0.4. slack=0.1. Score = 0.4 / (0.1 + e) ~ 4.0
            #   # This favors smaller slack AND larger `bins_remain_cap[i]`. This seems promising.
            #
            # Let's implement this.

            slack = bins_remain_cap[i] - item
            if slack >= 0:
                # Higher priority for smaller slack (closer to Best Fit for slack)
                # Also prioritize larger `bins_remain_cap[i]`
                # Combine: `bins_remain_cap[i] / (slack + small_epsilon)`
                # Add a small epsilon to avoid division by zero.
                small_epsilon = 1e-9
                priorities[i] = bins_remain_cap[i] / (slack + small_epsilon)
            else:
                priorities[i] = 0.0 # Cannot fit

    return priorities
```
