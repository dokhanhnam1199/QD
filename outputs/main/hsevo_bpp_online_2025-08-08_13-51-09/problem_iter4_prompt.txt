{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines the 'tight fit' prioritization of inverse difference with a sigmoid\n    function to normalize priorities, favoring bins that are a near-perfect fit\n    while maintaining a reasonable range.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins_mask = bins_remain_cap >= item\n    \n    if not np.any(valid_bins_mask):\n        return priorities\n\n    valid_bins_cap = bins_remain_cap[valid_bins_mask]\n    \n    # Calculate inverse difference for valid bins: smaller difference is better\n    # Adding a small epsilon to avoid division by zero and extreme values\n    inverse_diff = 1.0 / (valid_bins_cap - item + 1e-9)\n    \n    # Use sigmoid to normalize and shape the priorities.\n    # The sigmoid will map the inverse differences to a [0, 1] range.\n    # We can center the sigmoid around a typical \"good fit\" or use the min/max\n    # of the calculated inverse differences to create a more adaptive scaling.\n    \n    min_inv_diff = np.min(inverse_diff)\n    max_inv_diff = np.max(inverse_diff)\n    \n    # Normalize inverse_diff to [0, 1] before applying sigmoid for more stable results\n    if max_inv_diff - min_inv_diff > 1e-9:\n        normalized_inv_diff = (inverse_diff - min_inv_diff) / (max_inv_diff - min_inv_diff)\n    else:\n        normalized_inv_diff = np.zeros_like(inverse_diff)\n\n    # Apply sigmoid. A sigmoid centered around 0.5 (e.g., 2 * x - 1 for normalized input)\n    # will map [0, 1] to roughly [0, 1], with a steep rise in the middle.\n    # Here, we use a simple sigmoid form that maps values to [0, 1].\n    # A common sigmoid form: 1 / (1 + exp(-k * (x - x0)))\n    # Let's use a simpler form for demonstration, similar to a normalized inverse:\n    # We want smaller differences (larger inverse_diff) to have higher priority.\n    # A high inverse_diff should map to a high sigmoid output.\n    # Using normalized_inv_diff, a higher value means a tighter fit.\n    # Let's use a sigmoid that emphasizes the middle range.\n    \n    # Option 1: Simple sigmoid on normalized inverse difference\n    # This will give higher priority to bins that are \"moderately\" good fits\n    # relative to the best fits.\n    scaled_priorities = 1 / (1 + np.exp(-10 * (normalized_inv_diff - 0.5))) # steep sigmoid\n\n    # Option 2: Direct sigmoid on inverse difference, scaled and shifted.\n    # This approach might be more sensitive to extreme inverse_diff values.\n    # We can scale inverse_diff to a reasonable range for sigmoid.\n    # Let's use the inverse difference directly, but clip extreme values or scale carefully.\n    # For simplicity and robustness, sticking with normalized inverse difference.\n\n    priorities[valid_bins_mask] = scaled_priorities\n    \n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}