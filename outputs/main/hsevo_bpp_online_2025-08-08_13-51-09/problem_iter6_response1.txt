```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a heuristic that
    balances Best Fit and considering the "emptiness" of bins.

    This heuristic aims to find a bin that is a "tight fit" for the current item,
    minimizing wasted space. It also gives a slight preference to bins that are
    less full overall, promoting better distribution and potentially allowing
    for better packing of future larger items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities # No suitable bin found

    # Calculate the "tightness" of the fit (smaller is better)
    tightness = bins_remain_cap[suitable_bins_mask] - item

    # Calculate a measure of "emptiness" for suitable bins.
    # A higher value here means the bin is emptier (more remaining capacity).
    # We use log to dampen the effect of very large capacities.
    # Adding a small epsilon to avoid log(0).
    emptiness = np.log(bins_remain_cap[suitable_bins_mask] + 1e-9)

    # Combine tightness and emptiness.
    # We want small tightness (good fit) and high emptiness (less full bin).
    # So, we can subtract emptiness from tightness, or use a weighted sum.
    # Here, we prioritize a good fit, but give a bonus to emptier bins.
    # The negative sign for emptiness means higher emptiness leads to a higher score.
    scores = -tightness + emptiness * 0.1 # Adjust the multiplier (0.1) for balancing

    # Assign the calculated scores to the corresponding suitable bins
    priorities[suitable_bins_mask] = scores

    # Normalize priorities so the highest score is 1 and others are scaled accordingly.
    # This makes the scores more interpretable as a probability or preference.
    max_priority = np.max(priorities)
    if max_priority > 0:
        priorities /= max_priority
    elif np.any(suitable_bins_mask): # If all suitable bins have the same (non-positive) score
        priorities[suitable_bins_mask] = 1.0 / np.sum(suitable_bins_mask) # Distribute equally

    return priorities
```
