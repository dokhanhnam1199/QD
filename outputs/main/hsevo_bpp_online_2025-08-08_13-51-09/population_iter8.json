[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines tight packing (Best Fit) with a diversification bonus favoring\n    less utilized bins. Balances fitting tightly with spreading load.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_cap = bins_remain_cap[suitable_bins_mask]\n    remaining_after_placement = suitable_bins_cap - item\n\n    # Primary objective: Tight Fit (Best Fit)\n    # Higher score for smaller remaining capacity. Use reciprocal for emphasis.\n    tight_fit_score = 1.0 / (remaining_after_placement + 1e-9)\n\n    # Secondary objective: Diversification (Favor less utilized bins)\n    # This encourages using bins that are not already very full.\n    # We can measure this by the *remaining capacity after placement* relative to the\n    # *total capacity of the bin*. A higher ratio here means the bin was less full.\n    # Use min-max scaling for a robust normalized score between 0 and 1.\n    min_rem_after = np.min(remaining_after_placement)\n    max_rem_after = np.max(remaining_after_placement)\n\n    exploration_bonus = np.zeros_like(remaining_after_placement)\n    if max_rem_after > min_rem_after:\n        # Normalize remaining capacity after placement to get exploration score\n        exploration_bonus = (remaining_after_placement - min_rem_after) / (max_rem_after - min_rem_after)\n    else:\n        # If all suitable bins result in the same remaining capacity, no bonus from this metric.\n        pass\n\n    # Combine scores: Primarily driven by tight fit, with an additive exploration bonus.\n    # The exploration bonus is scaled down to ensure tight fit remains dominant,\n    # but it serves as a tie-breaker and encourages exploration.\n    # A weight of 0.1 is empirically chosen to give exploration a modest influence.\n    final_priorities = tight_fit_score + 0.1 * exploration_bonus\n\n    priorities[suitable_bins_mask] = final_priorities\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 71.27044276027125,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with an exploration bonus favoring less utilized bins using a log-transformed score.\n    This aims for efficient packing and better distribution of items across bins.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n\n    # Best Fit component: Inverse of the remaining space after packing\n    # Smaller remaining space yields a higher score. Add epsilon for stability.\n    best_fit_scores = 1.0 / (suitable_bins_remain_cap - item + 1e-9)\n\n    # Exploration component: Reward bins with more remaining capacity (less utilized)\n    # Use log transformation to dampen the effect of very large remaining capacities\n    # and provide a smoother exploration bonus. Add 1 to avoid log(0).\n    exploration_scores = np.log1p(suitable_bins_remain_cap)\n\n    # Normalize exploration scores using min-max scaling to ensure they are comparable\n    min_exp_score = np.min(exploration_scores)\n    max_exp_score = np.max(exploration_scores)\n    if max_exp_score - min_exp_score > 1e-9:\n        normalized_exploration_scores = (exploration_scores - min_exp_score) / (max_exp_score - min_exp_score)\n    else:\n        normalized_exploration_scores = np.zeros_like(exploration_scores)\n\n    # Combine Best Fit and Exploration scores\n    # Weighting can be tuned. Prioritizing Best Fit slightly.\n    w_best_fit = 0.7\n    w_exploration = 0.3\n    combined_scores = w_best_fit * best_fit_scores + w_exploration * normalized_exploration_scores\n\n    # Assign combined scores to the priority array for suitable bins\n    priorities[suitable_bins_mask] = combined_scores\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 83.62584762664541,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Best Fit with an exploration bonus favoring less utilized bins.\n\n    This heuristic balances packing tightly (Best Fit) with spreading items,\n    aiming for better overall bin utilization and diversification.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return np.zeros_like(bins_remain_cap)\n\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n\n    # Best Fit Component: Smaller remaining capacity after placing the item is better.\n    # We use the negative of the remaining capacity to make larger negative values (tighter fits)\n    # have higher priority in argmin later.\n    best_fit_scores = -(suitable_bins_remain_cap - item)\n\n    # Exploration Bonus Component: Favor bins that are less utilized (larger original capacity).\n    # Use min-max scaling to normalize the remaining capacities of *suitable* bins.\n    # Higher remaining capacity (before placing item) gets a bonus.\n    min_cap = np.min(suitable_bins_remain_cap)\n    max_cap = np.max(suitable_bins_remain_cap)\n    if max_cap - min_cap > 1e-9: # Avoid division by zero if all suitable bins have same capacity\n        exploration_scores = (suitable_bins_remain_cap - min_cap) / (max_cap - min_cap)\n    else:\n        exploration_scores = np.zeros_like(suitable_bins_remain_cap)\n\n    # Combine scores: Prioritize Best Fit, then exploration bonus.\n    # A simple weighted sum can work, but we can also directly combine them.\n    # Let's prioritize best-fit by giving it a larger weight.\n    # The 'best_fit_scores' are negative, so a higher value (closer to 0) is better.\n    # The 'exploration_scores' are positive, higher is better.\n    # To combine, we can add them, ensuring best_fit_scores are scaled appropriately.\n    # A common approach is to make the best-fit component dominant.\n    # Let's try: priority = best_fit_component + weight * exploration_component\n    # Since best_fit_scores are negative, we can add a large constant to make them positive\n    # or ensure that the best_fit_scores are the primary driver.\n    # Let's make the best_fit_scores dominant and add exploration as a tie-breaker or secondary factor.\n    # We want smaller (more negative) best_fit_scores to be prioritized, so we add the exploration.\n    combined_scores = best_fit_scores + 0.5 * exploration_scores # Weight for exploration\n\n    priorities[suitable_bins_mask] = combined_scores\n\n    # Ensure no -inf remains if all suitable bins were considered.\n    # If all suitable bins have the same priority, np.argmin will pick the first one.\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit (tightest residual space) with an exploration bonus\n    favoring bins with higher remaining capacity, normalized for balance.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]\n\n    # Metric 1: Best Fit - Prioritize bins with minimal remaining capacity after placement.\n    # Higher score for smaller remaining capacity (more tightly fitting).\n    remaining_after_placement = suitable_bins_caps - item\n    best_fit_scores = 1.0 / (remaining_after_placement + 1e-6)\n\n    # Metric 2: Exploration Bonus - Prioritize bins with more initial remaining capacity.\n    # This encourages using less full bins for better future packing flexibility.\n    # Use min-max normalization for a balanced exploration score.\n    if suitable_bins_caps.size > 0:\n        min_cap = np.min(suitable_bins_caps)\n        max_cap = np.max(suitable_bins_caps)\n        if max_cap - min_cap > 1e-6:\n            exploration_scores = (suitable_bins_caps - min_cap) / (max_cap - min_cap)\n        else:\n            exploration_scores = np.ones_like(suitable_bins_caps) * 0.5 # Handle case where all suitable bins have same capacity\n    else:\n        exploration_scores = np.array([])\n\n    # Normalize Best Fit scores to be in a comparable range [0, 1]\n    if np.max(best_fit_scores) > 1e-6:\n        normalized_best_fit = best_fit_scores / np.max(best_fit_scores)\n    else:\n        normalized_best_fit = np.zeros_like(best_fit_scores)\n\n    # Combine scores with weights: 70% for tight fit, 30% for exploration.\n    # This prioritizes filling bins efficiently while still considering diversification.\n    combined_scores = 0.7 * normalized_best_fit + 0.3 * exploration_scores\n\n    priorities[suitable_bins_mask] = combined_scores\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 3.9589150378939015,
    "SLOC": 24.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit (tightest residual space) with a preference for bins\n    that have more remaining capacity after placement, using normalized scores.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]\n    \n    # Metric 1: Best Fit - prioritize bins with minimal remaining capacity after placement.\n    # Higher score for smaller remaining capacity.\n    remaining_after_placement = suitable_bins_caps - item\n    best_fit_scores = 1.0 / (remaining_after_placement + 1e-6)\n    \n    # Metric 2: Favor bins with more remaining capacity *after* placement.\n    # This encourages spreading items out rather than packing too tightly if possible.\n    # Using the remaining capacity *after* placement as a diversification metric.\n    large_remaining_bin_scores = suitable_bins_caps - item\n\n    # Normalize Best Fit scores\n    max_bf = np.max(best_fit_scores)\n    if max_bf > 1e-6:\n        normalized_best_fit = best_fit_scores / max_bf\n    else:\n        normalized_best_fit = np.zeros_like(best_fit_scores)\n\n    # Normalize Large Remaining Bin scores (higher is better for diversification)\n    max_lrb = np.max(large_remaining_bin_scores)\n    if max_lrb > 1e-6:\n        normalized_large_remaining = large_remaining_bin_scores / max_lrb\n    else:\n        normalized_large_remaining = np.zeros_like(large_remaining_bin_scores)\n\n    # Combine normalized scores: A weighted sum.\n    # We slightly favor Best Fit (0.7) but also consider diversification (0.3).\n    combined_scores = 0.7 * normalized_best_fit + 0.3 * normalized_large_remaining\n    \n    priorities[suitable_bins_mask] = combined_scores\n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 22.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Balances Best Fit (tightness) with an exploration bonus for emptier bins.\n    This heuristic aims for efficient packing by favoring tight fits while also\n    promoting distribution and potentially accommodating future items.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    valid_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n\n    # Best Fit component: prioritize bins with minimal remaining capacity after placing the item.\n    # Using inverse of the difference: smaller difference means higher priority.\n    tightness_scores = 1.0 / (valid_bins_remain_cap - item + 1e-9)\n\n    # Exploration component: reward bins that are currently emptier.\n    # This encourages spreading items across bins. We'll use the log of remaining capacity\n    # to dampen the effect of very large capacities, and add a small epsilon to avoid log(0).\n    # Higher log(remaining_capacity) means emptier, so we want to add this as a bonus.\n    # A multiplier is used to balance exploration with the best-fit objective.\n    emptiness_bonus = np.log(valid_bins_remain_cap + 1e-9) * 0.1 # Tunable parameter\n\n    # Combine scores: Sum of Best Fit and exploration bonus.\n    # Higher combined score indicates a more desirable bin.\n    combined_scores = tightness_scores + emptiness_bonus\n\n    # Normalize scores to be between 0 and 1 for easier interpretation and comparison.\n    # This ensures that the highest score is 1, and others are scaled proportionally.\n    max_score = np.max(combined_scores)\n    if max_score > 1e-9: # Avoid division by zero if all scores are effectively zero\n        priorities[suitable_bins_mask] = combined_scores / max_score\n    elif np.any(suitable_bins_mask): # If all suitable bins have similar low scores\n        # Distribute priority equally among suitable bins if all scores are near zero.\n        priorities[suitable_bins_mask] = 1.0 / np.sum(suitable_bins_mask)\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 51.09692859992023,
    "SLOC": 15.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines tightest fit with a normalized bonus for larger remaining capacity,\n    using a weighted sum for balanced decision-making.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    suitable_bins_mask = bins_remain_cap >= item\n    \n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]\n    \n    # Metric 1: Best Fit - prioritize bins with minimal remaining capacity after placement.\n    remaining_after_placement = suitable_bins_caps - item\n    # Using inverse of remaining space (plus epsilon for numerical stability)\n    best_fit_scores = 1.0 / (remaining_after_placement + 1e-6)\n    \n    # Metric 2: Favor larger bins (diversification) - prioritize bins with more capacity initially.\n    # This encourages not always picking the absolute tightest.\n    large_bin_scores = suitable_bins_caps\n    \n    # Normalize Best Fit scores\n    if np.max(best_fit_scores) > 1e-6:\n        normalized_best_fit = best_fit_scores / np.max(best_fit_scores)\n    else:\n        normalized_best_fit = np.zeros_like(best_fit_scores)\n\n    # Normalize Large Bin scores (using min-max scaling on the capacities of suitable bins)\n    if suitable_bins_caps.size > 1:\n        min_cap = np.min(suitable_bins_caps)\n        max_cap = np.max(suitable_bins_caps)\n        range_cap = max_cap - min_cap\n        if range_cap > 1e-6:\n            normalized_large_bin = (suitable_bins_caps - min_cap) / range_cap\n        else:\n            normalized_large_bin = np.zeros_like(suitable_bins_caps) # All suitable bins have same capacity\n    elif suitable_bins_caps.size == 1:\n        normalized_large_bin = np.array([1.0]) # If only one bin, it's maximally \"large\" in this context\n    else:\n        normalized_large_bin = np.zeros_like(suitable_bins_caps)\n\n    # Combine normalized scores using a weighted sum.\n    # Weights can be tuned. Here, 70% Best Fit, 30% favor larger bins.\n    combined_scores = 0.7 * normalized_best_fit + 0.3 * normalized_large_bin\n    \n    priorities[suitable_bins_mask] = combined_scores\n    \n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 3.9589150378939015,
    "SLOC": 28.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Balances tight fit with a diversified exploration bonus using inverse remaining capacity\n    and a scaled bonus for less utilized bins. Favors tighter fits while encouraging\n    exploration of less full bins.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    valid_bins_mask = bins_remain_cap >= item\n    \n    if not np.any(valid_bins_mask):\n        return priorities\n        \n    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n    \n    # Metric 1: Tight Fit Score (Inverse of remaining capacity after fitting)\n    # This prioritizes bins that leave minimal space, promoting consolidation.\n    tight_fit_score = 1.0 / (valid_bins_remain_cap - item + 1e-9)\n    \n    # Metric 2: Diversification Bonus (Inverse of current remaining capacity, scaled)\n    # This encourages using less full bins to spread items, preventing premature bin closure.\n    # Scale by the maximum remaining capacity among valid bins to give a relative bonus.\n    if valid_bins_remain_cap.size > 0:\n        max_current_cap = np.max(valid_bins_remain_cap)\n        diversification_bonus = (1.0 / (valid_bins_remain_cap + 1e-9)) * (max_current_cap / (max_current_cap + 1e-9))\n    else:\n        diversification_bonus = np.zeros_like(valid_bins_remain_cap)\n\n    # Combine scores: weighted sum. Give slightly more emphasis to tight fit,\n    # but ensure diversification plays a significant role.\n    combined_scores = 0.7 * tight_fit_score + 0.3 * diversification_bonus\n    \n    # Assign combined scores back to the original priority array\n    priorities[valid_bins_mask] = combined_scores\n    \n    # Normalize priorities: Ensures the highest score is clearly dominant and\n    # provides a consistent range of priorities across different item/bin states.\n    max_priority = np.max(priorities[valid_bins_mask])\n    if max_priority > 0:\n        priorities[valid_bins_mask] /= max_priority\n        \n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by balancing a tight fit (minimal residual space)\n    with an exploration bonus (favoring less utilized bins) using a\n    logarithmic transformation for better distribution.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n\n    # Metric 1: Tight Fit (minimize remaining space after packing)\n    # Use inverse of remaining capacity after packing, add epsilon for stability.\n    # Higher score for smaller remaining space.\n    tightness_score = 1.0 / (suitable_bins_remain_cap - item + 1e-9)\n\n    # Metric 2: Exploration Bonus (favor less utilized bins)\n    # Use log of remaining capacity. Higher score for bins with more remaining capacity.\n    # This encourages using less full bins to potentially improve overall packing.\n    exploration_score = np.log(suitable_bins_remain_cap + 1e-9)\n\n    # Combine scores with weights. Prioritize tightness slightly more.\n    # Weights can be tuned.\n    combined_scores = 0.6 * tightness_score + 0.4 * exploration_score\n\n    # Normalize scores to a [0, 1] range to ensure comparable priorities.\n    # Handle cases where all scores are identical to avoid division by zero.\n    min_score = np.min(combined_scores)\n    max_score = np.max(combined_scores)\n    if max_score - min_score > 1e-9:\n        normalized_scores = (combined_scores - min_score) / (max_score - min_score)\n    else:\n        normalized_scores = np.ones_like(combined_scores) * 0.5 # Mid-range if all equal\n\n    priorities[suitable_bins_mask] = normalized_scores\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 83.6358197048265,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Balances Best Fit with an exploration bonus favoring bins with more remaining capacity,\n    using a weighted sum of inverse difference and normalized remaining capacity.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n\n    # Heuristic 1 component: Tightness score (higher for smaller remaining space)\n    # This is the inverse of the difference, so smaller difference is better (higher score)\n    tightness_scores = 1.0 / (suitable_bins_remain_cap - item + 1e-9) # Add epsilon for stability\n\n    # Heuristic 15/19 component: Exploration bonus (favor bins with more remaining capacity)\n    # Normalize remaining capacities of suitable bins to a [0, 1] range\n    min_rem_cap = np.min(suitable_bins_remain_cap)\n    max_rem_cap = np.max(suitable_bins_remain_cap)\n    if max_rem_cap - min_rem_cap > 1e-9: # Avoid division by zero if all remaining capacities are same\n        exploration_bonus = (suitable_bins_remain_cap - min_rem_cap) / (max_rem_cap - min_rem_cap)\n    else:\n        exploration_bonus = np.zeros_like(suitable_bins_remain_cap)\n\n    # Combine scores. Prioritize tightness but add exploration bonus.\n    # Weights can be tuned. Let's prioritize tightness slightly more.\n    combined_scores = 0.7 * tightness_scores + 0.3 * exploration_bonus\n\n    # Assign the combined scores to the original priority array for suitable bins\n    priorities[suitable_bins_mask] = combined_scores\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 83.62584762664541,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]