```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit (tightest residual) with Bin Fullness (prioritizing fuller bins)
    using dynamic weights based on item size. Aims for efficient packing by
    balancing tight fits with better overall bin utilization.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]

    # Metric 1: Best Fit (BF) - Prioritizes bins with minimum remaining capacity after placement.
    # Higher score for smaller `remaining_capacity = suitable_bins_caps - item`.
    remaining_capacity = suitable_bins_caps - item
    best_fit_scores = 1.0 / (remaining_capacity + 1e-9)

    # Metric 2: Bin Fullness (F) - Prioritizes bins that are already more full.
    # Higher score for smaller `suitable_bins_caps`.
    fullness_scores = 1.0 / (suitable_bins_caps + 1e-9)

    # Normalize scores for each metric to ensure they are in a comparable range.
    # Normalization helps in combining metrics with different scales.

    # Normalize Best Fit scores (0 to 1, higher is better)
    max_bf = np.max(best_fit_scores)
    norm_best_fit = best_fit_scores / max_bf if max_bf > 1e-9 else np.zeros_like(best_fit_scores)

    # Normalize Fullness scores (0 to 1, higher is better)
    max_f = np.max(fullness_scores)
    norm_fullness = fullness_scores / max_f if max_f > 1e-9 else np.zeros_like(fullness_scores)

    # --- Dynamic Weighting ---
    # Determine weights based on the item's size relative to the average suitable bin capacity.
    # This strategy adapts the heuristic's focus.
    avg_suitable_cap = np.mean(suitable_bins_caps)
    if avg_suitable_cap > 1e-9:
        item_vs_avg_cap_ratio = item / avg_suitable_cap
    else:
        item_vs_avg_cap_ratio = 1.0 # Default ratio if average capacity is zero/negligible

    # Base weights: Balanced approach
    w_bf_base = 0.6
    w_f_base = 0.4

    # Adjust weights:
    # If item is large relative to average suitable capacity, boost Best Fit.
    # If item is small relative to average suitable capacity, slightly boost Fullness (to use slightly fuller bins).
    # The goal is to make BF dominant for larger items and F still relevant for smaller ones.
    w_bf = w_bf_base + 0.3 * max(0, item_vs_avg_cap_ratio - 1.0)
    w_f = w_f_base - 0.3 * max(0, item_vs_avg_cap_ratio - 1.0)

    # Ensure weights are non-negative and sum to 1.
    w_bf = max(0.1, w_bf) # Ensure at least some weight for BF
    w_f = max(0.1, w_f)  # Ensure at least some weight for F

    total_w = w_bf + w_f
    w_bf /= total_w
    w_f /= total_w

    # Combine normalized scores with dynamically adjusted weights
    combined_scores = (w_bf * norm_best_fit + w_f * norm_fullness)

    # Assign the calculated combined scores to the priorities array for suitable bins.
    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
