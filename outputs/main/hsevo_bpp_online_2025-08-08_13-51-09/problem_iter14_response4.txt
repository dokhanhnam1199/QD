```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit's tightness with an exploration bonus favoring less utilized bins,
    using a balanced approach with dynamic weighting based on item size.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return np.zeros_like(bins_remain_cap)

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]

    # Best Fit Component: Prioritize bins with minimal remaining capacity after placement.
    # Use inverse of remaining capacity for higher scores for tighter fits.
    best_fit_scores = 1.0 / (suitable_bins_remain_cap - item + 1e-9)

    # Exploration Component: Favor bins with larger original capacity (less utilized).
    # Normalize remaining capacities of suitable bins using min-max scaling.
    min_cap = np.min(suitable_bins_remain_cap)
    max_cap = np.max(suitable_bins_remain_cap)
    if max_cap - min_cap > 1e-9:
        exploration_scores = (suitable_bins_remain_cap - min_cap) / (max_cap - min_cap)
    else:
        exploration_scores = np.zeros_like(suitable_bins_remain_cap)
        
    # Dynamic Weighting: Adjust weights based on item size relative to max suitable capacity.
    # For larger items, lean more towards Best Fit. For smaller items, give more weight to exploration.
    max_suitable_cap = np.max(suitable_bins_remain_cap)
    weight_bf = 0.5 + 0.5 * (item / max_suitable_cap) if max_suitable_cap > 1e-9 else 0.5
    weight_exp = 1.0 - weight_bf
    
    # Combine scores with dynamic weights. Higher combined scores indicate better bins.
    combined_scores = weight_bf * best_fit_scores + weight_exp * exploration_scores

    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
