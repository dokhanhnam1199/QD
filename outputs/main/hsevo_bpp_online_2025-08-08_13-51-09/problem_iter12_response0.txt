```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]

    # Metric 1: Best Fit - Prioritize bins that leave minimal remaining capacity.
    # Using inverse of remaining capacity, scaled to avoid extreme values.
    # A small epsilon is added to prevent division by zero and to ensure
    # even very tight fits (0 remaining) get a high score.
    remaining_after_placement = suitable_bins_caps - item
    best_fit_scores = 1.0 / (remaining_after_placement + 1e-6)

    # Metric 2: Bin Fullness - Reward bins that are already more full.
    # This encourages filling bins more completely before opening new ones.
    # We can approximate fullness by (bin_capacity - remaining_capacity) / bin_capacity.
    # For simplicity and adaptivity, let's use the remaining capacity relative to the maximum
    # capacity encountered among suitable bins. A smaller remaining capacity implies higher fullness.
    max_suitable_cap = np.max(suitable_bins_caps)
    if max_suitable_cap > 1e-6:
        # Lower remaining capacity relative to max suitable capacity means it's fuller.
        # We want to score higher for lower remaining capacity.
        fullness_scores = 1.0 - (suitable_bins_caps / max_suitable_cap)
    else:
        fullness_scores = np.zeros_like(suitable_bins_caps)

    # Metric 3: Item Size Ratio - Favor bins where the item takes up a significant portion
    # of the remaining capacity. This helps in reducing fragmentation for larger items.
    # Calculated as item_size / remaining_capacity. A higher ratio is better.
    # Add epsilon to denominator to avoid division by zero if remaining_capacity is zero.
    item_size_ratio_scores = item / (suitable_bins_caps + 1e-6)

    # Normalize scores to be in a comparable range [0, 1] for combination.
    # Use min-max scaling for robustness.

    if np.ptp(best_fit_scores) > 1e-6:
        normalized_best_fit = (best_fit_scores - np.min(best_fit_scores)) / np.ptp(best_fit_scores)
    else:
        normalized_best_fit = np.zeros_like(best_fit_scores)

    if np.ptp(fullness_scores) > 1e-6:
        normalized_fullness = (fullness_scores - np.min(fullness_scores)) / np.ptp(fullness_scores)
    else:
        normalized_fullness = np.zeros_like(fullness_scores)

    if np.ptp(item_size_ratio_scores) > 1e-6:
        normalized_item_ratio = (item_size_ratio_scores - np.min(item_size_ratio_scores)) / np.ptp(item_size_ratio_scores)
    else:
        normalized_item_ratio = np.zeros_like(item_size_ratio_scores)


    # Combine scores with dynamic weighting.
    # The weights are adjusted based on the item size relative to the bin capacity.
    # If the item is large relative to typical bin capacities, prioritize "best fit" and "item size ratio".
    # If the item is small, prioritize "fullness" to consolidate.

    # Assume a typical normalized bin capacity is 1.0 for scale.
    # The choice of scale can be an average item size or a predefined max capacity.
    # Let's use a soft threshold based on item size proportion to a conceptual "average" remaining capacity.
    # A simple heuristic for scale: consider average remaining capacity of suitable bins.
    avg_suitable_cap = np.mean(suitable_bins_caps) if suitable_bins_caps.size > 0 else 1.0
    item_ratio_to_avg_cap = item / (avg_suitable_cap + 1e-6)

    # Weights adjust based on how "large" the item is relative to the available space.
    # If item_ratio_to_avg_cap is high (item is relatively large), boost best_fit and item_ratio.
    # If item_ratio_to_avg_cap is low (item is relatively small), boost fullness.

    weight_best_fit = 0.3 + 0.4 * min(item_ratio_to_avg_cap, 1.0)
    weight_fullness = 0.4 - 0.3 * min(item_ratio_to_avg_cap, 1.0)
    weight_item_ratio = 0.3 + 0.3 * min(item_ratio_to_avg_cap, 1.0)

    # Ensure weights sum to 1
    total_weight = weight_best_fit + weight_fullness + weight_item_ratio
    if total_weight > 1e-6:
        weight_best_fit /= total_weight
        weight_fullness /= total_weight
        weight_item_ratio /= total_weight
    else: # Fallback if all weights are zero
        weight_best_fit, weight_fullness, weight_item_ratio = 1/3, 1/3, 1/3


    combined_scores = (weight_best_fit * normalized_best_fit +
                       weight_fullness * normalized_fullness +
                       weight_item_ratio * normalized_item_ratio)

    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
