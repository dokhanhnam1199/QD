The goal is to combine the strengths of "priority\_v0" and "priority\_v1". "priority\_v0" uses a nuanced "Modified Best Fit" with a quadratic penalty for residuals, an exploration bonus based on normalized capacities, and a subtle "usage" metric. "priority\_v1" uses a simpler reciprocal for tight fit and a linear exploration bonus based on remaining capacity after placement.

I will synthesize these by:
1.  **Retaining the "Modified Best Fit" from `priority_v0`**: The quadratic approach to penalize residuals near a target is more sophisticated than a simple reciprocal and can better avoid creating unusable small gaps.
2.  **Incorporating the "Exploration Bonus" from `priority_v1`**: The idea of favoring "less utilized bins" from `priority_v1` is simpler and more direct than the multi-part exploration in `priority_v0`. Specifically, using the difference from the minimum remaining capacity after placement as a primary driver for exploration is a good starting point.
3.  **Combining with a "Usage" Proxy (simplified from `priority_v0`)**: A simple proxy for usage could be the inverse of the remaining capacity *before* placement. Bins that are already less full (more remaining capacity) could get a slight boost, promoting spreading.
4.  **Weighting and Normalization**: Carefully choose weights to balance these components. Normalize scores appropriately to ensure they are comparable.

Let's define `priority_v2`:

*   **Metric 1 (Modified Best Fit):** From `priority_v0`. This metric aims to avoid extremely small, unusable gaps by favoring bins that leave a moderate residual capacity after placing the item. It uses a Gaussian-like function centered around a `target_residual`.
*   **Metric 2 (Exploration Bonus):** From `priority_v1`. This metric rewards bins that are less utilized, encouraging exploration of different bins. It's based on the remaining capacity *after* placement, normalized by the range of suitable bins. This means bins that have more space left (relative to other suitable bins) get a higher score.
*   **Metric 3 (Usage Proxy):** Inspired by `priority_v0`'s "Bin Age/Usage" but simplified. It prioritizes bins that have more total remaining capacity (i.e., are less full). This is approximated by `suitable_bins_caps`.

The combination will weigh these metrics, with a strong emphasis on the nuanced "Modified Best Fit".

```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines a nuanced best-fit approach with an exploration bonus favoring less utilized bins,
    and a subtle preference for bins with more overall remaining capacity.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]

    # Metric 1: Modified Best Fit (from priority_v0)
    # Prioritizes bins leaving a "sweet spot" residual capacity to avoid tiny unusable gaps.
    remaining_after_placement_m1 = suitable_bins_caps - item
    target_residual = item * 0.2  # Target residual capacity ~20% of item size
    # Gaussian-like function: higher score for residuals closer to target_residual
    # Add small epsilon to avoid division by zero if target_residual is 0.
    best_fit_scores = np.exp(-((remaining_after_placement_m1 - target_residual) / (target_residual + 1e-6))**2)

    # Metric 2: Exploration Bonus (inspired by priority_v1, simpler version)
    # Favors bins that are less full *after* placement, relative to other suitable bins.
    min_rem_after_m2 = np.min(remaining_after_placement_m1)
    max_rem_after_m2 = np.max(remaining_after_placement_m1)
    
    exploration_scores = np.zeros_like(suitable_bins_caps)
    if max_rem_after_m2 > min_rem_after_m2:
        # Normalized remaining capacity after placement: higher for more empty bins
        exploration_scores = (remaining_after_placement_m1 - min_rem_after_m2) / (max_rem_after_m2 - min_rem_after_m2)
    else:
        # If all suitable bins result in the same remaining capacity, no exploration bonus from this diff.
        # Default to 0.5 for any such bins to avoid bias.
        exploration_scores = np.ones_like(suitable_bins_caps) * 0.5

    # Metric 3: Usage Proxy (favors bins with more total remaining capacity)
    # This is a simple proxy for less-used bins.
    min_cap_all = np.min(bins_remain_cap)
    max_cap_all = np.max(bins_remain_cap)
    
    usage_scores = np.zeros_like(suitable_bins_caps)
    if max_cap_all > min_cap_all:
        # Normalize current remaining capacities. Higher score for more remaining capacity.
        normalized_current_caps = (suitable_bins_caps - min_cap_all) / (max_cap_all - min_cap_all)
        usage_scores = normalized_current_caps
    else:
        # If all bins have same capacity, this metric doesn't differentiate.
        usage_scores = np.ones_like(suitable_bins_caps) * 0.5

    # Combine scores: Heavy emphasis on nuanced best-fit, moderate on exploration, light on usage.
    # Weights are chosen to balance finding good fits with spreading items.
    # 0.6 for Best Fit (primary, quality of fit)
    # 0.3 for Exploration (secondary, diversity)
    # 0.1 for Usage (tertiary, simple preference for emptier bins)
    combined_scores = 0.6 * best_fit_scores + 0.3 * exploration_scores + 0.1 * usage_scores

    # Ensure scores are within a reasonable range and handle potential NaNs/Infs
    combined_scores = np.nan_to_num(combined_scores, nan=0.0, posinf=1.0, neginf=0.0)
    combined_scores = np.clip(combined_scores, 0.0, 1.0)

    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
