```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit (tightest residual space) with a bonus for bins that are
    larger (more potential for future items), using a normalized score.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    
    # Metric 1: Best Fit - prioritize bins with minimal remaining capacity after placement.
    # Higher score for smaller remaining capacity.
    remaining_after_placement = suitable_bins_caps - item
    best_fit_scores = 1.0 / (remaining_after_placement + 1e-6)
    
    # Metric 2: Favor larger bins - prioritize bins that have more capacity initially.
    # This provides a diversification aspect, not always picking the absolute tightest.
    large_bin_scores = suitable_bins_caps
    
    # Combine metrics: A weighted sum to balance tight fit and larger bin preference.
    # The weights can be tuned, but let's assume equal importance for now.
    # We want to normalize these scores to have a comparable range.
    
    # Normalize Best Fit scores (they are already positive and higher is better)
    if np.max(best_fit_scores) > 1e-6:
        normalized_best_fit = best_fit_scores / np.max(best_fit_scores)
    else:
        normalized_best_fit = np.zeros_like(best_fit_scores)

    # Normalize Large Bin scores
    if np.max(large_bin_scores) > 1e-6:
        normalized_large_bin = large_bin_scores / np.max(large_bin_scores)
    else:
        normalized_large_bin = np.zeros_like(large_bin_scores)

    # Combine normalized scores (e.g., simple average)
    # Higher priority indicates a better bin choice.
    combined_scores = 0.7 * normalized_best_fit + 0.3 * normalized_large_bin # Example weights
    
    priorities[suitable_bins_mask] = combined_scores
    
    return priorities
```
