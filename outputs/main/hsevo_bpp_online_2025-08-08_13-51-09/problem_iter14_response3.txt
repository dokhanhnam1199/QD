```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines a nuanced 'sweet spot' best-fit with exploration favoring less-used bins,
    weighted to prioritize good fits while encouraging diversification.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    
    # Metric 1: Nuanced Best Fit - Prioritize bins leaving a "sweet spot" of residual capacity.
    # This helps avoid very small unusable gaps. Using a Gaussian-like shape.
    remaining_after_placement = suitable_bins_caps - item
    # Define a target residual capacity, e.g., 20% of the item size, to aim for.
    target_residual = item * 0.2
    # Score is highest when remaining_after_placement is close to target_residual.
    # Adding a small epsilon to the denominator for numerical stability, especially if target_residual is 0.
    best_fit_scores = np.exp(-((remaining_after_placement - target_residual) / (target_residual + 1e-6))**2)

    # Metric 2: Exploration/Less Used Bin Preference - Favor bins that are less full *after* placement,
    # relative to other suitable bins. This encourages spreading items.
    # Calculate the range of remaining capacities after placing the item in suitable bins.
    min_rem_after_m2 = np.min(remaining_after_placement)
    max_rem_after_m2 = np.max(remaining_after_placement)
    
    exploration_scores = np.zeros_like(suitable_bins_caps)
    if max_rem_after_m2 > min_rem_after_m2:
        # Normalize remaining capacity after placement. Higher score for more empty bins.
        # This is a form of min-max scaling for the post-placement residual.
        exploration_scores = (remaining_after_placement - min_rem_after_m2) / (max_rem_after_m2 - min_rem_after_m2)
    elif suitable_bins_caps.size > 0:
        # If all suitable bins result in the same remaining capacity, this metric doesn't differentiate.
        # Assign a neutral score (e.g., 0.5) to avoid bias.
        exploration_scores = np.ones_like(suitable_bins_caps) * 0.5

    # Combine scores with a weighted sum.
    # Give a strong weight to the nuanced best-fit as it directly impacts packing efficiency.
    # Give a moderate weight to exploration to balance against potential fragmentation.
    # Weights are chosen to prioritize good fits while still allowing for diversification.
    # Example weights: 0.7 for Best Fit, 0.3 for Exploration.
    combined_scores = 0.7 * best_fit_scores + 0.3 * exploration_scores
    
    # Ensure scores are within a reasonable range and handle potential NaNs/Infs.
    # NaN values can occur if all suitable bins have the same remaining capacity after placement
    # and the denominator in exploration_scores becomes zero.
    combined_scores = np.nan_to_num(combined_scores, nan=0.5, posinf=1.0, neginf=0.0)
    # Clip scores to [0, 1] to maintain a consistent range.
    combined_scores = np.clip(combined_scores, 0.0, 1.0)

    priorities[suitable_bins_mask] = combined_scores
    
    return priorities
```
