```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit and Fullness Prioritization with adaptive weighting.
    This heuristic balances finding a snug fit for the item with utilizing fuller bins,
    adjusting emphasis based on the item's size relative to available capacity.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]

    # Metric 1: Best Fit (Minimize residual capacity)
    # Score is inversely proportional to the remaining capacity after placement.
    # Higher score for bins that leave less space.
    remaining_after_placement = suitable_bins_caps - item
    best_fit_scores = 1.0 / (remaining_after_placement + 1e-6)

    # Metric 2: Bin Fullness Prioritization (Favor fuller bins)
    # Score is inversely proportional to the bin's current remaining capacity.
    # Higher score for bins that are more full.
    fullness_scores = 1.0 / (suitable_bins_caps + 1e-6)

    # --- Adaptive Weighting ---
    # Determine the context: item size relative to average suitable bin capacity.
    avg_suitable_cap = np.mean(suitable_bins_caps)
    if avg_suitable_cap > 1e-9:
        item_vs_avg_cap_ratio = item / avg_suitable_cap
    else:
        item_vs_avg_cap_ratio = 0.5 # Default if no suitable bins or very small capacity

    # Base weights: BF for tight fit, F for consolidation.
    w_bf = 0.6
    w_f = 0.4

    # Adjust weights dynamically:
    # If item is relatively large, prioritize Best Fit more.
    # If item is relatively small, give more weight to Fullness to encourage consolidation.
    if item_vs_avg_cap_ratio > 1.0: # Item is larger than average remaining capacity
        w_bf += 0.2 * (item_vs_avg_cap_ratio - 1.0)
        w_f -= 0.2 * (item_vs_avg_cap_ratio - 1.0)
    else: # Item is smaller than average remaining capacity
        w_f += 0.2 * (1.0 - item_vs_avg_cap_ratio)
        w_bf -= 0.2 * (1.0 - item_vs_avg_cap_ratio)

    # Ensure weights remain valid and sum to 1.
    w_bf = max(0, w_bf)
    w_f = max(0, w_f)
    total_w = w_bf + w_f
    if total_w > 1e-9:
        w_bf /= total_w
        w_f /= total_w
    else: # Fallback if weights become zero
        w_bf, w_f = 0.5, 0.5

    # --- Normalization and Combination ---
    # Normalize scores to be in a comparable range [0, 1]
    # Normalize Best Fit scores: higher score is better.
    if np.max(best_fit_scores) > 1e-9:
        norm_best_fit = best_fit_scores / np.max(best_fit_scores)
    else:
        norm_best_fit = np.zeros_like(best_fit_scores)

    # Normalize Fullness scores: higher score is better.
    if np.max(fullness_scores) > 1e-9:
        norm_fullness = fullness_scores / np.max(fullness_scores)
    else:
        norm_fullness = np.zeros_like(fullness_scores)

    # Combine normalized scores with dynamic weights.
    combined_scores = (w_bf * norm_best_fit + w_f * norm_fullness)

    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
