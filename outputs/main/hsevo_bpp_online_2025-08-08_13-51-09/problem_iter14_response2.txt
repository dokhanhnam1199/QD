```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit (tightness) with a "Gap Fill Ratio" metric.
    Dynamic weights favor Best Fit for items that are a significant portion
    of the remaining space, and Gap Fill Ratio for items that are smaller
    relative to the available space.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    remaining_after_placement = suitable_bins_caps - item

    # Metric 1: Best Fit - Score based on the tightness of the fit.
    # Using the reciprocal of (1 + remaining capacity after placement)
    # This prioritizes bins where the remaining space is minimized.
    best_fit_scores = 1.0 / (1.0 + remaining_after_placement)

    # Metric 2: Gap Fill Ratio - Score based on how much the item fills the *current available space*.
    # High ratio means item is a large fraction of available space, good for utilizing larger gaps.
    # Add epsilon for stability.
    gap_fill_ratio_scores = item / (suitable_bins_caps + 1e-6)
    # Clip to avoid extreme values and ensure scores are somewhat bounded.
    gap_fill_ratio_scores = np.clip(gap_fill_ratio_scores, 0, 2.0)

    # Normalize scores to [0, 1] for combination. Avoid division by zero.
    max_best_fit = np.max(best_fit_scores)
    normalized_best_fit = best_fit_scores / max_best_fit if max_best_fit > 1e-6 else np.zeros_like(best_fit_scores)

    max_gap_fill = np.max(gap_fill_ratio_scores)
    normalized_gap_fill = gap_fill_ratio_scores / max_gap_fill if max_gap_fill > 1e-6 else np.zeros_like(gap_fill_ratio_scores)

    # Dynamic Weighting:
    # Aim to balance between fitting tightly (Best Fit) and utilizing larger gaps effectively (Gap Fill Ratio).
    # If an item is large relative to the available space in a bin, Best Fit becomes more important.
    # If an item is small relative to the available space, the Gap Fill Ratio (how much it contributes to filling that gap) is more relevant.

    # Consider the ratio of the item size to the maximum remaining capacity among suitable bins.
    # This gives a sense of whether the item is "large" or "small" compared to the best available space.
    max_suitable_cap = np.max(suitable_bins_caps)
    relative_item_size = item / (max_suitable_cap + 1e-6)

    # Weighting scheme:
    # For larger relative items (closer to 1), prioritize Best Fit.
    # For smaller relative items (closer to 0), prioritize Gap Fill Ratio.
    # Use a sigmoid-like shape for smooth transition.

    # Weight for Best Fit: increases with relative item size.
    # Range: [0.4, 0.9]
    weight_best_fit = 0.4 + 0.5 * relative_item_size
    weight_best_fit = np.clip(weight_best_fit, 0.4, 0.9)

    # Weight for Gap Fill Ratio: decreases with relative item size.
    # Range: [0.1, 0.6]
    weight_gap_fill = 0.6 - 0.5 * relative_item_size
    weight_gap_fill = np.clip(weight_gap_fill, 0.1, 0.6)

    # Ensure weights sum to 1.
    total_weight = weight_best_fit + weight_gap_fill
    if total_weight > 1e-6:
        weight_best_fit /= total_weight
        weight_gap_fill /= total_weight
    else: # Fallback if total_weight is near zero
        weight_best_fit = 0.5
        weight_gap_fill = 0.5

    combined_scores = (weight_best_fit * normalized_best_fit +
                       weight_gap_fill * normalized_gap_fill)

    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
