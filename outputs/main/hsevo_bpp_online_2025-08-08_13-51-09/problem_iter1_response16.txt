```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Sigmoid Fit Score strategy.

    The priority is higher for bins that have just enough remaining capacity to fit the item.
    This encourages fuller bins and potentially fewer overall bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    available_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if np.any(available_bins_mask):
        valid_capacities = bins_remain_cap[available_bins_mask]
        
        # Calculate the "fit score" - how close the remaining capacity is to the item size.
        # We want a high score when remaining_capacity is just slightly larger than item.
        # A good proxy is item / remaining_capacity for available bins.
        # If remaining_capacity is exactly item, this is 1. If much larger, it's close to 0.
        fit_scores = item / valid_capacities

        # Apply sigmoid to compress the fit scores into a [0, 1] range.
        # We can use a scaling factor to tune the steepness of the sigmoid.
        # A higher scaling factor makes the sigmoid steeper, more sensitive to small differences.
        # We can also add an offset to shift the sigmoid, but for this problem, a simple sigmoid is sufficient.
        scaling_factor = 5.0  # Tunable parameter
        sigmoided_scores = 1 / (1 + np.exp(-scaling_factor * (fit_scores - 0.8))) # Centered around a fit score of 0.8

        priorities[available_bins_mask] = sigmoided_scores

    return priorities
```
