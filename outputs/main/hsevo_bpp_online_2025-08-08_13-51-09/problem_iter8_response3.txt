```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit (tightest residual space) with an exploration bonus
    favoring bins with higher remaining capacity, normalized for balance.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]

    # Metric 1: Best Fit - Prioritize bins with minimal remaining capacity after placement.
    # Higher score for smaller remaining capacity (more tightly fitting).
    remaining_after_placement = suitable_bins_caps - item
    best_fit_scores = 1.0 / (remaining_after_placement + 1e-6)

    # Metric 2: Exploration Bonus - Prioritize bins with more initial remaining capacity.
    # This encourages using less full bins for better future packing flexibility.
    # Use min-max normalization for a balanced exploration score.
    if suitable_bins_caps.size > 0:
        min_cap = np.min(suitable_bins_caps)
        max_cap = np.max(suitable_bins_caps)
        if max_cap - min_cap > 1e-6:
            exploration_scores = (suitable_bins_caps - min_cap) / (max_cap - min_cap)
        else:
            exploration_scores = np.ones_like(suitable_bins_caps) * 0.5 # Handle case where all suitable bins have same capacity
    else:
        exploration_scores = np.array([])

    # Normalize Best Fit scores to be in a comparable range [0, 1]
    if np.max(best_fit_scores) > 1e-6:
        normalized_best_fit = best_fit_scores / np.max(best_fit_scores)
    else:
        normalized_best_fit = np.zeros_like(best_fit_scores)

    # Combine scores with weights: 70% for tight fit, 30% for exploration.
    # This prioritizes filling bins efficiently while still considering diversification.
    combined_scores = 0.7 * normalized_best_fit + 0.3 * exploration_scores

    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
