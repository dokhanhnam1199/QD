```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Balances Best Fit with an exploration bonus favoring bins with more remaining capacity,
    using a weighted sum of inverse difference and normalized remaining capacity.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]

    # Heuristic 1 component: Tightness score (higher for smaller remaining space)
    # This is the inverse of the difference, so smaller difference is better (higher score)
    tightness_scores = 1.0 / (suitable_bins_remain_cap - item + 1e-9) # Add epsilon for stability

    # Heuristic 15/19 component: Exploration bonus (favor bins with more remaining capacity)
    # Normalize remaining capacities of suitable bins to a [0, 1] range
    min_rem_cap = np.min(suitable_bins_remain_cap)
    max_rem_cap = np.max(suitable_bins_remain_cap)
    if max_rem_cap - min_rem_cap > 1e-9: # Avoid division by zero if all remaining capacities are same
        exploration_bonus = (suitable_bins_remain_cap - min_rem_cap) / (max_rem_cap - min_rem_cap)
    else:
        exploration_bonus = np.zeros_like(suitable_bins_remain_cap)

    # Combine scores. Prioritize tightness but add exploration bonus.
    # Weights can be tuned. Let's prioritize tightness slightly more.
    combined_scores = 0.7 * tightness_scores + 0.3 * exploration_bonus

    # Assign the combined scores to the original priority array for suitable bins
    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
