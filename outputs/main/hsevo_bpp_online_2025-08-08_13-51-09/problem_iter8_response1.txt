```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with an exploration bonus favoring less utilized bins using a log-transformed score.
    This aims for efficient packing and better distribution of items across bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]

    # Best Fit component: Inverse of the remaining space after packing
    # Smaller remaining space yields a higher score. Add epsilon for stability.
    best_fit_scores = 1.0 / (suitable_bins_remain_cap - item + 1e-9)

    # Exploration component: Reward bins with more remaining capacity (less utilized)
    # Use log transformation to dampen the effect of very large remaining capacities
    # and provide a smoother exploration bonus. Add 1 to avoid log(0).
    exploration_scores = np.log1p(suitable_bins_remain_cap)

    # Normalize exploration scores using min-max scaling to ensure they are comparable
    min_exp_score = np.min(exploration_scores)
    max_exp_score = np.max(exploration_scores)
    if max_exp_score - min_exp_score > 1e-9:
        normalized_exploration_scores = (exploration_scores - min_exp_score) / (max_exp_score - min_exp_score)
    else:
        normalized_exploration_scores = np.zeros_like(exploration_scores)

    # Combine Best Fit and Exploration scores
    # Weighting can be tuned. Prioritizing Best Fit slightly.
    w_best_fit = 0.7
    w_exploration = 0.3
    combined_scores = w_best_fit * best_fit_scores + w_exploration * normalized_exploration_scores

    # Assign combined scores to the priority array for suitable bins
    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
