```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit (tightest fit) with an exploration bonus for less utilized bins.
    It prioritizes bins that are nearly full but also gives a chance to less full bins.
    """
    epsilon = 0.05 # Exploration factor
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_cap = bins_remain_cap[suitable_bins_mask]

    # Best Fit component: inverse of the remaining capacity after placing the item.
    # Smaller remaining capacity is better (tighter fit). Add epsilon for stability.
    best_fit_score = 1.0 / (suitable_bins_cap - item + 1e-9)

    # Exploration component: bonus for bins that are less full (more remaining capacity).
    # This is a scaled difference from the average remaining capacity of suitable bins.
    # Higher remaining capacity gets a higher exploration bonus.
    avg_suitable_cap = np.mean(suitable_bins_cap)
    exploration_bonus = np.maximum(0, suitable_bins_cap - avg_suitable_cap) * epsilon

    # Combine Best Fit and Exploration.
    # The exploration bonus adds to the best fit score.
    # A small exploration factor prevents it from overpowering the best fit.
    priorities[suitable_bins_mask] = best_fit_score + exploration_bonus

    return priorities
```
