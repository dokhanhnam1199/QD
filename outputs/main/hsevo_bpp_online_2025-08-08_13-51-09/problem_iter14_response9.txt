```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a Bin Fullness metric, dynamically weighting them
    based on item size relative to bin capacities to balance tight fits and
    bin utilization.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]

    # Metric 1: Best Fit (Tightness)
    # Prioritize bins that leave minimum remaining capacity after packing.
    # Score is inverse of remaining capacity (smaller remaining = higher score).
    remaining_capacity = suitable_bins_caps - item
    best_fit_scores = 1.0 / (remaining_capacity + 1e-9)

    # Metric 2: Bin Fullness
    # Prioritize bins that are already more full, encouraging consolidation.
    # Score is inverse of current remaining capacity (more full = higher score).
    fullness_scores = 1.0 / (suitable_bins_caps + 1e-9)

    # --- Dynamic Weighting Strategy ---
    # Determine item's significance relative to available bin space.
    # Calculate average remaining capacity among suitable bins.
    avg_suitable_cap = np.mean(suitable_bins_caps)
    if avg_suitable_cap > 1e-9:
        # Ratio of item size to average suitable bin capacity.
        # > 1 suggests item is large relative to available space.
        # < 1 suggests item is small relative to available space.
        item_vs_avg_cap_ratio = item / avg_suitable_cap
    else:
        # Default if no suitable bins or average capacity is zero/negligible.
        item_vs_avg_cap_ratio = 0.5

    # Adjust weights:
    # For larger items (item_vs_avg_cap_ratio > 1.0):
    #   Emphasize Best Fit (tightness) and Bin Fullness.
    #   Reduce emphasis on Bin Fullness slightly as tightness is key.
    # For smaller items (item_vs_avg_cap_ratio <= 1.0):
    #   Emphasize Bin Fullness to use partially filled bins.
    #   Slightly reduce emphasis on Best Fit as exact tightness is less critical.
    if item_vs_avg_cap_ratio > 1.0:
        w_bf = 0.6  # More weight on tight fit for larger items
        w_f = 0.4   # Moderate weight on fullness
    else:
        w_bf = 0.4  # Moderate weight on tight fit for smaller items
        w_f = 0.6   # More weight on fullness for smaller items

    # Normalize weights to ensure they sum to 1 (though fixed here for clarity)
    # Total weight = w_bf + w_f

    # Normalize individual metric scores to a [0, 1] range for consistent combination.
    # Normalize Best Fit scores
    if np.max(best_fit_scores) > 1e-9:
        norm_best_fit = best_fit_scores / np.max(best_fit_scores)
    else:
        norm_best_fit = np.zeros_like(best_fit_scores)

    # Normalize Fullness scores
    if np.max(fullness_scores) > 1e-9:
        norm_fullness = fullness_scores / np.max(fullness_scores)
    else:
        norm_fullness = np.zeros_like(fullness_scores)

    # Combine normalized scores using dynamic weights
    combined_scores = (w_bf * norm_best_fit + w_f * norm_fullness)

    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
