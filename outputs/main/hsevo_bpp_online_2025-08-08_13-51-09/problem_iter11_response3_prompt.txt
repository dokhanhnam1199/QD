{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines Best Fit with an exploration bonus favoring less utilized bins.\n\n    This heuristic balances packing tightly (Best Fit) with spreading items,\n    aiming for better overall bin utilization and diversification.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return np.zeros_like(bins_remain_cap)\n\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n\n    # Best Fit Component: Smaller remaining capacity after placing the item is better.\n    # We use the negative of the remaining capacity to make larger negative values (tighter fits)\n    # have higher priority in argmin later.\n    best_fit_scores = -(suitable_bins_remain_cap - item)\n\n    # Exploration Bonus Component: Favor bins that are less utilized (larger original capacity).\n    # Use min-max scaling to normalize the remaining capacities of *suitable* bins.\n    # Higher remaining capacity (before placing item) gets a bonus.\n    min_cap = np.min(suitable_bins_remain_cap)\n    max_cap = np.max(suitable_bins_remain_cap)\n    if max_cap - min_cap > 1e-9: # Avoid division by zero if all suitable bins have same capacity\n        exploration_scores = (suitable_bins_remain_cap - min_cap) / (max_cap - min_cap)\n    else:\n        exploration_scores = np.zeros_like(suitable_bins_remain_cap)\n\n    # Combine scores: Prioritize Best Fit, then exploration bonus.\n    # A simple weighted sum can work, but we can also directly combine them.\n    # Let's prioritize best-fit by giving it a larger weight.\n    # The 'best_fit_scores' are negative, so a higher value (closer to 0) is better.\n    # The 'exploration_scores' are positive, higher is better.\n    # To combine, we can add them, ensuring best_fit_scores are scaled appropriately.\n    # A common approach is to make the best-fit component dominant.\n    # Let's try: priority = best_fit_component + weight * exploration_component\n    # Since best_fit_scores are negative, we can add a large constant to make them positive\n    # or ensure that the best_fit_scores are the primary driver.\n    # Let's make the best_fit_scores dominant and add exploration as a tie-breaker or secondary factor.\n    # We want smaller (more negative) best_fit_scores to be prioritized, so we add the exploration.\n    combined_scores = best_fit_scores + 0.5 * exploration_scores # Weight for exploration\n\n    priorities[suitable_bins_mask] = combined_scores\n\n    # Ensure no -inf remains if all suitable bins were considered.\n    # If all suitable bins have the same priority, np.argmin will pick the first one.\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Balances Best Fit (tightness) with an exploration bonus for emptier bins.\n    This heuristic aims for efficient packing by favoring tight fits while also\n    promoting distribution and potentially accommodating future items.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    valid_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n\n    # Best Fit component: prioritize bins with minimal remaining capacity after placing the item.\n    # Using inverse of the difference: smaller difference means higher priority.\n    tightness_scores = 1.0 / (valid_bins_remain_cap - item + 1e-9)\n\n    # Exploration component: reward bins that are currently emptier.\n    # This encourages spreading items across bins. We'll use the log of remaining capacity\n    # to dampen the effect of very large capacities, and add a small epsilon to avoid log(0).\n    # Higher log(remaining_capacity) means emptier, so we want to add this as a bonus.\n    # A multiplier is used to balance exploration with the best-fit objective.\n    emptiness_bonus = np.log(valid_bins_remain_cap + 1e-9) * 0.1 # Tunable parameter\n\n    # Combine scores: Sum of Best Fit and exploration bonus.\n    # Higher combined score indicates a more desirable bin.\n    combined_scores = tightness_scores + emptiness_bonus\n\n    # Normalize scores to be between 0 and 1 for easier interpretation and comparison.\n    # This ensures that the highest score is 1, and others are scaled proportionally.\n    max_score = np.max(combined_scores)\n    if max_score > 1e-9: # Avoid division by zero if all scores are effectively zero\n        priorities[suitable_bins_mask] = combined_scores / max_score\n    elif np.any(suitable_bins_mask): # If all suitable bins have similar low scores\n        # Distribute priority equally among suitable bins if all scores are near zero.\n        priorities[suitable_bins_mask] = 1.0 / np.sum(suitable_bins_mask)\n\n    return priorities\n\n### Analyze & experience\n- Comparing Heuristics 1st and 2nd: They are identical, indicating no difference in performance.\n\nComparing Heuristics 3rd, 4th, and 5th: These three heuristics are identical, suggesting they represent a single approach with consistent performance. They focus on a weighted sum of \"Best Fit\" and \"Favor Larger Bins\" using min-max scaling for the latter.\n\nComparing Heuristics 6th with 3rd/4th/5th: Heuristic 6th uses a different approach for exploration (less utilized bins) by directly using the difference from min/max suitable bin capacities for its score, and combines it with a negative best-fit score. This suggests a variation in how \"exploration\" is defined and combined.\n\nComparing Heuristics 9th with 1st/2nd: Heuristic 9th introduces a \"Modified Best Fit\" using a quadratic function around a target residual, and a refined \"Exploration Bonus\" with a sigmoid-like function, plus a \"Bin Age/Usage\" proxy. This is a more complex multi-metric approach compared to the simpler linear combinations in 1st/2nd.\n\nComparing Heuristics 10th/11th with 1st/2nd: Heuristics 10th and 11th are identical. They combine a \"tightness_scores\" (inverse of remaining space) with an \"emptiness_bonus\" (log of remaining capacity). This is a different combination than the more complex metrics in Heuristic 1.\n\nComparing Heuristics 12th/13th/14th with 10th/11th: These three heuristics are identical. They are very similar to Heuristics 10th/11th, using inverse of remaining space for tightness, and a normalized remaining capacity (min-max scaled) for exploration. The key difference is the normalization method for exploration and the weighting.\n\nComparing Heuristics 15th with 12th/13th/14th: Heuristic 15th is identical to Heuristics 16th and 17th. It uses inverse of remaining space for Best Fit and log1p of remaining capacity for exploration, then normalizes the exploration score and combines them.\n\nComparing Heuristics 18th/19th with 15th/16th/17th: Heuristics 18th and 19th are identical. They are similar to 15th/16th/17th by using inverse remaining space for tightness and log of remaining capacity for exploration, but normalize the *combined* scores instead of just the exploration component.\n\nComparing Heuristics 20th with others: Heuristic 20th introduces \"Fit Quality\" (ratio of bin capacity to item size) and \"Remaining Capacity Variance\" reduction. This is a distinct approach that doesn't directly use \"Best Fit\" in the same way.\n\nOverall: The heuristics generally explore variations of \"Best Fit\" (minimizing remaining space) and \"Exploration\" (favoring less full bins, or bins with specific properties). Normalization techniques and weighting schemes are varied. The complexity of metrics and their combination seems to loosely correlate with rank, with simpler combinations often appearing higher. Heuristics 7th and 8th are truncated and thus not fully comparable.\n- \nHere's a redefined approach to self-reflection for designing better heuristics:\n\n*   **Keywords:** Balance, Nuance, Justification, Adaptability, Simplicity (with purpose).\n*   **Advice:** Focus on *why* metrics are combined and *how* they interact. Justify normalization and weighting choices. Design heuristics that can adapt to different problem instances or stages of the search.\n*   **Avoid:** Arbitrary metric combinations, overly complex mathematical transformations without clear performance benefits, neglecting the *interpretability* of the heuristic's decisions, and assuming a single \"best\" metric.\n*   **Explanation:** True self-reflection goes beyond listing techniques. It requires critically assessing the *causal link* between a heuristic's design choices and its observed performance, aiming for elegant, well-reasoned solutions rather than just technically complex ones.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}