```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    
    # Metric 1: Worst Fit - Prioritize bins with maximal remaining capacity after placement.
    # This encourages keeping bins less full for better future packing flexibility.
    # We want to maximize (bins_remain_cap - item), so we want to minimize the negative of it.
    # Higher score for larger remaining capacity.
    remaining_after_placement = suitable_bins_caps - item
    worst_fit_scores = remaining_after_placement

    # Metric 2: Proximity to Average - Prioritize bins whose remaining capacity is close to the average remaining capacity of all suitable bins.
    # This aims to keep the distribution of remaining capacities more uniform, avoiding extreme values.
    if suitable_bins_caps.size > 0:
        avg_cap = np.mean(suitable_bins_caps)
        proximity_to_avg_scores = -np.abs(suitable_bins_caps - avg_cap)
    else:
        proximity_to_avg_scores = np.array([])

    # Normalize scores to be in a comparable range [0, 1]
    # For worst_fit_scores, higher is better, so normalize directly.
    if suitable_bins_caps.size > 0 and np.max(worst_fit_scores) > np.min(worst_fit_scores):
        normalized_worst_fit = (worst_fit_scores - np.min(worst_fit_scores)) / (np.max(worst_fit_scores) - np.min(worst_fit_scores))
    else:
        normalized_worst_fit = np.zeros_like(worst_fit_scores)

    # For proximity_to_avg_scores, more negative is better (closer to zero difference), so invert and normalize.
    if suitable_bins_caps.size > 0 and np.max(proximity_to_avg_scores) > np.min(proximity_to_avg_scores):
        normalized_proximity = (proximity_to_avg_scores - np.min(proximity_to_avg_scores)) / (np.max(proximity_to_avg_scores) - np.min(proximity_to_avg_scores))
    else:
        normalized_proximity = np.zeros_like(proximity_to_avg_scores)
    
    # Combine scores with weights: 60% for worst fit, 40% for proximity to average.
    # This prioritizes keeping bins less full and maintaining a balanced distribution of capacities.
    combined_scores = 0.6 * normalized_worst_fit + 0.4 * normalized_proximity

    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
