```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best Fit with a normalized exploration bonus for less full bins.

    Prioritizes bins that offer a tight fit, while also exploring less utilized
    bins through a normalized bonus, balancing immediate fit with future options.
    """
    epsilon = 0.1  # Weight for the exploration bonus
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item

    if np.any(suitable_bins_mask):
        suitable_bins_cap = bins_remain_cap[suitable_bins_mask]

        # Best Fit component: Prioritize bins with minimal remaining capacity after placing the item
        # Adding a small epsilon to the denominator to prevent division by zero.
        best_fit_score = 1.0 / (suitable_bins_cap - item + 1e-9)

        # Exploration component: Bonus for bins with larger remaining capacity (less full)
        # Normalize the remaining capacity using min-max scaling to provide a consistent bonus range.
        if suitable_bins_cap.size > 1:
            min_cap = np.min(suitable_bins_cap)
            max_cap = np.max(suitable_bins_cap)
            # Normalize remaining capacity: 0 for the fullest, 1 for the emptiest among suitable bins
            normalized_exploration_score = (suitable_bins_cap - min_cap) / (max_cap - min_cap + 1e-9)
            exploration_bonus = epsilon * normalized_exploration_score
        else:
            # If only one suitable bin, no relative exploration bonus is meaningful
            exploration_bonus = np.zeros_like(suitable_bins_cap)

        # Combine the Best Fit score with the exploration bonus
        priorities[suitable_bins_mask] = best_fit_score + exploration_bonus

    return priorities
```
