```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Balances tight fit with a diversified exploration bonus using inverse remaining capacity
    and a scaled bonus for less utilized bins. Favors tighter fits while encouraging
    exploration of less full bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    valid_bins_mask = bins_remain_cap >= item
    
    if not np.any(valid_bins_mask):
        return priorities
        
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]
    
    # Metric 1: Tight Fit Score (Inverse of remaining capacity after fitting)
    # This prioritizes bins that leave minimal space, promoting consolidation.
    tight_fit_score = 1.0 / (valid_bins_remain_cap - item + 1e-9)
    
    # Metric 2: Diversification Bonus (Inverse of current remaining capacity, scaled)
    # This encourages using less full bins to spread items, preventing premature bin closure.
    # Scale by the maximum remaining capacity among valid bins to give a relative bonus.
    if valid_bins_remain_cap.size > 0:
        max_current_cap = np.max(valid_bins_remain_cap)
        diversification_bonus = (1.0 / (valid_bins_remain_cap + 1e-9)) * (max_current_cap / (max_current_cap + 1e-9))
    else:
        diversification_bonus = np.zeros_like(valid_bins_remain_cap)

    # Combine scores: weighted sum. Give slightly more emphasis to tight fit,
    # but ensure diversification plays a significant role.
    combined_scores = 0.7 * tight_fit_score + 0.3 * diversification_bonus
    
    # Assign combined scores back to the original priority array
    priorities[valid_bins_mask] = combined_scores
    
    # Normalize priorities: Ensures the highest score is clearly dominant and
    # provides a consistent range of priorities across different item/bin states.
    max_priority = np.max(priorities[valid_bins_mask])
    if max_priority > 0:
        priorities[valid_bins_mask] /= max_priority
        
    return priorities
```
