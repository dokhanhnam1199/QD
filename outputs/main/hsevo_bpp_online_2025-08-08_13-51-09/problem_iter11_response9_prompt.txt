{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]\n\n    # Metric 1: Modified Best Fit - Prioritize bins that leave a small but not necessarily zero residual capacity.\n    # This aims to avoid leaving extremely small, unusable gaps.\n    remaining_after_placement = suitable_bins_caps - item\n    # Penalize very small residuals (e.g., < 10% of item size) slightly less than larger residuals.\n    # Reward residuals that are substantial enough to be potentially useful for future small items.\n    # We use a function that is high for residuals close to a \"sweet spot\" and decreases as it deviates.\n    # A quadratic function centered around a target residual (e.g., 20% of item size) can work.\n    target_residual = item * 0.2\n    best_fit_scores = np.exp(-((remaining_after_placement - target_residual) / (target_residual + 1e-6))**2)\n\n    # Metric 2: Exploration Bonus (Refined) - Favor bins that have a significant amount of remaining capacity,\n    # but also consider the \"quality\" of the space. Bins that are nearly full are still good for consolidation.\n    # We can use a sigmoid-like function to reward bins with moderate to high remaining capacity,\n    # but also give a slight boost to bins that are already quite full (consolidated).\n    min_cap_all = np.min(bins_remain_cap)\n    max_cap_all = np.max(bins_remain_cap)\n\n    if max_cap_all - min_cap_all > 1e-6:\n        normalized_caps = (suitable_bins_caps - min_cap_all) / (max_cap_all - min_cap_all)\n    else:\n        normalized_caps = np.ones_like(suitable_bins_caps) * 0.5\n\n    # Exploration score: favors moderately full bins (e.g., 30-70% full) and very full bins.\n    # Using a combination of a linear increase and a slight boost for higher capacities.\n    exploration_scores = normalized_caps * 0.6 + (normalized_caps**2) * 0.4\n\n    # Metric 3: Bin Age/Usage - Prioritize bins that have been used more recently or have been filled to a greater extent over time.\n    # This is an implicit metric. In an online setting, we can approximate this by looking at the\n    # \"age\" or number of items placed in a bin. For this function, we'll use remaining capacity as a proxy for \"emptiness\"\n    # and inversely relate it to \"usage\". Bins with less remaining capacity are considered \"more used\".\n    # We can factor this in by slightly boosting bins that are less empty (more filled).\n    # This is already somewhat captured by the Best Fit metric. Let's add a subtle bias for bins with less remaining capacity overall.\n    # Lower remaining capacity (i.e., higher usage) should get a slight preference.\n    usage_scores = 1.0 - normalized_caps\n    usage_scores = usage_scores / (np.max(usage_scores) + 1e-6) # Normalize to [0, 1]\n\n    # Combine scores with adjusted weights. Focus on balancing fit and exploration.\n    # 60% for Best Fit (nuanced), 30% for Exploration (rewarding moderate to high capacity), 10% for Usage.\n    # The interaction between these is more nuanced: Best Fit finds the tightest, Exploration uses less full bins,\n    # Usage encourages consolidation.\n    combined_scores = 0.6 * best_fit_scores + 0.3 * exploration_scores + 0.1 * usage_scores\n\n    # Ensure scores are within [0, 1] and handle potential NaNs or Infs\n    combined_scores = np.nan_to_num(combined_scores, nan=0.0, posinf=1.0, neginf=0.0)\n    combined_scores = np.clip(combined_scores, 0.0, 1.0)\n\n    priorities[suitable_bins_mask] = combined_scores\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines tight packing (Best Fit) with a diversification bonus favoring\n    less utilized bins. Balances fitting tightly with spreading load.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_cap = bins_remain_cap[suitable_bins_mask]\n    remaining_after_placement = suitable_bins_cap - item\n\n    # Primary objective: Tight Fit (Best Fit)\n    # Higher score for smaller remaining capacity. Use reciprocal for emphasis.\n    tight_fit_score = 1.0 / (remaining_after_placement + 1e-9)\n\n    # Secondary objective: Diversification (Favor less utilized bins)\n    # This encourages using bins that are not already very full.\n    # We can measure this by the *remaining capacity after placement* relative to the\n    # *total capacity of the bin*. A higher ratio here means the bin was less full.\n    # Use min-max scaling for a robust normalized score between 0 and 1.\n    min_rem_after = np.min(remaining_after_placement)\n    max_rem_after = np.max(remaining_after_placement)\n\n    exploration_bonus = np.zeros_like(remaining_after_placement)\n    if max_rem_after > min_rem_after:\n        # Normalize remaining capacity after placement to get exploration score\n        exploration_bonus = (remaining_after_placement - min_rem_after) / (max_rem_after - min_rem_after)\n    else:\n        # If all suitable bins result in the same remaining capacity, no bonus from this metric.\n        pass\n\n    # Combine scores: Primarily driven by tight fit, with an additive exploration bonus.\n    # The exploration bonus is scaled down to ensure tight fit remains dominant,\n    # but it serves as a tie-breaker and encourages exploration.\n    # A weight of 0.1 is empirically chosen to give exploration a modest influence.\n    final_priorities = tight_fit_score + 0.1 * exploration_bonus\n\n    priorities[suitable_bins_mask] = final_priorities\n\n    return priorities\n\n### Analyze & experience\n- Comparing Heuristics 1st and 2nd: They are identical, indicating no difference in performance.\n\nComparing Heuristics 3rd, 4th, and 5th: These three heuristics are identical, suggesting they represent a single approach with consistent performance. They focus on a weighted sum of \"Best Fit\" and \"Favor Larger Bins\" using min-max scaling for the latter.\n\nComparing Heuristics 6th with 3rd/4th/5th: Heuristic 6th uses a different approach for exploration (less utilized bins) by directly using the difference from min/max suitable bin capacities for its score, and combines it with a negative best-fit score. This suggests a variation in how \"exploration\" is defined and combined.\n\nComparing Heuristics 9th with 1st/2nd: Heuristic 9th introduces a \"Modified Best Fit\" using a quadratic function around a target residual, and a refined \"Exploration Bonus\" with a sigmoid-like function, plus a \"Bin Age/Usage\" proxy. This is a more complex multi-metric approach compared to the simpler linear combinations in 1st/2nd.\n\nComparing Heuristics 10th/11th with 1st/2nd: Heuristics 10th and 11th are identical. They combine a \"tightness_scores\" (inverse of remaining space) with an \"emptiness_bonus\" (log of remaining capacity). This is a different combination than the more complex metrics in Heuristic 1.\n\nComparing Heuristics 12th/13th/14th with 10th/11th: These three heuristics are identical. They are very similar to Heuristics 10th/11th, using inverse of remaining space for tightness, and a normalized remaining capacity (min-max scaled) for exploration. The key difference is the normalization method for exploration and the weighting.\n\nComparing Heuristics 15th with 12th/13th/14th: Heuristic 15th is identical to Heuristics 16th and 17th. It uses inverse of remaining space for Best Fit and log1p of remaining capacity for exploration, then normalizes the exploration score and combines them.\n\nComparing Heuristics 18th/19th with 15th/16th/17th: Heuristics 18th and 19th are identical. They are similar to 15th/16th/17th by using inverse remaining space for tightness and log of remaining capacity for exploration, but normalize the *combined* scores instead of just the exploration component.\n\nComparing Heuristics 20th with others: Heuristic 20th introduces \"Fit Quality\" (ratio of bin capacity to item size) and \"Remaining Capacity Variance\" reduction. This is a distinct approach that doesn't directly use \"Best Fit\" in the same way.\n\nOverall: The heuristics generally explore variations of \"Best Fit\" (minimizing remaining space) and \"Exploration\" (favoring less full bins, or bins with specific properties). Normalization techniques and weighting schemes are varied. The complexity of metrics and their combination seems to loosely correlate with rank, with simpler combinations often appearing higher. Heuristics 7th and 8th are truncated and thus not fully comparable.\n- \nHere's a redefined approach to self-reflection for designing better heuristics:\n\n*   **Keywords:** Balance, Nuance, Justification, Adaptability, Simplicity (with purpose).\n*   **Advice:** Focus on *why* metrics are combined and *how* they interact. Justify normalization and weighting choices. Design heuristics that can adapt to different problem instances or stages of the search.\n*   **Avoid:** Arbitrary metric combinations, overly complex mathematical transformations without clear performance benefits, neglecting the *interpretability* of the heuristic's decisions, and assuming a single \"best\" metric.\n*   **Explanation:** True self-reflection goes beyond listing techniques. It requires critically assessing the *causal link* between a heuristic's design choices and its observed performance, aiming for elegant, well-reasoned solutions rather than just technically complex ones.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}