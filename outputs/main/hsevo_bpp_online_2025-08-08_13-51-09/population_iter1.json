[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using First Fit decreasing heuristic logic.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins_mask = bins_remain_cap >= item\n    priorities[suitable_bins_mask] = bins_remain_cap[suitable_bins_mask] - item\n    best_fit_bin_index = np.argmin(priorities)\n    priorities[:] = 0\n    priorities[best_fit_bin_index] = 1\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements a Best Fit strategy for the online Bin Packing Problem.\n    Prioritizes bins that have the smallest remaining capacity *after* the item is placed,\n    as long as the item fits. Items that don't fit get a low priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    can_fit_mask = bins_remain_cap >= item\n    remaining_capacities_after_fit = bins_remain_cap[can_fit_mask] - item\n    \n    # We want the bin with the smallest remaining capacity after fitting the item.\n    # A smaller remaining capacity is better. So, we want to maximize the negative of the remaining capacity.\n    priorities[can_fit_mask] = -remaining_capacities_after_fit\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = bins_remain_cap[i] - item\n        else:\n            priorities[i] = -1\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.9999627090001 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Almost Full Fit strategy for Online Bin Packing Problem.\n    Prioritizes bins that are \"almost full\" and can accommodate the item.\n    A bin is considered \"almost full\" if its remaining capacity is\n    just enough to fit the item, plus a small tolerance.\n    \"\"\"\n    bin_capacity = 1.0  # Assuming standard bin capacity of 1.0\n    tolerance = 0.05   # A small tolerance for \"almost full\"\n\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Identify bins that can accommodate the item\n    fitting_bins_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate priority based on \"almost full\" criteria\n    # Higher priority for bins that are closer to being full (but still fit the item)\n    almost_full_priority_values = np.where(\n        fitting_bins_mask,\n        bin_capacity - (bins_remain_cap - item),\n        0  # Bins that cannot fit the item get zero priority\n    )\n\n    # Adjust priorities to favor bins that are \"almost full\"\n    # A bin is \"almost full\" if its remaining capacity after adding the item is small\n    # The formula bin_capacity - (bins_remain_cap - item) effectively penalizes\n    # bins that have a lot of remaining capacity after the item is placed.\n    # A smaller (bins_remain_cap - item) means the bin is \"more full\".\n\n    # Let's refine the \"almost full\" definition:\n    # We want to pick a bin such that after placing the item, the remaining capacity\n    # is as small as possible, but still positive.\n    # Remaining capacity after placing item: `bins_remain_cap - item`\n    # We want to minimize this value for fitting bins.\n    # So, for fitting bins, priority can be inversely related to `bins_remain_cap - item`.\n    # Or directly related to `item - (bin_capacity - bins_remain_cap)` which is the space utilized.\n    # To make it \"almost full\", we want the `bins_remain_cap - item` to be close to 0.\n    # A simple way is to maximize `item` that fits. But that's best fit.\n    # For Almost Full Fit, we want the `bins_remain_cap` to be *just* above `item`.\n\n    # Let's try a priority that is high if `bins_remain_cap` is slightly larger than `item`.\n    # A good heuristic might be to prioritize bins where `bins_remain_cap - item` is minimal,\n    # but still non-negative.\n    # We can use the negative of the remaining capacity after fitting the item as priority.\n    # This way, the smallest positive remaining capacity (most \"full\" bin) gets the highest negative value (largest magnitude).\n    # Or, we can use the absolute difference from a target \"almost full\" state.\n    # Target \"almost full\" state: remaining capacity is `tolerance`.\n    # So, priority is high when `bins_remain_cap - item` is close to `tolerance`.\n    # This means `bins_remain_cap` is close to `item + tolerance`.\n\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            # Higher priority for bins where remaining capacity is close to `item + tolerance`\n            # We want to maximize the \"closeness\" to this target.\n            # Let's define closeness as `abs((bins_remain_cap[i] - item) - tolerance)`\n            # And we want to minimize this closeness. So priority is `-abs(...)`\n            # Or, we want `bins_remain_cap[i]` to be close to `item + tolerance`.\n            # A higher value for `bins_remain_cap[i]` that is still acceptable (e.g., slightly larger than item)\n            # might be less preferred than a tighter fit.\n            #\n            # The \"Almost Full Fit\" strategy aims to fill bins as much as possible,\n            # but prefers bins that are *just* able to fit the item without much slack.\n            # So, we want `bins_remain_cap[i]` to be *just* greater than `item`.\n            # A good measure is `bins_remain_cap[i] - item`. We want this to be small and positive.\n            #\n            # Let's consider `bins_remain_cap[i] - item` as the \"slack\".\n            # We want to minimize slack.\n            # Priority can be the negative of the slack: `- (bins_remain_cap[i] - item)`\n            # However, this doesn't distinguish between \"almost full\" and simply fitting.\n            #\n            # \"Almost full\" implies we are looking for a bin whose current remaining capacity\n            # is just slightly more than the item's size.\n            #\n            # Let's consider the *target remaining capacity* to be `item + epsilon` where epsilon is small.\n            # If `bins_remain_cap[i]` is greater than `item + tolerance`, it's less \"almost full\"\n            # than a bin where `item <= bins_remain_cap[i] <= item + tolerance`.\n            #\n            # Strategy:\n            # 1. Prioritize bins that can fit the item.\n            # 2. Among fitting bins, prioritize those where the remaining capacity after placing\n            #    the item is small (i.e., `bins_remain_cap[i] - item` is small and positive).\n            #\n            # A simple priority could be to maximize `bins_remain_cap[i]`. This is First Fit.\n            # Best Fit is to minimize `bins_remain_cap[i]` among fitting bins.\n            #\n            # For \"Almost Full Fit\", we are looking for a bin that's already quite full,\n            # but still has space for the current item.\n            #\n            # Let's define a \"near fit\" condition: `item <= bins_remain_cap[i] < item + tolerance`.\n            # Among these, pick the one with the smallest `bins_remain_cap[i]`.\n            # If no such bin exists, fall back to something else.\n\n            # Revised approach for \"Almost Full Fit\":\n            # Prioritize bins that have a remaining capacity `r` such that `r - item` is minimized and non-negative.\n            # However, this is Best Fit.\n            # For \"Almost Full\", we are looking for bins that have a remaining capacity `r`\n            # such that `r` is small, and `r >= item`.\n            #\n            # Let's assign a higher priority to bins whose remaining capacity is just slightly\n            # larger than the item size.\n            #\n            # If `bins_remain_cap[i]` is very close to `item` (e.g., `bins_remain_cap[i] - item` is small),\n            # that bin is considered \"almost full\" for this item.\n\n            # A direct measure of \"almost full\" for a bin with capacity `c` to fit an item `i`:\n            # Consider the slack `s = c - i`. We want to find a bin where `s` is small and non-negative.\n            # This is Best Fit.\n            #\n            # The \"Almost Full Fit\" (or FFD-like) heuristics often prioritize bins that *are* almost full,\n            # meaning their current `bins_remain_cap` is high, but not excessively high.\n            #\n            # Let's try to define priority as a score that is higher for bins that are\n            # \"nearly full\" AND can fit the item.\n            #\n            # Consider the available space *after* placing the item: `bins_remain_cap[i] - item`.\n            # We want this to be small.\n            #\n            # Perhaps a simpler interpretation of \"Almost Full Fit\":\n            # Prioritize bins that are more filled, but can still accommodate the item.\n            # This means picking a bin `i` that minimizes `bins_remain_cap[i]` *among those that fit*.\n            # This is the Best Fit strategy.\n\n            # If we strictly follow \"Almost Full Fit\" as filling bins that are already quite full:\n            # It means bins with large `bins_remain_cap` are generally preferred if they can fit the item.\n            # But \"almost full\" implies not *too* much remaining space.\n            #\n            # Let's try to capture the idea that the remaining capacity is substantial, but not excessive.\n            #\n            # Consider the space *utilized* by the item in a bin with `bins_remain_cap[i]`.\n            # The percentage of the bin utilized by the *item* is `item / (bin_capacity - bins_remain_cap[i] + item)`\n            # No, that's not quite right.\n            #\n            # The concept is that we have a set of bins that are already quite full.\n            # We want to pick one that is \"almost full\" to put the item into.\n            #\n            # Let's assign a priority that is high if `bins_remain_cap[i]` is large,\n            # but not so large that it leaves excessive empty space.\n            #\n            # Try this: priority is high if `bins_remain_cap[i]` is large,\n            # but we want to penalize bins that leave a large *residual capacity* after the item is placed.\n            #\n            # Let's revisit the idea: find bins where `bins_remain_cap[i]` is just enough for the item,\n            # plus some small amount of slack.\n            #\n            # Consider a target `bins_remain_cap` for a bin to be \"almost full\" relative to the item.\n            # If `bins_remain_cap[i] >= item`, it fits.\n            # We want `bins_remain_cap[i]` to be close to `item` but not less than `item`.\n            #\n            # A higher priority should be given to bins that are \"more full\" but still accommodate.\n            # The metric `bins_remain_cap[i]` directly measures how full a bin is.\n            # We want to pick from bins where `bins_remain_cap[i] >= item`.\n            # Among these, we want to pick the one that is \"most full\".\n            #\n            # This implies we want to minimize `bins_remain_cap[i]` among fitting bins. This is Best Fit.\n            #\n            # However, \"Almost Full Fit\" as typically implemented in contexts like FFD\n            # means we consider bins that *are* already mostly full.\n            #\n            # Let's think about the bins that are already nearly full, say `bins_remain_cap[i] < threshold`.\n            # Then within those, pick the best.\n            #\n            # Alternative interpretation of \"Almost Full Fit\":\n            # Prioritize bins that have a high remaining capacity, but are NOT fully empty,\n            # and can fit the item. The priority increases with remaining capacity, up to a point.\n            #\n            # Let's try a scoring function that favors bins with a large remaining capacity,\n            # but gives diminishing returns or even a penalty if the remaining capacity is too large.\n            #\n            # If `bins_remain_cap[i] >= item`:\n            #   Priority could be `bins_remain_cap[i]`. This is greedy.\n            #   Priority could be `-bins_remain_cap[i]`. This favors less full bins. (Worst Fit)\n            #\n            # \"Almost Full Fit\": we want to pick a bin that is already substantially filled,\n            # but can still fit the current item.\n            #\n            # Let's try a function that is higher when `bins_remain_cap[i]` is large,\n            # and the gap `bins_remain_cap[i] - item` is small.\n            #\n            # Consider `bins_remain_cap[i]`.\n            # If it's very large (e.g., close to bin_capacity), it's not \"almost full\".\n            # If it's small (e.g., less than `item`), it cannot fit.\n            # We want `bins_remain_cap[i]` to be large, but not excessively large, and `>= item`.\n            #\n            # Let's try to reward bins whose remaining capacity is high.\n            # And penalize those where the residual space after placing the item is too large.\n            #\n            # For fitting bins: `bins_remain_cap[i] >= item`\n            # We want to maximize `bins_remain_cap[i]`, but cap the benefit.\n            #\n            # Let `slack = bins_remain_cap[i] - item`.\n            # We want `slack` to be small and non-negative.\n            # If `slack` is very small (near 0), priority is high.\n            # If `slack` is moderately small, priority is also high.\n            # If `slack` is large, priority is low.\n            #\n            # Let's define the priority based on the available space *after* fitting.\n            # We want to MINIMIZE `bins_remain_cap[i] - item`.\n            # So, priority is `- (bins_remain_cap[i] - item)`. This is Best Fit.\n            #\n            # Let's use a priority that captures the \"almost full\" nature directly.\n            # The priority should be higher for bins that have a remaining capacity `r`\n            # such that `item <= r < some_threshold`.\n            # And within that threshold, we prefer smaller `r`.\n            #\n            # Let's try to maximize `bins_remain_cap[i]`. This is Greedy.\n            # Let's try to minimize `bins_remain_cap[i]` given it fits. This is Best Fit.\n            #\n            # \"Almost Full Fit\":\n            # Prioritize bins that are already substantially filled, and can fit the item.\n            # A simple heuristic for \"almost full\" might be that the bin is *more than half full*,\n            # and can still fit the item.\n            #\n            # If `bins_remain_cap[i] >= item`:\n            #   If `bins_remain_cap[i] > bin_capacity / 2`: # Bin is more than half full\n            #     Priority = `bins_remain_cap[i]` # Favor more full bins\n            #   Else:\n            #     Priority = 0 # Not \"almost full\" enough\n\n            # Let's refine this. The notion of \"almost full\" is relative to the item.\n            # We want bins where `bins_remain_cap[i]` is large, but `bins_remain_cap[i] - item` is small.\n            #\n            # Priority function:\n            # For a bin `i` where `bins_remain_cap[i] >= item`:\n            #   Let `slack = bins_remain_cap[i] - item`.\n            #   We want to give higher priority as `slack` gets smaller (towards 0).\n            #   But also, the initial `bins_remain_cap[i]` should be relatively large.\n            #\n            # This implies a preference for bins that are:\n            # 1. Can fit the item (`bins_remain_cap[i] >= item`)\n            # 2. Are substantially filled (e.g., `bins_remain_cap[i]` is not close to `bin_capacity`)\n            # 3. Do not leave excessive slack after the item is placed (`bins_remain_cap[i] - item` is small)\n            #\n            # Let's consider `bins_remain_cap[i]`.\n            # If `bins_remain_cap[i] >= item`, it's a candidate.\n            # Among candidates, we want to find one that is \"almost full\".\n            #\n            # Let's try this definition: a bin is \"almost full\" if its remaining capacity\n            # is between `item` and `item + alpha`, where alpha is small.\n            # Among such bins, we prefer the ones with smaller `bins_remain_cap[i]`.\n            #\n            # If `item <= bins_remain_cap[i] < item + tolerance`:\n            #   Priority = `-(bins_remain_cap[i] - item)`  (favors smaller `bins_remain_cap[i]`)\n            # Else if `bins_remain_cap[i] >= item + tolerance`:\n            #   Priority = `-(tolerance)` # Less priority, but still usable if no \"almost full\" bin exists.\n            # Else:\n            #   Priority = -infinity (or a very small number)\n\n            # A simpler approach might be to prioritize bins that have *just enough* space.\n            # Let's try a priority that rewards bins where `bins_remain_cap[i]` is large,\n            # but penalizes bins that would leave a lot of space after the item is placed.\n            #\n            # If `bins_remain_cap[i] >= item`:\n            #   priority = `bins_remain_cap[i]`  # Favors fuller bins\n            #   # But we don't want it to be *too* full such that the gap is enormous.\n            #   # Let's say if `bins_remain_cap[i] > some_high_threshold`, priority is reduced.\n            #\n            # The common understanding of \"Almost Full Fit\" in heuristics like \"Almost Full First Fit\"\n            # is to select from bins that are *already* mostly full.\n            #\n            # Let's try to prioritize bins with higher remaining capacity, but with a slight preference for\n            # bins that will have less remaining space after the item is placed.\n            #\n            # If `bins_remain_cap[i] >= item`:\n            #   Priority = `bins_remain_cap[i]` - (a small penalty if `bins_remain_cap[i] - item` is large)\n            #\n            # Let's try a heuristic where we want to find a bin such that the *remaining space* after fitting\n            # is minimized, but also, the *original remaining space* was substantial.\n            #\n            # For bins that fit: `bins_remain_cap[i] >= item`\n            # We want to MINIMIZE `bins_remain_cap[i] - item`.\n            # Priority should be a decreasing function of `bins_remain_cap[i] - item`.\n            #\n            # Let's consider this: We want to fill bins. If a bin is almost full, it means\n            # it has substantial space but not excessive.\n            #\n            # Consider a bin's fill level *before* item: `1 - bins_remain_cap[i] / bin_capacity`.\n            # We want this to be high.\n            #\n            # A common \"Almost Full\" heuristic is related to fitting into bins that are already \"nearly full\".\n            # For an item of size `s`, a bin `j` with remaining capacity `r_j` is \"nearly full\" if `r_j` is not much larger than `s`.\n            #\n            # Let's try to score bins based on how \"close\" their remaining capacity is to the item size.\n            #\n            # For fitting bins (`bins_remain_cap[i] >= item`):\n            #   We want to reward bins where `bins_remain_cap[i]` is small.\n            #   This is Best Fit.\n            #\n            # If \"Almost Full Fit\" means we prioritize bins that are already largely filled,\n            # and we want to put the item into one of them, such that the resulting\n            # remaining space is minimized:\n            #\n            # Let `residual_capacity = bins_remain_cap[i] - item`\n            # We want to maximize `1.0 / (residual_capacity + epsilon)` for fitting bins.\n            # This rewards smaller residuals.\n\n            # Let's use the concept of \"desired gap\".\n            # For an item `item`, a bin with `bins_remain_cap[i]` is a candidate if `bins_remain_cap[i] >= item`.\n            # We want to find a bin where `bins_remain_cap[i]` is as close as possible to `item`,\n            # but not less than `item`.\n            # This means we want to minimize `bins_remain_cap[i] - item`.\n            #\n            # So, priority could be `- (bins_remain_cap[i] - item)` for fitting bins.\n            # This is equivalent to prioritizing the smallest remaining capacity after fitting.\n\n            # Let's try a priority that's higher for bins that have a good amount of remaining capacity,\n            # but not too much.\n            # A bin is \"almost full\" if its remaining capacity `r` satisfies:\n            # `item <= r < item + alpha`\n            # Among these, pick the one with the smallest `r`.\n\n            # Let's score a bin `i` if `bins_remain_cap[i] >= item`:\n            # Priority = `bins_remain_cap[i]` # Prioritize larger remaining capacities (less full bins) - THIS IS NOT ALMOST FULL\n            # Priority = `-bins_remain_cap[i]` # Prioritize smaller remaining capacities (more full bins) - THIS IS BEST FIT\n            #\n            # \"Almost Full Fit\": We want to find a bin that is already quite full, and the item *just* fits.\n            #\n            # Consider the value `bins_remain_cap[i]`.\n            # If `bins_remain_cap[i]` is very large (e.g., `> bin_capacity - some_small_value`), it's too empty.\n            # If `bins_remain_cap[i]` is small (e.g., `< item`), it doesn't fit.\n            #\n            # Let's define a range for \"almost full\": `[item, item + tolerance]`.\n            # If `bins_remain_cap[i]` is in this range, give it a high priority.\n            # And within this range, favor smaller `bins_remain_cap[i]`.\n            #\n            # Example: Bin capacity = 1.0, Item = 0.4. Tolerance = 0.1.\n            # Target range for remaining capacity: `[0.4, 0.5]`.\n            #\n            # Bin A: `bins_remain_cap[i]` = 0.7 (fits, but too much slack)\n            # Bin B: `bins_remain_cap[i]` = 0.45 (fits, in target range)\n            # Bin C: `bins_remain_cap[i]` = 0.4 (fits, in target range, smallest slack)\n            # Bin D: `bins_remain_cap[i]` = 0.3 (doesn't fit)\n            # Bin E: `bins_remain_cap[i]` = 0.6 (fits, but slack > tolerance)\n            #\n            # We want Bin C to have the highest priority, then Bin B, then perhaps Bin A or E.\n            #\n            # Priority function:\n            # If `bins_remain_cap[i] >= item`:\n            #   slack = bins_remain_cap[i] - item\n            #   If `slack <= tolerance`:\n            #     # \"Almost full\" bin - penalize larger slack within tolerance\n            #     priority = 1.0 - slack / tolerance # Higher priority for smaller slack\n            #   Else:\n            #     # Bin fits but has more slack than ideal \"almost full\"\n            #     # Give a lower priority. Maybe based on how much larger slack is.\n            #     # Let's give it a priority proportional to its remaining capacity, but less than \"almost full\".\n            #     priority = 0.5 * (1.0 - slack / (bin_capacity - item)) # Lower scale, favors larger remaining capacity if not \"almost full\"\n            # Else:\n            #   priority = 0.0 # Cannot fit\n\n            # Let's simplify.\n            # \"Almost Full Fit\": Prioritize bins that have the least remaining capacity *after* fitting the item,\n            # but ensuring this remaining capacity is not too small (i.e., not forcing an immediate overflow later).\n            # The key is that the bin is already *substantially* filled.\n            #\n            # A bin `i` is \"almost full\" if `bins_remain_cap[i]` is close to `item` and positive.\n            # The strategy aims to find bins that are already significantly filled.\n            #\n            # Consider the remaining capacity: `r = bins_remain_cap[i]`.\n            # If `r >= item`, it's a candidate.\n            # We want to select a candidate `i` that is \"most full\".\n            # This means `r` should be minimized. This is Best Fit.\n            #\n            # However, \"Almost Full Fit\" often implies a preference for bins that have a decent amount of remaining capacity,\n            # but not so much that they are nearly empty.\n            #\n            # Let's define \"almost full\" as `bins_remain_cap[i]` being between `item` and `bin_capacity * alpha`,\n            # where `alpha` is some fraction (e.g., 0.5 or 0.7).\n            #\n            # Let's consider priority based on how \"tight\" the fit is, given that it's a fit.\n            #\n            # If `bins_remain_cap[i] >= item`:\n            #   slack = bins_remain_cap[i] - item\n            #   # We want to maximize priority for small non-negative slack.\n            #   # Priority = 1 / (slack + epsilon)\n            #   # To make it \"almost full\", we also want `bins_remain_cap[i]` to be large.\n            #   # This is a trade-off.\n            #\n            # \"Almost Full Fit\": Pick the bin `j` that minimizes `bins_remain_cap[j]` among those that fit.\n            # This is Best Fit.\n            # The term \"almost full\" suggests that the bins themselves are already close to capacity.\n            #\n            # Let's try to implement a priority that favors bins which, after placing the item,\n            # leave a small but positive remaining capacity.\n            #\n            # If `bins_remain_cap[i] >= item`:\n            #   Priority = `1.0 / (bins_remain_cap[i] - item + 0.0001)` # Maximize inverse of slack\n            #\n            # This is essentially Best Fit if we just take the max.\n            #\n            # For \"Almost Full Fit\", the strategy is about selecting from bins that are already *mostly full*.\n            # So, bins with `bins_remain_cap[i]` closer to `0` are more \"almost full\".\n            # However, we also need `bins_remain_cap[i] >= item`.\n            #\n            # Let's assign a high priority to bins `i` where `bins_remain_cap[i]` is small, but still `>= item`.\n            # So, prioritize smaller `bins_remain_cap[i]`. This is Best Fit.\n            #\n            # Let's rethink the prompt's emphasis on \"Almost Full\".\n            # It's not just about fitting the item tightly, but about filling bins that are already *close to full*.\n            #\n            # Let's consider bins that have a substantial remaining capacity, but not an excessive one.\n            #\n            # If `bins_remain_cap[i] >= item`:\n            #   residual_after_fit = bins_remain_cap[i] - item\n            #   # We want `bins_remain_cap[i]` to be large.\n            #   # And we want `residual_after_fit` to be small.\n            #   # Let's try to score `bins_remain_cap[i] / (residual_after_fit + epsilon)`\n            #   # This rewards large `bins_remain_cap[i]` and small `residual_after_fit`.\n            #\n            #\n            # A simple approach that captures \"almost full\" might be:\n            # Prioritize bins with higher remaining capacity, but penalize those that are *too* empty.\n            #\n            # If `bins_remain_cap[i] >= item`:\n            #   # Priority = bins_remain_cap[i]\n            #   # This favors bins with more space.\n            #   # To make it \"almost full\", maybe we want to cap the `bins_remain_cap[i]` benefit.\n            #\n            # Let's consider a function that is high for values of `bins_remain_cap[i]` that are\n            # large, but not extremely large, and importantly, can fit the item.\n            #\n            # Final attempt at interpretation for \"Almost Full Fit\":\n            # Prioritize bins that have a remaining capacity that is just enough for the item,\n            # AND whose current state of \"fullness\" is high.\n            #\n            # For a bin `i` where `bins_remain_cap[i] >= item`:\n            #   We want to minimize `bins_remain_cap[i] - item`.\n            #   So, priority should be high for small non-negative `bins_remain_cap[i] - item`.\n            #   This makes the priority inversely proportional to the slack.\n            #\n            # Consider the percentage of the *remaining capacity* that the item will occupy.\n            # `item / bins_remain_cap[i]` (if `bins_remain_cap[i] > 0`).\n            # We want this to be high.\n            #\n            # Let's focus on `bins_remain_cap[i]`.\n            # A bin is \"almost full\" if its remaining capacity is small.\n            # However, it must be able to fit the item.\n            # So, we are looking for bins `i` such that `item <= bins_remain_cap[i] < some_threshold`.\n            # Among these, we want to pick the one that is *most* full, meaning smallest `bins_remain_cap[i]`.\n            #\n            # So, priority is highest for `bins_remain_cap[i]` that is minimal among fitting bins.\n            # This is Best Fit.\n            #\n            # Perhaps \"Almost Full Fit\" implies a preference for bins that are already *mostly full*,\n            # but not completely full.\n            #\n            # Let's try a priority that's higher for bins with a moderate-to-high remaining capacity,\n            # AND where the slack after fitting is small.\n            #\n            # Let `slack = bins_remain_cap[i] - item`.\n            #\n            # If `slack >= 0`:\n            #   # We want to reward smaller slacks AND larger `bins_remain_cap[i]`.\n            #   # Let's combine these.\n            #   # Priority proportional to `bins_remain_cap[i]` and inversely to `slack`.\n            #   # e.g., `bins_remain_cap[i] / (slack + epsilon)`\n            #   # This would mean: a bin with 0.8 capacity fitting a 0.7 item (slack 0.1) gives 8.0.\n            #   # A bin with 0.3 capacity fitting a 0.2 item (slack 0.1) gives 3.0.\n            #   # This still seems to favor larger `bins_remain_cap[i]`.\n            #\n            # Let's try to prioritize bins that are \"nearly full\" without being \"too empty\".\n            # Consider the \"waste\" after fitting the item: `bins_remain_cap[i] - item`.\n            # We want to minimize this waste. This is Best Fit.\n            #\n            # The term \"Almost Full Fit\" might be about preferring bins that are already substantially occupied,\n            # and this item fits neatly into it.\n            #\n            # Let's consider a penalty for being too empty.\n            # If `bins_remain_cap[i]` is very large (e.g., `> bin_capacity / 2` or some such threshold),\n            # then the priority is lower.\n            #\n            # Priority = `bins_remain_cap[i]` (favors more empty bins, First Fit-like if not capping)\n            # Priority = `-bins_remain_cap[i]` (favors fuller bins, Best Fit)\n            #\n            # Let's use a composite score:\n            # Prioritize bins that are \"full\" but not \"too full\".\n            #\n            # If `bins_remain_cap[i] >= item`:\n            #   priority = `bins_remain_cap[i]` * (1.0 - (bins_remain_cap[i] - item) / bin_capacity)\n            #   This tries to balance having more space with leaving less space after fit.\n\n            # Let's consider the common heuristics:\n            # First Fit: Iterate through bins, pick the first that fits.\n            # Best Fit: Iterate through bins, pick the one that fits with least remaining space.\n            # Worst Fit: Iterate through bins, pick the one that fits with most remaining space.\n            #\n            # \"Almost Full Fit\" often implies a strategy that tries to avoid leaving small gaps.\n            # Or it's about filling bins that are already *close to full*.\n            #\n            # Consider this interpretation:\n            # Prioritize bins `i` where `bins_remain_cap[i]` is large, but not excessively large.\n            # And the item fits.\n            #\n            # Let's define a threshold for \"almost full\": e.g., `bins_remain_cap[i] < 0.8 * bin_capacity`.\n            # If `item <= bins_remain_cap[i] < 0.8 * bin_capacity`:\n            #   priority = `bins_remain_cap[i]` (prioritize those with more space within this bound)\n            #\n            # A more direct approach for \"Almost Full Fit\":\n            # We want to find a bin that is already significantly full, and can accommodate the item.\n            # The priority should be high for bins that are close to full but can still fit the item.\n            #\n            # Let `desired_remaining_capacity = item + epsilon` (where epsilon is small).\n            # We are looking for bins where `bins_remain_cap[i]` is close to this `desired_remaining_capacity`.\n            #\n            # If `bins_remain_cap[i] >= item`:\n            #   slack = bins_remain_cap[i] - item\n            #   # We want small slack.\n            #   # Priority should increase as slack decreases.\n            #   # This is effectively maximizing `-slack`.\n            #   #\n            #   # For \"Almost Full\", the initial state of the bin matters.\n            #   # So, we want bins that are already full.\n            #   # This means `bins_remain_cap[i]` should be small.\n            #   #\n            #   # If we want bins that are \"almost full\" and the item fits:\n            #   # Small `bins_remain_cap[i]` that is still `>= item`.\n            #   # This is Best Fit.\n            #   #\n            #   # Let's try a different interpretation.\n            #   # Prioritize bins that have substantial remaining capacity, but *not* so much that it feels wasteful.\n            #   #\n            #   # For fitting bins (`bins_remain_cap[i] >= item`):\n            #   #   Let's penalize bins that are \"too empty\" OR \"too full (leaving large slack)\".\n            #   #   Define \"too empty\" threshold: `bins_remain_cap[i] < item` (already handled) or `bins_remain_cap[i] < some_lower_bound`\n            #   #   Define \"too much slack\": `bins_remain_cap[i] - item > some_upper_bound_on_slack`\n            #\n            #   # A common implementation for \"Almost Full Fit\" is to simply use Best Fit.\n            #   # However, if we need to be creative:\n            #   # Let's try to reward bins that are \"nearly filled\" with the item.\n            #   # This means `bins_remain_cap[i]` is close to `item`.\n            #   #\n            #   # If `item <= bins_remain_cap[i] < item + tolerance`:\n            #   #   Priority = 1.0 - (bins_remain_cap[i] - item) / tolerance\n            #   #   This gives higher priority to bins closer to `item`.\n            #   #\n            #   # What if no such bins exist?\n            #   # If `bins_remain_cap[i] >= item + tolerance`:\n            #   #   Then the bin is \"almost full\" in the sense that it has capacity, but not \"almost full\" relative to the item.\n            #   #   Let's give these a lower priority.\n            #   #   Maybe priority = 0.5 * (1.0 - (bins_remain_cap[i] - item) / bin_capacity) # scaled down priority\n            #\n            # Let's go with the interpretation that we want bins which, after placing the item, have a minimal but positive remaining capacity.\n            # This means minimizing `bins_remain_cap[i] - item`.\n            #\n            # Priority for fitting bins (`bins_remain_cap[i] >= item`):\n            #   `-(bins_remain_cap[i] - item)`\n            # This maximizes the negative slack, thus minimizing the positive slack.\n\n            # Let's refine: the \"almost full\" aspect suggests that the bin *itself* is already substantially filled.\n            # So, `bins_remain_cap[i]` should not be too large.\n            #\n            # Consider the total capacity used: `bin_capacity - bins_remain_cap[i]`.\n            # We want this to be large.\n            # AND `bins_remain_cap[i] >= item`.\n            #\n            # Let's score based on a combination:\n            # Higher priority if `bins_remain_cap[i]` is large AND `bins_remain_cap[i] - item` is small.\n            # This is inherently contradictory to some extent.\n            #\n            # Let's focus on making the bin *almost full after fitting the item*.\n            # This means `bins_remain_cap[i]` should be just a bit larger than `item`.\n            #\n            # If `bins_remain_cap[i] >= item`:\n            #   # We want to maximize the value of `bins_remain_cap[i]` such that `bins_remain_cap[i] - item` is minimal.\n            #   # Consider the \"fill level\" after the item is placed:\n            #   # `fill_level = (bin_capacity - (bins_remain_cap[i] - item)) / bin_capacity`\n            #   # We want to maximize this.\n            #   # Maximizing `bin_capacity - bins_remain_cap[i] + item`\n            #   # Which is maximizing `item - bins_remain_cap[i]` but this can be negative.\n            #   #\n            #   # If `bins_remain_cap[i] >= item`:\n            #   #   Maximize `item / (bins_remain_cap[i] - item + epsilon)`  -- This prioritizes small slack.\n            #\n            # This is becoming Best Fit.\n            #\n            # Let's use a priority that encourages placing items into bins that are already considerably full.\n            #\n            # If `bins_remain_cap[i] >= item`:\n            #   # Give higher priority to bins that have a smaller remaining capacity *overall*,\n            #   # as they are considered more \"full\".\n            #   # But also, we want the item to fit well.\n            #   #\n            #   # Priority = `bins_remain_cap[i]`  -> Favors bins with more empty space. (First Fit)\n            #   # Priority = `-bins_remain_cap[i]` -> Favors bins with less empty space. (Best Fit)\n            #   #\n            #   # For \"Almost Full Fit\", the goal is often to achieve a good packing density quickly.\n            #   # A common strategy related to this is to prefer bins that have a certain amount of remaining capacity,\n            #   # but not too much.\n            #   #\n            #   # Let's define priority based on the \"goodness\" of the fit.\n            #   # A good fit leaves little room for waste.\n            #   # `bins_remain_cap[i] - item` is the waste. We want to minimize this.\n            #   #\n            #   # Priority = `- (bins_remain_cap[i] - item)` is the inverse of waste.\n            #   # This is Best Fit.\n            #\n            # Let's interpret \"Almost Full Fit\" as preferring bins that are already quite full,\n            # and this item fits nicely into the remaining space without leaving a large gap.\n            #\n            # Priority = `bins_remain_cap[i]` - `(bins_remain_cap[i] - item)`\n            # This simplifies to `item`. This is constant for all fitting bins. Not useful.\n            #\n            # How about we give a bonus for being \"nearly full\"?\n            #\n            # If `bins_remain_cap[i] >= item`:\n            #   slack = bins_remain_cap[i] - item\n            #   # Reward small slack\n            #   priority = 1.0 - slack\n            #\n            # Let's refine \"almost full\": we want the bin's remaining capacity\n            # to be close to the item's size.\n            #\n            # If `bins_remain_cap[i] >= item`:\n            #   # We want `bins_remain_cap[i]` to be small. This is Best Fit.\n            #   #\n            #   # To be creative:\n            #   # Prioritize bins where `bins_remain_cap[i]` is large, but the amount of space *left over* after placing the item (`bins_remain_cap[i] - item`) is small.\n            #   #\n            #   # Let's try `priority = bins_remain_cap[i] - (bins_remain_cap[i] - item)`. This is `item`.\n            #   #\n            #   # What if we prioritize bins that are \"full enough\" such that putting the item makes it \"almost full\"?\n            #   #\n            #   # Final attempt: Prioritize bins that have a moderate-to-high remaining capacity,\n            #   # and importantly, leave minimal residual space after the item is placed.\n            #   #\n            #   # Let `remaining_after_fit = bins_remain_cap[i] - item`.\n            #   # We want to prioritize bins with larger `bins_remain_cap[i]`, but smaller `remaining_after_fit`.\n            #   #\n            #   # Score = `bins_remain_cap[i]` / (`remaining_after_fit` + epsilon)\n            #   # Example: BinCap=1.0, Item=0.3\n            #   # Bin A: rem=0.8. slack=0.5. Score = 0.8 / (0.5 + e) ~ 1.6\n            #   # Bin B: rem=0.4. slack=0.1. Score = 0.4 / (0.1 + e) ~ 4.0\n            #   # This favors smaller slack AND larger `bins_remain_cap[i]`. This seems promising.\n            #\n            # Let's implement this.\n\n            slack = bins_remain_cap[i] - item\n            if slack >= 0:\n                # Higher priority for smaller slack (closer to Best Fit for slack)\n                # Also prioritize larger `bins_remain_cap[i]`\n                # Combine: `bins_remain_cap[i] / (slack + small_epsilon)`\n                # Add a small epsilon to avoid division by zero.\n                small_epsilon = 1e-9\n                priorities[i] = bins_remain_cap[i] / (slack + small_epsilon)\n            else:\n                priorities[i] = 0.0 # Cannot fit\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996175599517 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            priorities[i] = capacity - item \n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996664299397 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    suitable_bins_mask = bins_remain_cap >= item\n    \n    if not np.any(suitable_bins_mask):\n        return np.zeros_like(bins_remain_cap)\n\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n    \n    distances = suitable_bins_remain_cap - item\n    \n    priorities = 1 / (distances + 1e-9)  # Add small epsilon to avoid division by zero\n    \n    full_priorities = np.zeros_like(bins_remain_cap)\n    full_priorities[suitable_bins_mask] = priorities\n    \n    return full_priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after placing the item\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Filter out bins where the item cannot fit\n    valid_bins_mask = potential_remaining_cap >= 0\n    valid_potential_remaining_cap = potential_remaining_cap[valid_bins_mask]\n\n    # If no bins can accommodate the item, return zeros\n    if valid_potential_remaining_cap.size == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    # Calculate the 'goodness' of fit. We want to minimize remaining capacity.\n    # A smaller remaining capacity is better, hence we use -valid_potential_remaining_cap.\n    # The sigmoid function squashes the values between 0 and 1.\n    # A higher value means a better fit (less remaining capacity).\n    # We'll use a scaling factor to control the steepness of the sigmoid.\n    # A larger scaling factor means the sigmoid is steeper, making the \"best fit\" more pronounced.\n    # Let's choose a scaling factor that encourages placing items in bins that are nearly full.\n    scaling_factor = 2.0\n    fit_scores = 1 / (1 + np.exp(-scaling_factor * (-valid_potential_remaining_cap)))\n\n    # Initialize priorities with zeros for all bins\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Assign the calculated fit scores to the valid bins\n    priorities[valid_bins_mask] = fit_scores\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-9)\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999951015008264 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Epsilon-Greedy priority for online Bin Packing Problem.\n\n    This priority function aims to balance exploration (trying less full bins)\n    and exploitation (using bins that are a good fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 0.1\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    suitable_bins = bins_remain_cap >= item\n    \n    if np.any(suitable_bins):\n        \n        best_fit_score = 1 / (bins_remain_cap[suitable_bins] - item + 1e-9) \n        \n        \n        avg_remaining_capacity = np.mean(bins_remain_cap[suitable_bins])\n        exploration_bonus = np.zeros_like(bins_remain_cap)\n        exploration_bonus[suitable_bins] = np.maximum(0, avg_remaining_capacity - bins_remain_cap[suitable_bins]) * epsilon\n\n        \n        priorities[suitable_bins] = best_fit_score + exploration_bonus[suitable_bins]\n    else:\n        \n        priorities = np.ones_like(bins_remain_cap) * -np.inf \n        \n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.178300757877951,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    fit_ratios = np.clip(bins_remain_cap - item, 0, None)\n    soft_max_priorities = np.exp(fit_ratios)\n    return soft_max_priorities / np.sum(soft_max_priorities)",
    "response_id": 9,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1 / (bins_remain_cap[i] - item + 1e-9)\n    return priorities",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 6.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    valid_bins_mask = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    if not np.any(valid_bins_mask):\n        return priorities\n        \n    available_capacities = bins_remain_cap[valid_bins_mask]\n    \n    gaps = available_capacities - item\n    \n    priorities[valid_bins_mask] = -gaps / available_capacities\n    \n    return priorities",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = bins_remain_cap[i] - item\n    return priorities",
    "response_id": 12,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": null,
    "response_id": 13,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Invalid response!"
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Exact Fit First strategy.\n    Prioritizes bins where the item fits exactly.\n    If no exact fit, prioritizes bins that leave the smallest remaining capacity.\n    If item doesn't fit anywhere, it gets a zero priority.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Check for exact fits\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    if exact_fit_indices.size > 0:\n        priorities[exact_fit_indices] = 1.0  # High priority for exact fits\n        return priorities\n\n    # If no exact fit, find bins that fit the item\n    fitting_indices = np.where(bins_remain_cap >= item)[0]\n    \n    if fitting_indices.size > 0:\n        remaining_capacities = bins_remain_cap[fitting_indices] - item\n        # Assign priority based on the smallest remaining capacity (closest to zero)\n        # We can use the negative of remaining capacity to sort in descending order\n        # so that smallest positive remaining capacity gets highest priority.\n        priorities[fitting_indices] = -remaining_capacities \n        \n    return priorities",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit) strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins_mask = bins_remain_cap >= item\n    \n    if not np.any(valid_bins_mask):\n        return priorities\n\n    valid_bins_cap = bins_remain_cap[valid_bins_bins_mask]\n    \n    \n    diffs = valid_bins_cap - item\n    \n    \n    priorities[valid_bins_mask] = 1.0 / (1.0 + diffs)\n    \n    return priorities",
    "response_id": 15,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 19, in priority_v2\nNameError: name 'valid_bins_bins_mask' is not defined. Did you mean: 'valid_bins_mask'?\n9\n2\n"
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Sigmoid Fit Score strategy.\n\n    The priority is higher for bins that have just enough remaining capacity to fit the item.\n    This encourages fuller bins and potentially fewer overall bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    available_bins_mask = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if np.any(available_bins_mask):\n        valid_capacities = bins_remain_cap[available_bins_mask]\n        \n        # Calculate the \"fit score\" - how close the remaining capacity is to the item size.\n        # We want a high score when remaining_capacity is just slightly larger than item.\n        # A good proxy is item / remaining_capacity for available bins.\n        # If remaining_capacity is exactly item, this is 1. If much larger, it's close to 0.\n        fit_scores = item / valid_capacities\n\n        # Apply sigmoid to compress the fit scores into a [0, 1] range.\n        # We can use a scaling factor to tune the steepness of the sigmoid.\n        # A higher scaling factor makes the sigmoid steeper, more sensitive to small differences.\n        # We can also add an offset to shift the sigmoid, but for this problem, a simple sigmoid is sufficient.\n        scaling_factor = 5.0  # Tunable parameter\n        sigmoided_scores = 1 / (1 + np.exp(-scaling_factor * (fit_scores - 0.8))) # Centered around a fit score of 0.8\n\n        priorities[available_bins_mask] = sigmoided_scores\n\n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            remaining_capacity = bins_remain_cap[i] - item\n            priorities[i] = 1.0 / (remaining_capacity + 1e-9)\n        else:\n            priorities[i] = -1.0\n    return priorities",
    "response_id": 17,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = cap - item\n    return priorities",
    "response_id": 18,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Softmax-based priority function for online Bin Packing Problem.\n\n    This function assigns a priority score to each bin based on how well\n    an item fits into it, using the Softmax function. Bins with more\n    remaining capacity, relative to the item's size, are prioritized.\n    The scores are normalized such that higher values indicate higher preference.\n    \"\"\"\n    # Calculate how much space is left in each bin if the item is placed there\n    # We only consider bins where the item *can* fit\n    potential_fits = bins_remain_cap - item\n    \n    # For bins where the item does not fit, set their potential_fit to a very small negative number\n    # to ensure they get a very low priority after softmax.\n    potential_fits[potential_fits < 0] = -np.inf\n\n    # Apply the Softmax function to transform scores into probabilities\n    # exp(score) / sum(exp(scores))\n    # This naturally handles the 'no fit' cases due to -inf, resulting in 0 probability.\n    # A small epsilon is added to the sum to prevent division by zero if all bins are full.\n    \n    # The core idea is to give higher priority to bins that have just enough space,\n    # or a bit more. Placing an item in a bin that leaves a very small gap might be\n    # better for tighter packing than placing it in a bin with vast excess capacity.\n    # We can achieve this by mapping the remaining capacity to a value that\n    # peaks when remaining_capacity = item_size.\n    # A possible transformation could be: -(remaining_capacity - item_size)^2\n    # However, a simpler approach that prioritizes larger remaining capacities is:\n    # just use the remaining capacity itself. For Softmax, higher values are better.\n    # Let's refine this: we want to prioritize bins that have enough space,\n    # and among those, perhaps those that leave a \"good\" amount of space.\n    # A simple \"good\" amount of space could be just enough or a bit more.\n    # Consider the inverse of the excess space.\n    \n    # Let's prioritize bins that have sufficient space and minimize wasted space.\n    # A bin that can barely fit the item (remaining_cap = item) is good.\n    # A bin that is much larger than the item is also okay.\n    # A bin that cannot fit the item is bad.\n    \n    # Consider a score that is higher for bins where remaining_cap >= item\n    # and penalizes large remaining_cap relative to item.\n    # A function like: item / (remaining_cap - item + epsilon) could work,\n    # but can be unstable.\n\n    # A common strategy in heuristic priority functions is to favor bins that\n    # leave the smallest possible remaining capacity after packing (Best Fit heuristic).\n    # In Softmax context, we want to assign higher scores to these bins.\n    # So, the 'score' should be inversely related to (bins_remain_cap - item).\n    # Let's try: score = - (bins_remain_cap - item)\n    # This makes smaller positive differences (closer to 0) have higher scores.\n    # And if bins_remain_cap - item is negative, it should be very low.\n    \n    # We already calculated potential_fits = bins_remain_cap - item.\n    # Let's use this directly in a way that emphasizes fitting well.\n    # We want to give higher scores to bins where (bins_remain_cap - item) is small and positive.\n    # This means the closer (bins_remain_cap - item) is to 0, the higher the priority.\n    # We can transform (bins_remain_cap - item) using an exponential decay or inverse.\n    # For Softmax, positive values are good, and we want the smallest positive values to be \"best\".\n    \n    # Let's try a score based on the \"tightness\" of the fit.\n    # If item fits, the gap is `bins_remain_cap - item`.\n    # We want to maximize priority when this gap is small and positive.\n    # So, `score = 1 / (bins_remain_cap - item + epsilon)` for positive gaps.\n    # For negative gaps, the score should be zero.\n    \n    # Let's create a score that is `-(bins_remain_cap - item)` for bins where it fits.\n    # This way, the smallest positive difference (closest to 0) gets the highest score.\n    # Example: item=3. Bins remaining_cap: [5, 8, 3, 4]\n    # Potential fits: [2, 5, 0, 1]\n    # Scores (-potential_fits): [-2, -5, 0, -1]\n    # Applying softmax to these scores.\n    # exp(-2), exp(-5), exp(0), exp(-1) -> approx [0.135, 0.0067, 1, 0.368]\n    # Sum = 0.135 + 0.0067 + 1 + 0.368 = 1.51\n    # Probabilities: [0.089, 0.004, 0.662, 0.244]\n    # This seems to prioritize the bin with remaining_cap = 3 correctly.\n\n    scores = bins_remain_cap - item\n    \n    # For bins where the item does not fit, assign a very low score.\n    # This ensures they get a probability close to zero after softmax.\n    scores[scores < 0] = -np.inf \n    \n    # Avoid division by zero if all scores are -inf (though unlikely if bins_remain_cap is non-empty)\n    # Add a small value to scores before exp to avoid 0 if -np.inf is handled in a peculiar way\n    # or if all remaining capacities are too small.\n    # A common technique is to add a small random noise or a small constant to prevent collapse.\n    # For Softmax, we can simply exponentiate and then normalize.\n    \n    exps = np.exp(scores)\n    \n    # If all exps are 0 (due to -np.inf), sum_exps will be 0. Handle this.\n    sum_exps = np.sum(exps)\n    if sum_exps == 0:\n        # This implies no bin could fit the item. Return uniform zero priorities or handle as an error.\n        # For now, returning zeros as it indicates no valid choice.\n        return np.zeros_like(bins_remain_cap)\n        \n    priorities = exps / sum_exps\n    \n    return priorities",
    "response_id": 19,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = bins_remain_cap[i] - item\n        else:\n            priorities[i] = -1\n    return priorities",
    "response_id": 20,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1 / (bins_remain_cap[i] - item + 1e-9)\n    return priorities",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 6.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            priorities[i] = capacity - item\n    return priorities",
    "response_id": 22,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Almost Full Fit: Prioritize bins that are almost full but can still fit the item.\n    # We want to put the item in a bin where the remaining capacity after fitting\n    # the item is as small as possible (but non-negative).\n    \n    # Calculate the remaining capacity if the item is placed in each bin\n    potential_remain_cap = bins_remain_cap - item\n\n    # Filter out bins where the item cannot fit\n    valid_bins_mask = potential_remain_cap >= 0\n    \n    # For valid bins, the priority is the negative of the remaining capacity.\n    # This makes bins with smaller remaining capacity (i.e., closer to full) have higher priority.\n    # We use a large negative number for bins that cannot fit the item, ensuring they are not chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins_mask] = -potential_remain_cap[valid_bins_mask]\n    \n    return priorities",
    "response_id": 23,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-9)\n    return priorities",
    "response_id": 24,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 6.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins_mask = bins_remain_cap >= item\n    \n    if np.any(valid_bins_mask):\n        valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n        \n        differences = valid_bins_remain_cap - item\n        \n        inverse_distances = 1.0 / (differences + 1e-9)\n        \n        priorities[valid_bins_mask] = inverse_distances\n\n    return priorities",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    available_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    if np.any(available_bins):\n        available_caps = bins_remain_cap[available_bins]\n        diff = available_caps - item\n        \n        # Sigmoid function to map differences to priorities\n        # We want smaller differences to have higher priority\n        # A larger negative number results in a sigmoid closer to 1\n        # Adding a small constant to avoid division by zero or very large negative numbers\n        adjusted_diff = - (diff + 1e-9) / (np.max(diff) - np.min(diff) + 1e-9)\n        \n        # Using a scaled sigmoid where the steepness is controlled\n        steepness = 5.0 # Controls how sharply the priority drops as difference increases\n        scaled_sigmoid_input = steepness * adjusted_diff\n        \n        # Apply sigmoid\n        priorities[available_bins] = 1 / (1 + np.exp(-scaled_sigmoid_input))\n        \n        # Normalize priorities to be between 0 and 1 (though sigmoid already does this)\n        # This step is more for conceptual clarity or if other scaling were involved\n        if np.max(priorities[available_bins]) > 0:\n            priorities[available_bins] /= np.max(priorities[available_bins])\n        \n    return priorities",
    "response_id": 26,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, remaining_cap in enumerate(bins_remain_cap):\n        if remaining_cap >= item:\n            priorities[i] = 1.0 / (remaining_cap - item + 1e-9)\n    return priorities",
    "response_id": 27,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 6.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Prioritize bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    # Heuristic: Prioritize bins with least remaining capacity that can still fit the item\n    # This is a \"best fit\" approach.\n    fitting_bins_capacity = bins_remain_cap[can_fit_mask]\n    if fitting_bins_capacity.size > 0:\n        # Calculate the \"waste\" if the item is placed in these bins\n        waste = fitting_bins_capacity - item\n        # Higher priority for bins with less waste (i.e., tighter fit)\n        # We invert the waste because we want the smallest waste to have the highest priority\n        # Add a small epsilon to avoid division by zero or very large negative numbers if waste is 0\n        priorities[can_fit_mask] = 1.0 / (waste + 1e-9)\n    \n    # A small random component can be added for exploration (epsilon-greedy like behavior)\n    # For simplicity in this priority function, we are directly implementing the greedy part.\n    # The epsilon-greedy strategy would then decide whether to pick the best fit (greedy)\n    # or a random bin. This priority function is solely for the greedy selection.\n    \n    return priorities",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    valid_bins_mask = bins_remain_cap >= item\n    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n    if valid_bins_remain_cap.size == 0:\n        return np.zeros_like(bins_remain_cap)\n    \n    capacities_ratio = valid_bins_remain_cap / np.sum(valid_bins_remain_cap)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins_mask] = np.exp(capacities_ratio) / np.sum(np.exp(capacities_ratio))\n    \n    return priorities",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]