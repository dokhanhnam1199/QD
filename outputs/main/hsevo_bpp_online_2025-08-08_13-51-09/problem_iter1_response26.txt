```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    available_bins = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    if np.any(available_bins):
        available_caps = bins_remain_cap[available_bins]
        diff = available_caps - item
        
        # Sigmoid function to map differences to priorities
        # We want smaller differences to have higher priority
        # A larger negative number results in a sigmoid closer to 1
        # Adding a small constant to avoid division by zero or very large negative numbers
        adjusted_diff = - (diff + 1e-9) / (np.max(diff) - np.min(diff) + 1e-9)
        
        # Using a scaled sigmoid where the steepness is controlled
        steepness = 5.0 # Controls how sharply the priority drops as difference increases
        scaled_sigmoid_input = steepness * adjusted_diff
        
        # Apply sigmoid
        priorities[available_bins] = 1 / (1 + np.exp(-scaled_sigmoid_input))
        
        # Normalize priorities to be between 0 and 1 (though sigmoid already does this)
        # This step is more for conceptual clarity or if other scaling were involved
        if np.max(priorities[available_bins]) > 0:
            priorities[available_bins] /= np.max(priorities[available_bins])
        
    return priorities
```
