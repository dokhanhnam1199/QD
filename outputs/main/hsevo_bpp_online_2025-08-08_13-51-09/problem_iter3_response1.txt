```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Filter bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item
    
    # Calculate potential remaining capacity if item is placed
    potential_remaining_cap = bins_remain_cap[suitable_bins_mask] - item
    
    # Heuristic 1: Prioritize bins with the smallest remaining capacity after placement (Best Fit)
    # Lower remaining capacity means a tighter fit. We want to prioritize these.
    # We invert the remaining capacity to get a higher score for smaller remaining capacity.
    # Add a small epsilon to avoid division by zero if remaining capacity is 0.
    best_fit_score = 1.0 / (potential_remaining_cap + 1e-9)
    
    # Heuristic 2: Consider the original remaining capacity for diversification.
    # Bins with larger original remaining capacity might offer more flexibility for future items.
    # We use a logarithmic scale to dampen the effect of very large capacities.
    original_capacity_score = np.log1p(bins_remain_cap[suitable_bins_mask])
    
    # Heuristic 3: Introduce a slight penalty for bins that are already very full.
    # This encourages using slightly less full bins to leave more room for future items.
    # The penalty is higher for bins that are closer to being full.
    fullness_penalty = 1.0 / (bins_remain_cap[suitable_bins_mask] + 1e-9)
    
    # Combine heuristics: A weighted sum of the scores.
    # The weights can be tuned. Here, we give a slightly higher weight to Best Fit.
    combined_score = (0.5 * best_fit_score + 0.3 * original_capacity_score - 0.2 * fullness_penalty)
    
    # Normalize scores to be between 0 and 1 for better stability and comparability
    if combined_score.size > 0:
        min_score = np.min(combined_score)
        max_score = np.max(combined_score)
        if max_score - min_score > 1e-9:
            normalized_scores = (combined_score - min_score) / (max_score - min_score)
        else:
            normalized_scores = np.ones_like(combined_score) * 0.5 # If all scores are the same, assign a neutral score
    else:
        normalized_scores = np.array([])

    # Assign the calculated priorities to the suitable bins
    priorities[suitable_bins_mask] = normalized_scores
    
    return priorities
```
