{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines tightest fit with a normalized bonus for larger remaining capacity,\n    using a weighted sum for balanced decision-making.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    suitable_bins_mask = bins_remain_cap >= item\n    \n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]\n    \n    # Metric 1: Best Fit - prioritize bins with minimal remaining capacity after placement.\n    remaining_after_placement = suitable_bins_caps - item\n    # Using inverse of remaining space (plus epsilon for numerical stability)\n    best_fit_scores = 1.0 / (remaining_after_placement + 1e-6)\n    \n    # Metric 2: Favor larger bins (diversification) - prioritize bins with more capacity initially.\n    # This encourages not always picking the absolute tightest.\n    large_bin_scores = suitable_bins_caps\n    \n    # Normalize Best Fit scores\n    if np.max(best_fit_scores) > 1e-6:\n        normalized_best_fit = best_fit_scores / np.max(best_fit_scores)\n    else:\n        normalized_best_fit = np.zeros_like(best_fit_scores)\n\n    # Normalize Large Bin scores (using min-max scaling on the capacities of suitable bins)\n    if suitable_bins_caps.size > 1:\n        min_cap = np.min(suitable_bins_caps)\n        max_cap = np.max(suitable_bins_caps)\n        range_cap = max_cap - min_cap\n        if range_cap > 1e-6:\n            normalized_large_bin = (suitable_bins_caps - min_cap) / range_cap\n        else:\n            normalized_large_bin = np.zeros_like(suitable_bins_caps) # All suitable bins have same capacity\n    elif suitable_bins_caps.size == 1:\n        normalized_large_bin = np.array([1.0]) # If only one bin, it's maximally \"large\" in this context\n    else:\n        normalized_large_bin = np.zeros_like(suitable_bins_caps)\n\n    # Combine normalized scores using a weighted sum.\n    # Weights can be tuned. Here, 70% Best Fit, 30% favor larger bins.\n    combined_scores = 0.7 * normalized_best_fit + 0.3 * normalized_large_bin\n    \n    priorities[suitable_bins_mask] = combined_scores\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines Best Fit with an exploration bonus favoring less utilized bins using a log-transformed score.\n    This aims for efficient packing and better distribution of items across bins.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n\n    # Best Fit component: Inverse of the remaining space after packing\n    # Smaller remaining space yields a higher score. Add epsilon for stability.\n    best_fit_scores = 1.0 / (suitable_bins_remain_cap - item + 1e-9)\n\n    # Exploration component: Reward bins with more remaining capacity (less utilized)\n    # Use log transformation to dampen the effect of very large remaining capacities\n    # and provide a smoother exploration bonus. Add 1 to avoid log(0).\n    exploration_scores = np.log1p(suitable_bins_remain_cap)\n\n    # Normalize exploration scores using min-max scaling to ensure they are comparable\n    min_exp_score = np.min(exploration_scores)\n    max_exp_score = np.max(exploration_scores)\n    if max_exp_score - min_exp_score > 1e-9:\n        normalized_exploration_scores = (exploration_scores - min_exp_score) / (max_exp_score - min_exp_score)\n    else:\n        normalized_exploration_scores = np.zeros_like(exploration_scores)\n\n    # Combine Best Fit and Exploration scores\n    # Weighting can be tuned. Prioritizing Best Fit slightly.\n    w_best_fit = 0.7\n    w_exploration = 0.3\n    combined_scores = w_best_fit * best_fit_scores + w_exploration * normalized_exploration_scores\n\n    # Assign combined scores to the priority array for suitable bins\n    priorities[suitable_bins_mask] = combined_scores\n\n    return priorities\n\n### Analyze & experience\n- Comparing Heuristics 1st and 2nd: They are identical, indicating no difference in performance.\n\nComparing Heuristics 3rd, 4th, and 5th: These three heuristics are identical, suggesting they represent a single approach with consistent performance. They focus on a weighted sum of \"Best Fit\" and \"Favor Larger Bins\" using min-max scaling for the latter.\n\nComparing Heuristics 6th with 3rd/4th/5th: Heuristic 6th uses a different approach for exploration (less utilized bins) by directly using the difference from min/max suitable bin capacities for its score, and combines it with a negative best-fit score. This suggests a variation in how \"exploration\" is defined and combined.\n\nComparing Heuristics 9th with 1st/2nd: Heuristic 9th introduces a \"Modified Best Fit\" using a quadratic function around a target residual, and a refined \"Exploration Bonus\" with a sigmoid-like function, plus a \"Bin Age/Usage\" proxy. This is a more complex multi-metric approach compared to the simpler linear combinations in 1st/2nd.\n\nComparing Heuristics 10th/11th with 1st/2nd: Heuristics 10th and 11th are identical. They combine a \"tightness_scores\" (inverse of remaining space) with an \"emptiness_bonus\" (log of remaining capacity). This is a different combination than the more complex metrics in Heuristic 1.\n\nComparing Heuristics 12th/13th/14th with 10th/11th: These three heuristics are identical. They are very similar to Heuristics 10th/11th, using inverse of remaining space for tightness, and a normalized remaining capacity (min-max scaled) for exploration. The key difference is the normalization method for exploration and the weighting.\n\nComparing Heuristics 15th with 12th/13th/14th: Heuristic 15th is identical to Heuristics 16th and 17th. It uses inverse of remaining space for Best Fit and log1p of remaining capacity for exploration, then normalizes the exploration score and combines them.\n\nComparing Heuristics 18th/19th with 15th/16th/17th: Heuristics 18th and 19th are identical. They are similar to 15th/16th/17th by using inverse remaining space for tightness and log of remaining capacity for exploration, but normalize the *combined* scores instead of just the exploration component.\n\nComparing Heuristics 20th with others: Heuristic 20th introduces \"Fit Quality\" (ratio of bin capacity to item size) and \"Remaining Capacity Variance\" reduction. This is a distinct approach that doesn't directly use \"Best Fit\" in the same way.\n\nOverall: The heuristics generally explore variations of \"Best Fit\" (minimizing remaining space) and \"Exploration\" (favoring less full bins, or bins with specific properties). Normalization techniques and weighting schemes are varied. The complexity of metrics and their combination seems to loosely correlate with rank, with simpler combinations often appearing higher. Heuristics 7th and 8th are truncated and thus not fully comparable.\n- \nHere's a redefined approach to self-reflection for designing better heuristics:\n\n*   **Keywords:** Balance, Nuance, Justification, Adaptability, Simplicity (with purpose).\n*   **Advice:** Focus on *why* metrics are combined and *how* they interact. Justify normalization and weighting choices. Design heuristics that can adapt to different problem instances or stages of the search.\n*   **Avoid:** Arbitrary metric combinations, overly complex mathematical transformations without clear performance benefits, neglecting the *interpretability* of the heuristic's decisions, and assuming a single \"best\" metric.\n*   **Explanation:** True self-reflection goes beyond listing techniques. It requires critically assessing the *causal link* between a heuristic's design choices and its observed performance, aiming for elegant, well-reasoned solutions rather than just technically complex ones.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}