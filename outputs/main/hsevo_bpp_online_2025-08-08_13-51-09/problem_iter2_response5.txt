```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins by combining a tight fit score (inverse of remaining capacity after fitting)
    with a diversification bonus for bins with less capacity.
    This aims to favor bins that are almost full for the current item while also
    exploring less utilized bins to prevent premature overcrowding.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Filter bins that can accommodate the item
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]
    
    if valid_bins_remain_cap.size > 0:
        # Calculate "tight fit" score: inverse of remaining capacity after fitting
        # A smaller remaining capacity means a tighter fit, hence higher priority.
        # Add a small epsilon to avoid division by zero.
        fit_scores = 1.0 / (valid_bins_remain_cap - item + 1e-9)
        
        # Calculate a "diversification bonus" based on the inverse of the remaining capacity
        # This slightly favors bins that are less full, promoting exploration.
        # We use the original remaining capacity here to gauge overall fullness.
        diversification_bonus = 1.0 / (bins_remain_cap[valid_bins_mask] + 1e-9)
        
        # Combine fit score and diversification bonus.
        # A simple additive combination, scaled to give reasonable influence to both.
        # The scaling factor can be tuned. Here, we'll give a slight edge to fit_scores.
        combined_priorities = fit_scores + 0.5 * diversification_bonus
        
        # Assign the calculated priorities back to the original array indices
        priorities[valid_bins_mask] = combined_priorities
        
    return priorities
```
