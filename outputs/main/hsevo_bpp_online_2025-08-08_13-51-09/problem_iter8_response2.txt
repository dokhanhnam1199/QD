```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best Fit with an exploration bonus favoring less utilized bins.

    This heuristic balances packing tightly (Best Fit) with spreading items,
    aiming for better overall bin utilization and diversification.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return np.zeros_like(bins_remain_cap)

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]

    # Best Fit Component: Smaller remaining capacity after placing the item is better.
    # We use the negative of the remaining capacity to make larger negative values (tighter fits)
    # have higher priority in argmin later.
    best_fit_scores = -(suitable_bins_remain_cap - item)

    # Exploration Bonus Component: Favor bins that are less utilized (larger original capacity).
    # Use min-max scaling to normalize the remaining capacities of *suitable* bins.
    # Higher remaining capacity (before placing item) gets a bonus.
    min_cap = np.min(suitable_bins_remain_cap)
    max_cap = np.max(suitable_bins_remain_cap)
    if max_cap - min_cap > 1e-9: # Avoid division by zero if all suitable bins have same capacity
        exploration_scores = (suitable_bins_remain_cap - min_cap) / (max_cap - min_cap)
    else:
        exploration_scores = np.zeros_like(suitable_bins_remain_cap)

    # Combine scores: Prioritize Best Fit, then exploration bonus.
    # A simple weighted sum can work, but we can also directly combine them.
    # Let's prioritize best-fit by giving it a larger weight.
    # The 'best_fit_scores' are negative, so a higher value (closer to 0) is better.
    # The 'exploration_scores' are positive, higher is better.
    # To combine, we can add them, ensuring best_fit_scores are scaled appropriately.
    # A common approach is to make the best-fit component dominant.
    # Let's try: priority = best_fit_component + weight * exploration_component
    # Since best_fit_scores are negative, we can add a large constant to make them positive
    # or ensure that the best_fit_scores are the primary driver.
    # Let's make the best_fit_scores dominant and add exploration as a tie-breaker or secondary factor.
    # We want smaller (more negative) best_fit_scores to be prioritized, so we add the exploration.
    combined_scores = best_fit_scores + 0.5 * exploration_scores # Weight for exploration

    priorities[suitable_bins_mask] = combined_scores

    # Ensure no -inf remains if all suitable bins were considered.
    # If all suitable bins have the same priority, np.argmin will pick the first one.
    return priorities
```
