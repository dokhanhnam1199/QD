```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with a normalized bonus for larger remaining capacity,
    using a weighted sum for balanced decision-making.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    
    # Metric 1: Best Fit - prioritize bins with minimal remaining capacity after placement.
    remaining_after_placement = suitable_bins_caps - item
    # Using inverse of remaining space (plus epsilon for numerical stability)
    best_fit_scores = 1.0 / (remaining_after_placement + 1e-6)
    
    # Metric 2: Favor larger bins (diversification) - prioritize bins with more capacity initially.
    # This encourages not always picking the absolute tightest.
    large_bin_scores = suitable_bins_caps
    
    # Normalize Best Fit scores
    if np.max(best_fit_scores) > 1e-6:
        normalized_best_fit = best_fit_scores / np.max(best_fit_scores)
    else:
        normalized_best_fit = np.zeros_like(best_fit_scores)

    # Normalize Large Bin scores (using min-max scaling on the capacities of suitable bins)
    if suitable_bins_caps.size > 1:
        min_cap = np.min(suitable_bins_caps)
        max_cap = np.max(suitable_bins_caps)
        range_cap = max_cap - min_cap
        if range_cap > 1e-6:
            normalized_large_bin = (suitable_bins_caps - min_cap) / range_cap
        else:
            normalized_large_bin = np.zeros_like(suitable_bins_caps) # All suitable bins have same capacity
    elif suitable_bins_caps.size == 1:
        normalized_large_bin = np.array([1.0]) # If only one bin, it's maximally "large" in this context
    else:
        normalized_large_bin = np.zeros_like(suitable_bins_caps)

    # Combine normalized scores using a weighted sum.
    # Weights can be tuned. Here, 70% Best Fit, 30% favor larger bins.
    combined_scores = 0.7 * normalized_best_fit + 0.3 * normalized_large_bin
    
    priorities[suitable_bins_mask] = combined_scores
    
    return priorities
```
