```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Sigmoid Fit Score strategy.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the remaining capacity after placing the item
    potential_remaining_cap = bins_remain_cap - item

    # Filter out bins where the item cannot fit
    valid_bins_mask = potential_remaining_cap >= 0
    valid_potential_remaining_cap = potential_remaining_cap[valid_bins_mask]

    # If no bins can accommodate the item, return zeros
    if valid_potential_remaining_cap.size == 0:
        return np.zeros_like(bins_remain_cap)

    # Calculate the 'goodness' of fit. We want to minimize remaining capacity.
    # A smaller remaining capacity is better, hence we use -valid_potential_remaining_cap.
    # The sigmoid function squashes the values between 0 and 1.
    # A higher value means a better fit (less remaining capacity).
    # We'll use a scaling factor to control the steepness of the sigmoid.
    # A larger scaling factor means the sigmoid is steeper, making the "best fit" more pronounced.
    # Let's choose a scaling factor that encourages placing items in bins that are nearly full.
    scaling_factor = 2.0
    fit_scores = 1 / (1 + np.exp(-scaling_factor * (-valid_potential_remaining_cap)))

    # Initialize priorities with zeros for all bins
    priorities = np.zeros_like(bins_remain_cap)

    # Assign the calculated fit scores to the valid bins
    priorities[valid_bins_mask] = fit_scores

    return priorities
```
