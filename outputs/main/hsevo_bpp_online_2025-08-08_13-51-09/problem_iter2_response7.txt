```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit (inverse difference) with an exploration bonus
    for less full bins, inspired by Epsilon-Greedy.

    Args:
        item: Size of item to be packed.
        bins_remain_cap: Array of remaining capacities of each bin.

    Returns:
        Array of priority scores for each bin.
    """
    epsilon = 0.1
    priorities = np.full_like(bins_remain_cap, -np.inf)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if np.any(suitable_bins_mask):
        suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
        
        # Best Fit component: Prioritize bins with minimal remaining capacity after packing
        # Using inverse of remaining capacity after fitting for a "tighter fit" score
        best_fit_scores = 1.0 / (suitable_bins_caps - item + 1e-9)
        
        # Exploration component: Bonus for bins with more remaining capacity
        # This encourages trying bins that are not necessarily the tightest fit
        avg_suitable_cap = np.mean(suitable_bins_caps)
        exploration_bonus = np.maximum(0, avg_suitable_cap - suitable_bins_caps) * epsilon
        
        priorities[suitable_bins_mask] = best_fit_scores + exploration_bonus
        
    return priorities
```
