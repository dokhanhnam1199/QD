```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit's tight packing with an epsilon-greedy exploration bonus
    using min-max scaling for robust exploration of less full bins.
    """
    epsilon = 0.1
    priorities = np.full_like(bins_remain_cap, -np.inf)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if np.any(suitable_bins_mask):
        suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
        
        # Best Fit component: Prioritize bins with minimal remaining capacity after packing
        best_fit_scores = 1.0 / (suitable_bins_caps - item + 1e-9)
        
        # Exploration component: Bonus for bins with more remaining capacity, normalized
        if suitable_bins_caps.size > 1:
            min_cap = np.min(suitable_bins_caps)
            max_cap = np.max(suitable_bins_caps)
            # Normalize remaining capacities to encourage exploration of emptier bins
            normalized_remaining_cap = (suitable_bins_caps - min_cap) / (max_cap - min_cap + 1e-9)
            exploration_bonus = epsilon * normalized_remaining_cap
        else:
            # If only one suitable bin, no relative exploration bonus
            exploration_bonus = np.zeros_like(suitable_bins_caps)
        
        priorities[suitable_bins_mask] = best_fit_scores + exploration_bonus
        
    return priorities
```
