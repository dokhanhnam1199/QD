```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Balances Best Fit (tightness) with an exploration bonus for emptier bins.
    This heuristic aims for efficient packing by favoring tight fits while also
    promoting distribution and potentially accommodating future items.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    valid_bins_remain_cap = bins_remain_cap[suitable_bins_mask]

    # Best Fit component: prioritize bins with minimal remaining capacity after placing the item.
    # Using inverse of the difference: smaller difference means higher priority.
    tightness_scores = 1.0 / (valid_bins_remain_cap - item + 1e-9)

    # Exploration component: reward bins that are currently emptier.
    # This encourages spreading items across bins. We'll use the log of remaining capacity
    # to dampen the effect of very large capacities, and add a small epsilon to avoid log(0).
    # Higher log(remaining_capacity) means emptier, so we want to add this as a bonus.
    # A multiplier is used to balance exploration with the best-fit objective.
    emptiness_bonus = np.log(valid_bins_remain_cap + 1e-9) * 0.1 # Tunable parameter

    # Combine scores: Sum of Best Fit and exploration bonus.
    # Higher combined score indicates a more desirable bin.
    combined_scores = tightness_scores + emptiness_bonus

    # Normalize scores to be between 0 and 1 for easier interpretation and comparison.
    # This ensures that the highest score is 1, and others are scaled proportionally.
    max_score = np.max(combined_scores)
    if max_score > 1e-9: # Avoid division by zero if all scores are effectively zero
        priorities[suitable_bins_mask] = combined_scores / max_score
    elif np.any(suitable_bins_mask): # If all suitable bins have similar low scores
        # Distribute priority equally among suitable bins if all scores are near zero.
        priorities[suitable_bins_mask] = 1.0 / np.sum(suitable_bins_mask)

    return priorities
```
