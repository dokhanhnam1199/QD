```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]

    # Metric 1: First Fit Decreasing Inspired - Prioritize bins that have enough capacity
    # but are not excessively large compared to the item. This aims for a balance
    # between fitting the item and leaving sufficient space for future items.
    # We use the ratio of bin capacity to item size as a proxy for "good fit".
    # A higher ratio means the bin is "just enough" or slightly larger.
    fit_quality_scores = suitable_bins_caps / item
    
    # Metric 2: Remaining Capacity Variance - Prioritize bins that reduce the variance
    # of remaining capacities among suitable bins. This encourages a more uniform
    # distribution of remaining capacities, potentially leading to better overall packing.
    # We want to favor bins that, after placing the item, result in remaining capacities
    # that are closer to the average remaining capacity.
    remaining_after_placement = suitable_bins_caps - item
    
    if remaining_after_placement.size > 0:
        mean_remaining = np.mean(remaining_after_placement)
        # We want bins that result in remaining capacity closer to the mean.
        # So, the score is inversely proportional to the absolute difference from the mean.
        variance_reduction_scores = 1.0 / (np.abs(remaining_after_placement - mean_remaining) + 1e-6)
        
        # Normalize variance reduction scores to [0, 1]
        max_vr_score = np.max(variance_reduction_scores)
        if max_vr_score > 1e-6:
            normalized_variance_reduction = variance_reduction_scores / max_vr_score
        else:
            normalized_variance_reduction = np.ones_like(variance_reduction_scores) * 0.5
    else:
        normalized_variance_reduction = np.array([])

    # Normalize fit quality scores to [0, 1]
    min_fq = np.min(fit_quality_scores)
    max_fq = np.max(fit_quality_scores)
    if max_fq - min_fq > 1e-6:
        normalized_fit_quality = (fit_quality_scores - min_fq) / (max_fq - min_fq)
    else:
        normalized_fit_quality = np.ones_like(fit_quality_scores) * 0.5

    # Combine scores with weights.
    # Giving more weight to fit quality (0.6) as it directly relates to how well
    # the item fits. The variance reduction (0.4) acts as a secondary objective
    # to promote better long-term packing.
    combined_scores = 0.6 * normalized_fit_quality + 0.4 * normalized_variance_reduction

    priorities[suitable_bins_mask] = combined_scores

    return priorities
```
