```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with an exploration bonus for less full bins.

    Prioritizes bins that offer a tight fit (small remaining capacity) but
    also encourages exploring bins with more empty space to avoid premature
    bin exhaustion.
    """
    epsilon = 0.1
    priorities = np.full_like(bins_remain_cap, -np.inf)

    suitable_bins_mask = bins_remain_cap >= item

    if np.any(suitable_bins_mask):
        suitable_bins_cap = bins_remain_cap[suitable_bins_mask]

        # Best Fit component: prioritize bins with minimal remaining capacity after fit
        # Add a small constant to avoid division by zero.
        best_fit_score = 1.0 / (suitable_bins_cap - item + 1e-9)

        # Exploration component: bonus for bins with larger remaining capacity
        # Normalize the bonus to prevent it from dominating the best fit score.
        # Using min-max scaling on the remaining capacities of suitable bins.
        if suitable_bins_cap.size > 1:
            min_cap = np.min(suitable_bins_cap)
            max_cap = np.max(suitable_bins_cap)
            normalized_remaining_cap = (suitable_bins_cap - min_cap) / (max_cap - min_cap + 1e-9)
            exploration_bonus = epsilon * normalized_remaining_cap
        else:
            # If only one suitable bin, no exploration bonus needed relative to others
            exploration_bonus = np.zeros_like(suitable_bins_cap)

        # Combine scores
        priorities[suitable_bins_mask] = best_fit_score + exploration_bonus

    return priorities
```
