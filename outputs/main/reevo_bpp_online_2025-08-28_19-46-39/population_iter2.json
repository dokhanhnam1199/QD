[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n        return priorities\n\n    eligible_bin_indices = np.where(eligible_bins)[0]\n    num_eligible_bins = len(eligible_bin_indices)\n\n    # Calculate a score based on bin utilization and item density\n    scores = np.zeros(num_eligible_bins)\n    for i, bin_index in enumerate(eligible_bin_indices):\n        remaining_capacity = bins_remain_cap[bin_index]\n        utilization = 1 - (remaining_capacity / bins_remain_cap[bin_index])\n        density = item / bins_remain_cap[bin_index]  # Item density relative to bin size\n        # Combine utilization and density.  Higher utilization is preferred, but also\n        # consider if the item is a good fit for the remaining space. Add some randomness.\n        scores[i] = 0.6 * utilization + 0.3 * density + 0.1 * np.random.rand()\n\n    priorities[eligible_bin_indices] = scores\n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999960250000186 seconds"
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n\n    if np.any(possible_bins):\n        # Prioritize bins with lower remaining capacity (better fit)\n        remaining_capacity = bins_remain_cap[possible_bins]\n        priorities[possible_bins] = 1.0 / (remaining_capacity - item + 1e-6)\n\n        # Add a small random element to break ties and encourage exploration\n        priorities[possible_bins] += np.random.rand(np.sum(possible_bins)) * 1e-6\n\n    return priorities",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 22, in priority_v2\n    return priorities\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n8\n2\n70.32403072095333\n"
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n\n    if np.any(possible_bins):\n        # Prioritize based on remaining capacity (smaller is better).\n        # Add a random element to avoid deterministic choices and explore different solutions.\n        remaining_space = bins_remain_cap[possible_bins] - item\n        priorities[possible_bins] = (1.0 / (remaining_space + 1e-6)) + np.random.rand(np.sum(possible_bins)) * 1e-3\n\n    return priorities",
    "response_id": 2,
    "obj": 4.188272836059035,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    eligible_bins = bins_remain_cap >= item\n    if not np.any(eligible_bins):\n        return priorities\n\n    # Prioritize empty bins\n    empty_bins = (bins_remain_cap == 0) & eligible_bins\n    priorities[empty_bins] = 1.0  # Highest priority\n\n    # Then prioritize bins with more remaining capacity\n    remaining_capacities = bins_remain_cap[eligible_bins]\n    \n    eligible_bin_indices = np.where(eligible_bins)[0]\n\n    if len(eligible_bin_indices) > 0:\n        # Normalize remaining capacities to [0, 1]\n        max_capacity = np.max(remaining_capacities)\n        if max_capacity > 0:\n            normalized_capacities = remaining_capacities / max_capacity\n            priorities[eligible_bin_indices] = normalized_capacities\n\n    # Add a small random component to break ties\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.001\n\n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 33, in priority_v2\n    \nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n16\n4\n114.20025299224778\n"
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin\n    fit_scores = item / bins_remain_cap\n    fit_scores[np.isinf(fit_scores)] = 0  # Handle cases where item > bin_remain_cap to avoid inf\n\n    # Apply a sigmoid function to the fit scores. A larger fit score will result in\n    # a priority closer to 1, representing a better fit. The sigmoid function\n    # ensures that the score remains between 0 and 1. We also introduce a scaling factor\n    # (e.g., 4) and a shift (e.g., -2) to adjust the sigmoid's slope and center.\n    # This could be tuned during experimentation. Adjusting the sigmoid's shape\n    # will influence the strategy; a steeper slope means more aggressive use of tight bins.\n    sigmoid_scores = 1 / (1 + np.exp(-4 * (fit_scores - 0.5)))\n\n    # Penalize bins that have very small remaining capacity. Adding the item to an\n    # almost full bin can lead to fragmentation.\n    capacity_penalty = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    sigmoid_scores = sigmoid_scores * capacity_penalty\n\n    # Additional penalty if the item doesn't fit at all in a particular bin. Avoids NaNs.\n    no_fit_penalty = np.where(bins_remain_cap < item, 0.0, 1.0)\n    sigmoid_scores = sigmoid_scores * no_fit_penalty\n\n    return sigmoid_scores",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 140.55415752892034,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the difference between the item size and the remaining capacity of each bin.\n    diffs = bins_remain_cap - item\n    \n    # Handle bins that are smaller than the item. Assign a large negative score.\n    priorities[diffs < 0] = -np.inf\n    \n    # For bins where the item fits, calculate the inverse distance.\n    valid_bins = diffs >= 0\n    \n    # Avoid division by zero by adding a small constant to the differences.\n    diffs_valid = diffs[valid_bins]\n    diffs_valid = np.where(diffs_valid == 0, 1e-6, diffs_valid)\n    \n    priorities[valid_bins] = 1.0 / diffs_valid\n    \n    return priorities",
    "response_id": 5,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 17, in priority_v2\n    # to a value between 0 and 1.  A higher value indicates a better fit.\nOverflowError: cannot convert float infinity to integer\n9\n1\n62.907475208398566\n"
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate fitness score using a sigmoid function.\n    # The sigmoid function maps the remaining capacity relative to the item size\n    # to a value between 0 and 1.  A higher value indicates a better fit.\n    # We add a small constant to avoid division by zero.\n    bins_remain_cap = np.maximum(bins_remain_cap, 1e-6)\n    fitness = bins_remain_cap / (item + 1e-6)  # Normalize by item size.\n    priorities = 1.0 / (1.0 + np.exp(-5 * (fitness - 0.5)))  # Sigmoid function.  Adjust scaling factor (5) as needed.\n    \n    return priorities",
    "response_id": 6,
    "obj": 145.17351416035103,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 81.7492568250068,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if np.any(possible_bins):\n        # Prioritize bins with less remaining capacity (better fit)\n        fit_score = 1.0 / (bins_remain_cap[possible_bins] - item + 1e-6)\n        # Add a diversity bonus:  bins that are less full get a slight boost.\n        # This encourages exploration and avoids filling up bins too quickly.\n        diversity_bonus = (bins_remain_cap[possible_bins] / np.max(bins_remain_cap) ) * 0.1\n        # Add some randomness for exploration\n        randomness = np.random.rand(np.sum(possible_bins)) * 1e-6\n        priorities[possible_bins] = fit_score + diversity_bonus + randomness\n    return priorities",
    "response_id": 7,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 118.59257041502654,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between the item size and the remaining capacity of each bin\n    diffs = bins_remain_cap - item\n    # Check for bins that can accommodate the item\n    valid_bins = diffs >= 0\n\n    if not np.any(valid_bins):\n        return priorities\n\n    # Calculate the priority score as a combination of fit and utilization.\n    # Smaller difference (better fit) gets higher priority.\n    # Higher remaining capacity (better utilization) also gets higher priority.\n    priorities[valid_bins] = (1.0 / (diffs[valid_bins] + 1e-6)) * (bins_remain_cap[valid_bins] / np.max(bins_remain_cap))\n\n    return priorities",
    "response_id": 8,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 84.9585502688717,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fitness score for each bin using a sigmoid function.\n    # The sigmoid function maps the remaining capacity to a value between 0 and 1,\n    # where 1 indicates a perfect fit and 0 indicates no fit.\n    # We use the item size as a scaling factor to adjust the sigmoid curve.\n    # Add a small constant to bins_remain_cap to avoid division by zero and instability.\n    bins_remain_cap = np.maximum(bins_remain_cap, 1e-6)\n    sigmoid_input = (bins_remain_cap - item) / item\n    priorities = 1 / (1 + np.exp(-sigmoid_input))\n\n    # Further boost the priority of bins that have very little remaining capacity,\n    # to encourage filling up those bins first. This can help reduce the total\n    # number of bins used. Add a small constant to item size to avoid division by zero.\n    item = np.maximum(item, 1e-6)\n    priorities = priorities * (bins_remain_cap / item)\n    return priorities",
    "response_id": 9,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 76.14709844115208,
    "exec_success": true
  }
]