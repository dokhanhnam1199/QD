[
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponential function to convert fit scores to priorities.\n        # Tighter fit -> higher priority.  Larger negative fit_score -> higher priority.\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 0,
    "obj": 3.9788591942560925,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Prioritize tightest fit (smallest remaining capacity after placing item)\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        best_fit_bin_index = np.argmin(fit_scores)\n        best_fit_bin_index = np.where(eligible_bins)[0][best_fit_bin_index]\n        priorities[best_fit_bin_index] = 1.0\n\n        # Epsilon-greedy exploration: assign random priority to other eligible bins\n        if np.random.rand() < epsilon:\n            other_eligible_bins = eligible_bins.copy()\n            other_eligible_bins[best_fit_bin_index] = False  # Exclude best fit\n            if np.any(other_eligible_bins):\n                random_bin_indices = np.where(other_eligible_bins)[0]\n                random_index = np.random.choice(random_bin_indices)\n                priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (tightest fit first)\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        fit_scores = 1.0 / (fit_scores + 1e-6)  # Avoid division by zero, prioritize tighter fits\n\n        # Normalize fit scores using sigmoid function\n        sigmoid_scale = 5.0  # Adjust for desired sigmoid steepness\n        fit_priorities = 1.0 / (1.0 + np.exp(-sigmoid_scale * fit_scores))\n\n        # Assign priorities to eligible bins\n        priorities[eligible_bins] = fit_priorities\n\n        # Epsilon-greedy exploration\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 2,
    "obj": 4.198244914240141,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a refined strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate bin densities\n        bin_densities = 1.0 - (bins_remain_cap[eligible_bins] / np.max(bins_remain_cap))\n\n        # Best-fit: Prioritize bins with smallest remaining capacity after placing the item\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        best_fit_bin_index = np.argmin(remaining_space)\n        best_fit_bin_index = np.where(eligible_bins)[0][best_fit_bin_index]\n        \n        # Prioritize based on density (lower density is better) and best-fit\n        priorities[best_fit_bin_index] = 1.0 / (remaining_space[best_fit_bin_index] + 1e-6) + bin_densities[best_fit_bin_index]\n\n        # Epsilon-greedy exploration: Assign random priorities to other eligible bins\n        if np.random.rand() < epsilon:\n            other_eligible_bins = eligible_bins.copy()\n            other_eligible_bins[best_fit_bin_index] = False\n            other_bin_indices = np.where(other_eligible_bins)[0]\n            if len(other_bin_indices) > 0:\n                random_priorities = np.random.rand(len(other_bin_indices))\n                priorities[other_bin_indices] = random_priorities\n            \n\n    return priorities",
    "response_id": 3,
    "obj": 4.068607897885915,
    "SLOC": 17.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 120.40465370320703,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Greedy: Best fit\n        best_fit_bin_index = np.argmin(bins_remain_cap[eligible_bins] - item)\n        best_fit_bin_index = np.where(eligible_bins)[0][best_fit_bin_index]\n        priorities[best_fit_bin_index] = 1.0\n\n        # Epsilon-greedy exploration\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response5.txt_stdout.txt",
    "code_path": "problem_iter6_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Greedy priority (best fit)\n        best_fit_bin_index = np.argmin(bins_remain_cap[eligible_bins] - item)\n        best_fit_bin_index = np.where(eligible_bins)[0][best_fit_bin_index]\n        priorities[best_fit_bin_index] = 1.0\n\n        # Epsilon-greedy exploration\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response6.txt_stdout.txt",
    "code_path": "problem_iter6_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if np.any(possible_bins):\n        remaining_space = bins_remain_cap[possible_bins] - item\n        priorities[possible_bins] = 1.0 / (remaining_space + 1e-6) + np.random.rand(np.sum(possible_bins)) * 1e-5\n    return priorities",
    "response_id": 6,
    "obj": 4.188272836059035,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response7.txt_stdout.txt",
    "code_path": "problem_iter6_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit score (smaller remaining capacity after placing item is better)\n        fit_score = 1.0 / (bins_remain_cap[eligible_bins] - item + 1e-6)\n        \n        # Normalize fit scores to be between 0 and 1\n        fit_score = (fit_score - np.min(fit_score)) / (np.max(fit_score) - np.min(fit_score))\n\n        # Assign fit score to eligible bins\n        bin_indices = np.where(eligible_bins)[0]\n        priorities[bin_indices] = fit_score\n\n        # Epsilon-greedy exploration\n        if np.random.rand() < epsilon:\n            # Assign a random priority to eligible bins\n            random_indices = np.random.choice(bin_indices, size=len(bin_indices), replace=False)\n            random_priorities = np.random.rand(len(bin_indices))\n            priorities[random_indices] = random_priorities\n\n    return priorities",
    "response_id": 7,
    "obj": 4.078579976067022,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 103.72627427729671,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponential scaling to convert fit scores to priorities.\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Tighter fit -> higher priority\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 8,
    "obj": 4.098524132429212,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response9.txt_stdout.txt",
    "code_path": "problem_iter6_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        # Prioritize tightest fit (smallest remaining capacity after placing item)\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        best_fit_bin_index = np.argmin(fit_scores)\n        best_fit_bin_index = np.where(eligible_bins)[0][best_fit_bin_index]\n        priorities[best_fit_bin_index] = 1.0\n\n        # Epsilon-greedy exploration: assign random priority to other eligible bins\n        if np.random.rand() < epsilon:\n            other_eligible_bins = eligible_bins.copy()\n            other_eligible_bins[best_fit_bin_index] = False  # Exclude best fit\n            if np.any(other_eligible_bins):\n                random_bin_indices = np.where(other_eligible_bins)[0]\n                random_index = np.random.choice(random_bin_indices)\n                priorities[random_index] = np.random.rand()\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 27.0,
    "exec_success": true
  }
]