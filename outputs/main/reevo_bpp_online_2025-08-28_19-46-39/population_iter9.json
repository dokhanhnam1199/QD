[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponential function to convert fit scores to priorities.\n        # Tighter fit -> higher priority. Larger negative fit_score -> higher priority.\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 0,
    "obj": 3.9589150378939015,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Prioritize tightest fit (smallest remaining capacity after placing item)\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        best_fit_bin_index = np.argmin(fit_scores)\n        best_fit_bin_index = np.where(eligible_bins)[0][best_fit_bin_index]\n        priorities[best_fit_bin_index] = 1.0\n\n        # Epsilon-greedy exploration: assign random priority to other eligible bins\n        if np.random.rand() < epsilon:\n            other_eligible_bins = eligible_bins.copy()\n            other_eligible_bins[best_fit_bin_index] = False  # Exclude best fit\n            if np.any(other_eligible_bins):\n                random_bin_indices = np.where(other_eligible_bins)[0]\n                random_index = np.random.choice(random_bin_indices)\n                priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = -fit_scores  # Prioritize tighter fits\n\n        # Epsilon-greedy exploration: with probability epsilon, add a small random value to one eligible bin\n        if np.random.rand() < 0.1:  # Reduced epsilon for more consistent tight packing\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.1  # Add small random value\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = -fit_scores  # Smaller remainder is better\n\n        # Epsilon-greedy exploration\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.uniform(0, 1)  # Add random value\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_utilizations: np.ndarray, epsilon: float = 0.05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit, bin utilization, and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_utilizations: Array of current utilizations for each bin (0 to 1).\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Combine fit score and bin utilization. Prioritize bins that are less utilized.\n        # Lower fit score and lower utilization are better, so we use negative values.\n        priorities[eligible_bins] = -fit_scores - 2 * (1 - bin_utilizations[eligible_bins])  # Weight utilization\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_utilizations'\n11\n3\n81.7492568250068\n"
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Greedy priority (best fit)\n        best_fit_bin_index = np.argmin(bins_remain_cap[eligible_bins] - item)\n        best_fit_bin_index = np.where(eligible_bins)[0][best_fit_bin_index]\n        priorities[best_fit_bin_index] = 1.0\n\n        # Epsilon-greedy exploration\n        if np.random.rand() < 0.1:  # Reduced epsilon for faster convergence\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponential scaling to convert fit scores to priorities.\n        # Tighter fit -> higher priority\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 6,
    "obj": 3.9988033506182825,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponential scaling to convert fit scores to priorities.\n        # A smaller fit score (tighter fit) results in a higher priority.\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 7,
    "obj": 4.01874750698045,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = -fit_scores  # Prioritize tighter fits (smaller difference)\n\n        # Epsilon-greedy exploration: with probability epsilon, add a small random value\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.1  # Add small random value\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a refined strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate bin densities\n        bin_densities = 1.0 - (bins_remain_cap[eligible_bins] / np.max(bins_remain_cap))\n\n        # Best-fit: Prioritize bins with smallest remaining capacity after placing the item\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        best_fit_bin_index = np.argmin(remaining_space)\n        best_fit_bin_index = np.where(eligible_bins)[0][best_fit_bin_index]\n\n        # Prioritize based on density (lower density is better) and best-fit\n        priorities[best_fit_bin_index] = 1.0 / (remaining_space[best_fit_bin_index] + 1e-6) + bin_densities[best_fit_bin_index]\n\n        # Targeted exploration: Assign random priorities to a subset of other eligible bins\n        if np.random.rand() < epsilon:\n            other_eligible_bins = eligible_bins.copy()\n            other_eligible_bins[best_fit_bin_index] = False\n            num_explore = int(np.sum(other_eligible_bins) * 0.2) # Explore 20% of remaining bins\n            other_bin_indices = np.where(other_eligible_bins)[0]\n            if len(other_bin_indices) > 0:\n                explore_indices = np.random.choice(other_bin_indices, size=min(num_explore, len(other_bin_indices)), replace=False)\n                priorities[explore_indices] = np.random.rand(len(explore_indices))\n\n    return priorities",
    "response_id": 9,
    "obj": 3.9888312724371757,
    "SLOC": 18.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 139.31568569324173,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Add small random perturbations for exploration\n        perturbations = np.random.rand(*bins_remain_cap.shape) * epsilon\n        priorities[eligible_bins] += perturbations[eligible_bins]\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 0,
    "obj": 33.7754287993618,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Add small, scaled random perturbations for exploration\n        perturbations = np.random.rand(*priorities.shape) * epsilon\n        priorities += perturbations\n\n        # Epsilon-greedy exploration (alternative to perturbations)\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 1,
    "obj": 35.13163143199042,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponentially scaled remainders for priority.  Tighter fit -> higher priority.\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Add small, scaled random perturbations for exploration.\n        priorities[eligible_bins] += np.random.rand(np.sum(eligible_bins)) * epsilon\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 2,
    "obj": 34.1942560829677,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response3.txt_stdout.txt",
    "code_path": "problem_iter9_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Add small random perturbations for exploration\n        perturbations = np.random.rand(*priorities.shape) * epsilon\n        priorities += perturbations\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 3,
    "obj": 33.99481451934584,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response4.txt_stdout.txt",
    "code_path": "problem_iter9_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponentially scaled remainders for priority.  Smaller remainder -> higher priority.\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Add small, scaled random perturbations for exploration.\n        priorities[eligible_bins] += np.random.rand(*fit_scores.shape) * epsilon\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()  # Assign a random priority\n\n    return priorities",
    "response_id": 4,
    "obj": 34.31392102114082,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  }
]