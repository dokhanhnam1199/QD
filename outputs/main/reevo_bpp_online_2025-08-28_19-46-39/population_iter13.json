[
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponentially scaled remainders for priority. Smaller remainder -> higher priority.\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 0,
    "obj": 4.01874750698045,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Normalize fit scores to avoid large exponential values and improve stability\n        fit_scores = np.abs(fit_scores)  # Use absolute values\n        fit_scores = 1.0 / (fit_scores + 1e-6)  # Add a small constant to avoid division by zero\n\n        # Use exponentially scaled remainders for priority. Smaller remainder -> higher priority.\n        priorities[eligible_bins] = np.exp(fit_scores)\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponentially scaled remainders for priority. Smaller remainder -> higher priority.\n        # Scale factor to ensure reasonable priority differences\n        scale_factor = 10.0\n        priorities[eligible_bins] = np.exp(-scale_factor * fit_scores)\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 2,
    "obj": 4.008775428799367,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.01) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Greedy priority (best fit)\n        best_fit_bin_index = np.argmin(bins_remain_cap[eligible_bins] - item)\n        best_fit_bin_index = np.where(eligible_bins)[0][best_fit_bin_index]\n        priorities[best_fit_bin_index] = 1.0\n\n        # Epsilon-greedy exploration\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponentially scaled remainders for priority. Smaller remainder -> higher priority.\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 4,
    "obj": 3.9589150378939015,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response5.txt_stdout.txt",
    "code_path": "problem_iter12_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.01) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = -fit_scores  # Smaller remainder is better\n\n        # Epsilon-greedy exploration: add a small random perturbation\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.uniform(-epsilon, epsilon)\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 59.207035490257475,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response6.txt_stdout.txt",
    "code_path": "problem_iter12_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponentially scaled remainders for priority. Smaller remainder -> higher priority.\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 6,
    "obj": 3.9190267251695206,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response7.txt_stdout.txt",
    "code_path": "problem_iter12_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponentially scaled remainders for priority. Smaller remainder -> higher priority.\n        priorities[eligible_bins] = np.exp(-fit_scores / item)  # Normalize by item size\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 50.18947501009619,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response8.txt_stdout.txt",
    "code_path": "problem_iter12_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a small random value to eligible bins\n        epsilon = 0.1  # Exploration rate\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.05  # Reduced random boost\n\n    return priorities",
    "response_id": 8,
    "obj": 3.8791384124451627,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response9.txt_stdout.txt",
    "code_path": "problem_iter12_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 9,
    "obj": 3.9988033506182825,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Prioritize tightest fit\n\n        # Epsilon-greedy exploration with decaying epsilon\n        epsilon = 0.1  # Initial exploration rate\n        epsilon = max(0.01, epsilon * 0.99)  # Decay epsilon over time\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.05  # Small random boost\n\n    return priorities",
    "response_id": 0,
    "obj": 3.9389708815317115,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 81.7492568250068,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response1.txt_stdout.txt",
    "code_path": "problem_iter13_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Exploit: tighter fit = higher priority\n\n        # Epsilon-greedy exploration with decaying epsilon\n        epsilon = 0.1  # Initial exploration rate\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.05  # Add small random boost\n\n    return priorities",
    "response_id": 1,
    "obj": 3.9888312724371757,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response2.txt_stdout.txt",
    "code_path": "problem_iter13_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Prioritize tightest fit\n\n        # Epsilon-greedy exploration with decaying epsilon\n        epsilon = 0.1\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.05  # Add small random boost\n\n    return priorities",
    "response_id": 2,
    "obj": 3.9988033506182825,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response3.txt_stdout.txt",
    "code_path": "problem_iter13_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Tightest fit first\n\n        # Epsilon-greedy exploration with decaying epsilon\n        epsilon = 0.1\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.05  # Small random boost\n\n    return priorities",
    "response_id": 3,
    "obj": 3.9589150378939015,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response4.txt_stdout.txt",
    "code_path": "problem_iter13_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Exponential scaling for tightest fit\n\n        # Epsilon-greedy exploration with decaying epsilon\n        epsilon = 0.1\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.05  # Small random boost\n\n    return priorities",
    "response_id": 4,
    "obj": 3.9190267251695206,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.0,
    "exec_success": true
  }
]