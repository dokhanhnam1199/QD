[
  {
    "stdout_filepath": "problem_iter16_response0.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponentially scaled remainders for priority. Smaller remainder -> higher priority.\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 0,
    "obj": 3.9788591942560925,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response1.txt_stdout.txt",
    "code_path": "problem_iter16_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, exploration_rate: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        exploration_rate: Probability of choosing a random bin for exploration.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Exploit: tighter fit = higher priority\n\n        # Epsilon-greedy exploration\n        if np.random.rand() < exploration_rate:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.1  # Add small random boost\n\n    return priorities",
    "response_id": 1,
    "obj": 3.948942959712818,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response2.txt_stdout.txt",
    "code_path": "problem_iter16_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)\n        epsilon = 0.05  # Exploration rate\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n    return priorities",
    "response_id": 2,
    "obj": 4.01874750698045,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response3.txt_stdout.txt",
    "code_path": "problem_iter16_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Exponential scaling for tightest fit\n\n        # Epsilon-greedy exploration with decaying epsilon\n        epsilon = 0.05  # Start with a lower epsilon\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.05  # Adjusted randomness scale\n\n    return priorities",
    "response_id": 3,
    "obj": 3.9688871160749857,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response4.txt_stdout.txt",
    "code_path": "problem_iter16_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Exponential scaling for tightest fit\n\n        # Adaptive exploration with scaled randomness\n        exploration_scale = 0.1  # Adjust as needed\n        randomness = np.random.rand(np.sum(eligible_bins)) * exploration_scale\n        priorities[eligible_bins] += randomness\n\n    return priorities",
    "response_id": 4,
    "obj": 34.59313921021142,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response5.txt_stdout.txt",
    "code_path": "problem_iter16_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Prioritize tightest fit\n\n        # Epsilon-greedy exploration with decaying epsilon\n        epsilon = 0.1  # Initial exploration rate\n        epsilon = max(0.01, epsilon * 0.99)  # Decay epsilon over time\n\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.1  # Small random boost\n\n    return priorities",
    "response_id": 5,
    "obj": 3.9190267251695206,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 81.7492568250068,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response6.txt_stdout.txt",
    "code_path": "problem_iter16_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Epsilon-greedy exploration: with probability epsilon, assign a small random value to eligible bins\n        epsilon = 0.05  # Reduced exploration rate\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.01  # Further reduced random boost\n    return priorities",
    "response_id": 6,
    "obj": 3.9888312724371757,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response7.txt_stdout.txt",
    "code_path": "problem_iter16_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1, adaptive_epsilon: bool = True, current_item_index: int = 0, total_items: int = 100) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n        adaptive_epsilon: Whether to adapt epsilon based on the item index.\n        current_item_index: The index of the current item being packed (for adaptive epsilon).\n        total_items: The total number of items to be packed.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Adaptive epsilon-greedy exploration\n        if adaptive_epsilon:\n            epsilon = max(0.01, 1 - (current_item_index / total_items))  # Reduce epsilon over time\n\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand() * 0.5  # Assign a random priority, but capped at 0.5\n\n    return priorities",
    "response_id": 7,
    "obj": 36.36816912644596,
    "SLOC": 13.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 83.39850002884624,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response8.txt_stdout.txt",
    "code_path": "problem_iter16_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponentially scaled remainders for priority. Smaller remainder -> higher priority.\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] = np.random.rand()\n\n    return priorities",
    "response_id": 8,
    "obj": 3.9688871160749857,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response9.txt_stdout.txt",
    "code_path": "problem_iter16_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1, exploration_strength: float = 1.0) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n        exploration_strength: Strength of the random exploration boost.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponentially scaled remainders for priority. Smaller remainder -> higher priority.\n        priorities[eligible_bins] = np.exp(-fit_scores)\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * exploration_strength\n\n    return priorities",
    "response_id": 9,
    "obj": 3.8990825688073536,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.0,
    "exec_success": true
  }
]