[
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1, exploration_strength: float = 1.0) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Exploration rate for epsilon-greedy approach.\n        exploration_strength: Strength of the random exploration boost.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponentially scaled remainders for priority. Smaller remainder -> higher priority.\n        # Add a small constant to avoid division by zero or extremely large values\n        priorities[eligible_bins] = np.exp(-fit_scores / (np.mean(bins_remain_cap) + 1e-6))\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a random priority to eligible bins\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * exploration_strength * (np.mean(bins_remain_cap) / (item + 1e-6))\n\n    return priorities",
    "response_id": 0,
    "obj": 4.15835660151576,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 148.60339807279118,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Exponential scaling for tightest fit\n\n        # Epsilon-greedy exploration with decaying epsilon\n        epsilon = 0.01\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.05  # Adjusted randomness scale\n    return priorities",
    "response_id": 1,
    "obj": 4.058635819704831,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Prioritize tightest fit\n\n        # Epsilon-greedy exploration with decaying epsilon\n        epsilon = 0.1  # Initial exploration rate\n        epsilon = max(0.01, epsilon * 0.995)  # Decay epsilon over time\n\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.05  # Adjusted randomness scale\n\n    return priorities",
    "response_id": 2,
    "obj": 3.9988033506182825,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 81.7492568250068,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response3.txt_stdout.txt",
    "code_path": "problem_iter20_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Exponential scaling for tightest fit\n\n        # Epsilon-greedy exploration with decaying epsilon\n        epsilon = 0.01  # Start with a low epsilon\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.05  # Adjusted randomness scale\n\n    return priorities",
    "response_id": 3,
    "obj": 4.068607897885915,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Calculate fit scores (remaining capacity - item size). Lower is better (tighter fit).\n        fit_scores = bins_remain_cap[eligible_bins] - item\n\n        # Use exponentially scaled remainders for priority. Smaller remainder -> higher priority.\n        # Add a small constant to avoid division by zero or extremely large values\n        priorities[eligible_bins] = np.exp(-fit_scores / (np.mean(bins_remain_cap[eligible_bins]) + 1e-6))\n\n        # Normalize priorities to avoid issues with scaling\n        priorities[eligible_bins] /= np.max(priorities[eligible_bins]) if np.max(priorities[eligible_bins]) > 0 else 1.0\n\n        # Dynamic exploration strength based on bin fullness\n        fullness = 1 - (np.sum(bins_remain_cap) / len(bins_remain_cap) / np.mean(bins_remain_cap) if np.mean(bins_remain_cap) > 0 else 1.0) #average fullness\n        exploration_strength = fullness * 0.5 + 0.1\n\n        # Epsilon-greedy exploration: with probability proportional to fullness, assign a random priority to eligible bins\n        if np.random.rand() < fullness:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * exploration_strength * (np.mean(bins_remain_cap[eligible_bins]) / item)\n            priorities[random_index] = min(priorities[random_index], 1.0) #clip to avoid extreme values\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 280.1263175996992,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Tightest fit first\n\n        # Scaled Randomness Exploration\n        epsilon = 0.3\n        scale = 1.0\n        random_boost = np.random.rand(len(bins_remain_cap)) * scale * epsilon / (bins_remain_cap + 1e-6)\n        random_boost[~eligible_bins] = 0.0  # Zero boost for ineligible bins\n        priorities += random_boost\n\n    return priorities",
    "response_id": 5,
    "obj": 3.430394894295981,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 109.80793556946902,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Tightest fit first\n\n        # Scaled Randomness Exploration\n        epsilon = 0.3\n        scale = 1.0\n        random_boost = np.random.rand(len(bins_remain_cap)) * scale * epsilon / (bins_remain_cap + 1e-9)\n        random_boost[~eligible_bins] = 0.0  # Zero boost for ineligible bins\n        priorities += random_boost\n\n    return priorities",
    "response_id": 6,
    "obj": 3.5001994415636353,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 109.80793556946902,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response7.txt_stdout.txt",
    "code_path": "problem_iter20_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores / item)  # Normalize by item size\n\n        # Epsilon-greedy exploration with decaying epsilon\n        epsilon = 0.01  # Start with a lower epsilon\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.05  # Adjusted randomness scale\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 83.39850002884624,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Tightest fit first\n\n        # Epsilon-greedy exploration: with probability epsilon, assign a small random value to eligible bins\n        epsilon = 0.2  # Tune exploration rate\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.1  # Control random boost magnitude\n\n    return priorities",
    "response_id": 8,
    "obj": 3.8292780215396984,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Prioritize tightest fit\n\n        # Epsilon-greedy exploration with decaying epsilon\n        epsilon = 0.1\n        epsilon = max(0.01, epsilon * 0.995)\n\n        if np.random.rand() < epsilon:\n            random_bin_indices = np.where(eligible_bins)[0]\n            random_index = np.random.choice(random_bin_indices)\n            priorities[random_index] += np.random.rand() * 0.08  # Adjusted randomness scale\n\n    return priorities",
    "response_id": 9,
    "obj": 3.9090546469884373,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 81.7492568250068,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response0.txt_stdout.txt",
    "code_path": "problem_iter21_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Tightest fit first\n\n        # Scaled Randomness Exploration with dynamic exploration rate\n        epsilon = 0.3\n        scale = 1.0\n        random_boost = np.random.rand(len(bins_remain_cap)) * scale * epsilon / (bins_remain_cap + 1e-6)  # avoid division by zero\n        random_boost[~eligible_bins] = 0.0  # Zero boost for ineligible bins\n        priorities += random_boost\n\n    return priorities",
    "response_id": 0,
    "obj": 3.5301156761069095,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 109.80793556946902,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response1.txt_stdout.txt",
    "code_path": "problem_iter21_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Tightest fit first\n\n        # Dynamically tuned exploration with decaying randomness\n        epsilon = 0.1  # Reduced exploration rate\n        scale = 1.0\n        random_boost = np.random.rand(len(bins_remain_cap)) * scale * epsilon / (bins_remain_cap + 1e-6)  # Avoid division by zero\n        random_boost[~eligible_bins] = 0.0  # Zero boost for ineligible bins\n        priorities += random_boost\n\n    return priorities",
    "response_id": 1,
    "obj": 3.4204228161148738,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 109.80793556946902,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response2.txt_stdout.txt",
    "code_path": "problem_iter21_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Tightest fit first\n\n        # Dynamic Exploration Rate: Adjust based on bin fullness\n        avg_remaining_cap = np.mean(bins_remain_cap[eligible_bins])\n        epsilon = 0.3 * (1.0 - (avg_remaining_cap / np.max(bins_remain_cap)))  # Lower epsilon when bins are fuller\n        scale = 1.0\n        random_boost = np.random.rand(len(bins_remain_cap)) * scale * epsilon\n        random_boost[~eligible_bins] = 0.0  # Zero boost for ineligible bins\n        priorities += random_boost\n\n    return priorities",
    "response_id": 2,
    "obj": 33.19704826485841,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 128.3789500201924,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response3.txt_stdout.txt",
    "code_path": "problem_iter21_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Tightest fit first\n\n    # Dynamic Exploration Rate and Scaled Randomness\n    exploration_rate = 0.1  # Initial exploration rate\n    scale = 1.0\n    random_boost = np.random.rand(len(bins_remain_cap)) * scale * exploration_rate / (bins_remain_cap + 1e-6)  # Add a small value to avoid division by zero\n    random_boost[~eligible_bins] = 0.0  # Zero boost for ineligible bins\n\n    priorities += random_boost\n\n    return priorities",
    "response_id": 3,
    "obj": 3.5001994415636353,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 109.80793556946902,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response4.txt_stdout.txt",
    "code_path": "problem_iter21_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tightest fit and exploration.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fit_scores = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = np.exp(-fit_scores)  # Tightest fit first\n\n        # Scaled Randomness Exploration with dynamic exploration rate\n        epsilon = 0.1  # Reduced exploration rate\n        scale = 1.0\n        random_boost = np.random.rand(len(bins_remain_cap)) * scale * epsilon / (bins_remain_cap + 1e-6)  # Avoid division by zero\n        random_boost[~eligible_bins] = 0.0  # Zero boost for ineligible bins\n        priorities += random_boost\n\n    return priorities",
    "response_id": 4,
    "obj": 3.5301156761069095,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 109.80793556946902,
    "exec_success": true
  }
]