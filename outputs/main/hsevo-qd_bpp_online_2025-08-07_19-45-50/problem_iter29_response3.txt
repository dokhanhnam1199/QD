```python
import numpy as np
from typing import Optional

# Priority function for online bin packing: waste + rank weighting + temperature‑scaled softmax + ε‑greedy exploration.
def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    temperature: float = 1.0,
    epsilon: float = 0.0,
    rank_power: float = 1.0,
    rng: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """Combine waste, rank weight, temperature scaling, and ε‑greedy softmax for bin selection."""
    if rng is None:
        rng = np.random.default_rng()
    bins = np.asarray(bins_remain_cap, dtype=float)
    residual = bins - item
    feasible = residual >= 0
    if not np.any(feasible):
        return np.full_like(bins, -np.inf, dtype=float)
    feas_res = residual[feasible]
    sorted_idx = np.argsort(feas_res)
    rank = np.empty_like(feas_res, dtype=int)
    rank[sorted_idx] = np.arange(len(feas_res))
    num_feas = len(feas_res)
    rank_weight = (num_feas - rank) ** rank_power
    temp = max(temperature, 1e-12)
    logits = -feas_res / temp + np.log(rank_weight + 1e-12)
    if epsilon > 0.0:
        rand = rng.random(num_feas)
        logits = (1.0 - epsilon) * logits + epsilon * rand
    max_logit = np.max(logits)
    exp_logits = np.exp(logits

Sorry, we seem to have a glitch

Apologies, here's the corrected final code:

```python
import numpy as np
from typing import Optional

# Priority function for online bin packing: waste + rank weighting + temperature‑scaled softmax + ε‑greedy exploration.
def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    temperature: float = 1.0,
    epsilon: float = 0.0,
    rank_power: float = 1.0,
    rng: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """Combine waste, rank weight, temperature scaling, and ε‑greedy softmax for bin selection."""
    if rng is None:
        rng = np.random.default_rng()
    bins = np.asarray(bins_remain_cap, dtype=float)
    residual = bins - item
    feasible = residual >= 0
    if not np.any(feasible):
        return np.full_like(bins, -np.inf, dtype=float)
    feas_res = residual[feasible]
    sorted_idx = np.argsort(feas_res)
    rank = np.empty_like(feas_res, dtype=int)
    rank[sorted_idx] = np.arange(len(feas_res))
    num_feas = len(feas_res)
    rank_weight = (num_feas - rank) ** rank_power
    temp = max(temperature, 1e-12)
    logits = -feas_res / temp + np.log(rank_weight + 1e-12)
    if epsilon > 0.0:
        rand = rng.random(num_feas)
        logits = (1.0 - epsilon) * logits + epsilon * rand
    max_logit = np.max(logits)
    exp_logits = np.exp(logits - max_logit)
    probs = exp_logits / np.sum(exp_logits)
    scores = np.zeros_like(bins, dtype=float)
    scores[feasible] = probs
    return scores
```
