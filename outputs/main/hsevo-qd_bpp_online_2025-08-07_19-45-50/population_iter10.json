[
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    left = bins_remain_cap - item\n    priorities = np.where(left >= 0, -left, -np.inf)\n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    priorities[feasible] = -residual[feasible]\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    caps = bins_remain_cap.astype(float)\n    space_left = caps - item\n    valid = space_left >= 0\n    priorities = np.full_like(space_left, -1e9, dtype=float)\n    if np.any(valid):\n        ratio = space_left[valid] / caps[valid]\n        k = 12.0\n        priorities[valid] = 1.0 / (1.0 + np.exp(-k * (1.0 - ratio)))\n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    exact_mask = bins_remain_cap == item\n    valid_mask = bins_remain_cap >= item\n    priorities[exact_mask] = 1e12\n    valid_not_exact = valid_mask & ~exact_mask\n    slack = bins_remain_cap[valid_not_exact] - item\n    priorities[valid_not_exact] = -slack\n    return priorities",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Softmax-Based Fit priority: tighter fits receive higher scores.\"\"\"\n    \\\n    residual = bins_remain_cap - item\n    mask = residual >= 0\n    if not np.any(mask):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    scores = -residual\n    scores[~mask] = -np.inf\n    max_score = scores[mask].max()\n    exp_scores = np.exp(scores - max_score)\n    exp_scores[~mask] = 0.0\n    total = exp_scores.sum()\n    if total == 0:\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    return exp_scores / total",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    return np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.01) -> np.ndarray:\n    \"\"\"Exact-fit-first priority with optional epsilon-greedy exploration.\"\"\"\n    # Feasibility mask and deterministic priority (negative waste)\n    feasible = bins_remain_cap >= item\n    deterministic = np.where(feasible, -(bins_remain_cap - item), -np.inf)\n    # With probability epsilon, use random scores for feasible bins\n    if np.random.rand() < epsilon:\n        random_scores = np.random.rand(bins := bins_remain_cap.shape[0])\n        return np.where(feasible, random_scores, -np.inf)\n    return deterministic",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.098524132429212,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns softmax-based priority for placing an item into each bin.\"\"\"\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    caps = bins_remain_cap.astype(float)\n    residual = caps - item\n    raw_scores = np.where(feasible, -residual, -np.inf)\n    max_score = raw_scores.max()\n    exp_scores = np.exp(raw_scores - max_score)\n    sum_exp = exp_scores.sum()\n    priorities = exp_scores / sum_exp if sum_exp > 0 else np.zeros_like(exp_scores)\n    return priorities",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if np.any(feasible):\n        slack = bins_remain_cap[feasible] - item\n        scores[feasible] = -slack\n        tau = 0.5\n        scaled = scores / tau\n        max_score = np.max(scaled[feasible])\n        exp_vals = np.exp(scaled - max_score)\n        priorities = exp_vals / exp_vals.sum()\n    else:\n        priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    return priorities",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0, rng: np.random.Generator | None = None) -> np.ndarray:\n    feasible = bins_remain_cap >= item\n    if epsilon > 0.0 and rng is not None and rng.random() < epsilon:\n        random_scores = rng.random(bins_remain_cap.shape[0])\n        return np.where(feasible, random_scores, -np.inf)\n    return np.where(feasible, -(bins_remain_cap - item), -np.inf)",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\nfrom typing import Optional\n\n# Priority function combining deterministic waste and optional epsilon\u2011greedy exploration\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0,\n                random_state: Optional[int] = None) -> np.ndarray:\n    \"\"\"Priority = -waste for feasible bins; optional epsilon\u2011greedy random scores.\"\"\"\n    feasible = bins_remain_cap >= item\n    if epsilon > 0.0:\n        rng = np.random.default_rng(random_state)\n        if rng.random() < epsilon:\n            rand_scores = rng.random(bins_remain_cap.shape[0])\n            return np.where(feasible, rand_scores, -np.inf)\n    waste = bins_remain_cap - item\n    return np.where(feasible, -waste, -np.inf)",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0, temperature: float = 1.0) -> np.ndarray:\n    \"\"\"Epsilon\u2011greedy softmax: random scores with prob \u03b5, else residual\u2011based softmax.\"\"\"\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if np.random.rand() < epsilon:\n        rand_scores = np.random.rand(bins_remain_cap.shape[0])\n        raw = np.where(feasible, rand_scores, -np.inf)\n    else:\n        residual = bins_remain_cap.astype(float) - item\n        raw = np.where(feasible, -residual / max(temperature, 1e-12), -np.inf)\n    max_raw = np.max(raw)\n    exp_raw = np.exp(raw - max_raw)\n    sum_exp = exp_raw.sum()\n    return exp_raw / sum_exp if sum_exp > 0 else np.zeros_like(exp_raw)",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0, seed: int | None = None) -> np.ndarray:\n    \"\"\"Prioritize bins: -waste for feasible bins, -inf otherwise; with \u03b5 chance assign random scores.\"\"\"\n    # Vectorized feasibility mask\n    feasible = bins_remain_cap >= item\n    rng = np.random.default_rng(seed)\n    # \u03b5\u2011greedy: random scores for feasible bins with probability \u03b5\n    if epsilon > 0.0 and rng.random() < epsilon:\n        random_scores = rng.random(bins_remain_cap.shape)\n        return np.where(feasible, random_scores, -np.inf)\n    # Deterministic waste\u2011minimizing priority\n    waste = bins_remain_cap - item\n    return np.where(feasible, -waste, -np.inf)",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                epsilon: float = 0.0,\n                tau: float = 1.0,\n                rng: Optional[np.random.Generator] = None) -> np.ndarray:\n    \"\"\"\n    Softmax priority with temperature scaling and optional epsilon-greedy exploration; returns a probability distribution over bins that favors low waste, with random exploration when epsilon>0.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if rng.random() < epsilon:\n        rand_vals = rng.random(bins_remain_cap.size)\n        priorities = np.where(feasible, rand_vals, 0.0)\n        total = priorities.sum()\n        if total > 0:\n            priorities /= total\n        return priorities\n    residual = bins_remain_cap.astype(float) - item\n    raw_scores = np.where(feasible, -residual / tau, -np.inf)\n    max_score = raw_scores.max()\n    exp_scores = np.exp(raw_scores - max_score)\n    sum_exp = exp_scores.sum()\n    return exp_scores / sum_exp if sum_exp > 0 else np.zeros_like(exp_scores)",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    # Softmax with temperature and optional epsilon\u2011greedy exploration for online BPP.\n    tau: float = 0.5,\n    epsilon: float = 0.0,\n    rng: np.random.Generator = None,\n) -> np.ndarray:\n    \"\"\"Softmax with temperature and optional epsilon\u2011greedy exploration for online BPP.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    scores = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return scores\n    if epsilon > 0.0 and rng.random() < epsilon:\n        rand_vals = rng.random(feasible.sum())\n        probs = rand_vals / rand_vals.sum()\n        scores[feasible] = probs\n    else:\n        slack = bins_remain_cap[feasible] - item\n        raw = -slack / tau\n        max_raw = np.max(raw)\n        exp_vals = np.exp(raw - max_raw)\n        probs = exp_vals / exp_vals.sum()\n        scores[feasible] = probs\n    return scores",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, tau: float = 1.0,\n                epsilon: float = 0.0, rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Softmax fit (temp\u202ftau) with epsilon\u2011greedy random exploration.\"\"\"\n    # Combine stable softmax scoring of waste with occasional random scoring.\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    mask = residual >= 0\n    if not np.any(mask):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if epsilon > 0 and rng.random() < epsilon:\n        rand_scores = rng.random(bins_remain_cap.shape[0])\n        rand_scores[~mask] = -np.inf\n        max_rand = rand_scores[mask].max()\n        exp_rand = np.exp(rand_scores - max_rand)\n        exp_rand[~mask] = 0.0\n        total_rand = exp_rand.sum()\n        return exp_rand / total_rand if total_rand > 0 else np.zeros_like(bins_remain_cap, dtype=float)",
    "response_id": 2,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 16.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 1.0,\n                epsilon: float = 0.0, rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"\n    Softmax fit with temperature and optional epsilon\u2011greedy randomization.\n    Tighter fits get higher probability; random selection occurs with probability epsilon.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if epsilon > 0 and rng.random() < epsilon:\n        rand_vals = rng.random(bins_remain_cap.shape[0])\n        scores = np.where(feasible, rand_vals, 0.0)\n        total = scores.sum()\n        if total == 0:\n            return np.zeros_like(bins_remain_cap, dtype=float)\n        return scores / total\n    raw = -residual\n    raw[~feasible] = -np.inf\n    scaled = raw / max(temperature, 1e-12)\n    max_score = scaled[feasible].max()\n    exp_scores = np.exp(scaled - max_score)\n    exp_scores[~feasible] = 0.0\n    total = exp_scores.sum()\n    if total == 0:\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    return exp_scores / total",
    "response_id": 3,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 25.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tau: float = 1.0,\n    epsilon: float = 0.0,\n    rng: np.random.Generator = None,\n) -> np.ndarray:\n    \"\"\"Priority via temperature\u2011scaled softmax of negative waste mixed with epsilon\u2011greedy random scores; infeasible bins get -inf.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    # Deterministic score: negative waste (higher is better)\n    det_score = np.where(feasible, -(bins_remain_cap - item), -np.inf)\n    # Stable softmax with temperature\n    max_score = np.max(det_score[feasible])\n    shifted = (det_score - max_score) / max(tau, 1e-12)\n    exp_shifted = np.exp(shifted) * feasible\n    sum_exp = exp_shifted.sum_exp if hasattr(exp_shifted, \"sum_exp\") else exp_shifted.sum()\n    if sum_exp > 0:\n        softmax = exp_shifted / sum_exp\n    else:\n        # Fallback: uniform among max\u2011score bins\n        max_mask = (det_score == max_score) & feasible\n        count_max = max_mask.sum()\n        softmax = np.where(max_mask, 1.0 / count_max, 0.0)\n    # Random uniform distribution over feasible bins\n    rand_vals = rng.random(bins_remain_cap.shape) * feasible\n    sum_rand = rand_vals.sum()\n    if sum_rand > 0:\n        rand_dist = rand_vals / sum_rand\n    else:\n        rand_dist = np.zeros_like(bins_remain_cap, dtype=float)\n    # Mix deterministic and random scores\n    combined = (1.0 - epsilon) * softmax + epsilon * rand_dist\n    return np.where(feasible, combined, -np.inf)",
    "response_id": 4,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 31.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                tau: float = 1.0,\n                epsilon: float = 0.0,\n                rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Softmax priority with temperature and optional epsilon\u2011greedy exploration.\"\"\"\n    # feasible bins: enough remaining capacity for the item\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if rng is None:\n        rng = np.random.default_rng()\n    # epsilon\u2011greedy: uniform random scores over feasible bins\n    if rng.random() < epsilon:\n        rand = rng.random(bins_remain_cap.shape[0])\n        rand[~feasible] = 0.0\n        s = rand.sum()\n        return rand / s if s > 0 else np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    # temperature\u2011scaled softmax on negative waste (higher score \u2192 less waste)\n    scores = np.where(feasible, -(bins_remain_cap - item) / tau, -np.inf)\n    max_score = np.max(scores[feasible])\n    exp_scores = np.exp(scores - max_score)          # infeasible become 0\n    total = exp_scores.sum()\n    return exp_scores / total if total > 0 else np.full_like(bins_remain_cap, -np.inf, dtype=float)",
    "response_id": 5,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1, tau: float = 1.0, rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Temperature-scaled softmax with optional epsilon-greedy exploration; returns normalized priorities for feasible bins.\"\"\"\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if rng is None:\n        rng = np.random.default_rng()\n    if rng.random() < epsilon:\n        probs = np.zeros_like(bins_remain_cap, dtype=float)\n        probs[feasible] = 1.0 / np.count_nonzero(feasible)\n        return probs\n    residual = bins_remain_cap.astype(float) - item\n    raw_scores = -residual / tau\n    raw_scores[~feasible] = -np.inf\n    max_score = np.max(raw_scores)\n    exp_scores = np.exp(raw_scores - max_score)\n    sum_exp = np.sum(exp_scores)\n    return exp_scores / sum_exp if sum_exp > 0 else np.zeros_like(exp_scores)",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 17.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, tau: float = 1.0, epsilon: float = 0.0) -> np.ndarray:\n    \"\"\"Softmax of negative slack with temperature and optional epsilon\u2011greedy exploration.\"\"\"\n    feasible = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if np.any(feasible):\n        slack = bins_remain_cap[feasible] - item\n        idx = np.nonzero(feasible)[0]\n        priorities[idx] = -slack\n        exact_idx = idx[slack == 0]\n        priorities[exact_idx] = 1e12\n        if tau > 0:\n            priorities[idx] = priorities[idx] / tau\n        if epsilon > 0 and np.random.rand() < epsilon:\n            priorities[idx] = np.random.rand(len(idx))\n        else:\n            max_val = np.max(priorities[idx])\n            exp_vals = np.exp(priorities[idx] - max_val)\n            probs = exp_vals / np.sum(exp_vals)\n            priorities[idx] = probs\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, tau: float = 0.1, epsilon: float = 0.05, rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Return a probability distribution over bins for an incoming item.\n\n    The distribution favors bins with minimal residual capacity after placement,\n    includes optional epsilon\u2011exploration, and adds Gumbel noise for stochasticity.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the bins.\n    tau : float, optional\n        Temperature controlling the softness of the softmax (default 0.1).\n    epsilon : float, optional\n        Exploration weight for a uniform distribution over feasible bins (default 0.05).\n    rng : np.random.Generator, optional\n        Random generator for stochastic components; created if None.\n\n    Returns\n    -------\n    np.ndarray\n        Probability vector of the same shape as ``bins_remain_cap``; infeasible bins have zero probability.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    logits = -residual / tau\n    logits[~feasible] = -np.inf\n    gumbel = -np.log(-np.log(rng.random(logits.shape) + 1e-12) + 1e-12)\n    logits_noisy = logits + gumbel\n    logits_noisy[~feasible] = -np.inf\n    max_logit = np.max(logits_noisy)\n    exp_shifted = np.exp(logits_noisy - max_logit)\n    sum_exp = np.sum(exp_shifted)\n    softmax = exp_shifted / sum_exp if sum_exp > 0 else np.zeros_like(bins_remain_cap, dtype=float)\n    uniform = np.zeros_like(bins_remain_cap, dtype=float)\n    uniform[feasible] = 1.0 / feasible.sum()\n    return (1 - epsilon) * softmax + epsilon * uniform",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\n# Stable softmax priority with optional \u03b5\u2011greedy exploration for online bin packing.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                tau: float = 0.5, epsilon: float = 0.0,\n                rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Return probability scores for each bin based on remaining capacity, using a temperature\u2011scaled softmax; optionally explore randomly via \u03b5\u2011greedy.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    scores = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return scores\n    if epsilon > 0.0 and rng.random() < epsilon:\n        rand = rng.random(feasible.sum())\n        probs = rand / rand.sum()\n        scores[feasible] = probs\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    raw = -slack / tau\n    max_raw = raw.max()\n    exp_vals = np.exp(raw - max_raw)\n    probs = exp_vals / exp_vals.sum()\n    scores[feasible] = probs\n    return scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0,\n                random_state: Optional[int] = None) -> np.ndarray:\n    \"\"\"Compute bin priority using negative waste and optional \u03b5\u2011greedy random scores; returns a probability vector.\"\"\"\n    # Combine deterministic waste minimization with \u03b5\u2011greedy exploration.\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    rng = np.random.default_rng(random_state)\n    if epsilon > 0.0 and rng.random() < epsilon:\n        scores = np.where(feasible, rng.random(bins_remain_cap.shape[0]), -np.inf)\n    else:\n        waste = bins_remain_cap - item\n        scores = np.where(feasible, -waste, -np.inf)\n    max_score = np.max(scores[feasible])\n    exp_scores = np.exp(scores - max_score)\n    exp_scores[~feasible] = 0.0\n    prob = exp_scores / np.sum(exp_scores)\n    return prob",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                tau: float = 0.5,\n                epsilon: float = 0.0,\n                rng: np.random.Generator | None = None,\n                logistic_k: float = 12.0,\n                logistic_lambda: float = 1.0) -> np.ndarray:\n    \"\"\"\n    Softmax over negative waste plus logistic fill ratio, with optional epsilon exploration.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n\n    if rng is None:\n        rng = np.random.default_rng()\n    if rng.random() < epsilon:\n        probs = np.zeros_like(bins_remain_cap, dtype=float)\n        probs[feasible] = 1.0 / np.count_nonzero(feasible)\n        return probs\n\n    caps = bins_remain_cap.astype(float)\n    residual = caps - item\n    raw_scores = -residual / tau\n\n    ratio = residual / caps\n    logistic_factor = 1.0 / (1.0 + np.exp(-logistic_k * (1.0 - ratio)))\n    raw_scores += logistic_lambda * logistic_factor\n\n    raw_scores[~feasible] = -np.inf\n\n    max_score = np.max(raw_scores)\n    exp_scores = np.exp(raw_scores - max_score)\n    sum_exp = np.sum(exp_scores)\n    return exp_scores / sum_exp if sum_exp > 0 else np.zeros_like(exp_scores)",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 27.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\n# Combine exact\u2011fit boost with epsilon\u2011greedy softmax for online BPP.\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    epsilon: float = 0.0,\n    temperature: float = 1.0,\n    rng: np.random.Generator = None,\n) -> np.ndarray:\n    \"\"\"Priority for online BPP: stable softmax over negative waste, boost exact fits, optional epsilon\u2011greedy exploration.\"\"\"\n    if rng:  # ensure rng is a Generator\n        pass\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if epsilon > 0 and rng.random() < epsilon:\n        rand = rng.random(bins_remain_cap.shape[0])\n        scores = np.where(feasible, rand, 0.0)\n        total = scores.sum()\n        return scores / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float)\n    boost = 1e3\n    raw = -residual + boost * (residual == 0)\n    raw[~feasible] = -np.inf\n    scaled = raw / max(temperature, 1e-12)\n    max_score = scaled[feasible].max()\n    exp_scores = np.exp(scaled - max_score)\n    exp_scores[~feasible] = 0.0\n    total = exp_scores.sum()\n    return exp_scores / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float)",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 30.0,
    "cyclomatic_complexity": 8.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\n# Priority function combining stable softmax and epsilon\u2011greedy exploration.\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                temperature: float = 1.0,\n                epsilon: float = 0.0,\n                rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Compute bin selection probabilities via temperature\u2011scaled softmax on negative waste, with optional epsilon\u2011greedy random exploration.\"\"\"\n    if rng is None:\n        rng = 0  # placeholder, will be overridden\n    # Initialize RNG lazily to avoid default_rng call overhead when not needed\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if epsilon > 0 and rng.random() < epsilon:\n        rand_vals = rng.random(bins_remain_cap.shape)\n        scores = np.where(feasible, rand_vals, 0.0)\n        total = scores.sum()\n        return scores / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float)\n    raw = -residual\n    raw[~feasible] = -np.inf\n    temp = max(temperature, 1e-12)\n    scaled = raw / temp\n    max_score = scaled[feasible].max()\n    exp_scores = np.exp(scaled - max_score)\n    exp_scores[~feasible] = 0.0\n    total = exp_scores.sum()\n    return exp_scores / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float)",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 27.0,
    "cyclomatic_complexity": 8.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\n_EPSILON = 0.05\n_TEMPERATURE = 0.1\n_RNG = np.random.default_rng()\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Softmax priority with epsilon\u2011greedy exploration, stable and masked.\"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap)\n    if _RNG.random() < _EPSILON:\n        probs = np.zeros_like(bins_remain_cap)\n        probs[feasible] = 1.0 / feasible.sum()\n        return probs\n    residual = bins_remain_cap[feasible] - item\n    temperature = max(_TEMPERATURE, 1e-12)\n    logits = -residual / temperature\n    max_logit = np.max(logits)\n    exp_shifted = np.exp(logits - max_logit)\n    softmax = exp_shifted / np.sum(exp_shifted)\n    scores = np.zeros_like(bins_remain_cap)\n    scores[feasible] = softmax\n    return scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.11846828879138,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]