[
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    left = bins_remain_cap - item\n    priorities = np.where(left >= 0, -left, -np.inf)\n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    priorities[feasible] = -residual[feasible]\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    caps = bins_remain_cap.astype(float)\n    space_left = caps - item\n    valid = space_left >= 0\n    priorities = np.full_like(space_left, -1e9, dtype=float)\n    if np.any(valid):\n        ratio = space_left[valid] / caps[valid]\n        k = 12.0\n        priorities[valid] = 1.0 / (1.0 + np.exp(-k * (1.0 - ratio)))\n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    exact_mask = bins_remain_cap == item\n    valid_mask = bins_remain_cap >= item\n    priorities[exact_mask] = 1e12\n    valid_not_exact = valid_mask & ~exact_mask\n    slack = bins_remain_cap[valid_not_exact] - item\n    priorities[valid_not_exact] = -slack\n    return priorities",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Softmax-Based Fit priority: tighter fits receive higher scores.\"\"\"\n    \\\n    residual = bins_remain_cap - item\n    mask = residual >= 0\n    if not np.any(mask):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    scores = -residual\n    scores[~mask] = -np.inf\n    max_score = scores[mask].max()\n    exp_scores = np.exp(scores - max_score)\n    exp_scores[~mask] = 0.0\n    total = exp_scores.sum()\n    if total == 0:\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    return exp_scores / total",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    return np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.01) -> np.ndarray:\n    \"\"\"Exact-fit-first priority with optional epsilon-greedy exploration.\"\"\"\n    # Feasibility mask and deterministic priority (negative waste)\n    feasible = bins_remain_cap >= item\n    deterministic = np.where(feasible, -(bins_remain_cap - item), -np.inf)\n    # With probability epsilon, use random scores for feasible bins\n    if np.random.rand() < epsilon:\n        random_scores = np.random.rand(bins := bins_remain_cap.shape[0])\n        return np.where(feasible, random_scores, -np.inf)\n    return deterministic",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.098524132429212,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns softmax-based priority for placing an item into each bin.\"\"\"\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    caps = bins_remain_cap.astype(float)\n    residual = caps - item\n    raw_scores = np.where(feasible, -residual, -np.inf)\n    max_score = raw_scores.max()\n    exp_scores = np.exp(raw_scores - max_score)\n    sum_exp = exp_scores.sum()\n    priorities = exp_scores / sum_exp if sum_exp > 0 else np.zeros_like(exp_scores)\n    return priorities",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if np.any(feasible):\n        slack = bins_remain_cap[feasible] - item\n        scores[feasible] = -slack\n        tau = 0.5\n        scaled = scores / tau\n        max_score = np.max(scaled[feasible])\n        exp_vals = np.exp(scaled - max_score)\n        priorities = exp_vals / exp_vals.sum()\n    else:\n        priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    return priorities",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0, rng: np.random.Generator | None = None) -> np.ndarray:\n    feasible = bins_remain_cap >= item\n    if epsilon > 0.0 and rng is not None and rng.random() < epsilon:\n        random_scores = rng.random(bins_remain_cap.shape[0])\n        return np.where(feasible, random_scores, -np.inf)\n    return np.where(feasible, -(bins_remain_cap - item), -np.inf)",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\nfrom typing import Optional\n\n# Priority function combining deterministic waste and optional epsilon\u2011greedy exploration\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0,\n                random_state: Optional[int] = None) -> np.ndarray:\n    \"\"\"Priority = -waste for feasible bins; optional epsilon\u2011greedy random scores.\"\"\"\n    feasible = bins_remain_cap >= item\n    if epsilon > 0.0:\n        rng = np.random.default_rng(random_state)\n        if rng.random() < epsilon:\n            rand_scores = rng.random(bins_remain_cap.shape[0])\n            return np.where(feasible, rand_scores, -np.inf)\n    waste = bins_remain_cap - item\n    return np.where(feasible, -waste, -np.inf)",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0, temperature: float = 1.0) -> np.ndarray:\n    \"\"\"Epsilon\u2011greedy softmax: random scores with prob \u03b5, else residual\u2011based softmax.\"\"\"\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if np.random.rand() < epsilon:\n        rand_scores = np.random.rand(bins_remain_cap.shape[0])\n        raw = np.where(feasible, rand_scores, -np.inf)\n    else:\n        residual = bins_remain_cap.astype(float) - item\n        raw = np.where(feasible, -residual / max(temperature, 1e-12), -np.inf)\n    max_raw = np.max(raw)\n    exp_raw = np.exp(raw - max_raw)\n    sum_exp = exp_raw.sum()\n    return exp_raw / sum_exp if sum_exp > 0 else np.zeros_like(exp_raw)",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0, seed: int | None = None) -> np.ndarray:\n    \"\"\"Prioritize bins: -waste for feasible bins, -inf otherwise; with \u03b5 chance assign random scores.\"\"\"\n    # Vectorized feasibility mask\n    feasible = bins_remain_cap >= item\n    rng = np.random.default_rng(seed)\n    # \u03b5\u2011greedy: random scores for feasible bins with probability \u03b5\n    if epsilon > 0.0 and rng.random() < epsilon:\n        random_scores = rng.random(bins_remain_cap.shape)\n        return np.where(feasible, random_scores, -np.inf)\n    # Deterministic waste\u2011minimizing priority\n    waste = bins_remain_cap - item\n    return np.where(feasible, -waste, -np.inf)",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]