[
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    left = bins_remain_cap - item\n    priorities = np.where(left >= 0, -left, -np.inf)\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    priorities[feasible] = -residual[feasible]\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    caps = bins_remain_cap.astype(float)\n    space_left = caps - item\n    valid = space_left >= 0\n    priorities = np.full_like(space_left, -1e9, dtype=float)\n    if np.any(valid):\n        ratio = space_left[valid] / caps[valid]\n        k = 12.0\n        priorities[valid] = 1.0 / (1.0 + np.exp(-k * (1.0 - ratio)))\n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    exact_mask = bins_remain_cap == item\n    valid_mask = bins_remain_cap >= item\n    priorities[exact_mask] = 1e12\n    valid_not_exact = valid_mask & ~exact_mask\n    slack = bins_remain_cap[valid_not_exact] - item\n    priorities[valid_not_exact] = -slack\n    return priorities",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Softmax-Based Fit priority: tighter fits receive higher scores.\"\"\"\n    \\\n    residual = bins_remain_cap - item\n    mask = residual >= 0\n    if not np.any(mask):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    scores = -residual\n    scores[~mask] = -np.inf\n    max_score = scores[mask].max()\n    exp_scores = np.exp(scores - max_score)\n    exp_scores[~mask] = 0.0\n    total = exp_scores.sum()\n    if total == 0:\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    return exp_scores / total",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    return np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    feasible = bins_remain_cap >= item\n    if np.random.rand() < epsilon:\n        random_scores = np.random.rand(bins_remain_cap.shape[0])\n        return np.where(feasible, random_scores, -np.inf)\n    waste = bins_remain_cap - item\n    return np.where(feasible, -waste, -np.inf)",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.15835660151576,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns softmax-based priority for placing an item into each bin.\"\"\"\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    caps = bins_remain_cap.astype(float)\n    residual = caps - item\n    raw_scores = np.where(feasible, -residual, -np.inf)\n    max_score = raw_scores.max()\n    exp_scores = np.exp(raw_scores - max_score)\n    sum_exp = exp_scores.sum()\n    priorities = exp_scores / sum_exp if sum_exp > 0 else np.zeros_like(exp_scores)\n    return priorities",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if np.any(feasible):\n        slack = bins_remain_cap[feasible] - item\n        scores[feasible] = -slack\n        tau = 0.5\n        scaled = scores / tau\n        max_score = np.max(scaled[feasible])\n        exp_vals = np.exp(scaled - max_score)\n        priorities = exp_vals / exp_vals.sum()\n    else:\n        priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    return priorities",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]