{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n                bins_remain_cap: np.ndarray,\n                epsilon: float = 0.0,\n                tau: float = 1.0,\n                rng: Optional[np.random.Generator] = None) -> np.ndarray:\n    \"\"\"\n    Softmax priority with temperature scaling and optional epsilon-greedy exploration; returns a probability distribution over bins that favors low waste, with random exploration when epsilon>0.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if rng.random() < epsilon:\n        rand_vals = rng.random(bins_remain_cap.size)\n        priorities = np.where(feasible, rand_vals, 0.0)\n        total = priorities.sum()\n        if total > 0:\n            priorities /= total\n        return priorities\n    residual = bins_remain_cap.astype(float) - item\n    raw_scores = np.where(feasible, -residual / tau, -np.inf)\n    max_score = raw_scores.max()\n    exp_scores = np.exp(raw_scores - max_score)\n    sum_exp = exp_scores.sum()\n    return exp_scores / sum_exp if sum_exp > 0 else np.zeros_like(exp_scores)\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n_GLOBAL_RNG = np.random.default_rng(123456)  # reproducible RNG\n\n_DEFAULT_TEMPERATURE = 0.1\n_DEFAULT_EPSILON = 0.05  # small exploration probability\n\n    \"\"\"\n    Compute a numerically stable priority distribution over bins for an incoming item.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` containing non\u2011negative\n        priorities that sum to one over feasible bins. Infeasible bins receive zero.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if _DEFAULT_EPSILON > 0.0 and _GLOBAL_RNG.random() < _DEFAULT_EPSILON:\n        probs = np.zeros_like(bins_remain_cap, dtype=float)\n        probs[feasible] = 1.0 / feasible.sum()\n        return probs\n    residual = bins_remain_cap[feasible] - item\n    temperature = max(_DEFAULT_TEMPERATURE, 1e-12)\n    logits = -residual / temperature\n    max_logit = np.max(logits)\n    exp_shifted = np.exp(logits - max_logit)\n    softmax = exp_shifted / np.sum(exp_shifted)\n    probs = np.zeros_like(bins_remain_cap, dtype=float)\n    probs[feasible] = softmax\n    return probs\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that heuristic\u202f1 provides a complete, numerically\u2011stable softmax with epsilon\u2011greedy exploration and explicit handling of infeasible bins, while heuristic\u202f20 is incomplete \u2013 it only defines a random branch, lacks a deterministic return, misuses `-inf`, and can return `None`.  \nComparing (second best) vs (second worst), we see heuristic\u202f2 implements a robust softmax over feasible bins and correctly returns zeros for infeasibility, whereas heuristic\u202f19 suffers the same omission as 20: no deterministic branch and a missing return, making it non\u2011functional.  \nComparing (1st) vs (2nd), both use softmax of negative waste; heuristic\u202f1 includes a default `\u03b5=0.1` and computes scores for all bins with `-inf` for infeasible ones, while heuristic\u202f2 isolates the feasible subset, defaults `\u03b5=0.\u202f0` and uses a sharper `\u03c4=0.5`, yielding a leaner implementation but fewer features.  \nComparing (3rd) vs (4th), heuristic\u202f3 simply returns linear negative waste (no normalization), whereas heuristic\u202f4 applies a sigmoid to the fill\u2011ratio (`k=12`), providing a non\u2011linear ranking but still no probability distribution; both ignore exploration and temperature.  \nComparing (second worst) vs (worst), heuristics\u202f19 and\u202f20 are identical copies with the same bug: they only handle the \u03b5\u2011branch and omit a return for the normal softmax case, so they are equally broken.  \nOverall, the top heuristics prioritize numerical stability, clear infeasibility handling, optional exploration, and return a proper probability distribution; mid\u2011tier heuristics vary in sophistication but often lack normalization; the bottom heuristics contain critical logical gaps and are unusable.\n- \n- **Keywords**: softmax, numerical stability, infeasibility masking, \u03b5\u2011exploration, defined distribution, concise code, documentation  \n- **Advice**: Use a stable softmax, explicitly mask infeasible options, add optional \u03b5\u2011exploration, always return a full probability vector, keep code concise, avoid duplicate logic, and document default parameters.  \n- **Avoid**: deterministic behavior, excessive brevity, full vectorization, needless softmax or stochasticity unless explicitly required.  \n- **Explanation**: Non\u2011determinism preserves exploration; controlled stochasticity improves robustness, while a stable softmax guarantees numerical safety and a usable probability vector.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}