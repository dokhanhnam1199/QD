[
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    left = bins_remain_cap - item\n    priorities = np.where(left >= 0, -left, -np.inf)\n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    residual = bins_remain_cap - item\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    priorities[feasible] = -residual[feasible]\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    caps = bins_remain_cap.astype(float)\n    space_left = caps - item\n    valid = space_left >= 0\n    priorities = np.full_like(space_left, -1e9, dtype=float)\n    if np.any(valid):\n        ratio = space_left[valid] / caps[valid]\n        k = 12.0\n        priorities[valid] = 1.0 / (1.0 + np.exp(-k * (1.0 - ratio)))\n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    exact_mask = bins_remain_cap == item\n    valid_mask = bins_remain_cap >= item\n    priorities[exact_mask] = 1e12\n    valid_not_exact = valid_mask & ~exact_mask\n    slack = bins_remain_cap[valid_not_exact] - item\n    priorities[valid_not_exact] = -slack\n    return priorities",
    "response_id": 14,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Softmax-Based Fit priority: tighter fits receive higher scores.\"\"\"\n    \\\n    residual = bins_remain_cap - item\n    mask = residual >= 0\n    if not np.any(mask):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    scores = -residual\n    scores[~mask] = -np.inf\n    max_score = scores[mask].max()\n    exp_scores = np.exp(scores - max_score)\n    exp_scores[~mask] = 0.0\n    total = exp_scores.sum()\n    if total == 0:\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    return exp_scores / total",
    "response_id": 9,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    return np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)",
    "response_id": 11,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.01) -> np.ndarray:\n    \"\"\"Exact-fit-first priority with optional epsilon-greedy exploration.\"\"\"\n    # Feasibility mask and deterministic priority (negative waste)\n    feasible = bins_remain_cap >= item\n    deterministic = np.where(feasible, -(bins_remain_cap - item), -np.inf)\n    # With probability epsilon, use random scores for feasible bins\n    if np.random.rand() < epsilon:\n        random_scores = np.random.rand(bins := bins_remain_cap.shape[0])\n        return np.where(feasible, random_scores, -np.inf)\n    return deterministic",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.098524132429212,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns softmax-based priority for placing an item into each bin.\"\"\"\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    caps = bins_remain_cap.astype(float)\n    residual = caps - item\n    raw_scores = np.where(feasible, -residual, -np.inf)\n    max_score = raw_scores.max()\n    exp_scores = np.exp(raw_scores - max_score)\n    sum_exp = exp_scores.sum()\n    priorities = exp_scores / sum_exp if sum_exp > 0 else np.zeros_like(exp_scores)\n    return priorities",
    "response_id": 19,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    feasible = bins_remain_cap >= item\n    if np.any(feasible):\n        slack = bins_remain_cap[feasible] - item\n        scores[feasible] = -slack\n        tau = 0.5\n        scaled = scores / tau\n        max_score = np.max(scaled[feasible])\n        exp_vals = np.exp(scaled - max_score)\n        priorities = exp_vals / exp_vals.sum()\n    else:\n        priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    return priorities",
    "response_id": 29,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0, rng: np.random.Generator | None = None) -> np.ndarray:\n    feasible = bins_remain_cap >= item\n    if epsilon > 0.0 and rng is not None and rng.random() < epsilon:\n        random_scores = rng.random(bins_remain_cap.shape[0])\n        return np.where(feasible, random_scores, -np.inf)\n    return np.where(feasible, -(bins_remain_cap - item), -np.inf)",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\nfrom typing import Optional\n\n# Priority function combining deterministic waste and optional epsilon\u2011greedy exploration\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0,\n                random_state: Optional[int] = None) -> np.ndarray:\n    \"\"\"Priority = -waste for feasible bins; optional epsilon\u2011greedy random scores.\"\"\"\n    feasible = bins_remain_cap >= item\n    if epsilon > 0.0:\n        rng = np.random.default_rng(random_state)\n        if rng.random() < epsilon:\n            rand_scores = rng.random(bins_remain_cap.shape[0])\n            return np.where(feasible, rand_scores, -np.inf)\n    waste = bins_remain_cap - item\n    return np.where(feasible, -waste, -np.inf)",
    "response_id": 3,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0, temperature: float = 1.0) -> np.ndarray:\n    \"\"\"Epsilon\u2011greedy softmax: random scores with prob \u03b5, else residual\u2011based softmax.\"\"\"\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if np.random.rand() < epsilon:\n        rand_scores = np.random.rand(bins_remain_cap.shape[0])\n        raw = np.where(feasible, rand_scores, -np.inf)\n    else:\n        residual = bins_remain_cap.astype(float) - item\n        raw = np.where(feasible, -residual / max(temperature, 1e-12), -np.inf)\n    max_raw = np.max(raw)\n    exp_raw = np.exp(raw - max_raw)\n    sum_exp = exp_raw.sum()\n    return exp_raw / sum_exp if sum_exp > 0 else np.zeros_like(exp_raw)",
    "response_id": 7,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0, seed: int | None = None) -> np.ndarray:\n    \"\"\"Prioritize bins: -waste for feasible bins, -inf otherwise; with \u03b5 chance assign random scores.\"\"\"\n    # Vectorized feasibility mask\n    feasible = bins_remain_cap >= item\n    rng = np.random.default_rng(seed)\n    # \u03b5\u2011greedy: random scores for feasible bins with probability \u03b5\n    if epsilon > 0.0 and rng.random() < epsilon:\n        random_scores = rng.random(bins_remain_cap.shape)\n        return np.where(feasible, random_scores, -np.inf)\n    # Deterministic waste\u2011minimizing priority\n    waste = bins_remain_cap - item\n    return np.where(feasible, -waste, -np.inf)",
    "response_id": 9,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                epsilon: float = 0.0,\n                tau: float = 1.0,\n                rng: Optional[np.random.Generator] = None) -> np.ndarray:\n    \"\"\"\n    Softmax priority with temperature scaling and optional epsilon-greedy exploration; returns a probability distribution over bins that favors low waste, with random exploration when epsilon>0.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if rng.random() < epsilon:\n        rand_vals = rng.random(bins_remain_cap.size)\n        priorities = np.where(feasible, rand_vals, 0.0)\n        total = priorities.sum()\n        if total > 0:\n            priorities /= total\n        return priorities\n    residual = bins_remain_cap.astype(float) - item\n    raw_scores = np.where(feasible, -residual / tau, -np.inf)\n    max_score = raw_scores.max()\n    exp_scores = np.exp(raw_scores - max_score)\n    sum_exp = exp_scores.sum()\n    return exp_scores / sum_exp if sum_exp > 0 else np.zeros_like(exp_scores)",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    # Softmax with temperature and optional epsilon\u2011greedy exploration for online BPP.\n    tau: float = 0.5,\n    epsilon: float = 0.0,\n    rng: np.random.Generator = None,\n) -> np.ndarray:\n    \"\"\"Softmax with temperature and optional epsilon\u2011greedy exploration for online BPP.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    scores = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return scores\n    if epsilon > 0.0 and rng.random() < epsilon:\n        rand_vals = rng.random(feasible.sum())\n        probs = rand_vals / rand_vals.sum()\n        scores[feasible] = probs\n    else:\n        slack = bins_remain_cap[feasible] - item\n        raw = -slack / tau\n        max_raw = np.max(raw)\n        exp_vals = np.exp(raw - max_raw)\n        probs = exp_vals / exp_vals.sum()\n        scores[feasible] = probs\n    return scores",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, tau: float = 1.0,\n                epsilon: float = 0.0, rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Softmax fit (temp\u202ftau) with epsilon\u2011greedy random exploration.\"\"\"\n    # Combine stable softmax scoring of waste with occasional random scoring.\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    mask = residual >= 0\n    if not np.any(mask):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if epsilon > 0 and rng.random() < epsilon:\n        rand_scores = rng.random(bins_remain_cap.shape[0])\n        rand_scores[~mask] = -np.inf\n        max_rand = rand_scores[mask].max()\n        exp_rand = np.exp(rand_scores - max_rand)\n        exp_rand[~mask] = 0.0\n        total_rand = exp_rand.sum()\n        return exp_rand / total_rand if total_rand > 0 else np.zeros_like(bins_remain_cap, dtype=float)",
    "response_id": 2,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 16.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 1.0,\n                epsilon: float = 0.0, rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"\n    Softmax fit with temperature and optional epsilon\u2011greedy randomization.\n    Tighter fits get higher probability; random selection occurs with probability epsilon.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if epsilon > 0 and rng.random() < epsilon:\n        rand_vals = rng.random(bins_remain_cap.shape[0])\n        scores = np.where(feasible, rand_vals, 0.0)\n        total = scores.sum()\n        if total == 0:\n            return np.zeros_like(bins_remain_cap, dtype=float)\n        return scores / total\n    raw = -residual\n    raw[~feasible] = -np.inf\n    scaled = raw / max(temperature, 1e-12)\n    max_score = scaled[feasible].max()\n    exp_scores = np.exp(scaled - max_score)\n    exp_scores[~feasible] = 0.0\n    total = exp_scores.sum()\n    if total == 0:\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    return exp_scores / total",
    "response_id": 3,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 25.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tau: float = 1.0,\n    epsilon: float = 0.0,\n    rng: np.random.Generator = None,\n) -> np.ndarray:\n    \"\"\"Priority via temperature\u2011scaled softmax of negative waste mixed with epsilon\u2011greedy random scores; infeasible bins get -inf.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    # Deterministic score: negative waste (higher is better)\n    det_score = np.where(feasible, -(bins_remain_cap - item), -np.inf)\n    # Stable softmax with temperature\n    max_score = np.max(det_score[feasible])\n    shifted = (det_score - max_score) / max(tau, 1e-12)\n    exp_shifted = np.exp(shifted) * feasible\n    sum_exp = exp_shifted.sum_exp if hasattr(exp_shifted, \"sum_exp\") else exp_shifted.sum()\n    if sum_exp > 0:\n        softmax = exp_shifted / sum_exp\n    else:\n        # Fallback: uniform among max\u2011score bins\n        max_mask = (det_score == max_score) & feasible\n        count_max = max_mask.sum()\n        softmax = np.where(max_mask, 1.0 / count_max, 0.0)\n    # Random uniform distribution over feasible bins\n    rand_vals = rng.random(bins_remain_cap.shape) * feasible\n    sum_rand = rand_vals.sum()\n    if sum_rand > 0:\n        rand_dist = rand_vals / sum_rand\n    else:\n        rand_dist = np.zeros_like(bins_remain_cap, dtype=float)\n    # Mix deterministic and random scores\n    combined = (1.0 - epsilon) * softmax + epsilon * rand_dist\n    return np.where(feasible, combined, -np.inf)",
    "response_id": 4,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 31.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                tau: float = 1.0,\n                epsilon: float = 0.0,\n                rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Softmax priority with temperature and optional epsilon\u2011greedy exploration.\"\"\"\n    # feasible bins: enough remaining capacity for the item\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if rng is None:\n        rng = np.random.default_rng()\n    # epsilon\u2011greedy: uniform random scores over feasible bins\n    if rng.random() < epsilon:\n        rand = rng.random(bins_remain_cap.shape[0])\n        rand[~feasible] = 0.0\n        s = rand.sum()\n        return rand / s if s > 0 else np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    # temperature\u2011scaled softmax on negative waste (higher score \u2192 less waste)\n    scores = np.where(feasible, -(bins_remain_cap - item) / tau, -np.inf)\n    max_score = np.max(scores[feasible])\n    exp_scores = np.exp(scores - max_score)          # infeasible become 0\n    total = exp_scores.sum()\n    return exp_scores / total if total > 0 else np.full_like(bins_remain_cap, -np.inf, dtype=float)",
    "response_id": 5,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1, tau: float = 1.0, rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Temperature-scaled softmax with optional epsilon-greedy exploration; returns normalized priorities for feasible bins.\"\"\"\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if rng is None:\n        rng = np.random.default_rng()\n    if rng.random() < epsilon:\n        probs = np.zeros_like(bins_remain_cap, dtype=float)\n        probs[feasible] = 1.0 / np.count_nonzero(feasible)\n        return probs\n    residual = bins_remain_cap.astype(float) - item\n    raw_scores = -residual / tau\n    raw_scores[~feasible] = -np.inf\n    max_score = np.max(raw_scores)\n    exp_scores = np.exp(raw_scores - max_score)\n    sum_exp = np.sum(exp_scores)\n    return exp_scores / sum_exp if sum_exp > 0 else np.zeros_like(exp_scores)",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 17.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, tau: float = 1.0, epsilon: float = 0.0) -> np.ndarray:\n    \"\"\"Softmax of negative slack with temperature and optional epsilon\u2011greedy exploration.\"\"\"\n    feasible = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if np.any(feasible):\n        slack = bins_remain_cap[feasible] - item\n        idx = np.nonzero(feasible)[0]\n        priorities[idx] = -slack\n        exact_idx = idx[slack == 0]\n        priorities[exact_idx] = 1e12\n        if tau > 0:\n            priorities[idx] = priorities[idx] / tau\n        if epsilon > 0 and np.random.rand() < epsilon:\n            priorities[idx] = np.random.rand(len(idx))\n        else:\n            max_val = np.max(priorities[idx])\n            exp_vals = np.exp(priorities[idx] - max_val)\n            probs = exp_vals / np.sum(exp_vals)\n            priorities[idx] = probs\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, tau: float = 0.1, epsilon: float = 0.05, rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Return a probability distribution over bins for an incoming item.\n\n    The distribution favors bins with minimal residual capacity after placement,\n    includes optional epsilon\u2011exploration, and adds Gumbel noise for stochasticity.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the bins.\n    tau : float, optional\n        Temperature controlling the softness of the softmax (default 0.1).\n    epsilon : float, optional\n        Exploration weight for a uniform distribution over feasible bins (default 0.05).\n    rng : np.random.Generator, optional\n        Random generator for stochastic components; created if None.\n\n    Returns\n    -------\n    np.ndarray\n        Probability vector of the same shape as ``bins_remain_cap``; infeasible bins have zero probability.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    logits = -residual / tau\n    logits[~feasible] = -np.inf\n    gumbel = -np.log(-np.log(rng.random(logits.shape) + 1e-12) + 1e-12)\n    logits_noisy = logits + gumbel\n    logits_noisy[~feasible] = -np.inf\n    max_logit = np.max(logits_noisy)\n    exp_shifted = np.exp(logits_noisy - max_logit)\n    sum_exp = np.sum(exp_shifted)\n    softmax = exp_shifted / sum_exp if sum_exp > 0 else np.zeros_like(bins_remain_cap, dtype=float)\n    uniform = np.zeros_like(bins_remain_cap, dtype=float)\n    uniform[feasible] = 1.0 / feasible.sum()\n    return (1 - epsilon) * softmax + epsilon * uniform",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\n# Stable softmax priority with optional \u03b5\u2011greedy exploration for online bin packing.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                tau: float = 0.5, epsilon: float = 0.0,\n                rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Return probability scores for each bin based on remaining capacity, using a temperature\u2011scaled softmax; optionally explore randomly via \u03b5\u2011greedy.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    scores = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return scores\n    if epsilon > 0.0 and rng.random() < epsilon:\n        rand = rng.random(feasible.sum())\n        probs = rand / rand.sum()\n        scores[feasible] = probs\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    raw = -slack / tau\n    max_raw = raw.max()\n    exp_vals = np.exp(raw - max_raw)\n    probs = exp_vals / exp_vals.sum()\n    scores[feasible] = probs\n    return scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0,\n                random_state: Optional[int] = None) -> np.ndarray:\n    \"\"\"Compute bin priority using negative waste and optional \u03b5\u2011greedy random scores; returns a probability vector.\"\"\"\n    # Combine deterministic waste minimization with \u03b5\u2011greedy exploration.\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    rng = np.random.default_rng(random_state)\n    if epsilon > 0.0 and rng.random() < epsilon:\n        scores = np.where(feasible, rng.random(bins_remain_cap.shape[0]), -np.inf)\n    else:\n        waste = bins_remain_cap - item\n        scores = np.where(feasible, -waste, -np.inf)\n    max_score = np.max(scores[feasible])\n    exp_scores = np.exp(scores - max_score)\n    exp_scores[~feasible] = 0.0\n    prob = exp_scores / np.sum(exp_scores)\n    return prob",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                tau: float = 0.5,\n                epsilon: float = 0.0,\n                rng: np.random.Generator | None = None,\n                logistic_k: float = 12.0,\n                logistic_lambda: float = 1.0) -> np.ndarray:\n    \"\"\"\n    Softmax over negative waste plus logistic fill ratio, with optional epsilon exploration.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n\n    if rng is None:\n        rng = np.random.default_rng()\n    if rng.random() < epsilon:\n        probs = np.zeros_like(bins_remain_cap, dtype=float)\n        probs[feasible] = 1.0 / np.count_nonzero(feasible)\n        return probs\n\n    caps = bins_remain_cap.astype(float)\n    residual = caps - item\n    raw_scores = -residual / tau\n\n    ratio = residual / caps\n    logistic_factor = 1.0 / (1.0 + np.exp(-logistic_k * (1.0 - ratio)))\n    raw_scores += logistic_lambda * logistic_factor\n\n    raw_scores[~feasible] = -np.inf\n\n    max_score = np.max(raw_scores)\n    exp_scores = np.exp(raw_scores - max_score)\n    sum_exp = np.sum(exp_scores)\n    return exp_scores / sum_exp if sum_exp > 0 else np.zeros_like(exp_scores)",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 27.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\n# Combine exact\u2011fit boost with epsilon\u2011greedy softmax for online BPP.\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    epsilon: float = 0.0,\n    temperature: float = 1.0,\n    rng: np.random.Generator = None,\n) -> np.ndarray:\n    \"\"\"Priority for online BPP: stable softmax over negative waste, boost exact fits, optional epsilon\u2011greedy exploration.\"\"\"\n    if rng:  # ensure rng is a Generator\n        pass\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if epsilon > 0 and rng.random() < epsilon:\n        rand = rng.random(bins_remain_cap.shape[0])\n        scores = np.where(feasible, rand, 0.0)\n        total = scores.sum()\n        return scores / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float)\n    boost = 1e3\n    raw = -residual + boost * (residual == 0)\n    raw[~feasible] = -np.inf\n    scaled = raw / max(temperature, 1e-12)\n    max_score = scaled[feasible].max()\n    exp_scores = np.exp(scaled - max_score)\n    exp_scores[~feasible] = 0.0\n    total = exp_scores.sum()\n    return exp_scores / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float)",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 30.0,
    "cyclomatic_complexity": 8.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\n# Priority function combining stable softmax and epsilon\u2011greedy exploration.\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                temperature: float = 1.0,\n                epsilon: float = 0.0,\n                rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Compute bin selection probabilities via temperature\u2011scaled softmax on negative waste, with optional epsilon\u2011greedy random exploration.\"\"\"\n    if rng is None:\n        rng = 0  # placeholder, will be overridden\n    # Initialize RNG lazily to avoid default_rng call overhead when not needed\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if epsilon > 0 and rng.random() < epsilon:\n        rand_vals = rng.random(bins_remain_cap.shape)\n        scores = np.where(feasible, rand_vals, 0.0)\n        total = scores.sum()\n        return scores / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float)\n    raw = -residual\n    raw[~feasible] = -np.inf\n    temp = max(temperature, 1e-12)\n    scaled = raw / temp\n    max_score = scaled[feasible].max()\n    exp_scores = np.exp(scaled - max_score)\n    exp_scores[~feasible] = 0.0\n    total = exp_scores.sum()\n    return exp_scores / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float)",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 27.0,
    "cyclomatic_complexity": 8.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response7.txt_stdout.txt",
    "code_path": "problem_iter17_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0, rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Priority based on logistic slack ratio with \u03b5\u2011greedy softmax exploration.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    ratio = residual / bins_remain_cap\n    k = 12.0\n    deterministic = 1.0 / (1.0 + np.exp(-k * (1.0 - ratio)))\n    deterministic[~feasible] = -np.inf\n    random_scores = rng.random(bins_remain_cap.shape[0])\n    random_scores[~feasible] = -np.inf\n    combined = (1.0 - epsilon) * deterministic + epsilon * random_scores\n    max_comb = combined[feasible].max()\n    exp_comb = np.exp(combined - max_comb)\n    exp_comb[~feasible] = 0.0\n    probs = exp_comb / exp_comb.sum()\n    return probs",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "import numpy as np\n\n# Priority function combining exact-fit bias with softmax waste scoring and epsilon\u2011greedy exploration.\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                epsilon: float = 0.0,\n                temperature: float = 1.0,\n                rng: np.random.Generator | None = None) -> np.ndarray:\n    \"\"\"Exact\u2011fit bias, softmax on waste, optional epsilon\u2011greedy randomization.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if epsilon > 0.0 and rng.random() < epsilon:\n        rand_vals = rng.random(bins_remain_cap.shape[0])\n        scores = np.where(feasible, rand_vals, 0.0)\n        total = scores.sum()\n        if total > 0.0:\n            return scores / total\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    exact = (residual == 0) & feasible\n    if np.any(exact):\n        prob = np.where(exact, 1.0, 0.0)\n        return prob / prob.sum()\n    waste = residual\n    raw = -waste\n    raw[~feasible] = -np.inf\n    scaled = raw / max(temperature, 1e-12)\n    max_raw = np.max(scaled[feasible])\n    exp_scores = np.exp(scaled - max_raw)\n    exp_scores[~feasible] = 0.0\n    total = exp_scores.sum()\n    if total > 0.0:\n        return exp_scores / total\n    return np.zeros_like(bins_remain_cap, dtype=float)",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 33.0,
    "cyclomatic_complexity": 8.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response5.txt_stdout.txt",
    "code_path": "problem_iter11_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                tau: float = 1.0,\n                epsilon: float = 0.1,\n                rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"\n    Temperature-scaled softmax with epsilon-greedy exploration over feasible bins; returns probability vector.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    det_score = np.where(feasible, -(bins_remain_cap - item), -np.inf)\n    max_score = np.max(det_score[feasible])\n    shifted = (det_score - max_score) / max(tau, 1e-12)\n    exp_shifted = np.exp(shifted) * feasible\n    sum_exp = exp_shifted.sum()\n    if sum_exp > 0:\n        softmax = exp_shifted / sum_exp\n    else:\n        max_mask = (det_score == max_score) & feasible\n        count_max = max_mask.sum()\n        softmax = np.where(max_mask, 1.0 / count_max, 0.0)\n    rand_vals = rng.random(bins_remain_cap.shape) * feasible\n    sum_rand = rand_vals.sum()\n    if sum_rand > 0:\n        rand_dist = rand_vals / sum_rand\n    else:\n        rand_dist = np.zeros_like(bins_remain_cap, dtype=float)\n    combined = (1.0 - epsilon) * softmax + epsilon * rand_dist\n    return np.where(feasible, combined, -np.inf)",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 30.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response7.txt_stdout.txt",
    "code_path": "problem_iter11_code7.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    temperature: float = 1.0,\n    epsilon: float = 0.0,\n    rng: Optional[np.random.Generator] = None,\n) -> np.ndarray:\n    \"\"\"Softmax over negative waste with temperature scaling and epsilon\u2011greedy exploration; masks infeasible bins.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if epsilon > 0.0 and rng.random() < epsilon:\n        scores = np.zeros_like(bins_remain_cap, dtype=float)\n        rand_vals = rng.random(feasible.sum())\n        scores[feasible] = rand_vals\n        total = scores.sum()\n        return scores / total\n    temp = max(temperature, 1e-12)\n    logits = -residual / temp\n    logits[~feasible] = -np.inf\n    max_logit = np.max(logits[feasible])\n    exp_vals = np.exp(logits - max_logit)\n    exp_vals[~feasible] = 0.0\n    total = exp_vals.sum()\n    return exp_vals / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float)",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 27.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response9.txt_stdout.txt",
    "code_path": "problem_iter11_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, tau: float = 0.1, epsilon: float = 0.05, rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Probability distribution over bins favoring minimal residual capacity, with epsilon mixing and Gumbel noise.\"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if rng is None:\n        rng = np.random.default_rng()\n    temperature = max(tau, 1e-12)\n    residual = bins_remain_cap - item\n    logits = -residual / temperature\n    logits[~feasible] = -np.inf\n    gumbel = -np.log(-np.log(rng.random(logits.shape) + 1e-12) + 1e-12)\n    logits_noisy = logits + gumbel\n    logits_noisy[~feasible] = -np.inf\n    max_logit = np.max(logits_noisy)\n    exp_shifted = np.exp(logits_noisy - max_logit)\n    sum_exp = np.sum(exp_shifted)\n    softmax = exp_shifted / sum_exp if sum_exp > 0 else np.zeros_like(bins_remain_cap, dtype=float)\n    uniform = np.zeros_like(bins_remain_cap, dtype=float)\n    uniform[feasible] = 1.0 / feasible.sum()\n    return (1 - epsilon) * softmax + epsilon * uniform",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response7.txt_stdout.txt",
    "code_path": "problem_iter20_code7.py",
    "code": "# Heuristic: combine waste minimization, temperature\u2011scaled softmax, \u03b5\u2011uniform mixing, and Gumbel perturbation.\nimport numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tau: float = 0.1,\n    epsilon: float = 0.05,\n    rng: np.random.Generator = None,\n) -> np.ndarray:\n    \"\"\"Score bins for online BPP: low waste, softmax with temperature, \u03b5\u2011uniform mix, and Gumbel noise.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    residual = bins_remain_cap - item\n    logits = -residual / tau\n    logits[~feasible] = -np.inf\n    gumbel = -np.log(-np.log(rng.random(logits.shape) + 1e-12) + 1e-12)\n    logits = logits + gumbel\n    max_logit = np.max(logits)\n    exp_shifted = np.exp(logits - max_logit)\n    exp_shifted[~feasible] = 0.0\n    total = exp_shifted.sum()\n    softmax = exp_shifted / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float)\n    uniform = np.zeros_like(bins_remain_cap, dtype=float)\n    uniform[feasible] = 1.0 / feasible.sum()\n    return (1.0 - epsilon) * softmax + epsilon * uniform",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 25.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    epsilon: float = 0.0,\n    tau: float = 1.0,\n    rng: np.random.Generator = None,\n) -> np.ndarray:\n    \"\"\"Return normalized priorities for feasible bins using epsilon\u2011greedy softmax.\"\"\"\n    # ensure RNG availability\n    if rng is None:\n        rng = np.random.default_rng()\n    # feasible bins mask\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    # epsilon\u2011greedy: random uniform among feasible bins\n    if epsilon > 0.0 and rng.random() < epsilon:\n        probs = np.zeros_like(bins_remain_cap, dtype=float)\n        probs[feasible] = 1.0 / feasible.sum()\n        return probs\n    # temperature\u2011scaled scores (negative waste)\n    raw_scores = - (bins_remain_cap.astype(float) - item) / tau\n    raw_scores[~feasible] = -np.inf\n    # stable softmax via log\u2011sum\u2011exp trick\n    max_score = np.max(raw_scores)\n    exp_scores = np.exp(raw_scores - max_score)\n    sum_exp = np.sum(exp_scores)\n    if sum_exp == 0.0:\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    return exp_scores / sum_exp",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 25.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, tau: float = 1.0, epsilon: float = 0.1, rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Hybrid waste\u2011based residual scoring with temperature\u2011scaled softmax and \u03b5\u2011weighted random\u2011logit exploration.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    feasible = bins >= item\n    if not np.any(feasible):\n        return np.full_like(bins, -np.inf, dtype=float)\n    residual = bins - item\n    det_logits = np.where(feasible, -residual, -np.inf)\n    max_det = np.max(det_logits[feasible])\n    det_shifted = (det_logits - max_det) / max(tau, 1e-12)\n    det_exp = np.exp(det_shifted) * feasible\n    det_sum = det_exp.sum()\n    det_softmax = np.where(det_sum > 0, det_exp / det_sum, 0.0)\n    rand_logits = rng.random(bins.shape)\n    rand_logits = np.where(feasible, rand_logits, -np.inf)\n    max_rand = np.max(rand_logits[feasible])\n    rand_shifted = rand_logits - max_rand\n    rand_exp = np.exp(rand_shifted) * feasible\n    rand_sum = rand_exp.sum()\n    rand_softmax = np.where(rand_sum > 0, rand_exp / rand_sum, 0.0)\n    probs = (1.0 - epsilon) * det_softmax + epsilon * rand_softmax\n    return np.where(feasible, probs, -np.inf)",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    temperature: float = 1.0,\n    epsilon: float = 0.0,\n    rng: np.random.Generator | None = None,\n) -> np.ndarray:\n    \"\"\"Probability over bins via temperature\u2011scaled softmax on negative waste with epsilon\u2011greedy exploration.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if epsilon > 0 and rng.random() < epsilon:\n        rand = rng.random(bins_remain_cap.shape)\n        scores = np.where(feasible, rand, 0.0)\n        total = scores.sum()\n        return scores / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float)\n    scores = -residual\n    scores = np.where(feasible, scores, -np.inf)\n    temp  # placeholder to avoid unused variable warning\n    temp = max(temperature, 1e-12)\n    scaled = scores / temp\n    max_score = np.max(scaled[feasible])\n    exp_scores = np.exp(scaled - max_score)\n    exp_scores = np.where(feasible, exp_scores, 0.0)\n    total = exp_scores.sum()\n    return exp_scores / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float)",
    "response_id": 6,
    "tryHS": false,
    "obj": 7.6086956521739095,
    "SLOC": 28.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\nfrom typing import Optional\n\n# Priority function for online bin packing: waste + rank + \u03b5\u2011weighted random.\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                *,\n                temperature: float = 1.0,\n                epsilon: float = 0.0,\n                rank_power: float = 1.0,\n                rng: Optional[np.random.Generator] = None) -> np.ndarray:\n    \"\"\"Combine waste, rank weight, and \u03b5\u2011weighted random perturbation; temperature scales waste.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    residual = bins - item\n    feasible = residual >= 0\n    scores = np.full_like(bins, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    waste = -residual[feasible] / max(temperature, 1e-12)\n    feas_res = residual[feasible]\n    sorted_idx = np.argsort(feas_res)\n    rank = np.empty_like(feas_res, dtype=int)\n    rank[sorted_idx] = np.arange(len(feas_res))\n    num_feas = len(feas_res)\n    rank_weight = (num_feas - rank) ** rank_power\n    deterministic = waste + np.log(rank_weight + 1e-12)\n    if epsilon > 0.0:\n        rand = rng.random(num_feas)\n        deterministic = (1 - epsilon) * deterministic + epsilon * rand\n    scores[feasible] = deterministic\n    return scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 28.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    epsilon: float = 0.0,\n    temperature: float = 1.0,\n    random_state: Optional[int] = None,\n) -> np.ndarray:\n    \"\"\"Combine waste\u2011based score (-remaining) with \u03b5\u2011greedy random component and temperature\u2011scaled softmax for balanced exploration/exploitation.\"\"\"\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    feasible = bins >= item\n    if not np.any(feasible):\n        return np.full_like(bins, -np.inf, dtype=float)\n    rng = np.random.default_rng(random_state)\n    deterministic = -(bins - item)\n    random_scores = rng.random(bins.shape)\n    mixed = (1.0 - epsilon) * deterministic + epsilon * random_scores\n    mixed = np.where(feasible, mixed, -np.inf)\n    temp = max(temperature, 1e-12)\n    max_val = np.max(mixed[feasible])\n    shifted = mixed - max_val\n    exp_vals = np.exp(shifted / temp)\n    exp_vals = np.where(feasible, exp_vals, 0.0)\n    probs = exp_vals / exp_vals.sum()\n    return probs",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    epsilon: float = 0.0,\n    temperature: float = 1.0,\n    random_state: Optional[int] = None,\n) -> np.ndarray:\n    \"\"\"Blend waste\u2011based score, rank weighting, \u03b5\u2011greedy perturbation, and temperature.\"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    waste = bins_remain_cap[feasible] - item\n    deterministic = -waste\n    rng = np.random.default_rng(random_state)\n    random_scores = rng.random(waste.shape)\n    mixed = (1.0 - epsilon) * deterministic + epsilon * random_scores\n    order = np.argsort(waste)\n    ranks = np.empty_like(order)\n    ranks[order] = np.arange(waste.size)\n    mixed *= 1.0 / (ranks + 1.0)\n    if temperature != 1.0:\n        mixed = mixed / temperature\n    scores[feasible] = mixed\n    return scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 86.55763861188672,
    "SLOC": 24.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                epsilon: float = 0.0,\n                temperature: float = 1.0,\n                rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"Softmax over negative waste with temperature, mixed with epsilon\u2011weighted random exploration for feasible bins.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    mask = residual >= 0\n    if not np.any(mask):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    # Deterministic waste\u2011based scores (tighter fit \u2192 higher)\n    det = -residual\n    det[~mask] = -np.inf\n    max_det = det[mask].max()\n    exp_det = np.exp((det - max_det) / max(temperature, 1e-12))\n    exp_det[~mask] = 0.0\n    sum_det = exp_det.sum()\n    det_soft = exp_det / sum_det if sum_det > 0 else np.zeros_like(bins_remain_cap, dtype=float)\n    # Random exploration component\n    if epsilon > 0:\n        rand = rng.random(bins_remain_cap.shape)\n        rand[~mask] = -np.inf\n        max_rand = rand[mask].max()\n        exp_rand = np.exp((rand - max_rand) / max(temperature, 1e-12))\n        exp_rand[~mask] = 0.0\n        sum_rand = exp_rand.sum()\n        rand_soft = exp_rand / sum_rand if sum_rand > 0 else np.zeros_like(bins_remain_cap, dtype=float)\n    else:\n        rand_soft = np.zeros_like(bins_remain_cap, dtype=float)\n    # Weighted mix of deterministic and random scores\n    final = (1 - epsilon) * det_soft + epsilon * rand_soft\n    total = final.sum()\n    if total > 0:\n        final /= total\n    return final",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 33.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response0.txt_stdout.txt",
    "code_path": "problem_iter21_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, rng: np.random.Generator = None,\n                tau: float = 1.0, alpha: float = 1.5, penalty_factor: float = 0.5,\n                noise_base: float = 0.1, risk_factor: float = 0.1) -> np.ndarray:\n    \"\"\"Rank\u2011based adaptive priority for online bin packing.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    penalty = np.where(feasible, 0.0, (item - bins_remain_cap) * penalty_factor)\n    base_score = -residual - penalty\n    max_residual = np.max(residual[feasible])\n    risk = np.where(feasible, 1 - residual / (max_residual + 1e-12), 0.0)\n    base_score -= risk_factor * risk\n    order = np.argsort(-base_score)\n    rank = np.empty_like(order)\n    rank[order] = np.arange(len(base_score))\n    weight = 1.0 / (rank + 1) ** alpha\n    raw_scores = base_score * weight\n    noise_scale = noise_base * (residual / (max_residual + 1e-12))\n    noise_scale = np.maximum(noise_scale, 0.0)\n    noise = rng.normal(0.0, noise_scale, size=bins_remain_cap.shape)\n    raw_scores += noise\n    max_raw = np.max(raw_scores)\n    exp_scores = np.exp((raw_scores - max_raw) / tau)\n    probs = exp_scores / np.sum(exp_scores)\n    return probs",
    "response_id": 0,
    "tryHS": false,
    "obj": 144.57518946948545,
    "SLOC": 27.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response0.txt_stdout.txt",
    "code_path": "problem_iter22_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                no_priority_value: float = -720997115643.1592,\n                exact_match_weight: float = 3557805332727.2324) -> np.ndarray:\n    priorities = np.full(bins_remain_cap.shape, no_priority_value, dtype=float)\n    exact_mask = bins_remain_cap == item\n    valid_mask = bins_remain_cap >= item\n    priorities[exact_mask] = exact_match_weight\n    valid_not_exact = valid_mask & ~exact_mask\n    slack = bins_remain_cap[valid_not_exact] - item\n    priorities[valid_not_exact] = -slack\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response3.txt_stdout.txt",
    "code_path": "problem_iter23_code3.py",
    "code": "import numpy as np\nfrom typing import Optional\n\n# Weighted waste + rank + \u03b5\u2011greedy + softmax\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    epsilon: float = 0.0,\n    temperature: float = 1.0,\n    random_state: Optional[int] = None,\n) -> np.ndarray:\n    \"\"\"Combines negative waste, rank weighting, \u03b5\u2011greedy exploration, and temperature\u2011scaled softmax for balanced bin selection.\"\"\"\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    feasible = bins >= item\n    if not np.any(feasible):\n        return np.full_like(bins, -np.inf, dtype=float)\n    rng = np.random.default_rng(random_state)\n    waste = bins[feasible] - item\n    deterministic = -waste\n    order = np.argsort(waste)\n    ranks = np.empty_like(order)\n    ranks[order] = np.arange(waste.size)\n    deterministic *= 1.0 / (ranks + 1.0)\n    random_scores = rng.random(waste.size)\n    mixed = (1.0 - epsilon) * deterministic + epsilon * random_scores\n    mixed_full = np.full_like(bins, -np.inf, dtype=float)\n    mixed_full[feasible] = mixed\n    temp = max(temperature, 1e-12)\n    max_val = np.max(mixed_full[feasible])\n    shifted = mixed_full - max_val\n    exp_vals = np.exp(shifted / temp)\n    probs = exp_vals / exp_vals.sum()\n    return probs",
    "response_id": 3,
    "tryHS": false,
    "obj": 86.55763861188672,
    "SLOC": 28.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response5.txt_stdout.txt",
    "code_path": "problem_iter23_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                temperature: float = 1.0,\n                epsilon: float = 0.0,\n                rng: np.random.Generator | None = None) -> np.ndarray:\n    \"\"\"Combine epsilon\u2011greedy random exploration with a temperature\u2011scaled softmax on negative residual (waste) to produce a normalized probability vector over feasible bins.\"\"\"\n    # Epsilon\u2011greedy + temperature\u2011scaled softmax on waste\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if epsilon > 0.0 and rng.random() < epsilon:\n        rand_vals = rng.random(bins_remain_cap.shape)\n        scores = np.where(feasible, rand_vals, 0.0)\n        total = scores.sum()\n        return scores / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float) \n    temp = max(temperature, 1e-12)\n    raw = np.where(feasible, -residual / temp, -np.inf)\n    max_raw = np.max(raw)\n    exp_raw = np.exp(raw - max_raw)\n    sum_exp = exp_raw.sum()\n    return exp_raw / sum_exp if sum_exp > 0 else np.zeros_like(bins_remain_cap, dtype=float)",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 22.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  }
]