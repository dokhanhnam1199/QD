```python
import numpy as np

class PriorityV2Ensemble:
    def __init__(self):
        self.num_components = 3
        self.weights = np.ones(self.num_components) / self.num_components
        self.alpha = 0.1
        self.tau = 0.5
        self.epsilon = 0.05
        self.rng = np.random.default_rng()
        self.residual_hist = []
        self.hist_len = 200
        self.step = 0

    def get_priority(self, item, bins):
        feasible = bins >= item
        if not np.any(feasible):
            return np.zeros_like(bins, dtype=float)
        residual = bins.astype(float) - item
        best_score = -residual
        worst_score = residual
        first_score = np.full_like(bins, -np.inf, dtype=float)
        idx = np.arange(len(bins))
        first_score[feasible] = -idx[feasible]
        comp_scores = np.stack([best_score, worst_score, first_score], axis=0)
        combined = np.sum(comp_scores * self.weights[:, None], axis=0)
        combined[~feasible] = -np.inf
        if self.rng.random() < self.epsilon:
            probs = np.zeros_like(bins, dtype=float)
            probs[feasible] = 1.0 / np.count_nonzero(feasibility) if np.count_nonzero(feasible) > 0 else 0.0
        else:
            max_score = np.max(combined)
            exp_scores = np.exp((combined - max_score) / self.tau)
            exp_scores[~feasible] = 0.0
            sum_exp = np.sum(exp_scores)
            probs = exp_scores / sum_exp if sum_exp > 0 else np.zeros_like(exp_scores)
        chosen_bin = np.argmax(probs)
        self._update_weights(item, bins, feasible, residual)
        self._update_meta(item, bins, chosen_bin, residual)
        self.step += 1
        return probs

    def _update_weights(self, item, bins, feasible, residual):
        feasible_residual = residual[feasible]
        std = np.std(feasible_residual)
        w_best = 1.0 / (std + 1e-6)
        w_worst = std
        w_first = 1.0
        target = np.array([w_best, w_worst, w_first])
        target = target / target.sum()
        self.weights = (1 - self.alpha) * self.weights + self.alpha * target

    def _update:
        pre = bins[chosen_bin]
        post = pre - item
        frac = post / pre if pre > 0 else 0.0
        self.residual_hist.append(frac)
        if len(self.residual_hist) > self.hist_len:
            self.residual_hist = self.residual_hist[-self.hist_len:]
        avg_frac = np.mean(self.residual_hist)
        target_frac = 0.2
        self.epsilon = max(0.01, min(0.3, self.epsilon * (1 + (avg_frac - target_frac))))
        entropy = -np.sum(self.weights * np.log(self.weights + 1e-12))
        self.tau = max(0.1, min(2.0, self.tau * (1 + (entropy - 1.0) * 0.5)))

_priority_ensemble = PriorityV2Ensemble()

def priority_v2(item, bins_remain_cap):
    return _priority_ensemble.get_priority(item, bins_remain_cap)
```
