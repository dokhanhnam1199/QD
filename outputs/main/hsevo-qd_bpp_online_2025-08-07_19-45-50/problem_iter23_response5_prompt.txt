{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Epsilon\u2011greedy softmax: random scores with prob \u03b5, else residual\u2011based softmax.\"\"\"\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if np.random.rand() < epsilon:\n        rand_scores = np.random.rand(bins_remain_cap.shape[0])\n        raw = np.where(feasible, rand_scores, -np.inf)\n    else:\n        residual = bins_remain_cap.astype(float) - item\n        raw = np.where(feasible, -residual / max(temperature, 1e-12), -np.inf)\n    max_raw = np.max(raw)\n    exp_raw = np.exp(raw - max_raw)\n    sum_exp = exp_raw.sum()\n    return exp_raw / sum_exp if sum_exp > 0 else np.zeros_like(exp_raw)\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    temperature: float = 1.0,\n    epsilon: float = 0.0,\n    rng: np.random.Generator | None = None,\n) -> np.ndarray:\n    \"\"\"Probability over bins via temperature\u2011scaled softmax on negative waste with epsilon\u2011greedy exploration.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    residual = bins_remain_cap - item\n    feasible = residual >= 0\n    if not np.any(feasible):\n        return np.zeros_like(bins_remain_cap, dtype=float)\n    if epsilon > 0 and rng.random() < epsilon:\n        rand = rng.random(bins_remain_cap.shape)\n        scores = np.where(feasible, rand, 0.0)\n        total = scores.sum()\n        return scores / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float)\n    scores = -residual\n    scores = np.where(feasible, scores, -np.inf)\n    temp  # placeholder to avoid unused variable warning\n    temp = max(temperature, 1e-12)\n    scaled = scores / temp\n    max_score = np.max(scaled[feasible])\n    exp_scores = np.exp(scaled - max_score)\n    exp_scores = np.where(feasible, exp_scores, 0.0)\n    total = exp_scores.sum()\n    return exp_scores / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=float)\n\n### Analyze & experience\n- - **Best (Heuristic\u202f1) vs Worst (Heuristic\u202f20):**\u202fHeuristic\u202f1 has a concise docstring, explicit feasibility mask, early exit, optional RNG injection, \u03b5\u2011greedy uniform exploration, temperature\u2011scaled softmax with log\u2011sum\u2011exp stability, and returns a proper probability distribution.\u202fHeuristic\u202f20 blends waste, rank weighting, and \u03b5\u2011perturbation but never normalises, lacks log\u2011sum\u2011exp, uses ad\u2011hoc scaling, and returns raw scores, making it numerically unstable and harder to interpret.  \n- **Second\u2011best (Heuristic\u202f2) vs Second\u2011worst (Heuristic\u202f19):**\u202fBoth implement the same softmax idea, but Heuristic\u202f2 is clean, has no stray comments, and uses a direct \u201cif rng is None\u201d pattern.\u202fHeuristic\u202f19 contains a placeholder comment (`temp  # placeholder to avoid unused variable warning`), duplicated logic from 18, and less\u2011direct variable naming, slightly reducing readability and hinting at sloppy maintenance.  \n- **Heuristic\u202f1 vs Heuristic\u202f2:**\u202fThe source code and docstring are identical; no functional or stylistic difference, confirming the ranking is based on external criteria rather than code quality.  \n- **Heuristic\u202f3 vs Heuristic\u202f4:**\u202fAgain identical implementations, showing redundancy; both share the same docstring and logic, indicating no quality distinction.  \n- **Second\u2011worst (Heuristic\u202f19) vs Worst (Heuristic\u202f20):**\u202fHeuristic\u202f19 performs a stable softmax (subtract max, exponentiate, normalise) and respects temperature scaling, while Heuristic\u202f20 applies rank\u2011based weighting on raw waste, does not apply a softmax nor temperature, and leaves the output unnormalised.\u202fThe former yields a well\u2011behaved probability distribution; the latter can produce arbitrary magnitudes and is more sensitive to scale.  \n- **Additional illustrative pairs:**  \n  - **Heuristic\u202f5 vs Heuristic\u202f6:**\u202fHeuristic\u202f5 returns deterministic \u2013waste without normalisation; Heuristic\u202f6 adds a stable softmax with \u03b5\u2011greedy, producing proper probabilities and smoother exploration.  \n  - **Heuristic\u202f7 vs Heuristic\u202f8:**\u202fHeuristic\u202f7 uses a hard\u2011coded huge constant for exact fits; Heuristic\u202f8 blends deterministic waste, random noise, and temperature\u2011scaled softmax, giving a tunable exploration\u2011exploitation balance.  \n  - **Heuristic\u202f13 vs Heuristic\u202f14:**\u202fHeuristic\u202f13 augments negative waste with a logistic fill\u2011ratio term before softmax, enriching the feature set; Heuristic\u202f14 uses plain softmax on waste only, simpler but potentially less discriminative.  \n\n**Overall:**\u202fTop\u2011ranked heuristics consistently (i) provide clear documentation, (ii) mask infeasible bins early, (iii) employ a numerically stable softmax (log\u2011sum\u2011exp), (iv) expose a controllable \u03b5\u2011greedy exploration with an injectable RNG, and (v) return normalized probability vectors. Lower\u2011ranked versions omit one or more of these pillars, leading to instability, ambiguous outputs, or harder tuning.\n- \n- **Keywords**: Dynamic weighting, ensemble, feedback\u2011driven, meta\u2011learning.  \n- **Advice**: Combine multiple scoring functions into an ensemble, continuously update each component\u2019s influence from observed outcomes, and let a meta\u2011learner propose parameter tweaks when performance deviates from expectations.  \n- **Avoid**: Fixed thresholds, static weight assignments, hand\u2011crafted parameters that never change, and isolated heuristics lacking self\u2011tuning.  \n- **Explanation**: Dynamic ensembles keep the search diverse, feedback refines component relevance, meta\u2011learning automates tuning, while static designs quickly become brittle across varied problem instances.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}