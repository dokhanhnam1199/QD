```python
import numpy as np
from typing import Optional
import unittest

def priority_v2(item: float, bins_remain_cap: np.ndarray, tau: float = 1.0, epsilon: float = 0.0, seed: Optional[int] = None) -> np.ndarray:
    """
    Compute selection probabilities for bins in an online bin packing problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Array of remaining capacities of each bin.
    tau : float, default 1.0
        Temperature parameter for softmax; must be positive.
    epsilon : float, default 0.0
        Probability of exploring uniformly among feasible bins; must be in [0, 1].
    seed : int, optional
        Seed for the internal random number generator to ensure reproducibility.

    Returns
    -------
    np.ndarray
        Probability vector of the same shape as `bins_remain_cap`. Infeasible bins
        receive probability zero. The probabilities for feasible bins sum to one
        (or zero if no bin can accommodate the item).
    """
    if not isinstance(bins_remain_cap, np.ndarray):
        raise TypeError("bins_remain_cap must be a numpy.ndarray")
    if tau <= 0.0:
        raise ValueError("tau must be positive")
    if not (0.0 <= epsilon <= 1.0):
        raise ValueError("epsilon must be between 0 and 1")
    rng = np.random.default_rng(seed)
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        return np.zeros_like(bins_remain_cap, dtype=float)
    if rng.random() < epsilon:
        probs = np.zeros_like(bins_remain_cap, dtype=float)
        probs[feasible] = 1.0 / np.count_nonzero(feasible)
        return probs
    residual = bins_remain_cap.astype(float) - item
    residual_feasible = residual[feasible]
    raw_scores = -residual_feasible / tau
    max_score = np.max(raw_scores)
    exp_scores = np.exp(raw_scores - max_score)
    sum_exp = np.sum(exp_scores)
    probs_feasible = exp_scores / sum_exp if sum_exp > 0 else np.zeros_like(exp_scores)
    probs = np.zeros_like(bins_remain_cap, dtype=float)
    probs[feasible] = probs_feasible
    return probs

class TestPriorityV2(unittest.TestCase):
    def test_no_feasible(self):
        bins = np.array([0.1, 0.2])
        item = 0.5
        probs = priority_v2(item, bins)
        self.assertTrue(np.allclose(probs, np.zeros_like(bins)))
        self.assertEqual(probs.sum(), 0.0)

    def test_softmax_sum_one(self):
        bins = np.array([0.5, 0.3, 0.1])
        item = 0.2
        probs = priority_v2(item, bins, tau=1.0, epsilon=0.0)
        residual_feasible = np.array([0.5 - 0.2, 0.3 - 0.2])
        raw_scores = -residual_feasible
        max_score = np.max(raw_scores)
        exp_scores = np.exp(raw_scores - max_score)
        probs_expected = exp_scores / exp_scores.sum()
        self.assertTrue(np.allclose(probs[:2], probs_expected))
        self.assertTrue(np.isclose(probs.sum(), 1.0))
        self.assertEqual(probs[2], 0.0)

    def test_uniform_eps(self):
        bins = np.array([0.5, 0.4])
        item = 0.2
        probs = priority_v2(item, bins, epsilon=1.0, seed=123)
        self.assertTrue(np.allclose(probs, np.array([0.5, 0.5])))
        self.assertEqual(probs.sum(), 1.0)

    def test_reproducibility(self):
        bins = np.array([0.5, 0.4, 0.2])
        item = 0.3
        probs1 = priority_v2(item, bins, tau=1.0, epsilon=0.5, seed=42)
        probs2 = priority_v2(item, bins, tau=1.0, epsilon=0.5, seed=42)
        self.assertTrue(np.allclose(probs1, probs2))

    def test_invalid_tau(self):
        bins = np.array([0.5, 0.3])
        with self.assertRaises(ValueError):
            priority_v2(0.2, bins, tau=0.0)

    def test_invalid_epsilon(self):
        bins = np.array([0.5, 0.3])
        with self.assertRaises(ValueError):
            priority_v2(0.2, bins, epsilon=-0.1)
        with self.assertRaises(ValueError):
            priority_v2(0.2, bins, epsilon=1.1)

    def test_shape_and_dtype(self):
        bins = np.array([[0.5, 0.4], [0.3, 0.2]])
        probs = priority_v2(0.2, bins)
        self.assertEqual(probs.shape, bins.shape)
        self.assertEqual(probs.dtype, np.float64)

    def test_full_fit(self):
        bins = np.array([1.0, 1.0])
        item = 1.0
        probs = priority_v2(item, bins, epsilon=0.0)
        self.assertTrue(np.allclose(probs, np.array([0.5, 0.5])))

if __name__ == "__main__":
    unittest.main()
```
