```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    CVRP heuristic: Combines distance, demand, depot proximity, adaptive sparsification, and route completion.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # 1. Inverse Distance Component
    inverse_distance = 1 / (distance_matrix + 1e-9)
    heuristics += inverse_distance

    # 2. Demand Consideration and Hard Pruning
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue
            if i == depot_index and demands[j] > capacity:
                heuristics[i, j] = 0  # Prune infeasible edges from depot
            elif i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and j==depot_index:
                heuristics[i,j] = 0 # Prune edges exceeding capacity towards the depot.

    # 3. Depot Proximity Incentive (Adaptive Scaling)
    depot_distances = distance_matrix[:, depot_index]
    mean_depot_distance = np.mean(depot_distances) + 1e-9
    for i in range(n):
        for j in range(n):
            if i != depot_index and j == depot_index:
                heuristics[i,j] = 0 #Except handled in route completion incentives
            if i != depot_index and j != depot_index:
                depot_proximity_penalty = 0.05 * (depot_distances[i] + depot_distances[j]) / mean_depot_distance
                heuristics[i, j] -= depot_proximity_penalty

                #Sparsification based on combined metric relative to averages
                combined_metric = distance_matrix[i, j] * demands[j]
                threshold = np.mean(distance_matrix) * np.mean(demands) * 1.5
                if combined_metric > threshold:
                    heuristics[i, j] = 0

    # 4. Route Completion Incentive
    for i in range(n):
        if i != depot_index:
            heuristics[i, depot_index] += 0.3

    # 5. Depot Connection Boost
    for j in range(1, n):  # Start from 1 to exclude depot itself
        if demands[j] <= capacity:
             heuristics[0, j] += 0.7 # strong boost from depot if demand feasible
        else:
             heuristics[0, j] = 0 # hard prune infeasible depot edges

    # 6. Normalize
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    # 7. Post-processing: Ensure depot has outgoing edges and no incoming edges (except route end).
    for i in range(n):
        if i != depot_index:
            heuristics[depot_index, i] = max(0, heuristics[depot_index, i])

    return heuristics
```
