{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\n### Better code\ndef heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity, angle considerations, k-NN intensification,\n    and adaptive sparsification with refined weight tuning and depot-specific adjustments.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance (foundation)\n    distance_heuristic = 1 / (distance_matrix + 1e-9)\n    heuristics += 0.4 * distance_heuristic  # Base influence\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity: # Directly prune edges that violate capacity constraint.\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i,j] += 0.2  #Depot boost with reduced weight\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route.  Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2*mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty # Increased weight compared to v1\n\n                # Adaptive pruning based on demand and distance.  Less aggressive than v1.\n                if distance_matrix[i, j] > 1.5*np.mean(distance_matrix) and demands[i] + demands[j] > capacity/2: # More strict pruning\n                    heuristics[i,j] = 0\n\n\n    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    # Convert cosine to angle in radians\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) #Ensure within valid range\n\n                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value\n                    heuristics[i,j] += 0.15 * (1 - angle / np.pi) #Increased reward with small angle\n\n    # Heuristic 5: k-NN intensification\n    k = min(5, n - 1)  # Ensure k is not larger than the number of nodes\n    for i in range(n):\n        # Get indices of k-nearest neighbors\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k+1] # Exclude itself\n\n        for neighbor in nearest_neighbors:\n            if i != neighbor:\n                heuristics[i, neighbor] += 0.05  # Small boost to neighbors\n\n    # Heuristic 6: Depot connection preference adjustment\n    for i in range(1, n):\n        heuristics[depot_index, i] += 0.05  # Encourage connections from depot\n        heuristics[i, depot_index] = 0 # ensure no connections from other nodes to depot.\n\n    # Heuristic 7: Sparsification: zero out small heuristic values\n    threshold = 0.005 * np.mean(heuristics) # More aggressive sparsification\n    heuristics[heuristics < threshold] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n### Worse code\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"CVRP heuristics: Combines inverse distance, demand, depot proximity and angle considerations.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i,j] += 0.3 #Depot boost\n            elif i != depot_index and j != depot_index:\n                if demands[i] + demands[j] > capacity:\n                    heuristics[i, j] = 0\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2*mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity/3:\n                    heuristics[i,j] = 0\n\n    # Heuristic 4: Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n                    heuristics[i,j] += 0.1 * (1 - angle / np.pi)\n\n    # Heuristic 5: Sparsification\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n\n    # Heuristic 6: K-Nearest Neighbor\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]\n        for nn in neighbors_idx:\n            heuristics[i, nn] += 0.2\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic incorporates inverse distance, demand/capacity considerations, depot proximity with adaptive pruning and k-NN, angle from depot, and sparsification, while the worst uses only inverse distance, demand-aware pruning, depot proximity, and sparsification. (2nd) vs (19th) shows k-NN dropped. Comparing (1st) vs (2nd), we see they are identical. (3rd) vs (4th) shows the more complex logic with different weighting and aggressive sparsification helps. Comparing (second worst) vs (worst), the second worst included K-NN while the worst does not. Overall: Better heuristics tend to incorporate more features (distance, demand, depot proximity, angles), adaptive pruning/sparsification, and intensification techniques (k-NN). They also carefully manage edge cases and normalize the heuristic values. Simpler heuristics are often outperformed by more complex, well-tuned ones.\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, let's refine self-reflection for designing better heuristics. We need to move beyond just listing techniques and focus on *why* and *how* to apply them effectively.\n\n*   **Keywords:** Adaptive learning, problem-specific knowledge, iterative refinement, evaluation metrics, trade-off analysis.\n*   **Advice:** Frame heuristic design as an iterative learning process driven by problem-specific insights and performance evaluation. Focus on understanding the underlying problem structure.\n*   **Avoid:** Blindly adding features or tuning weights without a clear rationale. Avoid complexity without demonstrated performance improvement.\n*   **Explanation:** Instead of simply stating techniques, emphasize adapting heuristic components based on *observed* performance and a deep understanding of the problem's characteristics.\n\n\nYour task is to write an improved function `heuristics_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}