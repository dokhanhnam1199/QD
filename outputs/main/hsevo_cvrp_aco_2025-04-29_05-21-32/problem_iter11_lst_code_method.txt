{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity and angle considerations with adaptive sparsification and simplified components.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:  # Directly prune edges that violate capacity constraint.\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4  # Depot boost, increased importance\n\n    # Heuristic 3: Depot proximity with adaptive pruning and k-NN\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    k = 5  # Number of nearest neighbors to consider for intensification\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route. Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty  # Increased weight\n\n                # Adaptive pruning based on demand and distance\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                # k-NN intensification:  If j is among the k nearest neighbors of i, boost the heuristic\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]  # Exclude self (i) and depot (0)\n                if j in neighbors:\n                    heuristics[i, j] += 0.2  # k-NN boost\n\n    # Heuristic 4: Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    # Convert cosine to angle in radians\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Ensure within valid range\n\n                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)  # Increased weight\n\n    # Heuristic 5: Sparsification: zero out small heuristic values and edges violating capacity for single vehicle routes.\n    threshold = 0.01 * np.mean(heuristics)  # Adaptive threshold\n    heuristics[heuristics < threshold] = 0\n    for i in range(1, n): # Start from 1 to avoid depot self-loop\n        for j in range(1, n):\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i,depot_index] + distance_matrix[depot_index, j] < 1.5* np.mean(distance_matrix):\n                heuristics[i, j] = 0 # Zero edges exceeding the vehicle capacity. Added proximity check to remove edges where going to depot in between is much shorter\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity and angle considerations with adaptive sparsification and simplified components.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:  # Directly prune edges that violate capacity constraint.\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4  # Depot boost, increased importance\n\n    # Heuristic 3: Depot proximity with adaptive pruning and k-NN\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    k = 5  # Number of nearest neighbors to consider for intensification\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route. Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty  # Increased weight\n\n                # Adaptive pruning based on demand and distance\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                # k-NN intensification:  If j is among the k nearest neighbors of i, boost the heuristic\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]  # Exclude self (i) and depot (0)\n                if j in neighbors:\n                    heuristics[i, j] += 0.2  # k-NN boost\n\n    # Heuristic 4: Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    # Convert cosine to angle in radians\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Ensure within valid range\n\n                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)  # Increased weight\n\n    # Heuristic 5: Sparsification: zero out small heuristic values and edges violating capacity for single vehicle routes.\n    threshold = 0.01 * np.mean(heuristics)  # Adaptive threshold\n    heuristics[heuristics < threshold] = 0\n    for i in range(1, n): # Start from 1 to avoid depot self-loop\n        for j in range(1, n):\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i,depot_index] + distance_matrix[depot_index, j] < 1.5* np.mean(distance_matrix):\n                heuristics[i, j] = 0 # Zero edges exceeding the vehicle capacity. Added proximity check to remove edges where going to depot in between is much shorter\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity and angle considerations with adaptive sparsification and simplified components.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:  # Directly prune edges that violate capacity constraint.\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4  # Depot boost, increased importance\n\n    # Heuristic 3: Depot proximity with adaptive pruning and k-NN\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    k = 5  # Number of nearest neighbors to consider for intensification\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route. Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty  # Increased weight\n\n                # Adaptive pruning based on demand and distance\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                # k-NN intensification:  If j is among the k nearest neighbors of i, boost the heuristic\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]  # Exclude self (i) and depot (0)\n                if j in neighbors:\n                    heuristics[i, j] += 0.2  # k-NN boost\n\n    # Heuristic 4: Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    # Convert cosine to angle in radians\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Ensure within valid range\n\n                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)  # Increased weight\n\n    # Heuristic 5: Sparsification: zero out small heuristic values and edges violating capacity for single vehicle routes.\n    threshold = 0.01 * np.mean(heuristics)  # Adaptive threshold\n    heuristics[heuristics < threshold] = 0\n    for i in range(1, n): # Start from 1 to avoid depot self-loop\n        for j in range(1, n):\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i,depot_index] + distance_matrix[depot_index, j] < 1.5* np.mean(distance_matrix):\n                heuristics[i, j] = 0 # Zero edges exceeding the vehicle capacity. Added proximity check to remove edges where going to depot in between is much shorter\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity, angle considerations, k-NN intensification,\n    and adaptive sparsification with refined weight tuning and depot-specific adjustments.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance (foundation)\n    distance_heuristic = 1 / (distance_matrix + 1e-9)\n    heuristics += 0.4 * distance_heuristic  # Base influence\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity: # Directly prune edges that violate capacity constraint.\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i,j] += 0.2  #Depot boost with reduced weight\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route.  Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2*mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty # Increased weight compared to v1\n\n                # Adaptive pruning based on demand and distance.  Less aggressive than v1.\n                if distance_matrix[i, j] > 1.5*np.mean(distance_matrix) and demands[i] + demands[j] > capacity/2: # More strict pruning\n                    heuristics[i,j] = 0\n\n\n    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    # Convert cosine to angle in radians\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) #Ensure within valid range\n\n                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value\n                    heuristics[i,j] += 0.15 * (1 - angle / np.pi) #Increased reward with small angle\n\n    # Heuristic 5: k-NN intensification\n    k = min(5, n - 1)  # Ensure k is not larger than the number of nodes\n    for i in range(n):\n        # Get indices of k-nearest neighbors\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k+1] # Exclude itself\n\n        for neighbor in nearest_neighbors:\n            if i != neighbor:\n                heuristics[i, neighbor] += 0.05  # Small boost to neighbors\n\n    # Heuristic 6: Depot connection preference adjustment\n    for i in range(1, n):\n        heuristics[depot_index, i] += 0.05  # Encourage connections from depot\n        heuristics[i, depot_index] = 0 # ensure no connections from other nodes to depot.\n\n    # Heuristic 7: Sparsification: zero out small heuristic values\n    threshold = 0.005 * np.mean(heuristics) # More aggressive sparsification\n    heuristics[heuristics < threshold] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity, angle considerations, k-NN intensification,\n    and adaptive sparsification with refined weight tuning and depot-specific adjustments.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance (foundation)\n    distance_heuristic = 1 / (distance_matrix + 1e-9)\n    heuristics += 0.4 * distance_heuristic  # Base influence\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity: # Directly prune edges that violate capacity constraint.\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i,j] += 0.2  #Depot boost with reduced weight\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route.  Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2*mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty # Increased weight compared to v1\n\n                # Adaptive pruning based on demand and distance.  Less aggressive than v1.\n                if distance_matrix[i, j] > 1.5*np.mean(distance_matrix) and demands[i] + demands[j] > capacity/2: # More strict pruning\n                    heuristics[i,j] = 0\n\n\n    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    # Convert cosine to angle in radians\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) #Ensure within valid range\n\n                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value\n                    heuristics[i,j] += 0.15 * (1 - angle / np.pi) #Increased reward with small angle\n\n    # Heuristic 5: k-NN intensification\n    k = min(5, n - 1)  # Ensure k is not larger than the number of nodes\n    for i in range(n):\n        # Get indices of k-nearest neighbors\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k+1] # Exclude itself\n\n        for neighbor in nearest_neighbors:\n            if i != neighbor:\n                heuristics[i, neighbor] += 0.05  # Small boost to neighbors\n\n    # Heuristic 6: Depot connection preference adjustment\n    for i in range(1, n):\n        heuristics[depot_index, i] += 0.05  # Encourage connections from depot\n        heuristics[i, depot_index] = 0 # ensure no connections from other nodes to depot.\n\n    # Heuristic 7: Sparsification: zero out small heuristic values\n    threshold = 0.005 * np.mean(heuristics) # More aggressive sparsification\n    heuristics[heuristics < threshold] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines inverse distance, demand, depot proximity and angle considerations.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i,j] += 0.3 #Depot boost\n            elif i != depot_index and j != depot_index:\n                if demands[i] + demands[j] > capacity:\n                    heuristics[i, j] = 0\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2*mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity/3:\n                    heuristics[i,j] = 0\n\n    # Heuristic 4: Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n                    heuristics[i,j] += 0.1 * (1 - angle / np.pi)\n\n    # Heuristic 5: Sparsification\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n\n    # Heuristic 6: K-Nearest Neighbor\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]\n        for nn in neighbors_idx:\n            heuristics[i, nn] += 0.2\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines inverse distance, demand, depot proximity and angle considerations.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i,j] += 0.3 #Depot boost\n            elif i != depot_index and j != depot_index:\n                if demands[i] + demands[j] > capacity:\n                    heuristics[i, j] = 0\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2*mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity/3:\n                    heuristics[i,j] = 0\n\n    # Heuristic 4: Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n                    heuristics[i,j] += 0.1 * (1 - angle / np.pi)\n\n    # Heuristic 5: Sparsification\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n\n    # Heuristic 6: K-Nearest Neighbor\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]\n        for nn in neighbors_idx:\n            heuristics[i, nn] += 0.2\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines inverse distance, demand, depot proximity and angle considerations.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i,j] += 0.3 #Depot boost\n            elif i != depot_index and j != depot_index:\n                if demands[i] + demands[j] > capacity:\n                    heuristics[i, j] = 0\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2*mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity/3:\n                    heuristics[i,j] = 0\n\n    # Heuristic 4: Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n                    heuristics[i,j] += 0.1 * (1 - angle / np.pi)\n\n    # Heuristic 5: Sparsification\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n\n    # Heuristic 6: K-Nearest Neighbor\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]\n        for nn in neighbors_idx:\n            heuristics[i, nn] += 0.2\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for CVRP: Combines adaptive pruning, demand, depot proximity, angle, and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Depot connection encouragement based on demand and distance\n    for j in range(1, n):  # Iterate over customers (excluding depot)\n        # Encourage connections from the depot to customers\n        if demands[j] <= capacity:  # Only consider if demand is within capacity\n            heuristics[depot_index, j] += 0.5 / (distance_matrix[depot_index, j] + 1e-6)  # Boost, scaled by inverse distance\n            heuristics[j, depot_index] = 0  # no incoming edges to depot except from depot.\n        else:\n            heuristics[depot_index, j] = 0  # prune edges if single demand exceeds capacity.\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route.  Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty  # Reduced weight\n\n                # Adaptive pruning based on demand and distance.  Less aggressive than v1.\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:  # Only prune if nodes have considerable demand compared to vehicle capacity.\n                    heuristics[i, j] = 0\n\n    # Heuristic 4: Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n                    heuristics[i, j] += 0.1 * (1 - angle / np.pi)\n\n    # Heuristic 5: Demand-based Sparsification: Adaptive threshold (Combined metric)\n    mean_distance = np.mean(distance_matrix)\n    mean_demand = np.mean(demands[1:])\n    threshold = mean_distance * mean_demand * 1.5\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            combined_metric = distance_matrix[i, j] * (demands[i] + demands[j])\n\n            if combined_metric > threshold:\n                heuristics[i, j] = 0\n\n    # Heuristic 6: Sparsification: zero out small heuristic values\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for CVRP: Combines adaptive pruning, demand, depot proximity, angle, and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Depot connection encouragement based on demand and distance\n    for j in range(1, n):  # Iterate over customers (excluding depot)\n        # Encourage connections from the depot to customers\n        if demands[j] <= capacity:  # Only consider if demand is within capacity\n            heuristics[depot_index, j] += 0.5 / (distance_matrix[depot_index, j] + 1e-6)  # Boost, scaled by inverse distance\n            heuristics[j, depot_index] = 0  # no incoming edges to depot except from depot.\n        else:\n            heuristics[depot_index, j] = 0  # prune edges if single demand exceeds capacity.\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route.  Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty  # Reduced weight\n\n                # Adaptive pruning based on demand and distance.  Less aggressive than v1.\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:  # Only prune if nodes have considerable demand compared to vehicle capacity.\n                    heuristics[i, j] = 0\n\n    # Heuristic 4: Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n                    heuristics[i, j] += 0.1 * (1 - angle / np.pi)\n\n    # Heuristic 5: Demand-based Sparsification: Adaptive threshold (Combined metric)\n    mean_distance = np.mean(distance_matrix)\n    mean_demand = np.mean(demands[1:])\n    threshold = mean_distance * mean_demand * 1.5\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            combined_metric = distance_matrix[i, j] * (demands[i] + demands[j])\n\n            if combined_metric > threshold:\n                heuristics[i, j] = 0\n\n    # Heuristic 6: Sparsification: zero out small heuristic values\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for CVRP: Combines adaptive pruning, demand, depot proximity, angle, and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Depot connection encouragement based on demand and distance\n    for j in range(1, n):  # Iterate over customers (excluding depot)\n        # Encourage connections from the depot to customers\n        if demands[j] <= capacity:  # Only consider if demand is within capacity\n            heuristics[depot_index, j] += 0.5 / (distance_matrix[depot_index, j] + 1e-6)  # Boost, scaled by inverse distance\n            heuristics[j, depot_index] = 0  # no incoming edges to depot except from depot.\n        else:\n            heuristics[depot_index, j] = 0  # prune edges if single demand exceeds capacity.\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route.  Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty  # Reduced weight\n\n                # Adaptive pruning based on demand and distance.  Less aggressive than v1.\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:  # Only prune if nodes have considerable demand compared to vehicle capacity.\n                    heuristics[i, j] = 0\n\n    # Heuristic 4: Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n                    heuristics[i, j] += 0.1 * (1 - angle / np.pi)\n\n    # Heuristic 5: Demand-based Sparsification: Adaptive threshold (Combined metric)\n    mean_distance = np.mean(distance_matrix)\n    mean_demand = np.mean(demands[1:])\n    threshold = mean_distance * mean_demand * 1.5\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            combined_metric = distance_matrix[i, j] * (demands[i] + demands[j])\n\n            if combined_metric > threshold:\n                heuristics[i, j] = 0\n\n    # Heuristic 6: Sparsification: zero out small heuristic values\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, adaptive sparsification, and route completion.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # 1. Inverse Distance Component\n    inverse_distance = 1 / (distance_matrix + 1e-9)\n    heuristics += inverse_distance\n\n    # 2. Demand Consideration and Hard Pruning\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n            if i == depot_index and demands[j] > capacity:\n                heuristics[i, j] = 0  # Prune infeasible edges from depot\n            elif i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and j==depot_index:\n                heuristics[i,j] = 0 # Prune edges exceeding capacity towards the depot.\n\n    # 3. Depot Proximity Incentive (Adaptive Scaling)\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances) + 1e-9\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i,j] = 0 #Except handled in route completion incentives\n            if i != depot_index and j != depot_index:\n                depot_proximity_penalty = 0.05 * (depot_distances[i] + depot_distances[j]) / mean_depot_distance\n                heuristics[i, j] -= depot_proximity_penalty\n\n                #Sparsification based on combined metric relative to averages\n                combined_metric = distance_matrix[i, j] * demands[j]\n                threshold = np.mean(distance_matrix) * np.mean(demands) * 1.5\n                if combined_metric > threshold:\n                    heuristics[i, j] = 0\n\n    # 4. Route Completion Incentive\n    for i in range(n):\n        if i != depot_index:\n            heuristics[i, depot_index] += 0.3\n\n    # 5. Depot Connection Boost\n    for j in range(1, n):  # Start from 1 to exclude depot itself\n        if demands[j] <= capacity:\n             heuristics[0, j] += 0.7 # strong boost from depot if demand feasible\n        else:\n             heuristics[0, j] = 0 # hard prune infeasible depot edges\n\n    # 6. Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    # 7. Post-processing: Ensure depot has outgoing edges and no incoming edges (except route end).\n    for i in range(n):\n        if i != depot_index:\n            heuristics[depot_index, i] = max(0, heuristics[depot_index, i])\n\n    return heuristics\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, adaptive sparsification, and route completion.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # 1. Inverse Distance Component\n    inverse_distance = 1 / (distance_matrix + 1e-9)\n    heuristics += inverse_distance\n\n    # 2. Demand Consideration and Hard Pruning\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n            if i == depot_index and demands[j] > capacity:\n                heuristics[i, j] = 0  # Prune infeasible edges from depot\n            elif i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and j==depot_index:\n                heuristics[i,j] = 0 # Prune edges exceeding capacity towards the depot.\n\n    # 3. Depot Proximity Incentive (Adaptive Scaling)\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances) + 1e-9\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i,j] = 0 #Except handled in route completion incentives\n            if i != depot_index and j != depot_index:\n                depot_proximity_penalty = 0.05 * (depot_distances[i] + depot_distances[j]) / mean_depot_distance\n                heuristics[i, j] -= depot_proximity_penalty\n\n                #Sparsification based on combined metric relative to averages\n                combined_metric = distance_matrix[i, j] * demands[j]\n                threshold = np.mean(distance_matrix) * np.mean(demands) * 1.5\n                if combined_metric > threshold:\n                    heuristics[i, j] = 0\n\n    # 4. Route Completion Incentive\n    for i in range(n):\n        if i != depot_index:\n            heuristics[i, depot_index] += 0.3\n\n    # 5. Depot Connection Boost\n    for j in range(1, n):  # Start from 1 to exclude depot itself\n        if demands[j] <= capacity:\n             heuristics[0, j] += 0.7 # strong boost from depot if demand feasible\n        else:\n             heuristics[0, j] = 0 # hard prune infeasible depot edges\n\n    # 6. Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    # 7. Post-processing: Ensure depot has outgoing edges and no incoming edges (except route end).\n    for i in range(n):\n        if i != depot_index:\n            heuristics[depot_index, i] = max(0, heuristics[depot_index, i])\n\n    return heuristics\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines inverse distance, demand, depot proximity, k-NN, and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Demand consideration and depot boost\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n            if i == depot_index and j != depot_index:\n                if capacity - demands[j] < 0:\n                    heuristics[i, j] = 0  # Prune infeasible edges\n                else:\n                    heuristics[i, j] += 0.5  # depot boost\n            elif i != depot_index and j == depot_index:\n                heuristics[i, j] += 0.1\n\n    # Depot proximity boost\n    depot_distances = distance_matrix[:, depot_index]\n    for i in range(n):\n        if i != depot_index:\n            heuristics[i, depot_index] += 0.2 * (1 / (depot_distances[i] + 1e-9))\n\n    # K-Nearest Neighbor Bonus\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]\n        for neighbor in neighbors_idx:\n            heuristics[i, neighbor] += 0.3\n\n    # Adaptive Sparsification based on mean and demand\n    mean_heuristic = np.mean(heuristics)\n    for i in range(n):\n        for j in range(n):\n            combined_metric = distance_matrix[i, j] * (demands[i] + demands[j] + 1e-9)\n            if heuristics[i, j] < mean_heuristic or combined_metric > np.mean(distance_matrix) * np.mean(demands) * 1.5:\n                heuristics[i, j] = 0\n\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines inverse distance, demand, depot proximity, angle, sparsification.\"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    distance_heuristic = 1 / (distance_matrix + 1e-9)\n    heuristics += distance_heuristic * 0.5\n\n    # Heuristic 2: Demand consideration and Depot Connection\n    demand_distance_heuristic = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_distance_heuristic[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity >= 0:\n                    demand_distance_heuristic[i, j] = 0.7\n                else:\n                    demand_distance_heuristic[i, j] = 0\n\n            elif i != depot_index and j == depot_index:\n                  demand_distance_heuristic[i,j] = 0\n            elif i != depot_index and j!= depot_index:\n                demand_distance_heuristic[i,j] = 1/(distance_matrix[i,j] * demands[j] + 1e-9)\n\n    heuristics += demand_distance_heuristic * 0.4\n\n    #Heuristic 3: Angle from Depot\n    angle_heuristic = np.zeros_like(distance_matrix)\n\n    for i in range(n):\n        for j in range(n):\n            if i == depot_index or j == depot_index or i ==j:\n                angle_heuristic[i,j] = 0\n                continue\n\n            # Calculate angles between the depot and the two nodes\n            vector_i = coordinates[i] - coordinates[depot_index]\n            vector_j = coordinates[j] - coordinates[depot_index]\n\n            #Calculate angle between vectors\n            norm_i = np.linalg.norm(vector_i)\n            norm_j = np.linalg.norm(vector_j)\n\n            if norm_i == 0 or norm_j == 0:\n                angle = 0\n            else:\n\n                dot_product = np.dot(vector_i, vector_j)\n                cos_angle = dot_product / (norm_i * norm_j)\n                angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) # Clip for numerical stability\n\n\n\n            angle_heuristic[i,j] = 1- (angle / np.pi)  # Smaller angle is better\n\n\n    heuristics += angle_heuristic * 0.1\n\n    # Sparsification\n    threshold = np.mean(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i != j and distance_matrix[i,j] > threshold * 2 :\n                heuristics[i, j] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines inverse distance, demand, depot proximity, angle, sparsification.\"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    distance_heuristic = 1 / (distance_matrix + 1e-9)\n    heuristics += distance_heuristic * 0.5\n\n    # Heuristic 2: Demand consideration and Depot Connection\n    demand_distance_heuristic = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_distance_heuristic[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity >= 0:\n                    demand_distance_heuristic[i, j] = 0.7\n                else:\n                    demand_distance_heuristic[i, j] = 0\n\n            elif i != depot_index and j == depot_index:\n                  demand_distance_heuristic[i,j] = 0\n            elif i != depot_index and j!= depot_index:\n                demand_distance_heuristic[i,j] = 1/(distance_matrix[i,j] * demands[j] + 1e-9)\n\n    heuristics += demand_distance_heuristic * 0.4\n\n    #Heuristic 3: Angle from Depot\n    angle_heuristic = np.zeros_like(distance_matrix)\n\n    for i in range(n):\n        for j in range(n):\n            if i == depot_index or j == depot_index or i ==j:\n                angle_heuristic[i,j] = 0\n                continue\n\n            # Calculate angles between the depot and the two nodes\n            vector_i = coordinates[i] - coordinates[depot_index]\n            vector_j = coordinates[j] - coordinates[depot_index]\n\n            #Calculate angle between vectors\n            norm_i = np.linalg.norm(vector_i)\n            norm_j = np.linalg.norm(vector_j)\n\n            if norm_i == 0 or norm_j == 0:\n                angle = 0\n            else:\n\n                dot_product = np.dot(vector_i, vector_j)\n                cos_angle = dot_product / (norm_i * norm_j)\n                angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) # Clip for numerical stability\n\n\n\n            angle_heuristic[i,j] = 1- (angle / np.pi)  # Smaller angle is better\n\n\n    heuristics += angle_heuristic * 0.1\n\n    # Sparsification\n    threshold = np.mean(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i != j and distance_matrix[i,j] > threshold * 2 :\n                heuristics[i, j] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines distance, demand, depot proximity, angle, adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    distance_heuristic = 1 / (distance_matrix + 1e-9)\n    heuristics += distance_heuristic * 0.5\n\n    # Demand and Depot Connection\n    demand_distance_heuristic = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if i == depot_index:\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity >= 0:\n                    demand_distance_heuristic[i, j] = 0.7\n                else:\n                    demand_distance_heuristic[i, j] = 0\n            elif i != depot_index and j == depot_index:\n                  demand_distance_heuristic[i,j] = 0\n            else:\n                demand_distance_heuristic[i,j] = 1/(distance_matrix[i,j] * demands[j] + 1e-9)\n\n    heuristics += demand_distance_heuristic * 0.4\n\n    # Angle from Depot\n    angle_heuristic = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i == depot_index or j == depot_index or i ==j:\n                angle_heuristic[i,j] = 0\n                continue\n\n            vector_i = coordinates[i] - coordinates[depot_index]\n            vector_j = coordinates[j] - coordinates[depot_index]\n\n            norm_i = np.linalg.norm(vector_i)\n            norm_j = np.linalg.norm(vector_j)\n\n            if norm_i == 0 or norm_j == 0:\n                angle = 0\n            else:\n                dot_product = np.dot(vector_i, vector_j)\n                cos_angle = dot_product / (norm_i * norm_j)\n                angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n            angle_heuristic[i,j] = 1- (angle / np.pi)\n\n    heuristics += angle_heuristic * 0.1\n\n    # Adaptive Sparsification\n    threshold = np.mean(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i != j and distance_matrix[i,j] > threshold * 2 :\n                heuristics[i, j] = 0\n\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines distance, demand, depot proximity, angle, adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    distance_heuristic = 1 / (distance_matrix + 1e-9)\n    heuristics += distance_heuristic * 0.5\n\n    # Demand and Depot Connection\n    demand_distance_heuristic = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if i == depot_index:\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity >= 0:\n                    demand_distance_heuristic[i, j] = 0.7\n                else:\n                    demand_distance_heuristic[i, j] = 0\n            elif i != depot_index and j == depot_index:\n                  demand_distance_heuristic[i,j] = 0\n            else:\n                demand_distance_heuristic[i,j] = 1/(distance_matrix[i,j] * demands[j] + 1e-9)\n\n    heuristics += demand_distance_heuristic * 0.4\n\n    # Angle from Depot\n    angle_heuristic = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i == depot_index or j == depot_index or i ==j:\n                angle_heuristic[i,j] = 0\n                continue\n\n            vector_i = coordinates[i] - coordinates[depot_index]\n            vector_j = coordinates[j] - coordinates[depot_index]\n\n            norm_i = np.linalg.norm(vector_i)\n            norm_j = np.linalg.norm(vector_j)\n\n            if norm_i == 0 or norm_j == 0:\n                angle = 0\n            else:\n                dot_product = np.dot(vector_i, vector_j)\n                cos_angle = dot_product / (norm_i * norm_j)\n                angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n            angle_heuristic[i,j] = 1- (angle / np.pi)\n\n    heuristics += angle_heuristic * 0.1\n\n    # Adaptive Sparsification\n    threshold = np.mean(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i != j and distance_matrix[i,j] > threshold * 2 :\n                heuristics[i, j] = 0\n\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 19th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines inverse distance, demand penalty, k-NN, and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Inverse distance\n    heuristic_matrix = 1 / (distance_matrix + 1e-9)\n\n    # Demand penalty\n    demand_penalty = np.zeros(n)\n    for i in range(1, n):\n      demand_penalty[i] = demands[i] / capacity\n\n    for i in range(n):\n      for j in range(n):\n        if i == j:\n          heuristic_matrix[i, j] = 0\n        else:\n            heuristic_matrix[i,j] /= (1 + 0.5*demand_penalty[i] + 0.5*demand_penalty[j]) # Penalize high demand\n\n\n    # K-Nearest Neighbor\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i,:])[1:k_nearest_neighbors+1]\n        for nn in neighbors_idx:\n            heuristic_matrix[i,nn] += 0.2\n\n    # Sparsify (adaptive threshold)\n    heuristic_mean = np.mean(heuristic_matrix[heuristic_matrix > 0])\n    heuristic_matrix[heuristic_matrix < 0.5 * heuristic_mean] = 0\n\n    # Depot proximity boost and capacity check\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if i == 0:\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity <= 0:\n                    heuristic_matrix[i, j] = 0 # Hard constraint\n\n                heuristic_matrix[i,j] += 0.4\n\n    # Normalize\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix = heuristic_matrix / max_heuristic\n\n    return heuristic_matrix\n\n[Heuristics 20th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines inverse distance, demand-aware pruning, depot proximity, and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Demand-aware pruning\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n            if i == depot_index and j != depot_index:\n                if capacity - demands[j] < 0:\n                    heuristics[i, j] = 0  # Infeasible edge\n\n    # Depot proximity\n    depot_distances = distance_matrix[:, depot_index]\n    for i in range(n):\n        if i != depot_index:\n            heuristics[i, depot_index] += 0.1 * (1 / (depot_distances[i] + 1e-9))\n\n    # Sparsification\n    threshold = np.mean(heuristics) * 0.2\n    heuristics[heuristics < threshold] = 0\n\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}