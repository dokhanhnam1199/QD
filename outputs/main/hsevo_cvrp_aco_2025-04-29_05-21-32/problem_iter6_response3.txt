```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates demand, distance, depot proximity and angle considerations with sparsification and adaptive weighting.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Heuristic 1: Basic inverse distance
    distance_heuristic = 1 / (distance_matrix + 1e-9)
    heuristics += distance_heuristic * 0.6  # Base contribution from distance

    # Heuristic 2: Demand consideration and Depot Connection
    demand_distance_heuristic = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_distance_heuristic[i, j] = 0
                continue

            if i == depot_index and j != depot_index:
                remaining_capacity = capacity - demands[j]
                if remaining_capacity >= 0:
                    demand_distance_heuristic[i, j] = 0.7  # Initial Depot Boost
                else:
                    demand_distance_heuristic[i, j] = 0  # Prune unpromising edges from depot

            elif i != depot_index and j == depot_index:
                  demand_distance_heuristic[i,j] = 0  # No edges to depot except from depot
            elif i != depot_index and j!= depot_index:
                demand_distance_heuristic[i,j] = 1/(distance_matrix[i,j] * demands[j] + 1e-9)

    heuristics += demand_distance_heuristic * 0.4


    #Heuristic 3: Angle from Depot
    angle_heuristic = np.zeros_like(distance_matrix)

    for i in range(n):
        for j in range(n):
            if i == depot_index or j == depot_index or i ==j:
                angle_heuristic[i,j] = 0
                continue

            # Calculate angles between the depot and the two nodes
            vector_i = coordinates[i] - coordinates[depot_index]
            vector_j = coordinates[j] - coordinates[depot_index]

            #Calculate angle between vectors
            norm_i = np.linalg.norm(vector_i)
            norm_j = np.linalg.norm(vector_j)

            if norm_i == 0 or norm_j == 0:
                angle = 0
            else:

                dot_product = np.dot(vector_i, vector_j)
                cos_angle = dot_product / (norm_i * norm_j)
                angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) # Clip for numerical stability



            angle_heuristic[i,j] = 1- (angle / np.pi)  # Smaller angle is better


    heuristics += angle_heuristic * 0.1


    # Heuristic 4: Sparsification
    threshold = np.mean(distance_matrix) # Adaptive Threshold
    for i in range(n):
        for j in range(n):
            if i != j and distance_matrix[i,j] > threshold * 2 : # More Aggressive
                heuristics[i, j] = 0

    # Normalize
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```
