```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Adaptive heuristics using distance, demand, depot proximity, and k-NN."""
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # 1. Cost-Based Prioritization (Distance and Demand)
    cost_matrix = distance_matrix + (demands[:, None] + demands[None, :]) / capacity * np.mean(distance_matrix)
    heuristics = 1 / (cost_matrix + 1e-9)

    # 2. Depot Influence
    depot_distances = distance_matrix[:, depot_index]
    for i in range(1, n):
        heuristics[depot_index, i] += 0.2 * (1 - depot_distances[i] / np.max(depot_distances))
        heuristics[i, depot_index] = 0  # Block return trip except from depot

    # 3. k-NN with adaptive k
    knn_base = 4
    knn_weight = 0.15
    node_densities = np.zeros(n)
    for i in range(1, n):
        distances_from_i = distance_matrix[i, 1:]
        nearest_neighbors_dist = np.sort(distances_from_i)[:min(knn_base, n - 1)]
        node_densities[i] = np.mean(nearest_neighbors_dist)
    mean_node_density = np.mean(node_densities[1:])

    for i in range(1, n):
        adaptive_knn = int(knn_base * (mean_node_density / (node_densities[i] + 1e-9)))
        adaptive_knn = max(1, min(adaptive_knn, n - 1))
        distances_from_i = distance_matrix[i, 1:]
        nearest_neighbors = np.argsort(distances_from_i)[:adaptive_knn] + 1
        for j in nearest_neighbors:
            heuristics[i, j] += knn_weight
            heuristics[j, i] += knn_weight
    #4 sparsification
    sparsification_percentile = 35
    threshold = np.percentile(heuristics[heuristics > 0], sparsification_percentile)
    heuristics[heuristics < threshold] = 0

    # 5. Normalization
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```
