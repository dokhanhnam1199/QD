{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\n### Better code\ndef heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version prioritizes routes based on a combination of distance, demand, and depot proximity,\n    with adaptive sparsification and route completion incentives.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # 1. Inverse Distance with a base value\n    base_heuristic = 1 / (distance_matrix + 1e-9)\n    heuristics += base_heuristic\n\n    # 2. Demand and Capacity Consideration:\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            # Depot connection boost\n            if i == depot_index and j != depot_index:\n                if demands[j] <= capacity:  # Only allow depot starts if demand is within capacity.\n                    heuristics[i, j] += 0.7 # stronger boost for edges *from* the depot.\n                else:\n                    heuristics[i, j] = 0  # Infeasible edges from depot are pruned\n\n            # Prune edges that would immediately violate capacity\n            elif i != depot_index and j != depot_index:\n                 if demands[i] + demands[j] > capacity and i != depot_index and j == depot_index:\n                    heuristics[i,j] = 0 # remove edges to depot if combined demand is violated from the current node\n\n    # 3. Depot Proximity Incentive (with adaptive scaling):\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances) + 1e-9\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n              heuristics[i,j] = 0\n            if i != depot_index and j != depot_index:\n                depot_proximity_penalty = 0.05 * (depot_distances[i] + depot_distances[j]) / mean_depot_distance\n                heuristics[i, j] -= depot_proximity_penalty\n                 # Sparsification based on combined distance and demand relative to averages\n                combined_metric = distance_matrix[i, j] * demands[j]\n                threshold = np.mean(distance_matrix) * np.mean(demands) * 1.5  # Adjusted threshold\n                if combined_metric > threshold:\n                   heuristics[i, j] = 0\n\n    # 4. Route Completion Incentive: Encourages closing routes back to the depot.\n    for i in range(n):\n        if i != depot_index:\n            heuristics[i, depot_index] += 0.3 # Incentivize returns to depot, making CVRP a little more like TSP\n\n    # 5. Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    # Post-processing: Ensure depot has outgoing edges and no incoming edges (except from the route end).\n    for i in range(n):\n        if i != depot_index:\n            heuristics[depot_index, i] = max(0, heuristics[depot_index, i])\n            heuristics[i, depot_index] = 0  # Except handled in route completion incentives\n    return heuristics\n\n### Worse code\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Inverse distance component\n    inverse_distance = 1 / (distance_matrix + 1e-9)\n\n    # Demand penalty\n    demand_penalty = np.ones_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                if demands[i] + demands[j] > capacity:\n                    demand_penalty[i, j] = 0.1 # Penalize edges exceeding capacity\n\n    # Depot proximity component\n    depot_proximity = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        depot_proximity[0, i] = 1 / (distance_matrix[0, i] + 1e-9)\n        depot_proximity[i, 0] = 1 / (distance_matrix[i, 0] + 1e-9)\n\n    # Combine components\n    heuristics = inverse_distance * demand_penalty + depot_proximity\n\n    # Sparsification (remove less promising edges)\n    threshold = np.mean(heuristics) * 0.2  # Dynamic threshold\n    heuristics[heuristics < threshold] = 0\n\n    # Normalize\n    heuristics = heuristics / np.max(heuristics) if np.max(heuristics) > 0 else heuristics\n\n    return heuristics\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the top heuristic uses depot proximity with adaptive pruning, angle from depot, and sparsification based on the mean of heuristic values, while the bottom heuristic relies on inverse distance, demand consideration, depot proximity, k-NN, and sparsification using a quantile-based threshold. The top heuristic also focuses on pruning infeasible edges related to capacity early on.\nComparing (2nd best) vs (2nd worst), the second-best also contains depot proximity, angle from depot, and sparsification but lacks the explicit adaptive pruning based on capacity constraints. The second-worst only calculates demand penalty instead of hard pruning edges.\nComparing (1st) vs (2nd), we see the top heuristic includes stronger depot connection boosts and considers a normalized angle reward, while the second heuristic omits the route completion incentive.\nComparing (3rd) vs (4th), the 3rd and 4th heuristic are similar, but the 4th heuristic incorporates route completion incentives, stronger depot connection boosts, and a more sophisticated sparsification approach based on combined distance and demand. Comparing (second worst) vs (worst), both functions are virtually identical. Overall: The better heuristics incorporate more nuanced adaptive sparsification techniques (based on means and combined metrics), depot proximity and angle considerations and prioritize pruning infeasible edges.\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, let's refine \"Current self-reflection\" for designing better heuristics, avoiding the pitfalls of \"Ineffective self-reflection\" (which is currently empty, implying all current reflections are potentially valuable). Here's a redefinition:\n\n*   **Keywords:** Adaptive pruning, problem constraints, factor combinations (distance, demand, angles), normalization, iterative refinement, k-NN intensification, sparsification, depot-specific adjustments, weight tuning.\n*   **Advice:** Begin with simple, intuitive heuristics. Incrementally add sophistication (k-NN, sparsification, depot adjustments) while prioritizing weight tuning for parameter control and balance.\n*   **Avoid:** Overly complex combinations or excessively specific calculations early on. Prematurely dismissing the value of weight optimization.\n*   **Explanation:** Start simple, normalize to stabilize, adapt based on problem constraints, tune weights to balance factors, and iteratively improve the heuristic's components.\n\n\nYour task is to write an improved function `heuristics_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}