{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Improved heuristics for CVRP, combining distance, savings, demand, and coordinates.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings based on Clarke-Wright algorithm\n    savings_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Incorporate distance and savings\n    heuristic_matrix = (1 / distance_matrix + savings_matrix / np.max(savings_matrix)) #avoiding infs/NaNs\n\n    # Penalize edges connecting to nodes with high demand relative to capacity\n    demand_penalty = np.zeros(n)\n    for i in range(1, n):\n      demand_penalty[i] = demands[i] / capacity\n\n    for i in range(n):\n      for j in range(n):\n        if i == j:\n          heuristic_matrix[i, j] = 0 #ensure no loops\n        else:\n            heuristic_matrix[i,j] /= (1 + demand_penalty[i] + demand_penalty[j]) #slightly penalize high demand nodes\n\n    #Prioritize connecting nodes that are close in coordinate space. This can help exploit locality.\n    coordinate_distances = np.zeros_like(distance_matrix)\n    for i in range(n):\n      for j in range(n):\n        coordinate_distances[i,j] = np.linalg.norm(coordinates[i] - coordinates[j])\n\n    heuristic_matrix += (1/coordinate_distances) #prefer edges with small coordinate distance\n    heuristic_matrix[np.isinf(heuristic_matrix)] = 0  # Remove any potential infinities created by division by zero on diagonals.\n    heuristic_matrix[np.isnan(heuristic_matrix)] = 0 # Clean NaN values\n\n    #Add depot proximity component\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                depot_proximity_component = (1 - (depot_distances[i] + depot_distances[j]) / (2 * max_depot_distance))\n                heuristic_matrix[i, j] += 0.1 * depot_proximity_component # Weight of 0.1\n    return heuristic_matrix\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}