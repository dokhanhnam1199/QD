```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several factors to estimate the desirability of including an edge:
    - Inverse distance (as in v1)
    - Savings heuristic component
    - Demand considerations: penalty for connecting nodes that, when added to a route,
      make it difficult to add more nodes without exceeding capacity.  Favors
      connections that keep remaining route capacity flexible.
    - Depot proximity:  Favors edges connecting customers to the depot, especially for
      customers with high demand, as it's more likely they'll need a dedicated route.
    - Randomness: Add a small amount of randomness to break symmetry and encourage exploration.

    Args:
        distance_matrix: Distance matrix (shape: n by n).
        coordinates: Euclidean coordinates of nodes (shape: n by 2).
        demands: Customer demands (shape: n).
        capacity: Vehicle capacity.

    Returns:
        Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Inverse distance component (baseline)
    inverse_distance = 1 / (distance_matrix + 1e-6)  # Add small constant to avoid division by zero

    # Savings heuristic component
    savings = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings[j, i] = savings[i, j]  # Savings matrix is symmetric
    
    # Demand-based penalty and depot proximity
    demand_penalty = np.zeros((n, n))
    depot_attraction = np.zeros((n, n))
    
    avg_demand = np.mean(demands[1:])  #average demand of the customers

    for i in range(1, n):
        for j in range(1, n):  #Demand based penality is only meaningful for edges between customers.
            if i == j:
                continue

            combined_demand_fraction = (demands[i] + demands[j]) / capacity
            # Apply high penalty if edge contributes to using most of the capacity
            # penalize connections that lead to small remainder, as there will not be much choice left.
            remaining_capacity = capacity - demands[i] - demands[j]
            # remaining_fraction = remaining_capacity / capacity

            demand_penalty[i, j] = (combined_demand_fraction + (1- np.exp(-remaining_capacity/avg_demand)) )

        #Favor connections to the depot, especially high-demand.
        depot_attraction[0, i] = demands[i] / capacity #scale by demand
        depot_attraction[i, 0] = depot_attraction[0, i]

    # Combine the components with weights
    heuristics = (
        0.5 * inverse_distance
        + 0.3 * savings
        - 0.1 * demand_penalty
        + 0.2 * depot_attraction
        + 0.01 * np.random.rand(n, n)  # Add a bit of randomness
    )

    return heuristics
```
