{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for CVRP edge selection, considering distance, demand, and vehicle capacity.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Demand of each node (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising each edge is (n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Start with inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero\n\n    # Modify based on demand and proximity to depot\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0  # No self-loops\n\n            # Penalize edges that might overload vehicles\n            avg_demand = (demands[i] + demands[j]) / 2\n            if avg_demand > capacity / 3:  # Adjusted threshold\n                heuristics[i, j] *= 0.5 # Moderate Penalization\n\n            # Reward edges closer to the depot to encourage route starts near the depot\n            depot_distance_penalty = 0.0\n            depot_distance_penalty = (distance_matrix[0, i] + distance_matrix[0, j]) / (2 * np.mean(distance_matrix))\n\n            heuristics[i, j] /= (1 + depot_distance_penalty)  # The closer to depot, the larger the divisor\n\n            # Encourage edges leading away from the depot initially.\n            # After the first vehicle visit some customers, it may return to the depot again.\n            # Thus we focus more on connecting customers instead of returning depot.\n            # initial_reward = np.exp(-distance_matrix[0,i] * distance_matrix[0,j]/(np.mean(distance_matrix)**2))\n            # heuristics[i,j] *= (1 + initial_reward)\n\n    # Normalize heuristics (optional, but can improve performance)\n    heuristics = heuristics / np.max(heuristics)\n\n    return heuristics\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix (shape: n by n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (same shape as distance_matrix).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings based on Clarke-Wright algorithm\n    savings_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Incorporate distance and savings\n    heuristic_matrix = (1 / distance_matrix + savings_matrix / np.max(savings_matrix)) #avoiding infs/NaNs\n\n    # Penalize edges connecting to nodes with high demand relative to capacity\n    demand_penalty = np.zeros(n)\n    for i in range(1, n):\n      demand_penalty[i] = demands[i] / capacity\n\n    for i in range(n):\n      for j in range(n):\n        if i == j:\n          heuristic_matrix[i, j] = 0 #ensure no loops\n        else:\n            heuristic_matrix[i,j] /= (1 + demand_penalty[i] + demand_penalty[j]) #slightly penalize high demand nodes\n\n    #Prioritize connecting nodes that are close in coordinate space. This can help exploit locality.\n    coordinate_distances = np.zeros_like(distance_matrix)\n    for i in range(n):\n      for j in range(n):\n        coordinate_distances[i,j] = np.linalg.norm(coordinates[i] - coordinates[j])\n\n    heuristic_matrix += (1/coordinate_distances) #prefer edges with small coordinate distance\n    heuristic_matrix[np.isinf(heuristic_matrix)] = 0  # Remove any potential infinities created by division by zero on diagonals.\n    heuristic_matrix[np.isnan(heuristic_matrix)] = 0 # Clean NaN values\n\n    return heuristic_matrix\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix (shape: n by n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (same shape as distance_matrix).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings based on Clarke-Wright algorithm\n    savings_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Incorporate distance and savings\n    heuristic_matrix = (1 / distance_matrix + savings_matrix / np.max(savings_matrix)) #avoiding infs/NaNs\n\n    # Penalize edges connecting to nodes with high demand relative to capacity\n    demand_penalty = np.zeros(n)\n    for i in range(1, n):\n      demand_penalty[i] = demands[i] / capacity\n\n    for i in range(n):\n      for j in range(n):\n        if i == j:\n          heuristic_matrix[i, j] = 0 #ensure no loops\n        else:\n            heuristic_matrix[i,j] /= (1 + demand_penalty[i] + demand_penalty[j]) #slightly penalize high demand nodes\n\n    #Prioritize connecting nodes that are close in coordinate space. This can help exploit locality.\n    coordinate_distances = np.zeros_like(distance_matrix)\n    for i in range(n):\n      for j in range(n):\n        coordinate_distances[i,j] = np.linalg.norm(coordinates[i] - coordinates[j])\n\n    heuristic_matrix += (1/coordinate_distances) #prefer edges with small coordinate distance\n    heuristic_matrix[np.isinf(heuristic_matrix)] = 0  # Remove any potential infinities created by division by zero on diagonals.\n    heuristic_matrix[np.isnan(heuristic_matrix)] = 0 # Clean NaN values\n\n    return heuristic_matrix\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP) using a combination of distance, demand, and node proximity to depot.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Customer demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Parameters for tuning the heuristic (adjust as needed)\n    distance_weight = 1.0  # Weight for distance\n    demand_weight = 0.5    # Weight for demand (penalizes high demand)\n    depot_proximity_weight = 0.2  # Weight for proximity to the depot\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n            else:\n                # Heuristic based on a combination of factors\n                distance_factor = distance_weight / (distance_matrix[i, j] + 1e-6)  # Avoid division by zero\n                demand_factor = np.exp(-demand_weight * (demands[i] + demands[j]) / capacity)  # Penalize high demand\n                depot_proximity_i = np.exp(-depot_proximity_weight * distance_matrix[i, 0] / np.mean(distance_matrix))\n                depot_proximity_j = np.exp(-depot_proximity_weight * distance_matrix[j, 0] / np.mean(distance_matrix))\n                depot_proximity_factor = (depot_proximity_i + depot_proximity_j) / 2  # average proximity\n\n                heuristic_matrix[i, j] = distance_factor * demand_factor * depot_proximity_factor # Combine\n\n    return heuristic_matrix\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for CVRP using a combination of distance, demand, and angular considerations.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Customer demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Edge prior indicators (n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Parameters to tune\n    alpha = 1.0  # Distance weight\n    beta = 0.5  # Demand weight\n    gamma = 0.2  # Angular weight (relative to depot)\n\n    # Calculate angles relative to the depot (node 0)\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0  # No self-loops\n            else:\n                # Distance component: inversely proportional to distance\n                distance_component = 1 / distance_matrix[i, j]\n\n                # Demand component: penalize edges connecting high-demand nodes (encourage balanced routes)\n                demand_component = 1 / (demands[i] + demands[j] + 1e-6) #Adding a small value to avoid division by zero\n\n                # Angular component: Favor edges that maintain angular progression from the depot.\n                # Encourage exploration and avoid immediately returning to depot unless necessary.\n                angle_diff = np.abs(angles[i] - angles[j])\n                angular_component = 1 / (angle_diff + 0.1)  # Penalize large angle changes (smooth route transitions)\n                if i==0:\n                  angular_component=1 # always prioritize connection to depot\n\n                # Combine components with weights\n                heuristics[i, j] = (\n                    alpha * distance_component\n                    + beta * demand_component\n                    + gamma * angular_component\n                )\n\n    return heuristics\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristic function for CVRP that considers distance, demand, and angle.\n\n    Args:\n        distance_matrix: Distance between nodes (n x n).\n        coordinates: Euclidean coordinates of nodes (n x 2).\n        demands: Demand of each node (n).\n        capacity: Vehicle capacity.\n\n    Returns:\n        A matrix of heuristics values (n x n), where higher values indicate more promising edges.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Depot coordinates\n    depot_x, depot_y = coordinates[0]\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n\n            # Distance-based heuristic (shorter distances are better)\n            distance_heuristic = 1 / (distance_matrix[i, j] + 1e-6) #Adding a tiny constant to avoid divide by zero error\n\n            # Demand-based heuristic (penalize connections to high-demand nodes early in the route)\n            demand_penalty_i = demands[i] / capacity if i != 0 else 0 # i != 0 avoids dividing by zero\n            demand_penalty_j = demands[j] / capacity if j != 0 else 0\n\n            #Angle heuristic (try to keep angles smaller when leaving depot)\n            angle_penalty = 1\n            if i == 0:\n                x_i, y_i = coordinates[i]\n                x_j, y_j = coordinates[j]\n                dx = x_j - x_i\n                dy = y_j - y_i\n                angle = np.arctan2(dy, dx)\n                angle_penalty = 1 / (np.abs(angle)+1e-6) # Small angles better, adding constant for stability.\n\n            heuristic_matrix[i, j] = distance_heuristic * (1 - demand_penalty_i) * (1 - demand_penalty_j) * angle_penalty\n\n\n    return heuristic_matrix\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic for CVRP considering distance, demand, and geometric properties.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate a basic distance-based heuristic\n    distance_heuristic = 1 / (distance_matrix + np.eye(n))  # Add identity to avoid division by zero on diagonal\n    \n    # Demand-based penalty.  Heavier demand makes longer paths less attractive.\n    demand_penalty = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                demand_penalty[i, j] = (demands[i] + demands[j]) / capacity # Normalized combined demand\n                \n    # Geometric proximity factor: Favors edges that connect nodes close to each other in euclidean space.\n    # But penalizes connection to depot for high demands.\n    proximity_factor = np.zeros_like(distance_matrix)\n    center = np.mean(coordinates, axis=0) # Center of all nodes.\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist_to_center_i = np.linalg.norm(coordinates[i] - center)\n                dist_to_center_j = np.linalg.norm(coordinates[j] - center)\n                proximity_factor[i, j] = 1 / (dist_to_center_i + dist_to_center_j + 1e-6) # Add epsilon to avoid division by zero.\n\n                if i == 0 or j == 0: #Depot connection. Penalize connections to the depot if either node connected has high demand.\n                    proximity_factor[i,j] *= (1- (demands[i] + demands[j])/ (2*capacity)) #Reduced importance of connection when demand of other nodes are high. Max reduction of 50%.\n\n\n\n    # Combine the heuristics, weighing distance more. and then slightly adjust by proximity factor and demand.\n    heuristic_matrix = distance_heuristic * (1 - 0.5 * demand_penalty) + 0.25 * proximity_factor\n\n    return heuristic_matrix\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic for CVRP considering distance, demand, and geometric properties.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate a basic distance-based heuristic\n    distance_heuristic = 1 / (distance_matrix + np.eye(n))  # Add identity to avoid division by zero on diagonal\n    \n    # Demand-based penalty.  Heavier demand makes longer paths less attractive.\n    demand_penalty = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                demand_penalty[i, j] = (demands[i] + demands[j]) / capacity # Normalized combined demand\n                \n    # Geometric proximity factor: Favors edges that connect nodes close to each other in euclidean space.\n    # But penalizes connection to depot for high demands.\n    proximity_factor = np.zeros_like(distance_matrix)\n    center = np.mean(coordinates, axis=0) # Center of all nodes.\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist_to_center_i = np.linalg.norm(coordinates[i] - center)\n                dist_to_center_j = np.linalg.norm(coordinates[j] - center)\n                proximity_factor[i, j] = 1 / (dist_to_center_i + dist_to_center_j + 1e-6) # Add epsilon to avoid division by zero.\n\n                if i == 0 or j == 0: #Depot connection. Penalize connections to the depot if either node connected has high demand.\n                    proximity_factor[i,j] *= (1- (demands[i] + demands[j])/ (2*capacity)) #Reduced importance of connection when demand of other nodes are high. Max reduction of 50%.\n\n\n\n    # Combine the heuristics, weighing distance more. and then slightly adjust by proximity factor and demand.\n    heuristic_matrix = distance_heuristic * (1 - 0.5 * demand_penalty) + 0.25 * proximity_factor\n\n    return heuristic_matrix\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Improved heuristics for CVRP incorporating distance, demand, and angle.\n\n    Args:\n        distance_matrix: Distance matrix between nodes.\n        coordinates: Euclidean coordinates of nodes.\n        demands: Demand of each node.\n        capacity: Vehicle capacity.\n\n    Returns:\n        Heuristic matrix indicating the desirability of each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Parameters for tuning the heuristics\n    distance_importance = 1.0\n    demand_importance = 0.5\n    angle_importance = 0.2\n\n    depot_index = 0\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n\n            # Distance component: Inverse of distance\n            distance_heuristic = 1 / distance_matrix[i, j] if distance_matrix[i, j] > 0 else 0\n\n            # Demand component: Penalize edges leading to high-demand nodes\n            demand_heuristic = 1 - (demands[j] / capacity) if demands[j] < capacity else 0\n\n            # Angle component: Favor nodes in a forward direction from the depot.\n            # Calculate the angle between the vector from i to j and the vector from the depot to j.\n            vector_ij = coordinates[j] - coordinates[i]\n            vector_dj = coordinates[j] - coordinates[depot_index]\n\n            # Normalize vectors to handle cases when i or depot_index equals to j\n            norm_ij = np.linalg.norm(vector_ij)\n            norm_dj = np.linalg.norm(vector_dj)\n\n            if norm_ij > 0 and norm_dj > 0:\n                cos_angle = np.dot(vector_ij, vector_dj) / (norm_ij * norm_dj)\n                # Clip cosine values to avoid potential errors in arccos\n                cos_angle = np.clip(cos_angle, -1.0, 1.0)\n                angle = np.arccos(cos_angle) # Angle in radians\n            else:\n                angle = np.pi / 2 # Default value\n\n            # The angle component\n            angle_heuristic = 1 - (angle / np.pi) # Normalize angle to [0, 1]\n\n            # Combine the heuristics\n            heuristic_matrix[i, j] = (\n                distance_importance * distance_heuristic +\n                demand_importance * demand_heuristic +\n                angle_importance * angle_heuristic\n            )\n\n    return heuristic_matrix\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates several factors to estimate the desirability of including\n    an edge in a route, going beyond a simple inverse distance.  It considers:\n\n    1. Distance: Shorter distances are preferred (inverse relationship).\n    2. Demand Compatibility: Edges connecting nodes that, when combined with the\n       current route's load, are less likely to violate capacity constraints are\n       preferred.\n    3. Angle: Edges forming sharper turns are penalized, as they often lead to less\n       efficient routes.  This is done by computing the angle between potential edges\n       and penalizing sharp turns.\n    4. Closeness to Depot: Edges closer to the depot are generally favored, especially\n       when near capacity, to facilitate returns to the depot.\n\n    Args:\n        distance_matrix: Distance matrix (n x n).\n        coordinates: Node coordinates (n x 2).\n        demands: Node demands (n).\n        capacity: Vehicle capacity.\n\n    Returns:\n        Heuristic matrix (n x n) indicating the desirability of each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Add a small constant to the distance matrix to avoid division by zero\n    distance_matrix = distance_matrix + 1e-9  # Avoid division by zero\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n\n            # 1. Distance-based heuristic (inverse distance)\n            distance_heuristic = 1 / distance_matrix[i, j]\n\n            # 2. Demand-based heuristic (penalize edges likely to cause capacity violations)\n            demand_penalty = (demands[i] + demands[j]) / (2 * capacity) # Normalize to a penalty factor around 1\n            demand_heuristic = max(0, 1 - demand_penalty) # Scales to between 0-1\n            \n\n            # 3. Angle-based heuristic (penalize sharp turns)\n            #   - Approximate by considering depot as the previous node for now.\n            #   - Can be improved by keeping track of the actual route as it's built\n            if i == 0:\n                angle_heuristic = 1.0 #No turn\n            else:\n                # vector from depot to node i and node i to node j\n                vector1 = coordinates[i] - coordinates[0]\n                vector2 = coordinates[j] - coordinates[i]\n\n                # Calculate the cosine of the angle between the vectors\n                norm1 = np.linalg.norm(vector1)\n                norm2 = np.linalg.norm(vector2)\n\n                if norm1 > 0 and norm2 > 0:\n                    cos_angle = np.dot(vector1, vector2) / (norm1 * norm2)\n                    # Clip cosine to [-1, 1] to avoid potential errors\n                    cos_angle = np.clip(cos_angle, -1.0, 1.0)\n                    angle = np.arccos(cos_angle)  # Angle in radians\n                    angle_penalty = angle / np.pi  # Normalize to a penalty factor between 0 and 1. Sharp turn is 1, straight line is 0\n                    angle_heuristic = max(0, 1-angle_penalty)\n                else:\n                    angle_heuristic = 0.5 # Default penalty\n\n\n\n            # 4. Depot Proximity\n            depot_distance = distance_matrix[i,0] + distance_matrix[j,0]\n            depot_proximity = np.exp(-depot_distance/np.mean(distance_matrix)) # Bias shorter total distance from i & j to depot\n\n\n\n            # Combine the heuristics (weighted sum) - EXPERIMENTAL\n            heuristic_matrix[i, j] = (\n                0.4 * distance_heuristic +\n                0.3 * demand_heuristic +\n                0.2 * angle_heuristic +\n                0.1 * depot_proximity\n            )\n\n    return heuristic_matrix\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for CVRP using a combination of distance, demand, and angular considerations.\n\n    Args:\n        distance_matrix: Distance matrix between nodes.\n        coordinates: Coordinates of nodes.\n        demands: Demand of each node.\n        capacity: Vehicle capacity.\n\n    Returns:\n        A matrix of heuristics values, indicating the desirability of each edge.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # Heuristic components:\n    # 1. Distance-based: Shorter distances are preferred.  Adjusted by capacity.\n    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Avoid division by zero\n\n    # 2. Demand-based:  Penalize edges connecting to nodes that would easily saturate vehicle capacity.\n    demand_penalty = np.zeros((n,n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_penalty[i, j] = 0  # Avoid self-loops.\n            else:\n                # Probability of exceeding capacity by going to j directly from depot\n                demand_prob_i = demands[i]/capacity if i != 0 else 0\n                demand_prob_j = demands[j]/capacity if j != 0 else 0\n                demand_penalty[i, j] = min(demand_prob_i + demand_prob_j,1)\n    demand_heuristic = 1 - demand_penalty\n\n    # 3. Angular-based:  Prefer routes that are less likely to cause sharp turns. Helps to explore diverse routes\n\n    depot_x, depot_y = coordinates[0]  # Depot location\n    angular_heuristic = np.zeros((n, n))\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                 #calculate angle between vector depot-i and depot-j.\n                x_i, y_i = coordinates[i]\n                x_j, y_j = coordinates[j]\n\n                vector_i = np.array([x_i - depot_x, y_i - depot_y])\n                vector_j = np.array([x_j - depot_x, y_j - depot_y])\n\n                # Dot product to calculate angle\n                dot_product = np.dot(vector_i, vector_j)\n                magnitude_i = np.linalg.norm(vector_i)\n                magnitude_j = np.linalg.norm(vector_j)\n                if (magnitude_i == 0 or magnitude_j == 0):\n                    angle_radians = 0.0  # Assign 0 if either vector is zero\n                else:\n                     angle_radians = np.arccos(dot_product / (magnitude_i * magnitude_j)) #Angle in radians.\n\n                angular_heuristic[i,j] = 1 - np.abs(angle_radians) / np.pi # Normalise the angle\n\n\n\n    # Combine the heuristics: weighted sum.\n    alpha = 0.5  # Weight for distance\n    beta = 0.3   # Weight for demand\n    gamma = 0.2 # Weight for angle\n    heuristics = alpha * distance_heuristic + beta * demand_heuristic + gamma * angular_heuristic\n\n    # Ensure no self-loops:\n    for i in range(n):\n        heuristics[i, i] = 0\n\n    return heuristics\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for CVRP using a combination of distance, demand, and angular considerations.\n\n    Args:\n        distance_matrix: Distance matrix between nodes.\n        coordinates: Coordinates of nodes.\n        demands: Demand of each node.\n        capacity: Vehicle capacity.\n\n    Returns:\n        A matrix of heuristics values, indicating the desirability of each edge.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # Heuristic components:\n    # 1. Distance-based: Shorter distances are preferred.  Adjusted by capacity.\n    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Avoid division by zero\n\n    # 2. Demand-based:  Penalize edges connecting to nodes that would easily saturate vehicle capacity.\n    demand_penalty = np.zeros((n,n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_penalty[i, j] = 0  # Avoid self-loops.\n            else:\n                # Probability of exceeding capacity by going to j directly from depot\n                demand_prob_i = demands[i]/capacity if i != 0 else 0\n                demand_prob_j = demands[j]/capacity if j != 0 else 0\n                demand_penalty[i, j] = min(demand_prob_i + demand_prob_j,1)\n    demand_heuristic = 1 - demand_penalty\n\n    # 3. Angular-based:  Prefer routes that are less likely to cause sharp turns. Helps to explore diverse routes\n\n    depot_x, depot_y = coordinates[0]  # Depot location\n    angular_heuristic = np.zeros((n, n))\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                 #calculate angle between vector depot-i and depot-j.\n                x_i, y_i = coordinates[i]\n                x_j, y_j = coordinates[j]\n\n                vector_i = np.array([x_i - depot_x, y_i - depot_y])\n                vector_j = np.array([x_j - depot_x, y_j - depot_y])\n\n                # Dot product to calculate angle\n                dot_product = np.dot(vector_i, vector_j)\n                magnitude_i = np.linalg.norm(vector_i)\n                magnitude_j = np.linalg.norm(vector_j)\n                if (magnitude_i == 0 or magnitude_j == 0):\n                    angle_radians = 0.0  # Assign 0 if either vector is zero\n                else:\n                     angle_radians = np.arccos(dot_product / (magnitude_i * magnitude_j)) #Angle in radians.\n\n                angular_heuristic[i,j] = 1 - np.abs(angle_radians) / np.pi # Normalise the angle\n\n\n\n    # Combine the heuristics: weighted sum.\n    alpha = 0.5  # Weight for distance\n    beta = 0.3   # Weight for demand\n    gamma = 0.2 # Weight for angle\n    heuristics = alpha * distance_heuristic + beta * demand_heuristic + gamma * angular_heuristic\n\n    # Ensure no self-loops:\n    for i in range(n):\n        heuristics[i, i] = 0\n\n    return heuristics\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    A more sophisticated heuristics function for CVRP.  It considers distance,\n    demand, and angular relationships between nodes to estimate the desirability\n    of including an edge in a route.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Normalize demands for scaling purposes.  Avoid division by zero.\n    max_demand = np.max(demands)\n    normalized_demands = demands / max_demand if max_demand > 0 else np.zeros_like(demands)\n\n\n    # Depot location\n    depot_x, depot_y = coordinates[0]\n\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n\n            distance = distance_matrix[i, j]\n            if distance == 0:\n                heuristic_matrix[i, j] = 0 #Avoid divide by zero, same point\n                continue\n\n            # Base heuristic: inverse of distance\n            heuristic = 1 / distance\n\n            # Demand factor:  Less desirable to link high-demand nodes directly\n            # unless it is to the depot.\n            demand_penalty = normalized_demands[i] + normalized_demands[j]\n\n            if i!= 0 and j != 0:\n               heuristic /= (1 + demand_penalty)\n\n            # Angular component:  Penalize sharp turns. Nodes should be added more favorably\n            #   in similar directions to the depot. This is only relevant if\n            #   neither node is the depot itself\n\n            if i != 0 and j != 0:\n\n                angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)\n                angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)\n\n                angle_diff = np.abs(angle_i - angle_j)\n                angle_diff = np.minimum(angle_diff, 2 * np.pi - angle_diff)  # Ensure the smaller angle is used\n\n                # Penalize edges where the nodes have very different angles from the depot.\n                # Higher values indicate angles are very different so penalty is increased.\n                angle_penalty = (angle_diff / np.pi)**2\n                heuristic /= (1+angle_penalty)\n\n\n            heuristic_matrix[i, j] = heuristic\n\n    return heuristic_matrix\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates distance, demand, and depot proximity for edge prioritization.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Vector of customer demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n\n    # Avoid self-loops\n    for i in range(n):\n        heuristics_matrix[i, i] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Base heuristic: inverse of distance\n                distance_heuristic = 1 / (distance_matrix[i, j] + 1e-9) # Adding a small constant to avoid division by zero\n\n                # Demand-based heuristic:  discourage connecting nodes whose combined demand significantly exceeds capacity when starting from the depot.\n                demand_heuristic = 1.0\n                if i == 0:  # Penalize high demands *starting* from the depot.\n                    if demands[j] > capacity/2: #heuristically chosen threshold to penalize *starting* from depot\n                        demand_heuristic = 0.1 #drastically reduce the indicator if demand is high\n                else:\n                   demand_heuristic = 1 #Neutralize demand_heuristic.  Important, because the depot condition strongly steers routes toward the depot.\n\n\n                # Depot proximity heuristic: Favor edges closer to the depot, especially for initiating routes (starting at the depot)\n                depot_proximity_i = distance_matrix[0, i]\n                depot_proximity_j = distance_matrix[0, j]\n                depot_proximity_heuristic = 1 / ((depot_proximity_i + depot_proximity_j)/2 + 1e-9)  #Avoid divide by zero\n\n                # Combined heuristic (weighted sum - weights can be tuned)\n                heuristics_matrix[i, j] = (0.6 * distance_heuristic +\n                                             0.2 * demand_heuristic +\n                                             0.2 * depot_proximity_heuristic)\n\n    return heuristics_matrix\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP) that considers\n    distance, demand, and proximity to the depot.\n\n    Args:\n        distance_matrix: A numpy array of shape (n, n) representing the distances\n                         between each pair of nodes.\n        coordinates: A numpy array of shape (n, 2) representing the Euclidean coordinates\n                     of each node.\n        demands: A numpy array of shape (n,) representing the demand of each node.\n        capacity: An integer representing the capacity of each vehicle.\n\n    Returns:\n        A numpy array of shape (n, n) representing the prior indicators of how\n        promising it is to include each edge in a solution.  Higher values indicate\n        more promising edges.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Heuristic 1: Inverse of distance\n    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero\n\n    # Heuristic 2: Demand-based adjustment.  Edges connecting to nodes with high demand\n    # are penalized if they are far from the depot.\n    depot_distances = distance_matrix[0, :]  # Distances from the depot to all nodes\n    demand_heuristic = np.zeros((n, n))\n    for i in range(1, n):  # Skip depot (index 0)\n        for j in range(1, n):\n            if i != j:\n                demand_heuristic[i, j] = (capacity / (demands[i] + demands[j] + 1e-6)) * (1/(depot_distances[i]+ depot_distances[j] +1e-6)) #Nodes close to the depot more likely to be used\n\n    # Heuristic 3: Combination of distance and demand, prioritize the close distance to depot\n    proximity_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                proximity_heuristic[i, j] = 1/ (distance_matrix[i,j]+ depot_distances[i]+ depot_distances[j]+ 1e-6)\n\n\n    # Combine the heuristics\n    heuristic_matrix = 0.5 * distance_heuristic + 0.25 * demand_heuristic + 0.25 * proximity_heuristic\n\n\n    # Ensure the depot node (0) is always a good starting point, boost edges connected to the depot\n    for i in range(1, n):\n          heuristic_matrix[0, i] = heuristic_matrix[0, i] * 1.5\n          heuristic_matrix[i, 0] = heuristic_matrix[i, 0] * 1.5\n\n\n\n    return heuristic_matrix\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for CVRP based on distance, demand, and node proximity to the depot.\n\n    This heuristic considers the following factors:\n    1. Distance between nodes: Shorter distances are preferred.\n    2. Demand of the target node:  Penalizes edges leading to high-demand nodes.\n    3. Proximity to the depot: Encourages routes to start and end near the depot,\n       and penalizes routes going far away from the depot without returning.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix (n x n).\n        coordinates (np.ndarray): Node coordinates (n x 2).\n        demands (np.ndarray): Node demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Edge prior indicators (n x n).\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Depot coordinates\n    depot_x, depot_y = coordinates[0]\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # Avoid self-loops\n                continue\n\n            distance = distance_matrix[i, j]\n            demand = demands[j]\n\n            # Distance factor: inversely proportional to distance\n            distance_factor = 1 / (distance + 1e-6)  # Avoid division by zero\n\n            # Demand factor: penalize high-demand nodes\n            demand_factor = 1 / (demand / capacity + 1e-6) if demand > 0 else 1.0 #avoid divide by zero, demand is 0 at depot.\n\n            # Proximity to depot factor: encourage starting/ending near the depot\n            # Euclidean distance to the depot\n            dist_i_to_depot = np.sqrt((coordinates[i, 0] - depot_x)**2 + (coordinates[i, 1] - depot_y)**2)\n            dist_j_to_depot = np.sqrt((coordinates[j, 0] - depot_x)**2 + (coordinates[j, 1] - depot_y)**2)\n            \n            # Penalize going far without returning - gives a very small score, i.e., highly discouraged.\n            depot_factor = 1 / (dist_i_to_depot + dist_j_to_depot + 1e-6) #avoid divide by zero\n\n            # Combine the factors (weighted combination)\n            heuristic_matrix[i, j] = (0.6 * distance_factor + 0.3 * demand_factor + 0.1 * depot_factor)\n            # Small adjustment to favor edges connected to depot\n            if i == 0 or j == 0:\n                heuristic_matrix[i, j] *= 1.2\n\n    return heuristic_matrix\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for CVRP based on distance, demand, and depot proximity.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes.\n        coordinates (np.ndarray): Coordinates of each node.\n        demands (np.ndarray): Demand of each node.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Edge weights indicating the desirability of each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Inverse distance component (closer nodes are preferred)\n    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero\n\n    # Demand-aware component: penalize edges that would overload vehicles\n    demand_penalty = np.ones_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                if demands[i] + demands[j] > capacity:\n                    demand_penalty[i, j] = 0.1  # Heavily penalize if combined demand exceeds capacity significantly\n\n    # Depot proximity component: favor edges near the depot to promote returns\n    depot_proximity = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        depot_proximity[0, i] = 1 / (distance_matrix[0, i] + 1e-9) # Favor shorter path to depot\n        depot_proximity[i, 0] = 1 / (distance_matrix[i, 0] + 1e-9)\n\n\n    # Combined heuristic: balance distance, demand, and depot proximity\n    heuristics = inverse_distance * demand_penalty + depot_proximity\n\n    # Normalize the heuristic values\n    heuristics = heuristics / np.max(heuristics)\n\n    return heuristics\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This function calculates prior indicators of how promising it is to include each edge in a solution.\n    It considers distance, demand, and proximity to the depot.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix (shape: n by n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of edge inclusion (shape: n by n).\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # Parameters for tuning the heuristics\n    alpha = 1.0   # Weight for distance\n    beta = 0.5    # Weight for demand\n    gamma = 0.2   # Weight for depot proximity\n    delta = 0.1 # Weight for demand distance similarity\n\n    # Calculate depot distances\n    depot_distances = distance_matrix[0, :]\n\n    # Normalize demands\n    normalized_demands = demands / capacity\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:  # Avoid self-loops\n                # Distance component: encourage shorter edges\n                distance_component = alpha / distance_matrix[i, j]\n\n                # Demand component: penalize edges connecting nodes that would exceed capacity easily\n                demand_component = beta * (1 - (normalized_demands[i] + normalized_demands[j]))\n                demand_component = max(0, demand_component)  # Ensure non-negativity\n\n                # Depot proximity component: encourage edges closer to the depot\n                depot_proximity_component = gamma * (1 - (depot_distances[i] + depot_distances[j]) / (2 * np.max(depot_distances)))\n\n                # Demand distance similarity component: prioritize edges connecting similar demands\n                demand_distance = abs(demands[i] - demands[j])\n                demand_distance_component = delta * (1 / (demand_distance + 1e-6))\n\n\n                # Combine the components\n                heuristics[i, j] = distance_component + demand_component + depot_proximity_component + demand_distance_component\n            else:\n                heuristics[i, j] = 0  # No self-loops\n\n    return heuristics\n\n[Heuristics 19th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates distance, demand, and angle considerations to guide edge selection.\n\n    Args:\n        distance_matrix: Distance matrix between nodes (shape: n x n).\n        coordinates: Euclidean coordinates of nodes (shape: n x 2).\n        demands: Demand of each node (shape: n).\n        capacity: Vehicle capacity.\n\n    Returns:\n        A matrix of the same shape as distance_matrix, indicating the attractiveness of each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Parameters (can be tuned)\n    alpha = 1.0  # Weight for distance\n    beta = 1.0   # Weight for demand\n    gamma = 1.0  # Weight for angle\n    delta = 1.0  # Weight for capacity slack\n\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Distance factor: Shorter distances are more attractive\n                distance_factor = alpha / distance_matrix[i, j]\n\n                # Demand factor: Prefer nodes with demands that fit well within vehicle capacity\n                demand_factor = beta / (demands[j] + 1e-6) # Add small value to avoid division by zero\n\n                # Angle factor: Penalize sharp turns\n                if i == 0:  # Depot case - angle is less relevant\n                    angle_factor = 1.0\n                else:\n                    # Compute angles\n                    vector_ij = coordinates[j] - coordinates[i]\n                    vector_0i = coordinates[i] - coordinates[0]  # Depot at node 0\n\n                    # Normalize vectors to get cosine\n                    norm_ij = np.linalg.norm(vector_ij)\n                    norm_0i = np.linalg.norm(vector_0i)\n\n                    if norm_ij > 0 and norm_0i > 0:\n                         cos_angle = np.dot(vector_ij, vector_0i) / (norm_ij * norm_0i)\n                         # Map cosine (-1 to 1) to a score (0 to 1), higher is better\n                         angle_factor = gamma * (cos_angle + 1) / 2\n                    else:\n                         angle_factor = gamma # Avoid zero norm case\n                # Capacity slack factor: Higher slack is more desirable for exploration\n                capacity_slack_factor = delta # Initialize\n                # Consider current node i and potential next node j, if node i is the depot, then consider only j's demand\n                if i==0:\n                  capacity_slack_factor = delta * np.exp(-demands[j] / capacity)\n                else:\n                   capacity_slack_factor = delta\n\n                # Combine factors to create the heuristic value\n                heuristic_matrix[i, j] = distance_factor + demand_factor + angle_factor + capacity_slack_factor\n\n    return heuristic_matrix\n\n[Heuristics 20th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates distance, demand, and angle considerations to guide edge selection.\n\n    Args:\n        distance_matrix: Distance matrix between nodes (shape: n x n).\n        coordinates: Euclidean coordinates of nodes (shape: n x 2).\n        demands: Demand of each node (shape: n).\n        capacity: Vehicle capacity.\n\n    Returns:\n        A matrix of the same shape as distance_matrix, indicating the attractiveness of each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Parameters (can be tuned)\n    alpha = 1.0  # Weight for distance\n    beta = 1.0   # Weight for demand\n    gamma = 1.0  # Weight for angle\n    delta = 1.0  # Weight for capacity slack\n\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Distance factor: Shorter distances are more attractive\n                distance_factor = alpha / distance_matrix[i, j]\n\n                # Demand factor: Prefer nodes with demands that fit well within vehicle capacity\n                demand_factor = beta / (demands[j] + 1e-6) # Add small value to avoid division by zero\n\n                # Angle factor: Penalize sharp turns\n                if i == 0:  # Depot case - angle is less relevant\n                    angle_factor = 1.0\n                else:\n                    # Compute angles\n                    vector_ij = coordinates[j] - coordinates[i]\n                    vector_0i = coordinates[i] - coordinates[0]  # Depot at node 0\n\n                    # Normalize vectors to get cosine\n                    norm_ij = np.linalg.norm(vector_ij)\n                    norm_0i = np.linalg.norm(vector_0i)\n\n                    if norm_ij > 0 and norm_0i > 0:\n                         cos_angle = np.dot(vector_ij, vector_0i) / (norm_ij * norm_0i)\n                         # Map cosine (-1 to 1) to a score (0 to 1), higher is better\n                         angle_factor = gamma * (cos_angle + 1) / 2\n                    else:\n                         angle_factor = gamma # Avoid zero norm case\n                # Capacity slack factor: Higher slack is more desirable for exploration\n                capacity_slack_factor = delta # Initialize\n                # Consider current node i and potential next node j, if node i is the depot, then consider only j's demand\n                if i==0:\n                  capacity_slack_factor = delta * np.exp(-demands[j] / capacity)\n                else:\n                   capacity_slack_factor = delta\n\n                # Combine factors to create the heuristic value\n                heuristic_matrix[i, j] = distance_factor + demand_factor + angle_factor + capacity_slack_factor\n\n    return heuristic_matrix\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}