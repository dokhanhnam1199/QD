```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for CVRP that considers distance, demand, and angle.

    Args:
        distance_matrix: Distance between nodes (n x n).
        coordinates: Euclidean coordinates of nodes (n x 2).
        demands: Demand of each node (n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of heuristics values (n x n), where higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Depot coordinates
    depot_x, depot_y = coordinates[0]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance-based heuristic (shorter distances are better)
            distance_heuristic = 1 / (distance_matrix[i, j] + 1e-6) #Adding a tiny constant to avoid divide by zero error

            # Demand-based heuristic (penalize connections to high-demand nodes early in the route)
            demand_penalty_i = demands[i] / capacity if i != 0 else 0 # i != 0 avoids dividing by zero
            demand_penalty_j = demands[j] / capacity if j != 0 else 0

            #Angle heuristic (try to keep angles smaller when leaving depot)
            angle_penalty = 1
            if i == 0:
                x_i, y_i = coordinates[i]
                x_j, y_j = coordinates[j]
                dx = x_j - x_i
                dy = y_j - y_i
                angle = np.arctan2(dy, dx)
                angle_penalty = 1 / (np.abs(angle)+1e-6) # Small angles better, adding constant for stability.

            heuristic_matrix[i, j] = distance_heuristic * (1 - demand_penalty_i) * (1 - demand_penalty_j) * angle_penalty


    return heuristic_matrix
```
