{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity and angle considerations with adaptive sparsification and simplified components.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity: # Directly prune edges that violate capacity constraint.\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i,j] += 0.3 #Depot boost\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route.  Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2*mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty # Reduced weight\n\n                # Adaptive pruning based on demand and distance.  Less aggressive than v1.\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity/3: #Only prune if nodes have considerable demand compared to vehicle capacity.\n                    heuristics[i,j] = 0\n\n\n    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    # Convert cosine to angle in radians\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) #Ensure within valid range\n\n                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value\n                    heuristics[i,j] += 0.1 * (1 - angle / np.pi) # Normalized angle reward, reduced weight\n\n\n    # Heuristic 5: Sparsification: zero out small heuristic values\n    threshold = 0.01 * np.mean(heuristics) # Adaptive threshold\n    heuristics[heuristics < threshold] = 0\n\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity and angle considerations with adaptive sparsification and simplified components.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity: # Directly prune edges that violate capacity constraint.\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i,j] += 0.3 #Depot boost\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route.  Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2*mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty # Reduced weight\n\n                # Adaptive pruning based on demand and distance.  Less aggressive than v1.\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity/3: #Only prune if nodes have considerable demand compared to vehicle capacity.\n                    heuristics[i,j] = 0\n\n\n    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    # Convert cosine to angle in radians\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) #Ensure within valid range\n\n                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value\n                    heuristics[i,j] += 0.1 * (1 - angle / np.pi) # Normalized angle reward, reduced weight\n\n\n    # Heuristic 5: Sparsification: zero out small heuristic values\n    threshold = 0.01 * np.mean(heuristics) # Adaptive threshold\n    heuristics[heuristics < threshold] = 0\n\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity and angle considerations with adaptive sparsification and simplified components.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity: # Directly prune edges that violate capacity constraint.\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i,j] += 0.3 #Depot boost\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route.  Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2*mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty # Reduced weight\n\n                # Adaptive pruning based on demand and distance.  Less aggressive than v1.\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity/3: #Only prune if nodes have considerable demand compared to vehicle capacity.\n                    heuristics[i,j] = 0\n\n\n    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    # Convert cosine to angle in radians\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) #Ensure within valid range\n\n                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value\n                    heuristics[i,j] += 0.1 * (1 - angle / np.pi) # Normalized angle reward, reduced weight\n\n\n    # Heuristic 5: Sparsification: zero out small heuristic values\n    threshold = 0.01 * np.mean(heuristics) # Adaptive threshold\n    heuristics[heuristics < threshold] = 0\n\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version prioritizes routes based on a combination of distance, demand, and depot proximity,\n    with adaptive sparsification and route completion incentives.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # 1. Inverse Distance with a base value\n    base_heuristic = 1 / (distance_matrix + 1e-9)\n    heuristics += base_heuristic\n\n    # 2. Demand and Capacity Consideration:\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            # Depot connection boost\n            if i == depot_index and j != depot_index:\n                if demands[j] <= capacity:  # Only allow depot starts if demand is within capacity.\n                    heuristics[i, j] += 0.7 # stronger boost for edges *from* the depot.\n                else:\n                    heuristics[i, j] = 0  # Infeasible edges from depot are pruned\n\n            # Prune edges that would immediately violate capacity\n            elif i != depot_index and j != depot_index:\n                 if demands[i] + demands[j] > capacity and i != depot_index and j == depot_index:\n                    heuristics[i,j] = 0 # remove edges to depot if combined demand is violated from the current node\n\n    # 3. Depot Proximity Incentive (with adaptive scaling):\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances) + 1e-9\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n              heuristics[i,j] = 0\n            if i != depot_index and j != depot_index:\n                depot_proximity_penalty = 0.05 * (depot_distances[i] + depot_distances[j]) / mean_depot_distance\n                heuristics[i, j] -= depot_proximity_penalty\n                 # Sparsification based on combined distance and demand relative to averages\n                combined_metric = distance_matrix[i, j] * demands[j]\n                threshold = np.mean(distance_matrix) * np.mean(demands) * 1.5  # Adjusted threshold\n                if combined_metric > threshold:\n                   heuristics[i, j] = 0\n\n    # 4. Route Completion Incentive: Encourages closing routes back to the depot.\n    for i in range(n):\n        if i != depot_index:\n            heuristics[i, depot_index] += 0.3 # Incentivize returns to depot, making CVRP a little more like TSP\n\n    # 5. Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    # Post-processing: Ensure depot has outgoing edges and no incoming edges (except from the route end).\n    for i in range(n):\n        if i != depot_index:\n            heuristics[depot_index, i] = max(0, heuristics[depot_index, i])\n            heuristics[i, depot_index] = 0  # Except handled in route completion incentives\n    return heuristics\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version focuses on a simplified approach with adaptive intensification and sparsification.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Inverse distance with a small constant to avoid division by zero\n    heuristics = 1 / (distance_matrix + 1e-6)\n\n    # Heuristic 2: Depot connection encouragement based on demand and distance\n    for j in range(1, n):  # Iterate over customers (excluding depot)\n        # Encourage connections from the depot to customers\n        if demands[j] <= capacity:  # Only consider if demand is within capacity\n            heuristics[depot_index, j] += 0.5 / (distance_matrix[depot_index, j] + 1e-6)  # Boost, scaled by inverse distance\n            heuristics[j, depot_index] = 0 #no incoming edges to depot except from depot.\n        else:\n            heuristics[depot_index, j] = 0 #prune edges if single demand exceeds capacity.\n\n    # Heuristic 3: Demand-based Sparsification: Adaptive threshold\n    mean_distance = np.mean(distance_matrix)\n    mean_demand = np.mean(demands[1:])  # Exclude depot demand\n    threshold = mean_distance * mean_demand * 1.5  # Adaptive threshold based on means\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            combined_metric = distance_matrix[i, j] * (demands[i] + demands[j]) #Considers combined demand\n\n            if combined_metric > threshold:\n                heuristics[i, j] = 0  # Aggressive pruning if over threshold\n\n    # Heuristic 4: Nearest Neighbor Adjustment (Simplified k-NN)\n    k_nearest_neighbors = 2 # Reduced k for simplicity\n    for i in range(1, n):\n        neighbors_idx = np.argsort(distance_matrix[i, 1:])[ :k_nearest_neighbors] + 1 # Exclude self and depot, adjust indices\n        for nn in neighbors_idx:\n            heuristics[i, nn] += 0.1 # Small encouragement\n\n    # Heuristic 5:  Discourage long edges generally (more aggressive sparsification)\n    long_edge_threshold = np.median(distance_matrix) * 2  #Example: Adaptive threshold\n    for i in range(1,n):\n        for j in range(1,n):\n            if distance_matrix[i,j] > long_edge_threshold:\n                heuristics[i,j] = 0\n\n    # Normalize to [0, 1]\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version focuses on a simplified approach with adaptive intensification and sparsification.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Inverse distance with a small constant to avoid division by zero\n    heuristics = 1 / (distance_matrix + 1e-6)\n\n    # Heuristic 2: Depot connection encouragement based on demand and distance\n    for j in range(1, n):  # Iterate over customers (excluding depot)\n        # Encourage connections from the depot to customers\n        if demands[j] <= capacity:  # Only consider if demand is within capacity\n            heuristics[depot_index, j] += 0.5 / (distance_matrix[depot_index, j] + 1e-6)  # Boost, scaled by inverse distance\n            heuristics[j, depot_index] = 0 #no incoming edges to depot except from depot.\n        else:\n            heuristics[depot_index, j] = 0 #prune edges if single demand exceeds capacity.\n\n    # Heuristic 3: Demand-based Sparsification: Adaptive threshold\n    mean_distance = np.mean(distance_matrix)\n    mean_demand = np.mean(demands[1:])  # Exclude depot demand\n    threshold = mean_distance * mean_demand * 1.5  # Adaptive threshold based on means\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            combined_metric = distance_matrix[i, j] * (demands[i] + demands[j]) #Considers combined demand\n\n            if combined_metric > threshold:\n                heuristics[i, j] = 0  # Aggressive pruning if over threshold\n\n    # Heuristic 4: Nearest Neighbor Adjustment (Simplified k-NN)\n    k_nearest_neighbors = 2 # Reduced k for simplicity\n    for i in range(1, n):\n        neighbors_idx = np.argsort(distance_matrix[i, 1:])[ :k_nearest_neighbors] + 1 # Exclude self and depot, adjust indices\n        for nn in neighbors_idx:\n            heuristics[i, nn] += 0.1 # Small encouragement\n\n    # Heuristic 5:  Discourage long edges generally (more aggressive sparsification)\n    long_edge_threshold = np.median(distance_matrix) * 2  #Example: Adaptive threshold\n    for i in range(1,n):\n        for j in range(1,n):\n            if distance_matrix[i,j] > long_edge_threshold:\n                heuristics[i,j] = 0\n\n    # Normalize to [0, 1]\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity and angle considerations with sparsification and adaptive weighting.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    distance_heuristic = 1 / (distance_matrix + 1e-9)\n    heuristics += distance_heuristic * 0.6  # Base contribution from distance\n\n    # Heuristic 2: Demand consideration and Depot Connection\n    demand_distance_heuristic = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_distance_heuristic[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity >= 0:\n                    demand_distance_heuristic[i, j] = 0.7  # Initial Depot Boost\n                else:\n                    demand_distance_heuristic[i, j] = 0  # Prune unpromising edges from depot\n\n            elif i != depot_index and j == depot_index:\n                  demand_distance_heuristic[i,j] = 0  # No edges to depot except from depot\n            elif i != depot_index and j!= depot_index:\n                demand_distance_heuristic[i,j] = 1/(distance_matrix[i,j] * demands[j] + 1e-9)\n\n    heuristics += demand_distance_heuristic * 0.4\n\n\n    #Heuristic 3: Angle from Depot\n    angle_heuristic = np.zeros_like(distance_matrix)\n\n    for i in range(n):\n        for j in range(n):\n            if i == depot_index or j == depot_index or i ==j:\n                angle_heuristic[i,j] = 0\n                continue\n\n            # Calculate angles between the depot and the two nodes\n            vector_i = coordinates[i] - coordinates[depot_index]\n            vector_j = coordinates[j] - coordinates[depot_index]\n\n            #Calculate angle between vectors\n            norm_i = np.linalg.norm(vector_i)\n            norm_j = np.linalg.norm(vector_j)\n\n            if norm_i == 0 or norm_j == 0:\n                angle = 0\n            else:\n\n                dot_product = np.dot(vector_i, vector_j)\n                cos_angle = dot_product / (norm_i * norm_j)\n                angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) # Clip for numerical stability\n\n\n\n            angle_heuristic[i,j] = 1- (angle / np.pi)  # Smaller angle is better\n\n\n    heuristics += angle_heuristic * 0.1\n\n\n    # Heuristic 4: Sparsification\n    threshold = np.mean(distance_matrix) # Adaptive Threshold\n    for i in range(n):\n        for j in range(n):\n            if i != j and distance_matrix[i,j] > threshold * 2 : # More Aggressive\n                heuristics[i, j] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity and angle considerations with sparsification and adaptive weighting.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    distance_heuristic = 1 / (distance_matrix + 1e-9)\n    heuristics += distance_heuristic * 0.6  # Base contribution from distance\n\n    # Heuristic 2: Demand consideration and Depot Connection\n    demand_distance_heuristic = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_distance_heuristic[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity >= 0:\n                    demand_distance_heuristic[i, j] = 0.7  # Initial Depot Boost\n                else:\n                    demand_distance_heuristic[i, j] = 0  # Prune unpromising edges from depot\n\n            elif i != depot_index and j == depot_index:\n                  demand_distance_heuristic[i,j] = 0  # No edges to depot except from depot\n            elif i != depot_index and j!= depot_index:\n                demand_distance_heuristic[i,j] = 1/(distance_matrix[i,j] * demands[j] + 1e-9)\n\n    heuristics += demand_distance_heuristic * 0.4\n\n\n    #Heuristic 3: Angle from Depot\n    angle_heuristic = np.zeros_like(distance_matrix)\n\n    for i in range(n):\n        for j in range(n):\n            if i == depot_index or j == depot_index or i ==j:\n                angle_heuristic[i,j] = 0\n                continue\n\n            # Calculate angles between the depot and the two nodes\n            vector_i = coordinates[i] - coordinates[depot_index]\n            vector_j = coordinates[j] - coordinates[depot_index]\n\n            #Calculate angle between vectors\n            norm_i = np.linalg.norm(vector_i)\n            norm_j = np.linalg.norm(vector_j)\n\n            if norm_i == 0 or norm_j == 0:\n                angle = 0\n            else:\n\n                dot_product = np.dot(vector_i, vector_j)\n                cos_angle = dot_product / (norm_i * norm_j)\n                angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) # Clip for numerical stability\n\n\n\n            angle_heuristic[i,j] = 1- (angle / np.pi)  # Smaller angle is better\n\n\n    heuristics += angle_heuristic * 0.1\n\n\n    # Heuristic 4: Sparsification\n    threshold = np.mean(distance_matrix) # Adaptive Threshold\n    for i in range(n):\n        for j in range(n):\n            if i != j and distance_matrix[i,j] > threshold * 2 : # More Aggressive\n                heuristics[i, j] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines inverse distance, demand, depot proximity, k-NN, and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Demand consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n            if i == depot_index and j != depot_index:\n                if capacity - demands[j] < 0:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.3  # depot boost\n            elif i != depot_index and j == depot_index:\n                heuristics[i, j] += 0.1\n\n    # Depot proximity\n    depot_distances = distance_matrix[:, depot_index]\n    for i in range(n):\n        if i != depot_index:\n            heuristics[i, depot_index] += 0.1 * (1 / (depot_distances[i] + 1e-9))\n\n    # K-Nearest Neighbor Bonus\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]\n        for neighbor in neighbors_idx:\n            heuristics[i, neighbor] += 0.2\n\n    # Sparsification\n    distance_threshold = np.mean(distance_matrix) * 1.2\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > distance_threshold:\n                heuristics[i, j] = 0\n\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines inverse distance, demand, depot proximity, k-NN, and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Demand consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n            if i == depot_index and j != depot_index:\n                if capacity - demands[j] < 0:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.3  # depot boost\n            elif i != depot_index and j == depot_index:\n                heuristics[i, j] += 0.1\n\n    # Depot proximity\n    depot_distances = distance_matrix[:, depot_index]\n    for i in range(n):\n        if i != depot_index:\n            heuristics[i, depot_index] += 0.1 * (1 / (depot_distances[i] + 1e-9))\n\n    # K-Nearest Neighbor Bonus\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]\n        for neighbor in neighbors_idx:\n            heuristics[i, neighbor] += 0.2\n\n    # Sparsification\n    distance_threshold = np.mean(distance_matrix) * 1.2\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > distance_threshold:\n                heuristics[i, j] = 0\n\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Improved heuristics for CVRP, combines distance, savings, demand, k-NN and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Inverse distance\n    heuristic_matrix = 1 / (distance_matrix + 1e-9)\n\n    # Savings based on Clarke-Wright\n    savings_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    heuristic_matrix += savings_matrix / np.max(savings_matrix)\n\n    # Demand consideration\n    depot_index = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity < 0:\n                    heuristic_matrix[i, j] = 0\n                else:\n                    heuristic_matrix[i, j] += 0.25 #Slightly less boost\n\n            if i != depot_index and j != depot_index:\n                potential_load = demands[i] + demands[j]\n                if potential_load > capacity:\n                    heuristic_matrix[i,j] = 0\n\n    # K-Nearest Neighbor\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i,:])[1:k_nearest_neighbors+1]\n        for nn in neighbors_idx:\n            heuristic_matrix[i,nn] += 0.2\n\n    # Sparsify based on average distance\n    average_distance = np.mean(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i,j] > 2.0 * average_distance:\n                heuristic_matrix[i,j] = 0.0\n    \n    # Normalize\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix = heuristic_matrix / max_heuristic\n\n    return heuristic_matrix\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines distance, savings, demand, k-NN, and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Inverse distance\n    heuristic_matrix = 1 / (distance_matrix + 1e-9)\n\n    # Savings\n    savings_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    heuristic_matrix += savings_matrix / np.max(savings_matrix + 1e-9)\n\n    # Demand penalty\n    demand_penalty = np.zeros(n)\n    for i in range(1, n):\n      demand_penalty[i] = demands[i] / capacity\n\n    for i in range(n):\n      for j in range(n):\n        if i == j:\n          heuristic_matrix[i, j] = 0\n        else:\n            heuristic_matrix[i,j] /= (1 + 0.5*demand_penalty[i] + 0.5*demand_penalty[j]) # Penalize high demand\n\n    # K-Nearest Neighbor\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i,:])[1:k_nearest_neighbors+1]\n        for nn in neighbors_idx:\n            heuristic_matrix[i,nn] += 0.2\n\n    # Sparsify\n    average_distance = np.mean(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i,j] > 2.0 * average_distance:\n                heuristic_matrix[i,j] = 0.0\n\n    # Normalize\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix = heuristic_matrix / max_heuristic\n\n    return heuristic_matrix\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines distance, savings, demand, k-NN, and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Inverse distance\n    heuristic_matrix = 1 / (distance_matrix + 1e-9)\n\n    # Savings\n    savings_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    heuristic_matrix += savings_matrix / np.max(savings_matrix + 1e-9)\n\n    # Demand penalty\n    demand_penalty = np.zeros(n)\n    for i in range(1, n):\n      demand_penalty[i] = demands[i] / capacity\n\n    for i in range(n):\n      for j in range(n):\n        if i == j:\n          heuristic_matrix[i, j] = 0\n        else:\n            heuristic_matrix[i,j] /= (1 + 0.5*demand_penalty[i] + 0.5*demand_penalty[j]) # Penalize high demand\n\n    # K-Nearest Neighbor\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i,:])[1:k_nearest_neighbors+1]\n        for nn in neighbors_idx:\n            heuristic_matrix[i,nn] += 0.2\n\n    # Sparsify\n    average_distance = np.mean(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i,j] > 2.0 * average_distance:\n                heuristic_matrix[i,j] = 0.0\n\n    # Normalize\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix = heuristic_matrix / max_heuristic\n\n    return heuristic_matrix\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines inverse distance, demand, k-NN, sparsification.\"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Demand consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                    heuristics[i, j] = 0\n\n    # K-Nearest Neighbor\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]\n        for nn in neighbors_idx:\n            heuristics[i, nn] += 0.2\n\n    # Sparsify\n    average_distance = np.mean(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > 2.0 * average_distance:\n                heuristics[i, j] = 0.0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines inverse distance, demand, k-NN, sparsification.\"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Demand consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i != 0 and j != 0:\n                if demands[i] + demands[j] > capacity:\n                    heuristics[i, j] = 0\n\n    # K-Nearest Neighbor\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]\n        for nn in neighbors_idx:\n            heuristics[i, nn] += 0.2\n\n    # Sparsify\n    average_distance = np.mean(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > 2.0 * average_distance:\n                heuristics[i, j] = 0.0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Inverse distance component\n    inverse_distance = 1 / (distance_matrix + 1e-9)\n\n    # Demand penalty\n    demand_penalty = np.ones_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                if demands[i] + demands[j] > capacity:\n                    demand_penalty[i, j] = 0.1 # Penalize edges exceeding capacity\n\n    # Depot proximity component\n    depot_proximity = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        depot_proximity[0, i] = 1 / (distance_matrix[0, i] + 1e-9)\n        depot_proximity[i, 0] = 1 / (distance_matrix[i, 0] + 1e-9)\n\n    # Combine components\n    heuristics = inverse_distance * demand_penalty + depot_proximity\n\n    # Sparsification (remove less promising edges)\n    threshold = np.mean(heuristics) * 0.2  # Dynamic threshold\n    heuristics[heuristics < threshold] = 0\n\n    # Normalize\n    heuristics = heuristics / np.max(heuristics) if np.max(heuristics) > 0 else heuristics\n\n    return heuristics\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity, and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Inverse distance component\n    inverse_distance = 1 / (distance_matrix + 1e-9)\n\n    # Demand penalty\n    demand_penalty = np.ones_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                if demands[i] + demands[j] > capacity:\n                    demand_penalty[i, j] = 0.1 # Penalize edges exceeding capacity\n\n    # Depot proximity component\n    depot_proximity = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        depot_proximity[0, i] = 1 / (distance_matrix[0, i] + 1e-9)\n        depot_proximity[i, 0] = 1 / (distance_matrix[i, 0] + 1e-9)\n\n    # Combine components\n    heuristics = inverse_distance * demand_penalty + depot_proximity\n\n    # Sparsification (remove less promising edges)\n    threshold = np.mean(heuristics) * 0.2  # Dynamic threshold\n    heuristics[heuristics < threshold] = 0\n\n    # Normalize\n    heuristics = heuristics / np.max(heuristics) if np.max(heuristics) > 0 else heuristics\n\n    return heuristics\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Heuristic combining distance, demand, depot proximity, k-NN, sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Inverse distance\n    heuristic_matrix = 1 / (distance_matrix + 1e-9)\n\n    # Demand consideration, boost edges emanating from depot\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if i == 0:  # Depot departure boost with remaining capacity\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity > 0:\n                    heuristic_matrix[i, j] += 0.7\n                else:\n                    heuristic_matrix[i, j] = 0  #Invalid\n            else:\n                heuristic_matrix[i, j] /= (demands[j] + 1e-9)\n\n\n    # Depot proximity boost\n    for i in range(n):\n        for j in range(n):\n            if i == 0 or j == 0:\n                heuristic_matrix[i, j] += 0.6\n\n    # k-Nearest Neighbors\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]\n        for nn in neighbors_idx:\n            heuristic_matrix[i, nn] += 0.3\n\n    # Sparsification\n    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.2)\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    # Normalization\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix = heuristic_matrix / max_heuristic\n\n    return heuristic_matrix\n\n[Heuristics 19th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Heuristic combining distance, demand, depot proximity, k-NN, sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Inverse distance\n    heuristic_matrix = 1 / (distance_matrix + 1e-9)\n\n    # Demand consideration, boost edges emanating from depot\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if i == 0:  # Depot departure boost with remaining capacity\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity > 0:\n                    heuristic_matrix[i, j] += 0.7\n                else:\n                    heuristic_matrix[i, j] = 0  #Invalid\n            else:\n                heuristic_matrix[i, j] /= (demands[j] + 1e-9)\n\n\n    # Depot proximity boost\n    for i in range(n):\n        for j in range(n):\n            if i == 0 or j == 0:\n                heuristic_matrix[i, j] += 0.6\n\n    # k-Nearest Neighbors\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]\n        for nn in neighbors_idx:\n            heuristic_matrix[i, nn] += 0.3\n\n    # Sparsification\n    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.2)\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    # Normalization\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix = heuristic_matrix / max_heuristic\n\n    return heuristic_matrix\n\n[Heuristics 20th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Heuristic combining distance, demand, depot proximity, k-NN, sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Inverse distance\n    heuristic_matrix = 1 / (distance_matrix + 1e-9)\n\n    # Demand consideration, boost edges emanating from depot\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if i == 0:  # Depot departure boost with remaining capacity\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity > 0:\n                    heuristic_matrix[i, j] += 0.7\n                else:\n                    heuristic_matrix[i, j] = 0  #Invalid\n            else:\n                heuristic_matrix[i, j] /= (demands[j] + 1e-9)\n\n\n    # Depot proximity boost\n    for i in range(n):\n        for j in range(n):\n            if i == 0 or j == 0:\n                heuristic_matrix[i, j] += 0.6\n\n    # k-Nearest Neighbors\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]\n        for nn in neighbors_idx:\n            heuristic_matrix[i, nn] += 0.3\n\n    # Sparsification\n    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.2)\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    # Normalization\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix = heuristic_matrix / max_heuristic\n\n    return heuristic_matrix\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}