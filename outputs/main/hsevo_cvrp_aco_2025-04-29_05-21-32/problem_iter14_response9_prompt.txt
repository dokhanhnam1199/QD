{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\n### Better code\ndef heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"Combines distance, demand, depot proximity, angle, and k-NN with adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Demand and Depot Connection\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4\n\n    # Depot proximity with adaptive pruning and k-NN\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    k = 5\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]\n                if j in neighbors:\n                    heuristics[i, j] += 0.2\n\n    # Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)\n\n    # Sparsification: zero out small heuristic values and edges violating capacity for single vehicle routes.\n    threshold = 0.01 * np.mean(heuristics)  # Adaptive threshold\n    heuristics[heuristics < threshold] = 0\n    for i in range(1, n):  # Start from 1 to avoid depot self-loop\n        for j in range(1, n):\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i, depot_index] + distance_matrix[depot_index, j] < 1.5 * np.mean(distance_matrix):\n                heuristics[i, j] = 0  # Zero edges exceeding the vehicle capacity. Added proximity check to remove edges where going to depot in between is much shorter\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n### Worse code\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version refines heuristics_v1 by incorporating more adaptive and problem-aware components,\n    including cost-based prioritization, adaptive neighborhood scaling, and route completion encouragement.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # 1. Cost-Based Prioritization (Combined Distance and Demand): More informed initial values\n    cost_matrix = distance_matrix.copy()\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                cost_matrix[i, j] += (demands[i] + demands[j]) / capacity * np.mean(distance_matrix)  # Scale demand cost by average distance\n\n    heuristics = 1 / (cost_matrix + 1e-9)\n    heuristics *= np.mean(distance_matrix) #scaling\n\n    # 2. Depot Influence: Adaptive Scaling based on distance to depot and remaining capacity.\n    depot_distances = distance_matrix[:, depot_index]\n    remaining_capacity_weight = 0.3  # Tunable\n    depot_proximity_weight = 0.2\n    for i in range(1, n):\n        heuristics[depot_index, i] += depot_proximity_weight * (1 - depot_distances[i] / np.max(depot_distances))\n        heuristics[i, depot_index] = 0 #block return trip except from depot.\n\n    # 3. Route Completion Encouragement:  Prioritize links that help complete partial routes (Capacity-aware).\n    route_completion_weight = 0.25  # Tunable.\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                 # Encourage connections that reduce remaining capacity on a potential route\n                route_efficiency =  min(demands[i],demands[j])/(capacity + 1e-9) #Scale\n                heuristics[i, j] += route_completion_weight * route_efficiency\n\n\n    # 4. Adaptive Neighborhood Scaling (k-NN with dynamic k based on node density)\n    knn_base = 4\n    knn_weight = 0.15\n\n    # Estimate node density based on average distance to neighbors\n    node_densities = np.zeros(n)\n    for i in range(1, n):\n        distances_from_i = distance_matrix[i, 1:]\n        nearest_neighbors_dist = np.sort(distances_from_i)[:min(knn_base,n-1)]\n        node_densities[i] = np.mean(nearest_neighbors_dist)\n\n    mean_node_density = np.mean(node_densities[1:])\n\n    for i in range(1, n):\n        #Adaptive K based on node density compared to average\n        adaptive_knn = int(knn_base * (mean_node_density / (node_densities[i] + 1e-9)))\n        adaptive_knn = max(1, min(adaptive_knn, n - 1)) #Clamp between 1 and n-1\n        distances_from_i = distance_matrix[i, 1:]  # Exclude depot\n        nearest_neighbors = np.argsort(distances_from_i)[:adaptive_knn] + 1  # Get indices of nearest neighbors\n        for j in nearest_neighbors:\n            heuristics[i, j] += knn_weight\n            heuristics[j, i] += knn_weight\n\n\n    # 5. Sparsification: More aggressive sparsification based on percentile.\n    sparsification_percentile = 35  # Sparsify below this percentile. Tunable.\n    threshold = np.percentile(heuristics[heuristics > 0], sparsification_percentile)  #Consider only positive values\n    heuristics[heuristics < threshold] = 0\n\n\n\n    # 6. Normalize (After Sparsification)\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st ranks higher by incorporating pheromone reinforcement and a simulated learning route, whereas the 20th employs cost-based prioritization, adaptive neighborhood scaling, and route completion encouragement. Comparing (2nd best) vs (second worst), both share almost the same code, with no differences observed. Comparing (1st) vs (2nd), the key distinction lies in the inclusion of pheromone reinforcement and simulated route learning in the 1st, which are absent in the 2nd. (3rd) vs (4th) shows a shift towards simpler calculations and a more direct approach to depot connection preference. Comparing (second worst) vs (worst), both share almost the same code, with no differences observed. Overall: The better heuristics progressively integrate more sophisticated mechanisms like pheromone updates, adaptive parameter adjustments based on problem characteristics, and refined penalty systems, whereas worse heuristics rely on static weights and simpler combinations of basic factors like distance and demand.\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, here's a redefined approach to self-reflection for designing better heuristics, aiming to avoid pitfalls and focusing on actionable insights.\n\n*   **Keywords:** Adaptive parameters, incremental refinement, problem-specific constraints, normalization, k-NN intensification, sparsification.\n\n*   **Advice:** Begin with simple components, progressively integrate adaptive mechanisms (k-NN, sparsification), and normalize intermediate results. Focus on problem constraints to drive adaptation.\n\n*   **Avoid:** Overly complex formulas, fixed parameters, neglecting problem-specific constraints, relying solely on intuition, and premature optimization.\n\n*   **Explanation:** Start simple, *adapt* to the *problem*, and control scaling through normalization. Let problem constraints *guide* heuristic refinement, not complicate it.\n\n\nYour task is to write an improved function `heuristics_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}