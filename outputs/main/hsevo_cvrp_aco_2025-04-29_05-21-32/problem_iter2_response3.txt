```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Combines distance, savings, demand, and coordinate proximity for CVRP."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Distance and Savings (Clarke-Wright)
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Normalize savings and combine with inverse distance
    heuristic_matrix = (1 / (distance_matrix + np.eye(n))) + (savings_matrix / np.max(savings_matrix))

    # Demand penalty:  Penalize edges connecting nodes with high demand.
    demand_penalty = np.zeros(n)
    for i in range(1, n):
        demand_penalty[i] = demands[i] / capacity

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No loops
            else:
                heuristic_matrix[i, j] /= (1 + demand_penalty[i] + demand_penalty[j]) # Slightly penalize high demand nodes.

    # Coordinate proximity: Favor edges connecting nearby nodes in space.
    coordinate_distances = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            coordinate_distances[i, j] = np.linalg.norm(coordinates[i] - coordinates[j])

    heuristic_matrix += (1 / (coordinate_distances + np.eye(n)))  # Prefer shorter coordinate distance
    heuristic_matrix[np.isinf(heuristic_matrix)] = 0  # Handle infinities
    heuristic_matrix[np.isnan(heuristic_matrix)] = 0  # Handle NaN values

    return heuristic_matrix
```
