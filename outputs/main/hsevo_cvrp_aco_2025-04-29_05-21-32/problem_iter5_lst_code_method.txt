{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Improved heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Inverse distance (primary factor)\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand consideration - scaled penalty based on remaining capacity\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity < 0:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.3  # A bit boost from depot\n            elif i != depot_index and j == depot_index:\n                 heuristics[i,j] += 0.1 # encourage returning to depot\n\n\n\n    # Heuristic 3: Depot proximity encouragement\n    depot_distances = distance_matrix[:, depot_index]\n    for i in range(n):\n        if i != depot_index:\n             #Scaled by distance to depot\n            heuristics[i, depot_index] += 0.1 * (1 / (depot_distances[i] + 1e-9))\n\n    # Heuristic 4: K-Nearest Neighbor Bonus (Sparsification and Intensification)\n\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]  # Exclude self\n        for neighbor in neighbors_idx:\n            heuristics[i, neighbor] += 0.2 # tune-able\n\n    # Heuristic 5: Sparsification based on a threshold.\n    # A more aggressive sparsification.  This is crucial.\n\n    distance_threshold = np.mean(distance_matrix) * 1.5  #Example\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > distance_threshold:\n                heuristics[i, j] = 0\n\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristics combining distance, demand, and depot proximity.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    alpha = 0.7  # Distance weight\n    beta = 0.3  # Demand weight\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n            else:\n                distance_component = 1 / distance_matrix[i, j]\n                demand_component = 1 / (demands[i] + demands[j] + 1e-6)\n\n                depot_distance = distance_matrix[i, 0] + distance_matrix[j, 0]\n                depot_proximity = np.exp(-depot_distance / np.mean(distance_matrix))\n                heuristics[i, j] = (\n                    alpha * distance_component + beta * demand_component+ (1-alpha-beta)*depot_proximity\n                )\n\n    return heuristics\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Improved heuristics for CVRP, combining distance, savings, demand, and coordinates.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings based on Clarke-Wright algorithm\n    savings_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Incorporate distance and savings\n    heuristic_matrix = (1 / distance_matrix + savings_matrix / np.max(savings_matrix)) #avoiding infs/NaNs\n\n    # Penalize edges connecting to nodes with high demand relative to capacity\n    demand_penalty = np.zeros(n)\n    for i in range(1, n):\n      demand_penalty[i] = demands[i] / capacity\n\n    for i in range(n):\n      for j in range(n):\n        if i == j:\n          heuristic_matrix[i, j] = 0 #ensure no loops\n        else:\n            heuristic_matrix[i,j] /= (1 + demand_penalty[i] + demand_penalty[j]) #slightly penalize high demand nodes\n\n    #Prioritize connecting nodes that are close in coordinate space. This can help exploit locality.\n    coordinate_distances = np.zeros_like(distance_matrix)\n    for i in range(n):\n      for j in range(n):\n        coordinate_distances[i,j] = np.linalg.norm(coordinates[i] - coordinates[j])\n\n    heuristic_matrix += (1/coordinate_distances) #prefer edges with small coordinate distance\n    heuristic_matrix[np.isinf(heuristic_matrix)] = 0  # Remove any potential infinities created by division by zero on diagonals.\n    heuristic_matrix[np.isnan(heuristic_matrix)] = 0 # Clean NaN values\n\n    #Add depot proximity component\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                depot_proximity_component = (1 - (depot_distances[i] + depot_distances[j]) / (2 * max_depot_distance))\n                heuristic_matrix[i, j] += 0.1 * depot_proximity_component # Weight of 0.1\n    return heuristic_matrix\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Improved heuristics for CVRP, combining distance, savings, demand, and coordinates.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Calculate savings based on Clarke-Wright algorithm\n    savings_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Incorporate distance and savings\n    heuristic_matrix = (1 / distance_matrix + savings_matrix / np.max(savings_matrix)) #avoiding infs/NaNs\n\n    # Penalize edges connecting to nodes with high demand relative to capacity\n    demand_penalty = np.zeros(n)\n    for i in range(1, n):\n      demand_penalty[i] = demands[i] / capacity\n\n    for i in range(n):\n      for j in range(n):\n        if i == j:\n          heuristic_matrix[i, j] = 0 #ensure no loops\n        else:\n            heuristic_matrix[i,j] /= (1 + demand_penalty[i] + demand_penalty[j]) #slightly penalize high demand nodes\n\n    #Prioritize connecting nodes that are close in coordinate space. This can help exploit locality.\n    coordinate_distances = np.zeros_like(distance_matrix)\n    for i in range(n):\n      for j in range(n):\n        coordinate_distances[i,j] = np.linalg.norm(coordinates[i] - coordinates[j])\n\n    heuristic_matrix += (1/coordinate_distances) #prefer edges with small coordinate distance\n    heuristic_matrix[np.isinf(heuristic_matrix)] = 0  # Remove any potential infinities created by division by zero on diagonals.\n    heuristic_matrix[np.isnan(heuristic_matrix)] = 0 # Clean NaN values\n\n    #Add depot proximity component\n    depot_distances = distance_matrix[0, :]\n    max_depot_distance = np.max(depot_distances)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                depot_proximity_component = (1 - (depot_distances[i] + depot_distances[j]) / (2 * max_depot_distance))\n                heuristic_matrix[i, j] += 0.1 * depot_proximity_component # Weight of 0.1\n    return heuristic_matrix\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, savings, demand, and coordinate proximity for CVRP.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Distance and Savings (Clarke-Wright)\n    savings_matrix = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]\n\n    # Normalize savings and combine with inverse distance\n    heuristic_matrix = (1 / (distance_matrix + np.eye(n))) + (savings_matrix / np.max(savings_matrix))\n\n    # Demand penalty:  Penalize edges connecting nodes with high demand.\n    demand_penalty = np.zeros(n)\n    for i in range(1, n):\n        demand_penalty[i] = demands[i] / capacity\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No loops\n            else:\n                heuristic_matrix[i, j] /= (1 + demand_penalty[i] + demand_penalty[j]) # Slightly penalize high demand nodes.\n\n    # Coordinate proximity: Favor edges connecting nearby nodes in space.\n    coordinate_distances = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            coordinate_distances[i, j] = np.linalg.norm(coordinates[i] - coordinates[j])\n\n    heuristic_matrix += (1 / (coordinate_distances + np.eye(n)))  # Prefer shorter coordinate distance\n    heuristic_matrix[np.isinf(heuristic_matrix)] = 0  # Handle infinities\n    heuristic_matrix[np.isnan(heuristic_matrix)] = 0  # Handle NaN values\n\n    return heuristic_matrix\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates several improvements over v1, including a more refined demand consideration,\n    depot proximity enhancements, and sparsification of unpromising edges.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Inverse distance (primary factor)\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand consideration, penalizing edges that risk exceeding capacity\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            # Depot departures boost: only apply to edges *from* the depot. Scale inversely with demand.\n            if i == depot_index and j != depot_index:\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity > 0:\n                    heuristics[i, j] += 0.75 * (remaining_capacity / capacity)  # Scale boost by remaining capacity\n\n            # Penalize high-demand edges to discourage routes that fill up too quickly. Don't penalize edges *to* the depot.\n            if j != depot_index:\n                demand_penalty = demands[j] / capacity # Higher demand leads to higher penalty\n                heuristics[i, j] *= max(0, 1 - demand_penalty) #scale values to avoid negatives\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0 #impossible node visits\n\n    # Heuristic 3: Depot proximity. Encourages connections to nodes close to the depot.\n    # Adjust strength based on distance *from* the depot. Only do this for edges *from* a node.\n    for i in range(n):\n      if i != depot_index:\n        depot_distance = distance_matrix[i, depot_index]\n        proximity_bonus = max(0, 1 - (depot_distance / np.max(distance_matrix))) # Closer = larger bonus\n        heuristics[i, :] += 0.25 * proximity_bonus  # Apply bonus to *all* outbound edges from node i\n\n    # Heuristic 4: Sparsification - remove very unpromising edges to focus search\n    # Identify and zero out edges below a threshold based on mean heuristic value.\n\n    mean_heuristic = np.mean(heuristics)\n    sparsification_threshold = 0.25 * mean_heuristic  # Adjust this factor as needed\n\n    heuristics[heuristics < sparsification_threshold] = 0\n\n    # Heuristic 5: k-Nearest Neighbors encouragement (Similar to v1, but with fine-tuning)\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]  # Exclude self\n\n        for nn in neighbors_idx:\n            heuristics[i, nn] += 0.15  # Slight preference for neighbors\n\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates several heuristics for improved performance.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Heuristic 1: Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand consideration and capacity feasibility\n    depot_index = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            # Depot connection boost\n            if i == depot_index and j != depot_index:\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity < 0:\n                    heuristics[i, j] = 0  # Impossible start\n                else:\n                    heuristics[i, j] += 0.5\n\n            # Penalize edges that lead to immediate capacity issues.\n            # Consider cases where going i -> j -> depot is not possible with current capacity\n            if i != depot_index and j != depot_index:\n\n                potential_load = demands[i] + demands[j]\n                if potential_load > capacity:\n                    heuristics[i,j] = 0 #Cannot do\n\n            # Heuristic 3: Depot proximity (Encourage returning to the depot)\n            depot_distances = distance_matrix[:, depot_index]\n            # Favor returning to depot from nodes far away.\n            if i != depot_index:\n                heuristics[i, depot_index] += 0.1 * (np.max(distance_matrix) - depot_distances[i]) / np.max(distance_matrix)\n\n            #Heuristic 4: K-Nearest Neighbor\n            k_nearest_neighbors = 4 # Increased K, better performance in testing\n\n            neighbors_idx = np.argsort(distance_matrix[i,:])[1:k_nearest_neighbors+1]\n            for nn in neighbors_idx:\n                heuristics[i,nn] += 0.2\n            \n            \n            #Heuristic 5: Sparsify the matrix, remove unpromising connections\n            average_distance = np.mean(distance_matrix)\n            if distance_matrix[i,j] > 2.0 * average_distance:  #Adjusted threshold for stricter sparsification\n                heuristics[i,j] = 0.0\n\n\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates several heuristics for improved performance.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Heuristic 1: Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand consideration and capacity feasibility\n    depot_index = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            # Depot connection boost\n            if i == depot_index and j != depot_index:\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity < 0:\n                    heuristics[i, j] = 0  # Impossible start\n                else:\n                    heuristics[i, j] += 0.5\n\n            # Penalize edges that lead to immediate capacity issues.\n            # Consider cases where going i -> j -> depot is not possible with current capacity\n            if i != depot_index and j != depot_index:\n\n                potential_load = demands[i] + demands[j]\n                if potential_load > capacity:\n                    heuristics[i,j] = 0 #Cannot do\n\n            # Heuristic 3: Depot proximity (Encourage returning to the depot)\n            depot_distances = distance_matrix[:, depot_index]\n            # Favor returning to depot from nodes far away.\n            if i != depot_index:\n                heuristics[i, depot_index] += 0.1 * (np.max(distance_matrix) - depot_distances[i]) / np.max(distance_matrix)\n\n            #Heuristic 4: K-Nearest Neighbor\n            k_nearest_neighbors = 4 # Increased K, better performance in testing\n\n            neighbors_idx = np.argsort(distance_matrix[i,:])[1:k_nearest_neighbors+1]\n            for nn in neighbors_idx:\n                heuristics[i,nn] += 0.2\n            \n            \n            #Heuristic 5: Sparsify the matrix, remove unpromising connections\n            average_distance = np.mean(distance_matrix)\n            if distance_matrix[i,j] > 2.0 * average_distance:  #Adjusted threshold for stricter sparsification\n                heuristics[i,j] = 0.0\n\n\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates several heuristics for improved performance.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Heuristic 1: Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand consideration and capacity feasibility\n    depot_index = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            # Depot connection boost\n            if i == depot_index and j != depot_index:\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity < 0:\n                    heuristics[i, j] = 0  # Impossible start\n                else:\n                    heuristics[i, j] += 0.5\n\n            # Penalize edges that lead to immediate capacity issues.\n            # Consider cases where going i -> j -> depot is not possible with current capacity\n            if i != depot_index and j != depot_index:\n\n                potential_load = demands[i] + demands[j]\n                if potential_load > capacity:\n                    heuristics[i,j] = 0 #Cannot do\n\n            # Heuristic 3: Depot proximity (Encourage returning to the depot)\n            depot_distances = distance_matrix[:, depot_index]\n            # Favor returning to depot from nodes far away.\n            if i != depot_index:\n                heuristics[i, depot_index] += 0.1 * (np.max(distance_matrix) - depot_distances[i]) / np.max(distance_matrix)\n\n            #Heuristic 4: K-Nearest Neighbor\n            k_nearest_neighbors = 4 # Increased K, better performance in testing\n\n            neighbors_idx = np.argsort(distance_matrix[i,:])[1:k_nearest_neighbors+1]\n            for nn in neighbors_idx:\n                heuristics[i,nn] += 0.2\n            \n            \n            #Heuristic 5: Sparsify the matrix, remove unpromising connections\n            average_distance = np.mean(distance_matrix)\n            if distance_matrix[i,j] > 2.0 * average_distance:  #Adjusted threshold for stricter sparsification\n                heuristics[i,j] = 0.0\n\n\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristic for CVRP: Combines distance, demand, and proximity.\n    Uses inverse distance, demand penalty, and proximity bonus.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Distance heuristic\n    distance_heuristic = 1 / (distance_matrix + np.eye(n) * 1e-6)\n\n    # Demand penalty\n    demand_penalty = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                demand_penalty[i, j] = (demands[i] + demands[j]) / (2*capacity) # Normalized combined demand.\n\n    # Proximity factor\n    proximity_factor = np.zeros_like(distance_matrix)\n    center = np.mean(coordinates, axis=0)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist_to_center_i = np.linalg.norm(coordinates[i] - center)\n                dist_to_center_j = np.linalg.norm(coordinates[j] - center)\n                proximity = 1 / (dist_to_center_i + dist_to_center_j + 1e-6)\n                proximity_factor[i, j] = proximity\n                if i == 0 or j == 0:\n                    proximity_factor[i, j] *= (1 - (demands[i] + demands[j]) / (2*capacity))\n\n    # Combine factors\n    heuristic_matrix = distance_heuristic * (1 - 0.5 * demand_penalty) + 0.25 * proximity_factor\n\n    return heuristic_matrix\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristic combining distance, demand, and angle for CVRP.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    distance_importance = 1.0\n    demand_importance = 0.5\n    angle_importance = 0.2\n\n    depot_index = 0\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0\n                continue\n\n            distance_heuristic = 1 / distance_matrix[i, j] if distance_matrix[i, j] > 0 else 0\n\n            demand_heuristic = 1 - (demands[j] / capacity) if demands[j] < capacity else 0\n\n            vector_ij = coordinates[j] - coordinates[i]\n            vector_dj = coordinates[j] - coordinates[depot_index]\n\n            norm_ij = np.linalg.norm(vector_ij)\n            norm_dj = np.linalg.norm(vector_dj)\n\n            if norm_ij > 0 and norm_dj > 0:\n                cos_angle = np.dot(vector_ij, vector_dj) / (norm_ij * norm_dj)\n                cos_angle = np.clip(cos_angle, -1.0, 1.0)\n                angle = np.arccos(cos_angle)\n            else:\n                angle = np.pi / 2\n\n            angle_heuristic = 1 - (angle / np.pi)\n\n            heuristic_matrix[i, j] = (\n                distance_importance * distance_heuristic +\n                demand_importance * demand_heuristic +\n                angle_importance * angle_heuristic\n            )\n    return heuristic_matrix\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristic combining distance, demand, and angle for CVRP.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    distance_importance = 1.0\n    demand_importance = 0.5\n    angle_importance = 0.2\n\n    depot_index = 0\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0\n                continue\n\n            distance_heuristic = 1 / distance_matrix[i, j] if distance_matrix[i, j] > 0 else 0\n\n            demand_heuristic = 1 - (demands[j] / capacity) if demands[j] < capacity else 0\n\n            vector_ij = coordinates[j] - coordinates[i]\n            vector_dj = coordinates[j] - coordinates[depot_index]\n\n            norm_ij = np.linalg.norm(vector_ij)\n            norm_dj = np.linalg.norm(vector_dj)\n\n            if norm_ij > 0 and norm_dj > 0:\n                cos_angle = np.dot(vector_ij, vector_dj) / (norm_ij * norm_dj)\n                cos_angle = np.clip(cos_angle, -1.0, 1.0)\n                angle = np.arccos(cos_angle)\n            else:\n                angle = np.pi / 2\n\n            angle_heuristic = 1 - (angle / np.pi)\n\n            heuristic_matrix[i, j] = (\n                distance_importance * distance_heuristic +\n                demand_importance * demand_heuristic +\n                angle_importance * angle_heuristic\n            )\n    return heuristic_matrix\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristic combining distance, demand, and angle for CVRP.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    distance_importance = 1.0\n    demand_importance = 0.5\n    angle_importance = 0.2\n\n    depot_index = 0\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0\n                continue\n\n            distance_heuristic = 1 / distance_matrix[i, j] if distance_matrix[i, j] > 0 else 0\n\n            demand_heuristic = 1 - (demands[j] / capacity) if demands[j] < capacity else 0\n\n            vector_ij = coordinates[j] - coordinates[i]\n            vector_dj = coordinates[j] - coordinates[depot_index]\n\n            norm_ij = np.linalg.norm(vector_ij)\n            norm_dj = np.linalg.norm(vector_dj)\n\n            if norm_ij > 0 and norm_dj > 0:\n                cos_angle = np.dot(vector_ij, vector_dj) / (norm_ij * norm_dj)\n                cos_angle = np.clip(cos_angle, -1.0, 1.0)\n                angle = np.arccos(cos_angle)\n            else:\n                angle = np.pi / 2\n\n            angle_heuristic = 1 - (angle / np.pi)\n\n            heuristic_matrix[i, j] = (\n                distance_importance * distance_heuristic +\n                demand_importance * demand_heuristic +\n                angle_importance * angle_heuristic\n            )\n    return heuristic_matrix\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines distance, demand, and angular factors.\"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # 1. Distance heuristic\n    distance_heuristic = 1 / (distance_matrix + 1e-6)\n\n    # 2. Demand heuristic\n    demand_penalty = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                demand_prob_i = demands[i] / capacity if i != 0 else 0\n                demand_prob_j = demands[j] / capacity if j != 0 else 0\n                demand_penalty[i, j] = min(demand_prob_i + demand_prob_j, 1)\n    demand_heuristic = 1 - demand_penalty\n\n    # 3. Angular heuristic\n    depot_x, depot_y = coordinates[0]\n    angular_heuristic = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                x_i, y_i = coordinates[i]\n                x_j, y_j = coordinates[j]\n                vector_i = np.array([x_i - depot_x, y_i - depot_y])\n                vector_j = np.array([x_j - depot_x, y_j - depot_y])\n                dot_product = np.dot(vector_i, vector_j)\n                magnitude_i = np.linalg.norm(vector_i)\n                magnitude_j = np.linalg.norm(vector_j)\n                if magnitude_i == 0 or magnitude_j == 0:\n                    angle_radians = 0.0\n                else:\n                    angle_radians = np.arccos(dot_product / (magnitude_i * magnitude_j))\n                angular_heuristic[i, j] = 1 - np.abs(angle_radians) / np.pi\n\n    # Combine heuristics with weights\n    alpha = 0.5  # Distance\n    beta = 0.3  # Demand\n    gamma = 0.2  # Angle\n    heuristics = alpha * distance_heuristic + beta * demand_heuristic + gamma * angular_heuristic\n\n    # No self-loops\n    for i in range(n):\n        heuristics[i, i] = 0\n\n    return heuristics\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Combines inverse distance with demand and depot proximity for CVRP heuristic.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Base: Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Demand penalization\n    max_demand = np.max(demands)\n    normalized_demands = demands / max_demand if max_demand > 0 else np.zeros_like(demands)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n            if i!= 0 and j != 0:\n                demand_penalty = normalized_demands[i] + normalized_demands[j]\n                heuristics[i, j] /= (1 + demand_penalty)\n\n\n    #Depot proximity reward/penalty\n    for i in range(n):\n        for j in range(n):\n\n            depot_distance_penalty = 0.0\n            depot_distance_penalty = (distance_matrix[0, i] + distance_matrix[0, j]) / (2 * np.mean(distance_matrix))\n\n            heuristics[i, j] /= (1 + depot_distance_penalty)\n    # Normalize\n    heuristics = heuristics / np.max(heuristics)\n\n    return heuristics\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines inverse distance, demand penalty, and depot proximity.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    inverse_distance = 1 / (distance_matrix + 1e-9)\n    demand_penalty = np.ones_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                if demands[i] + demands[j] > capacity:\n                    demand_penalty[i, j] = 0.1\n\n    depot_proximity = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        depot_proximity[0, i] = 1 / (distance_matrix[0, i] + 1e-9)\n        depot_proximity[i, 0] = 1 / (distance_matrix[i, 0] + 1e-9)\n\n    heuristics = inverse_distance * demand_penalty + depot_proximity\n    heuristics = heuristics / np.max(heuristics)\n\n    return heuristics\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Heuristic combining distance, demand, angle from depot, and depot proximity.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            dist_heuristic = 1 / (distance_matrix[i, j] + 1e-6)\n\n            demand_penalty_i = demands[i] / capacity if i != 0 else 0\n            demand_penalty_j = demands[j] / capacity if j != 0 else 0\n\n            angle_penalty = 1\n            if i == 0:\n                x_i, y_i = coordinates[i]\n                x_j, y_j = coordinates[j]\n                dx = x_j - x_i\n                dy = y_j - y_i\n                angle = np.arctan2(dy, dx)\n                angle_penalty = 1 / (np.abs(angle) + 1e-6)\n\n            depot_proximity_i = distance_matrix[0, i]\n            depot_proximity_j = distance_matrix[0, j]\n            depot_proximity_heuristic = 1 / ((depot_proximity_i + depot_proximity_j) / 2 + 1e-6)\n\n            heuristic_matrix[i, j] = (0.5 * dist_heuristic * (1 - demand_penalty_i) * (1 - demand_penalty_j) * angle_penalty +\n                                     0.5 * depot_proximity_heuristic)\n\n    return heuristic_matrix\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Heuristic combining distance, demand, angle from depot, and depot proximity.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            dist_heuristic = 1 / (distance_matrix[i, j] + 1e-6)\n\n            demand_penalty_i = demands[i] / capacity if i != 0 else 0\n            demand_penalty_j = demands[j] / capacity if j != 0 else 0\n\n            angle_penalty = 1\n            if i == 0:\n                x_i, y_i = coordinates[i]\n                x_j, y_j = coordinates[j]\n                dx = x_j - x_i\n                dy = y_j - y_i\n                angle = np.arctan2(dy, dx)\n                angle_penalty = 1 / (np.abs(angle) + 1e-6)\n\n            depot_proximity_i = distance_matrix[0, i]\n            depot_proximity_j = distance_matrix[0, j]\n            depot_proximity_heuristic = 1 / ((depot_proximity_i + depot_proximity_j) / 2 + 1e-6)\n\n            heuristic_matrix[i, j] = (0.5 * dist_heuristic * (1 - demand_penalty_i) * (1 - demand_penalty_j) * angle_penalty +\n                                     0.5 * depot_proximity_heuristic)\n\n    return heuristic_matrix\n\n[Heuristics 19th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Improved heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Inverse distance\n    inverse_distance = 1 / (distance_matrix + 1e-9)\n    heuristics += inverse_distance\n\n    # Heuristic 2: Demand consideration\n    demand_factor = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            #Adjust for Depot Location and the assumption vehicles have just left depot and moving outward\n            if i == depot_index and j != depot_index:\n                remaining_capacity_after_visit = capacity - demands[j]\n                if remaining_capacity_after_visit < 0:\n                    demand_factor[i, j] = 0\n                else:\n                    demand_factor[i, j] = 0.7  # Boost for paths emanating from the depot\n\n            else:\n                demand_factor[i, j] = 1 / (demands[j] + 1e-9) #Nodes with smaller demand become more attractive\n\n    heuristics += demand_factor\n\n    # Heuristic 3: Depot proximity - encourage connections to/from the depot\n\n    depot_proximity_factor = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i == depot_index or j == depot_index:\n                depot_proximity_factor[i,j] = 0.6 #Boost edges connected to the depot\n    heuristics += depot_proximity_factor\n\n    #Heuristic 4: k-Nearest Neighbors\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i,:])[1:k_nearest_neighbors+1] # not include self, start at index 1\n\n        for nn in neighbors_idx:\n            heuristics[i,nn] = heuristics[i,nn] + 0.3  #Give slight preference (tune-able: 0.3)\n\n\n    # Sparsification: Remove edges with very low heuristic values\n\n    threshold = np.quantile(heuristics[heuristics > 0], 0.2)  # Keep top 80% edges, remove very bad ones\n    heuristics[heuristics < threshold] = 0\n\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 20th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Improved heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Inverse distance\n    inverse_distance = 1 / (distance_matrix + 1e-9)\n    heuristics += inverse_distance\n\n    # Heuristic 2: Demand consideration\n    demand_factor = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            #Adjust for Depot Location and the assumption vehicles have just left depot and moving outward\n            if i == depot_index and j != depot_index:\n                remaining_capacity_after_visit = capacity - demands[j]\n                if remaining_capacity_after_visit < 0:\n                    demand_factor[i, j] = 0\n                else:\n                    demand_factor[i, j] = 0.7  # Boost for paths emanating from the depot\n\n            else:\n                demand_factor[i, j] = 1 / (demands[j] + 1e-9) #Nodes with smaller demand become more attractive\n\n    heuristics += demand_factor\n\n    # Heuristic 3: Depot proximity - encourage connections to/from the depot\n\n    depot_proximity_factor = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i == depot_index or j == depot_index:\n                depot_proximity_factor[i,j] = 0.6 #Boost edges connected to the depot\n    heuristics += depot_proximity_factor\n\n    #Heuristic 4: k-Nearest Neighbors\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i,:])[1:k_nearest_neighbors+1] # not include self, start at index 1\n\n        for nn in neighbors_idx:\n            heuristics[i,nn] = heuristics[i,nn] + 0.3  #Give slight preference (tune-able: 0.3)\n\n\n    # Sparsification: Remove edges with very low heuristic values\n\n    threshold = np.quantile(heuristics[heuristics > 0], 0.2)  # Keep top 80% edges, remove very bad ones\n    heuristics[heuristics < threshold] = 0\n\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}