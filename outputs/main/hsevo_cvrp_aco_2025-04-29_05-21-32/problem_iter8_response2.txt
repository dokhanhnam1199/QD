```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """CVRP heuristics: Combines distance, savings, demand, k-NN, sparsification, and depot handling."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Inverse distance
    heuristic_matrix = 1 / (distance_matrix + 1e-9)

    # Savings based on Clarke-Wright
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    heuristic_matrix += savings_matrix / np.max(savings_matrix + 1e-9)

    # Demand consideration and depot proximity
    depot_index = 0
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0
                continue

            if i == depot_index and j != depot_index:
                remaining_capacity = capacity - demands[j]
                if remaining_capacity < 0:
                    heuristic_matrix[i, j] = 0
                else:
                    heuristic_matrix[i, j] += 0.25 #Slightly less boost
            
            if i != depot_index and j != depot_index:
                potential_load = demands[i] + demands[j]
                if potential_load > capacity:
                    heuristic_matrix[i,j] = 0

    # K-Nearest Neighbor
    k_nearest_neighbors = 4
    for i in range(n):
        neighbors_idx = np.argsort(distance_matrix[i,:])[1:k_nearest_neighbors+1]
        for nn in neighbors_idx:
            heuristic_matrix[i,nn] += 0.2
            
    # Sparsify based on average distance
    average_distance = np.mean(distance_matrix)
    for i in range(n):
        for j in range(n):
            if distance_matrix[i,j] > 2.0 * average_distance:
                heuristic_matrix[i,j] = 0.0

    # Normalize
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        heuristic_matrix = heuristic_matrix / max_heuristic

    return heuristic_matrix
```
