```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for CVRP using a combination of distance, demand, and angular considerations.

    Args:
        distance_matrix: Distance matrix between nodes.
        coordinates: Coordinates of nodes.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        A matrix of heuristics values, indicating the desirability of each edge.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Heuristic components:
    # 1. Distance-based: Shorter distances are preferred.  Adjusted by capacity.
    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Avoid division by zero

    # 2. Demand-based:  Penalize edges connecting to nodes that would easily saturate vehicle capacity.
    demand_penalty = np.zeros((n,n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_penalty[i, j] = 0  # Avoid self-loops.
            else:
                # Probability of exceeding capacity by going to j directly from depot
                demand_prob_i = demands[i]/capacity if i != 0 else 0
                demand_prob_j = demands[j]/capacity if j != 0 else 0
                demand_penalty[i, j] = min(demand_prob_i + demand_prob_j,1)
    demand_heuristic = 1 - demand_penalty

    # 3. Angular-based:  Prefer routes that are less likely to cause sharp turns. Helps to explore diverse routes

    depot_x, depot_y = coordinates[0]  # Depot location
    angular_heuristic = np.zeros((n, n))

    for i in range(n):
        for j in range(n):
            if i != j:
                 #calculate angle between vector depot-i and depot-j.
                x_i, y_i = coordinates[i]
                x_j, y_j = coordinates[j]

                vector_i = np.array([x_i - depot_x, y_i - depot_y])
                vector_j = np.array([x_j - depot_x, y_j - depot_y])

                # Dot product to calculate angle
                dot_product = np.dot(vector_i, vector_j)
                magnitude_i = np.linalg.norm(vector_i)
                magnitude_j = np.linalg.norm(vector_j)
                if (magnitude_i == 0 or magnitude_j == 0):
                    angle_radians = 0.0  # Assign 0 if either vector is zero
                else:
                     angle_radians = np.arccos(dot_product / (magnitude_i * magnitude_j)) #Angle in radians.

                angular_heuristic[i,j] = 1 - np.abs(angle_radians) / np.pi # Normalise the angle



    # Combine the heuristics: weighted sum.
    alpha = 0.5  # Weight for distance
    beta = 0.3   # Weight for demand
    gamma = 0.2 # Weight for angle
    heuristics = alpha * distance_heuristic + beta * demand_heuristic + gamma * angular_heuristic

    # Ensure no self-loops:
    for i in range(n):
        heuristics[i, i] = 0

    return heuristics
```
