{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\nCurrent heuristics:\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity, angle considerations, k-NN intensification,\n    and adaptive sparsification with more refined components and weight tuning. It also adds a route length\n    estimation penalty and refines the k-NN selection and sparsification.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance (with a slight modification)\n    distance_scaling = np.mean(distance_matrix)\n    heuristics = distance_scaling / (distance_matrix + 1e-9)  # Use scaling directly in the division\n\n    # Heuristic 2: Demand and Capacity consideration\n    demand_penalty_factor = 0.6  # Tunable weight - Increased importance of demand\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:  # Directly prune edges that violate capacity constraint.\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.7  # Depot boost (increased)\n            elif i != depot_index and j != depot_index:\n                demand_ratio = (demands[i] + demands[j]) / capacity\n                demand_penalty = demand_penalty_factor * demand_ratio**1.5 # Higher power to amplify penalty for large demand\n                heuristics[i, j] -= demand_penalty\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    depot_proximity_weight = 0.2  # Tunable weight - Increased importance\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= depot_proximity_weight * detour_penalty\n\n                # Adaptive pruning based on demand and distance - more aggressive\n                if distance_matrix[i, j] > 1.1 * distance_scaling and demands[i] + demands[j] > capacity / 2:\n                    heuristics[i, j] = 0\n\n    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)\n    angle_weight = 0.3  # Tunable weight - Increased importance\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n                    heuristics[i, j] += angle_weight * (1 - angle / np.pi)**2  # Favor smaller angles even more\n\n    # Heuristic 5: k-NN intensification (Focus on local search) - Refined k-NN selection\n    knn = min(7, n - 1)  # Adjusted k-NN, ensure knn < n-1\n    knn_weight = 0.2  # Tunable weight - Increased importance\n\n    for i in range(1, n):\n        # Find k-nearest neighbors based on distance, excluding depot.\n        distances_from_i = distance_matrix[i, 1:]\n        nearest_neighbors = np.argsort(distances_from_i)[:knn] + 1  # Correctly offset indices\n\n        # Demand aware k-NN selection.\n        demand_neighbors = []\n        for neighbor in nearest_neighbors:\n            if demands[i] + demands[neighbor] <= capacity:\n                demand_neighbors.append(neighbor)\n\n        # No neighbors satisfying demand constraint.\n        if len(demand_neighbors) == 0:\n            for j in nearest_neighbors:\n                heuristics[i, j] += knn_weight/2.0\n                heuristics[j, i] += knn_weight/2.0\n            continue # Move to the next i\n\n        for j in demand_neighbors:\n            heuristics[i, j] += knn_weight\n            heuristics[j, i] += knn_weight\n\n    # Heuristic 6: Route length estimation and penalty\n    route_length_weight = 0.1 # Tunable weight for route length\n\n    for i in range(1,n):\n        for j in range(1,n):\n            if i != j:\n                #Estimate the route length if edge (i,j) included. Simplified estimation.\n                estimated_route_length = distance_matrix[depot_index, i] + distance_matrix[i,j] + distance_matrix[j, depot_index]\n                heuristics[i,j] -= route_length_weight * estimated_route_length / (3 * distance_scaling + 1e-9)\n\n    # Heuristic 7: Sparsification: zero out small heuristic values (Adaptive Threshold) - Refined Sparsification\n    threshold_factor = 0.03 # Tunable parameter for adaptive threshold - Adjusted Threshold\n    threshold = threshold_factor * np.std(heuristics) #Adaptive threshold uses standard deviation\n    heuristics[heuristics < threshold] = 0 #Sparsify only based on values smaller than threshold\n\n    # Normalize (After Sparsification)\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\nNow, think outside the box write a mutated function `heuristics_v2` better than current version.\nYou can use some hints below:\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, here's a redefined approach to self-reflection for designing better heuristics, aiming to avoid pitfalls and focusing on actionable insights.\n\n*   **Keywords:** Adaptive parameters, incremental refinement, problem-specific constraints, normalization, k-NN intensification, sparsification.\n\n*   **Advice:** Begin with simple components, progressively integrate adaptive mechanisms (k-NN, sparsification), and normalize intermediate results. Focus on problem constraints to drive adaptation.\n\n*   **Avoid:** Overly complex formulas, fixed parameters, neglecting problem-specific constraints, relying solely on intuition, and premature optimization.\n\n*   **Explanation:** Start simple, *adapt* to the *problem*, and control scaling through normalization. Let problem constraints *guide* heuristic refinement, not complicate it.\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}