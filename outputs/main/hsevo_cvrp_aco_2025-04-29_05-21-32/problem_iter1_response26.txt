```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and angular considerations.

    Args:
        distance_matrix: Distance matrix (n x n).
        coordinates: Node coordinates (n x 2).
        demands: Node demands (n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of heuristics values (n x n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters for tuning the heuristic. Adjust these to see what works best
    distance_weight = 1.0   # Weight for the distance component
    demand_weight = 0.5    # Weight for the demand component
    angle_weight = 0.2     # Weight for the angle component
    capacity_penalty = 2.0 # Scale the influence of node exceeding available capacity.
    depot_proximity = 0.8 # Scale for biasing route construction for near to depot customers.
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance component (inverse distance, as shorter distances are preferred)
            distance_heuristic = 1 / distance_matrix[i, j]

            # Demand component (penalize high demands if both are not the depot)
            demand_heuristic = 1
            if i != 0 and j != 0:
                demand_heuristic = max(0.0, 1 - demands[j] / capacity * capacity_penalty) #Penalize higher demand

            # Angle component (encourage routes with less sharp turns, considering the depot)
            angle_heuristic = 1.0
            if i != 0 and j != 0:
              depot_x, depot_y = coordinates[0]
              x_i, y_i = coordinates[i]
              x_j, y_j = coordinates[j]

              #Calculate angles
              angle_i = np.arctan2(y_i - depot_y, x_i - depot_x)
              angle_j = np.arctan2(y_j - depot_y, x_j - depot_x)

              #Calculate the absolute difference between angles. Make the differences
              #to always be in range 0 - pi to avoid penalizing the case
              #in which a node is visited at different direction from the depot.
              angle_diff = np.abs(angle_i-angle_j)
              angle_diff = min(angle_diff, 2 * np.pi - angle_diff)

              angle_heuristic = max(0.0, 1 - (angle_diff / np.pi) * angle_weight)
            elif j == 0: #incentivize returns to depot
                angle_heuristic = depot_proximity
            elif i == 0:
                angle_heuristic = depot_proximity

            # Combine the components using weighted sum
            heuristic_matrix[i, j] = (
                distance_weight * distance_heuristic +
                demand_weight * demand_heuristic +
                angle_weight * angle_heuristic
            )

    # Normalize the heuristic matrix (optional, but can be helpful)
    heuristic_matrix = (heuristic_matrix - np.min(heuristic_matrix)) / (np.max(heuristic_matrix) - np.min(heuristic_matrix))

    return heuristic_matrix
```
