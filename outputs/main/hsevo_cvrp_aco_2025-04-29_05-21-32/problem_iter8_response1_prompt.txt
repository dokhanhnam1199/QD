{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\n### Better code\ndef heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity and angle considerations with adaptive sparsification and simplified components.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity: # Directly prune edges that violate capacity constraint.\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i,j] += 0.3 #Depot boost\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route.  Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2*mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty # Reduced weight\n\n                # Adaptive pruning based on demand and distance.  Less aggressive than v1.\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity/3: #Only prune if nodes have considerable demand compared to vehicle capacity.\n                    heuristics[i,j] = 0\n\n\n    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    # Convert cosine to angle in radians\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) #Ensure within valid range\n\n                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value\n                    heuristics[i,j] += 0.1 * (1 - angle / np.pi) # Normalized angle reward, reduced weight\n\n\n    # Heuristic 5: Sparsification: zero out small heuristic values\n    threshold = 0.01 * np.mean(heuristics) # Adaptive threshold\n    heuristics[heuristics < threshold] = 0\n\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n### Worse code\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version focuses on a simplified approach with adaptive intensification and sparsification.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Inverse distance with a small constant to avoid division by zero\n    heuristics = 1 / (distance_matrix + 1e-6)\n\n    # Heuristic 2: Depot connection encouragement based on demand and distance\n    for j in range(1, n):  # Iterate over customers (excluding depot)\n        # Encourage connections from the depot to customers\n        if demands[j] <= capacity:  # Only consider if demand is within capacity\n            heuristics[depot_index, j] += 0.5 / (distance_matrix[depot_index, j] + 1e-6)  # Boost, scaled by inverse distance\n            heuristics[j, depot_index] = 0 #no incoming edges to depot except from depot.\n        else:\n            heuristics[depot_index, j] = 0 #prune edges if single demand exceeds capacity.\n\n    # Heuristic 3: Demand-based Sparsification: Adaptive threshold\n    mean_distance = np.mean(distance_matrix)\n    mean_demand = np.mean(demands[1:])  # Exclude depot demand\n    threshold = mean_distance * mean_demand * 1.5  # Adaptive threshold based on means\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            combined_metric = distance_matrix[i, j] * (demands[i] + demands[j]) #Considers combined demand\n\n            if combined_metric > threshold:\n                heuristics[i, j] = 0  # Aggressive pruning if over threshold\n\n    # Heuristic 4: Nearest Neighbor Adjustment (Simplified k-NN)\n    k_nearest_neighbors = 2 # Reduced k for simplicity\n    for i in range(1, n):\n        neighbors_idx = np.argsort(distance_matrix[i, 1:])[ :k_nearest_neighbors] + 1 # Exclude self and depot, adjust indices\n        for nn in neighbors_idx:\n            heuristics[i, nn] += 0.1 # Small encouragement\n\n    # Heuristic 5:  Discourage long edges generally (more aggressive sparsification)\n    long_edge_threshold = np.median(distance_matrix) * 2  #Example: Adaptive threshold\n    for i in range(1,n):\n        for j in range(1,n):\n            if distance_matrix[i,j] > long_edge_threshold:\n                heuristics[i,j] = 0\n\n    # Normalize to [0, 1]\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the top heuristic uses depot proximity with adaptive pruning, angle from depot, and sparsification based on the mean of heuristic values, while the bottom heuristic relies on inverse distance, demand consideration, depot proximity, k-NN, and sparsification using a quantile-based threshold. The top heuristic also focuses on pruning infeasible edges related to capacity early on.\nComparing (2nd best) vs (2nd worst), the second-best also contains depot proximity, angle from depot, and sparsification but lacks the explicit adaptive pruning based on capacity constraints. The second-worst only calculates demand penalty instead of hard pruning edges.\nComparing (1st) vs (2nd), we see the top heuristic includes stronger depot connection boosts and considers a normalized angle reward, while the second heuristic omits the route completion incentive.\nComparing (3rd) vs (4th), the 3rd and 4th heuristic are similar, but the 4th heuristic incorporates route completion incentives, stronger depot connection boosts, and a more sophisticated sparsification approach based on combined distance and demand. Comparing (second worst) vs (worst), both functions are virtually identical. Overall: The better heuristics incorporate more nuanced adaptive sparsification techniques (based on means and combined metrics), depot proximity and angle considerations and prioritize pruning infeasible edges.\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, let's refine \"Current self-reflection\" for designing better heuristics, avoiding the pitfalls of \"Ineffective self-reflection\" (which is currently empty, implying all current reflections are potentially valuable). Here's a redefinition:\n\n*   **Keywords:** Adaptive pruning, problem constraints, factor combinations (distance, demand, angles), normalization, iterative refinement, k-NN intensification, sparsification, depot-specific adjustments, weight tuning.\n*   **Advice:** Begin with simple, intuitive heuristics. Incrementally add sophistication (k-NN, sparsification, depot adjustments) while prioritizing weight tuning for parameter control and balance.\n*   **Avoid:** Overly complex combinations or excessively specific calculations early on. Prematurely dismissing the value of weight optimization.\n*   **Explanation:** Start simple, normalize to stabilize, adapt based on problem constraints, tune weights to balance factors, and iteratively improve the heuristic's components.\n\n\nYour task is to write an improved function `heuristics_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}