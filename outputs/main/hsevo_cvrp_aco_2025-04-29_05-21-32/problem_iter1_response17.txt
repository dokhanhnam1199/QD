```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP edge prioritization, considering distance, angle, demand, and depot proximity.

    This function combines several heuristic principles inspired by physical intuition
    and problem-specific considerations to estimate the "attractiveness" of including
    each edge in a CVRP solution.

    Args:
        distance_matrix (np.ndarray): n x n matrix of distances between nodes.
        coordinates (np.ndarray): n x 2 matrix of node coordinates (x, y).
        demands (np.ndarray): Vector of customer demands (including depot demand).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: n x n matrix of edge scores (higher is better).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (tuned for potentially better performance, feel free to adjust)
    alpha = 1.0  # Distance weighting (attractiveness decreases with distance)
    beta = 0.5 # Demand weighting (discourages high demand edges early on)
    gamma = 0.2 # Angle weighting (encourages smooth paths/turns)
    delta = 0.8 # Depot proximity (encourages routes to originate/terminate near depot)

    # Avoid division by zero
    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)

    # Calculate angle scores (higher = smaller angle = smoother path)
    def angle_score(i, j, k):
        """Calculates angle between edges (i,j) and (j,k). Closer to 180 is better."""
        vec_ij = coordinates[j] - coordinates[i]
        vec_jk = coordinates[k] - coordinates[j]

        norm_ij = np.linalg.norm(vec_ij)
        norm_jk = np.linalg.norm(vec_jk)

        if norm_ij == 0 or norm_jk == 0:
            return 0.  # Or a small value to avoid issues

        dot_product = np.dot(vec_ij, vec_jk)
        cosine_angle = dot_product / (norm_ij * norm_jk)

        # Clip to ensure valid arccos input. Critical for numerical stability.
        cosine_angle = np.clip(cosine_angle, -1.0, 1.0)

        angle_rad = np.arccos(cosine_angle)
        angle_deg = np.degrees(angle_rad)

        #We aim for turning angle being small and close to 180 degrees
        return 1 - abs(angle_deg - 180) / 180 # Scale between 0 and 1. Near 180 is near 1

    for i in range(n):
        for j in range(n):
            if i != j:  #No self loops
                # Basic distance heuristic
                distance_score = 1 / (distance_matrix[i, j] ** alpha)

                # Demand heuristic
                demand_score = np.exp(-beta * (demands[i] + demands[j]) / capacity) # Penalize high demand edges

                # Depot proximity heuristic (encourage routes starting/ending near the depot)
                depot_proximity_score = (
                    np.exp(-delta * distance_matrix[i, 0] / np.max(distance_matrix)) +  # How close i is to depot
                    np.exp(-delta * distance_matrix[j, 0] / np.max(distance_matrix))    # How close j is to depot
                )

                #Angle needs k, and there are n choices of k.
                angle_sum = 0
                for k in range(n):
                  if i != k and j != k:
                    angle_sum += angle_score(i,j,k)
                angle_score_avg = angle_sum/(n-2) if n > 2 else 0  # average turning angle across all possibilities.

                # Combine the heuristics
                heuristic_matrix[i, j] = (
                    distance_score * demand_score * depot_proximity_score * (angle_score_avg**gamma)
                )

    return heuristic_matrix
```
