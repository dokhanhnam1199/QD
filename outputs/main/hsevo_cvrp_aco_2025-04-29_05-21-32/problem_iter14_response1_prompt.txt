{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\n### Better code\ndef heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"CVRP heuristic: Combines distance, demand, depot proximity, angle, adaptive sparsification, and k-NN.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Demand and Depot Connection\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4\n            elif i != depot_index and j == depot_index:\n                heuristics[i,j] = 0\n            else:\n                heuristics[i,j] += 1/(distance_matrix[i,j] * demands[j] + 1e-9)\n\n    # Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)\n\n    # Adaptive Sparsification and k-NN\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n    k = 5  # Number of nearest neighbors\n\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != depot_index and j != depot_index:\n                #Penalize edges based on detour from direct depot route. Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty  # Increased weight\n\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]\n                if j in neighbors:\n                    heuristics[i, j] += 0.2\n\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i,depot_index] + distance_matrix[depot_index, j] < 1.5* np.mean(distance_matrix):\n                heuristics[i, j] = 0\n\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n### Worse code\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"CVRP heuristic: Combines adaptive pruning, demand/capacity, depot proximity, and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Depot connection encouragement\n    for j in range(1, n):\n        if demands[j] <= capacity:\n            heuristics[depot_index, j] += 0.5 / (distance_matrix[depot_index, j] + 1e-6)\n            heuristics[j, depot_index] = 0\n        else:\n            heuristics[depot_index, j] = 0\n\n    # Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n    # Demand-based Sparsification\n    mean_distance = np.mean(distance_matrix)\n    mean_demand = np.mean(demands[1:])\n    threshold = mean_distance * mean_demand * 1.5\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            combined_metric = distance_matrix[i, j] * (demands[i] + demands[j])\n            if combined_metric > threshold:\n                heuristics[i, j] = 0\n\n    # Sparsification\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st ranks higher by incorporating pheromone reinforcement and a simulated learning route, whereas the 20th employs cost-based prioritization, adaptive neighborhood scaling, and route completion encouragement. Comparing (2nd best) vs (second worst), both share almost the same code, with no differences observed. Comparing (1st) vs (2nd), the key distinction lies in the inclusion of pheromone reinforcement and simulated route learning in the 1st, which are absent in the 2nd. (3rd) vs (4th) shows a shift towards simpler calculations and a more direct approach to depot connection preference. Comparing (second worst) vs (worst), both share almost the same code, with no differences observed. Overall: The better heuristics progressively integrate more sophisticated mechanisms like pheromone updates, adaptive parameter adjustments based on problem characteristics, and refined penalty systems, whereas worse heuristics rely on static weights and simpler combinations of basic factors like distance and demand.\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, here's a redefined approach to self-reflection for designing better heuristics, aiming to avoid pitfalls and focusing on actionable insights.\n\n*   **Keywords:** Adaptive parameters, incremental refinement, problem-specific constraints, normalization, k-NN intensification, sparsification.\n\n*   **Advice:** Begin with simple components, progressively integrate adaptive mechanisms (k-NN, sparsification), and normalize intermediate results. Focus on problem constraints to drive adaptation.\n\n*   **Avoid:** Overly complex formulas, fixed parameters, neglecting problem-specific constraints, relying solely on intuition, and premature optimization.\n\n*   **Explanation:** Start simple, *adapt* to the *problem*, and control scaling through normalization. Let problem constraints *guide* heuristic refinement, not complicate it.\n\n\nYour task is to write an improved function `heuristics_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}