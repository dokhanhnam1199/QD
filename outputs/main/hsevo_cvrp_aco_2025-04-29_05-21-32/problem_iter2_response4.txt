```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """CVRP heuristics: Combines distance, demand, and angular factors."""

    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # 1. Distance heuristic
    distance_heuristic = 1 / (distance_matrix + 1e-6)

    # 2. Demand heuristic
    demand_penalty = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                demand_prob_i = demands[i] / capacity if i != 0 else 0
                demand_prob_j = demands[j] / capacity if j != 0 else 0
                demand_penalty[i, j] = min(demand_prob_i + demand_prob_j, 1)
    demand_heuristic = 1 - demand_penalty

    # 3. Angular heuristic
    depot_x, depot_y = coordinates[0]
    angular_heuristic = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                x_i, y_i = coordinates[i]
                x_j, y_j = coordinates[j]
                vector_i = np.array([x_i - depot_x, y_i - depot_y])
                vector_j = np.array([x_j - depot_x, y_j - depot_y])
                dot_product = np.dot(vector_i, vector_j)
                magnitude_i = np.linalg.norm(vector_i)
                magnitude_j = np.linalg.norm(vector_j)
                if magnitude_i == 0 or magnitude_j == 0:
                    angle_radians = 0.0
                else:
                    angle_radians = np.arccos(dot_product / (magnitude_i * magnitude_j))
                angular_heuristic[i, j] = 1 - np.abs(angle_radians) / np.pi

    # Combine heuristics with weights
    alpha = 0.5  # Distance
    beta = 0.3  # Demand
    gamma = 0.2  # Angle
    heuristics = alpha * distance_heuristic + beta * demand_heuristic + gamma * angular_heuristic

    # No self-loops
    for i in range(n):
        heuristics[i, i] = 0

    return heuristics
```
