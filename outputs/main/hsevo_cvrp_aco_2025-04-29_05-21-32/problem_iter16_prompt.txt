{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Adaptive heuristics using distance, demand, depot proximity, and k-NN.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # 1. Cost-Based Prioritization (Distance and Demand)\n    cost_matrix = distance_matrix + (demands[:, None] + demands[None, :]) / capacity * np.mean(distance_matrix)\n    heuristics = 1 / (cost_matrix + 1e-9)\n\n    # 2. Depot Influence\n    depot_distances = distance_matrix[:, depot_index]\n    for i in range(1, n):\n        heuristics[depot_index, i] += 0.2 * (1 - depot_distances[i] / np.max(depot_distances))\n        heuristics[i, depot_index] = 0  # Block return trip except from depot\n\n    # 3. k-NN with adaptive k\n    knn_base = 4\n    knn_weight = 0.15\n    node_densities = np.zeros(n)\n    for i in range(1, n):\n        distances_from_i = distance_matrix[i, 1:]\n        nearest_neighbors_dist = np.sort(distances_from_i)[:min(knn_base, n - 1)]\n        node_densities[i] = np.mean(nearest_neighbors_dist)\n    mean_node_density = np.mean(node_densities[1:])\n\n    for i in range(1, n):\n        adaptive_knn = int(knn_base * (mean_node_density / (node_densities[i] + 1e-9)))\n        adaptive_knn = max(1, min(adaptive_knn, n - 1))\n        distances_from_i = distance_matrix[i, 1:]\n        nearest_neighbors = np.argsort(distances_from_i)[:adaptive_knn] + 1\n        for j in nearest_neighbors:\n            heuristics[i, j] += knn_weight\n            heuristics[j, i] += knn_weight\n    #4 sparsification\n    sparsification_percentile = 35\n    threshold = np.percentile(heuristics[heuristics > 0], sparsification_percentile)\n    heuristics[heuristics < threshold] = 0\n\n    # 5. Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}