```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Improves upon heuristics_v1 by incorporating demand and capacity constraints.
    Prioritizes edges connecting nodes with lower demands and penalizes edges that
    would lead to early capacity exhaustion. Also considers geometric clustering.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Inverse distance component (as in v1)
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small constant to prevent division by zero

    # Demand-based component
    demand_factor = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            demand_factor[i, j] = (capacity - demands[i] - demands[j]) / capacity # Favors edges if it doesn't exhaust capacity quickly

    demand_factor = np.clip(demand_factor, 0.1, 1) # Clips values

    #Geometric Proximity for depot. Nodes closer to depot should be linked together.
    depot_proximity = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
           depot_proximity[i,j] = 1/(distance_matrix[0,i]+distance_matrix[0,j]+1e-9)

    # Combine components - giving different weightings.  Fine tune weights accordingly.
    heuristic_matrix = 0.6 * inverse_distance + 0.3 * demand_factor + 0.1*depot_proximity

    #Penalize the edges starting from the depot since each round trip should start from depot.
    for i in range(1, n):
        heuristic_matrix[0, i] *=1.1

    # Remove the self loop with large negative penalty.
    for i in range(n):
        heuristic_matrix[i, i] = -1000

    return heuristic_matrix
```
