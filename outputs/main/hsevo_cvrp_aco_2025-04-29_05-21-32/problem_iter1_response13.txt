```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) using a combination of distance,
    demand, and a bit of stochasticity. This heuristic prioritizes shorter distances, penalizes
    edges connecting nodes with high combined demands (that may violate capacity), and introduces
    a small random element for exploration.

    Args:
        distance_matrix (np.ndarray): n x n distance matrix between nodes.
        coordinates (np.ndarray): n x 2 Euclidean coordinates of nodes.
        demands (np.ndarray): Vector of customer demands.
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: n x n matrix of heuristic values for each edge. Higher values indicate
                    more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Scale the distance matrix to be between 0 and 1 for better handling of inverse.  Add small value to avoid dividing by zero.
    scaled_distances = distance_matrix / np.max(distance_matrix)
    scaled_distances += 1e-9


    # Demand-based penalty.  Connections between high demand customers are penalized.
    demand_penalty = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            demand_penalty[i, j] = (demands[i] + demands[j]) / (2 * capacity)  # Normalize

    # Random component for exploration.
    random_component = np.random.rand(n, n) * 0.1  # Adjust scale as needed

    for i in range(n):
        for j in range(n):
            if i != j:
                # Base heuristic: Inverse distance, so shorter distances are preferred
                heuristic_matrix[i, j] = 1 / scaled_distances[i, j]  # inverse distance is more helpful

                # Penalize edges that are more likely to cause a vehicle to exceed capacity.
                heuristic_matrix[i, j] *= (1 - demand_penalty[i, j])
                heuristic_matrix[i,j] = max(0.0, heuristic_matrix[i,j]) #Do not have negative heuristic values

                # Add a small random component for exploration
                heuristic_matrix[i, j] += random_component[i, j] # Adding some randomness

            else:
                heuristic_matrix[i, j] = 0  # No self-loops

    return heuristic_matrix
```
