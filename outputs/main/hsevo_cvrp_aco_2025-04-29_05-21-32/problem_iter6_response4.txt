```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version prioritizes routes based on a combination of distance, demand, and depot proximity,
    with adaptive sparsification and route completion incentives.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # 1. Inverse Distance with a base value
    base_heuristic = 1 / (distance_matrix + 1e-9)
    heuristics += base_heuristic

    # 2. Demand and Capacity Consideration:
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue

            # Depot connection boost
            if i == depot_index and j != depot_index:
                if demands[j] <= capacity:  # Only allow depot starts if demand is within capacity.
                    heuristics[i, j] += 0.7 # stronger boost for edges *from* the depot.
                else:
                    heuristics[i, j] = 0  # Infeasible edges from depot are pruned

            # Prune edges that would immediately violate capacity
            elif i != depot_index and j != depot_index:
                 if demands[i] + demands[j] > capacity and i != depot_index and j == depot_index:
                    heuristics[i,j] = 0 # remove edges to depot if combined demand is violated from the current node

    # 3. Depot Proximity Incentive (with adaptive scaling):
    depot_distances = distance_matrix[:, depot_index]
    mean_depot_distance = np.mean(depot_distances) + 1e-9

    for i in range(n):
        for j in range(n):
            if i != depot_index and j == depot_index:
              heuristics[i,j] = 0
            if i != depot_index and j != depot_index:
                depot_proximity_penalty = 0.05 * (depot_distances[i] + depot_distances[j]) / mean_depot_distance
                heuristics[i, j] -= depot_proximity_penalty
                 # Sparsification based on combined distance and demand relative to averages
                combined_metric = distance_matrix[i, j] * demands[j]
                threshold = np.mean(distance_matrix) * np.mean(demands) * 1.5  # Adjusted threshold
                if combined_metric > threshold:
                   heuristics[i, j] = 0

    # 4. Route Completion Incentive: Encourages closing routes back to the depot.
    for i in range(n):
        if i != depot_index:
            heuristics[i, depot_index] += 0.3 # Incentivize returns to depot, making CVRP a little more like TSP

    # 5. Normalize
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    # Post-processing: Ensure depot has outgoing edges and no incoming edges (except from the route end).
    for i in range(n):
        if i != depot_index:
            heuristics[depot_index, i] = max(0, heuristics[depot_index, i])
            heuristics[i, depot_index] = 0  # Except handled in route completion incentives
    return heuristics
```
