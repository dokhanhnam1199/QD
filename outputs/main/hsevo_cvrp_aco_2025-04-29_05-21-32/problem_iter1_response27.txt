```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP using a combination of distance, demand, and clustering.

    This heuristic function aims to provide a more informed estimate of edge desirability
    by considering not only distance but also customer demand and spatial clustering,
    encouraging the formation of feasible routes.

    Args:
        distance_matrix: (n by n) matrix of distances between nodes.
        coordinates: (n by 2) array of node coordinates.
        demands: (n) array of customer demands.
        capacity: Vehicle capacity.

    Returns:
        (n by n) array of edge desirability scores. Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Heuristic 1: Inverse Distance
    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Add a small value to avoid division by zero
    distance_heuristic[np.isinf(distance_heuristic)] = 0  #Handle infinities.

    # Heuristic 2: Demand Consideration
    demand_normalized = demands / np.max(demands)  # Normalize demands to [0, 1]

    # Heuristic 3: Savings heuristic inspired cluster affinity (simplified)
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]  # Ensure symmetry

    # Normalize savings matrix
    savings_normalized = savings_matrix / np.max(savings_matrix + 1e-6)


    # Combine heuristics
    heuristic_matrix = (0.6 * distance_heuristic +
                         0.2 * savings_normalized +
                         0.2 * (1 - demand_normalized)) # Give higher weights to distances, savings.

    # Discourage connections between nodes with high individual demands relative to capacity.
    for i in range(n):
      for j in range(n):
        if demands[i] + demands[j] > capacity:
          heuristic_matrix[i,j] *= 0.1  # Heavily penalize exceeding capacity

    # Encourage return to depot
    for i in range(1, n):
      heuristic_matrix[0, i] *= 1.2
      heuristic_matrix[i, 0] *= 1.2

    return heuristic_matrix
```
