{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\n### Better code\ndef heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity, angle considerations, k-NN intensification,\n    adaptive sparsification, and pheromone-inspired reinforcement learning.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Initialize Pheromone Matrix: start with small values\n    pheromone = np.ones_like(distance_matrix) * 0.01\n\n    # Heuristic 1: Basic inverse distance (with scaling)\n    distance_scaling = np.mean(distance_matrix)\n    heuristics = distance_scaling / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity\n    demand_penalty_factor = 0.6\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.6  # Increased depot boost\n            elif i != depot_index and j != depot_index:\n                demand_ratio = (demands[i] + demands[j]) / capacity\n                demand_penalty = demand_penalty_factor * demand_ratio\n                heuristics[i, j] -= demand_penalty\n\n    # Heuristic 3: Depot proximity and adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    depot_proximity_weight = 0.2\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= depot_proximity_weight * detour_penalty\n\n                if distance_matrix[i, j] > 1.3 * distance_scaling and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n    # Heuristic 4: Angle from Depot\n    angle_weight = 0.3\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                    heuristics[i, j] += angle_weight * (1 - angle / np.pi)\n\n    # Heuristic 5: k-NN intensification\n    knn = 6\n    knn_weight = 0.2\n\n    for i in range(1, n):\n        distances_from_i = distance_matrix[i, 1:]\n        nearest_neighbors = np.argsort(distances_from_i)[:knn] + 1\n        for j in nearest_neighbors:\n            heuristics[i, j] += knn_weight\n            heuristics[j, i] += knn_weight\n\n    # Heuristic 6: Pheromone reinforcement\n    pheromone_weight = 0.1\n    heuristics += pheromone_weight * pheromone  # Incorporate pheromone\n\n    # Heuristic 7: Adaptive Sparsification\n    threshold_factor = 0.03\n    threshold = threshold_factor * np.mean(np.abs(heuristics))\n    heuristics[np.abs(heuristics) < threshold] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    # Update Pheromone (Simulated Learning - Reward/Punish Edges)\n    def update_pheromone(route, reward=0.1, punishment=0.01): # Pheromone Update Function\n        for i in range(len(route) - 1):\n            u, v = route[i], route[i+1]\n            pheromone[u, v] += reward * heuristics[u, v]  # Reward\n            pheromone[v, u] += reward * heuristics[v, u]  # Ensure symmetry\n\n        # Optional: Punish less promising edges (can be risky)\n        # for i in range(n):\n        #     for j in range(n):\n        #         if (i, j) not in [(route[k], route[k+1]) for k in range(len(route)-1)]:\n        #             pheromone[i,j] -= punishment * heuristics[i,j]\n        pheromone[pheromone < 0.001] = 0.001 # Lower Bounded\n\n    # Simulate a \"good\" route selection. A more sophisticated approach could incorporate a local search routine\n    # and use the resulting route to update the pheromones\n\n    simulated_route = [0]  # Start at depot\n    current_node = 0\n    unvisited_nodes = set(range(1, n)) # All nodes except depot\n    current_load = 0\n    while unvisited_nodes:\n        # Find the nearest unvisited node\n        next_node = None\n        min_dist = float('inf')\n\n        possible_next_nodes = []\n        for node in unvisited_nodes:\n          if demands[node] + current_load <= capacity:\n            possible_next_nodes.append(node)\n\n        if not possible_next_nodes:\n          #Return to depot and continue\n          simulated_route.append(0)\n          current_node = 0\n          current_load = 0\n          continue #From the beginning with depot.\n\n        for node in possible_next_nodes:\n            dist = distance_matrix[current_node, node]\n            if dist < min_dist:\n                min_dist = dist\n                next_node = node\n\n        if next_node is not None:\n            simulated_route.append(next_node)\n            unvisited_nodes.remove(next_node)\n            current_load += demands[next_node]\n            current_node = next_node\n        else:\n            break # no next node\n\n    simulated_route.append(0) # Return to depot\n\n    update_pheromone(simulated_route)\n\n    return heuristics\n\n### Worse code\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"Improved CVRP heuristic: combines inverse distance, demand, depot proximity, angle, and adaptive sparsification with k-NN.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance with a small constant added to avoid division by zero\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration and Depot Connection preference\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4  # Increased depot connection importance\n\n            elif i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Removing edges to depot\n\n            elif i != depot_index and j != depot_index:\n                  heuristics[i,j] += 1/(distance_matrix[i,j] * demands[j] + 1e-9)\n\n    # Heuristic 3: Depot proximity with adaptive pruning and k-NN intensification\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    k = 5\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty\n\n                # Adaptive pruning\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                # k-NN intensification\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]\n                if j in neighbors:\n                    heuristics[i, j] += 0.2\n\n    # Heuristic 4: Angle from Depot - Prefer edges where nodes are in similar direction from depot.\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)\n\n    # Heuristic 5: Sparsification\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i,depot_index] + distance_matrix[depot_index, j] < 1.5* np.mean(distance_matrix):\n                heuristics[i, j] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st ranks higher by incorporating pheromone reinforcement and a simulated learning route, whereas the 20th employs cost-based prioritization, adaptive neighborhood scaling, and route completion encouragement. Comparing (2nd best) vs (second worst), both share almost the same code, with no differences observed. Comparing (1st) vs (2nd), the key distinction lies in the inclusion of pheromone reinforcement and simulated route learning in the 1st, which are absent in the 2nd. (3rd) vs (4th) shows a shift towards simpler calculations and a more direct approach to depot connection preference. Comparing (second worst) vs (worst), both share almost the same code, with no differences observed. Overall: The better heuristics progressively integrate more sophisticated mechanisms like pheromone updates, adaptive parameter adjustments based on problem characteristics, and refined penalty systems, whereas worse heuristics rely on static weights and simpler combinations of basic factors like distance and demand.\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, here's a redefined approach to self-reflection for designing better heuristics, aiming to avoid pitfalls and focusing on actionable insights.\n\n*   **Keywords:** Adaptive parameters, incremental refinement, problem-specific constraints, normalization, k-NN intensification, sparsification.\n\n*   **Advice:** Begin with simple components, progressively integrate adaptive mechanisms (k-NN, sparsification), and normalize intermediate results. Focus on problem constraints to drive adaptation.\n\n*   **Avoid:** Overly complex formulas, fixed parameters, neglecting problem-specific constraints, relying solely on intuition, and premature optimization.\n\n*   **Explanation:** Start simple, *adapt* to the *problem*, and control scaling through normalization. Let problem constraints *guide* heuristic refinement, not complicate it.\n\n\nYour task is to write an improved function `heuristics_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}