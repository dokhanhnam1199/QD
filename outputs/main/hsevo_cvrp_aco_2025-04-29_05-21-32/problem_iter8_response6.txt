```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """CVRP heuristic: Combines inverse distance, demand penalty, k-NN, and adaptive sparsification."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Inverse distance
    heuristic_matrix = 1 / (distance_matrix + 1e-9)

    # Demand penalty
    demand_penalty = np.zeros(n)
    for i in range(1, n):
      demand_penalty[i] = demands[i] / capacity

    for i in range(n):
      for j in range(n):
        if i == j:
          heuristic_matrix[i, j] = 0
        else:
            heuristic_matrix[i,j] /= (1 + 0.5*demand_penalty[i] + 0.5*demand_penalty[j]) # Penalize high demand


    # K-Nearest Neighbor
    k_nearest_neighbors = 4
    for i in range(n):
        neighbors_idx = np.argsort(distance_matrix[i,:])[1:k_nearest_neighbors+1]
        for nn in neighbors_idx:
            heuristic_matrix[i,nn] += 0.2

    # Sparsify (adaptive threshold)
    heuristic_mean = np.mean(heuristic_matrix[heuristic_matrix > 0])
    heuristic_matrix[heuristic_matrix < 0.5 * heuristic_mean] = 0

    # Depot proximity boost and capacity check
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            if i == 0:
                remaining_capacity = capacity - demands[j]
                if remaining_capacity <= 0:
                    heuristic_matrix[i, j] = 0 # Hard constraint

                heuristic_matrix[i,j] += 0.4

    # Normalize
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        heuristic_matrix = heuristic_matrix / max_heuristic

    return heuristic_matrix
```
