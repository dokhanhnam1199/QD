import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  demand_penalty_factor: float = 0.46324906238727115, depot_proximity_weight: float = 0.1757769773833881,
                  angle_weight: float = 0.060312203491050174, knn_weight: float = 0.057251314168443306, route_length_weight: float = 0.17715455732412308,
                  threshold_factor_abs: float = 0.04702596422328957, threshold_factor_rel: float = 0.06995898800431329,
                  knn_min_neighbors: int = 3.6699398235839373, knn_max_neighbors: int = 14.96080325036865,
                  depot_boost: float = 0.5039820972065999, adaptive_pruning_factor: float = 1.2942853063151984,
                  knn_initial_neighbors: int = 9.708978228801694) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates demand, distance, depot proximity, angle considerations, k-NN intensification,
    and adaptive sparsification with more refined components and weight tuning. It also adds a route length
    estimation penalty and refines the k-NN selection and sparsification. Furthermore, it adaptively adjusts
    the k-NN neighborhood size based on local demand density and uses a more robust sparsification strategy.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.
        demand_penalty_factor (float): Weight for demand penalty.
        depot_proximity_weight (float): Weight for depot proximity.
        angle_weight (float): Weight for angle from depot.
        knn_weight (float): Weight for k-NN intensification.
        route_length_weight (float): Weight for route length estimation.
        threshold_factor_abs (float): Absolute threshold factor for sparsification.
        threshold_factor_rel (float): Relative threshold factor for sparsification.
        knn_min_neighbors (int): Minimum number of neighbors for k-NN.
        knn_max_neighbors (int): Maximum number of neighbors for k-NN.
        depot_boost (float): Boost for edges from the depot.
        adaptive_pruning_factor (float): Factor for adaptive pruning based on distance.
        knn_initial_neighbors (int): Initial neighbors to consider for local demand density

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Heuristic 1: Basic inverse distance (with a slight modification)
    distance_scaling = np.mean(distance_matrix)
    heuristics = distance_scaling / (distance_matrix + 1e-9)  # Use scaling directly in the division

    # Heuristic 2: Demand and Capacity consideration
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue

            if i == depot_index and j != depot_index:
                if demands[j] > capacity:  # Directly prune edges that violate capacity constraint.
                    heuristics[i, j] = 0
                else:
                    heuristics[i, j] += depot_boost  # Depot boost (increased)
            elif i != depot_index and j != depot_index:
                demand_ratio = (demands[i] + demands[j]) / capacity
                demand_penalty = demand_penalty_factor * demand_ratio**1.5 # Higher power to amplify penalty for large demand
                heuristics[i, j] -= demand_penalty

    # Heuristic 3: Depot proximity with adaptive pruning
    depot_distances = distance_matrix[:, depot_index]
    mean_depot_distance = np.mean(depot_distances)

    for i in range(n):
        for j in range(n):
            if i != depot_index and j == depot_index:
                heuristics[i, j] = 0  # Remove edges to depot (except from depot)
            elif i != depot_index and j != depot_index:
                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)
                heuristics[i, j] -= depot_proximity_weight * detour_penalty

                # Adaptive pruning based on demand and distance - more aggressive
                if distance_matrix[i, j] > adaptive_pruning_factor * distance_scaling and demands[i] + demands[j] > capacity / 2:
                    heuristics[i, j] = 0

    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                vector_i = coordinates[i] - coordinates[depot_index]
                vector_j = coordinates[j] - coordinates[depot_index]

                norm_i = np.linalg.norm(vector_i)
                norm_j = np.linalg.norm(vector_j)

                if norm_i > 0 and norm_j > 0:
                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)
                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))

                    heuristics[i, j] += angle_weight * (1 - angle / np.pi)**2  # Favor smaller angles even more

    # Heuristic 5: k-NN intensification (Focus on local search) - Refined k-NN selection
    # Adaptive k-NN neighborhood size based on local demand density.
    for i in range(1, n):
        # Estimate local demand density (average demand of nearby nodes).
        distances_from_i = distance_matrix[i, 1:]
        nearest_neighbors = np.argsort(distances_from_i)[:min(knn_initial_neighbors, n - 1)] + 1
        local_demand_density = np.mean(demands[nearest_neighbors]) if len(nearest_neighbors) > 0 else 0

        # Adjust k-NN size based on density; higher density -> smaller k.
        knn = max(knn_min_neighbors, min(knn_max_neighbors, int(knn_max_neighbors * (1 - local_demand_density / capacity))))  # Ensure knn > 0
        knn = min(knn, n-1)

        # Find k-nearest neighbors based on distance, excluding depot.
        distances_from_i = distance_matrix[i, 1:]
        nearest_neighbors = np.argsort(distances_from_i)[:knn] + 1  # Correctly offset indices

        # Demand aware k-NN selection.
        demand_neighbors = []
        for neighbor in nearest_neighbors:
            if demands[i] + demands[neighbor] <= capacity:
                demand_neighbors.append(neighbor)

        # No neighbors satisfying demand constraint.
        if len(demand_neighbors) == 0:
            for j in nearest_neighbors:
                heuristics[i, j] += knn_weight/2.0
                heuristics[j, i] += knn_weight/2.0
            continue # Move to the next i

        for j in demand_neighbors:
            heuristics[i, j] += knn_weight
            heuristics[j, i] += knn_weight

    # Heuristic 6: Route length estimation and penalty
    for i in range(1,n):
        for j in range(1,n):
            if i != j:
                #Estimate the route length if edge (i,j) included. Simplified estimation.
                estimated_route_length = distance_matrix[depot_index, i] + distance_matrix[i,j] + distance_matrix[j, depot_index]
                heuristics[i,j] -= route_length_weight * estimated_route_length / (3 * distance_scaling + 1e-9)

    # Heuristic 7: Sparsification: zero out small heuristic values (Adaptive Threshold) - Refined Sparsification
    # Robust adaptive sparsification using a combination of absolute and relative thresholds.

    threshold_abs = threshold_factor_abs * np.std(heuristics)  # Adaptive threshold uses standard deviation
    threshold_rel = threshold_factor_rel * np.max(heuristics)   # Adaptive threshold relative to maximum value

    # Apply sparsification using the maximum of the two thresholds.
    threshold = max(threshold_abs, threshold_rel)

    heuristics[heuristics < threshold] = 0  # Sparsify only based on values smaller than threshold

    # Normalize (After Sparsification)
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
