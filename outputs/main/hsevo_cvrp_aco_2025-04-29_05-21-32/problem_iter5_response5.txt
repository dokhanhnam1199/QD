```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """CVRP heuristics: Combines distance, savings, demand, k-NN, and sparsification."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Inverse distance
    heuristic_matrix = 1 / (distance_matrix + 1e-9)

    # Savings
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    heuristic_matrix += savings_matrix / np.max(savings_matrix + 1e-9)

    # Demand penalty
    demand_penalty = np.zeros(n)
    for i in range(1, n):
      demand_penalty[i] = demands[i] / capacity

    for i in range(n):
      for j in range(n):
        if i == j:
          heuristic_matrix[i, j] = 0
        else:
            heuristic_matrix[i,j] /= (1 + 0.5*demand_penalty[i] + 0.5*demand_penalty[j]) # Penalize high demand

    # K-Nearest Neighbor
    k_nearest_neighbors = 4
    for i in range(n):
        neighbors_idx = np.argsort(distance_matrix[i,:])[1:k_nearest_neighbors+1]
        for nn in neighbors_idx:
            heuristic_matrix[i,nn] += 0.2

    # Sparsify
    average_distance = np.mean(distance_matrix)
    for i in range(n):
        for j in range(n):
            if distance_matrix[i,j] > 2.0 * average_distance:
                heuristic_matrix[i,j] = 0.0

    # Normalize
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        heuristic_matrix = heuristic_matrix / max_heuristic

    return heuristic_matrix
```
