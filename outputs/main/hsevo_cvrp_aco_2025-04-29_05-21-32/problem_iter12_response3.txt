```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version refines heuristics_v1 by incorporating more adaptive and problem-aware components,
    including cost-based prioritization, adaptive neighborhood scaling, and route completion encouragement.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # 1. Cost-Based Prioritization (Combined Distance and Demand): More informed initial values
    cost_matrix = distance_matrix.copy()
    for i in range(n):
        for j in range(n):
            if i != j:
                cost_matrix[i, j] += (demands[i] + demands[j]) / capacity * np.mean(distance_matrix)  # Scale demand cost by average distance

    heuristics = 1 / (cost_matrix + 1e-9)
    heuristics *= np.mean(distance_matrix) #scaling

    # 2. Depot Influence: Adaptive Scaling based on distance to depot and remaining capacity.
    depot_distances = distance_matrix[:, depot_index]
    remaining_capacity_weight = 0.3  # Tunable
    depot_proximity_weight = 0.2
    for i in range(1, n):
        heuristics[depot_index, i] += depot_proximity_weight * (1 - depot_distances[i] / np.max(depot_distances))
        heuristics[i, depot_index] = 0 #block return trip except from depot.

    # 3. Route Completion Encouragement:  Prioritize links that help complete partial routes (Capacity-aware).
    route_completion_weight = 0.25  # Tunable.

    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                 # Encourage connections that reduce remaining capacity on a potential route
                route_efficiency =  min(demands[i],demands[j])/(capacity + 1e-9) #Scale
                heuristics[i, j] += route_completion_weight * route_efficiency


    # 4. Adaptive Neighborhood Scaling (k-NN with dynamic k based on node density)
    knn_base = 4
    knn_weight = 0.15

    # Estimate node density based on average distance to neighbors
    node_densities = np.zeros(n)
    for i in range(1, n):
        distances_from_i = distance_matrix[i, 1:]
        nearest_neighbors_dist = np.sort(distances_from_i)[:min(knn_base,n-1)]
        node_densities[i] = np.mean(nearest_neighbors_dist)

    mean_node_density = np.mean(node_densities[1:])

    for i in range(1, n):
        #Adaptive K based on node density compared to average
        adaptive_knn = int(knn_base * (mean_node_density / (node_densities[i] + 1e-9)))
        adaptive_knn = max(1, min(adaptive_knn, n - 1)) #Clamp between 1 and n-1
        distances_from_i = distance_matrix[i, 1:]  # Exclude depot
        nearest_neighbors = np.argsort(distances_from_i)[:adaptive_knn] + 1  # Get indices of nearest neighbors
        for j in nearest_neighbors:
            heuristics[i, j] += knn_weight
            heuristics[j, i] += knn_weight


    # 5. Sparsification: More aggressive sparsification based on percentile.
    sparsification_percentile = 35  # Sparsify below this percentile. Tunable.
    threshold = np.percentile(heuristics[heuristics > 0], sparsification_percentile)  #Consider only positive values
    heuristics[heuristics < threshold] = 0



    # 6. Normalize (After Sparsification)
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```
