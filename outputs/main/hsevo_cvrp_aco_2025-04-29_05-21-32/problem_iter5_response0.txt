```python
import numpy as np
from scipy.spatial.distance import cdist

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Combines distance, savings, demand, and coordinate proximity."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Distance and Savings (Clarke-Wright)
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Normalize savings and combine with inverse distance
    heuristic_matrix = (1 / (distance_matrix + np.eye(n))) + (savings_matrix / np.max(savings_matrix))

    # Demand penalty:  Penalize edges connecting nodes with high demand.
    demand_penalty = np.zeros(n)
    for i in range(1, n):
        demand_penalty[i] = demands[i] / capacity

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No loops
            else:
                heuristic_matrix[i, j] /= (1 + demand_penalty[i] + demand_penalty[j]) # Slightly penalize high demand nodes.

    # Coordinate proximity: Favor edges connecting nearby nodes in space.
    coordinate_distances = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            coordinate_distances[i, j] = np.linalg.norm(coordinates[i] - coordinates[j])

    heuristic_matrix += (1 / (coordinate_distances + np.eye(n)))  # Prefer shorter coordinate distance
    heuristic_matrix[np.isinf(heuristic_matrix)] = 0  # Handle infinities
    heuristic_matrix[np.isnan(heuristic_matrix)] = 0  # Handle NaN values
    
    # Depot proximity and demand awareness
    depot_distances = cdist(coordinates[[0]], coordinates).flatten()
    for i in range(1,n):
        heuristic_matrix[0,i] += (1/(depot_distances[i]+1)) * (1 - demands[i]/capacity) # Encourage connection to depot, adjusted by demand

    # Sparsification: prune edges based on heuristic values
    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2 # Dynamic threshold
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
