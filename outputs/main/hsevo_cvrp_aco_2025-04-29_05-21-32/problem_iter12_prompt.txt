{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\nCurrent heuristics:\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity, angle considerations, k-NN intensification,\n    and adaptive sparsification with more refined components and weight tuning.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance (with a slight modification)\n    heuristics = 1 / (distance_matrix + 1e-9)\n    distance_scaling = np.mean(distance_matrix)  # Use mean distance for scaling\n    heuristics *= distance_scaling  # Scale based on average distance\n\n    # Heuristic 2: Demand and Capacity consideration\n    demand_penalty_factor = 0.5  # Tunable weight\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:  # Directly prune edges that violate capacity constraint.\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.5  # Depot boost (increased)\n            elif i != depot_index and j != depot_index:\n                demand_ratio = (demands[i] + demands[j]) / capacity\n                demand_penalty = demand_penalty_factor * demand_ratio\n                heuristics[i, j] -= demand_penalty # More aggressive demand penalty\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    depot_proximity_weight = 0.1  # Tunable weight\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route. Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= depot_proximity_weight * detour_penalty  # Reduced weight\n\n                # Adaptive pruning based on demand and distance. Less aggressive than v1.\n                if distance_matrix[i, j] > 1.2 * distance_scaling and demands[i] + demands[j] > capacity / 3:  # Adjusted threshold and demand check\n                    heuristics[i, j] = 0\n\n    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)\n    angle_weight = 0.2  # Tunable weight\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    # Convert cosine to angle in radians\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Ensure within valid range\n\n                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value\n                    heuristics[i, j] += angle_weight * (1 - angle / np.pi)  # Normalized angle reward, reduced weight\n\n    # Heuristic 5: k-NN intensification (Focus on local search)\n    knn = 5  # Number of nearest neighbors to consider\n    knn_weight = 0.15 # Tunable weight\n\n    for i in range(1, n):\n        # Find k-nearest neighbors based on distance\n        distances_from_i = distance_matrix[i, 1:]  # Exclude depot\n        nearest_neighbors = np.argsort(distances_from_i)[:knn] + 1  # Get indices of nearest neighbors\n        for j in nearest_neighbors:\n            heuristics[i, j] += knn_weight\n            heuristics[j, i] += knn_weight\n\n    # Heuristic 6: Sparsification: zero out small heuristic values (Adaptive Threshold)\n    threshold_factor = 0.02 # Tunable parameter for adaptive threshold\n    threshold = threshold_factor * np.mean(np.abs(heuristics))  # Adaptive threshold based on absolute mean.\n    heuristics[np.abs(heuristics) < threshold] = 0\n\n    # Normalize (After Sparsification)\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\nNow, think outside the box write a mutated function `heuristics_v2` better than current version.\nYou can use some hints below:\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, let's refine self-reflection for designing better heuristics. We need to move beyond just listing techniques and focus on *why* and *how* to apply them effectively.\n\n*   **Keywords:** Adaptive learning, problem-specific knowledge, iterative refinement, evaluation metrics, trade-off analysis.\n*   **Advice:** Frame heuristic design as an iterative learning process driven by problem-specific insights and performance evaluation. Focus on understanding the underlying problem structure.\n*   **Avoid:** Blindly adding features or tuning weights without a clear rationale. Avoid complexity without demonstrated performance improvement.\n*   **Explanation:** Instead of simply stating techniques, emphasize adapting heuristic components based on *observed* performance and a deep understanding of the problem's characteristics.\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}