```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """CVRP heuristic: Combines distance, demand, depot proximity, angle, adaptive sparsification."""
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Inverse distance
    distance_heuristic = 1 / (distance_matrix + 1e-9)
    heuristics += distance_heuristic * 0.5

    # Demand and Depot Connection
    demand_distance_heuristic = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            if i == depot_index:
                remaining_capacity = capacity - demands[j]
                if remaining_capacity >= 0:
                    demand_distance_heuristic[i, j] = 0.7
                else:
                    demand_distance_heuristic[i, j] = 0
            elif i != depot_index and j == depot_index:
                  demand_distance_heuristic[i,j] = 0
            else:
                demand_distance_heuristic[i,j] = 1/(distance_matrix[i,j] * demands[j] + 1e-9)

    heuristics += demand_distance_heuristic * 0.4

    # Angle from Depot
    angle_heuristic = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i == depot_index or j == depot_index or i ==j:
                angle_heuristic[i,j] = 0
                continue

            vector_i = coordinates[i] - coordinates[depot_index]
            vector_j = coordinates[j] - coordinates[depot_index]

            norm_i = np.linalg.norm(vector_i)
            norm_j = np.linalg.norm(vector_j)

            if norm_i == 0 or norm_j == 0:
                angle = 0
            else:
                dot_product = np.dot(vector_i, vector_j)
                cos_angle = dot_product / (norm_i * norm_j)
                angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))

            angle_heuristic[i,j] = 1- (angle / np.pi)

    heuristics += angle_heuristic * 0.1

    # Adaptive Sparsification
    threshold = np.mean(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j and distance_matrix[i,j] > threshold * 2 :
                heuristics[i, j] = 0

    # Normalization
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```
