{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity, angle considerations, k-NN intensification,\n    adaptive sparsification, and pheromone-inspired reinforcement learning.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Initialize Pheromone Matrix: start with small values\n    pheromone = np.ones_like(distance_matrix) * 0.01\n\n    # Heuristic 1: Basic inverse distance (with scaling)\n    distance_scaling = np.mean(distance_matrix)\n    heuristics = distance_scaling / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity\n    demand_penalty_factor = 0.6\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.6  # Increased depot boost\n            elif i != depot_index and j != depot_index:\n                demand_ratio = (demands[i] + demands[j]) / capacity\n                demand_penalty = demand_penalty_factor * demand_ratio\n                heuristics[i, j] -= demand_penalty\n\n    # Heuristic 3: Depot proximity and adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    depot_proximity_weight = 0.2\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= depot_proximity_weight * detour_penalty\n\n                if distance_matrix[i, j] > 1.3 * distance_scaling and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n    # Heuristic 4: Angle from Depot\n    angle_weight = 0.3\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                    heuristics[i, j] += angle_weight * (1 - angle / np.pi)\n\n    # Heuristic 5: k-NN intensification\n    knn = 6\n    knn_weight = 0.2\n\n    for i in range(1, n):\n        distances_from_i = distance_matrix[i, 1:]\n        nearest_neighbors = np.argsort(distances_from_i)[:knn] + 1\n        for j in nearest_neighbors:\n            heuristics[i, j] += knn_weight\n            heuristics[j, i] += knn_weight\n\n    # Heuristic 6: Pheromone reinforcement\n    pheromone_weight = 0.1\n    heuristics += pheromone_weight * pheromone  # Incorporate pheromone\n\n    # Heuristic 7: Adaptive Sparsification\n    threshold_factor = 0.03\n    threshold = threshold_factor * np.mean(np.abs(heuristics))\n    heuristics[np.abs(heuristics) < threshold] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    # Update Pheromone (Simulated Learning - Reward/Punish Edges)\n    def update_pheromone(route, reward=0.1, punishment=0.01): # Pheromone Update Function\n        for i in range(len(route) - 1):\n            u, v = route[i], route[i+1]\n            pheromone[u, v] += reward * heuristics[u, v]  # Reward\n            pheromone[v, u] += reward * heuristics[v, u]  # Ensure symmetry\n\n        # Optional: Punish less promising edges (can be risky)\n        # for i in range(n):\n        #     for j in range(n):\n        #         if (i, j) not in [(route[k], route[k+1]) for k in range(len(route)-1)]:\n        #             pheromone[i,j] -= punishment * heuristics[i,j]\n        pheromone[pheromone < 0.001] = 0.001 # Lower Bounded\n\n    # Simulate a \"good\" route selection. A more sophisticated approach could incorporate a local search routine\n    # and use the resulting route to update the pheromones\n\n    simulated_route = [0]  # Start at depot\n    current_node = 0\n    unvisited_nodes = set(range(1, n)) # All nodes except depot\n    current_load = 0\n    while unvisited_nodes:\n        # Find the nearest unvisited node\n        next_node = None\n        min_dist = float('inf')\n\n        possible_next_nodes = []\n        for node in unvisited_nodes:\n          if demands[node] + current_load <= capacity:\n            possible_next_nodes.append(node)\n\n        if not possible_next_nodes:\n          #Return to depot and continue\n          simulated_route.append(0)\n          current_node = 0\n          current_load = 0\n          continue #From the beginning with depot.\n\n        for node in possible_next_nodes:\n            dist = distance_matrix[current_node, node]\n            if dist < min_dist:\n                min_dist = dist\n                next_node = node\n\n        if next_node is not None:\n            simulated_route.append(next_node)\n            unvisited_nodes.remove(next_node)\n            current_load += demands[next_node]\n            current_node = next_node\n        else:\n            break # no next node\n\n    simulated_route.append(0) # Return to depot\n\n    update_pheromone(simulated_route)\n\n    return heuristics\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity, angle considerations, k-NN intensification,\n    adaptive sparsification, and pheromone-inspired reinforcement learning.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Initialize Pheromone Matrix: start with small values\n    pheromone = np.ones_like(distance_matrix) * 0.01\n\n    # Heuristic 1: Basic inverse distance (with scaling)\n    distance_scaling = np.mean(distance_matrix)\n    heuristics = distance_scaling / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity\n    demand_penalty_factor = 0.6\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.6  # Increased depot boost\n            elif i != depot_index and j != depot_index:\n                demand_ratio = (demands[i] + demands[j]) / capacity\n                demand_penalty = demand_penalty_factor * demand_ratio\n                heuristics[i, j] -= demand_penalty\n\n    # Heuristic 3: Depot proximity and adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    depot_proximity_weight = 0.2\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= depot_proximity_weight * detour_penalty\n\n                if distance_matrix[i, j] > 1.3 * distance_scaling and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n    # Heuristic 4: Angle from Depot\n    angle_weight = 0.3\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                    heuristics[i, j] += angle_weight * (1 - angle / np.pi)\n\n    # Heuristic 5: k-NN intensification\n    knn = 6\n    knn_weight = 0.2\n\n    for i in range(1, n):\n        distances_from_i = distance_matrix[i, 1:]\n        nearest_neighbors = np.argsort(distances_from_i)[:knn] + 1\n        for j in nearest_neighbors:\n            heuristics[i, j] += knn_weight\n            heuristics[j, i] += knn_weight\n\n    # Heuristic 6: Pheromone reinforcement\n    pheromone_weight = 0.1\n    heuristics += pheromone_weight * pheromone  # Incorporate pheromone\n\n    # Heuristic 7: Adaptive Sparsification\n    threshold_factor = 0.03\n    threshold = threshold_factor * np.mean(np.abs(heuristics))\n    heuristics[np.abs(heuristics) < threshold] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    # Update Pheromone (Simulated Learning - Reward/Punish Edges)\n    def update_pheromone(route, reward=0.1, punishment=0.01): # Pheromone Update Function\n        for i in range(len(route) - 1):\n            u, v = route[i], route[i+1]\n            pheromone[u, v] += reward * heuristics[u, v]  # Reward\n            pheromone[v, u] += reward * heuristics[v, u]  # Ensure symmetry\n\n        # Optional: Punish less promising edges (can be risky)\n        # for i in range(n):\n        #     for j in range(n):\n        #         if (i, j) not in [(route[k], route[k+1]) for k in range(len(route)-1)]:\n        #             pheromone[i,j] -= punishment * heuristics[i,j]\n        pheromone[pheromone < 0.001] = 0.001 # Lower Bounded\n\n    # Simulate a \"good\" route selection. A more sophisticated approach could incorporate a local search routine\n    # and use the resulting route to update the pheromones\n\n    simulated_route = [0]  # Start at depot\n    current_node = 0\n    unvisited_nodes = set(range(1, n)) # All nodes except depot\n    current_load = 0\n    while unvisited_nodes:\n        # Find the nearest unvisited node\n        next_node = None\n        min_dist = float('inf')\n\n        possible_next_nodes = []\n        for node in unvisited_nodes:\n          if demands[node] + current_load <= capacity:\n            possible_next_nodes.append(node)\n\n        if not possible_next_nodes:\n          #Return to depot and continue\n          simulated_route.append(0)\n          current_node = 0\n          current_load = 0\n          continue #From the beginning with depot.\n\n        for node in possible_next_nodes:\n            dist = distance_matrix[current_node, node]\n            if dist < min_dist:\n                min_dist = dist\n                next_node = node\n\n        if next_node is not None:\n            simulated_route.append(next_node)\n            unvisited_nodes.remove(next_node)\n            current_load += demands[next_node]\n            current_node = next_node\n        else:\n            break # no next node\n\n    simulated_route.append(0) # Return to depot\n\n    update_pheromone(simulated_route)\n\n    return heuristics\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines inverse distance, demand, depot proximity, angle, k-NN.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    distance_heuristic = 1 / (distance_matrix + 1e-9)\n    heuristics += 0.4 * distance_heuristic\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i,j] += 0.2\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2*mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty\n\n                if distance_matrix[i, j] > 1.5*np.mean(distance_matrix) and demands[i] + demands[j] > capacity/2:\n                    heuristics[i,j] = 0\n\n    # Heuristic 4: Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n                    heuristics[i,j] += 0.15 * (1 - angle / np.pi)\n\n    # Heuristic 5: k-NN intensification\n    k = min(5, n - 1)\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k+1]\n\n        for neighbor in nearest_neighbors:\n            if i != neighbor:\n                heuristics[i, neighbor] += 0.05\n\n    # Heuristic 6: Depot connection preference adjustment\n    for i in range(1, n):\n        heuristics[depot_index, i] += 0.05\n        heuristics[i, depot_index] = 0\n\n    # Heuristic 7: Sparsification\n    threshold = 0.005 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, depot proximity, angle, and k-NN with adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Demand and Depot Connection\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4\n\n    # Depot proximity with adaptive pruning and k-NN\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    k = 5\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]\n                if j in neighbors:\n                    heuristics[i, j] += 0.2\n\n    # Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)\n\n    # Sparsification: zero out small heuristic values and edges violating capacity for single vehicle routes.\n    threshold = 0.01 * np.mean(heuristics)  # Adaptive threshold\n    heuristics[heuristics < threshold] = 0\n    for i in range(1, n):  # Start from 1 to avoid depot self-loop\n        for j in range(1, n):\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i, depot_index] + distance_matrix[depot_index, j] < 1.5 * np.mean(distance_matrix):\n                heuristics[i, j] = 0  # Zero edges exceeding the vehicle capacity. Added proximity check to remove edges where going to depot in between is much shorter\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, depot proximity, angle, and k-NN with adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Demand and Depot Connection\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4\n\n    # Depot proximity with adaptive pruning and k-NN\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    k = 5\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]\n                if j in neighbors:\n                    heuristics[i, j] += 0.2\n\n    # Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)\n\n    # Sparsification: zero out small heuristic values and edges violating capacity for single vehicle routes.\n    threshold = 0.01 * np.mean(heuristics)  # Adaptive threshold\n    heuristics[heuristics < threshold] = 0\n    for i in range(1, n):  # Start from 1 to avoid depot self-loop\n        for j in range(1, n):\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i, depot_index] + distance_matrix[depot_index, j] < 1.5 * np.mean(distance_matrix):\n                heuristics[i, j] = 0  # Zero edges exceeding the vehicle capacity. Added proximity check to remove edges where going to depot in between is much shorter\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, depot proximity, angle, and k-NN with adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Demand and Depot Connection\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4\n\n    # Depot proximity with adaptive pruning and k-NN\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    k = 5\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]\n                if j in neighbors:\n                    heuristics[i, j] += 0.2\n\n    # Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)\n\n    # Sparsification: zero out small heuristic values and edges violating capacity for single vehicle routes.\n    threshold = 0.01 * np.mean(heuristics)  # Adaptive threshold\n    heuristics[heuristics < threshold] = 0\n    for i in range(1, n):  # Start from 1 to avoid depot self-loop\n        for j in range(1, n):\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i, depot_index] + distance_matrix[depot_index, j] < 1.5 * np.mean(distance_matrix):\n                heuristics[i, j] = 0  # Zero edges exceeding the vehicle capacity. Added proximity check to remove edges where going to depot in between is much shorter\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, depot proximity, angle, and k-NN with adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Demand and Depot Connection\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4\n\n    # Depot proximity with adaptive pruning and k-NN\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    k = 5\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]\n                if j in neighbors:\n                    heuristics[i, j] += 0.2\n\n    # Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)\n\n    # Sparsification: zero out small heuristic values and edges violating capacity for single vehicle routes.\n    threshold = 0.01 * np.mean(heuristics)  # Adaptive threshold\n    heuristics[heuristics < threshold] = 0\n    for i in range(1, n):  # Start from 1 to avoid depot self-loop\n        for j in range(1, n):\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i, depot_index] + distance_matrix[depot_index, j] < 1.5 * np.mean(distance_matrix):\n                heuristics[i, j] = 0  # Zero edges exceeding the vehicle capacity. Added proximity check to remove edges where going to depot in between is much shorter\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines distance, demand, depot proximity, angle, adaptive sparsification, and k-NN.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Demand and Depot Connection\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4\n            elif i != depot_index and j == depot_index:\n                heuristics[i,j] = 0\n            else:\n                heuristics[i,j] += 1/(distance_matrix[i,j] * demands[j] + 1e-9)\n\n    # Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)\n\n    # Adaptive Sparsification and k-NN\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n    k = 5  # Number of nearest neighbors\n\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != depot_index and j != depot_index:\n                #Penalize edges based on detour from direct depot route. Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty  # Increased weight\n\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]\n                if j in neighbors:\n                    heuristics[i, j] += 0.2\n\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i,depot_index] + distance_matrix[depot_index, j] < 1.5* np.mean(distance_matrix):\n                heuristics[i, j] = 0\n\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines distance, demand, depot proximity, angle, adaptive sparsification, and k-NN.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Demand and Depot Connection\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4\n            elif i != depot_index and j == depot_index:\n                heuristics[i,j] = 0\n            else:\n                heuristics[i,j] += 1/(distance_matrix[i,j] * demands[j] + 1e-9)\n\n    # Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)\n\n    # Adaptive Sparsification and k-NN\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n    k = 5  # Number of nearest neighbors\n\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != depot_index and j != depot_index:\n                #Penalize edges based on detour from direct depot route. Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty  # Increased weight\n\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]\n                if j in neighbors:\n                    heuristics[i, j] += 0.2\n\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i,depot_index] + distance_matrix[depot_index, j] < 1.5* np.mean(distance_matrix):\n                heuristics[i, j] = 0\n\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity, angle considerations, k-NN intensification,\n    and adaptive sparsification with refined components, dynamic weight tuning based on problem characteristics,\n    and a more sophisticated penalty system.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # --- Problem Characterization for Adaptive Weights ---\n    total_demand = np.sum(demands)\n    avg_distance = np.mean(distance_matrix)\n    demand_capacity_ratio = total_demand / (n * capacity)  # Scale of demand vs. capacity\n\n    # --- Heuristic Weights (Dynamically Adjusted) ---\n    distance_weight = 0.4\n    demand_weight = 0.3\n    depot_proximity_weight = 0.15\n    angle_weight = 0.1\n    knn_weight = 0.05\n\n    # Adjust weights based on problem characteristics\n    if demand_capacity_ratio > 0.5:  # High demand relative to capacity\n        demand_weight += 0.1\n        distance_weight -= 0.05 # Reduce weight on distance, focus on meeting demands\n        depot_proximity_weight -= 0.05 # Avoid premature return to depot if demand is high\n\n    if avg_distance > np.median(distance_matrix): # if distances are generally large\n        distance_weight += 0.05\n        depot_proximity_weight += 0.05\n        knn_weight -= 0.05\n\n    # Heuristic 1: Basic inverse distance (scaled)\n    heuristics = 1 / (distance_matrix + 1e-9)\n    heuristics *= avg_distance  # Scale based on average distance\n    heuristics *= distance_weight\n\n    # Heuristic 2: Demand and Capacity consideration\n    demand_penalty_exponent = 1.5  # Increase the penalty effect for higher demand ratios\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:  # Directly prune edges that violate capacity constraint.\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.5 * demand_weight  # Depot boost\n            elif i != depot_index and j != depot_index:\n                demand_ratio = (demands[i] + demands[j]) / capacity\n                demand_penalty = demand_weight * (demand_ratio ** demand_penalty_exponent)\n                heuristics[i, j] -= demand_penalty\n\n    # Heuristic 3: Depot proximity with Adaptive Penalty\n    depot_distances = distance_matrix[:, depot_index]\n    median_depot_distance = np.median(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * median_depot_distance + 1e-9)\n                heuristics[i, j] -= depot_proximity_weight * detour_penalty\n\n                # Adaptive pruning based on demand and distance.\n                if distance_matrix[i, j] > 1.3 * avg_distance and demands[i] + demands[j] > capacity / 2:\n                    heuristics[i, j] = 0\n\n    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    # Convert cosine to angle in radians\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Ensure within valid range\n\n                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value\n                    heuristics[i, j] += angle_weight * (1 - angle / np.pi)  # Normalized angle reward\n\n    # Heuristic 5: k-NN intensification (Focus on local search)\n    knn = min(5, n - 1)  # Cap k-NN at n-1\n    for i in range(1, n):\n        # Find k-nearest neighbors based on distance\n        distances_from_i = distance_matrix[i, 1:]  # Exclude depot\n        nearest_neighbors = np.argsort(distances_from_i)[:knn] + 1  # Get indices of nearest neighbors\n        for j in nearest_neighbors:\n            heuristics[i, j] += knn_weight\n            heuristics[j, i] += knn_weight\n\n    # Heuristic 6: Sparsification: zero out small heuristic values (Adaptive Threshold)\n    threshold_factor = 0.02\n    threshold = threshold_factor * np.mean(np.abs(heuristics))  # Adaptive threshold\n    heuristics[np.abs(heuristics) < threshold] = 0\n\n    # Normalize (After Sparsification)\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Improved CVRP heuristic: combines inverse distance, demand, depot proximity, angle, and adaptive sparsification with k-NN.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance with a small constant added to avoid division by zero\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration and Depot Connection preference\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4  # Increased depot connection importance\n\n            elif i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Removing edges to depot\n\n            elif i != depot_index and j != depot_index:\n                  heuristics[i,j] += 1/(distance_matrix[i,j] * demands[j] + 1e-9)\n\n    # Heuristic 3: Depot proximity with adaptive pruning and k-NN intensification\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    k = 5\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty\n\n                # Adaptive pruning\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                # k-NN intensification\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]\n                if j in neighbors:\n                    heuristics[i, j] += 0.2\n\n    # Heuristic 4: Angle from Depot - Prefer edges where nodes are in similar direction from depot.\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)\n\n    # Heuristic 5: Sparsification\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i,depot_index] + distance_matrix[depot_index, j] < 1.5* np.mean(distance_matrix):\n                heuristics[i, j] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Improved CVRP heuristic: combines inverse distance, demand, depot proximity, angle, and adaptive sparsification with k-NN.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance with a small constant added to avoid division by zero\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration and Depot Connection preference\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4  # Increased depot connection importance\n\n            elif i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Removing edges to depot\n\n            elif i != depot_index and j != depot_index:\n                  heuristics[i,j] += 1/(distance_matrix[i,j] * demands[j] + 1e-9)\n\n    # Heuristic 3: Depot proximity with adaptive pruning and k-NN intensification\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    k = 5\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty\n\n                # Adaptive pruning\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                # k-NN intensification\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]\n                if j in neighbors:\n                    heuristics[i, j] += 0.2\n\n    # Heuristic 4: Angle from Depot - Prefer edges where nodes are in similar direction from depot.\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)\n\n    # Heuristic 5: Sparsification\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i,depot_index] + distance_matrix[depot_index, j] < 1.5* np.mean(distance_matrix):\n                heuristics[i, j] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Improved CVRP heuristic: combines inverse distance, demand, depot proximity, angle, and adaptive sparsification with k-NN.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance with a small constant added to avoid division by zero\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration and Depot Connection preference\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4  # Increased depot connection importance\n\n            elif i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Removing edges to depot\n\n            elif i != depot_index and j != depot_index:\n                  heuristics[i,j] += 1/(distance_matrix[i,j] * demands[j] + 1e-9)\n\n    # Heuristic 3: Depot proximity with adaptive pruning and k-NN intensification\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    k = 5\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty\n\n                # Adaptive pruning\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                # k-NN intensification\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]\n                if j in neighbors:\n                    heuristics[i, j] += 0.2\n\n    # Heuristic 4: Angle from Depot - Prefer edges where nodes are in similar direction from depot.\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)\n\n    # Heuristic 5: Sparsification\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i,depot_index] + distance_matrix[depot_index, j] < 1.5* np.mean(distance_matrix):\n                heuristics[i, j] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines adaptive pruning, demand/capacity, depot proximity, and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Depot connection encouragement\n    for j in range(1, n):\n        if demands[j] <= capacity:\n            heuristics[depot_index, j] += 0.5 / (distance_matrix[depot_index, j] + 1e-6)\n            heuristics[j, depot_index] = 0\n        else:\n            heuristics[depot_index, j] = 0\n\n    # Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n    # Demand-based Sparsification\n    mean_distance = np.mean(distance_matrix)\n    mean_demand = np.mean(demands[1:])\n    threshold = mean_distance * mean_demand * 1.5\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            combined_metric = distance_matrix[i, j] * (demands[i] + demands[j])\n            if combined_metric > threshold:\n                heuristics[i, j] = 0\n\n    # Sparsification\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines adaptive pruning, demand/capacity, depot proximity, and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Depot connection encouragement\n    for j in range(1, n):\n        if demands[j] <= capacity:\n            heuristics[depot_index, j] += 0.5 / (distance_matrix[depot_index, j] + 1e-6)\n            heuristics[j, depot_index] = 0\n        else:\n            heuristics[depot_index, j] = 0\n\n    # Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n    # Demand-based Sparsification\n    mean_distance = np.mean(distance_matrix)\n    mean_demand = np.mean(demands[1:])\n    threshold = mean_distance * mean_demand * 1.5\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            combined_metric = distance_matrix[i, j] * (demands[i] + demands[j])\n            if combined_metric > threshold:\n                heuristics[i, j] = 0\n\n    # Sparsification\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines adaptive pruning, demand/capacity, depot proximity, and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Depot connection encouragement\n    for j in range(1, n):\n        if demands[j] <= capacity:\n            heuristics[depot_index, j] += 0.5 / (distance_matrix[depot_index, j] + 1e-6)\n            heuristics[j, depot_index] = 0\n        else:\n            heuristics[depot_index, j] = 0\n\n    # Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n    # Demand-based Sparsification\n    mean_distance = np.mean(distance_matrix)\n    mean_demand = np.mean(demands[1:])\n    threshold = mean_distance * mean_demand * 1.5\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            combined_metric = distance_matrix[i, j] * (demands[i] + demands[j])\n            if combined_metric > threshold:\n                heuristics[i, j] = 0\n\n    # Sparsification\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Adaptive pruning, demand, depot proximity, angle, sparsification, k-NN.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration + Depot encouragement\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.5 / (distance_matrix[i, j] + 1e-6) # Depot boost, scaled by inverse distance\n            elif i != depot_index and j != depot_index:\n                if demands[i] + demands[j] > capacity:\n                    heuristics[i, j] = 0\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n    # Heuristic 4: Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n                    heuristics[i, j] += 0.1 * (1 - angle / np.pi)\n\n    # Heuristic 5: Demand-based Sparsification (Combined metric)\n    mean_distance = np.mean(distance_matrix)\n    mean_demand = np.mean(demands[1:])\n    threshold = mean_distance * mean_demand * 1.5\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            combined_metric = distance_matrix[i, j] * (demands[i] + demands[j])\n\n            if combined_metric > threshold:\n                heuristics[i, j] = 0\n\n    # Heuristic 6: Sparsification: zero out small heuristic values\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n\n    # Heuristic 7: K-Nearest Neighbor\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]\n        for nn in neighbors_idx:\n            heuristics[i, nn] += 0.2\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Adaptive pruning, demand, depot proximity, angle, sparsification, k-NN.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration + Depot encouragement\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.5 / (distance_matrix[i, j] + 1e-6) # Depot boost, scaled by inverse distance\n            elif i != depot_index and j != depot_index:\n                if demands[i] + demands[j] > capacity:\n                    heuristics[i, j] = 0\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n    # Heuristic 4: Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n                    heuristics[i, j] += 0.1 * (1 - angle / np.pi)\n\n    # Heuristic 5: Demand-based Sparsification (Combined metric)\n    mean_distance = np.mean(distance_matrix)\n    mean_demand = np.mean(demands[1:])\n    threshold = mean_distance * mean_demand * 1.5\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            combined_metric = distance_matrix[i, j] * (demands[i] + demands[j])\n\n            if combined_metric > threshold:\n                heuristics[i, j] = 0\n\n    # Heuristic 6: Sparsification: zero out small heuristic values\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n\n    # Heuristic 7: K-Nearest Neighbor\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]\n        for nn in neighbors_idx:\n            heuristics[i, nn] += 0.2\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 19th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Adaptive pruning, demand, depot proximity, angle, sparsification, k-NN.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration + Depot encouragement\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.5 / (distance_matrix[i, j] + 1e-6) # Depot boost, scaled by inverse distance\n            elif i != depot_index and j != depot_index:\n                if demands[i] + demands[j] > capacity:\n                    heuristics[i, j] = 0\n\n    # Heuristic 3: Depot proximity with adaptive pruning\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0\n            elif i != depot_index and j != depot_index:\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.05 * detour_penalty\n\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n    # Heuristic 4: Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n                    heuristics[i, j] += 0.1 * (1 - angle / np.pi)\n\n    # Heuristic 5: Demand-based Sparsification (Combined metric)\n    mean_distance = np.mean(distance_matrix)\n    mean_demand = np.mean(demands[1:])\n    threshold = mean_distance * mean_demand * 1.5\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            combined_metric = distance_matrix[i, j] * (demands[i] + demands[j])\n\n            if combined_metric > threshold:\n                heuristics[i, j] = 0\n\n    # Heuristic 6: Sparsification: zero out small heuristic values\n    threshold = 0.01 * np.mean(heuristics)\n    heuristics[heuristics < threshold] = 0\n\n    # Heuristic 7: K-Nearest Neighbor\n    k_nearest_neighbors = 4\n    for i in range(n):\n        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]\n        for nn in neighbors_idx:\n            heuristics[i, nn] += 0.2\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n[Heuristics 20th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version refines heuristics_v1 by incorporating more adaptive and problem-aware components,\n    including cost-based prioritization, adaptive neighborhood scaling, and route completion encouragement.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # 1. Cost-Based Prioritization (Combined Distance and Demand): More informed initial values\n    cost_matrix = distance_matrix.copy()\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                cost_matrix[i, j] += (demands[i] + demands[j]) / capacity * np.mean(distance_matrix)  # Scale demand cost by average distance\n\n    heuristics = 1 / (cost_matrix + 1e-9)\n    heuristics *= np.mean(distance_matrix) #scaling\n\n    # 2. Depot Influence: Adaptive Scaling based on distance to depot and remaining capacity.\n    depot_distances = distance_matrix[:, depot_index]\n    remaining_capacity_weight = 0.3  # Tunable\n    depot_proximity_weight = 0.2\n    for i in range(1, n):\n        heuristics[depot_index, i] += depot_proximity_weight * (1 - depot_distances[i] / np.max(depot_distances))\n        heuristics[i, depot_index] = 0 #block return trip except from depot.\n\n    # 3. Route Completion Encouragement:  Prioritize links that help complete partial routes (Capacity-aware).\n    route_completion_weight = 0.25  # Tunable.\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                 # Encourage connections that reduce remaining capacity on a potential route\n                route_efficiency =  min(demands[i],demands[j])/(capacity + 1e-9) #Scale\n                heuristics[i, j] += route_completion_weight * route_efficiency\n\n\n    # 4. Adaptive Neighborhood Scaling (k-NN with dynamic k based on node density)\n    knn_base = 4\n    knn_weight = 0.15\n\n    # Estimate node density based on average distance to neighbors\n    node_densities = np.zeros(n)\n    for i in range(1, n):\n        distances_from_i = distance_matrix[i, 1:]\n        nearest_neighbors_dist = np.sort(distances_from_i)[:min(knn_base,n-1)]\n        node_densities[i] = np.mean(nearest_neighbors_dist)\n\n    mean_node_density = np.mean(node_densities[1:])\n\n    for i in range(1, n):\n        #Adaptive K based on node density compared to average\n        adaptive_knn = int(knn_base * (mean_node_density / (node_densities[i] + 1e-9)))\n        adaptive_knn = max(1, min(adaptive_knn, n - 1)) #Clamp between 1 and n-1\n        distances_from_i = distance_matrix[i, 1:]  # Exclude depot\n        nearest_neighbors = np.argsort(distances_from_i)[:adaptive_knn] + 1  # Get indices of nearest neighbors\n        for j in nearest_neighbors:\n            heuristics[i, j] += knn_weight\n            heuristics[j, i] += knn_weight\n\n\n    # 5. Sparsification: More aggressive sparsification based on percentile.\n    sparsification_percentile = 35  # Sparsify below this percentile. Tunable.\n    threshold = np.percentile(heuristics[heuristics > 0], sparsification_percentile)  #Consider only positive values\n    heuristics[heuristics < threshold] = 0\n\n\n\n    # 6. Normalize (After Sparsification)\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}