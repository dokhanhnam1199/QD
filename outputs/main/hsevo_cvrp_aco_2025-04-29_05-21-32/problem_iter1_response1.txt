```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several factors to estimate the desirability of including
    an edge in a route, going beyond a simple inverse distance.  It considers:

    1. Distance: Shorter distances are preferred (inverse relationship).
    2. Demand Compatibility: Edges connecting nodes that, when combined with the
       current route's load, are less likely to violate capacity constraints are
       preferred.
    3. Angle: Edges forming sharper turns are penalized, as they often lead to less
       efficient routes.  This is done by computing the angle between potential edges
       and penalizing sharp turns.
    4. Closeness to Depot: Edges closer to the depot are generally favored, especially
       when near capacity, to facilitate returns to the depot.

    Args:
        distance_matrix: Distance matrix (n x n).
        coordinates: Node coordinates (n x 2).
        demands: Node demands (n).
        capacity: Vehicle capacity.

    Returns:
        Heuristic matrix (n x n) indicating the desirability of each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Add a small constant to the distance matrix to avoid division by zero
    distance_matrix = distance_matrix + 1e-9  # Avoid division by zero

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # 1. Distance-based heuristic (inverse distance)
            distance_heuristic = 1 / distance_matrix[i, j]

            # 2. Demand-based heuristic (penalize edges likely to cause capacity violations)
            demand_penalty = (demands[i] + demands[j]) / (2 * capacity) # Normalize to a penalty factor around 1
            demand_heuristic = max(0, 1 - demand_penalty) # Scales to between 0-1
            

            # 3. Angle-based heuristic (penalize sharp turns)
            #   - Approximate by considering depot as the previous node for now.
            #   - Can be improved by keeping track of the actual route as it's built
            if i == 0:
                angle_heuristic = 1.0 #No turn
            else:
                # vector from depot to node i and node i to node j
                vector1 = coordinates[i] - coordinates[0]
                vector2 = coordinates[j] - coordinates[i]

                # Calculate the cosine of the angle between the vectors
                norm1 = np.linalg.norm(vector1)
                norm2 = np.linalg.norm(vector2)

                if norm1 > 0 and norm2 > 0:
                    cos_angle = np.dot(vector1, vector2) / (norm1 * norm2)
                    # Clip cosine to [-1, 1] to avoid potential errors
                    cos_angle = np.clip(cos_angle, -1.0, 1.0)
                    angle = np.arccos(cos_angle)  # Angle in radians
                    angle_penalty = angle / np.pi  # Normalize to a penalty factor between 0 and 1. Sharp turn is 1, straight line is 0
                    angle_heuristic = max(0, 1-angle_penalty)
                else:
                    angle_heuristic = 0.5 # Default penalty



            # 4. Depot Proximity
            depot_distance = distance_matrix[i,0] + distance_matrix[j,0]
            depot_proximity = np.exp(-depot_distance/np.mean(distance_matrix)) # Bias shorter total distance from i & j to depot



            # Combine the heuristics (weighted sum) - EXPERIMENTAL
            heuristic_matrix[i, j] = (
                0.4 * distance_heuristic +
                0.3 * demand_heuristic +
                0.2 * angle_heuristic +
                0.1 * depot_proximity
            )

    return heuristic_matrix
```
