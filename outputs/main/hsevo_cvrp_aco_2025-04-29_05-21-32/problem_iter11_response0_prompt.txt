{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\n### Better code\ndef heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates demand, distance, depot proximity and angle considerations with adaptive sparsification and simplified components.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Heuristic 1: Basic inverse distance\n    heuristics = 1 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Demand and Capacity consideration\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0\n                continue\n\n            if i == depot_index and j != depot_index:\n                if demands[j] > capacity:  # Directly prune edges that violate capacity constraint.\n                    heuristics[i, j] = 0\n                else:\n                    heuristics[i, j] += 0.4  # Depot boost, increased importance\n\n    # Heuristic 3: Depot proximity with adaptive pruning and k-NN\n    depot_distances = distance_matrix[:, depot_index]\n    mean_depot_distance = np.mean(depot_distances)\n    k = 5  # Number of nearest neighbors to consider for intensification\n\n    for i in range(n):\n        for j in range(n):\n            if i != depot_index and j == depot_index:\n                heuristics[i, j] = 0  # Remove edges to depot (except from depot)\n            elif i != depot_index and j != depot_index:\n                # Penalize edges based on detour from direct depot route. Simpler calculation.\n                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)\n                heuristics[i, j] -= 0.1 * detour_penalty  # Increased weight\n\n                # Adaptive pruning based on demand and distance\n                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity / 3:\n                    heuristics[i, j] = 0\n\n                # k-NN intensification:  If j is among the k nearest neighbors of i, boost the heuristic\n                neighbors = np.argsort(distance_matrix[i, :])[1:k + 1]  # Exclude self (i) and depot (0)\n                if j in neighbors:\n                    heuristics[i, j] += 0.2  # k-NN boost\n\n    # Heuristic 4: Angle from Depot\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Dot product to find the cosine of the angle between vectors\n                vector_i = coordinates[i] - coordinates[depot_index]\n                vector_j = coordinates[j] - coordinates[depot_index]\n\n                norm_i = np.linalg.norm(vector_i)\n                norm_j = np.linalg.norm(vector_j)\n\n                if norm_i > 0 and norm_j > 0:\n                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)\n                    # Convert cosine to angle in radians\n                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Ensure within valid range\n\n                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value\n                    heuristics[i, j] += 0.15 * (1 - angle / np.pi)  # Increased weight\n\n    # Heuristic 5: Sparsification: zero out small heuristic values and edges violating capacity for single vehicle routes.\n    threshold = 0.01 * np.mean(heuristics)  # Adaptive threshold\n    heuristics[heuristics < threshold] = 0\n    for i in range(1, n): # Start from 1 to avoid depot self-loop\n        for j in range(1, n):\n            if i != depot_index and j != depot_index and demands[i] + demands[j] > capacity and distance_matrix[i,depot_index] + distance_matrix[depot_index, j] < 1.5* np.mean(distance_matrix):\n                heuristics[i, j] = 0 # Zero edges exceeding the vehicle capacity. Added proximity check to remove edges where going to depot in between is much shorter\n\n    # Normalize\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n### Worse code\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"CVRP heuristic: Combines distance, demand, depot proximity, angle, adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    depot_index = 0\n\n    # Inverse distance\n    distance_heuristic = 1 / (distance_matrix + 1e-9)\n    heuristics += distance_heuristic * 0.5\n\n    # Demand and Depot Connection\n    demand_distance_heuristic = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if i == depot_index:\n                remaining_capacity = capacity - demands[j]\n                if remaining_capacity >= 0:\n                    demand_distance_heuristic[i, j] = 0.7\n                else:\n                    demand_distance_heuristic[i, j] = 0\n            elif i != depot_index and j == depot_index:\n                  demand_distance_heuristic[i,j] = 0\n            else:\n                demand_distance_heuristic[i,j] = 1/(distance_matrix[i,j] * demands[j] + 1e-9)\n\n    heuristics += demand_distance_heuristic * 0.4\n\n    # Angle from Depot\n    angle_heuristic = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i == depot_index or j == depot_index or i ==j:\n                angle_heuristic[i,j] = 0\n                continue\n\n            vector_i = coordinates[i] - coordinates[depot_index]\n            vector_j = coordinates[j] - coordinates[depot_index]\n\n            norm_i = np.linalg.norm(vector_i)\n            norm_j = np.linalg.norm(vector_j)\n\n            if norm_i == 0 or norm_j == 0:\n                angle = 0\n            else:\n                dot_product = np.dot(vector_i, vector_j)\n                cos_angle = dot_product / (norm_i * norm_j)\n                angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n            angle_heuristic[i,j] = 1- (angle / np.pi)\n\n    heuristics += angle_heuristic * 0.1\n\n    # Adaptive Sparsification\n    threshold = np.mean(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i != j and distance_matrix[i,j] > threshold * 2 :\n                heuristics[i, j] = 0\n\n    # Normalization\n    max_heuristic = np.max(heuristics)\n    if max_heuristic > 0:\n        heuristics = heuristics / max_heuristic\n\n    return heuristics\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic incorporates inverse distance, demand/capacity considerations, depot proximity with adaptive pruning and k-NN, angle from depot, and sparsification, while the worst uses only inverse distance, demand-aware pruning, depot proximity, and sparsification. (2nd) vs (19th) shows k-NN dropped. Comparing (1st) vs (2nd), we see they are identical. (3rd) vs (4th) shows the more complex logic with different weighting and aggressive sparsification helps. Comparing (second worst) vs (worst), the second worst included K-NN while the worst does not. Overall: Better heuristics tend to incorporate more features (distance, demand, depot proximity, angles), adaptive pruning/sparsification, and intensification techniques (k-NN). They also carefully manage edge cases and normalize the heuristic values. Simpler heuristics are often outperformed by more complex, well-tuned ones.\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, let's refine self-reflection for designing better heuristics. We need to move beyond just listing techniques and focus on *why* and *how* to apply them effectively.\n\n*   **Keywords:** Adaptive learning, problem-specific knowledge, iterative refinement, evaluation metrics, trade-off analysis.\n*   **Advice:** Frame heuristic design as an iterative learning process driven by problem-specific insights and performance evaluation. Focus on understanding the underlying problem structure.\n*   **Avoid:** Blindly adding features or tuning weights without a clear rationale. Avoid complexity without demonstrated performance improvement.\n*   **Explanation:** Instead of simply stating techniques, emphasize adapting heuristic components based on *observed* performance and a deep understanding of the problem's characteristics.\n\n\nYour task is to write an improved function `heuristics_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}