```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP) that combines distance, demand,
    and a stochastic component to generate edge priorities.

    Args:
        distance_matrix (np.ndarray): A matrix of distances between all nodes.
        coordinates (np.ndarray): The Euclidean coordinates of each node.
        demands (np.ndarray): The demand of each customer node.
        capacity (int): The capacity of each vehicle.

    Returns:
        np.ndarray: A matrix of heuristic values indicating the priority of each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (tunable)
    distance_weight = 1.0
    demand_weight = 0.5
    coordinate_proximity_weight = 0.2
    stochasticity_weight = 0.1  # Increased stochasticity

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance component: encourages shorter edges
                distance_heuristic = distance_weight / distance_matrix[i, j]

                # Demand component: penalizes edges connecting nodes with high cumulative demand in local region
                # Higher demands between i and j make connections less desirable
                demand_heuristic = 1.0 / (1 + demands[i] + demands[j])  # Ensure always positive and bounded

                # Coordinate proximity component: encourages edges connecting nodes close in space, adjusted for depot
                # Nodes closer to the depot can be valuable depending on capacity
                proximity = np.linalg.norm(coordinates[i] - coordinates[j])
                depot_distance_i = np.linalg.norm(coordinates[i] - coordinates[0])
                depot_distance_j = np.linalg.norm(coordinates[j] - coordinates[0])
                coordinate_heuristic = coordinate_proximity_weight / (1 + proximity + depot_distance_i + depot_distance_j)

                # Stochastic component: adds randomness to the heuristic to explore different solutions
                stochastic_component = np.random.uniform(0, stochasticity_weight)

                # Combine the components
                heuristic_matrix[i, j] = (
                    distance_heuristic + demand_heuristic + coordinate_heuristic + stochastic_component
                )

    return heuristic_matrix
```
