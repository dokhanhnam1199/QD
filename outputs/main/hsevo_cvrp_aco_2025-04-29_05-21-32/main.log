[2025-04-29 05:21:32,279][root][INFO] - Workspace: C:\Users\Nam\Documents\GitHub\HSEvo\outputs\main\hsevo_cvrp_aco_2025-04-29_05-21-32
[2025-04-29 05:21:32,280][root][INFO] - Project Root: C:\Users\Nam\Documents\GitHub\HSEvo
[2025-04-29 05:21:32,280][root][INFO] - Using LLM: gemini/gemini-2.0-flash
[2025-04-29 05:21:32,280][root][INFO] - Using Algorithm: hsevo
[2025-04-29 05:21:34,867][httpx][INFO] - HTTP Request: GET https://raw.githubusercontent.com/BerriAI/litellm/main/model_prices_and_context_window.json "HTTP/1.1 200 OK"
[2025-04-29 05:21:36,699][root][INFO] - Problem: cvrp_aco
[2025-04-29 05:21:36,700][root][INFO] - Problem description: Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
[2025-04-29 05:21:36,705][root][INFO] - Function name: heuristics
[2025-04-29 05:21:36,707][root][INFO] - Evaluating seed function...
[2025-04-29 05:21:36,708][root][INFO] - Seed function code: 
import numpy as np
import random
import math
import scipy
import torch
def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix
[2025-04-29 05:21:36,708][root][INFO] - Iteration 0: Running Code 0
[2025-04-29 05:21:42,401][root][INFO] - Iteration 0: Code Run 0 successful!
[2025-04-29 05:22:12,824][root][INFO] - Iteration 0, response_id 0: Objective value: 18.33277511962764
[2025-04-29 05:22:12,825][root][INFO] - Iteration 0: Elitist: 18.33277511962764
[2025-04-29 05:22:12,825][root][INFO] - Iteration 0 finished...
[2025-04-29 05:22:12,825][root][INFO] - Best obj: 18.33277511962764, Best Code Path: problem_iter0_code0.py
[2025-04-29 05:22:12,825][root][INFO] - LLM usage: prompt_tokens = 0, completion_tokens = 0
[2025-04-29 05:22:12,825][root][INFO] - Function Evals: 1
[2025-04-29 05:22:12,826][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,827][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,829][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Isaac Newton, the father of physics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Isaac Newton, the father of physics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,831][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,832][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Nikola Tesla, master of electricity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Nikola Tesla, master of electricity. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,834][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,836][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,838][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,840][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,841][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,843][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,845][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,847][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Isaac Newton, the father of physics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Isaac Newton, the father of physics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,848][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,849][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Nikola Tesla, master of electricity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Nikola Tesla, master of electricity. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,851][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,852][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,854][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,856][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,858][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,860][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,862][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,864][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Isaac Newton, the father of physics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Isaac Newton, the father of physics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,865][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,868][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Nikola Tesla, master of electricity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Nikola Tesla, master of electricity. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,869][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,871][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,873][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,874][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,875][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 05:22:12,897][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:12,898][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:18,246][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:22:18,250][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:22:18,252][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:18,252][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:18,255][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:18,257][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:21,512][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:22:21,516][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:22:21,517][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:21,518][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:21,520][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:21,521][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:24,368][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:22:24,371][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:22:24,373][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:24,373][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:24,376][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:24,377][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:26,955][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:22:26,956][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:22:26,957][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:26,957][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:26,958][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:26,958][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:29,793][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:22:29,797][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:22:29,798][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:29,798][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:29,800][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:29,802][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:32,707][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:22:32,710][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:22:32,711][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:32,712][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:32,715][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:32,716][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:36,877][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:22:36,880][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:22:36,881][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:36,881][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:36,883][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:36,885][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:37,220][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:22:37,221][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:22:37,222][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:37,222][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:37,223][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:37,224][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:41,206][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:22:41,209][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:22:41,210][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:41,211][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:41,213][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:41,214][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:42,870][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:22:42,873][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:22:42,874][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:42,875][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:42,876][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:42,879][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:46,502][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:22:46,505][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:22:46,506][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:46,507][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:46,509][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:46,511][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:49,931][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:22:49,933][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:22:49,934][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:49,934][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:49,935][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:49,936][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:52,378][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:22:52,381][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:22:52,382][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:52,383][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:52,385][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:52,386][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:54,019][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:22:54,021][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:22:54,022][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:54,023][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:54,024][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:54,025][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:59,717][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:22:59,719][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:22:59,721][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:59,721][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:22:59,724][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:22:59,725][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:00,962][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:23:00,966][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:23:00,966][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:00,966][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:00,967][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:00,968][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:01,432][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-29 05:23:01,451][root][INFO] - Attempt 1 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "location": "global",
              "model": "gemini-2.0-flash"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "53s"
      }
    ]
  }
}

[2025-04-29 05:23:01,758][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-29 05:23:01,773][root][INFO] - Attempt 1 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "location": "global",
              "model": "gemini-2.0-flash"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "53s"
      }
    ]
  }
}

[2025-04-29 05:23:04,454][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:04,774][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:06,128][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-29 05:23:06,142][root][INFO] - Attempt 2 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "location": "global",
              "model": "gemini-2.0-flash"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "49s"
      }
    ]
  }
}

[2025-04-29 05:23:06,514][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-29 05:23:06,532][root][INFO] - Attempt 2 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "location": "global",
              "model": "gemini-2.0-flash"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "48s"
      }
    ]
  }
}

[2025-04-29 05:23:09,145][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:09,533][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:10,022][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-29 05:23:10,046][root][INFO] - Attempt 3 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "model": "gemini-2.0-flash",
              "location": "global"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "45s"
      }
    ]
  }
}

[2025-04-29 05:23:11,172][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-29 05:23:11,186][root][INFO] - Attempt 3 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "location": "global",
              "model": "gemini-2.0-flash"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "44s"
      }
    ]
  }
}

[2025-04-29 05:23:13,049][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:14,029][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-29 05:23:14,048][root][INFO] - Attempt 4 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "location": "global",
              "model": "gemini-2.0-flash"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "41s"
      }
    ]
  }
}

[2025-04-29 05:23:14,188][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:17,050][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:22,054][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:23:22,057][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:23:22,058][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:22,059][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:22,061][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:22,062][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:25,142][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:23:25,145][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:23:25,147][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:25,147][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:25,149][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:25,151][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:26,588][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:23:26,591][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:23:26,592][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:26,593][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:26,594][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:26,595][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:31,263][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:23:31,266][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:23:31,267][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:31,268][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:31,271][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:31,272][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:32,271][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:23:32,274][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:23:32,275][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:32,275][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:32,278][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:32,280][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:36,199][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:23:36,201][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:23:36,202][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:36,202][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:36,203][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:36,203][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:37,116][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:23:37,119][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:23:37,120][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:37,120][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:37,122][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:37,124][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:41,365][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:23:41,368][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:23:41,369][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:41,369][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:41,370][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:41,371][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:42,255][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:23:42,258][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:23:42,259][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:42,260][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:42,262][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:42,263][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:46,105][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:23:46,108][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:23:46,109][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:46,110][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:46,111][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:46,111][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:48,399][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:23:48,401][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:23:48,401][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:48,402][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:48,403][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:48,403][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:51,984][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:23:51,987][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:23:51,989][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:51,989][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:51,991][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:23:51,993][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:53,429][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:23:53,430][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:23:53,431][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:53,431][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:53,432][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:57,528][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:23:57,531][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:23:57,532][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:57,532][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:57,537][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:23:57,596][root][INFO] - Iteration 1: Running Code 0
[2025-04-29 05:24:03,529][root][INFO] - Iteration 1: Code Run 0 successful!
[2025-04-29 05:24:03,529][root][INFO] - Iteration 1: Running Code 1
[2025-04-29 05:24:10,388][root][INFO] - Iteration 1: Code Run 1 successful!
[2025-04-29 05:24:10,388][root][INFO] - Iteration 1: Running Code 2
[2025-04-29 05:24:18,261][root][INFO] - Iteration 1: Code Run 2 successful!
[2025-04-29 05:24:18,262][root][INFO] - Iteration 1: Running Code 3
[2025-04-29 05:24:26,497][root][INFO] - Iteration 1: Code Run 3 successful!
[2025-04-29 05:24:26,498][root][INFO] - Iteration 1: Running Code 4
[2025-04-29 05:24:34,927][root][INFO] - Iteration 1: Code Run 4 successful!
[2025-04-29 05:24:34,927][root][INFO] - Iteration 1: Running Code 5
[2025-04-29 05:24:44,248][root][INFO] - Iteration 1: Code Run 5 successful!
[2025-04-29 05:24:44,249][root][INFO] - Iteration 1: Running Code 6
[2025-04-29 05:24:54,348][root][INFO] - Iteration 1: Code Run 6 successful!
[2025-04-29 05:24:54,348][root][INFO] - Iteration 1: Running Code 7
[2025-04-29 05:25:04,565][root][INFO] - Iteration 1: Code Run 7 successful!
[2025-04-29 05:25:04,565][root][INFO] - Iteration 1: Running Code 8
[2025-04-29 05:25:15,278][root][INFO] - Iteration 1: Code Run 8 successful!
[2025-04-29 05:25:15,278][root][INFO] - Iteration 1: Running Code 9
[2025-04-29 05:25:27,038][root][INFO] - Iteration 1: Code Run 9 successful!
[2025-04-29 05:25:27,038][root][INFO] - Iteration 1: Running Code 10
[2025-04-29 05:25:39,105][root][INFO] - Iteration 1: Code Run 10 successful!
[2025-04-29 05:25:39,105][root][INFO] - Iteration 1: Running Code 11
[2025-04-29 05:25:51,536][root][INFO] - Iteration 1: Code Run 11 successful!
[2025-04-29 05:25:51,536][root][INFO] - Iteration 1: Running Code 12
[2025-04-29 05:26:04,833][root][INFO] - Iteration 1: Code Run 12 successful!
[2025-04-29 05:26:04,833][root][INFO] - Iteration 1: Running Code 13
[2025-04-29 05:26:18,071][root][INFO] - Iteration 1: Code Run 13 successful!
[2025-04-29 05:26:18,071][root][INFO] - Iteration 1: Running Code 14
[2025-04-29 05:26:31,245][root][INFO] - Iteration 1: Code Run 14 successful!
[2025-04-29 05:26:31,246][root][INFO] - Iteration 1: Running Code 15
[2025-04-29 05:26:44,188][root][INFO] - Iteration 1: Code Run 15 successful!
[2025-04-29 05:26:44,188][root][INFO] - Iteration 1: Running Code 16
[2025-04-29 05:26:59,492][root][INFO] - Iteration 1: Code Run 16 successful!
[2025-04-29 05:26:59,493][root][INFO] - Iteration 1: Running Code 17
[2025-04-29 05:27:14,910][root][INFO] - Iteration 1: Code Run 17 successful!
[2025-04-29 05:27:14,911][root][INFO] - Iteration 1: Running Code 18
[2025-04-29 05:27:30,711][root][INFO] - Iteration 1: Code Run 18 successful!
[2025-04-29 05:27:30,711][root][INFO] - Iteration 1: Running Code 19
[2025-04-29 05:27:46,199][root][INFO] - Iteration 1: Code Run 19 successful!
[2025-04-29 05:27:46,199][root][INFO] - Iteration 1: Running Code 20
[2025-04-29 05:28:01,928][root][INFO] - Iteration 1: Code Run 20 successful!
[2025-04-29 05:28:01,928][root][INFO] - Iteration 1: Running Code 21
[2025-04-29 05:28:19,400][root][INFO] - Iteration 1: Code Run 21 successful!
[2025-04-29 05:28:19,400][root][INFO] - Iteration 1: Running Code 22
[2025-04-29 05:28:35,086][root][INFO] - Iteration 1: Code Run 22 successful!
[2025-04-29 05:28:35,086][root][INFO] - Iteration 1: Running Code 23
[2025-04-29 05:28:52,416][root][INFO] - Iteration 1: Code Run 23 successful!
[2025-04-29 05:28:52,416][root][INFO] - Iteration 1: Running Code 24
[2025-04-29 05:29:09,939][root][INFO] - Iteration 1: Code Run 24 successful!
[2025-04-29 05:29:09,939][root][INFO] - Iteration 1: Running Code 25
[2025-04-29 05:29:27,773][root][INFO] - Iteration 1: Code Run 25 successful!
[2025-04-29 05:29:27,773][root][INFO] - Iteration 1: Running Code 26
[2025-04-29 05:29:44,361][root][INFO] - Iteration 1: Code Run 26 successful!
[2025-04-29 05:29:44,361][root][INFO] - Iteration 1: Running Code 27
[2025-04-29 05:30:00,266][root][INFO] - Iteration 1: Code Run 27 successful!
[2025-04-29 05:30:00,266][root][INFO] - Iteration 1: Running Code 28
[2025-04-29 05:30:17,083][root][INFO] - Iteration 1: Code Run 28 successful!
[2025-04-29 05:30:17,084][root][INFO] - Iteration 1: Running Code 29
[2025-04-29 05:30:34,108][root][INFO] - Iteration 1: Code Run 29 successful!
[2025-04-29 05:30:34,129][root][INFO] - Iteration 1, response_id 0: Objective value: 19.554326328167726
[2025-04-29 05:30:34,157][root][INFO] - Iteration 1, response_id 1: Objective value: 20.007807523070124
[2025-04-29 05:30:34,182][root][INFO] - Iteration 1, response_id 2: Objective value: 18.400949406180153
[2025-04-29 05:30:34,209][root][INFO] - Iteration 1, response_id 3: Objective value: 20.89999709638416
[2025-04-29 05:30:34,234][root][INFO] - Iteration 1, response_id 4: Objective value: 19.749973113209727
[2025-04-29 05:30:34,259][root][INFO] - Iteration 1, response_id 5: Objective value: 18.30888405363647
[2025-04-29 05:30:34,283][root][INFO] - Iteration 1, response_id 6: Objective value: 20.346754526412255
[2025-04-29 05:30:34,309][root][INFO] - Iteration 1, response_id 7: Objective value: 18.40301992975818
[2025-04-29 05:30:34,333][root][INFO] - Iteration 1, response_id 8: Objective value: 21.243456887614247
[2025-04-29 05:30:34,357][root][INFO] - Iteration 1, response_id 9: Objective value: 20.39055874837024
[2025-04-29 05:30:34,388][root][INFO] - Iteration 1, response_id 10: Objective value: 20.402013917397205
[2025-04-29 05:30:34,409][root][INFO] - Iteration 1, response_id 11: Objective value: 18.842746945111546
[2025-04-29 05:30:34,436][root][INFO] - Iteration 1, response_id 12: Objective value: 15.309384807110408
[2025-04-29 05:30:34,457][root][INFO] - Iteration 1, response_id 13: Objective value: 19.43220516830763
[2025-04-29 05:31:17,712][root][INFO] - Iteration 1, response_id 14: Objective value: 25.144093595790473
[2025-04-29 05:31:17,722][root][INFO] - Iteration 1, response_id 15: Objective value: 16.768739741484442
[2025-04-29 05:31:24,056][root][INFO] - Iteration 1, response_id 16: Objective value: 21.01912015685196
[2025-04-29 05:31:26,601][root][INFO] - Iteration 1, response_id 17: Objective value: 18.019643679340668
[2025-04-29 05:31:29,504][root][INFO] - Iteration 1, response_id 18: Objective value: 19.766161813513527
[2025-04-29 05:31:40,195][root][INFO] - Iteration 1, response_id 19: Objective value: 19.889855375802366
[2025-04-29 05:32:20,221][root][INFO] - Iteration 1, response_id 20: Objective value: 38.330385194409914
[2025-04-29 05:32:20,237][root][INFO] - Iteration 1, response_id 21: Objective value: 18.26496406209286
[2025-04-29 05:32:20,249][root][INFO] - Iteration 1, response_id 22: Objective value: 18.89034100198618
[2025-04-29 05:32:20,269][root][INFO] - Iteration 1, response_id 23: Objective value: 20.548846223050695
[2025-04-29 05:32:29,079][root][INFO] - Iteration 1, response_id 24: Objective value: 20.386512252237754
[2025-04-29 05:32:29,090][root][INFO] - Iteration 1, response_id 25: Objective value: 18.955776782765412
[2025-04-29 05:32:30,806][root][INFO] - Iteration 1, response_id 26: Objective value: 19.47476081555588
[2025-04-29 05:32:34,269][root][INFO] - Iteration 1, response_id 27: Objective value: 19.94948499573278
[2025-04-29 05:32:34,279][root][INFO] - Iteration 1, response_id 28: Objective value: 22.5469684999134
[2025-04-29 05:32:38,485][root][INFO] - Iteration 1, response_id 29: Objective value: 19.81033111600735
[2025-04-29 05:32:38,488][root][INFO] - Iteration 1: Elitist: 15.309384807110408
[2025-04-29 05:32:38,488][root][INFO] - Iteration 1 finished...
[2025-04-29 05:32:38,489][root][INFO] - Best obj: 15.309384807110408, Best Code Path: problem_iter1_code12.py
[2025-04-29 05:32:38,489][root][INFO] - LLM usage: prompt_tokens = 9708, completion_tokens = 17696
[2025-04-29 05:32:38,489][root][INFO] - Function Evals: 31
[2025-04-29 05:32:38,490][root][INFO] - Flash reflection Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.

User Prompt: 
### List heuristics
Below is a list of design heuristics ranked from best to worst.
[Heuristics 1st]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP edge selection, considering distance, demand, and vehicle capacity.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Demand of each node (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising each edge is (n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Start with inverse distance
    heuristics = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # Modify based on demand and proximity to depot
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops

            # Penalize edges that might overload vehicles
            avg_demand = (demands[i] + demands[j]) / 2
            if avg_demand > capacity / 3:  # Adjusted threshold
                heuristics[i, j] *= 0.5 # Moderate Penalization

            # Reward edges closer to the depot to encourage route starts near the depot
            depot_distance_penalty = 0.0
            depot_distance_penalty = (distance_matrix[0, i] + distance_matrix[0, j]) / (2 * np.mean(distance_matrix))

            heuristics[i, j] /= (1 + depot_distance_penalty)  # The closer to depot, the larger the divisor

            # Encourage edges leading away from the depot initially.
            # After the first vehicle visit some customers, it may return to the depot again.
            # Thus we focus more on connecting customers instead of returning depot.
            # initial_reward = np.exp(-distance_matrix[0,i] * distance_matrix[0,j]/(np.mean(distance_matrix)**2))
            # heuristics[i,j] *= (1 + initial_reward)

    # Normalize heuristics (optional, but can improve performance)
    heuristics = heuristics / np.max(heuristics)

    return heuristics

[Heuristics 2nd]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Calculate savings based on Clarke-Wright algorithm
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Incorporate distance and savings
    heuristic_matrix = (1 / distance_matrix + savings_matrix / np.max(savings_matrix)) #avoiding infs/NaNs

    # Penalize edges connecting to nodes with high demand relative to capacity
    demand_penalty = np.zeros(n)
    for i in range(1, n):
      demand_penalty[i] = demands[i] / capacity

    for i in range(n):
      for j in range(n):
        if i == j:
          heuristic_matrix[i, j] = 0 #ensure no loops
        else:
            heuristic_matrix[i,j] /= (1 + demand_penalty[i] + demand_penalty[j]) #slightly penalize high demand nodes

    #Prioritize connecting nodes that are close in coordinate space. This can help exploit locality.
    coordinate_distances = np.zeros_like(distance_matrix)
    for i in range(n):
      for j in range(n):
        coordinate_distances[i,j] = np.linalg.norm(coordinates[i] - coordinates[j])

    heuristic_matrix += (1/coordinate_distances) #prefer edges with small coordinate distance
    heuristic_matrix[np.isinf(heuristic_matrix)] = 0  # Remove any potential infinities created by division by zero on diagonals.
    heuristic_matrix[np.isnan(heuristic_matrix)] = 0 # Clean NaN values

    return heuristic_matrix

[Heuristics 3rd]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Calculate savings based on Clarke-Wright algorithm
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Incorporate distance and savings
    heuristic_matrix = (1 / distance_matrix + savings_matrix / np.max(savings_matrix)) #avoiding infs/NaNs

    # Penalize edges connecting to nodes with high demand relative to capacity
    demand_penalty = np.zeros(n)
    for i in range(1, n):
      demand_penalty[i] = demands[i] / capacity

    for i in range(n):
      for j in range(n):
        if i == j:
          heuristic_matrix[i, j] = 0 #ensure no loops
        else:
            heuristic_matrix[i,j] /= (1 + demand_penalty[i] + demand_penalty[j]) #slightly penalize high demand nodes

    #Prioritize connecting nodes that are close in coordinate space. This can help exploit locality.
    coordinate_distances = np.zeros_like(distance_matrix)
    for i in range(n):
      for j in range(n):
        coordinate_distances[i,j] = np.linalg.norm(coordinates[i] - coordinates[j])

    heuristic_matrix += (1/coordinate_distances) #prefer edges with small coordinate distance
    heuristic_matrix[np.isinf(heuristic_matrix)] = 0  # Remove any potential infinities created by division by zero on diagonals.
    heuristic_matrix[np.isnan(heuristic_matrix)] = 0 # Clean NaN values

    return heuristic_matrix

[Heuristics 4th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP) using a combination of distance, demand, and node proximity to depot.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters for tuning the heuristic (adjust as needed)
    distance_weight = 1.0  # Weight for distance
    demand_weight = 0.5    # Weight for demand (penalizes high demand)
    depot_proximity_weight = 0.2  # Weight for proximity to the depot

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
            else:
                # Heuristic based on a combination of factors
                distance_factor = distance_weight / (distance_matrix[i, j] + 1e-6)  # Avoid division by zero
                demand_factor = np.exp(-demand_weight * (demands[i] + demands[j]) / capacity)  # Penalize high demand
                depot_proximity_i = np.exp(-depot_proximity_weight * distance_matrix[i, 0] / np.mean(distance_matrix))
                depot_proximity_j = np.exp(-depot_proximity_weight * distance_matrix[j, 0] / np.mean(distance_matrix))
                depot_proximity_factor = (depot_proximity_i + depot_proximity_j) / 2  # average proximity

                heuristic_matrix[i, j] = distance_factor * demand_factor * depot_proximity_factor # Combine

    return heuristic_matrix

[Heuristics 5th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP using a combination of distance, demand, and angular considerations.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Edge prior indicators (n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Parameters to tune
    alpha = 1.0  # Distance weight
    beta = 0.5  # Demand weight
    gamma = 0.2  # Angular weight (relative to depot)

    # Calculate angles relative to the depot (node 0)
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
            else:
                # Distance component: inversely proportional to distance
                distance_component = 1 / distance_matrix[i, j]

                # Demand component: penalize edges connecting high-demand nodes (encourage balanced routes)
                demand_component = 1 / (demands[i] + demands[j] + 1e-6) #Adding a small value to avoid division by zero

                # Angular component: Favor edges that maintain angular progression from the depot.
                # Encourage exploration and avoid immediately returning to depot unless necessary.
                angle_diff = np.abs(angles[i] - angles[j])
                angular_component = 1 / (angle_diff + 0.1)  # Penalize large angle changes (smooth route transitions)
                if i==0:
                  angular_component=1 # always prioritize connection to depot

                # Combine components with weights
                heuristics[i, j] = (
                    alpha * distance_component
                    + beta * demand_component
                    + gamma * angular_component
                )

    return heuristics

[Heuristics 6th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for CVRP that considers distance, demand, and angle.

    Args:
        distance_matrix: Distance between nodes (n x n).
        coordinates: Euclidean coordinates of nodes (n x 2).
        demands: Demand of each node (n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of heuristics values (n x n), where higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Depot coordinates
    depot_x, depot_y = coordinates[0]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance-based heuristic (shorter distances are better)
            distance_heuristic = 1 / (distance_matrix[i, j] + 1e-6) #Adding a tiny constant to avoid divide by zero error

            # Demand-based heuristic (penalize connections to high-demand nodes early in the route)
            demand_penalty_i = demands[i] / capacity if i != 0 else 0 # i != 0 avoids dividing by zero
            demand_penalty_j = demands[j] / capacity if j != 0 else 0

            #Angle heuristic (try to keep angles smaller when leaving depot)
            angle_penalty = 1
            if i == 0:
                x_i, y_i = coordinates[i]
                x_j, y_j = coordinates[j]
                dx = x_j - x_i
                dy = y_j - y_i
                angle = np.arctan2(dy, dx)
                angle_penalty = 1 / (np.abs(angle)+1e-6) # Small angles better, adding constant for stability.

            heuristic_matrix[i, j] = distance_heuristic * (1 - demand_penalty_i) * (1 - demand_penalty_j) * angle_penalty


    return heuristic_matrix

[Heuristics 7th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Enhanced heuristic for CVRP considering distance, demand, and geometric properties.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Calculate a basic distance-based heuristic
    distance_heuristic = 1 / (distance_matrix + np.eye(n))  # Add identity to avoid division by zero on diagonal
    
    # Demand-based penalty.  Heavier demand makes longer paths less attractive.
    demand_penalty = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                demand_penalty[i, j] = (demands[i] + demands[j]) / capacity # Normalized combined demand
                
    # Geometric proximity factor: Favors edges that connect nodes close to each other in euclidean space.
    # But penalizes connection to depot for high demands.
    proximity_factor = np.zeros_like(distance_matrix)
    center = np.mean(coordinates, axis=0) # Center of all nodes.

    for i in range(n):
        for j in range(n):
            if i != j:
                dist_to_center_i = np.linalg.norm(coordinates[i] - center)
                dist_to_center_j = np.linalg.norm(coordinates[j] - center)
                proximity_factor[i, j] = 1 / (dist_to_center_i + dist_to_center_j + 1e-6) # Add epsilon to avoid division by zero.

                if i == 0 or j == 0: #Depot connection. Penalize connections to the depot if either node connected has high demand.
                    proximity_factor[i,j] *= (1- (demands[i] + demands[j])/ (2*capacity)) #Reduced importance of connection when demand of other nodes are high. Max reduction of 50%.



    # Combine the heuristics, weighing distance more. and then slightly adjust by proximity factor and demand.
    heuristic_matrix = distance_heuristic * (1 - 0.5 * demand_penalty) + 0.25 * proximity_factor

    return heuristic_matrix

[Heuristics 8th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Enhanced heuristic for CVRP considering distance, demand, and geometric properties.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Calculate a basic distance-based heuristic
    distance_heuristic = 1 / (distance_matrix + np.eye(n))  # Add identity to avoid division by zero on diagonal
    
    # Demand-based penalty.  Heavier demand makes longer paths less attractive.
    demand_penalty = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                demand_penalty[i, j] = (demands[i] + demands[j]) / capacity # Normalized combined demand
                
    # Geometric proximity factor: Favors edges that connect nodes close to each other in euclidean space.
    # But penalizes connection to depot for high demands.
    proximity_factor = np.zeros_like(distance_matrix)
    center = np.mean(coordinates, axis=0) # Center of all nodes.

    for i in range(n):
        for j in range(n):
            if i != j:
                dist_to_center_i = np.linalg.norm(coordinates[i] - center)
                dist_to_center_j = np.linalg.norm(coordinates[j] - center)
                proximity_factor[i, j] = 1 / (dist_to_center_i + dist_to_center_j + 1e-6) # Add epsilon to avoid division by zero.

                if i == 0 or j == 0: #Depot connection. Penalize connections to the depot if either node connected has high demand.
                    proximity_factor[i,j] *= (1- (demands[i] + demands[j])/ (2*capacity)) #Reduced importance of connection when demand of other nodes are high. Max reduction of 50%.



    # Combine the heuristics, weighing distance more. and then slightly adjust by proximity factor and demand.
    heuristic_matrix = distance_heuristic * (1 - 0.5 * demand_penalty) + 0.25 * proximity_factor

    return heuristic_matrix

[Heuristics 9th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Improved heuristics for CVRP incorporating distance, demand, and angle.

    Args:
        distance_matrix: Distance matrix between nodes.
        coordinates: Euclidean coordinates of nodes.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        Heuristic matrix indicating the desirability of each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters for tuning the heuristics
    distance_importance = 1.0
    demand_importance = 0.5
    angle_importance = 0.2

    depot_index = 0

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance component: Inverse of distance
            distance_heuristic = 1 / distance_matrix[i, j] if distance_matrix[i, j] > 0 else 0

            # Demand component: Penalize edges leading to high-demand nodes
            demand_heuristic = 1 - (demands[j] / capacity) if demands[j] < capacity else 0

            # Angle component: Favor nodes in a forward direction from the depot.
            # Calculate the angle between the vector from i to j and the vector from the depot to j.
            vector_ij = coordinates[j] - coordinates[i]
            vector_dj = coordinates[j] - coordinates[depot_index]

            # Normalize vectors to handle cases when i or depot_index equals to j
            norm_ij = np.linalg.norm(vector_ij)
            norm_dj = np.linalg.norm(vector_dj)

            if norm_ij > 0 and norm_dj > 0:
                cos_angle = np.dot(vector_ij, vector_dj) / (norm_ij * norm_dj)
                # Clip cosine values to avoid potential errors in arccos
                cos_angle = np.clip(cos_angle, -1.0, 1.0)
                angle = np.arccos(cos_angle) # Angle in radians
            else:
                angle = np.pi / 2 # Default value

            # The angle component
            angle_heuristic = 1 - (angle / np.pi) # Normalize angle to [0, 1]

            # Combine the heuristics
            heuristic_matrix[i, j] = (
                distance_importance * distance_heuristic +
                demand_importance * demand_heuristic +
                angle_importance * angle_heuristic
            )

    return heuristic_matrix

[Heuristics 10th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several factors to estimate the desirability of including
    an edge in a route, going beyond a simple inverse distance.  It considers:

    1. Distance: Shorter distances are preferred (inverse relationship).
    2. Demand Compatibility: Edges connecting nodes that, when combined with the
       current route's load, are less likely to violate capacity constraints are
       preferred.
    3. Angle: Edges forming sharper turns are penalized, as they often lead to less
       efficient routes.  This is done by computing the angle between potential edges
       and penalizing sharp turns.
    4. Closeness to Depot: Edges closer to the depot are generally favored, especially
       when near capacity, to facilitate returns to the depot.

    Args:
        distance_matrix: Distance matrix (n x n).
        coordinates: Node coordinates (n x 2).
        demands: Node demands (n).
        capacity: Vehicle capacity.

    Returns:
        Heuristic matrix (n x n) indicating the desirability of each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Add a small constant to the distance matrix to avoid division by zero
    distance_matrix = distance_matrix + 1e-9  # Avoid division by zero

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # 1. Distance-based heuristic (inverse distance)
            distance_heuristic = 1 / distance_matrix[i, j]

            # 2. Demand-based heuristic (penalize edges likely to cause capacity violations)
            demand_penalty = (demands[i] + demands[j]) / (2 * capacity) # Normalize to a penalty factor around 1
            demand_heuristic = max(0, 1 - demand_penalty) # Scales to between 0-1
            

            # 3. Angle-based heuristic (penalize sharp turns)
            #   - Approximate by considering depot as the previous node for now.
            #   - Can be improved by keeping track of the actual route as it's built
            if i == 0:
                angle_heuristic = 1.0 #No turn
            else:
                # vector from depot to node i and node i to node j
                vector1 = coordinates[i] - coordinates[0]
                vector2 = coordinates[j] - coordinates[i]

                # Calculate the cosine of the angle between the vectors
                norm1 = np.linalg.norm(vector1)
                norm2 = np.linalg.norm(vector2)

                if norm1 > 0 and norm2 > 0:
                    cos_angle = np.dot(vector1, vector2) / (norm1 * norm2)
                    # Clip cosine to [-1, 1] to avoid potential errors
                    cos_angle = np.clip(cos_angle, -1.0, 1.0)
                    angle = np.arccos(cos_angle)  # Angle in radians
                    angle_penalty = angle / np.pi  # Normalize to a penalty factor between 0 and 1. Sharp turn is 1, straight line is 0
                    angle_heuristic = max(0, 1-angle_penalty)
                else:
                    angle_heuristic = 0.5 # Default penalty



            # 4. Depot Proximity
            depot_distance = distance_matrix[i,0] + distance_matrix[j,0]
            depot_proximity = np.exp(-depot_distance/np.mean(distance_matrix)) # Bias shorter total distance from i & j to depot



            # Combine the heuristics (weighted sum) - EXPERIMENTAL
            heuristic_matrix[i, j] = (
                0.4 * distance_heuristic +
                0.3 * demand_heuristic +
                0.2 * angle_heuristic +
                0.1 * depot_proximity
            )

    return heuristic_matrix

[Heuristics 11th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for CVRP using a combination of distance, demand, and angular considerations.

    Args:
        distance_matrix: Distance matrix between nodes.
        coordinates: Coordinates of nodes.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        A matrix of heuristics values, indicating the desirability of each edge.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Heuristic components:
    # 1. Distance-based: Shorter distances are preferred.  Adjusted by capacity.
    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Avoid division by zero

    # 2. Demand-based:  Penalize edges connecting to nodes that would easily saturate vehicle capacity.
    demand_penalty = np.zeros((n,n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_penalty[i, j] = 0  # Avoid self-loops.
            else:
                # Probability of exceeding capacity by going to j directly from depot
                demand_prob_i = demands[i]/capacity if i != 0 else 0
                demand_prob_j = demands[j]/capacity if j != 0 else 0
                demand_penalty[i, j] = min(demand_prob_i + demand_prob_j,1)
    demand_heuristic = 1 - demand_penalty

    # 3. Angular-based:  Prefer routes that are less likely to cause sharp turns. Helps to explore diverse routes

    depot_x, depot_y = coordinates[0]  # Depot location
    angular_heuristic = np.zeros((n, n))

    for i in range(n):
        for j in range(n):
            if i != j:
                 #calculate angle between vector depot-i and depot-j.
                x_i, y_i = coordinates[i]
                x_j, y_j = coordinates[j]

                vector_i = np.array([x_i - depot_x, y_i - depot_y])
                vector_j = np.array([x_j - depot_x, y_j - depot_y])

                # Dot product to calculate angle
                dot_product = np.dot(vector_i, vector_j)
                magnitude_i = np.linalg.norm(vector_i)
                magnitude_j = np.linalg.norm(vector_j)
                if (magnitude_i == 0 or magnitude_j == 0):
                    angle_radians = 0.0  # Assign 0 if either vector is zero
                else:
                     angle_radians = np.arccos(dot_product / (magnitude_i * magnitude_j)) #Angle in radians.

                angular_heuristic[i,j] = 1 - np.abs(angle_radians) / np.pi # Normalise the angle



    # Combine the heuristics: weighted sum.
    alpha = 0.5  # Weight for distance
    beta = 0.3   # Weight for demand
    gamma = 0.2 # Weight for angle
    heuristics = alpha * distance_heuristic + beta * demand_heuristic + gamma * angular_heuristic

    # Ensure no self-loops:
    for i in range(n):
        heuristics[i, i] = 0

    return heuristics

[Heuristics 12th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for CVRP using a combination of distance, demand, and angular considerations.

    Args:
        distance_matrix: Distance matrix between nodes.
        coordinates: Coordinates of nodes.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        A matrix of heuristics values, indicating the desirability of each edge.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Heuristic components:
    # 1. Distance-based: Shorter distances are preferred.  Adjusted by capacity.
    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Avoid division by zero

    # 2. Demand-based:  Penalize edges connecting to nodes that would easily saturate vehicle capacity.
    demand_penalty = np.zeros((n,n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_penalty[i, j] = 0  # Avoid self-loops.
            else:
                # Probability of exceeding capacity by going to j directly from depot
                demand_prob_i = demands[i]/capacity if i != 0 else 0
                demand_prob_j = demands[j]/capacity if j != 0 else 0
                demand_penalty[i, j] = min(demand_prob_i + demand_prob_j,1)
    demand_heuristic = 1 - demand_penalty

    # 3. Angular-based:  Prefer routes that are less likely to cause sharp turns. Helps to explore diverse routes

    depot_x, depot_y = coordinates[0]  # Depot location
    angular_heuristic = np.zeros((n, n))

    for i in range(n):
        for j in range(n):
            if i != j:
                 #calculate angle between vector depot-i and depot-j.
                x_i, y_i = coordinates[i]
                x_j, y_j = coordinates[j]

                vector_i = np.array([x_i - depot_x, y_i - depot_y])
                vector_j = np.array([x_j - depot_x, y_j - depot_y])

                # Dot product to calculate angle
                dot_product = np.dot(vector_i, vector_j)
                magnitude_i = np.linalg.norm(vector_i)
                magnitude_j = np.linalg.norm(vector_j)
                if (magnitude_i == 0 or magnitude_j == 0):
                    angle_radians = 0.0  # Assign 0 if either vector is zero
                else:
                     angle_radians = np.arccos(dot_product / (magnitude_i * magnitude_j)) #Angle in radians.

                angular_heuristic[i,j] = 1 - np.abs(angle_radians) / np.pi # Normalise the angle



    # Combine the heuristics: weighted sum.
    alpha = 0.5  # Weight for distance
    beta = 0.3   # Weight for demand
    gamma = 0.2 # Weight for angle
    heuristics = alpha * distance_heuristic + beta * demand_heuristic + gamma * angular_heuristic

    # Ensure no self-loops:
    for i in range(n):
        heuristics[i, i] = 0

    return heuristics

[Heuristics 13th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A more sophisticated heuristics function for CVRP.  It considers distance,
    demand, and angular relationships between nodes to estimate the desirability
    of including an edge in a route.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Normalize demands for scaling purposes.  Avoid division by zero.
    max_demand = np.max(demands)
    normalized_demands = demands / max_demand if max_demand > 0 else np.zeros_like(demands)


    # Depot location
    depot_x, depot_y = coordinates[0]


    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            distance = distance_matrix[i, j]
            if distance == 0:
                heuristic_matrix[i, j] = 0 #Avoid divide by zero, same point
                continue

            # Base heuristic: inverse of distance
            heuristic = 1 / distance

            # Demand factor:  Less desirable to link high-demand nodes directly
            # unless it is to the depot.
            demand_penalty = normalized_demands[i] + normalized_demands[j]

            if i!= 0 and j != 0:
               heuristic /= (1 + demand_penalty)

            # Angular component:  Penalize sharp turns. Nodes should be added more favorably
            #   in similar directions to the depot. This is only relevant if
            #   neither node is the depot itself

            if i != 0 and j != 0:

                angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)
                angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)

                angle_diff = np.abs(angle_i - angle_j)
                angle_diff = np.minimum(angle_diff, 2 * np.pi - angle_diff)  # Ensure the smaller angle is used

                # Penalize edges where the nodes have very different angles from the depot.
                # Higher values indicate angles are very different so penalty is increased.
                angle_penalty = (angle_diff / np.pi)**2
                heuristic /= (1+angle_penalty)


            heuristic_matrix[i, j] = heuristic

    return heuristic_matrix

[Heuristics 14th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates distance, demand, and depot proximity for edge prioritization.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Vector of customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).
    """

    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Avoid self-loops
    for i in range(n):
        heuristics_matrix[i, i] = 0

    for i in range(n):
        for j in range(n):
            if i != j:
                # Base heuristic: inverse of distance
                distance_heuristic = 1 / (distance_matrix[i, j] + 1e-9) # Adding a small constant to avoid division by zero

                # Demand-based heuristic:  discourage connecting nodes whose combined demand significantly exceeds capacity when starting from the depot.
                demand_heuristic = 1.0
                if i == 0:  # Penalize high demands *starting* from the depot.
                    if demands[j] > capacity/2: #heuristically chosen threshold to penalize *starting* from depot
                        demand_heuristic = 0.1 #drastically reduce the indicator if demand is high
                else:
                   demand_heuristic = 1 #Neutralize demand_heuristic.  Important, because the depot condition strongly steers routes toward the depot.


                # Depot proximity heuristic: Favor edges closer to the depot, especially for initiating routes (starting at the depot)
                depot_proximity_i = distance_matrix[0, i]
                depot_proximity_j = distance_matrix[0, j]
                depot_proximity_heuristic = 1 / ((depot_proximity_i + depot_proximity_j)/2 + 1e-9)  #Avoid divide by zero

                # Combined heuristic (weighted sum - weights can be tuned)
                heuristics_matrix[i, j] = (0.6 * distance_heuristic +
                                             0.2 * demand_heuristic +
                                             0.2 * depot_proximity_heuristic)

    return heuristics_matrix

[Heuristics 15th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP) that considers
    distance, demand, and proximity to the depot.

    Args:
        distance_matrix: A numpy array of shape (n, n) representing the distances
                         between each pair of nodes.
        coordinates: A numpy array of shape (n, 2) representing the Euclidean coordinates
                     of each node.
        demands: A numpy array of shape (n,) representing the demand of each node.
        capacity: An integer representing the capacity of each vehicle.

    Returns:
        A numpy array of shape (n, n) representing the prior indicators of how
        promising it is to include each edge in a solution.  Higher values indicate
        more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Heuristic 1: Inverse of distance
    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero

    # Heuristic 2: Demand-based adjustment.  Edges connecting to nodes with high demand
    # are penalized if they are far from the depot.
    depot_distances = distance_matrix[0, :]  # Distances from the depot to all nodes
    demand_heuristic = np.zeros((n, n))
    for i in range(1, n):  # Skip depot (index 0)
        for j in range(1, n):
            if i != j:
                demand_heuristic[i, j] = (capacity / (demands[i] + demands[j] + 1e-6)) * (1/(depot_distances[i]+ depot_distances[j] +1e-6)) #Nodes close to the depot more likely to be used

    # Heuristic 3: Combination of distance and demand, prioritize the close distance to depot
    proximity_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                proximity_heuristic[i, j] = 1/ (distance_matrix[i,j]+ depot_distances[i]+ depot_distances[j]+ 1e-6)


    # Combine the heuristics
    heuristic_matrix = 0.5 * distance_heuristic + 0.25 * demand_heuristic + 0.25 * proximity_heuristic


    # Ensure the depot node (0) is always a good starting point, boost edges connected to the depot
    for i in range(1, n):
          heuristic_matrix[0, i] = heuristic_matrix[0, i] * 1.5
          heuristic_matrix[i, 0] = heuristic_matrix[i, 0] * 1.5



    return heuristic_matrix

[Heuristics 16th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and node proximity to the depot.

    This heuristic considers the following factors:
    1. Distance between nodes: Shorter distances are preferred.
    2. Demand of the target node:  Penalizes edges leading to high-demand nodes.
    3. Proximity to the depot: Encourages routes to start and end near the depot,
       and penalizes routes going far away from the depot without returning.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Node coordinates (n x 2).
        demands (np.ndarray): Node demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Edge prior indicators (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Depot coordinates
    depot_x, depot_y = coordinates[0]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # Avoid self-loops
                continue

            distance = distance_matrix[i, j]
            demand = demands[j]

            # Distance factor: inversely proportional to distance
            distance_factor = 1 / (distance + 1e-6)  # Avoid division by zero

            # Demand factor: penalize high-demand nodes
            demand_factor = 1 / (demand / capacity + 1e-6) if demand > 0 else 1.0 #avoid divide by zero, demand is 0 at depot.

            # Proximity to depot factor: encourage starting/ending near the depot
            # Euclidean distance to the depot
            dist_i_to_depot = np.sqrt((coordinates[i, 0] - depot_x)**2 + (coordinates[i, 1] - depot_y)**2)
            dist_j_to_depot = np.sqrt((coordinates[j, 0] - depot_x)**2 + (coordinates[j, 1] - depot_y)**2)
            
            # Penalize going far without returning - gives a very small score, i.e., highly discouraged.
            depot_factor = 1 / (dist_i_to_depot + dist_j_to_depot + 1e-6) #avoid divide by zero

            # Combine the factors (weighted combination)
            heuristic_matrix[i, j] = (0.6 * distance_factor + 0.3 * demand_factor + 0.1 * depot_factor)
            # Small adjustment to favor edges connected to depot
            if i == 0 or j == 0:
                heuristic_matrix[i, j] *= 1.2

    return heuristic_matrix

[Heuristics 17th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and depot proximity.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes.
        coordinates (np.ndarray): Coordinates of each node.
        demands (np.ndarray): Demand of each node.
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Edge weights indicating the desirability of each edge.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Inverse distance component (closer nodes are preferred)
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # Demand-aware component: penalize edges that would overload vehicles
    demand_penalty = np.ones_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                if demands[i] + demands[j] > capacity:
                    demand_penalty[i, j] = 0.1  # Heavily penalize if combined demand exceeds capacity significantly

    # Depot proximity component: favor edges near the depot to promote returns
    depot_proximity = np.zeros_like(distance_matrix)
    for i in range(1, n):
        depot_proximity[0, i] = 1 / (distance_matrix[0, i] + 1e-9) # Favor shorter path to depot
        depot_proximity[i, 0] = 1 / (distance_matrix[i, 0] + 1e-9)


    # Combined heuristic: balance distance, demand, and depot proximity
    heuristics = inverse_distance * demand_penalty + depot_proximity

    # Normalize the heuristic values
    heuristics = heuristics / np.max(heuristics)

    return heuristics

[Heuristics 18th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This function calculates prior indicators of how promising it is to include each edge in a solution.
    It considers distance, demand, and proximity to the depot.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of edge inclusion (shape: n by n).
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Parameters for tuning the heuristics
    alpha = 1.0   # Weight for distance
    beta = 0.5    # Weight for demand
    gamma = 0.2   # Weight for depot proximity
    delta = 0.1 # Weight for demand distance similarity

    # Calculate depot distances
    depot_distances = distance_matrix[0, :]

    # Normalize demands
    normalized_demands = demands / capacity

    for i in range(n):
        for j in range(n):
            if i != j:  # Avoid self-loops
                # Distance component: encourage shorter edges
                distance_component = alpha / distance_matrix[i, j]

                # Demand component: penalize edges connecting nodes that would exceed capacity easily
                demand_component = beta * (1 - (normalized_demands[i] + normalized_demands[j]))
                demand_component = max(0, demand_component)  # Ensure non-negativity

                # Depot proximity component: encourage edges closer to the depot
                depot_proximity_component = gamma * (1 - (depot_distances[i] + depot_distances[j]) / (2 * np.max(depot_distances)))

                # Demand distance similarity component: prioritize edges connecting similar demands
                demand_distance = abs(demands[i] - demands[j])
                demand_distance_component = delta * (1 / (demand_distance + 1e-6))


                # Combine the components
                heuristics[i, j] = distance_component + demand_component + depot_proximity_component + demand_distance_component
            else:
                heuristics[i, j] = 0  # No self-loops

    return heuristics

[Heuristics 19th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates distance, demand, and angle considerations to guide edge selection.

    Args:
        distance_matrix: Distance matrix between nodes (shape: n x n).
        coordinates: Euclidean coordinates of nodes (shape: n x 2).
        demands: Demand of each node (shape: n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of the same shape as distance_matrix, indicating the attractiveness of each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (can be tuned)
    alpha = 1.0  # Weight for distance
    beta = 1.0   # Weight for demand
    gamma = 1.0  # Weight for angle
    delta = 1.0  # Weight for capacity slack


    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor: Shorter distances are more attractive
                distance_factor = alpha / distance_matrix[i, j]

                # Demand factor: Prefer nodes with demands that fit well within vehicle capacity
                demand_factor = beta / (demands[j] + 1e-6) # Add small value to avoid division by zero

                # Angle factor: Penalize sharp turns
                if i == 0:  # Depot case - angle is less relevant
                    angle_factor = 1.0
                else:
                    # Compute angles
                    vector_ij = coordinates[j] - coordinates[i]
                    vector_0i = coordinates[i] - coordinates[0]  # Depot at node 0

                    # Normalize vectors to get cosine
                    norm_ij = np.linalg.norm(vector_ij)
                    norm_0i = np.linalg.norm(vector_0i)

                    if norm_ij > 0 and norm_0i > 0:
                         cos_angle = np.dot(vector_ij, vector_0i) / (norm_ij * norm_0i)
                         # Map cosine (-1 to 1) to a score (0 to 1), higher is better
                         angle_factor = gamma * (cos_angle + 1) / 2
                    else:
                         angle_factor = gamma # Avoid zero norm case
                # Capacity slack factor: Higher slack is more desirable for exploration
                capacity_slack_factor = delta # Initialize
                # Consider current node i and potential next node j, if node i is the depot, then consider only j's demand
                if i==0:
                  capacity_slack_factor = delta * np.exp(-demands[j] / capacity)
                else:
                   capacity_slack_factor = delta

                # Combine factors to create the heuristic value
                heuristic_matrix[i, j] = distance_factor + demand_factor + angle_factor + capacity_slack_factor

    return heuristic_matrix

[Heuristics 20th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates distance, demand, and angle considerations to guide edge selection.

    Args:
        distance_matrix: Distance matrix between nodes (shape: n x n).
        coordinates: Euclidean coordinates of nodes (shape: n x 2).
        demands: Demand of each node (shape: n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of the same shape as distance_matrix, indicating the attractiveness of each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (can be tuned)
    alpha = 1.0  # Weight for distance
    beta = 1.0   # Weight for demand
    gamma = 1.0  # Weight for angle
    delta = 1.0  # Weight for capacity slack


    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor: Shorter distances are more attractive
                distance_factor = alpha / distance_matrix[i, j]

                # Demand factor: Prefer nodes with demands that fit well within vehicle capacity
                demand_factor = beta / (demands[j] + 1e-6) # Add small value to avoid division by zero

                # Angle factor: Penalize sharp turns
                if i == 0:  # Depot case - angle is less relevant
                    angle_factor = 1.0
                else:
                    # Compute angles
                    vector_ij = coordinates[j] - coordinates[i]
                    vector_0i = coordinates[i] - coordinates[0]  # Depot at node 0

                    # Normalize vectors to get cosine
                    norm_ij = np.linalg.norm(vector_ij)
                    norm_0i = np.linalg.norm(vector_0i)

                    if norm_ij > 0 and norm_0i > 0:
                         cos_angle = np.dot(vector_ij, vector_0i) / (norm_ij * norm_0i)
                         # Map cosine (-1 to 1) to a score (0 to 1), higher is better
                         angle_factor = gamma * (cos_angle + 1) / 2
                    else:
                         angle_factor = gamma # Avoid zero norm case
                # Capacity slack factor: Higher slack is more desirable for exploration
                capacity_slack_factor = delta # Initialize
                # Consider current node i and potential next node j, if node i is the depot, then consider only j's demand
                if i==0:
                  capacity_slack_factor = delta * np.exp(-demands[j] / capacity)
                else:
                   capacity_slack_factor = delta

                # Combine factors to create the heuristic value
                heuristic_matrix[i, j] = distance_factor + demand_factor + angle_factor + capacity_slack_factor

    return heuristic_matrix


### Guide
- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.
- The response in Markdown style and nothing else has the following structure:
"**Analysis:**
**Experience:**"
In there:
+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.
Example: "Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:"

+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).

I'm going to tip $999K for a better heuristics! Let's think step by step.
[2025-04-29 05:32:38,503][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:32:44,292][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:32:44,295][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:32:44,297][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:44,297][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:44,300][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:44,323][root][INFO] - Comprehensive reflection Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.

User Prompt: 
Your task is to redefine 'Current self-reflection' paying attention to avoid all things in 'Ineffective self-reflection' in order to come up with ideas to design better heuristics.

### Current self-reflection
Start with a simple, intuitive heuristic (e.g., inverse distance). Gradually incorporate additional factors like demand and depot proximity. Use normalization techniques and avoid over-complex combinations or excessively specific calculations (e.g., Clarke-Wright savings, complex angular penalties). Weights may not be helpful.
None

### Ineffective self-reflection
None

Response (<100 words) should have 4 bullet points: Keywords, Advice, Avoid, Explanation.
I'm going to tip $999K for a better heuristics! Let's think step by step.
[2025-04-29 05:32:44,324][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:32:47,268][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:32:47,270][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:32:47,271][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:47,271][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:47,273][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:47,279][root][INFO] - Crossover Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.


### Better code
def heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    Heuristics for CVRP using a combination of distance, demand, and angular considerations.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Edge prior indicators (n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Parameters to tune
    alpha = 1.0  # Distance weight
    beta = 0.5  # Demand weight
    gamma = 0.2  # Angular weight (relative to depot)

    # Calculate angles relative to the depot (node 0)
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
            else:
                # Distance component: inversely proportional to distance
                distance_component = 1 / distance_matrix[i, j]

                # Demand component: penalize edges connecting high-demand nodes (encourage balanced routes)
                demand_component = 1 / (demands[i] + demands[j] + 1e-6) #Adding a small value to avoid division by zero

                # Angular component: Favor edges that maintain angular progression from the depot.
                # Encourage exploration and avoid immediately returning to depot unless necessary.
                angle_diff = np.abs(angles[i] - angles[j])
                angular_component = 1 / (angle_diff + 0.1)  # Penalize large angle changes (smooth route transitions)
                if i==0:
                  angular_component=1 # always prioritize connection to depot

                # Combine components with weights
                heuristics[i, j] = (
                    alpha * distance_component
                    + beta * demand_component
                    + gamma * angular_component
                )

    return heuristics

### Worse code
def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several factors to estimate the desirability of including
    an edge in a route, going beyond a simple inverse distance.  It considers:

    1. Distance: Shorter distances are preferred (inverse relationship).
    2. Demand Compatibility: Edges connecting nodes that, when combined with the
       current route's load, are less likely to violate capacity constraints are
       preferred.
    3. Angle: Edges forming sharper turns are penalized, as they often lead to less
       efficient routes.  This is done by computing the angle between potential edges
       and penalizing sharp turns.
    4. Closeness to Depot: Edges closer to the depot are generally favored, especially
       when near capacity, to facilitate returns to the depot.

    Args:
        distance_matrix: Distance matrix (n x n).
        coordinates: Node coordinates (n x 2).
        demands: Node demands (n).
        capacity: Vehicle capacity.

    Returns:
        Heuristic matrix (n x n) indicating the desirability of each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Add a small constant to the distance matrix to avoid division by zero
    distance_matrix = distance_matrix + 1e-9  # Avoid division by zero

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # 1. Distance-based heuristic (inverse distance)
            distance_heuristic = 1 / distance_matrix[i, j]

            # 2. Demand-based heuristic (penalize edges likely to cause capacity violations)
            demand_penalty = (demands[i] + demands[j]) / (2 * capacity) # Normalize to a penalty factor around 1
            demand_heuristic = max(0, 1 - demand_penalty) # Scales to between 0-1
            

            # 3. Angle-based heuristic (penalize sharp turns)
            #   - Approximate by considering depot as the previous node for now.
            #   - Can be improved by keeping track of the actual route as it's built
            if i == 0:
                angle_heuristic = 1.0 #No turn
            else:
                # vector from depot to node i and node i to node j
                vector1 = coordinates[i] - coordinates[0]
                vector2 = coordinates[j] - coordinates[i]

                # Calculate the cosine of the angle between the vectors
                norm1 = np.linalg.norm(vector1)
                norm2 = np.linalg.norm(vector2)

                if norm1 > 0 and norm2 > 0:
                    cos_angle = np.dot(vector1, vector2) / (norm1 * norm2)
                    # Clip cosine to [-1, 1] to avoid potential errors
                    cos_angle = np.clip(cos_angle, -1.0, 1.0)
                    angle = np.arccos(cos_angle)  # Angle in radians
                    angle_penalty = angle / np.pi  # Normalize to a penalty factor between 0 and 1. Sharp turn is 1, straight line is 0
                    angle_heuristic = max(0, 1-angle_penalty)
                else:
                    angle_heuristic = 0.5 # Default penalty



            # 4. Depot Proximity
            depot_distance = distance_matrix[i,0] + distance_matrix[j,0]
            depot_proximity = np.exp(-depot_distance/np.mean(distance_matrix)) # Bias shorter total distance from i & j to depot



            # Combine the heuristics (weighted sum) - EXPERIMENTAL
            heuristic_matrix[i, j] = (
                0.4 * distance_heuristic +
                0.3 * demand_heuristic +
                0.2 * angle_heuristic +
                0.1 * depot_proximity
            )

    return heuristic_matrix

### Analyze & experience
- Comparing (1st) vs (2nd), we see that the 1st heuristic focuses on simplicity, using inverse distance modified by demand and depot proximity, while the 2nd incorporates the Clarke-Wright savings algorithm and coordinate distances. The 2nd also normalizes savings. Overall, the 1st heuristics seems to be more straightforward.

Comparing (2nd best) vs (second worst), we see heuristic 2nd includes savings calculations from Clarke-Wright and also coordinate distance. The 19th makes use of angle and capacity slack. These factors might be too specific or not generally effective, potentially overfitting to certain problem instances. Heuristic 2nd normalizes savings by dividing by `np.max(savings_matrix)`. This appears to be important.

Comparing (1st) vs (3rd), we see that they are different.

Comparing (3rd) vs (4th), the 3rd is identical to the 2nd, but the 4th uses weights for distance, demand, and depot proximity, also using exponential functions for demand and proximity. The use of tunable weights may not be enough.

Comparing (second worst) vs (worst), 19th vs 20th is identical. Perhaps it wasn't possible to improve on the bad designs.

Overall: The better heuristics generally balance simplicity with relevant factors (distance, demand, depot proximity) without over-engineering. Normalization is important. Angular considerations, while intuitive, may not always improve performance. Overly complex combinations of factors can also hinder performance.
- - Try combining various factors to determine how promising it is to select an edge.
- Try sparsifying the matrix by setting unpromising elements to zero.
Okay, I understand. Let's redefine "Current Self-Reflection" for better heuristic design, focusing on actionable steps and avoiding common pitfalls.

Here's a breakdown:

*   **Keywords:** Iterative refinement, factor incorporation, normalization, simplicity, adaptability.

*   **Advice:** Begin with a clear, basic heuristic. Systematically add factors (demand, depot proximity, etc.) one at a time, evaluating the impact of each addition on performance.

*   **Avoid:** Over-engineered formulas, premature optimization, overly specific parameters, complex interactions without empirical justification.

*   **Explanation:** Emphasize incremental improvements and data-driven decisions. Simple, adaptable heuristics are easier to understand, debug, and modify, ultimately leading to more robust solutions.


Your task is to write an improved function `heuristics_v2` by COMBINING elements of two above heuristics base Analyze & experience.
Output the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.

I'm going to tip $999K for a better heuristics! Let's think step by step.
[2025-04-29 05:32:47,307][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:32:47,308][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:32:50,895][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:32:50,896][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:32:50,897][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:50,897][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:50,898][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:32:50,899][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:51,021][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:32:51,022][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:32:51,023][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:51,023][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:51,024][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:32:51,024][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:54,258][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:32:54,261][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:32:54,262][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:54,263][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:54,264][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:32:54,266][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:55,714][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:32:55,717][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:32:55,719][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:55,719][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:55,721][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:32:55,723][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:58,804][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:32:58,806][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:32:58,808][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:58,808][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:58,810][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:32:58,812][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:59,119][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:32:59,120][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:32:59,121][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:59,121][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:32:59,122][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:32:59,122][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:33:02,124][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:33:02,127][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:33:02,128][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:33:02,129][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:33:02,130][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:33:02,132][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:33:02,816][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:33:02,819][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:33:02,820][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:33:02,821][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:33:02,823][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:33:02,825][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:33:05,990][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:33:05,993][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:33:05,994][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:33:05,995][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:33:05,997][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:33:07,790][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:33:07,792][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:33:07,793][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:33:07,793][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:33:07,794][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:33:07,826][root][INFO] - Iteration 2: Running Code 0
[2025-04-29 05:33:13,712][root][INFO] - Iteration 2: Code Run 0 successful!
[2025-04-29 05:33:13,712][root][INFO] - Iteration 2: Running Code 1
[2025-04-29 05:33:20,608][root][INFO] - Iteration 2: Code Run 1 successful!
[2025-04-29 05:33:20,608][root][INFO] - Iteration 2: Running Code 2
[2025-04-29 05:33:28,589][root][INFO] - Iteration 2: Code Run 2 successful!
[2025-04-29 05:33:28,589][root][INFO] - Iteration 2: Running Code 3
[2025-04-29 05:33:36,895][root][INFO] - Iteration 2: Code Run 3 successful!
[2025-04-29 05:33:36,895][root][INFO] - Iteration 2: Running Code 4
[2025-04-29 05:33:46,060][root][INFO] - Iteration 2: Code Run 4 successful!
[2025-04-29 05:33:46,060][root][INFO] - Iteration 2: Running Code 5
[2025-04-29 05:33:55,994][root][INFO] - Iteration 2: Code Run 5 successful!
[2025-04-29 05:33:55,994][root][INFO] - Iteration 2: Running Code 6
[2025-04-29 05:34:06,243][root][INFO] - Iteration 2: Code Run 6 successful!
[2025-04-29 05:34:06,243][root][INFO] - Iteration 2: Running Code 7
[2025-04-29 05:34:16,651][root][INFO] - Iteration 2: Code Run 7 successful!
[2025-04-29 05:34:16,651][root][INFO] - Iteration 2: Running Code 8
[2025-04-29 05:34:28,241][root][INFO] - Iteration 2: Code Run 8 successful!
[2025-04-29 05:34:28,242][root][INFO] - Iteration 2: Running Code 9
[2025-04-29 05:34:39,832][root][INFO] - Iteration 2: Code Run 9 successful!
[2025-04-29 05:34:39,845][root][INFO] - Iteration 2, response_id 0: Objective value: 18.78665439767729
[2025-04-29 05:34:39,858][root][INFO] - Iteration 2, response_id 1: Objective value: 18.212851377381742
[2025-04-29 05:35:06,156][root][INFO] - Iteration 2, response_id 2: Objective value: 19.80458822389557
[2025-04-29 05:35:18,378][root][INFO] - Iteration 2, response_id 3: Objective value: 19.093768467069673
[2025-04-29 05:35:32,380][root][INFO] - Iteration 2, response_id 4: Objective value: 20.168602868428152
[2025-04-29 05:35:45,731][root][INFO] - Iteration 2, response_id 5: Objective value: 20.72906398938542
[2025-04-29 05:35:46,081][root][INFO] - Iteration 2, response_id 6: Objective value: 19.65212284294969
[2025-04-29 05:35:51,999][root][INFO] - Iteration 2, response_id 7: Objective value: 20.359871373957493
[2025-04-29 05:35:52,389][root][INFO] - Iteration 2, response_id 8: Objective value: 21.45996852115022
[2025-04-29 05:35:54,995][root][INFO] - Iteration 2, response_id 9: Objective value: 18.82012618989734
[2025-04-29 05:35:54,996][root][INFO] - Iteration 2 finished...
[2025-04-29 05:35:54,997][root][INFO] - Best obj: 15.309384807110408, Best Code Path: problem_iter1_code12.py
[2025-04-29 05:35:54,997][root][INFO] - LLM usage: prompt_tokens = 41562, completion_tokens = 21442
[2025-04-29 05:35:54,997][root][INFO] - Function Evals: 41
[2025-04-29 05:35:54,999][root][INFO] - Mutation Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.


Current heuristics:
def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Heuristic 1: Inverse distance, as closer nodes are generally preferred.
    heuristics = 1 / (distance_matrix + 1e-9)  # Add small value to avoid division by zero

    # Heuristic 2: Demand considerations.  Penalize edges that would likely lead to exceeding capacity early on.
    #   - Consider the potential load of each edge (demand of the destination node).
    #   - Adjust the heuristic value based on the remaining capacity after starting from the depot and visiting that node.

    depot_index = 0
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
                continue

            #Adjust for Depot Location and the assumption vehicles have just left depot and moving outward
            if i == depot_index and j != depot_index:
                remaining_capacity_after_visit = capacity - demands[j]
                if remaining_capacity_after_visit < 0:
                    heuristics[i, j] = 0  #impossible starting path
                else:
                     heuristics[i, j] += 0.5 #Give boost to paths emanating from Depot (0.5 is tune-able value)

            # Penalize edges if going back to the depot would be beneficial
            # This is a rough penalty and could lead to early convergence.
            # This part is tricky. Penalizing every edge back to the depot might be harmful

            # Heuristic 3: Proximity to Depot
            depot_distances = distance_matrix[:, depot_index]
            # Encourage to connect each node to closest neighbors

            k_nearest_neighbors = 3
            neighbors_idx = np.argsort(distance_matrix[i,:])[1:k_nearest_neighbors+1] # not include self, start at index 1

            for nn in neighbors_idx:
              heuristics[i,nn] = heuristics[i,nn] + 0.2  #Give slight preference (tune-able: 0.2)



    # Normalize the heuristics to be between 0 and 1 (optional but often helpful)
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics

Now, think outside the box write a mutated function `heuristics_v2` better than current version.
You can use some hints below:
- - Try combining various factors to determine how promising it is to select an edge.
- Try sparsifying the matrix by setting unpromising elements to zero.
Okay, I understand. Let's redefine "Current Self-Reflection" for better heuristic design, focusing on actionable steps and avoiding common pitfalls.

Here's a breakdown:

*   **Keywords:** Iterative refinement, factor incorporation, normalization, simplicity, adaptability.

*   **Advice:** Begin with a clear, basic heuristic. Systematically add factors (demand, depot proximity, etc.) one at a time, evaluating the impact of each addition on performance.

*   **Avoid:** Over-engineered formulas, premature optimization, overly specific parameters, complex interactions without empirical justification.

*   **Explanation:** Emphasize incremental improvements and data-driven decisions. Simple, adaptable heuristics are easier to understand, debug, and modify, ultimately leading to more robust solutions.


Output code only and enclose your code with Python code block: ```python ... ```.
I'm going to tip $999K for a better solution!
[2025-04-29 05:35:55,002][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:35:55,002][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:36:00,455][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:36:00,458][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:36:00,460][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:36:00,460][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:36:00,462][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:36:00,464][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:36:01,846][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:36:01,849][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:36:01,851][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:36:01,851][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:36:01,853][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:36:01,855][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:36:06,528][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:36:06,534][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:36:06,535][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:36:06,535][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:36:06,537][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:36:06,539][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:36:09,445][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:36:09,451][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:36:09,452][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:36:09,453][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:36:09,456][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:36:13,056][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:36:13,059][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:36:13,061][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:36:13,061][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:36:13,064][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:36:13,083][root][INFO] - Iteration 3: Running Code 0
[2025-04-29 05:36:18,978][root][INFO] - Iteration 3: Code Run 0 successful!
[2025-04-29 05:36:18,979][root][INFO] - Iteration 3: Running Code 1
[2025-04-29 05:36:25,849][root][INFO] - Iteration 3: Code Run 1 successful!
[2025-04-29 05:36:25,849][root][INFO] - Iteration 3: Running Code 2
[2025-04-29 05:36:33,720][root][INFO] - Iteration 3: Code Run 2 successful!
[2025-04-29 05:36:33,720][root][INFO] - Iteration 3: Running Code 3
[2025-04-29 05:36:41,872][root][INFO] - Iteration 3: Code Run 3 successful!
[2025-04-29 05:36:41,872][root][INFO] - Iteration 3: Running Code 4
[2025-04-29 05:36:50,311][root][INFO] - Iteration 3: Code Run 4 successful!
[2025-04-29 05:37:09,114][root][INFO] - Iteration 3, response_id 0: Objective value: 18.671422377102793
[2025-04-29 05:37:17,750][root][INFO] - Iteration 3, response_id 1: Objective value: 19.287527811708404
[2025-04-29 05:37:17,759][root][INFO] - Iteration 3, response_id 2: Objective value: 10.404584569726522
[2025-04-29 05:37:30,633][root][INFO] - Iteration 3, response_id 3: Objective value: 19.225359288669544
[2025-04-29 05:37:43,144][root][INFO] - Iteration 3, response_id 4: Objective value: 38.330385194409914
[2025-04-29 05:37:43,145][root][INFO] - Iteration 3: Elitist: 10.404584569726522
[2025-04-29 05:37:43,145][root][INFO] - Iteration 3 finished...
[2025-04-29 05:37:43,145][root][INFO] - Best obj: 10.404584569726522, Best Code Path: problem_iter3_code2.py
[2025-04-29 05:37:43,146][root][INFO] - LLM usage: prompt_tokens = 42718, completion_tokens = 22098
[2025-04-29 05:37:43,146][root][INFO] - Function Evals: 46
[2025-04-29 05:37:43,147][root][INFO] - Harmony Search Prompt: 
System Prompt: 
You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.
User Prompt: 
[code]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates demand, distance, and depot proximity considerations with sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Heuristic 1: Basic inverse distance
    heuristics = 1 / (distance_matrix + 1e-9)

    # Heuristic 2: Demand consideration + Depot Starting Edge boost
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue

            if i == depot_index and j != depot_index:
                remaining_capacity = capacity - demands[j]
                if remaining_capacity >= 0:
                    heuristics[i, j] += 0.5  # Initial Depot Boost (tuneable)
                else:
                    heuristics[i, j] = 0 # Prune unpromising edges emanating from depot

    # Heuristic 3: Depot Proximity
    depot_distances = distance_matrix[:, depot_index]
    for i in range(n):
        for j in range(n):
            if i != depot_index and j == depot_index:
                heuristics[i,j] = 0 #remove edges to depot except from depot
            if i != depot_index and j != depot_index:

                #Adjust heuristic based on distances to depot - promotes returning to depot
                heuristics[i, j] -=  0.1 * (depot_distances[i] + depot_distances[j]) / (np.mean(depot_distances)+ 1e-9) #Slight penalty for longer path to depot.

                # Further pruning based on combined distance and demand.  Aggressive sparsification.
                # The greater the distance and demand, the more aggressively prune.
                combined_metric = distance_matrix[i,j] * demands[j]
                threshold = np.mean(distance_matrix) * np.mean(demands) * 2 # Adaptive threshold

                if combined_metric > threshold:
                    heuristics[i,j] = 0 # zero out this edge as it is unpromising


    # Heuristic 4: Nearest Neighbor Preference (k-NN)
    k_nearest_neighbors = 3
    for i in range(n):
      neighbors_idx = np.argsort(distance_matrix[i,:])[1:k_nearest_neighbors+1] # not include self, start at index 1
      for nn in neighbors_idx:
          heuristics[i,nn] += 0.2 # give preference

    # Normalize
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics

Now extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.

- Output code only and enclose your code with Python code block: ```python ... ```.
- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```.
[2025-04-29 05:37:43,150][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:37:50,129][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:37:50,131][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:37:50,132][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:37:50,132][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:37:50,133][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:37:50,135][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  depot_boost: float = 0.5, depot_proximity_penalty: float = 0.1, combined_metric_threshold_factor: float = 2.0,
                  k_nearest_neighbors: int = 3, nearest_neighbor_preference: float = 0.2, small_number: float = 1e-9) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates demand, distance, and depot proximity considerations with sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.
        depot_boost (float): Boost given to edges emanating from the depot. Default is 0.5.
        depot_proximity_penalty (float): Penalty for longer paths to the depot. Default is 0.1.
        combined_metric_threshold_factor (float): Factor to adjust the combined metric threshold. Default is 2.0.
        k_nearest_neighbors (int): Number of nearest neighbors to consider. Default is 3.
        nearest_neighbor_preference (float): Preference given to edges connecting to nearest neighbors. Default is 0.2.
        small_number (float): A small number to prevent division by zero. Default is 1e-9.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Heuristic 1: Basic inverse distance
    heuristics = 1 / (distance_matrix + small_number)

    # Heuristic 2: Demand consideration + Depot Starting Edge boost
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue

            if i == depot_index and j != depot_index:
                remaining_capacity = capacity - demands[j]
                if remaining_capacity >= 0:
                    heuristics[i, j] += depot_boost  # Initial Depot Boost (tuneable)
                else:
                    heuristics[i, j] = 0 # Prune unpromising edges emanating from depot

    # Heuristic 3: Depot Proximity
    depot_distances = distance_matrix[:, depot_index]
    for i in range(n):
        for j in range(n):
            if i != depot_index and j == depot_index:
                heuristics[i,j] = 0 #remove edges to depot except from depot
            if i != depot_index and j != depot_index:

                #Adjust heuristic based on distances to depot - promotes returning to depot
                heuristics[i, j] -=  depot_proximity_penalty * (depot_distances[i] + depot_distances[j]) / (np.mean(depot_distances)+ small_number) #Slight penalty for longer path to depot.

                # Further pruning based on combined distance and demand.  Aggressive sparsification.
                # The greater the distance and demand, the more aggressively prune.
                combined_metric = distance_matrix[i,j] * demands[j]
                threshold = np.mean(distance_matrix) * np.mean(demands) * combined_metric_threshold_factor # Adaptive threshold

                if combined_metric > threshold:
                    heuristics[i,j] = 0 # zero out this edge as it is unpromising


    # Heuristic 4: Nearest Neighbor Preference (k-NN)

    for i in range(n):
      neighbors_idx = np.argsort(distance_matrix[i,:])[1:k_nearest_neighbors+1] # not include self, start at index 1
      for nn in neighbors_idx:
          heuristics[i,nn] += nearest_neighbor_preference # give preference

    # Normalize
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```

```python
parameter_ranges = {
    'depot_boost': (0.0, 1.0),
    'depot_proximity_penalty': (0.0, 0.5),
    'combined_metric_threshold_factor': (1.0, 5.0),
    'k_nearest_neighbors': (1.0, 10.0),
    'nearest_neighbor_preference': (0.0, 0.5),
    'small_number': (1e-10, 1e-6)
}
```
[2025-04-29 05:37:50,153][root][INFO] - Iteration 4: Running Code 0
[2025-04-29 05:37:52,382][root][INFO] - Iteration 4: Code Run 0 execution error!
[2025-04-29 05:37:52,383][root][INFO] - Iteration 4: Running Code 1
[2025-04-29 05:37:54,488][root][INFO] - Iteration 4: Code Run 1 execution error!
[2025-04-29 05:37:54,488][root][INFO] - Iteration 4: Running Code 2
[2025-04-29 05:37:56,632][root][INFO] - Iteration 4: Code Run 2 execution error!
[2025-04-29 05:37:56,632][root][INFO] - Iteration 4: Running Code 3
[2025-04-29 05:37:58,813][root][INFO] - Iteration 4: Code Run 3 execution error!
[2025-04-29 05:37:58,814][root][INFO] - Iteration 4: Running Code 4
[2025-04-29 05:38:00,913][root][INFO] - Iteration 4: Code Run 4 execution error!
[2025-04-29 05:38:00,928][root][INFO] - Iteration 4, response_id 0: Objective value: inf
[2025-04-29 05:38:00,931][root][INFO] - Iteration 4, response_id 1: Objective value: inf
[2025-04-29 05:38:00,933][root][INFO] - Iteration 4, response_id 2: Objective value: inf
[2025-04-29 05:38:00,935][root][INFO] - Iteration 4, response_id 3: Objective value: inf
[2025-04-29 05:38:01,197][root][INFO] - Iteration 4, response_id 4: Objective value: inf
[2025-04-29 05:38:01,200][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:38:04,638][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:38:04,641][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:38:04,642][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:38:04,643][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:38:04,644][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:38:04,645][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                   distance_weight: float = 0.6, demand_proximity_weight: float = 0.4,
                   depot_boost: float = 1.2, small_value: float = 1e-6) -> np.ndarray:
    """
    Improved heuristic for CVRP: Combines inverse distance with normalized demand and depot proximity.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Inverse distance
    distance_heuristic = 1 / (distance_matrix + small_value)

    # Demand and depot proximity
    depot_distances = distance_matrix[0, :]
    demand_proximity_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                demand_proximity_heuristic[i, j] = (capacity / (demands[i] + demands[j] + small_value)) * (1/(depot_distances[i]+ depot_distances[j] +small_value))

    # Combine heuristics
    heuristic_matrix = distance_weight * distance_heuristic + demand_proximity_weight * demand_proximity_heuristic


    # Boost edges connected to the depot
    for i in range(1, n):
        heuristic_matrix[0, i] *= depot_boost
        heuristic_matrix[i, 0] *= depot_boost

    return heuristic_matrix
```

```python
parameter_ranges = {
    'distance_weight': (0.0, 1.0),
    'demand_proximity_weight': (0.0, 1.0),
    'depot_boost': (1.0, 2.0),
    'small_value': (1e-8, 1e-4)
}
```
[2025-04-29 05:38:04,652][root][INFO] - Iteration 4: Running Code 0
[2025-04-29 05:38:10,387][root][INFO] - Iteration 4: Code Run 0 successful!
[2025-04-29 05:38:10,388][root][INFO] - Iteration 4: Running Code 1
[2025-04-29 05:38:16,067][root][INFO] - Iteration 4: Code Run 1 execution error!
[2025-04-29 05:38:16,067][root][INFO] - Iteration 4: Running Code 2
[2025-04-29 05:38:21,880][root][INFO] - Iteration 4: Code Run 2 execution error!
[2025-04-29 05:38:21,880][root][INFO] - Iteration 4: Running Code 3
[2025-04-29 05:38:27,785][root][INFO] - Iteration 4: Code Run 3 successful!
[2025-04-29 05:38:27,786][root][INFO] - Iteration 4: Running Code 4
[2025-04-29 05:38:33,591][root][INFO] - Iteration 4: Code Run 4 execution error!
[2025-04-29 05:38:33,592][root][INFO] - Iteration 4, response_id 0: Objective value: inf
[2025-04-29 05:38:33,594][root][INFO] - Iteration 4, response_id 1: Objective value: inf
[2025-04-29 05:38:33,595][root][INFO] - Iteration 4, response_id 2: Objective value: inf
[2025-04-29 05:38:33,597][root][INFO] - Iteration 4, response_id 3: Objective value: inf
[2025-04-29 05:38:34,081][root][INFO] - Iteration 4, response_id 4: Objective value: inf
[2025-04-29 05:38:34,084][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:38:40,134][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:38:40,136][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:38:40,138][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:38:40,138][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:38:40,141][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:38:40,144][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int, 
                  demand_penalty_weight: float = 1.0, coordinate_distance_weight: float = 1.0, depot_proximity_weight: float = 0.1) -> np.ndarray:
    """Improved heuristics for CVRP, combining distance, savings, demand, and coordinates."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Calculate savings based on Clarke-Wright algorithm
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Incorporate distance and savings
    heuristic_matrix = (1 / distance_matrix + savings_matrix / np.max(savings_matrix)) #avoiding infs/NaNs

    # Penalize edges connecting to nodes with high demand relative to capacity
    demand_penalty = np.zeros(n)
    for i in range(1, n):
      demand_penalty[i] = demands[i] / capacity

    for i in range(n):
      for j in range(n):
        if i == j:
          heuristic_matrix[i, j] = 0 #ensure no loops
        else:
            heuristic_matrix[i,j] /= (1 + demand_penalty_weight * (demand_penalty[i] + demand_penalty[j])) #slightly penalize high demand nodes

    #Prioritize connecting nodes that are close in coordinate space. This can help exploit locality.
    coordinate_distances = np.zeros_like(distance_matrix)
    for i in range(n):
      for j in range(n):
        coordinate_distances[i,j] = np.linalg.norm(coordinates[i] - coordinates[j])

    heuristic_matrix += (coordinate_distance_weight/coordinate_distances) #prefer edges with small coordinate distance
    heuristic_matrix[np.isinf(heuristic_matrix)] = 0  # Remove any potential infinities created by division by zero on diagonals.
    heuristic_matrix[np.isnan(heuristic_matrix)] = 0 # Clean NaN values

    #Add depot proximity component
    depot_distances = distance_matrix[0, :]
    max_depot_distance = np.max(depot_distances)
    for i in range(n):
        for j in range(n):
            if i != j:
                depot_proximity_component = (1 - (depot_distances[i] + depot_distances[j]) / (2 * max_depot_distance))
                heuristic_matrix[i, j] += depot_proximity_weight * depot_proximity_component
    return heuristic_matrix
```

```python
parameter_ranges = {
    "demand_penalty_weight": (0.0, 2.0),
    "coordinate_distance_weight": (0.0, 2.0),
    "depot_proximity_weight": (0.0, 0.5),
}
```
[2025-04-29 05:38:40,153][root][INFO] - Iteration 4: Running Code 0
[2025-04-29 05:38:46,095][root][INFO] - Iteration 4: Code Run 0 execution error!
[2025-04-29 05:38:46,096][root][INFO] - Iteration 4: Running Code 1
[2025-04-29 05:38:51,857][root][INFO] - Iteration 4: Code Run 1 successful!
[2025-04-29 05:38:51,858][root][INFO] - Iteration 4: Running Code 2
[2025-04-29 05:38:57,599][root][INFO] - Iteration 4: Code Run 2 execution error!
[2025-04-29 05:38:57,599][root][INFO] - Iteration 4: Running Code 3
[2025-04-29 05:39:03,412][root][INFO] - Iteration 4: Code Run 3 execution error!
[2025-04-29 05:39:03,412][root][INFO] - Iteration 4: Running Code 4
[2025-04-29 05:39:09,164][root][INFO] - Iteration 4: Code Run 4 successful!
[2025-04-29 05:39:09,166][root][INFO] - Iteration 4, response_id 0: Objective value: inf
[2025-04-29 05:39:09,167][root][INFO] - Iteration 4, response_id 1: Objective value: inf
[2025-04-29 05:39:09,169][root][INFO] - Iteration 4, response_id 2: Objective value: inf
[2025-04-29 05:39:09,171][root][INFO] - Iteration 4, response_id 3: Objective value: inf
[2025-04-29 05:39:09,671][root][INFO] - Iteration 4, response_id 4: Objective value: inf
[2025-04-29 05:39:09,671][root][INFO] - Iteration 4 finished...
[2025-04-29 05:39:09,672][root][INFO] - Best obj: 10.404584569726522, Best Code Path: problem_iter3_code2.py
[2025-04-29 05:39:09,672][root][INFO] - LLM usage: prompt_tokens = 44699, completion_tokens = 24165
[2025-04-29 05:39:09,672][root][INFO] - Function Evals: 46
[2025-04-29 05:39:09,674][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:39:15,698][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:39:15,701][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:39:15,703][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:15,703][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:15,706][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:15,738][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:39:19,152][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:39:19,155][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:39:19,156][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:19,157][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:19,159][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:19,199][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:39:19,200][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:39:23,119][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:39:23,122][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:39:23,123][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:23,124][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:23,126][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:39:23,127][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:24,615][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:39:24,616][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:39:24,617][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:24,617][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:24,618][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:39:24,619][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:27,824][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:39:27,826][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:39:27,826][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:27,826][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:27,827][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:39:27,828][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:28,304][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:39:28,307][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:39:28,308][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:28,309][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:28,311][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:39:28,312][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:31,920][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:39:31,922][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:39:31,923][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:31,923][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:31,924][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:39:31,925][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:32,175][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:39:32,176][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:39:32,177][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:32,177][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:32,178][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:39:32,179][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:36,236][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:39:36,239][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:39:36,240][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:36,241][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:36,243][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:39:36,244][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:36,278][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:39:36,280][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:39:36,281][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:36,282][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:39:36,282][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:36,283][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:40,650][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:39:40,652][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:39:40,653][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:40,653][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:40,654][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:40,828][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:39:40,830][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:39:40,831][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:40,831][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:40,833][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:39:40,866][root][INFO] - Iteration 5: Running Code 0
[2025-04-29 05:39:46,703][root][INFO] - Iteration 5: Code Run 0 successful!
[2025-04-29 05:39:46,703][root][INFO] - Iteration 5: Running Code 1
[2025-04-29 05:39:53,497][root][INFO] - Iteration 5: Code Run 1 successful!
[2025-04-29 05:39:53,497][root][INFO] - Iteration 5: Running Code 2
[2025-04-29 05:40:01,269][root][INFO] - Iteration 5: Code Run 2 successful!
[2025-04-29 05:40:01,270][root][INFO] - Iteration 5: Running Code 3
[2025-04-29 05:40:09,444][root][INFO] - Iteration 5: Code Run 3 successful!
[2025-04-29 05:40:09,444][root][INFO] - Iteration 5: Running Code 4
[2025-04-29 05:40:18,308][root][INFO] - Iteration 5: Code Run 4 successful!
[2025-04-29 05:40:18,309][root][INFO] - Iteration 5: Running Code 5
[2025-04-29 05:40:28,185][root][INFO] - Iteration 5: Code Run 5 successful!
[2025-04-29 05:40:28,185][root][INFO] - Iteration 5: Running Code 6
[2025-04-29 05:40:38,799][root][INFO] - Iteration 5: Code Run 6 successful!
[2025-04-29 05:40:38,799][root][INFO] - Iteration 5: Running Code 7
[2025-04-29 05:40:42,594][root][INFO] - Iteration 5: Code Run 7 execution error!
[2025-04-29 05:40:42,594][root][INFO] - Iteration 5: Running Code 8
[2025-04-29 05:40:52,770][root][INFO] - Iteration 5: Code Run 8 successful!
[2025-04-29 05:40:52,771][root][INFO] - Iteration 5: Running Code 9
[2025-04-29 05:41:03,501][root][INFO] - Iteration 5: Code Run 9 successful!
[2025-04-29 05:41:03,513][root][INFO] - Iteration 5, response_id 0: Objective value: 18.46057046758821
[2025-04-29 05:41:13,717][root][INFO] - Iteration 5, response_id 1: Objective value: 18.672279783294613
[2025-04-29 05:41:27,759][root][INFO] - Iteration 5, response_id 2: Objective value: 18.09640775346171
[2025-04-29 05:41:51,887][root][INFO] - Iteration 5, response_id 3: Objective value: 21.026050429223424
[2025-04-29 05:42:07,813][root][INFO] - Iteration 5, response_id 4: Objective value: 38.330385194409914
[2025-04-29 05:42:07,828][root][INFO] - Iteration 5, response_id 5: Objective value: 18.335456581211528
[2025-04-29 05:42:17,474][root][INFO] - Iteration 5, response_id 6: Objective value: 38.330385194409914
[2025-04-29 05:42:17,488][root][INFO] - Iteration 5, response_id 7: Objective value: inf
[2025-04-29 05:42:17,501][root][INFO] - Iteration 5, response_id 8: Objective value: 17.69047784823895
[2025-04-29 05:42:17,521][root][INFO] - Iteration 5, response_id 9: Objective value: 18.883956318852984
[2025-04-29 05:42:17,522][root][INFO] - Iteration 5 finished...
[2025-04-29 05:42:17,522][root][INFO] - Best obj: 10.404584569726522, Best Code Path: problem_iter3_code2.py
[2025-04-29 05:42:17,523][root][INFO] - LLM usage: prompt_tokens = 75028, completion_tokens = 28826
[2025-04-29 05:42:17,523][root][INFO] - Function Evals: 56
[2025-04-29 05:42:17,526][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:42:17,527][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:42:24,393][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:42:24,396][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:42:24,398][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:42:24,398][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:42:24,400][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:42:24,401][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:42:24,929][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:42:24,933][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:42:24,934][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:42:24,934][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:42:24,936][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:42:24,938][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:42:32,363][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:42:32,365][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:42:32,365][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:42:32,366][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:42:32,366][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:42:32,367][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:42:32,547][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:42:32,548][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:42:32,549][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:42:32,549][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:42:32,550][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:42:40,067][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:42:40,070][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:42:40,071][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:42:40,072][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:42:40,074][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:42:40,090][root][INFO] - Iteration 6: Running Code 0
[2025-04-29 05:42:45,906][root][INFO] - Iteration 6: Code Run 0 successful!
[2025-04-29 05:42:45,906][root][INFO] - Iteration 6: Running Code 1
[2025-04-29 05:42:52,713][root][INFO] - Iteration 6: Code Run 1 successful!
[2025-04-29 05:42:52,713][root][INFO] - Iteration 6: Running Code 2
[2025-04-29 05:43:00,549][root][INFO] - Iteration 6: Code Run 2 successful!
[2025-04-29 05:43:00,549][root][INFO] - Iteration 6: Running Code 3
[2025-04-29 05:43:08,758][root][INFO] - Iteration 6: Code Run 3 successful!
[2025-04-29 05:43:08,758][root][INFO] - Iteration 6: Running Code 4
[2025-04-29 05:43:17,244][root][INFO] - Iteration 6: Code Run 4 successful!
[2025-04-29 05:43:39,008][root][INFO] - Iteration 6, response_id 0: Objective value: 19.849201344679805
[2025-04-29 05:43:39,018][root][INFO] - Iteration 6, response_id 1: Objective value: 11.177811383159241
[2025-04-29 05:43:42,699][root][INFO] - Iteration 6, response_id 2: Objective value: 10.16919453248675
[2025-04-29 05:43:57,274][root][INFO] - Iteration 6, response_id 3: Objective value: 17.426626295632285
[2025-04-29 05:43:57,285][root][INFO] - Iteration 6, response_id 4: Objective value: 10.805402695918342
[2025-04-29 05:43:57,286][root][INFO] - Iteration 6: Elitist: 10.16919453248675
[2025-04-29 05:43:57,286][root][INFO] - Iteration 6 finished...
[2025-04-29 05:43:57,286][root][INFO] - Best obj: 10.16919453248675, Best Code Path: problem_iter6_code2.py
[2025-04-29 05:43:57,287][root][INFO] - LLM usage: prompt_tokens = 76240, completion_tokens = 29493
[2025-04-29 05:43:57,287][root][INFO] - Function Evals: 61
[2025-04-29 05:43:57,290][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:44:07,376][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:44:07,379][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:44:07,381][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:44:07,381][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:44:07,382][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:44:07,384][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                   depot_boost: float = 0.3, detour_penalty_weight: float = 0.05,
                   demand_capacity_ratio: float = 1/3, angle_reward_weight: float = 0.1,
                   sparsification_threshold_factor: float = 0.01, inverse_distance_epsilon: float = 1e-9,
                   mean_depot_distance_epsilon: float = 1e-9) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates demand, distance, depot proximity and angle considerations with adaptive sparsification and simplified components.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.
        depot_boost (float): Boost added to heuristics for edges originating from the depot.
        detour_penalty_weight (float): Weight of the detour penalty.
        demand_capacity_ratio (float): Ratio used in the adaptive pruning based on demand and capacity.
        angle_reward_weight (float): Weight of the angle reward.
        sparsification_threshold_factor (float): Factor used to calculate the sparsification threshold.
        inverse_distance_epsilon(float): Epsilon to prevent division by zero.
        mean_depot_distance_epsilon(float): Epsilon to prevent division by zero in mean depot distance calculation

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Heuristic 1: Basic inverse distance
    heuristics = 1 / (distance_matrix + inverse_distance_epsilon)

    # Heuristic 2: Demand and Capacity consideration
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue

            if i == depot_index and j != depot_index:
                if demands[j] > capacity: # Directly prune edges that violate capacity constraint.
                    heuristics[i, j] = 0
                else:
                    heuristics[i,j] += depot_boost #Depot boost

    # Heuristic 3: Depot proximity with adaptive pruning
    depot_distances = distance_matrix[:, depot_index]
    mean_depot_distance = np.mean(depot_distances)

    for i in range(n):
        for j in range(n):
            if i != depot_index and j == depot_index:
                heuristics[i, j] = 0  # Remove edges to depot (except from depot)
            elif i != depot_index and j != depot_index:
                # Penalize edges based on detour from direct depot route.  Simpler calculation.
                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2*mean_depot_distance + mean_depot_distance_epsilon)
                heuristics[i, j] -= detour_penalty_weight * detour_penalty # Reduced weight

                # Adaptive pruning based on demand and distance.  Less aggressive than v1.
                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity * demand_capacity_ratio: #Only prune if nodes have considerable demand compared to vehicle capacity.
                    heuristics[i,j] = 0


    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                # Dot product to find the cosine of the angle between vectors
                vector_i = coordinates[i] - coordinates[depot_index]
                vector_j = coordinates[j] - coordinates[depot_index]

                norm_i = np.linalg.norm(vector_i)
                norm_j = np.linalg.norm(vector_j)

                if norm_i > 0 and norm_j > 0:
                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)
                    # Convert cosine to angle in radians
                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) #Ensure within valid range

                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value
                    heuristics[i,j] += angle_reward_weight * (1 - angle / np.pi) # Normalized angle reward, reduced weight


    # Heuristic 5: Sparsification: zero out small heuristic values
    threshold = sparsification_threshold_factor * np.mean(heuristics) # Adaptive threshold
    heuristics[heuristics < threshold] = 0


    # Normalize
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```

```python
parameter_ranges = {
    'depot_boost': (0.0, 1.0),
    'detour_penalty_weight': (0.0, 0.5),
    'demand_capacity_ratio': (0.0, 1.0),
    'angle_reward_weight': (0.0, 0.5),
    'sparsification_threshold_factor': (0.0, 0.1),
    'inverse_distance_epsilon': (1e-10, 1e-8),
    'mean_depot_distance_epsilon': (1e-10, 1e-8)
}
```
[2025-04-29 05:44:07,404][root][INFO] - Iteration 7: Running Code 0
[2025-04-29 05:44:13,178][root][INFO] - Iteration 7: Code Run 0 execution error!
[2025-04-29 05:44:13,178][root][INFO] - Iteration 7: Running Code 1
[2025-04-29 05:44:19,100][root][INFO] - Iteration 7: Code Run 1 successful!
[2025-04-29 05:44:19,100][root][INFO] - Iteration 7: Running Code 2
[2025-04-29 05:44:24,811][root][INFO] - Iteration 7: Code Run 2 successful!
[2025-04-29 05:44:24,811][root][INFO] - Iteration 7: Running Code 3
[2025-04-29 05:44:30,715][root][INFO] - Iteration 7: Code Run 3 successful!
[2025-04-29 05:44:30,715][root][INFO] - Iteration 7: Running Code 4
[2025-04-29 05:44:36,559][root][INFO] - Iteration 7: Code Run 4 successful!
[2025-04-29 05:44:36,560][root][INFO] - Iteration 7, response_id 0: Objective value: inf
[2025-04-29 05:44:36,562][root][INFO] - Iteration 7, response_id 1: Objective value: inf
[2025-04-29 05:44:36,564][root][INFO] - Iteration 7, response_id 2: Objective value: inf
[2025-04-29 05:44:36,565][root][INFO] - Iteration 7, response_id 3: Objective value: inf
[2025-04-29 05:44:37,057][root][INFO] - Iteration 7, response_id 4: Objective value: inf
[2025-04-29 05:44:37,060][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:44:45,626][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:44:45,629][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:44:45,630][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:44:45,631][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:44:45,633][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:44:45,639][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  distance_weight: float = 0.6, initial_depot_boost: float = 0.7, angle_weight: float = 0.1,
                  sparsification_multiplier: float = 2.0, small_number: float = 1e-9) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates demand, distance, depot proximity and angle considerations with sparsification and adaptive weighting.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.
        distance_weight (float): Weight for the distance heuristic. Default is 0.6.
        initial_depot_boost (float): Initial boost for edges from the depot. Default is 0.7.
        angle_weight (float): Weight for the angle heuristic. Default is 0.1.
        sparsification_multiplier (float): Multiplier for the sparsification threshold. Default is 2.0.
        small_number (float): A small number to avoid division by zero. Default is 1e-9.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Heuristic 1: Basic inverse distance
    distance_heuristic = 1 / (distance_matrix + small_number)
    heuristics += distance_heuristic * distance_weight  # Base contribution from distance

    # Heuristic 2: Demand consideration and Depot Connection
    demand_distance_heuristic = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_distance_heuristic[i, j] = 0
                continue

            if i == depot_index and j != depot_index:
                remaining_capacity = capacity - demands[j]
                if remaining_capacity >= 0:
                    demand_distance_heuristic[i, j] = initial_depot_boost  # Initial Depot Boost
                else:
                    demand_distance_heuristic[i, j] = 0  # Prune unpromising edges from depot

            elif i != depot_index and j == depot_index:
                  demand_distance_heuristic[i,j] = 0  # No edges to depot except from depot
            elif i != depot_index and j!= depot_index:
                demand_distance_heuristic[i,j] = 1/(distance_matrix[i,j] * demands[j] + small_number)

    heuristics += demand_distance_heuristic * (1 - distance_weight)


    #Heuristic 3: Angle from Depot
    angle_heuristic = np.zeros_like(distance_matrix)

    for i in range(n):
        for j in range(n):
            if i == depot_index or j == depot_index or i ==j:
                angle_heuristic[i,j] = 0
                continue

            # Calculate angles between the depot and the two nodes
            vector_i = coordinates[i] - coordinates[depot_index]
            vector_j = coordinates[j] - coordinates[depot_index]

            #Calculate angle between vectors
            norm_i = np.linalg.norm(vector_i)
            norm_j = np.linalg.norm(vector_j)

            if norm_i == 0 or norm_j == 0:
                angle = 0
            else:

                dot_product = np.dot(vector_i, vector_j)
                cos_angle = dot_product / (norm_i * norm_j)
                angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) # Clip for numerical stability



            angle_heuristic[i,j] = 1- (angle / np.pi)  # Smaller angle is better


    heuristics += angle_heuristic * angle_weight


    # Heuristic 4: Sparsification
    threshold = np.mean(distance_matrix) # Adaptive Threshold
    for i in range(n):
        for j in range(n):
            if i != j and distance_matrix[i,j] > threshold * sparsification_multiplier : # More Aggressive
                heuristics[i, j] = 0

    # Normalize
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```

```python
parameter_ranges = {
    'distance_weight': (0.0, 1.0),
    'initial_depot_boost': (0.0, 1.0),
    'angle_weight': (0.0, 1.0),
    'sparsification_multiplier': (1.0, 5.0),
    'small_number': (1e-10, 1e-6)
}
```
[2025-04-29 05:44:45,648][root][INFO] - Iteration 7: Running Code 0
[2025-04-29 05:44:51,467][root][INFO] - Iteration 7: Code Run 0 execution error!
[2025-04-29 05:44:51,468][root][INFO] - Iteration 7: Running Code 1
[2025-04-29 05:44:57,399][root][INFO] - Iteration 7: Code Run 1 execution error!
[2025-04-29 05:44:57,400][root][INFO] - Iteration 7: Running Code 2
[2025-04-29 05:45:03,210][root][INFO] - Iteration 7: Code Run 2 execution error!
[2025-04-29 05:45:03,210][root][INFO] - Iteration 7: Running Code 3
[2025-04-29 05:45:08,999][root][INFO] - Iteration 7: Code Run 3 successful!
[2025-04-29 05:45:09,000][root][INFO] - Iteration 7: Running Code 4
[2025-04-29 05:45:14,768][root][INFO] - Iteration 7: Code Run 4 successful!
[2025-04-29 05:45:14,769][root][INFO] - Iteration 7, response_id 0: Objective value: inf
[2025-04-29 05:45:14,771][root][INFO] - Iteration 7, response_id 1: Objective value: inf
[2025-04-29 05:45:14,772][root][INFO] - Iteration 7, response_id 2: Objective value: inf
[2025-04-29 05:45:14,774][root][INFO] - Iteration 7, response_id 3: Objective value: inf
[2025-04-29 05:45:15,270][root][INFO] - Iteration 7, response_id 4: Objective value: inf
[2025-04-29 05:45:15,273][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:45:24,569][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:45:24,572][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:45:24,574][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:45:24,574][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:45:24,576][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:45:24,581][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  depot_boost_weight: float = 0.3, detour_penalty_weight: float = 0.05,
                  demand_capacity_threshold: float = 1/3, angle_reward_weight: float = 0.1,
                  sparsification_threshold_factor: float = 0.01, inverse_distance_epsilon: float = 1e-9,
                  mean_depot_distance_epsilon: float = 1e-9) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates demand, distance, depot proximity and angle considerations with adaptive sparsification and simplified components.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.
        depot_boost_weight (float): Weight for boosting edges from the depot. Default is 0.3.
        detour_penalty_weight (float): Weight for penalizing detours from the direct depot route. Default is 0.05.
        demand_capacity_threshold (float): Threshold for pruning based on demand and capacity. Default is 1/3.
        angle_reward_weight (float): Weight for rewarding edges with similar angles from the depot. Default is 0.1.
        sparsification_threshold_factor (float): Factor for determining the sparsification threshold. Default is 0.01.
        inverse_distance_epsilon (float): Epsilon value to avoid division by zero in inverse distance calculation. Default is 1e-9.
        mean_depot_distance_epsilon (float): Epsilon value to avoid division by zero when calculating detour penalty. Default is 1e-9.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Heuristic 1: Basic inverse distance
    heuristics = 1 / (distance_matrix + inverse_distance_epsilon)

    # Heuristic 2: Demand and Capacity consideration
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue

            if i == depot_index and j != depot_index:
                if demands[j] > capacity: # Directly prune edges that violate capacity constraint.
                    heuristics[i, j] = 0
                else:
                    heuristics[i,j] += depot_boost_weight #Depot boost

    # Heuristic 3: Depot proximity with adaptive pruning
    depot_distances = distance_matrix[:, depot_index]
    mean_depot_distance = np.mean(depot_distances)

    for i in range(n):
        for j in range(n):
            if i != depot_index and j == depot_index:
                heuristics[i, j] = 0  # Remove edges to depot (except from depot)
            elif i != depot_index and j != depot_index:
                # Penalize edges based on detour from direct depot route.  Simpler calculation.
                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2*mean_depot_distance + mean_depot_distance_epsilon)
                heuristics[i, j] -= detour_penalty_weight * detour_penalty # Reduced weight

                # Adaptive pruning based on demand and distance.  Less aggressive than v1.
                if distance_matrix[i, j] > np.mean(distance_matrix) and demands[i] + demands[j] > capacity*demand_capacity_threshold: #Only prune if nodes have considerable demand compared to vehicle capacity.
                    heuristics[i,j] = 0


    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                # Dot product to find the cosine of the angle between vectors
                vector_i = coordinates[i] - coordinates[depot_index]
                vector_j = coordinates[j] - coordinates[depot_index]

                norm_i = np.linalg.norm(vector_i)
                norm_j = np.linalg.norm(vector_j)

                if norm_i > 0 and norm_j > 0:
                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)
                    # Convert cosine to angle in radians
                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) #Ensure within valid range

                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value
                    heuristics[i,j] += angle_reward_weight * (1 - angle / np.pi) # Normalized angle reward, reduced weight


    # Heuristic 5: Sparsification: zero out small heuristic values
    threshold = sparsification_threshold_factor * np.mean(heuristics) # Adaptive threshold
    heuristics[heuristics < threshold] = 0


    # Normalize
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```

```python
parameter_ranges = {
    'depot_boost_weight': (0.0, 1.0),
    'detour_penalty_weight': (0.0, 0.5),
    'demand_capacity_threshold': (0.0, 1.0),
    'angle_reward_weight': (0.0, 1.0),
    'sparsification_threshold_factor': (0.0, 0.1),
    'inverse_distance_epsilon': (1e-10, 1e-6),
    'mean_depot_distance_epsilon': (1e-10, 1e-6)
}
```
[2025-04-29 05:45:24,598][root][INFO] - Iteration 7: Running Code 0
[2025-04-29 05:45:30,338][root][INFO] - Iteration 7: Code Run 0 successful!
[2025-04-29 05:45:30,338][root][INFO] - Iteration 7: Running Code 1
[2025-04-29 05:45:36,100][root][INFO] - Iteration 7: Code Run 1 execution error!
[2025-04-29 05:45:36,100][root][INFO] - Iteration 7: Running Code 2
[2025-04-29 05:45:41,916][root][INFO] - Iteration 7: Code Run 2 successful!
[2025-04-29 05:45:41,916][root][INFO] - Iteration 7: Running Code 3
[2025-04-29 05:45:47,537][root][INFO] - Iteration 7: Code Run 3 successful!
[2025-04-29 05:45:47,537][root][INFO] - Iteration 7: Running Code 4
[2025-04-29 05:45:53,185][root][INFO] - Iteration 7: Code Run 4 execution error!
[2025-04-29 05:45:53,187][root][INFO] - Iteration 7, response_id 0: Objective value: inf
[2025-04-29 05:45:53,188][root][INFO] - Iteration 7, response_id 1: Objective value: inf
[2025-04-29 05:45:53,190][root][INFO] - Iteration 7, response_id 2: Objective value: inf
[2025-04-29 05:45:53,192][root][INFO] - Iteration 7, response_id 3: Objective value: inf
[2025-04-29 05:45:53,686][root][INFO] - Iteration 7, response_id 4: Objective value: inf
[2025-04-29 05:45:53,687][root][INFO] - Iteration 7 finished...
[2025-04-29 05:45:53,687][root][INFO] - Best obj: 10.16919453248675, Best Code Path: problem_iter6_code2.py
[2025-04-29 05:45:53,687][root][INFO] - LLM usage: prompt_tokens = 79293, completion_tokens = 33117
[2025-04-29 05:45:53,687][root][INFO] - Function Evals: 61
[2025-04-29 05:45:53,689][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:45:58,531][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:45:58,538][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:45:58,539][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:45:58,540][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:45:58,541][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:45:58,563][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:46:01,020][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:46:01,024][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:46:01,025][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:01,026][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:01,029][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:01,065][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:46:01,066][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:46:06,480][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:46:06,485][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:46:06,487][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:06,487][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:06,489][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:46:06,492][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:06,914][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:46:06,916][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:46:06,916][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:06,917][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:06,917][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:46:06,918][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:11,159][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:46:11,162][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:46:11,164][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:11,164][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:11,166][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:46:11,168][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:13,465][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:46:13,468][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:46:13,469][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:13,470][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:13,471][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:46:13,473][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:16,296][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:46:16,299][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:46:16,300][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:16,300][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:16,302][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:46:16,303][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:17,779][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:46:17,782][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:46:17,783][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:17,784][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:17,785][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:46:17,787][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:20,722][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:46:20,725][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:46:20,727][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:20,727][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:20,729][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:46:20,731][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:21,426][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:46:21,429][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:46:21,430][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:21,430][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:21,433][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:46:21,434][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:26,076][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:46:26,079][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:46:26,080][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:26,081][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:26,082][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:26,201][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:46:26,202][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:46:26,203][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:26,203][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:26,205][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:46:26,238][root][INFO] - Iteration 8: Running Code 0
[2025-04-29 05:46:32,032][root][INFO] - Iteration 8: Code Run 0 successful!
[2025-04-29 05:46:32,033][root][INFO] - Iteration 8: Running Code 1
[2025-04-29 05:46:39,138][root][INFO] - Iteration 8: Code Run 1 successful!
[2025-04-29 05:46:39,138][root][INFO] - Iteration 8: Running Code 2
[2025-04-29 05:46:47,073][root][INFO] - Iteration 8: Code Run 2 successful!
[2025-04-29 05:46:47,073][root][INFO] - Iteration 8: Running Code 3
[2025-04-29 05:46:55,428][root][INFO] - Iteration 8: Code Run 3 successful!
[2025-04-29 05:46:55,428][root][INFO] - Iteration 8: Running Code 4
[2025-04-29 05:47:04,686][root][INFO] - Iteration 8: Code Run 4 successful!
[2025-04-29 05:47:04,687][root][INFO] - Iteration 8: Running Code 5
[2025-04-29 05:47:14,372][root][INFO] - Iteration 8: Code Run 5 successful!
[2025-04-29 05:47:14,372][root][INFO] - Iteration 8: Running Code 6
[2025-04-29 05:47:24,221][root][INFO] - Iteration 8: Code Run 6 successful!
[2025-04-29 05:47:24,221][root][INFO] - Iteration 8: Running Code 7
[2025-04-29 05:47:34,448][root][INFO] - Iteration 8: Code Run 7 successful!
[2025-04-29 05:47:34,448][root][INFO] - Iteration 8: Running Code 8
[2025-04-29 05:47:44,897][root][INFO] - Iteration 8: Code Run 8 successful!
[2025-04-29 05:47:44,897][root][INFO] - Iteration 8: Running Code 9
[2025-04-29 05:47:56,100][root][INFO] - Iteration 8: Code Run 9 successful!
[2025-04-29 05:47:56,113][root][INFO] - Iteration 8, response_id 0: Objective value: 10.5376899606542
[2025-04-29 05:47:56,125][root][INFO] - Iteration 8, response_id 1: Objective value: 10.205529653020175
[2025-04-29 05:48:12,113][root][INFO] - Iteration 8, response_id 2: Objective value: 18.052030520910453
[2025-04-29 05:48:12,126][root][INFO] - Iteration 8, response_id 3: Objective value: 11.391570339898578
[2025-04-29 05:48:20,634][root][INFO] - Iteration 8, response_id 4: Objective value: 11.555218276664801
[2025-04-29 05:48:38,559][root][INFO] - Iteration 8, response_id 5: Objective value: 17.533774455364384
[2025-04-29 05:48:46,948][root][INFO] - Iteration 8, response_id 6: Objective value: 18.02581981145422
[2025-04-29 05:48:52,261][root][INFO] - Iteration 8, response_id 7: Objective value: 19.42119687648927
[2025-04-29 05:48:54,459][root][INFO] - Iteration 8, response_id 8: Objective value: 17.40941421590905
[2025-04-29 05:48:56,933][root][INFO] - Iteration 8, response_id 9: Objective value: 13.872754902186719
[2025-04-29 05:48:56,935][root][INFO] - Iteration 8 finished...
[2025-04-29 05:48:56,935][root][INFO] - Best obj: 10.16919453248675, Best Code Path: problem_iter6_code2.py
[2025-04-29 05:48:56,935][root][INFO] - LLM usage: prompt_tokens = 112152, completion_tokens = 39231
[2025-04-29 05:48:56,936][root][INFO] - Function Evals: 71
[2025-04-29 05:48:56,939][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:48:56,940][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:49:05,966][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:49:05,969][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:49:05,971][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:49:05,971][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:49:05,974][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:49:05,975][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:49:06,531][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:49:06,534][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:49:06,535][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:49:06,536][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:49:06,538][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:49:06,539][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:49:14,314][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:49:14,317][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:49:14,318][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:49:14,319][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:49:14,321][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:49:14,323][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:49:16,515][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:49:16,518][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:49:16,519][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:49:16,520][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:49:16,522][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:49:23,325][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:49:23,327][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:49:23,327][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:49:23,328][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:49:23,329][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:49:23,347][root][INFO] - Iteration 9: Running Code 0
[2025-04-29 05:49:29,233][root][INFO] - Iteration 9: Code Run 0 successful!
[2025-04-29 05:49:29,234][root][INFO] - Iteration 9: Running Code 1
[2025-04-29 05:49:36,014][root][INFO] - Iteration 9: Code Run 1 successful!
[2025-04-29 05:49:36,014][root][INFO] - Iteration 9: Running Code 2
[2025-04-29 05:49:43,963][root][INFO] - Iteration 9: Code Run 2 successful!
[2025-04-29 05:49:43,963][root][INFO] - Iteration 9: Running Code 3
[2025-04-29 05:49:52,336][root][INFO] - Iteration 9: Code Run 3 successful!
[2025-04-29 05:49:52,336][root][INFO] - Iteration 9: Running Code 4
[2025-04-29 05:50:01,649][root][INFO] - Iteration 9: Code Run 4 successful!
[2025-04-29 05:50:07,240][root][INFO] - Iteration 9, response_id 0: Objective value: 10.248157244713628
[2025-04-29 05:50:17,696][root][INFO] - Iteration 9, response_id 1: Objective value: 10.095646192475877
[2025-04-29 05:50:25,193][root][INFO] - Iteration 9, response_id 2: Objective value: 10.19433279259759
[2025-04-29 05:50:31,548][root][INFO] - Iteration 9, response_id 3: Objective value: 9.981625510701699
[2025-04-29 05:50:34,678][root][INFO] - Iteration 9, response_id 4: Objective value: 10.157510316853761
[2025-04-29 05:50:34,679][root][INFO] - Iteration 9: Elitist: 9.981625510701699
[2025-04-29 05:50:34,680][root][INFO] - Iteration 9 finished...
[2025-04-29 05:50:34,680][root][INFO] - Best obj: 9.981625510701699, Best Code Path: problem_iter9_code3.py
[2025-04-29 05:50:34,680][root][INFO] - LLM usage: prompt_tokens = 113580, completion_tokens = 40341
[2025-04-29 05:50:34,681][root][INFO] - Function Evals: 76
[2025-04-29 05:50:34,691][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:50:44,196][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:50:44,198][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:50:44,200][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:50:44,200][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:50:44,202][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:50:44,205][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  demand_penalty_factor: float = 0.5, depot_proximity_weight: float = 0.1,
                  adaptive_pruning_distance_factor: float = 1.2, adaptive_pruning_demand_divisor: float = 3,
                  angle_weight: float = 0.2, knn: int = 5, knn_weight: float = 0.15,
                  threshold_factor: float = 0.02, depot_boost: float = 0.5) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates demand, distance, depot proximity, angle considerations, k-NN intensification,
    and adaptive sparsification with more refined components and weight tuning.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.
        demand_penalty_factor (float): Weight for penalizing edges based on demand.
        depot_proximity_weight (float): Weight for penalizing edges based on detour from the depot.
        adaptive_pruning_distance_factor (float): Factor to scale the average distance for adaptive pruning.
        adaptive_pruning_demand_divisor (float): Divisor for capacity when checking demand for adaptive pruning.
        angle_weight (float): Weight for rewarding edges based on the angle from the depot.
        knn (int): Number of nearest neighbors to consider for k-NN intensification.
        knn_weight (float): Weight for k-NN intensification.
        threshold_factor (float): Factor for adaptive thresholding.
        depot_boost (float): Boost for edges connecting depot to other nodes.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Heuristic 1: Basic inverse distance (with a slight modification)
    heuristics = 1 / (distance_matrix + 1e-9)
    distance_scaling = np.mean(distance_matrix)  # Use mean distance for scaling
    heuristics *= distance_scaling  # Scale based on average distance

    # Heuristic 2: Demand and Capacity consideration
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue

            if i == depot_index and j != depot_index:
                if demands[j] > capacity:  # Directly prune edges that violate capacity constraint.
                    heuristics[i, j] = 0
                else:
                    heuristics[i, j] += depot_boost  # Depot boost (increased)
            elif i != depot_index and j != depot_index:
                demand_ratio = (demands[i] + demands[j]) / capacity
                demand_penalty = demand_penalty_factor * demand_ratio
                heuristics[i, j] -= demand_penalty # More aggressive demand penalty

    # Heuristic 3: Depot proximity with adaptive pruning
    depot_distances = distance_matrix[:, depot_index]
    mean_depot_distance = np.mean(depot_distances)

    for i in range(n):
        for j in range(n):
            if i != depot_index and j == depot_index:
                heuristics[i, j] = 0  # Remove edges to depot (except from depot)
            elif i != depot_index and j != depot_index:
                # Penalize edges based on detour from direct depot route. Simpler calculation.
                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)
                heuristics[i, j] -= depot_proximity_weight * detour_penalty  # Reduced weight

                # Adaptive pruning based on demand and distance. Less aggressive than v1.
                if distance_matrix[i, j] > adaptive_pruning_distance_factor * distance_scaling and demands[i] + demands[j] > capacity / adaptive_pruning_demand_divisor:  # Adjusted threshold and demand check
                    heuristics[i, j] = 0

    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                # Dot product to find the cosine of the angle between vectors
                vector_i = coordinates[i] - coordinates[depot_index]
                vector_j = coordinates[j] - coordinates[depot_index]

                norm_i = np.linalg.norm(vector_i)
                norm_j = np.linalg.norm(vector_j)

                if norm_i > 0 and norm_j > 0:
                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)
                    # Convert cosine to angle in radians
                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Ensure within valid range

                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value
                    heuristics[i, j] += angle_weight * (1 - angle / np.pi)  # Normalized angle reward, reduced weight

    # Heuristic 5: k-NN intensification (Focus on local search)
    for i in range(1, n):
        # Find k-nearest neighbors based on distance
        distances_from_i = distance_matrix[i, 1:]  # Exclude depot
        nearest_neighbors = np.argsort(distances_from_i)[:knn] + 1  # Get indices of nearest neighbors
        for j in nearest_neighbors:
            heuristics[i, j] += knn_weight
            heuristics[j, i] += knn_weight

    # Heuristic 6: Sparsification: zero out small heuristic values (Adaptive Threshold)
    threshold = threshold_factor * np.mean(np.abs(heuristics))  # Adaptive threshold based on absolute mean.
    heuristics[np.abs(heuristics) < threshold] = 0

    # Normalize (After Sparsification)
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```

```python
parameter_ranges = {
    'demand_penalty_factor': (0.0, 1.0),
    'depot_proximity_weight': (0.0, 1.0),
    'adaptive_pruning_distance_factor': (1.0, 2.0),
    'adaptive_pruning_demand_divisor': (2.0, 5.0),
    'angle_weight': (0.0, 1.0),
    'knn': (1.0, 10.0),
    'knn_weight': (0.0, 1.0),
    'threshold_factor': (0.0, 0.1),
    'depot_boost': (0.0, 1.0)
}
```
[2025-04-29 05:50:44,226][root][INFO] - Iteration 10: Running Code 0
[2025-04-29 05:50:49,988][root][INFO] - Iteration 10: Code Run 0 successful!
[2025-04-29 05:50:49,988][root][INFO] - Iteration 10: Running Code 1
[2025-04-29 05:50:55,877][root][INFO] - Iteration 10: Code Run 1 successful!
[2025-04-29 05:50:55,878][root][INFO] - Iteration 10: Running Code 2
[2025-04-29 05:51:01,732][root][INFO] - Iteration 10: Code Run 2 execution error!
[2025-04-29 05:51:01,733][root][INFO] - Iteration 10: Running Code 3
[2025-04-29 05:51:07,490][root][INFO] - Iteration 10: Code Run 3 execution error!
[2025-04-29 05:51:07,491][root][INFO] - Iteration 10: Running Code 4
[2025-04-29 05:51:13,406][root][INFO] - Iteration 10: Code Run 4 successful!
[2025-04-29 05:51:13,408][root][INFO] - Iteration 10, response_id 0: Objective value: inf
[2025-04-29 05:51:13,410][root][INFO] - Iteration 10, response_id 1: Objective value: inf
[2025-04-29 05:51:13,412][root][INFO] - Iteration 10, response_id 2: Objective value: inf
[2025-04-29 05:51:13,414][root][INFO] - Iteration 10, response_id 3: Objective value: inf
[2025-04-29 05:51:13,909][root][INFO] - Iteration 10, response_id 4: Objective value: inf
[2025-04-29 05:51:13,912][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:51:24,386][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:51:24,389][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:51:24,391][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:51:24,391][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:51:24,394][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:51:24,399][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  depot_boost: float = 0.4, detour_penalty_factor: float = 0.07,
                  adaptive_distance_threshold: float = 1.2, adaptive_demand_factor: float = 2.5,
                  angle_reward_weight: float = 0.12, k_nearest_neighbors: int = 10,
                  knn_promising_value: float = 0.15, sparsification_threshold_factor: float = 0.02,
                  depot_distance_adjustment: float = 0.03, small_value: float = 1e-9) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates demand, distance, depot proximity, angle considerations, k-NN intensification, and adaptive sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.
        depot_boost (float): Boost for edges connected to the depot. Default is 0.4.
        detour_penalty_factor (float): Penalty factor for detours from direct depot route. Default is 0.07.
        adaptive_distance_threshold (float): Threshold for adaptive pruning based on distance. Default is 1.2.
        adaptive_demand_factor (float): Factor for adaptive pruning based on demand. Default is 2.5.
        angle_reward_weight (float): Weight for rewarding edges based on angle from depot. Default is 0.12.
        k_nearest_neighbors (int): Number of nearest neighbors to consider for intensification. Default is 10.
        knn_promising_value (float): Extra value added to promising edges based on k-NN. Default is 0.15.
        sparsification_threshold_factor (float): Factor for adaptive sparsification threshold. Default is 0.02.
        depot_distance_adjustment (float): Adjustment factor for depot-node edge heuristic based on distance. Default is 0.03.
        small_value: Small value to avoid dividing zero

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Heuristic 1: Basic inverse distance (base heuristic)
    heuristics = 1 / (distance_matrix + small_value)

    # Heuristic 2: Demand and Capacity consideration
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue

            if i == depot_index and j != depot_index:
                if demands[j] > capacity:  # Directly prune edges that violate capacity constraint.
                    heuristics[i, j] = 0
                else:
                    heuristics[i, j] += depot_boost  # Depot boost (slightly increased)
            elif j == depot_index and i != depot_index:
                heuristics[i, j] = 0 # No direct routes back to depot except *from* depot


    # Heuristic 3: Depot proximity with adaptive pruning (refined)
    depot_distances = distance_matrix[:, depot_index]
    mean_depot_distance = np.mean(depot_distances)

    for i in range(n):
        for j in range(n):
            if i != depot_index and j != depot_index:
                # Penalize edges based on detour from direct depot route.
                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + small_value)
                heuristics[i, j] -= detour_penalty_factor * detour_penalty  # Increased penalty

                # Adaptive pruning based on demand and distance.
                if distance_matrix[i, j] > adaptive_distance_threshold * np.mean(distance_matrix) and demands[i] + demands[j] > capacity / adaptive_demand_factor: #Tuned parameters
                    heuristics[i, j] = 0


    # Heuristic 4: Angle from Depot (more robust angle heuristic)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                # Dot product to find the cosine of the angle between vectors
                vector_i = coordinates[i] - coordinates[depot_index]
                vector_j = coordinates[j] - coordinates[depot_index]

                norm_i = np.linalg.norm(vector_i)
                norm_j = np.linalg.norm(vector_j)

                if norm_i > 0 and norm_j > 0:
                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)
                    # Convert cosine to angle in radians
                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Ensure within valid range

                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value
                    heuristics[i, j] += angle_reward_weight * (1 - angle / np.pi)  # Normalized angle reward, increased weight


    # Heuristic 5: k-NN intensification (focus on nearest neighbors)
    k = min(k_nearest_neighbors, n - 1)  # Number of neighbors
    for i in range(1, n):
        # Find k-nearest neighbors of node i (excluding itself)
        distances_i = distance_matrix[i, 1:]  # Distances to other nodes
        nearest_neighbors = np.argsort(distances_i)[:k] + 1  # Indices of k-NN

        for j in range(1, n):
            if i != j and j in nearest_neighbors:
                heuristics[i, j] += knn_promising_value # Add some extra promising value


    # Heuristic 6: Sparsification: zero out small heuristic values (adaptive thresholding)
    threshold = sparsification_threshold_factor * np.mean(heuristics)  # Adaptive threshold (tuned)
    heuristics[heuristics < threshold] = 0


    # Heuristic 7: Refine Depot-Specific Adjustments
    for i in range(1,n):
        heuristics[depot_index,i] = max(0, heuristics[depot_index,i] - depot_distance_adjustment*distance_matrix[depot_index, i]/mean_depot_distance) #Adjust edge depot-node by distance
        heuristics[i, depot_index] = 0

    # Normalize
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```

```python
parameter_ranges = {
    "depot_boost": (0.0, 1.0),
    "detour_penalty_factor": (0.0, 0.5),
    "adaptive_distance_threshold": (0.5, 2.0),
    "adaptive_demand_factor": (1.0, 5.0),
    "angle_reward_weight": (0.0, 0.5),
    "k_nearest_neighbors": (1, 20),
    "knn_promising_value": (0.0, 0.5),
    "sparsification_threshold_factor": (0.0, 0.1),
    "depot_distance_adjustment": (0.0, 0.1),
    "small_value": (1e-10, 1e-6)
}
```
[2025-04-29 05:51:24,412][root][INFO] - Iteration 10: Running Code 0
[2025-04-29 05:51:30,109][root][INFO] - Iteration 10: Code Run 0 successful!
[2025-04-29 05:51:30,109][root][INFO] - Iteration 10: Running Code 1
[2025-04-29 05:51:35,893][root][INFO] - Iteration 10: Code Run 1 successful!
[2025-04-29 05:51:35,894][root][INFO] - Iteration 10: Running Code 2
[2025-04-29 05:51:41,495][root][INFO] - Iteration 10: Code Run 2 successful!
[2025-04-29 05:51:41,496][root][INFO] - Iteration 10: Running Code 3
[2025-04-29 05:51:47,313][root][INFO] - Iteration 10: Code Run 3 successful!
[2025-04-29 05:51:47,314][root][INFO] - Iteration 10: Running Code 4
[2025-04-29 05:51:53,011][root][INFO] - Iteration 10: Code Run 4 successful!
[2025-04-29 05:51:53,013][root][INFO] - Iteration 10, response_id 0: Objective value: inf
[2025-04-29 05:51:53,014][root][INFO] - Iteration 10, response_id 1: Objective value: inf
[2025-04-29 05:51:53,016][root][INFO] - Iteration 10, response_id 2: Objective value: inf
[2025-04-29 05:51:53,018][root][INFO] - Iteration 10, response_id 3: Objective value: inf
[2025-04-29 05:51:53,503][root][INFO] - Iteration 10, response_id 4: Objective value: inf
[2025-04-29 05:51:53,506][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:52:10,349][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:52:10,352][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:52:10,354][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:10,354][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:10,357][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:10,362][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  depot_boost_weight: float = 0.4, detour_penalty_weight: float = 0.07,
                  adaptive_pruning_distance_multiplier: float = 1.2, adaptive_pruning_demand_divisor: float = 3.0,
                  angle_reward_weight: float = 0.15, knn_k: int = 10, knn_boost_weight: float = 0.08,
                  sparsification_threshold_multiplier: float = 0.008, small_number: float = 1e-9) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates demand, distance, depot proximity, and angle considerations with adaptive sparsification,
    k-NN intensification, and refined components.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.
        depot_boost_weight (float): Weight for boosting edges connected to the depot. Default is 0.4.
        detour_penalty_weight (float): Weight for penalizing detours from the direct depot route. Default is 0.07.
        adaptive_pruning_distance_multiplier (float): Multiplier for the mean distance in adaptive pruning. Default is 1.2.
        adaptive_pruning_demand_divisor (float): Divisor for capacity in adaptive pruning based on demand. Default is 3.0.
        angle_reward_weight (float): Weight for rewarding edges based on the angle from the depot. Default is 0.15.
        knn_k (int): Number of nearest neighbors to consider for k-NN intensification. Default is 10.
        knn_boost_weight (float): Weight for boosting edges connected to k-nearest neighbors. Default is 0.08.
        sparsification_threshold_multiplier (float): Multiplier for the mean heuristic value in sparsification. Default is 0.008.
        small_number(float): A small number to prevent division by zero

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Heuristic 1: Basic inverse distance
    heuristics = 1 / (distance_matrix + small_number)

    # Heuristic 2: Demand and Capacity consideration
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue

            if i == depot_index and j != depot_index:
                if demands[j] > capacity:  # Directly prune edges that violate capacity constraint.
                    heuristics[i, j] = 0
                else:
                    heuristics[i, j] += depot_boost_weight  # Depot boost, increased weight

            if j == depot_index and i != depot_index:
                heuristics[i,j] = 0 # No edge to the depot.

    # Heuristic 3: Depot proximity with adaptive pruning
    depot_distances = distance_matrix[:, depot_index]
    mean_depot_distance = np.mean(depot_distances)

    for i in range(n):
        for j in range(n):
            if i != depot_index and j != depot_index:
                # Penalize edges based on detour from direct depot route.  Simpler calculation.
                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + small_number)
                heuristics[i, j] -= detour_penalty_weight * detour_penalty  # Reduced weight

                # Adaptive pruning based on demand and distance.  Less aggressive than v1.
                if distance_matrix[i, j] > adaptive_pruning_distance_multiplier * np.mean(distance_matrix) and demands[i] + demands[j] > capacity / adaptive_pruning_demand_divisor:  # Only prune if nodes have considerable demand compared to vehicle capacity. Increased distance multiplier.
                    heuristics[i, j] = 0

    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                # Dot product to find the cosine of the angle between vectors
                vector_i = coordinates[i] - coordinates[depot_index]
                vector_j = coordinates[j] - coordinates[depot_index]

                norm_i = np.linalg.norm(vector_i)
                norm_j = np.linalg.norm(vector_j)

                if norm_i > 0 and norm_j > 0:
                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)
                    # Convert cosine to angle in radians
                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Ensure within valid range

                    # Prefer edges where nodes are in similar direction from depot. Smaller angle -> higher heuristic value
                    heuristics[i, j] += angle_reward_weight * (1 - angle / np.pi)  # Normalized angle reward, increased weight

    # Heuristic 5: k-NN intensification (Focuses on local neighborhood connectivity)
    k = min(knn_k, n - 1)  # Limit k to prevent issues with small n
    for i in range(1, n):
        # Find k-nearest neighbors of node i (excluding itself)
        distances_i = distance_matrix[i, 1:]  # Exclude depot distance
        nearest_neighbors = np.argsort(distances_i)[:k] + 1  # Get indices of k nearest neighbors, add 1 to offset depot exclusion

        for neighbor in nearest_neighbors:
            if i != neighbor:
                heuristics[i, neighbor] += knn_boost_weight  # Small boost to neighbors, reduced weight
                heuristics[neighbor, i] += knn_boost_weight  # Ensure symmetry

    # Heuristic 6: Sparsification: zero out small heuristic values. Adaptive threshold, more aggressive.
    threshold = sparsification_threshold_multiplier * np.mean(heuristics)  # Adaptive threshold, reduced multiplier
    heuristics[heuristics < threshold] = 0

    # Normalize
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```

```python
parameter_ranges = {
    "depot_boost_weight": (0.0, 1.0),
    "detour_penalty_weight": (0.0, 0.5),
    "adaptive_pruning_distance_multiplier": (0.5, 2.0),
    "adaptive_pruning_demand_divisor": (1.0, 5.0),
    "angle_reward_weight": (0.0, 0.5),
    "knn_k": (1, 20),
    "knn_boost_weight": (0.0, 0.2),
    "sparsification_threshold_multiplier": (0.0, 0.01),
    "small_number": (1e-10, 1e-6)
}
```
[2025-04-29 05:52:10,378][root][INFO] - Iteration 10: Running Code 0
[2025-04-29 05:52:16,092][root][INFO] - Iteration 10: Code Run 0 execution error!
[2025-04-29 05:52:16,092][root][INFO] - Iteration 10: Running Code 1
[2025-04-29 05:52:21,889][root][INFO] - Iteration 10: Code Run 1 successful!
[2025-04-29 05:52:21,889][root][INFO] - Iteration 10: Running Code 2
[2025-04-29 05:52:27,683][root][INFO] - Iteration 10: Code Run 2 execution error!
[2025-04-29 05:52:27,683][root][INFO] - Iteration 10: Running Code 3
[2025-04-29 05:52:33,484][root][INFO] - Iteration 10: Code Run 3 execution error!
[2025-04-29 05:52:33,484][root][INFO] - Iteration 10: Running Code 4
[2025-04-29 05:52:39,127][root][INFO] - Iteration 10: Code Run 4 execution error!
[2025-04-29 05:52:39,129][root][INFO] - Iteration 10, response_id 0: Objective value: inf
[2025-04-29 05:52:39,130][root][INFO] - Iteration 10, response_id 1: Objective value: inf
[2025-04-29 05:52:39,132][root][INFO] - Iteration 10, response_id 2: Objective value: inf
[2025-04-29 05:52:39,133][root][INFO] - Iteration 10, response_id 3: Objective value: inf
[2025-04-29 05:52:39,623][root][INFO] - Iteration 10, response_id 4: Objective value: inf
[2025-04-29 05:52:39,624][root][INFO] - Iteration 10 finished...
[2025-04-29 05:52:39,624][root][INFO] - Best obj: 9.981625510701699, Best Code Path: problem_iter9_code3.py
[2025-04-29 05:52:39,624][root][INFO] - LLM usage: prompt_tokens = 117478, completion_tokens = 45159
[2025-04-29 05:52:39,625][root][INFO] - Function Evals: 76
[2025-04-29 05:52:39,626][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:52:43,985][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:52:43,986][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:52:43,987][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:43,987][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:43,989][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:44,022][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:52:46,054][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:52:46,056][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:52:46,057][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:46,057][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:46,058][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:46,095][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:52:46,112][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:52:52,147][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:52:52,151][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:52:52,152][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:52,152][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:52,155][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:52:52,156][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:52,260][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:52:52,261][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:52:52,262][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:52,262][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:52,263][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:52:52,264][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:57,800][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:52:57,803][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:52:57,804][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:57,805][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:57,807][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:52:57,809][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:58,080][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:52:58,082][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:52:58,082][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:58,082][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:52:58,083][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:52:58,084][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:03,864][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:53:03,867][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:53:03,868][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:03,869][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:03,871][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:53:03,873][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:04,612][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:53:04,614][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:53:04,616][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:04,616][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:04,618][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:04,620][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:53:09,421][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:53:09,424][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:53:09,426][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:09,426][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:09,428][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:53:09,430][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:10,126][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:53:10,127][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:53:10,128][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:10,128][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:10,129][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:53:10,130][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:14,089][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:53:14,092][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:53:14,093][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:14,093][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:14,094][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:14,151][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:53:14,152][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:53:14,153][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:14,153][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:14,154][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:53:14,187][root][INFO] - Iteration 11: Running Code 0
[2025-04-29 05:53:19,956][root][INFO] - Iteration 11: Code Run 0 successful!
[2025-04-29 05:53:19,956][root][INFO] - Iteration 11: Running Code 1
[2025-04-29 05:53:26,804][root][INFO] - Iteration 11: Code Run 1 successful!
[2025-04-29 05:53:26,804][root][INFO] - Iteration 11: Running Code 2
[2025-04-29 05:53:34,636][root][INFO] - Iteration 11: Code Run 2 successful!
[2025-04-29 05:53:34,636][root][INFO] - Iteration 11: Running Code 3
[2025-04-29 05:53:42,735][root][INFO] - Iteration 11: Code Run 3 successful!
[2025-04-29 05:53:42,736][root][INFO] - Iteration 11: Running Code 4
[2025-04-29 05:53:51,226][root][INFO] - Iteration 11: Code Run 4 successful!
[2025-04-29 05:53:51,226][root][INFO] - Iteration 11: Running Code 5
[2025-04-29 05:54:00,560][root][INFO] - Iteration 11: Code Run 5 successful!
[2025-04-29 05:54:00,560][root][INFO] - Iteration 11: Running Code 6
[2025-04-29 05:54:10,462][root][INFO] - Iteration 11: Code Run 6 successful!
[2025-04-29 05:54:10,462][root][INFO] - Iteration 11: Running Code 7
[2025-04-29 05:54:20,439][root][INFO] - Iteration 11: Code Run 7 successful!
[2025-04-29 05:54:20,439][root][INFO] - Iteration 11: Running Code 8
[2025-04-29 05:54:30,559][root][INFO] - Iteration 11: Code Run 8 successful!
[2025-04-29 05:54:30,559][root][INFO] - Iteration 11: Running Code 9
[2025-04-29 05:54:40,830][root][INFO] - Iteration 11: Code Run 9 successful!
[2025-04-29 05:54:40,842][root][INFO] - Iteration 11, response_id 0: Objective value: 10.189860691433685
[2025-04-29 05:54:40,857][root][INFO] - Iteration 11, response_id 1: Objective value: 10.31832604041077
[2025-04-29 05:54:40,869][root][INFO] - Iteration 11, response_id 2: Objective value: 11.375904220326941
[2025-04-29 05:54:44,534][root][INFO] - Iteration 11, response_id 3: Objective value: 10.04190150303541
[2025-04-29 05:54:57,112][root][INFO] - Iteration 11, response_id 4: Objective value: 10.1171993024281
[2025-04-29 05:55:08,579][root][INFO] - Iteration 11, response_id 5: Objective value: 11.335461386041548
[2025-04-29 05:55:12,711][root][INFO] - Iteration 11, response_id 6: Objective value: 10.405186604003083
[2025-04-29 05:55:18,549][root][INFO] - Iteration 11, response_id 7: Objective value: 11.287624820945515
[2025-04-29 05:55:30,988][root][INFO] - Iteration 11, response_id 8: Objective value: 18.583986316643774
[2025-04-29 05:55:32,394][root][INFO] - Iteration 11, response_id 9: Objective value: 14.128133490452768
[2025-04-29 05:55:32,396][root][INFO] - Iteration 11 finished...
[2025-04-29 05:55:32,396][root][INFO] - Best obj: 9.981625510701699, Best Code Path: problem_iter9_code3.py
[2025-04-29 05:55:32,396][root][INFO] - LLM usage: prompt_tokens = 157049, completion_tokens = 52422
[2025-04-29 05:55:32,397][root][INFO] - Function Evals: 86
[2025-04-29 05:55:32,400][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:55:32,401][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:55:42,659][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:55:42,662][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:55:42,663][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:55:42,664][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:55:42,666][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:55:42,668][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:55:44,740][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:55:44,744][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:55:44,745][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:55:44,745][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:55:44,748][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:55:44,749][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:55:52,724][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:55:52,726][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:55:52,727][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:55:52,727][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:55:52,728][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:55:52,729][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:55:53,122][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:55:53,124][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:55:53,125][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:55:53,125][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:55:53,126][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:56:03,145][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:56:03,147][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:56:03,149][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:56:03,149][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:56:03,152][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:56:03,175][root][INFO] - Iteration 12: Running Code 0
[2025-04-29 05:56:09,030][root][INFO] - Iteration 12: Code Run 0 successful!
[2025-04-29 05:56:09,030][root][INFO] - Iteration 12: Running Code 1
[2025-04-29 05:56:15,888][root][INFO] - Iteration 12: Code Run 1 successful!
[2025-04-29 05:56:15,889][root][INFO] - Iteration 12: Running Code 2
[2025-04-29 05:56:23,699][root][INFO] - Iteration 12: Code Run 2 successful!
[2025-04-29 05:56:23,700][root][INFO] - Iteration 12: Running Code 3
[2025-04-29 05:56:31,887][root][INFO] - Iteration 12: Code Run 3 successful!
[2025-04-29 05:56:31,887][root][INFO] - Iteration 12: Running Code 4
[2025-04-29 05:56:40,324][root][INFO] - Iteration 12: Code Run 4 successful!
[2025-04-29 05:56:45,579][root][INFO] - Iteration 12, response_id 0: Objective value: 10.055799640268692
[2025-04-29 05:56:54,426][root][INFO] - Iteration 12, response_id 1: Objective value: 10.38534272232526
[2025-04-29 05:57:00,419][root][INFO] - Iteration 12, response_id 2: Objective value: 9.956565191737711
[2025-04-29 05:57:08,267][root][INFO] - Iteration 12, response_id 3: Objective value: 11.38166757970696
[2025-04-29 05:57:12,652][root][INFO] - Iteration 12, response_id 4: Objective value: 10.139035360940591
[2025-04-29 05:57:12,653][root][INFO] - Iteration 12: Elitist: 9.956565191737711
[2025-04-29 05:57:12,653][root][INFO] - Iteration 12 finished...
[2025-04-29 05:57:12,654][root][INFO] - Best obj: 9.956565191737711, Best Code Path: problem_iter12_code2.py
[2025-04-29 05:57:12,654][root][INFO] - LLM usage: prompt_tokens = 158763, completion_tokens = 54001
[2025-04-29 05:57:12,654][root][INFO] - Function Evals: 91
[2025-04-29 05:57:12,657][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:57:23,685][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:57:23,690][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:57:23,691][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:57:23,692][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:57:23,694][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:57:23,699][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                   demand_penalty_factor: float = 0.6, depot_boost: float = 0.7, depot_proximity_weight: float = 0.2,
                   angle_weight: float = 0.3, knn: int = 7, knn_weight: float = 0.2, route_length_weight: float = 0.1,
                   threshold_factor: float = 0.03, adaptive_pruning_factor: float = 1.1) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates demand, distance, depot proximity, angle considerations, k-NN intensification,
    and adaptive sparsification with more refined components and weight tuning. It also adds a route length
    estimation penalty and refines the k-NN selection and sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.
        demand_penalty_factor (float): Weight for demand penalty.
        depot_boost (float): Boost for edges from depot.
        depot_proximity_weight (float): Weight for depot proximity.
        angle_weight (float): Weight for angle from depot.
        knn (int): Number of nearest neighbors for k-NN intensification.
        knn_weight (float): Weight for k-NN intensification.
        route_length_weight (float): Weight for route length penalty.
        threshold_factor (float): Factor for adaptive threshold.
        adaptive_pruning_factor (float): Factor for adaptive pruning based on distance.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Heuristic 1: Basic inverse distance (with a slight modification)
    distance_scaling = np.mean(distance_matrix)
    heuristics = distance_scaling / (distance_matrix + 1e-9)  # Use scaling directly in the division

    # Heuristic 2: Demand and Capacity consideration
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue

            if i == depot_index and j != depot_index:
                if demands[j] > capacity:  # Directly prune edges that violate capacity constraint.
                    heuristics[i, j] = 0
                else:
                    heuristics[i, j] += depot_boost  # Depot boost (increased)
            elif i != depot_index and j != depot_index:
                demand_ratio = (demands[i] + demands[j]) / capacity
                demand_penalty = demand_penalty_factor * demand_ratio**1.5 # Higher power to amplify penalty for large demand
                heuristics[i, j] -= demand_penalty

    # Heuristic 3: Depot proximity with adaptive pruning
    depot_distances = distance_matrix[:, depot_index]
    mean_depot_distance = np.mean(depot_distances)

    for i in range(n):
        for j in range(n):
            if i != depot_index and j == depot_index:
                heuristics[i, j] = 0  # Remove edges to depot (except from depot)
            elif i != depot_index and j != depot_index:
                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)
                heuristics[i, j] -= depot_proximity_weight * detour_penalty

                # Adaptive pruning based on demand and distance - more aggressive
                if distance_matrix[i, j] > adaptive_pruning_factor * distance_scaling and demands[i] + demands[j] > capacity / 2:
                    heuristics[i, j] = 0

    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                vector_i = coordinates[i] - coordinates[depot_index]
                vector_j = coordinates[j] - coordinates[depot_index]

                norm_i = np.linalg.norm(vector_i)
                norm_j = np.linalg.norm(vector_j)

                if norm_i > 0 and norm_j > 0:
                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)
                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))

                    heuristics[i, j] += angle_weight * (1 - angle / np.pi)**2  # Favor smaller angles even more

    # Heuristic 5: k-NN intensification (Focus on local search) - Refined k-NN selection
    knn = min(knn, n - 1)  # Adjusted k-NN, ensure knn < n-1

    for i in range(1, n):
        # Find k-nearest neighbors based on distance, excluding depot.
        distances_from_i = distance_matrix[i, 1:]
        nearest_neighbors = np.argsort(distances_from_i)[:knn] + 1  # Correctly offset indices

        # Demand aware k-NN selection.
        demand_neighbors = []
        for neighbor in nearest_neighbors:
            if demands[i] + demands[neighbor] <= capacity:
                demand_neighbors.append(neighbor)

        # No neighbors satisfying demand constraint.
        if len(demand_neighbors) == 0:
            for j in nearest_neighbors:
                heuristics[i, j] += knn_weight/2.0
                heuristics[j, i] += knn_weight/2.0
            continue # Move to the next i

        for j in demand_neighbors:
            heuristics[i, j] += knn_weight
            heuristics[j, i] += knn_weight

    # Heuristic 6: Route length estimation and penalty

    for i in range(1,n):
        for j in range(1,n):
            if i != j:
                #Estimate the route length if edge (i,j) included. Simplified estimation.
                estimated_route_length = distance_matrix[depot_index, i] + distance_matrix[i,j] + distance_matrix[j, depot_index]
                heuristics[i,j] -= route_length_weight * estimated_route_length / (3 * distance_scaling + 1e-9)

    # Heuristic 7: Sparsification: zero out small heuristic values (Adaptive Threshold) - Refined Sparsification
    threshold = threshold_factor * np.std(heuristics) #Adaptive threshold uses standard deviation
    heuristics[heuristics < threshold] = 0 #Sparsify only based on values smaller than threshold

    # Normalize (After Sparsification)
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```

```python
parameter_ranges = {
    'demand_penalty_factor': (0.0, 1.0),
    'depot_boost': (0.0, 1.0),
    'depot_proximity_weight': (0.0, 1.0),
    'angle_weight': (0.0, 1.0),
    'knn': (1.0, 10.0),
    'knn_weight': (0.0, 1.0),
    'route_length_weight': (0.0, 1.0),
    'threshold_factor': (0.0, 0.1),
    'adaptive_pruning_factor': (1.0, 2.0)
}
```
[2025-04-29 05:57:23,718][root][INFO] - Iteration 13: Running Code 0
[2025-04-29 05:57:29,361][root][INFO] - Iteration 13: Code Run 0 execution error!
[2025-04-29 05:57:29,361][root][INFO] - Iteration 13: Running Code 1
[2025-04-29 05:57:34,926][root][INFO] - Iteration 13: Code Run 1 execution error!
[2025-04-29 05:57:34,927][root][INFO] - Iteration 13: Running Code 2
[2025-04-29 05:57:40,588][root][INFO] - Iteration 13: Code Run 2 execution error!
[2025-04-29 05:57:40,588][root][INFO] - Iteration 13: Running Code 3
[2025-04-29 05:57:46,112][root][INFO] - Iteration 13: Code Run 3 execution error!
[2025-04-29 05:57:46,112][root][INFO] - Iteration 13: Running Code 4
[2025-04-29 05:57:51,817][root][INFO] - Iteration 13: Code Run 4 execution error!
[2025-04-29 05:57:51,818][root][INFO] - Iteration 13, response_id 0: Objective value: inf
[2025-04-29 05:57:51,820][root][INFO] - Iteration 13, response_id 1: Objective value: inf
[2025-04-29 05:57:51,821][root][INFO] - Iteration 13, response_id 2: Objective value: inf
[2025-04-29 05:57:51,823][root][INFO] - Iteration 13, response_id 3: Objective value: inf
[2025-04-29 05:57:52,315][root][INFO] - Iteration 13, response_id 4: Objective value: inf
[2025-04-29 05:57:52,317][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:57:59,864][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:57:59,866][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:57:59,867][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:57:59,867][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:57:59,868][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:57:59,869][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  inverse_distance_weight: float = 0.4, depot_boost_weight: float = 0.2,
                  detour_penalty_weight: float = 0.1, long_edge_threshold_factor: float = 1.5,
                  angle_weight: float = 0.15, knn_count: int = 5, knn_weight: float = 0.05,
                  depot_connection_weight: float = 0.05, sparsification_threshold_factor: float = 0.005) -> np.ndarray:
    """Combines distance, demand, depot proximity, angle, k-NN, and adaptive sparsification."""
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Inverse distance
    heuristics += inverse_distance_weight / (distance_matrix + 1e-9)

    # Demand-aware pruning and depot boost
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue
            if i == depot_index and j != depot_index:
                if demands[j] > capacity:
                    heuristics[i, j] = 0  # Infeasible edge
                else:
                    heuristics[i,j] += depot_boost_weight

    # Depot proximity
    depot_distances = distance_matrix[:, depot_index]
    mean_depot_distance = np.mean(depot_distances)

    for i in range(n):
        for j in range(n):
            if i != depot_index and j == depot_index:
                heuristics[i, j] = 0
            elif i != depot_index and j != depot_index:
                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2*mean_depot_distance + 1e-9)
                heuristics[i, j] -= detour_penalty_weight * detour_penalty
                if distance_matrix[i, j] > long_edge_threshold_factor*np.mean(distance_matrix) and demands[i] + demands[j] > capacity/2:
                    heuristics[i,j] = 0

    # Angle from Depot
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                vector_i = coordinates[i] - coordinates[depot_index]
                vector_j = coordinates[j] - coordinates[depot_index]

                norm_i = np.linalg.norm(vector_i)
                norm_j = np.linalg.norm(vector_j)

                if norm_i > 0 and norm_j > 0:
                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)
                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))
                    heuristics[i,j] += angle_weight * (1 - angle / np.pi)

    # k-NN intensification
    k = min(knn_count, n - 1)
    for i in range(n):
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k+1]

        for neighbor in nearest_neighbors:
            if i != neighbor:
                heuristics[i, neighbor] += knn_weight

    # Depot connection preference
    for i in range(1, n):
        heuristics[depot_index, i] += depot_connection_weight
        heuristics[i, depot_index] = 0

    # Sparsification
    threshold = sparsification_threshold_factor * np.mean(heuristics)
    heuristics[heuristics < threshold] = 0

    # Normalization
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```

```python
parameter_ranges = {
    'inverse_distance_weight': (0.0, 1.0),
    'depot_boost_weight': (0.0, 1.0),
    'detour_penalty_weight': (0.0, 1.0),
    'long_edge_threshold_factor': (1.0, 2.5),
    'angle_weight': (0.0, 1.0),
    'knn_count': (1.0, 10.0),
    'knn_weight': (0.0, 1.0),
    'depot_connection_weight': (0.0, 1.0),
    'sparsification_threshold_factor': (0.0, 0.01)
}
```
[2025-04-29 05:57:59,879][root][INFO] - Iteration 13: Running Code 0
[2025-04-29 05:58:05,446][root][INFO] - Iteration 13: Code Run 0 execution error!
[2025-04-29 05:58:05,447][root][INFO] - Iteration 13: Running Code 1
[2025-04-29 05:58:11,123][root][INFO] - Iteration 13: Code Run 1 execution error!
[2025-04-29 05:58:11,123][root][INFO] - Iteration 13: Running Code 2
[2025-04-29 05:58:16,788][root][INFO] - Iteration 13: Code Run 2 successful!
[2025-04-29 05:58:16,789][root][INFO] - Iteration 13: Running Code 3
[2025-04-29 05:58:22,663][root][INFO] - Iteration 13: Code Run 3 successful!
[2025-04-29 05:58:22,663][root][INFO] - Iteration 13: Running Code 4
[2025-04-29 05:58:28,346][root][INFO] - Iteration 13: Code Run 4 successful!
[2025-04-29 05:58:28,348][root][INFO] - Iteration 13, response_id 0: Objective value: inf
[2025-04-29 05:58:28,349][root][INFO] - Iteration 13, response_id 1: Objective value: inf
[2025-04-29 05:58:28,351][root][INFO] - Iteration 13, response_id 2: Objective value: inf
[2025-04-29 05:58:28,353][root][INFO] - Iteration 13, response_id 3: Objective value: inf
[2025-04-29 05:58:28,848][root][INFO] - Iteration 13, response_id 4: Objective value: inf
[2025-04-29 05:58:28,850][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:58:34,589][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:58:34,592][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:58:34,594][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:58:34,594][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:58:34,597][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:58:34,599][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                   inverse_distance_epsilon: float = 1e-9, depot_boost: float = 0.7, depot_return: float = 0.3,
                   depot_proximity_weight: float = 0.2, k_nearest_neighbors: int = 4, knn_bonus: float = 0.3,
                   sparsification_threshold_multiplier: float = 1.5) -> np.ndarray:
    """Combines distance, demand, depot proximity, k-NN, and sparsification."""
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # 1. Inverse distance
    inverse_distance = 1 / (distance_matrix + inverse_distance_epsilon)
    heuristics += inverse_distance

    # 2. Demand consideration and depot boost/prune
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue
            if i == depot_index and j != depot_index:
                if demands[j] > capacity:
                    heuristics[i, j] = 0  # Prune infeasible edges from depot
                else:
                    heuristics[i, j] += depot_boost  # depot boost
            elif i != depot_index and j == depot_index:
                heuristics[i, j] += depot_return

    # 3. Depot proximity consideration.
    depot_distances = distance_matrix[:, depot_index]
    mean_depot_distance = np.mean(depot_distances) + inverse_distance_epsilon
    for i in range(n):
        if i != depot_index:
            heuristics[i, depot_index] += depot_proximity_weight * (1 / (depot_distances[i] + inverse_distance_epsilon))
            
    # 4. K-Nearest Neighbor Bonus
    for i in range(n):
        neighbors_idx = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors + 1]
        for neighbor in neighbors_idx:
            heuristics[i, neighbor] += knn_bonus
            
    # 5. Adaptive Sparsification based on mean and demand
    mean_heuristic = np.mean(heuristics)
    for i in range(n):
        for j in range(n):
            combined_metric = distance_matrix[i, j] * demands[j]
            threshold = np.mean(distance_matrix) * np.mean(demands) * sparsification_threshold_multiplier
            if heuristics[i, j] < mean_heuristic or combined_metric > threshold:
                heuristics[i, j] = 0

    # 6. Normalization
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```

```python
parameter_ranges = {
    "inverse_distance_epsilon": (1e-10, 1e-6),
    "depot_boost": (0.5, 1.0),
    "depot_return": (0.1, 0.5),
    "depot_proximity_weight": (0.1, 0.5),
    "k_nearest_neighbors": (2.0, 10.0),
    "knn_bonus": (0.1, 0.5),
    "sparsification_threshold_multiplier": (1.0, 2.0),
}
```
[2025-04-29 05:58:34,609][root][INFO] - Iteration 13: Running Code 0
[2025-04-29 05:58:36,706][root][INFO] - Iteration 13: Code Run 0 execution error!
[2025-04-29 05:58:36,706][root][INFO] - Iteration 13: Running Code 1
[2025-04-29 05:58:38,844][root][INFO] - Iteration 13: Code Run 1 execution error!
[2025-04-29 05:58:38,844][root][INFO] - Iteration 13: Running Code 2
[2025-04-29 05:58:40,865][root][INFO] - Iteration 13: Code Run 2 execution error!
[2025-04-29 05:58:40,865][root][INFO] - Iteration 13: Running Code 3
[2025-04-29 05:58:42,972][root][INFO] - Iteration 13: Code Run 3 execution error!
[2025-04-29 05:58:42,973][root][INFO] - Iteration 13: Running Code 4
[2025-04-29 05:58:45,017][root][INFO] - Iteration 13: Code Run 4 execution error!
[2025-04-29 05:58:45,027][root][INFO] - Iteration 13, response_id 0: Objective value: inf
[2025-04-29 05:58:45,030][root][INFO] - Iteration 13, response_id 1: Objective value: inf
[2025-04-29 05:58:45,032][root][INFO] - Iteration 13, response_id 2: Objective value: inf
[2025-04-29 05:58:45,034][root][INFO] - Iteration 13, response_id 3: Objective value: inf
[2025-04-29 05:58:45,300][root][INFO] - Iteration 13, response_id 4: Objective value: inf
[2025-04-29 05:58:45,301][root][INFO] - Iteration 13 finished...
[2025-04-29 05:58:45,301][root][INFO] - Best obj: 9.956565191737711, Best Code Path: problem_iter12_code2.py
[2025-04-29 05:58:45,301][root][INFO] - LLM usage: prompt_tokens = 161929, completion_tokens = 57463
[2025-04-29 05:58:45,302][root][INFO] - Function Evals: 91
[2025-04-29 05:58:45,303][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:58:49,043][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:58:49,049][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:58:49,050][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:58:49,050][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:58:49,052][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:58:49,083][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:58:51,388][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:58:51,394][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:58:51,396][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:58:51,396][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:58:51,398][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:58:51,442][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:58:51,443][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:58:55,937][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:58:55,942][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:58:55,944][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:58:55,944][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:58:55,946][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:58:55,948][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:58:57,410][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:58:57,413][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:58:57,415][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:58:57,415][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:58:57,417][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:58:57,419][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:01,144][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:59:01,149][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:59:01,151][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:01,151][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:01,154][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:59:01,155][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:02,908][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:59:02,913][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:59:02,914][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:02,915][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:02,916][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:59:02,916][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:06,289][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:59:06,291][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:59:06,292][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:06,292][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:06,293][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:59:06,293][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:08,107][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:59:08,109][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:59:08,111][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:08,111][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:08,113][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:59:08,115][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:11,907][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:59:11,912][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:59:11,914][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:11,914][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:11,916][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:59:11,918][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:13,627][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:59:13,630][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:59:13,631][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:13,631][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:13,632][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 05:59:13,633][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:17,631][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:59:17,634][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:59:17,636][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:17,636][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:17,639][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 05:59:17,640][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:17,643][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 05:59:17,644][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:17,644][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:17,646][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 05:59:17,685][root][INFO] - Iteration 14: Running Code 0
[2025-04-29 05:59:23,210][root][INFO] - Iteration 14: Code Run 0 successful!
[2025-04-29 05:59:23,211][root][INFO] - Iteration 14: Running Code 1
[2025-04-29 05:59:29,934][root][INFO] - Iteration 14: Code Run 1 successful!
[2025-04-29 05:59:29,934][root][INFO] - Iteration 14: Running Code 2
[2025-04-29 05:59:37,741][root][INFO] - Iteration 14: Code Run 2 successful!
[2025-04-29 05:59:37,742][root][INFO] - Iteration 14: Running Code 3
[2025-04-29 05:59:45,758][root][INFO] - Iteration 14: Code Run 3 successful!
[2025-04-29 05:59:45,758][root][INFO] - Iteration 14: Running Code 4
[2025-04-29 05:59:54,042][root][INFO] - Iteration 14: Code Run 4 successful!
[2025-04-29 05:59:54,043][root][INFO] - Iteration 14: Running Code 5
[2025-04-29 06:00:03,320][root][INFO] - Iteration 14: Code Run 5 successful!
[2025-04-29 06:00:03,320][root][INFO] - Iteration 14: Running Code 6
[2025-04-29 06:00:12,658][root][INFO] - Iteration 14: Code Run 6 successful!
[2025-04-29 06:00:12,659][root][INFO] - Iteration 14: Running Code 7
[2025-04-29 06:00:22,436][root][INFO] - Iteration 14: Code Run 7 successful!
[2025-04-29 06:00:22,436][root][INFO] - Iteration 14: Running Code 8
[2025-04-29 06:00:32,282][root][INFO] - Iteration 14: Code Run 8 successful!
[2025-04-29 06:00:32,282][root][INFO] - Iteration 14: Running Code 9
[2025-04-29 06:00:42,637][root][INFO] - Iteration 14: Code Run 9 successful!
[2025-04-29 06:00:42,649][root][INFO] - Iteration 14, response_id 0: Objective value: 11.231080516494506
[2025-04-29 06:00:42,663][root][INFO] - Iteration 14, response_id 1: Objective value: 11.53102251910656
[2025-04-29 06:00:42,676][root][INFO] - Iteration 14, response_id 2: Objective value: 10.324437770298822
[2025-04-29 06:00:42,689][root][INFO] - Iteration 14, response_id 3: Objective value: 10.275363033499705
[2025-04-29 06:01:12,271][root][INFO] - Iteration 14, response_id 4: Objective value: 18.332245440525277
[2025-04-29 06:01:12,284][root][INFO] - Iteration 14, response_id 5: Objective value: 10.296343979530388
[2025-04-29 06:01:15,647][root][INFO] - Iteration 14, response_id 6: Objective value: 11.394240000291678
[2025-04-29 06:01:18,796][root][INFO] - Iteration 14, response_id 7: Objective value: 9.981960657679064
[2025-04-29 06:01:24,059][root][INFO] - Iteration 14, response_id 8: Objective value: 10.138109303047596
[2025-04-29 06:01:26,771][root][INFO] - Iteration 14, response_id 9: Objective value: 11.423018949384648
[2025-04-29 06:01:26,772][root][INFO] - Iteration 14 finished...
[2025-04-29 06:01:26,773][root][INFO] - Best obj: 9.956565191737711, Best Code Path: problem_iter12_code2.py
[2025-04-29 06:01:26,773][root][INFO] - LLM usage: prompt_tokens = 206376, completion_tokens = 65546
[2025-04-29 06:01:26,773][root][INFO] - Function Evals: 101
[2025-04-29 06:01:26,777][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:01:26,779][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:01:38,119][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:01:38,135][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:01:38,136][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:01:38,136][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:01:38,137][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:01:38,138][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:01:39,851][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:01:39,854][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:01:39,856][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:01:39,856][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:01:39,859][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:01:39,860][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:01:48,160][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:01:48,163][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:01:48,164][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:01:48,164][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:01:48,165][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:01:48,165][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:01:51,558][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:01:51,561][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:01:51,563][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:01:51,563][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:01:51,564][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:02:00,187][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:02:00,190][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:02:00,192][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:02:00,192][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:02:00,195][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:02:00,218][root][INFO] - Iteration 15: Running Code 0
[2025-04-29 06:02:05,943][root][INFO] - Iteration 15: Code Run 0 successful!
[2025-04-29 06:02:05,943][root][INFO] - Iteration 15: Running Code 1
[2025-04-29 06:02:12,720][root][INFO] - Iteration 15: Code Run 1 successful!
[2025-04-29 06:02:12,721][root][INFO] - Iteration 15: Running Code 2
[2025-04-29 06:02:20,526][root][INFO] - Iteration 15: Code Run 2 successful!
[2025-04-29 06:02:20,526][root][INFO] - Iteration 15: Running Code 3
[2025-04-29 06:02:28,572][root][INFO] - Iteration 15: Code Run 3 successful!
[2025-04-29 06:02:28,572][root][INFO] - Iteration 15: Running Code 4
[2025-04-29 06:02:37,682][root][INFO] - Iteration 15: Code Run 4 successful!
[2025-04-29 06:02:56,298][root][INFO] - Iteration 15, response_id 0: Objective value: 16.1375906683461
[2025-04-29 06:02:59,302][root][INFO] - Iteration 15, response_id 1: Objective value: 10.106057669781748
[2025-04-29 06:03:04,464][root][INFO] - Iteration 15, response_id 2: Objective value: 10.294574110668448
[2025-04-29 06:03:11,439][root][INFO] - Iteration 15, response_id 3: Objective value: 10.463042972415234
[2025-04-29 06:03:15,696][root][INFO] - Iteration 15, response_id 4: Objective value: 10.220440494345938
[2025-04-29 06:03:15,697][root][INFO] - Iteration 15 finished...
[2025-04-29 06:03:15,697][root][INFO] - Best obj: 9.956565191737711, Best Code Path: problem_iter12_code2.py
[2025-04-29 06:03:15,697][root][INFO] - LLM usage: prompt_tokens = 208320, completion_tokens = 67228
[2025-04-29 06:03:15,697][root][INFO] - Function Evals: 106
[2025-04-29 06:03:15,700][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:03:23,871][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:03:23,876][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:03:23,877][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:03:23,878][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:03:23,881][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:03:23,884][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                   demand_penalty_factor: float = 0.6, depot_proximity_weight: float = 0.2, 
                   angle_weight: float = 0.3, knn: int = 6, knn_weight: float = 0.2,
                   threshold_factor: float = 0.03, depot_boost: float = 0.6, detour_threshold_factor: float = 1.3, demand_capacity_ratio: float = 1/3) -> np.ndarray:
    """
    CVRP heuristic combining inverse distance, demand, depot proximity, angle, 
    k-NN, adaptive sparsification, and pheromone-inspired reinforcement.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Heuristic 1: Basic inverse distance (scaled)
    distance_scaling = np.mean(distance_matrix)
    heuristics = distance_scaling / (distance_matrix + 1e-9)

    # Heuristic 2: Demand and Capacity penalty
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue
            if i == depot_index and j != depot_index:
                if demands[j] > capacity:
                    heuristics[i, j] = 0
                else:
                    heuristics[i, j] += depot_boost #Depot boost
            elif i != depot_index and j != depot_index:
                demand_ratio = (demands[i] + demands[j]) / capacity
                demand_penalty = demand_penalty_factor * demand_ratio
                heuristics[i, j] -= demand_penalty

    # Heuristic 3: Depot proximity and adaptive pruning
    depot_distances = distance_matrix[:, depot_index]
    mean_depot_distance = np.mean(depot_distances)

    for i in range(n):
        for j in range(n):
            if i != depot_index and j == depot_index:
                heuristics[i, j] = 0
            elif i != depot_index and j != depot_index:
                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)
                heuristics[i, j] -= depot_proximity_weight * detour_penalty
                if distance_matrix[i, j] > detour_threshold_factor * distance_scaling and demands[i] + demands[j] > capacity * demand_capacity_ratio:
                    heuristics[i, j] = 0

    # Heuristic 4: Angle from Depot
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                vector_i = coordinates[i] - coordinates[depot_index]
                vector_j = coordinates[j] - coordinates[depot_index]
                norm_i = np.linalg.norm(vector_i)
                norm_j = np.linalg.norm(vector_j)
                if norm_i > 0 and norm_j > 0:
                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)
                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))
                    heuristics[i, j] += angle_weight * (1 - angle / np.pi)

    # Heuristic 5: k-NN intensification
    for i in range(1, n):
        distances_from_i = distance_matrix[i, 1:]
        nearest_neighbors = np.argsort(distances_from_i)[:knn] + 1
        for j in nearest_neighbors:
            heuristics[i, j] += knn_weight
            heuristics[j, i] += knn_weight
    
    # Heuristic 6: Adaptive Sparsification
    threshold = threshold_factor * np.mean(np.abs(heuristics))
    heuristics[np.abs(heuristics) < threshold] = 0

    # Normalize
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```

```python
parameter_ranges = {
    "demand_penalty_factor": (0.0, 1.0),
    "depot_proximity_weight": (0.0, 1.0),
    "angle_weight": (0.0, 1.0),
    "knn_weight": (0.0, 1.0),
    "threshold_factor": (0.0, 0.1),
    "depot_boost": (0.0, 1.0),
    "detour_threshold_factor": (1.0, 2.0),
    "demand_capacity_ratio": (0.0, 1.0),
    "knn": (1.0, 10.0)
}
```
[2025-04-29 06:03:23,900][root][INFO] - Iteration 16: Running Code 0
[2025-04-29 06:03:29,368][root][INFO] - Iteration 16: Code Run 0 execution error!
[2025-04-29 06:03:29,368][root][INFO] - Iteration 16: Running Code 1
[2025-04-29 06:03:35,016][root][INFO] - Iteration 16: Code Run 1 execution error!
[2025-04-29 06:03:35,017][root][INFO] - Iteration 16: Running Code 2
[2025-04-29 06:03:40,746][root][INFO] - Iteration 16: Code Run 2 execution error!
[2025-04-29 06:03:40,746][root][INFO] - Iteration 16: Running Code 3
[2025-04-29 06:03:46,404][root][INFO] - Iteration 16: Code Run 3 execution error!
[2025-04-29 06:03:46,404][root][INFO] - Iteration 16: Running Code 4
[2025-04-29 06:03:52,094][root][INFO] - Iteration 16: Code Run 4 successful!
[2025-04-29 06:03:52,095][root][INFO] - Iteration 16, response_id 0: Objective value: inf
[2025-04-29 06:03:52,097][root][INFO] - Iteration 16, response_id 1: Objective value: inf
[2025-04-29 06:03:52,098][root][INFO] - Iteration 16, response_id 2: Objective value: inf
[2025-04-29 06:03:52,099][root][INFO] - Iteration 16, response_id 3: Objective value: inf
[2025-04-29 06:03:52,585][root][INFO] - Iteration 16, response_id 4: Objective value: inf
[2025-04-29 06:03:52,589][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:04:06,820][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:04:06,824][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:04:06,826][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:04:06,826][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:04:06,829][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:04:06,833][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  demand_penalty_factor: float = 0.6, depot_proximity_weight: float = 0.2,
                  angle_weight: float = 0.3, knn_weight: float = 0.2, route_length_weight: float = 0.1,
                  threshold_factor_abs: float = 0.03, threshold_factor_rel: float = 0.10,
                  knn_min_neighbors: int = 3, knn_max_neighbors: int = 7,
                  depot_boost: float = 0.7, adaptive_pruning_factor: float = 1.1,
                  knn_initial_neighbors: int = 10) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates demand, distance, depot proximity, angle considerations, k-NN intensification,
    and adaptive sparsification with more refined components and weight tuning. It also adds a route length
    estimation penalty and refines the k-NN selection and sparsification. Furthermore, it adaptively adjusts
    the k-NN neighborhood size based on local demand density and uses a more robust sparsification strategy.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.
        demand_penalty_factor (float): Weight for demand penalty.
        depot_proximity_weight (float): Weight for depot proximity.
        angle_weight (float): Weight for angle from depot.
        knn_weight (float): Weight for k-NN intensification.
        route_length_weight (float): Weight for route length estimation.
        threshold_factor_abs (float): Absolute threshold factor for sparsification.
        threshold_factor_rel (float): Relative threshold factor for sparsification.
        knn_min_neighbors (int): Minimum number of neighbors for k-NN.
        knn_max_neighbors (int): Maximum number of neighbors for k-NN.
        depot_boost (float): Boost for edges from the depot.
        adaptive_pruning_factor (float): Factor for adaptive pruning based on distance.
        knn_initial_neighbors (int): Initial neighbors to consider for local demand density

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Heuristic 1: Basic inverse distance (with a slight modification)
    distance_scaling = np.mean(distance_matrix)
    heuristics = distance_scaling / (distance_matrix + 1e-9)  # Use scaling directly in the division

    # Heuristic 2: Demand and Capacity consideration
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue

            if i == depot_index and j != depot_index:
                if demands[j] > capacity:  # Directly prune edges that violate capacity constraint.
                    heuristics[i, j] = 0
                else:
                    heuristics[i, j] += depot_boost  # Depot boost (increased)
            elif i != depot_index and j != depot_index:
                demand_ratio = (demands[i] + demands[j]) / capacity
                demand_penalty = demand_penalty_factor * demand_ratio**1.5 # Higher power to amplify penalty for large demand
                heuristics[i, j] -= demand_penalty

    # Heuristic 3: Depot proximity with adaptive pruning
    depot_distances = distance_matrix[:, depot_index]
    mean_depot_distance = np.mean(depot_distances)

    for i in range(n):
        for j in range(n):
            if i != depot_index and j == depot_index:
                heuristics[i, j] = 0  # Remove edges to depot (except from depot)
            elif i != depot_index and j != depot_index:
                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)
                heuristics[i, j] -= depot_proximity_weight * detour_penalty

                # Adaptive pruning based on demand and distance - more aggressive
                if distance_matrix[i, j] > adaptive_pruning_factor * distance_scaling and demands[i] + demands[j] > capacity / 2:
                    heuristics[i, j] = 0

    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                vector_i = coordinates[i] - coordinates[depot_index]
                vector_j = coordinates[j] - coordinates[depot_index]

                norm_i = np.linalg.norm(vector_i)
                norm_j = np.linalg.norm(vector_j)

                if norm_i > 0 and norm_j > 0:
                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)
                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))

                    heuristics[i, j] += angle_weight * (1 - angle / np.pi)**2  # Favor smaller angles even more

    # Heuristic 5: k-NN intensification (Focus on local search) - Refined k-NN selection
    # Adaptive k-NN neighborhood size based on local demand density.
    for i in range(1, n):
        # Estimate local demand density (average demand of nearby nodes).
        distances_from_i = distance_matrix[i, 1:]
        nearest_neighbors = np.argsort(distances_from_i)[:min(knn_initial_neighbors, n - 1)] + 1
        local_demand_density = np.mean(demands[nearest_neighbors]) if len(nearest_neighbors) > 0 else 0

        # Adjust k-NN size based on density; higher density -> smaller k.
        knn = max(knn_min_neighbors, min(knn_max_neighbors, int(knn_max_neighbors * (1 - local_demand_density / capacity))))  # Ensure knn > 0
        knn = min(knn, n-1)

        # Find k-nearest neighbors based on distance, excluding depot.
        distances_from_i = distance_matrix[i, 1:]
        nearest_neighbors = np.argsort(distances_from_i)[:knn] + 1  # Correctly offset indices

        # Demand aware k-NN selection.
        demand_neighbors = []
        for neighbor in nearest_neighbors:
            if demands[i] + demands[neighbor] <= capacity:
                demand_neighbors.append(neighbor)

        # No neighbors satisfying demand constraint.
        if len(demand_neighbors) == 0:
            for j in nearest_neighbors:
                heuristics[i, j] += knn_weight/2.0
                heuristics[j, i] += knn_weight/2.0
            continue # Move to the next i

        for j in demand_neighbors:
            heuristics[i, j] += knn_weight
            heuristics[j, i] += knn_weight

    # Heuristic 6: Route length estimation and penalty
    for i in range(1,n):
        for j in range(1,n):
            if i != j:
                #Estimate the route length if edge (i,j) included. Simplified estimation.
                estimated_route_length = distance_matrix[depot_index, i] + distance_matrix[i,j] + distance_matrix[j, depot_index]
                heuristics[i,j] -= route_length_weight * estimated_route_length / (3 * distance_scaling + 1e-9)

    # Heuristic 7: Sparsification: zero out small heuristic values (Adaptive Threshold) - Refined Sparsification
    # Robust adaptive sparsification using a combination of absolute and relative thresholds.

    threshold_abs = threshold_factor_abs * np.std(heuristics)  # Adaptive threshold uses standard deviation
    threshold_rel = threshold_factor_rel * np.max(heuristics)   # Adaptive threshold relative to maximum value

    # Apply sparsification using the maximum of the two thresholds.
    threshold = max(threshold_abs, threshold_rel)

    heuristics[heuristics < threshold] = 0  # Sparsify only based on values smaller than threshold

    # Normalize (After Sparsification)
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```

```python
parameter_ranges = {
    'demand_penalty_factor': (0.1, 1.0),
    'depot_proximity_weight': (0.05, 0.5),
    'angle_weight': (0.05, 0.5),
    'knn_weight': (0.05, 0.5),
    'route_length_weight': (0.01, 0.2),
    'threshold_factor_abs': (0.01, 0.1),
    'threshold_factor_rel': (0.05, 0.2),
    'knn_min_neighbors': (1.0, 5.0),
    'knn_max_neighbors': (5.0, 15.0),
    'depot_boost': (0.1, 1.0),
    'adaptive_pruning_factor': (1.0, 1.5),
    'knn_initial_neighbors': (5.0, 20.0)
}
```
[2025-04-29 06:04:06,848][root][INFO] - Iteration 16: Running Code 0
[2025-04-29 06:04:12,480][root][INFO] - Iteration 16: Code Run 0 execution error!
[2025-04-29 06:04:12,481][root][INFO] - Iteration 16: Running Code 1
[2025-04-29 06:04:18,147][root][INFO] - Iteration 16: Code Run 1 execution error!
[2025-04-29 06:04:18,147][root][INFO] - Iteration 16: Running Code 2
[2025-04-29 06:04:23,975][root][INFO] - Iteration 16: Code Run 2 execution error!
[2025-04-29 06:04:23,976][root][INFO] - Iteration 16: Running Code 3
[2025-04-29 06:04:29,655][root][INFO] - Iteration 16: Code Run 3 successful!
[2025-04-29 06:04:29,655][root][INFO] - Iteration 16: Running Code 4
[2025-04-29 06:04:35,322][root][INFO] - Iteration 16: Code Run 4 execution error!
[2025-04-29 06:04:35,324][root][INFO] - Iteration 16, response_id 0: Objective value: inf
[2025-04-29 06:04:35,325][root][INFO] - Iteration 16, response_id 1: Objective value: inf
[2025-04-29 06:04:35,327][root][INFO] - Iteration 16, response_id 2: Objective value: inf
[2025-04-29 06:04:35,329][root][INFO] - Iteration 16, response_id 3: Objective value: inf
[2025-04-29 06:04:35,823][root][INFO] - Iteration 16, response_id 4: Objective value: inf
[2025-04-29 06:04:35,826][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:04:41,052][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:04:41,058][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:04:41,060][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:04:41,060][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:04:41,063][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:04:41,065][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  depot_influence_weight: float = 0.2, knn_base: int = 4, knn_weight: float = 0.15,
                  sparsification_percentile: float = 35.0, small_value: float = 1e-9) -> np.ndarray:
    """Adaptive heuristics using distance, demand, depot proximity, and k-NN."""
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # 1. Cost-Based Prioritization (Distance and Demand)
    cost_matrix = distance_matrix + (demands[:, None] + demands[None, :]) / capacity * np.mean(distance_matrix)
    heuristics = 1 / (cost_matrix + small_value)

    # 2. Depot Influence
    depot_distances = distance_matrix[:, depot_index]
    for i in range(1, n):
        heuristics[depot_index, i] += depot_influence_weight * (1 - depot_distances[i] / np.max(depot_distances))
        heuristics[i, depot_index] = 0  # Block return trip except from depot

    # 3. k-NN with adaptive k
    node_densities = np.zeros(n)
    for i in range(1, n):
        distances_from_i = distance_matrix[i, 1:]
        nearest_neighbors_dist = np.sort(distances_from_i)[:min(knn_base, n - 1)]
        node_densities[i] = np.mean(nearest_neighbors_dist)
    mean_node_density = np.mean(node_densities[1:])

    for i in range(1, n):
        adaptive_knn = int(knn_base * (mean_node_density / (node_densities[i] + small_value)))
        adaptive_knn = max(1, min(adaptive_knn, n - 1))
        distances_from_i = distance_matrix[i, 1:]
        nearest_neighbors = np.argsort(distances_from_i)[:adaptive_knn] + 1
        for j in nearest_neighbors:
            heuristics[i, j] += knn_weight
            heuristics[j, i] += knn_weight
    #4 sparsification

    threshold = np.percentile(heuristics[heuristics > 0], sparsification_percentile)
    heuristics[heuristics < threshold] = 0

    # 5. Normalization
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```

```python
parameter_ranges = {
    'depot_influence_weight': (0.0, 0.5),
    'knn_base': (2.0, 8.0),
    'knn_weight': (0.05, 0.3),
    'sparsification_percentile': (10.0, 50.0),
    'small_value': (1e-10, 1e-6)
}
```
[2025-04-29 06:04:41,066][root][INFO] - Iteration 16 finished...
[2025-04-29 06:04:41,066][root][INFO] - Best obj: 9.956565191737711, Best Code Path: problem_iter12_code2.py
[2025-04-29 06:04:41,067][root][INFO] - LLM usage: prompt_tokens = 211847, completion_tokens = 71058
[2025-04-29 06:04:41,067][root][INFO] - Function Evals: 106
[2025-04-29 06:04:41,067][root][INFO] - Best Code Overall: import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates demand, distance, depot proximity, angle considerations, k-NN intensification,
    and adaptive sparsification with more refined components and weight tuning. It also adds a route length
    estimation penalty and refines the k-NN selection and sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    depot_index = 0

    # Heuristic 1: Basic inverse distance (with a slight modification)
    distance_scaling = np.mean(distance_matrix)
    heuristics = distance_scaling / (distance_matrix + 1e-9)  # Use scaling directly in the division

    # Heuristic 2: Demand and Capacity consideration
    demand_penalty_factor = 0.6  # Tunable weight - Increased importance of demand
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0
                continue

            if i == depot_index and j != depot_index:
                if demands[j] > capacity:  # Directly prune edges that violate capacity constraint.
                    heuristics[i, j] = 0
                else:
                    heuristics[i, j] += 0.7  # Depot boost (increased)
            elif i != depot_index and j != depot_index:
                demand_ratio = (demands[i] + demands[j]) / capacity
                demand_penalty = demand_penalty_factor * demand_ratio**1.5 # Higher power to amplify penalty for large demand
                heuristics[i, j] -= demand_penalty

    # Heuristic 3: Depot proximity with adaptive pruning
    depot_distances = distance_matrix[:, depot_index]
    mean_depot_distance = np.mean(depot_distances)
    depot_proximity_weight = 0.2  # Tunable weight - Increased importance

    for i in range(n):
        for j in range(n):
            if i != depot_index and j == depot_index:
                heuristics[i, j] = 0  # Remove edges to depot (except from depot)
            elif i != depot_index and j != depot_index:
                detour_penalty = (depot_distances[i] + depot_distances[j]) / (2 * mean_depot_distance + 1e-9)
                heuristics[i, j] -= depot_proximity_weight * detour_penalty

                # Adaptive pruning based on demand and distance - more aggressive
                if distance_matrix[i, j] > 1.1 * distance_scaling and demands[i] + demands[j] > capacity / 2:
                    heuristics[i, j] = 0

    # Heuristic 4: Angle from Depot (less computational intensive angle heuristic)
    angle_weight = 0.3  # Tunable weight - Increased importance
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                vector_i = coordinates[i] - coordinates[depot_index]
                vector_j = coordinates[j] - coordinates[depot_index]

                norm_i = np.linalg.norm(vector_i)
                norm_j = np.linalg.norm(vector_j)

                if norm_i > 0 and norm_j > 0:
                    cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)
                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))

                    heuristics[i, j] += angle_weight * (1 - angle / np.pi)**2  # Favor smaller angles even more

    # Heuristic 5: k-NN intensification (Focus on local search) - Refined k-NN selection
    knn = min(7, n - 1)  # Adjusted k-NN, ensure knn < n-1
    knn_weight = 0.2  # Tunable weight - Increased importance

    for i in range(1, n):
        # Find k-nearest neighbors based on distance, excluding depot.
        distances_from_i = distance_matrix[i, 1:]
        nearest_neighbors = np.argsort(distances_from_i)[:knn] + 1  # Correctly offset indices

        # Demand aware k-NN selection.
        demand_neighbors = []
        for neighbor in nearest_neighbors:
            if demands[i] + demands[neighbor] <= capacity:
                demand_neighbors.append(neighbor)

        # No neighbors satisfying demand constraint.
        if len(demand_neighbors) == 0:
            for j in nearest_neighbors:
                heuristics[i, j] += knn_weight/2.0
                heuristics[j, i] += knn_weight/2.0
            continue # Move to the next i

        for j in demand_neighbors:
            heuristics[i, j] += knn_weight
            heuristics[j, i] += knn_weight

    # Heuristic 6: Route length estimation and penalty
    route_length_weight = 0.1 # Tunable weight for route length

    for i in range(1,n):
        for j in range(1,n):
            if i != j:
                #Estimate the route length if edge (i,j) included. Simplified estimation.
                estimated_route_length = distance_matrix[depot_index, i] + distance_matrix[i,j] + distance_matrix[j, depot_index]
                heuristics[i,j] -= route_length_weight * estimated_route_length / (3 * distance_scaling + 1e-9)

    # Heuristic 7: Sparsification: zero out small heuristic values (Adaptive Threshold) - Refined Sparsification
    threshold_factor = 0.03 # Tunable parameter for adaptive threshold - Adjusted Threshold
    threshold = threshold_factor * np.std(heuristics) #Adaptive threshold uses standard deviation
    heuristics[heuristics < threshold] = 0 #Sparsify only based on values smaller than threshold

    # Normalize (After Sparsification)
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
[2025-04-29 06:04:41,069][root][INFO] - Best Code Path Overall: problem_iter12_code2.py
[2025-04-29 06:04:41,072][root][INFO] - Running validation script...: C:\Users\Nam\Documents\GitHub\HSEvo/problems/cvrp_aco/eval.py
[2025-04-29 06:13:14,677][root][INFO] - Validation script finished. Results are saved in best_code_overall_val_stdout.txt.
[2025-04-29 06:13:14,688][root][INFO] - [*] Running ...
[2025-04-29 06:13:14,688][root][INFO] - [*] Average for 20: 4.853037132418033
[2025-04-29 06:13:14,688][root][INFO] - [*] Average for 50: 10.052552079310392
[2025-04-29 06:13:14,688][root][INFO] - [*] Average for 100: 17.663699032960402
