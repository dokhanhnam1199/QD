```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates distance, demand, and geometric considerations.

    Args:
        distance_matrix: Distance matrix (n x n).
        coordinates: Euclidean coordinates of nodes (n x 2).
        demands: Customer demands (n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of the same shape as distance_matrix, representing prior indicators
        of how promising it is to include each edge in a solution.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # 1. Inverse Distance: Shorter distances are generally better.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small value to avoid division by zero

    # 2. Demand Considerations: Penalize edges that lead to overloaded vehicles.
    demand_penalty = np.ones_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            # Estimate remaining capacity after visiting node i if starting from depot
            remaining_capacity_i = capacity - demands[i] if i != 0 else capacity
            #Estimate remaining capacity after visiting node j if starting from depot
            remaining_capacity_j = capacity - demands[j] if j != 0 else capacity


            #If demand of j is larger than the available capacity of one vehicle, it should return to depot
            if demands[j] > capacity and j != 0:
                demand_penalty[i, j] = 0.0
            elif demands[i] > capacity and i != 0:
                demand_penalty[i,j] = 0.0

            # Scale by how close i and j are to depot
            dist_depot_i = distance_matrix[0, i]
            dist_depot_j = distance_matrix[0, j]
            demand_penalty[i, j] *= (1+ np.exp(- (dist_depot_i + dist_depot_j) / distance_matrix.max())) #Nodes close to depot get a boost, otherwise do not influence
            #Penalty can prevent edges such that capacity of nodes i and j would together exceed total capacity
            if (demands[i] + demands[j] > capacity) and i != 0 and j != 0:
                demand_penalty[i,j] *= 0.1 #reduce the liklihood



    # 3. Geometric Considerations: Encourage connections to geographically close nodes
    #    and penalize connections that force long detours.
    geometric_factor = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i == j:
                continue

            #angle between i, j, and depot. If close to zero encourage (or 180 discourage)
            vector_i = coordinates[i] - coordinates[0]
            vector_j = coordinates[j] - coordinates[0]
            norm_i = np.linalg.norm(vector_i)
            norm_j = np.linalg.norm(vector_j)
            if norm_i == 0 or norm_j == 0:
                angle = 0 #If coordinate overlaps with depot don't bias angle
            else:
                dot_product = np.dot(vector_i, vector_j)
                cosine_angle = dot_product / (norm_i * norm_j)
                angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0)) #angle in radians
                angle = np.degrees(angle)

            # Geometric preference; penalize if angle to depot is wide
            geometric_factor[i,j] = np.exp(-0.1 * abs(angle - 45))#Bias towards medium angles


    # Combine the heuristics (you can adjust the weights as needed)
    heuristic_matrix = inverse_distance * demand_penalty * geometric_factor #element-wise multiplication

    #Depot edges should always be kept;
    for i in range(n):
        heuristic_matrix[0, i] = inverse_distance[0, i] * 1.1
        heuristic_matrix[i,0] = inverse_distance[i,0] * 1.1

    return heuristic_matrix
```
