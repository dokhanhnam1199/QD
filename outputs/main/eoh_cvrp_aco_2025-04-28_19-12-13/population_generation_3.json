[
     {
          "algorithm": "This algorithm estimates edge probabilities by iteratively constructing routes based on a combination of distance and demand considerations, rewarding edges used in feasible routes and penalizing those leading to capacity violations, while also incorporating a diversification strategy to explore different route configurations.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by iteratively constructing routes based on a combination of distance and demand considerations, rewarding edges used in feasible routes and penalizing those leading to capacity violations, while also incorporating a diversification strategy to explore different route configurations.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    penalty_factor = 10\n    reward_factor = 2\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on a combined metric of distance and demand\n            # Add a small random factor for diversification\n            scores = np.zeros(len(remaining_nodes))\n            for i, node in enumerate(remaining_nodes):\n              scores[i] = distance_matrix[current_node, node] + (demands[node] / capacity) + np.random.rand() * 0.1\n\n            sorted_indices = np.argsort(scores)\n            \n            next_node_found = False\n            for idx in sorted_indices:\n              candidate_node = remaining_nodes[idx]\n              if vehicle_load + demands[candidate_node] <= capacity:\n                next_node = candidate_node\n                next_node_found = True\n                break\n\n            if not next_node_found:\n              # Return to depot if no feasible node found\n              for node in current_route:\n                heuristics_matrix[current_node, 0] -= penalty_factor\n                heuristics_matrix[0, current_node] -= penalty_factor\n                current_node = 0\n              vehicle_load = 0\n              current_route = []\n              continue\n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix - reward feasible edges\n            heuristics_matrix[current_node, next_node] += reward_factor\n            heuristics_matrix[next_node, current_node] += reward_factor\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += reward_factor\n        heuristics_matrix[0, current_node] += reward_factor\n\n    return heuristics_matrix",
          "objective": 11.10452,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes proportionally to the inverse of the distance, penalizing infeasible edge selections.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes proportionally to the inverse of the distance, penalizing infeasible edge selections.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    reward_factor = 1\n    penalty_factor = 0.1\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on a combination of distance, demand\n            distances = distance_matrix[current_node, remaining_nodes]\n            \n            # Create a score based on distance and demand\n            scores = []\n            for i, node_idx in enumerate(remaining_nodes):\n                demand = demands[node_idx]\n                distance = distances[i]\n                \n                if vehicle_load + demand <= capacity:\n                    # Calculate score: inverse of the distance\n                    score = 1 / (distance + 1e-6)  # Adding a small constant to avoid division by zero\n                    scores.append((distance, score, node_idx))\n                else:\n                    scores.append((float('inf'), 0, node_idx))\n\n            # Find the possible node based on minimum distance and maximum score\n            sorted_scores = sorted(scores, key=lambda x: (x[0], -x[1]))\n\n            next_node_found = False\n            for distance, score, candidate_node in sorted_scores:\n                if distance != float('inf'):\n                    next_node = candidate_node\n                    next_node_found = True\n                    break\n\n            if not next_node_found:\n                # Return to depot if no feasible node found\n                for node in current_route:\n                    heuristics_matrix[current_node, 0] -= penalty_factor * distance_matrix[current_node,0]\n                    heuristics_matrix[0, current_node] -= penalty_factor * distance_matrix[0, current_node]\n                current_node = 0 # restart current_node from depot\n                vehicle_load = 0\n                current_route = []\n                continue\n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix (reward proportional to inverse of distance)\n            heuristics_matrix[current_node, next_node] += reward_factor * score\n            heuristics_matrix[next_node, current_node] += reward_factor * score\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += reward_factor\n        heuristics_matrix[0, current_node] += reward_factor\n\n    return heuristics_matrix",
          "objective": 12.30421,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes based on a combined score of distance, demand, and pheromone-inspired reinforcement, while penalizing infeasible selections.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes based on a combined score of distance, demand, and pheromone-inspired reinforcement, while penalizing infeasible selections.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    reward_factor = 1\n    penalty_factor = 0.1\n    pheromone_influence = 0.5  # Adjust this parameter\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on a combination of distance, demand and inverse distance\n            distances = distance_matrix[current_node, remaining_nodes]\n            \n            # Create a score based on distance, demand and inverse distance\n            scores = []\n            for i, node_idx in enumerate(remaining_nodes):\n                demand = demands[node_idx]\n                distance = distances[i]\n                \n                if vehicle_load + demand <= capacity:\n                    # Calculate inverse_distance\n                    inverse_distance = 1/(distance + 1e-6)  # Adding a small constant to avoid division by zero\n                    pheromone_level = heuristics_matrix[current_node, node_idx]  # Get the current \"pheromone\" level\n                    score = (distance, inverse_distance, pheromone_level, node_idx) # combined score\n                    scores.append(score)\n                else:\n                    scores.append((float('inf'),0,0, node_idx))\n\n            #Find the possible node based on minimum distance and maximum inverse distance and pheromone\n            sorted_scores = sorted(scores, key=lambda x: (x[0], -x[1] - pheromone_influence * x[2]))\n\n            next_node_found = False\n            for distance, inverse_distance, pheromone_level, candidate_node in sorted_scores:\n                if distance != float('inf'):\n                    next_node = candidate_node\n                    next_node_found = True\n                    break\n\n            if not next_node_found:\n                # Return to depot if no feasible node found\n                for node in current_route:\n                    heuristics_matrix[current_node, 0] -= penalty_factor * distance_matrix[current_node,0]\n                    heuristics_matrix[0, current_node] -= penalty_factor * distance_matrix[0, current_node]\n                current_node = 0 # restart current_node from depot\n                vehicle_load = 0\n                current_route = []\n                continue\n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix (reward proportional to inverse distance and pheromone update)\n            heuristics_matrix[current_node, next_node] += reward_factor * inverse_distance\n            heuristics_matrix[next_node, current_node] += reward_factor * inverse_distance\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += reward_factor\n        heuristics_matrix[0, current_node] += reward_factor\n\n    return heuristics_matrix",
          "objective": 12.31147,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes proportionally to the inverse of the distance achieved by their inclusion and penalizing infeasible edge selections.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes proportionally to the inverse of the distance achieved by their inclusion and penalizing infeasible edge selections.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    reward_factor = 1\n    penalty_factor = 0.1\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on a combination of distance, demand and inverse distance\n            distances = distance_matrix[current_node, remaining_nodes]\n            \n            # Create a score based on distance, demand and inverse distance\n            scores = []\n            for i, node_idx in enumerate(remaining_nodes):\n                demand = demands[node_idx]\n                distance = distances[i]\n                \n                if vehicle_load + demand <= capacity:\n                    # Calculate inverse_distance\n                    inverse_distance = 1/(distance + 1e-6)  # Adding a small constant to avoid division by zero\n                    scores.append((distance, inverse_distance, node_idx))\n                else:\n                    scores.append((float('inf'),0, node_idx))\n\n            #Find the possible node based on minimum distance and maximum inverse distance\n            sorted_scores = sorted(scores, key=lambda x: (x[0], -x[1]))\n\n            next_node_found = False\n            for distance, inverse_distance, candidate_node in sorted_scores:\n                if distance != float('inf'):\n                    next_node = candidate_node\n                    next_node_found = True\n                    break\n\n            if not next_node_found:\n                # Return to depot if no feasible node found\n                for node in current_route:\n                    heuristics_matrix[current_node, 0] -= penalty_factor * distance_matrix[current_node,0]\n                    heuristics_matrix[0, current_node] -= penalty_factor * distance_matrix[0, current_node]\n                current_node = 0 # restart current_node from depot\n                vehicle_load = 0\n                current_route = []\n                continue\n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix (reward proportional to inverse distance)\n            heuristics_matrix[current_node, next_node] += reward_factor * inverse_distance\n            heuristics_matrix[next_node, current_node] += reward_factor * inverse_distance\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += reward_factor\n        heuristics_matrix[0, current_node] += reward_factor\n\n    return heuristics_matrix",
          "objective": 12.34447,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes proportionally to a combination of inverse distance and demand, and penalizing infeasible edge selections.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes proportionally to a combination of inverse distance and demand, and penalizing infeasible edge selections.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    reward_factor = 1\n    penalty_factor = 0.1\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on a combination of distance, demand and inverse distance\n            distances = distance_matrix[current_node, remaining_nodes]\n            \n            # Create a score based on distance, demand and inverse distance\n            scores = []\n            for i, node_idx in enumerate(remaining_nodes):\n                demand = demands[node_idx]\n                distance = distances[i]\n                \n                if vehicle_load + demand <= capacity:\n                    # Calculate inverse_distance\n                    inverse_distance = 1/(distance + 1e-6)  # Adding a small constant to avoid division by zero\n                    \n                    # Combine inverse distance and demand\n                    combined_score = inverse_distance / (demand + 1e-6)  #Add a small constant to avoid division by zero\n                    scores.append((distance, combined_score, node_idx))\n                else:\n                    scores.append((float('inf'), 0, node_idx))\n\n            #Find the possible node based on minimum distance and maximum inverse distance\n            sorted_scores = sorted(scores, key=lambda x: (x[0], -x[1]))\n\n            next_node_found = False\n            for distance, combined_score, candidate_node in sorted_scores:\n                if distance != float('inf'):\n                    next_node = candidate_node\n                    next_node_found = True\n                    break\n\n            if not next_node_found:\n                # Return to depot if no feasible node found\n                for node in current_route:\n                    heuristics_matrix[current_node, 0] -= penalty_factor * distance_matrix[current_node,0]\n                    heuristics_matrix[0, current_node] -= penalty_factor * distance_matrix[0, current_node]\n                current_node = 0 # restart current_node from depot\n                vehicle_load = 0\n                current_route = []\n                continue\n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix (reward proportional to combined score)\n            heuristics_matrix[current_node, next_node] += reward_factor * combined_score\n            heuristics_matrix[next_node, current_node] += reward_factor * combined_score\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += reward_factor\n        heuristics_matrix[0, current_node] += reward_factor\n\n    return heuristics_matrix",
          "objective": 12.60642,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewarding edges in feasible routes proportionally to the savings achieved by their inclusion and penalizing infeasible edge selections.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewarding edges in feasible routes proportionally to the savings achieved by their inclusion and penalizing infeasible edge selections.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    reward_factor = 1\n    penalty_factor = 0.1\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on a combination of distance, demand and savings\n            distances = distance_matrix[current_node, remaining_nodes]\n            \n            # Create a score based on distance, demand and savings\n            scores = []\n            for i, node_idx in enumerate(remaining_nodes):\n                demand = demands[node_idx]\n                distance = distances[i]\n                \n                if vehicle_load + demand <= capacity:\n                    # Calculate savings: distance to depot - distance to customer\n                    savings = distance_matrix[node_idx, 0] - distance\n                    scores.append((distance, savings, node_idx))\n                else:\n                    scores.append((float('inf'),0, node_idx))\n\n            #Find the possible node based on minimum distance and maximum savings\n            sorted_scores = sorted(scores, key=lambda x: (x[0], -x[1]))\n\n            next_node_found = False\n            for distance, savings, candidate_node in sorted_scores:\n                if distance != float('inf'):\n                    next_node = candidate_node\n                    next_node_found = True\n                    break\n\n            if not next_node_found:\n                # Return to depot if no feasible node found\n                for node in current_route:\n                    heuristics_matrix[current_node, 0] -= penalty_factor * distance_matrix[current_node,0]\n                    heuristics_matrix[0, current_node] -= penalty_factor * distance_matrix[0, current_node]\n                current_node = 0 # restart current_node from depot\n                vehicle_load = 0\n                current_route = []\n                continue\n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix (reward proportional to savings)\n            heuristics_matrix[current_node, next_node] += reward_factor * savings\n            heuristics_matrix[next_node, current_node] += reward_factor * savings\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += reward_factor\n        heuristics_matrix[0, current_node] += reward_factor\n\n    return heuristics_matrix",
          "objective": 13.84711,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs initial routes using a savings-based approach, then iteratively refines these routes using local search and updates edge frequencies based on the improved solutions.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs initial routes using a savings-based approach, then iteratively refines these routes using local search and updates edge frequencies based on the improved solutions.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 50\n\n    # Savings calculation\n    savings = np.zeros((n, n), dtype=float)\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings[j, i] = savings[i, j]\n\n    # Initial route construction (Savings based)\n    routes = []\n    unvisited = set(range(1, n))\n    while unvisited:\n        best_saving = -1\n        best_i = -1\n        best_j = -1\n        for i in unvisited:\n            for j in unvisited:\n                if i != j and savings[i, j] > best_saving:\n                    best_saving = savings[i, j]\n                    best_i = i\n                    best_j = j\n\n        if best_i == -1:  # If no savings, create a route from depot to any remaining node\n            node = unvisited.pop()\n            routes.append([0, node, 0])\n            continue\n        \n        route = [0, best_i, best_j, 0]\n        current_load = demands[best_i] + demands[best_j]\n        unvisited.remove(best_i)\n        unvisited.remove(best_j)\n\n        # add more nodes until reaching capacity.\n        while True:\n            best_add_node = -1\n            best_add_saving = -1\n\n            for node in unvisited:\n                if current_load + demands[node] <= capacity:\n\n                    saving_i = savings[best_i, node]\n                    saving_j = savings[best_j, node]\n                    \n                    if saving_i >= saving_j and saving_i > best_add_saving :\n                        best_add_node = node\n                        best_add_saving = saving_i\n                    \n                    elif saving_j > saving_i and saving_j > best_add_saving:\n                        best_add_node = node\n                        best_add_saving = saving_j\n\n\n            if best_add_node != -1:\n                route.insert(len(route)-1,best_add_node)\n                current_load += demands[best_add_node]\n                unvisited.remove(best_add_node)\n                \n                best_j = route[-2] #update best_j\n                best_i = route[1]\n                \n\n            else:\n                routes.append(route)\n                break\n\n    # Iterative Improvement (Local Search - 2-opt within routes)\n    for _ in range(num_iterations):\n        for route in routes:\n            if len(route) <= 3:\n                continue\n            \n            for i in range(1, len(route) - 2):\n                for k in range(i + 1, len(route) - 1):\n                    # 2-opt swap\n                    new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]\n                    \n                    current_cost = 0\n                    for j in range(len(route) - 1):\n                        current_cost += distance_matrix[route[j], route[j+1]]\n                    \n                    new_cost = 0\n                    for j in range(len(new_route) - 1):\n                        new_cost += distance_matrix[new_route[j], new_route[j+1]]\n\n                    if new_cost < current_cost:\n                        route[:] = new_route  # Update route in place\n\n    # Update heuristics matrix\n    for route in routes:\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] += 1\n            heuristics_matrix[route[i+1], route[i]] += 1\n    \n    #Normalize heuristic matrix\n    total_visits = np.sum(heuristics_matrix)\n    if total_visits > 0:\n      heuristics_matrix = heuristics_matrix / total_visits\n    return heuristics_matrix",
          "objective": 13.97251,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes, prioritizing edges to closer nodes and penalizing edges in overloaded routes based on the degree of overload.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes, prioritizing edges to closer nodes and penalizing edges in overloaded routes based on the degree of overload.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    penalty_factor = 5\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on shortest distance\n            distances = distance_matrix[current_node, remaining_nodes]\n            sorted_indices = np.argsort(distances)\n            \n            next_node_found = False\n            for idx in sorted_indices:\n              candidate_node = remaining_nodes[idx]\n              if vehicle_load + demands[candidate_node] <= capacity:\n                next_node = candidate_node\n                next_node_found = True\n                break\n\n            if not next_node_found:\n              # Return to depot if no feasible node found\n              overload = vehicle_load\n              for node in current_route:\n                heuristics_matrix[current_node, 0] -= penalty_factor * (overload / capacity)\n                heuristics_matrix[0, current_node] -= penalty_factor * (overload / capacity)\n              current_node = 0 # restart current_node from depot\n              vehicle_load = 0\n              current_route = []\n              \n              continue\n            \n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix\n            heuristics_matrix[current_node, next_node] += 1\n            heuristics_matrix[next_node, current_node] += 1\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += 1\n        heuristics_matrix[0, current_node] += 1\n\n\n    return heuristics_matrix",
          "objective": 14.20577,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs initial routes using a cheapest insertion heuristic, then iteratively refines these routes by applying a 2-opt local search and reassigning nodes to different routes based on a savings criterion, updating edge frequencies based on the best solutions found.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs initial routes using a cheapest insertion heuristic, then iteratively refines these routes by applying a 2-opt local search and reassigning nodes to different routes based on a savings criterion, updating edge frequencies based on the best solutions found.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 200\n\n    def calculate_route_load(route):\n        load = 0\n        for node in route[1:-1]:\n            load += demands[node]\n        return load\n\n    def calculate_route_cost(route):\n        cost = 0\n        for i in range(len(route) - 1):\n            cost += distance_matrix[route[i], route[i+1]]\n        return cost\n    \n    def calculate_total_cost(routes):\n      total_cost = 0\n      for route in routes:\n        total_cost += calculate_route_cost(route)\n      return total_cost\n\n    def savings(node1, node2):\n      return distance_matrix[node1, 0] + distance_matrix[0, node2] - distance_matrix[node1, node2]\n\n    def two_opt_swap(route, i, k):\n        \"\"\"Performs a 2-opt swap on a route.\"\"\"\n        new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]\n        return new_route\n\n    def two_opt(route):\n      \"\"\"Applies 2-opt local search to a route.\"\"\"\n      best_route = route\n      improved = True\n      while improved:\n        improved = False\n        for i in range(1, len(route) - 2):\n          for k in range(i + 1, len(route) - 1):\n            new_route = two_opt_swap(route, i, k)\n            if calculate_route_cost(new_route) < calculate_route_cost(best_route):\n              best_route = new_route\n              improved = True\n        route = best_route\n      return best_route\n    \n    # Initialization: Cheapest Insertion\n    unassigned_nodes = set(range(1, n))\n    routes = []\n    while unassigned_nodes:\n        seed_node = random.choice(list(unassigned_nodes))\n        route = [0, seed_node, 0]\n        unassigned_nodes.remove(seed_node)\n\n        while True:\n            best_node = -1\n            best_insertion_index = -1\n            min_insertion_cost = float('inf')\n\n            for node in unassigned_nodes:\n                if calculate_route_load(route) + demands[node] <= capacity:\n                    for i in range(1, len(route)):\n                        cost = distance_matrix[route[i-1], node] + distance_matrix[node, route[i]] - distance_matrix[route[i-1], route[i]]\n                        if cost < min_insertion_cost:\n                            min_insertion_cost = cost\n                            best_node = node\n                            best_insertion_index = i\n\n            if best_node != -1:\n                route.insert(best_insertion_index, best_node)\n                unassigned_nodes.remove(best_node)\n            else:\n                break\n        routes.append(route)\n\n    best_routes = [route[:] for route in routes]\n    best_cost = calculate_total_cost(routes)\n\n    # Iterative Refinement\n    for _ in range(num_iterations):\n        # Local Search (2-opt)\n        for i in range(len(routes)):\n          routes[i] = two_opt(routes[i])\n\n        # Reassignment based on Savings\n        for i in range(len(routes)):\n            if len(routes[i]) <= 3:\n                continue\n            node_index = random.randint(1, len(routes[i]) - 2)\n            node_to_move = routes[i][node_index]\n            original_route = routes[i][:]\n            routes[i].pop(node_index)\n            \n            best_route_index = -1\n            best_insertion_index = -1\n            max_savings_val = -float('inf')\n\n            for j in range(len(routes)):\n                for k in range(1, len(routes[j])):\n                  temp_route = routes[j][:]\n                  temp_route.insert(k, node_to_move)\n                  if calculate_route_load(temp_route) <= capacity:\n                    current_savings = savings(routes[j][k-1], node_to_move) + savings(node_to_move,routes[j][k])\n                    if current_savings > max_savings_val:\n                      max_savings_val = current_savings\n                      best_route_index = j\n                      best_insertion_index = k\n                      \n            if best_route_index != -1:\n              if best_route_index == i:\n                routes[best_route_index].insert(best_insertion_index,node_to_move)\n              else:\n                routes[best_route_index].insert(best_insertion_index,node_to_move)\n                if len(routes[i]) <= 2:\n                  routes.pop(i)\n                  if i < best_route_index:\n                      best_route_index -=1\n            else:\n              routes[i].insert(node_index, node_to_move)\n\n        # Update best solution\n        current_cost = calculate_total_cost(routes)\n        if current_cost < best_cost:\n            best_cost = current_cost\n            best_routes = [route[:] for route in routes]\n\n    # Heuristic Matrix Update\n    for route in best_routes:\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] += 1\n            heuristics_matrix[route[i+1], route[i]] += 1\n    \n    #Normalize heuristic matrix\n    total_visits = np.sum(heuristics_matrix)\n    if total_visits > 0:\n      heuristics_matrix = heuristics_matrix / total_visits\n\n    return heuristics_matrix",
          "objective": 14.26677,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs solutions using a modified cost-benefit analysis that prioritizes capacity utilization and applies a more aggressive simulated annealing with dynamic temperature adjustment to diversify the search and updates edge frequencies.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs solutions using a modified cost-benefit analysis that prioritizes capacity utilization and applies a more aggressive simulated annealing with dynamic temperature adjustment to diversify the search and updates edge frequencies.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 400\n    initial_temperature = 150\n    cooling_rate = 0.995\n    capacity_penalty_factor = 0.5\n\n    def calculate_route_load(route):\n        load = 0\n        for node in route[1:-1]:\n            load += demands[node]\n        return load\n\n    def calculate_route_cost(route):\n        cost = 0\n        for i in range(len(route) - 1):\n            cost += distance_matrix[route[i], route[i+1]]\n        return cost\n    \n    def calculate_total_cost(routes):\n      total_cost = 0\n      for route in routes:\n        total_cost += calculate_route_cost(route)\n      return total_cost\n\n    def insertion_cost(route, node, index):\n        \"\"\"Calculates the cost of inserting a node into a route at a specific index, with a capacity penalty.\"\"\"\n        cost = distance_matrix[route[index-1], node] + distance_matrix[node, route[index]] - distance_matrix[route[index-1], route[index]]\n        remaining_capacity = capacity - calculate_route_load(route)\n        # Encourage filling up capacity\n        capacity_utilization = 1 - (remaining_capacity - demands[node]) / capacity if remaining_capacity - demands[node] >= 0 else 100\n        cost += capacity_penalty_factor * (1 - capacity_utilization)\n        return cost\n\n    routes = []\n    unassigned_nodes = set(range(1, n))\n\n    # Initial Solution Construction: Greedy Insertion with Capacity Check\n    while unassigned_nodes:\n        route = [0, 0]\n        current_load = 0\n        \n        while True:\n            best_node = -1\n            best_insertion_index = -1\n            min_insertion_cost = float('inf')\n            \n            for node in unassigned_nodes:\n                if current_load + demands[node] <= capacity:\n                    for i in range(1, len(route)):\n                        cost = insertion_cost(route, node, i)\n                        if cost < min_insertion_cost:\n                            min_insertion_cost = cost\n                            best_node = node\n                            best_insertion_index = i\n\n            if best_node != -1:\n                route.insert(best_insertion_index, best_node)\n                current_load += demands[best_node]\n                unassigned_nodes.remove(best_node)\n            else:\n                break\n        \n        if len(route) > 2: #only append routes with customer nodes\n            routes.append(route)\n\n    # Simulated Annealing\n    best_routes = [route[:] for route in routes]\n    best_cost = calculate_total_cost(routes)\n    current_temperature = initial_temperature\n\n    for iteration in range(num_iterations):\n        # Choose a random route and a random node within that route\n        route_index = random.randint(0, len(routes) - 1)\n        if len(routes[route_index]) <= 3:\n            continue\n        node_index = random.randint(1, len(routes[route_index]) - 2)\n        node_to_move = routes[route_index][node_index]\n        \n        #Remove node from the route\n        original_load = calculate_route_load(routes[route_index])\n        routes[route_index].pop(node_index)\n\n        # Find best insertion point in other routes or the same route\n        best_new_route_index = -1\n        best_new_index = -1\n        best_insertion_cost = float('inf')\n        \n        for i in range(len(routes)):\n            for j in range(1, len(routes[i])):\n                temp_route = routes[i][:]\n                temp_route.insert(j, node_to_move)\n                \n                if calculate_route_load(temp_route) <= capacity:\n                    new_cost = calculate_route_cost(temp_route)\n                    original_cost = calculate_route_cost(routes[i])\n                    delta_cost = new_cost - original_cost\n                    \n                    if delta_cost < best_insertion_cost:\n                        best_insertion_cost = delta_cost\n                        best_new_route_index = i\n                        best_new_index = j\n                        \n        #Accept or reject move based on simulated annealing criteria\n        if best_new_route_index != -1:\n            delta_cost = best_insertion_cost\n            if delta_cost < 0 or random.random() < np.exp(-delta_cost / current_temperature):\n              # Move the node\n              if best_new_route_index == route_index:\n                  routes[best_new_route_index].insert(best_new_index, node_to_move)\n              else:\n                routes[best_new_route_index].insert(best_new_index, node_to_move)\n                if len(routes[route_index]) <= 2:\n                   routes.pop(route_index)\n                   if route_index < best_new_route_index:\n                     best_new_route_index -=1 #adjust index if route removed before the insertion route\n                \n              # Check if this is the best solution so far\n              current_cost = calculate_total_cost(routes)\n              if current_cost < best_cost:\n                best_cost = current_cost\n                best_routes = [route[:] for route in routes]\n            else:\n                routes[route_index].insert(node_index, node_to_move) #reinsert if move rejected\n        else:\n            routes[route_index].insert(node_index, node_to_move) #reinsert if no feasible solution found\n        \n        #Dynamic temperature adjustment\n        if iteration % 50 == 0:\n            if calculate_total_cost(routes) > best_cost:\n                current_temperature *= 1.1 #Increase temperature to escape local optima\n            else:\n                current_temperature *= cooling_rate\n        else:\n             current_temperature *= cooling_rate\n\n\n    # Heuristic Matrix Update\n    for route in best_routes:\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] += 1\n            heuristics_matrix[route[i+1], route[i]] += 1\n    \n    #Normalize heuristic matrix\n    total_visits = np.sum(heuristics_matrix)\n    if total_visits > 0:\n      heuristics_matrix = heuristics_matrix / total_visits\n\n    return heuristics_matrix",
          "objective": 14.30893,
          "other_inf": null
     }
]