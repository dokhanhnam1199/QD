{
     "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes proportionally to the inverse of the distance achieved by their inclusion and penalizing infeasible edge selections.",
     "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes proportionally to the inverse of the distance achieved by their inclusion and penalizing infeasible edge selections.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    reward_factor = 1\n    penalty_factor = 0.1\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on a combination of distance, demand and inverse distance\n            distances = distance_matrix[current_node, remaining_nodes]\n            \n            # Create a score based on distance, demand and inverse distance\n            scores = []\n            for i, node_idx in enumerate(remaining_nodes):\n                demand = demands[node_idx]\n                distance = distances[i]\n                \n                if vehicle_load + demand <= capacity:\n                    # Calculate inverse_distance\n                    inverse_distance = 1/(distance + 1e-6)  # Adding a small constant to avoid division by zero\n                    scores.append((distance, inverse_distance, node_idx))\n                else:\n                    scores.append((float('inf'),0, node_idx))\n\n            #Find the possible node based on minimum distance and maximum inverse distance\n            sorted_scores = sorted(scores, key=lambda x: (x[0], -x[1]))\n\n            next_node_found = False\n            for distance, inverse_distance, candidate_node in sorted_scores:\n                if distance != float('inf'):\n                    next_node = candidate_node\n                    next_node_found = True\n                    break\n\n            if not next_node_found:\n                # Return to depot if no feasible node found\n                for node in current_route:\n                    heuristics_matrix[current_node, 0] -= penalty_factor * distance_matrix[current_node,0]\n                    heuristics_matrix[0, current_node] -= penalty_factor * distance_matrix[0, current_node]\n                current_node = 0 # restart current_node from depot\n                vehicle_load = 0\n                current_route = []\n                continue\n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix (reward proportional to inverse distance)\n            heuristics_matrix[current_node, next_node] += reward_factor * inverse_distance\n            heuristics_matrix[next_node, current_node] += reward_factor * inverse_distance\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += reward_factor\n        heuristics_matrix[0, current_node] += reward_factor\n\n    return heuristics_matrix",
     "objective": 12.34447,
     "other_inf": null
}