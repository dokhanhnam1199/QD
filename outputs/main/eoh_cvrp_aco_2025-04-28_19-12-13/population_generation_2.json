[
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes proportionally to the inverse of the distance achieved by their inclusion and penalizing infeasible edge selections.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes proportionally to the inverse of the distance achieved by their inclusion and penalizing infeasible edge selections.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    reward_factor = 1\n    penalty_factor = 0.1\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on a combination of distance, demand and inverse distance\n            distances = distance_matrix[current_node, remaining_nodes]\n            \n            # Create a score based on distance, demand and inverse distance\n            scores = []\n            for i, node_idx in enumerate(remaining_nodes):\n                demand = demands[node_idx]\n                distance = distances[i]\n                \n                if vehicle_load + demand <= capacity:\n                    # Calculate inverse_distance\n                    inverse_distance = 1/(distance + 1e-6)  # Adding a small constant to avoid division by zero\n                    scores.append((distance, inverse_distance, node_idx))\n                else:\n                    scores.append((float('inf'),0, node_idx))\n\n            #Find the possible node based on minimum distance and maximum inverse distance\n            sorted_scores = sorted(scores, key=lambda x: (x[0], -x[1]))\n\n            next_node_found = False\n            for distance, inverse_distance, candidate_node in sorted_scores:\n                if distance != float('inf'):\n                    next_node = candidate_node\n                    next_node_found = True\n                    break\n\n            if not next_node_found:\n                # Return to depot if no feasible node found\n                for node in current_route:\n                    heuristics_matrix[current_node, 0] -= penalty_factor * distance_matrix[current_node,0]\n                    heuristics_matrix[0, current_node] -= penalty_factor * distance_matrix[0, current_node]\n                current_node = 0 # restart current_node from depot\n                vehicle_load = 0\n                current_route = []\n                continue\n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix (reward proportional to inverse distance)\n            heuristics_matrix[current_node, next_node] += reward_factor * inverse_distance\n            heuristics_matrix[next_node, current_node] += reward_factor * inverse_distance\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += reward_factor\n        heuristics_matrix[0, current_node] += reward_factor\n\n    return heuristics_matrix",
          "objective": 12.34447,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewarding edges in feasible routes proportionally to the savings achieved by their inclusion and penalizing infeasible edge selections.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewarding edges in feasible routes proportionally to the savings achieved by their inclusion and penalizing infeasible edge selections.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    reward_factor = 1\n    penalty_factor = 0.1\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on a combination of distance, demand and savings\n            distances = distance_matrix[current_node, remaining_nodes]\n            \n            # Create a score based on distance, demand and savings\n            scores = []\n            for i, node_idx in enumerate(remaining_nodes):\n                demand = demands[node_idx]\n                distance = distances[i]\n                \n                if vehicle_load + demand <= capacity:\n                    # Calculate savings: distance to depot - distance to customer\n                    savings = distance_matrix[node_idx, 0] - distance\n                    scores.append((distance, savings, node_idx))\n                else:\n                    scores.append((float('inf'),0, node_idx))\n\n            #Find the possible node based on minimum distance and maximum savings\n            sorted_scores = sorted(scores, key=lambda x: (x[0], -x[1]))\n\n            next_node_found = False\n            for distance, savings, candidate_node in sorted_scores:\n                if distance != float('inf'):\n                    next_node = candidate_node\n                    next_node_found = True\n                    break\n\n            if not next_node_found:\n                # Return to depot if no feasible node found\n                for node in current_route:\n                    heuristics_matrix[current_node, 0] -= penalty_factor * distance_matrix[current_node,0]\n                    heuristics_matrix[0, current_node] -= penalty_factor * distance_matrix[0, current_node]\n                current_node = 0 # restart current_node from depot\n                vehicle_load = 0\n                current_route = []\n                continue\n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix (reward proportional to savings)\n            heuristics_matrix[current_node, next_node] += reward_factor * savings\n            heuristics_matrix[next_node, current_node] += reward_factor * savings\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += reward_factor\n        heuristics_matrix[0, current_node] += reward_factor\n\n    return heuristics_matrix",
          "objective": 13.84711,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs initial routes using a savings-based approach, then iteratively refines these routes using local search and updates edge frequencies based on the improved solutions.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs initial routes using a savings-based approach, then iteratively refines these routes using local search and updates edge frequencies based on the improved solutions.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 50\n\n    # Savings calculation\n    savings = np.zeros((n, n), dtype=float)\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings[j, i] = savings[i, j]\n\n    # Initial route construction (Savings based)\n    routes = []\n    unvisited = set(range(1, n))\n    while unvisited:\n        best_saving = -1\n        best_i = -1\n        best_j = -1\n        for i in unvisited:\n            for j in unvisited:\n                if i != j and savings[i, j] > best_saving:\n                    best_saving = savings[i, j]\n                    best_i = i\n                    best_j = j\n\n        if best_i == -1:  # If no savings, create a route from depot to any remaining node\n            node = unvisited.pop()\n            routes.append([0, node, 0])\n            continue\n        \n        route = [0, best_i, best_j, 0]\n        current_load = demands[best_i] + demands[best_j]\n        unvisited.remove(best_i)\n        unvisited.remove(best_j)\n\n        # add more nodes until reaching capacity.\n        while True:\n            best_add_node = -1\n            best_add_saving = -1\n\n            for node in unvisited:\n                if current_load + demands[node] <= capacity:\n\n                    saving_i = savings[best_i, node]\n                    saving_j = savings[best_j, node]\n                    \n                    if saving_i >= saving_j and saving_i > best_add_saving :\n                        best_add_node = node\n                        best_add_saving = saving_i\n                    \n                    elif saving_j > saving_i and saving_j > best_add_saving:\n                        best_add_node = node\n                        best_add_saving = saving_j\n\n\n            if best_add_node != -1:\n                route.insert(len(route)-1,best_add_node)\n                current_load += demands[best_add_node]\n                unvisited.remove(best_add_node)\n                \n                best_j = route[-2] #update best_j\n                best_i = route[1]\n                \n\n            else:\n                routes.append(route)\n                break\n\n    # Iterative Improvement (Local Search - 2-opt within routes)\n    for _ in range(num_iterations):\n        for route in routes:\n            if len(route) <= 3:\n                continue\n            \n            for i in range(1, len(route) - 2):\n                for k in range(i + 1, len(route) - 1):\n                    # 2-opt swap\n                    new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]\n                    \n                    current_cost = 0\n                    for j in range(len(route) - 1):\n                        current_cost += distance_matrix[route[j], route[j+1]]\n                    \n                    new_cost = 0\n                    for j in range(len(new_route) - 1):\n                        new_cost += distance_matrix[new_route[j], new_route[j+1]]\n\n                    if new_cost < current_cost:\n                        route[:] = new_route  # Update route in place\n\n    # Update heuristics matrix\n    for route in routes:\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] += 1\n            heuristics_matrix[route[i+1], route[i]] += 1\n    \n    #Normalize heuristic matrix\n    total_visits = np.sum(heuristics_matrix)\n    if total_visits > 0:\n      heuristics_matrix = heuristics_matrix / total_visits\n    return heuristics_matrix",
          "objective": 13.97251,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes, prioritizing edges to closer nodes and penalizing edges in overloaded routes based on the degree of overload.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes, prioritizing edges to closer nodes and penalizing edges in overloaded routes based on the degree of overload.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    penalty_factor = 5\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on shortest distance\n            distances = distance_matrix[current_node, remaining_nodes]\n            sorted_indices = np.argsort(distances)\n            \n            next_node_found = False\n            for idx in sorted_indices:\n              candidate_node = remaining_nodes[idx]\n              if vehicle_load + demands[candidate_node] <= capacity:\n                next_node = candidate_node\n                next_node_found = True\n                break\n\n            if not next_node_found:\n              # Return to depot if no feasible node found\n              overload = vehicle_load\n              for node in current_route:\n                heuristics_matrix[current_node, 0] -= penalty_factor * (overload / capacity)\n                heuristics_matrix[0, current_node] -= penalty_factor * (overload / capacity)\n              current_node = 0 # restart current_node from depot\n              vehicle_load = 0\n              current_route = []\n              \n              continue\n            \n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix\n            heuristics_matrix[current_node, next_node] += 1\n            heuristics_matrix[next_node, current_node] += 1\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += 1\n        heuristics_matrix[0, current_node] += 1\n\n\n    return heuristics_matrix",
          "objective": 14.20577,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively constructs solutions using a randomized Clarke-Wright savings approach, followed by route improvement via 2-opt swaps and guided by a pheromone-inspired heuristic matrix updated based on solution quality.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm iteratively constructs solutions using a randomized Clarke-Wright savings approach, followed by route improvement via 2-opt swaps and guided by a pheromone-inspired heuristic matrix updated based on solution quality.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 500\n    pheromone_matrix = np.ones_like(distance_matrix) * 0.01 # Initialize pheromone matrix\n\n    def calculate_route_load(route):\n        load = 0\n        for node in route[1:-1]:\n            load += demands[node]\n        return load\n\n    def calculate_route_cost(route):\n        cost = 0\n        for i in range(len(route) - 1):\n            cost += distance_matrix[route[i], route[i+1]]\n        return cost\n\n    def two_opt_swap(route):\n        best_route = route[:]\n        best_cost = calculate_route_cost(route)\n        for i in range(1, len(route) - 2):\n            for k in range(i + 1, len(route) - 1):\n                new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]\n                new_cost = calculate_route_cost(new_route)\n                if new_cost < best_cost:\n                    best_route = new_route[:]\n                    best_cost = new_cost\n        return best_route\n\n    def savings_heuristic(i, j):\n        return distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n\n    best_routes = None\n    best_cost = float('inf')\n\n    for iteration in range(num_iterations):\n        routes = []\n        unassigned_nodes = set(range(1, n))\n\n        # Randomized Savings-Based Route Construction\n        while unassigned_nodes:\n            i = random.choice(list(unassigned_nodes))\n            route = [0, i, 0]\n            current_load = demands[i]\n            unassigned_nodes.remove(i)\n\n            while True:\n                eligible_nodes = []\n                for j in unassigned_nodes:\n                    if current_load + demands[j] <= capacity:\n                        eligible_nodes.append(j)\n\n                if not eligible_nodes:\n                    break\n\n                # Use pheromone and savings to select the next node\n                probabilities = []\n                for node in eligible_nodes:\n                    savings = savings_heuristic(route[-2], node)\n                    pheromone = pheromone_matrix[route[-2], node]\n                    probabilities.append(savings * pheromone)\n                \n                if sum(probabilities) == 0:\n                    next_node = random.choice(eligible_nodes)\n                else:\n                    probabilities = [p / sum(probabilities) for p in probabilities]\n                    next_node = random.choices(eligible_nodes, weights=probabilities, k=1)[0]\n                \n\n                route.insert(-1, next_node)\n                current_load += demands[next_node]\n                unassigned_nodes.remove(next_node)\n\n            routes.append(route)\n\n        # Route Improvement with 2-Opt\n        for i in range(len(routes)):\n            routes[i] = two_opt_swap(routes[i])\n\n        # Evaluate Solution\n        current_cost = sum(calculate_route_cost(route) for route in routes)\n\n        # Update Best Solution\n        if current_cost < best_cost:\n            best_cost = current_cost\n            best_routes = [route[:] for route in routes]\n            \n             # Pheromone Update\n            delta_pheromone = 1.0 / current_cost\n            for route in routes:\n                for i in range(len(route) - 1):\n                    pheromone_matrix[route[i], route[i+1]] += delta_pheromone\n                    pheromone_matrix[route[i+1], route[i]] += delta_pheromone\n\n        # Evaporation\n        pheromone_matrix *= 0.9\n\n    # Heuristic Matrix Update based on best solution\n    for route in best_routes:\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] += 1\n            heuristics_matrix[route[i+1], route[i]] += 1\n    \n    #Normalize heuristic matrix\n    total_visits = np.sum(heuristics_matrix)\n    if total_visits > 0:\n      heuristics_matrix = heuristics_matrix / total_visits\n\n    return heuristics_matrix",
          "objective": 14.33413,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs solutions by iteratively inserting unrouted nodes into existing partial routes based on a cost-benefit analysis considering distance and remaining capacity, and then applies a simulated annealing procedure to refine the routes and updates edge frequencies.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs solutions by iteratively inserting unrouted nodes into existing partial routes based on a cost-benefit analysis considering distance and remaining capacity, and then applies a simulated annealing procedure to refine the routes and updates edge frequencies.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 300\n    initial_temperature = 100\n    cooling_rate = 0.98\n\n    def calculate_route_load(route):\n        load = 0\n        for node in route[1:-1]:\n            load += demands[node]\n        return load\n\n    def calculate_route_cost(route):\n        cost = 0\n        for i in range(len(route) - 1):\n            cost += distance_matrix[route[i], route[i+1]]\n        return cost\n    \n    def calculate_total_cost(routes):\n      total_cost = 0\n      for route in routes:\n        total_cost += calculate_route_cost(route)\n      return total_cost\n\n    def insertion_cost(route, node, index):\n        \"\"\"Calculates the cost of inserting a node into a route at a specific index.\"\"\"\n        cost = distance_matrix[route[index-1], node] + distance_matrix[node, route[index]] - distance_matrix[route[index-1], route[index]]\n        return cost\n\n    routes = []\n    unassigned_nodes = set(range(1, n))\n\n    # Initial Solution Construction: Greedy Insertion with Capacity Check\n    while unassigned_nodes:\n        route = [0, 0]\n        current_load = 0\n        \n        while True:\n            best_node = -1\n            best_insertion_index = -1\n            min_insertion_cost = float('inf')\n            \n            for node in unassigned_nodes:\n                if current_load + demands[node] <= capacity:\n                    for i in range(1, len(route)):\n                        cost = insertion_cost(route, node, i)\n                        if cost < min_insertion_cost:\n                            min_insertion_cost = cost\n                            best_node = node\n                            best_insertion_index = i\n\n            if best_node != -1:\n                route.insert(best_insertion_index, best_node)\n                current_load += demands[best_node]\n                unassigned_nodes.remove(best_node)\n            else:\n                break\n        \n        if len(route) > 2: #only append routes with customer nodes\n            routes.append(route)\n\n    # Simulated Annealing\n    best_routes = [route[:] for route in routes]\n    best_cost = calculate_total_cost(routes)\n    current_temperature = initial_temperature\n\n    for _ in range(num_iterations):\n        # Choose a random route and a random node within that route\n        route_index = random.randint(0, len(routes) - 1)\n        if len(routes[route_index]) <= 3:\n            continue\n        node_index = random.randint(1, len(routes[route_index]) - 2)\n        node_to_move = routes[route_index][node_index]\n        \n        #Remove node from the route\n        original_load = calculate_route_load(routes[route_index])\n        routes[route_index].pop(node_index)\n\n        # Find best insertion point in other routes or the same route\n        best_new_route_index = -1\n        best_new_index = -1\n        best_insertion_cost = float('inf')\n        \n        for i in range(len(routes)):\n            for j in range(1, len(routes[i])):\n                temp_route = routes[i][:]\n                temp_route.insert(j, node_to_move)\n                \n                if calculate_route_load(temp_route) <= capacity:\n                    new_cost = calculate_route_cost(temp_route)\n                    original_cost = calculate_route_cost(routes[i])\n                    delta_cost = new_cost - original_cost\n                    \n                    if delta_cost < best_insertion_cost:\n                        best_insertion_cost = delta_cost\n                        best_new_route_index = i\n                        best_new_index = j\n                        \n        #Accept or reject move based on simulated annealing criteria\n        if best_new_route_index != -1:\n            delta_cost = best_insertion_cost\n            if delta_cost < 0 or random.random() < np.exp(-delta_cost / current_temperature):\n              # Move the node\n              if best_new_route_index == route_index:\n                  routes[best_new_route_index].insert(best_new_index, node_to_move)\n              else:\n                routes[best_new_route_index].insert(best_new_index, node_to_move)\n                if len(routes[route_index]) <= 2:\n                   routes.pop(route_index)\n                   if route_index < best_new_route_index:\n                     best_new_route_index -=1 #adjust index if route removed before the insertion route\n                \n              # Check if this is the best solution so far\n              current_cost = calculate_total_cost(routes)\n              if current_cost < best_cost:\n                best_cost = current_cost\n                best_routes = [route[:] for route in routes]\n            else:\n                routes[route_index].insert(node_index, node_to_move) #reinsert if move rejected\n        else:\n            routes[route_index].insert(node_index, node_to_move) #reinsert if no feasible solution found\n\n        current_temperature *= cooling_rate\n\n    # Heuristic Matrix Update\n    for route in best_routes:\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] += 1\n            heuristics_matrix[route[i+1], route[i]] += 1\n    \n    #Normalize heuristic matrix\n    total_visits = np.sum(heuristics_matrix)\n    if total_visits > 0:\n      heuristics_matrix = heuristics_matrix / total_visits\n\n    return heuristics_matrix",
          "objective": 14.44962,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and penalizing edges in infeasible routes.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and penalizing edges in infeasible routes.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    penalty_factor = 10\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on shortest distance\n            distances = distance_matrix[current_node, remaining_nodes]\n            sorted_indices = np.argsort(distances)\n            \n            next_node_found = False\n            for idx in sorted_indices:\n              candidate_node = remaining_nodes[idx]\n              if vehicle_load + demands[candidate_node] <= capacity:\n                next_node = candidate_node\n                next_node_found = True\n                break\n\n            if not next_node_found:\n              # Return to depot if no feasible node found\n              for node in current_route:\n                heuristics_matrix[current_node, 0] -= penalty_factor\n                heuristics_matrix[0, current_node] -= penalty_factor\n                current_node = 0 # restart current_node from depot\n              vehicle_load = 0\n              current_route = []\n              \n              continue\n            \n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix\n            heuristics_matrix[current_node, next_node] += 1\n            heuristics_matrix[next_node, current_node] += 1\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += 1\n        heuristics_matrix[0, current_node] += 1\n\n\n    return heuristics_matrix",
          "objective": 14.4825,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge importance by iteratively constructing routes using a nearest neighbor approach with stochastic selection, favoring shorter edges and respecting capacity constraints, and updates edge importance based on route frequency and edge length with adjusted weighting.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge importance by iteratively constructing routes using a nearest neighbor approach with stochastic selection, favoring shorter edges and respecting capacity constraints, and updates edge importance based on route frequency and edge length with adjusted weighting.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Start from the depot\n        current_node = 0\n        current_route = [0]\n        current_load = 0\n        remaining_customers = set(range(1, n))\n        routes = []\n\n        while remaining_customers:\n            # Find nearest neighbors within capacity\n            eligible_neighbors = []\n            for neighbor in remaining_customers:\n                if current_load + demands[neighbor] <= capacity:\n                    eligible_neighbors.append(neighbor)\n\n            if not eligible_neighbors:\n                # Return to depot and start a new route\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0]\n                current_load = 0\n                current_node = 0\n                continue\n            \n            # Stochastic selection of the next node based on distance\n            probabilities = []\n            total_distance = 0\n            for neighbor in eligible_neighbors:\n                total_distance += (1 / (distance_matrix[current_node, neighbor]**2 + 1e-6)) # Square the distance\n\n            for neighbor in eligible_neighbors:\n                probabilities.append((1 / (distance_matrix[current_node, neighbor]**2 + 1e-6)) / total_distance) # Square the distance\n\n            next_node = random.choices(eligible_neighbors, weights=probabilities, k=1)[0]\n            \n            current_route.append(next_node)\n            current_load += demands[next_node]\n            remaining_customers.remove(next_node)\n            current_node = next_node\n        \n        current_route.append(0)\n        routes.append(current_route)\n    \n        # Update heuristic matrix based on edges in the routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n\n    # Normalize the heuristic matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    # Incorporate distance information (shorter distances are better)\n    heuristics_matrix = heuristics_matrix / (distance_matrix**1.5 + 1e-6) # Avoid division by zero and adjust the exponent\n\n    return heuristics_matrix",
          "objective": 14.55165,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewarding edges in feasible routes and penalizing less promising edges based on distance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewarding edges in feasible routes and penalizing less promising edges based on distance.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    reward_factor = 1\n    penalty_factor = 0.1\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on a combination of distance and demand\n            distances = distance_matrix[current_node, remaining_nodes]\n            \n            # Create a score based on distance and demand\n            scores = []\n            for i, node_idx in enumerate(remaining_nodes):\n                demand = demands[node_idx]\n                distance = distances[i]\n                \n                if vehicle_load + demand <= capacity:\n                    scores.append((distance, node_idx))\n                else:\n                    scores.append((float('inf'), node_idx))\n\n            #Find the possible node based on minimum distance\n            sorted_scores = sorted(scores, key=lambda x: x[0])\n\n            next_node_found = False\n            for distance, candidate_node in sorted_scores:\n                if distance != float('inf'):\n                    next_node = candidate_node\n                    next_node_found = True\n                    break\n\n            if not next_node_found:\n                # Return to depot if no feasible node found\n                for node in current_route:\n                    heuristics_matrix[current_node, 0] -= penalty_factor * distance_matrix[current_node,0]\n                    heuristics_matrix[0, current_node] -= penalty_factor * distance_matrix[0, current_node]\n                    current_node = 0 # restart current_node from depot\n                vehicle_load = 0\n                current_route = []\n                continue\n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix\n            heuristics_matrix[current_node, next_node] += reward_factor\n            heuristics_matrix[next_node, current_node] += reward_factor\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += reward_factor\n        heuristics_matrix[0, current_node] += reward_factor\n\n    return heuristics_matrix",
          "objective": 14.57733,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes proportionally to a modified savings calculation that considers both distance and demand, while penalizing infeasible selections.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes proportionally to a modified savings calculation that considers both distance and demand, while penalizing infeasible selections.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    reward_factor = 1\n    penalty_factor = 0.1\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on a combination of distance, demand and savings\n            distances = distance_matrix[current_node, remaining_nodes]\n            \n            # Create a score based on distance, demand and savings\n            scores = []\n            for i, node_idx in enumerate(remaining_nodes):\n                demand = demands[node_idx]\n                distance = distances[i]\n                \n                if vehicle_load + demand <= capacity:\n                    # Calculate savings: distance to depot - distance to customer - demand weight\n                    savings = distance_matrix[node_idx, 0] - distance - 0.01 * demand\n                    scores.append((distance, savings, node_idx))\n                else:\n                    scores.append((float('inf'),0, node_idx))\n\n            #Find the possible node based on minimum distance and maximum savings\n            sorted_scores = sorted(scores, key=lambda x: (x[0], -x[1]))\n\n            next_node_found = False\n            for distance, savings, candidate_node in sorted_scores:\n                if distance != float('inf'):\n                    next_node = candidate_node\n                    next_node_found = True\n                    break\n\n            if not next_node_found:\n                # Return to depot if no feasible node found\n                for node in current_route:\n                    heuristics_matrix[current_node, 0] -= penalty_factor * distance_matrix[current_node,0]\n                    heuristics_matrix[0, current_node] -= penalty_factor * distance_matrix[0, current_node]\n                current_node = 0 # restart current_node from depot\n                vehicle_load = 0\n                current_route = []\n                continue\n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix (reward proportional to savings)\n            heuristics_matrix[current_node, next_node] += reward_factor * savings\n            heuristics_matrix[next_node, current_node] += reward_factor * savings\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += reward_factor\n        heuristics_matrix[0, current_node] += reward_factor\n\n    return heuristics_matrix",
          "objective": 14.67729,
          "other_inf": null
     }
]