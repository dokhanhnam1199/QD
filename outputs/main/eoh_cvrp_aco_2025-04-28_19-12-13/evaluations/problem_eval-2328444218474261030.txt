import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge probabilities by iteratively constructing routes by adaptively weighting distance, demand, and angle, rewarding edges in successful routes and penalizing those in failed attempts based on their contribution to constraint violations.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones((n, n))
    
    num_samples = 1000
    reward_factor = 1.0
    penalty_factor = 0.5
    angle_factor = 0.1

    for _ in range(num_samples):
        current_node = 0
        route = [0]
        remaining_nodes = list(range(1, n))
        vehicle_load = 0
        current_route = []

        while remaining_nodes:
            # Adaptive weighting based on remaining capacity, demand, and angle
            weights = []
            for node_idx in remaining_nodes:
                demand = demands[node_idx]
                distance = distance_matrix[current_node, node_idx]
                
                # Calculate angle between current_node, next_node, and depot
                current_coords = coordinates[current_node]
                next_coords = coordinates[node_idx]
                depot_coords = coordinates[0]
                
                vector1 = next_coords - current_coords
                vector2 = depot_coords - current_coords
                
                dot_product = np.dot(vector1, vector2)
                magnitude1 = np.linalg.norm(vector1)
                magnitude2 = np.linalg.norm(vector2)
                
                # Avoid division by zero
                if magnitude1 == 0 or magnitude2 == 0:
                  angle = 0
                else:
                  angle = np.arccos(dot_product / (magnitude1 * magnitude2))
                
                # Bias towards closer nodes with smaller demands and smaller angles if capacity allows
                if vehicle_load + demand <= capacity:
                  weight = distance + (demand / capacity) + (angle_factor * angle)
                  weights.append((weight, node_idx))
                else:
                  weights.append((float('inf'),node_idx))

            #Select the best node with minimum weight
            sorted_weights = sorted(weights, key = lambda x: x[0])

            next_node_found = False
            for weight, candidate_node in sorted_weights:
                if weight != float('inf'):
                    next_node = candidate_node
                    next_node_found = True
                    break
            
            if not next_node_found:
                # Penalize the edges of the current route
                penalty = penalty_factor * (vehicle_load / capacity)
                for node in current_route:
                    heuristics_matrix[current_node, 0] -= penalty
                    heuristics_matrix[0, current_node] -= penalty
                current_node = 0
                vehicle_load = 0
                current_route = []
                continue

            # Update route
            route.append(next_node)
            current_route.append(next_node)
            vehicle_load += demands[next_node]

            # Reward edge
            heuristics_matrix[current_node, next_node] += reward_factor
            heuristics_matrix[next_node, current_node] += reward_factor

            # Remove node from remaining nodes
            remaining_nodes.remove(next_node)
            current_node = next_node

        # Return to depot
        route.append(0)
        heuristics_matrix[current_node, 0] += reward_factor
        heuristics_matrix[0, current_node] += reward_factor
    
    return heuristics_matrix
