import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge probabilities by iteratively constructing routes by adaptively weighting distance, demand, and a pheromone-like trace, rewarding edges in successful routes and penalizing those in failed attempts based on their contribution to constraint violations.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones((n, n))
    pheromone_matrix = np.ones((n, n)) * 0.1  # Initialize pheromone matrix

    num_samples = 1000
    reward_factor = 1.0
    penalty_factor = 0.5
    pheromone_decay = 0.01
    pheromone_weight = 0.5 # Importance of pheromone

    for _ in range(num_samples):
        current_node = 0
        route = [0]
        remaining_nodes = list(range(1, n))
        vehicle_load = 0
        current_route = []

        while remaining_nodes:
            # Adaptive weighting based on remaining capacity, demand, distance, and pheromone
            weights = []
            for node_idx in remaining_nodes:
                demand = demands[node_idx]
                distance = distance_matrix[current_node, node_idx]
                pheromone = pheromone_matrix[current_node, node_idx]

                # Bias towards closer nodes with smaller demands if capacity allows
                if vehicle_load + demand <= capacity:
                    weight = distance + (demand / capacity) - (pheromone_weight * pheromone)
                    weights.append((weight, node_idx))
                else:
                    weights.append((float('inf'), node_idx))

            # Select the best node with minimum weight
            sorted_weights = sorted(weights, key=lambda x: x[0])

            next_node_found = False
            for weight, candidate_node in sorted_weights:
                if weight != float('inf'):
                    next_node = candidate_node
                    next_node_found = True
                    break

            if not next_node_found:
                # Penalize the edges of the current route and decay pheromones
                penalty = penalty_factor * (vehicle_load / capacity)
                for node in current_route:
                    heuristics_matrix[current_node, node] -= penalty
                    heuristics_matrix[node, current_node] -= penalty
                    pheromone_matrix[current_node, node] *= (1 - pheromone_decay)
                    pheromone_matrix[node, current_node] *= (1 - pheromone_decay)

                current_node = 0
                vehicle_load = 0
                current_route = []
                continue

            # Update route
            route.append(next_node)
            current_route.append(next_node)
            vehicle_load += demands[next_node]

            # Reward edge and update pheromone
            heuristics_matrix[current_node, next_node] += reward_factor
            heuristics_matrix[next_node, current_node] += reward_factor
            pheromone_matrix[current_node, next_node] += reward_factor
            pheromone_matrix[next_node, current_node] += reward_factor

            # Remove node from remaining nodes
            remaining_nodes.remove(next_node)
            current_node = next_node

        # Return to depot
        route.append(0)
        heuristics_matrix[current_node, 0] += reward_factor
        heuristics_matrix[0, current_node] += reward_factor
        pheromone_matrix[current_node, 0] += reward_factor
        pheromone_matrix[0, current_node] += reward_factor

        #Decay all pheromones after each route construction to reduce accumulation
        pheromone_matrix *= (1 - pheromone_decay)
    return heuristics_matrix
