import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs routes by iteratively selecting the nearest feasible node and applies simulated annealing to refine the routes by occasionally accepting worse solutions to escape local optima.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones((n, n))

    num_samples = 100
    temperature = 100
    cooling_rate = 0.95

    for _ in range(num_samples):
        current_node = 0
        route = [0]
        remaining_nodes = list(range(1, n))
        vehicle_load = 0
        current_route = []

        while remaining_nodes:
            # Select the next node based on shortest distance
            distances = distance_matrix[current_node, remaining_nodes]
            sorted_indices = np.argsort(distances)

            next_node_found = False
            for idx in sorted_indices:
                candidate_node = remaining_nodes[idx]
                if vehicle_load + demands[candidate_node] <= capacity:
                    next_node = candidate_node
                    next_node_found = True
                    break

            if not next_node_found:
                # Return to depot if no feasible node found
                route.append(0)
                current_node = 0
                vehicle_load = 0
                current_route = []
                remaining_nodes = list(range(1, n))
                route = [0] # restart route from depot
                continue

            # Update route information
            route.append(next_node)
            current_route.append(next_node)
            vehicle_load += demands[next_node]

            # Update heuristic matrix
            heuristics_matrix[current_node, next_node] += 1
            heuristics_matrix[next_node, current_node] += 1

            # Remove node from remaining nodes
            remaining_nodes.remove(next_node)
            current_node = next_node

        # Return to depot
        route.append(0)
        heuristics_matrix[current_node, 0] += 1
        heuristics_matrix[0, current_node] += 1

        # Simulated Annealing - Perturb the route
        if np.random.rand() < 0.1: # Perturbation probability
            idx1 = np.random.randint(1, len(route) - 1)
            idx2 = np.random.randint(1, len(route) - 1)
            route[idx1], route[idx2] = route[idx2], route[idx1]

        temperature *= cooling_rate

    return heuristics_matrix
