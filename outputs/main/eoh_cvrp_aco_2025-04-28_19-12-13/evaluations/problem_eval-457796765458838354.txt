import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm combines an adaptive large neighborhood search (ALNS) framework with a route-splitting procedure to explore diverse solution spaces and refine routes, iteratively updating a heuristic matrix based on the frequency of edge usage in accepted solutions.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 500
    initial_temperature = 100
    cooling_rate = 0.98
    
    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost
    
    def calculate_total_cost(routes):
      total_cost = 0
      for route in routes:
        total_cost += calculate_route_cost(route)
      return total_cost
    
    def split_route(route):
        """Splits a route into multiple feasible routes based on capacity."""
        sub_routes = []
        current_route = [0]
        current_load = 0
        
        for node in route[1:-1]:
            if current_load + demands[node] <= capacity:
                current_route.append(node)
                current_load += demands[node]
            else:
                current_route.append(0)
                sub_routes.append(current_route)
                current_route = [0, node]
                current_load = demands[node]
        
        current_route.append(0)
        sub_routes.append(current_route)
        
        return sub_routes

    def generate_initial_solution():
        """Generates an initial solution using a simple insertion heuristic."""
        unassigned_nodes = set(range(1, n))
        routes = []
        while unassigned_nodes:
            route = [0, 0]
            current_load = 0
            while True:
                best_node = -1
                min_insertion_cost = float('inf')

                for node in unassigned_nodes:
                    if current_load + demands[node] <= capacity:
                        cost = distance_matrix[route[-2], node] + distance_matrix[node, 0] - distance_matrix[route[-2], 0]
                        if cost < min_insertion_cost:
                            min_insertion_cost = cost
                            best_node = node
                if best_node != -1:
                    route.insert(-1, best_node)
                    current_load += demands[best_node]
                    unassigned_nodes.remove(best_node)
                else:
                    break
            if len(route) > 2:
                routes.append(route)
        return routes

    # Adaptive Large Neighborhood Search (ALNS) Framework
    routes = generate_initial_solution()
    best_routes = [route[:] for route in routes]
    best_cost = calculate_total_cost(routes)
    current_temperature = initial_temperature

    for _ in range(num_iterations):
        # 1. Select a route to destroy (randomly)
        if not routes: continue
        route_index = random.randint(0, len(routes) - 1)
        destroyed_route = routes.pop(route_index)

        # 2. Split the destroyed route into feasible sub-routes
        sub_routes = split_route(destroyed_route)
        
        # 3. Re-insert the sub-routes into the solution
        for sub_route in sub_routes:
            if len(sub_route) > 2:
                routes.append(sub_route)

        # 4. Evaluate the new solution
        current_cost = calculate_total_cost(routes)
        cost_difference = current_cost - best_cost
        
        # 5. Acceptance criterion (Simulated Annealing)
        if cost_difference < 0 or random.random() < np.exp(-cost_difference / current_temperature):
            if current_cost < best_cost:
                best_cost = current_cost
                best_routes = [route[:] for route in routes]
        else:
            #Revert if move rejected
            routes.pop()
            routes.insert(route_index, destroyed_route)

        current_temperature *= cooling_rate

    # Heuristic Matrix Update
    for route in best_routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1

    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
