import numpy as np
import random
from collections import deque

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses an Ant Colony Optimization approach to explore the solution space, constructing routes iteratively based on pheromone trails and heuristic information, and then updates the pheromone trails based on the quality of the solutions found.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    pheromone_matrix = np.ones_like(distance_matrix)
    alpha = 1
    beta = 2
    rho = 0.1
    Q = 100
    num_ants = 20
    num_iterations = 100

    def calculate_route_load(route):
        load = 0
        for node in route:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost
    
    def ant_tour(pheromone, unvisited, current_node, current_route, current_load, capacity):
        if not unvisited:
            current_route.append(0)
            return current_route
        
        probabilities = []
        for next_node in unvisited:
            if current_load + demands[next_node] <= capacity:
                heuristic = (1.0 / distance_matrix[current_node, next_node])**beta
                trail = (pheromone[current_node, next_node])**alpha
                probabilities.append((next_node, trail * heuristic))
            else:
                probabilities.append((next_node, 0))
        
        total_prob = sum([prob for node, prob in probabilities])
        if total_prob == 0:
            return None # No feasible nodes left

        probabilities = [(node, prob / total_prob) for node, prob in probabilities]
        
        #Roulette wheel selection
        rand = random.random()
        cumulative_prob = 0
        next_node = -1
        for node, prob in probabilities:
            cumulative_prob += prob
            if rand <= cumulative_prob:
                next_node = node
                break
        
        if next_node == -1:
            return None

        new_unvisited = unvisited.copy()
        new_unvisited.remove(next_node)
        new_route = current_route + [next_node]
        new_load = current_load + demands[next_node]
        
        return ant_tour(pheromone, new_unvisited, next_node, new_route, new_load, capacity)
    
    for _ in range(num_iterations):
        all_routes = []
        for _ in range(num_ants):
            unvisited_nodes = set(range(1, n))
            route = [0]
            current_load = 0
            
            final_route = ant_tour(pheromone_matrix, unvisited_nodes, 0, route, current_load, capacity)
            
            if final_route is not None:
                all_routes.append(final_route)

        # Pheromone Update
        for i in range(n):
            for j in range(n):
                pheromone_matrix[i, j] *= (1 - rho)
        
        for route in all_routes:
            cost = calculate_route_cost(route)
            if cost > 0:
                delta_pheromone = Q / cost
            else:
                delta_pheromone = 0
            for i in range(len(route) - 1):
                pheromone_matrix[route[i], route[i+1]] += delta_pheromone
                pheromone_matrix[route[i+1], route[i]] += delta_pheromone

    #Heuristic Matrix construction
    for i in range(n):
      for j in range(n):
        heuristics_matrix[i,j] = pheromone_matrix[i,j]

    #Normalize
    total_pheromone = np.sum(pheromone_matrix)
    if total_pheromone > 0:
        heuristics_matrix = heuristics_matrix / total_pheromone
    return heuristics_matrix
