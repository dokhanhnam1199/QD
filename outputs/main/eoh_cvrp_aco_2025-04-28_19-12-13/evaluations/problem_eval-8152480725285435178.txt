import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge importance by iteratively constructing routes using a nearest neighbor approach with stochastic selection, favoring shorter edges and respecting capacity constraints, and updates edge importance based on route frequency and edge length with adjusted weighting, but modifying the probability calculation to emphasize the nearest neighbors more strongly and adjusting the impact of edge distance in the heuristic score.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000

    for _ in range(num_samples):
        # Start from the depot
        current_node = 0
        current_route = [0]
        current_load = 0
        remaining_customers = set(range(1, n))
        routes = []

        while remaining_customers:
            # Find nearest neighbors within capacity
            eligible_neighbors = []
            for neighbor in remaining_customers:
                if current_load + demands[neighbor] <= capacity:
                    eligible_neighbors.append(neighbor)

            if not eligible_neighbors:
                # Return to depot and start a new route
                current_route.append(0)
                routes.append(current_route)
                current_route = [0]
                current_load = 0
                current_node = 0
                continue
            
            # Stochastic selection of the next node based on distance
            probabilities = []
            total_weight = 0
            for neighbor in eligible_neighbors:
                weight = np.exp(-distance_matrix[current_node, neighbor] / (distance_matrix.mean()+ 1e-6))  # Exponential weighting
                total_weight += weight

            for neighbor in eligible_neighbors:
                weight = np.exp(-distance_matrix[current_node, neighbor] / (distance_matrix.mean()+ 1e-6)) # Exponential weighting
                probabilities.append(weight / total_weight)

            next_node = random.choices(eligible_neighbors, weights=probabilities, k=1)[0]
            
            current_route.append(next_node)
            current_load += demands[next_node]
            remaining_customers.remove(next_node)
            current_node = next_node
        
        current_route.append(0)
        routes.append(current_route)
    
        # Update heuristic matrix based on edges in the routes
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1

    # Normalize the heuristic matrix
    heuristics_matrix = heuristics_matrix / num_samples

    # Incorporate distance information (shorter distances are better)
    heuristics_matrix = heuristics_matrix / (distance_matrix + 1e-6)**0.75 # Avoid division by zero and adjust the exponent

    return heuristics_matrix
