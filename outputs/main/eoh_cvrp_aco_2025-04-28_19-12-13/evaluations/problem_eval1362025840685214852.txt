import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge probabilities by repeatedly sampling random routes using a regret-based insertion heuristic, penalizing edges in poorly performing routes and rewarding edges in promising routes.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones((n, n))

    num_samples = 1000
    penalty_factor = 10
    reward_factor = 5

    for _ in range(num_samples):
        current_node = 0
        route = [0]
        remaining_nodes = list(range(1, n))
        vehicle_load = 0
        current_route = []

        while remaining_nodes:
            # Calculate insertion cost for each remaining node
            insertion_costs = {}
            for node in remaining_nodes:
                if vehicle_load + demands[node] <= capacity:
                    best_insertion_cost = float('inf')
                    best_insertion_index = -1

                    # Try inserting the node at different positions in the current route
                    for i in range(len(current_route) + 1):
                        if i == 0:
                          cost = distance_matrix[0,node] + distance_matrix[node,current_route[0]] - distance_matrix[0,current_route[0]]
                        elif i == len(current_route):
                          cost = distance_matrix[current_route[-1],node] + distance_matrix[node,0] - distance_matrix[current_route[-1],0]
                        else:
                          cost = distance_matrix[current_route[i-1],node] + distance_matrix[node,current_route[i]] - distance_matrix[current_route[i-1],current_route[i]]
                        
                        if cost < best_insertion_cost:
                            best_insertion_cost = cost
                            best_insertion_index = i

                    insertion_costs[node] = (best_insertion_cost, best_insertion_index)

            if not insertion_costs:
                # Return to depot if no feasible node found
                for node in current_route:
                    heuristics_matrix[current_node, node] -= penalty_factor
                    heuristics_matrix[node, current_node] -= penalty_factor
                heuristics_matrix[current_node, 0] -= penalty_factor
                heuristics_matrix[0, current_node] -= penalty_factor
                current_node = 0
                vehicle_load = 0
                current_route = []
                continue
            
            # Select node with minimum insertion cost
            best_node = min(insertion_costs, key=lambda k: insertion_costs[k][0])
            best_insertion_cost, best_insertion_index = insertion_costs[best_node]

            #Insert best_node into current_route
            if len(current_route) == 0:
              current_route.insert(0,best_node)
            else:
              current_route.insert(best_insertion_index, best_node)

            # Update route information
            route.append(best_node)
            vehicle_load += demands[best_node]

            # Update heuristic matrix
            heuristics_matrix[current_node, best_node] += reward_factor
            heuristics_matrix[best_node, current_node] += reward_factor

            # Remove node from remaining nodes
            remaining_nodes.remove(best_node)
            current_node = best_node

        # Return to depot
        route.append(0)
        heuristics_matrix[current_node, 0] += reward_factor
        heuristics_matrix[0, current_node] += reward_factor

    return heuristics_matrix
