import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm explores the solution space by constructing routes using a weighted combination of savings, pheromone, and distance, updating the pheromone matrix with an adaptive learning rate, and intensifying the search around promising edges.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 500
    pheromone_matrix = np.ones_like(distance_matrix) * 0.01

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    def two_opt_swap(route):
        best_route = route[:]
        best_cost = calculate_route_cost(route)
        for i in range(1, len(route) - 2):
            for k in range(i + 1, len(route) - 1):
                new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]
                new_cost = calculate_route_cost(new_route)
                if new_cost < best_cost:
                    best_route = new_route[:]
                    best_cost = new_cost
        return best_route

    def savings_heuristic(i, j):
        return distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]

    best_routes = None
    best_cost = float('inf')

    for iteration in range(num_iterations):
        routes = []
        unassigned_nodes = set(range(1, n))

        while unassigned_nodes:
            i = random.choice(list(unassigned_nodes))
            route = [0, i, 0]
            current_load = demands[i]
            unassigned_nodes.remove(i)

            while True:
                eligible_nodes = []
                for j in unassigned_nodes:
                    if current_load + demands[j] <= capacity:
                        eligible_nodes.append(j)

                if not eligible_nodes:
                    break

                probabilities = []
                for node in eligible_nodes:
                    savings = savings_heuristic(route[-2], node)
                    pheromone = pheromone_matrix[route[-2], node]
                    distance = distance_matrix[route[-2], node]
                    # Weighted combination of savings, pheromone, and inverse distance
                    probabilities.append(savings * pheromone / (distance + 1e-6)) # Adding a small constant to avoid division by zero
                
                if sum(probabilities) == 0:
                    next_node = random.choice(eligible_nodes)
                else:
                    probabilities = [p / sum(probabilities) for p in probabilities]
                    next_node = random.choices(eligible_nodes, weights=probabilities, k=1)[0]
                

                route.insert(-1, next_node)
                current_load += demands[next_node]
                unassigned_nodes.remove(next_node)

            routes.append(route)

        for i in range(len(routes)):
            routes[i] = two_opt_swap(routes[i])

        current_cost = sum(calculate_route_cost(route) for route in routes)

        if current_cost < best_cost:
            best_cost = current_cost
            best_routes = [route[:] for route in routes]
            
            # Adaptive Pheromone Update
            delta_pheromone = 1.0 / current_cost
            learning_rate = 0.1  # Fixed learning rate

            for route in routes:
                for i in range(len(route) - 1):
                    pheromone_matrix[route[i], route[i+1]] += learning_rate * delta_pheromone
                    pheromone_matrix[route[i+1], route[i]] += learning_rate * delta_pheromone

        # Evaporation
        pheromone_matrix *= 0.9

    for route in best_routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1
    

    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
