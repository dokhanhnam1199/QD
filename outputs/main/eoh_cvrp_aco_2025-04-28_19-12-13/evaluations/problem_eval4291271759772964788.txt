import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively samples routes by probabilistically selecting edges based on an evolving edge frequency matrix, and then refines these routes using a guided local search, updating the edge frequency matrix based on the improved routes.}
    """
    n = len(demands)
    heuristics_matrix = np.ones_like(distance_matrix, dtype=float) * 0.001  # Initialize with small values to avoid division by zero
    num_iterations = 100
    num_samples = 10
    local_search_iterations = 10

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    def construct_route(start_node, unvisited_nodes):
        route = [0, start_node, 0]
        current_load = demands[start_node]
        while True:
            possible_next_nodes = []
            probabilities = []
            for node in unvisited_nodes:
                if current_load + demands[node] <= capacity:
                    possible_next_nodes.append(node)
                    probabilities.append(heuristics_matrix[route[-2], node])

            if not possible_next_nodes:
                break

            probabilities = np.array(probabilities)
            probabilities /= np.sum(probabilities)

            next_node = np.random.choice(possible_next_nodes, p=probabilities)
            route.insert(len(route)-1, next_node)
            current_load += demands[next_node]
            unvisited_nodes.remove(next_node)
        return route, unvisited_nodes

    def guided_local_search(routes):
        for _ in range(local_search_iterations):
            for route in routes:
                if len(route) <= 3:
                    continue

                for i in range(1, len(route) - 2):
                    for k in range(i + 1, len(route) - 1):
                        new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]

                        current_cost = calculate_route_cost(route)
                        new_cost = calculate_route_cost(new_route)

                        if new_cost < current_cost:
                            route[:] = new_route

    for _ in range(num_iterations):
        all_routes = []
        for _ in range(num_samples):
            unvisited_nodes = set(range(1, n))
            routes = []
            while unvisited_nodes:
                start_node = random.choice(list(unvisited_nodes))
                route, unvisited_nodes = construct_route(start_node, unvisited_nodes)
                routes.append(route)

            guided_local_search(routes)
            all_routes.extend(routes)

        # Update heuristic matrix based on the sampled routes
        for route in all_routes:
            for i in range(len(route) - 1):
                heuristics_matrix[route[i], route[i+1]] += 1
                heuristics_matrix[route[i+1], route[i]] += 1

    # Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
        heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
