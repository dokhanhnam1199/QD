import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs routes using a cluster-first, route-second approach, where nodes are first clustered based on proximity to randomly selected seed nodes, and then routes are optimized within each cluster using a genetic algorithm.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_clusters = int(np.ceil(sum(demands) / capacity))
    num_iterations = 100
    population_size = 50
    mutation_rate = 0.1

    # Cluster-First: Random Seed Clustering
    clusters = [[] for _ in range(num_clusters)]
    unassigned_nodes = set(range(1, n))
    seed_nodes = random.sample(range(1, n), min(num_clusters, n - 1))
    cluster_seeds = {seed_nodes[i]: i for i in range(len(seed_nodes))}


    while unassigned_nodes:
        node = unassigned_nodes.pop()
        best_cluster = -1
        min_dist = float('inf')

        for seed, cluster_id in cluster_seeds.items():
             dist = distance_matrix[node, seed]
             if dist < min_dist:
                min_dist = dist
                best_cluster = cluster_id
        
        clusters[best_cluster].append(node)

    # Route-Second: Genetic Algorithm for each cluster
    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    def create_individual(cluster):
        return [0] + random.sample(cluster, len(cluster)) + [0]

    def crossover(parent1, parent2):
        start = random.randint(1, len(parent1) - 2)
        end = random.randint(start + 1, len(parent1) - 1)
        offspring = [0] * len(parent1)
        offspring[start:end] = parent1[start:end]
        
        ptr1 = 1
        ptr2 = 1
        for i in range(len(parent1)):
            if offspring[i] == 0:
                while parent2[ptr2] in offspring:
                    ptr2+=1
                offspring[i] = parent2[ptr2]
                ptr2+=1
        return offspring
        

    def mutate(individual, mutation_rate):
        if random.random() < mutation_rate:
            idx1, idx2 = random.sample(range(1, len(individual) - 1), 2)
            individual[idx1], individual[idx2] = individual[idx2], individual[idx1]
        return individual

    for cluster in clusters:
        if not cluster:
            continue

        population = [create_individual(cluster) for _ in range(population_size)]

        for _ in range(num_iterations):
            # Evaluate fitness
            fitness = [(calculate_route_cost(individual), individual) for individual in population]
            fitness.sort(key=lambda x: x[0])

            # Selection (Elitism)
            selected = [individual for _, individual in fitness[:population_size // 2]]

            # Crossover and Mutation
            offspring = []
            while len(offspring) < population_size - len(selected):
                parent1 = random.choice(selected)
                parent2 = random.choice(selected)
                child = crossover(parent1, parent2)
                child = mutate(child, mutation_rate)
                offspring.append(child)

            population = selected + offspring
        
        best_route = min(population, key=calculate_route_cost)

        # Update heuristics matrix
        for i in range(len(best_route) - 1):
            heuristics_matrix[best_route[i], best_route[i+1]] += 1
            heuristics_matrix[best_route[i+1], best_route[i]] += 1

    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits
    return heuristics_matrix
