import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs an initial solution using a nearest neighbor heuristic, then iteratively improves the solution by swapping nodes between routes and within routes, accepting moves based on cost improvement or a simulated annealing criterion, and finally aggregates edge frequencies from the accepted solutions to build a heuristic matrix.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 1000
    initial_temperature = 50
    cooling_rate = 0.995

    # 1. Initial Solution (Nearest Neighbor)
    def create_initial_solution(distance_matrix, demands, capacity):
        remaining_nodes = set(range(1, len(demands)))
        routes = []
        while remaining_nodes:
            route = [0]
            current_capacity = capacity
            current_node = 0
            while remaining_nodes:
                nearest_node = None
                min_distance = float('inf')
                for neighbor in remaining_nodes:
                    if distance_matrix[current_node, neighbor] < min_distance and demands[neighbor] <= current_capacity:
                        nearest_node = neighbor
                        min_distance = distance_matrix[current_node, neighbor]

                if nearest_node is None:
                    break

                route.append(nearest_node)
                current_capacity -= demands[nearest_node]
                remaining_nodes.remove(nearest_node)
                current_node = nearest_node
            route.append(0)
            routes.append(route)
        return routes

    routes = create_initial_solution(distance_matrix, demands, capacity)

    def calculate_cost(routes):
        cost = 0
        for route in routes:
            for i in range(len(route) - 1):
                cost += distance_matrix[route[i]][route[i+1]]
        return cost

    def is_feasible(routes):
        for route in routes:
            current_capacity = capacity
            for i in range(1,len(route)-1):
                current_capacity -= demands[route[i]]
            if current_capacity < 0:
                return False
        return True

    best_routes = [route[:] for route in routes]
    best_cost = calculate_cost(routes)

    # 2. Iterative Improvement (Simulated Annealing with Node Swaps)
    temperature = initial_temperature
    for iteration in range(num_iterations):
        routes_copy = [route[:] for route in routes]
        # a. Perturb: Randomly select a route and perform a swap (within or between routes)
        if len(routes_copy) > 0:
            route_idx1 = random.randint(0, len(routes_copy) - 1)
            route1 = routes_copy[route_idx1]

            # Swap within route
            if len(route1) > 3:
                idx1 = random.randint(1, len(route1) - 2)
                idx2 = random.randint(1, len(route1) - 2)
                route1[idx1], route1[idx2] = route1[idx2], route1[idx1]
                routes_copy[route_idx1] = route1

            #Swap between routes
            else:
                route_idx2 = random.randint(0, len(routes_copy) - 1)
                while route_idx2 == route_idx1 and len(routes_copy) > 1:
                    route_idx2 = random.randint(0, len(routes_copy) - 1)
                route2 = routes_copy[route_idx2]

                if len(route1) > 2 and len(route2) > 2:

                    node_idx1 = random.randint(1, len(route1) - 2)
                    node_idx2 = random.randint(1, len(route2) - 2)

                    node1 = route1[node_idx1]
                    node2 = route2[node_idx2]

                    route1[node_idx1] = node2
                    route2[node_idx2] = node1
                    
                    original_capacity1 = capacity
                    for i in range(1, len(route1)-1):
                        original_capacity1 -= demands[route1[i]]

                    original_capacity2 = capacity
                    for i in range(1, len(route2)-1):
                        original_capacity2 -= demands[route2[i]]


                    if original_capacity1 < 0 or original_capacity2 < 0:
                        routes_copy = [route[:] for route in routes]
                    else:
                        routes_copy[route_idx1] = route1
                        routes_copy[route_idx2] = route2

            new_cost = calculate_cost(routes_copy)
            cost_difference = new_cost - calculate_cost(routes)

            # b. Acceptance Criterion (Simulated Annealing)
            if cost_difference < 0 or random.random() < np.exp(-cost_difference / temperature):
                routes = routes_copy
                if new_cost < best_cost:
                    best_cost = new_cost
                    best_routes = [route[:] for route in routes]

        # c. Cooling
        temperature *= cooling_rate

    # 3. Heuristic Matrix Construction
    for route in best_routes:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
