import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge probabilities by repeatedly sampling random routes using a regret-based insertion heuristic to select nodes, penalizing edges in infeasible routes, and rewarding edges in feasible routes.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones((n, n))

    num_samples = 1000
    penalty_factor = 10
    reward_factor = 1

    for _ in range(num_samples):
        current_node = 0
        route = [0]
        remaining_nodes = list(range(1, n))
        vehicle_load = 0
        current_route = []

        while remaining_nodes:
            # Calculate regret values for each remaining node
            regrets = {}
            for node in remaining_nodes:
                if vehicle_load + demands[node] <= capacity:
                    distances = distance_matrix[current_node, remaining_nodes]
                    sorted_indices = np.argsort(distances)
                    
                    best_insertion_cost = distance_matrix[current_node, node] + distance_matrix[node, 0] - distance_matrix[current_node, 0] if not current_route else distance_matrix[current_node, node] 
                    
                    second_best_node = None
                    second_best_cost = float('inf')

                    
                    if len(remaining_nodes) > 1:

                        potential_second_best_nodes = [rem_node for rem_node in remaining_nodes if rem_node != node]
                        
                        for other_node in potential_second_best_nodes:
                            
                            cost = distance_matrix[current_node, other_node] + distance_matrix[other_node, 0] - distance_matrix[current_node, 0] if not current_route else distance_matrix[current_node, other_node]
                            if cost < second_best_cost:
                                second_best_cost = cost
                                second_best_node = other_node
                    else:
                        second_best_cost = float('inf')

                    regrets[node] = second_best_cost - best_insertion_cost if second_best_node else 0
                else:
                    regrets[node] = -float('inf')

            # Select the node with the highest regret value
            if regrets:
                next_node = max(regrets, key=regrets.get)
            else:
                next_node = None

            if next_node is None or vehicle_load + demands[next_node] > capacity:
              # Return to depot if no feasible node found
              for node in current_route:
                heuristics_matrix[current_node, 0] -= penalty_factor
                heuristics_matrix[0, current_node] -= penalty_factor
              
              vehicle_load = 0
              current_node = 0
              current_route = []
              
              continue

            # Update route information
            route.append(next_node)
            current_route.append(next_node)
            vehicle_load += demands[next_node]

            # Update heuristic matrix
            heuristics_matrix[current_node, next_node] += reward_factor
            heuristics_matrix[next_node, current_node] += reward_factor

            # Remove node from remaining nodes
            remaining_nodes.remove(next_node)
            current_node = next_node

        # Return to depot
        route.append(0)
        heuristics_matrix[current_node, 0] += reward_factor
        heuristics_matrix[0, current_node] += reward_factor

    return heuristics_matrix
