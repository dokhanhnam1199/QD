import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge probabilities by iteratively constructing routes using a combination of shortest distance and pheromone-inspired reinforcement learning with adaptive pheromone evaporation and dynamic route improvement.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix, dtype=float)
    pheromone_matrix = np.ones_like(distance_matrix, dtype=float)
    
    num_iterations = 1000
    alpha = 1  # Influence of distance
    beta = 2   # Influence of pheromone
    rho_initial = 0.5  # Initial evaporation rate
    rho_min = 0.05      # Minimum evaporation rate
    Q = 100    # Pheromone deposit amount
    
    best_cost = float('inf')
    best_route = None

    for iteration in range(num_iterations):
        current_node = 0
        route = [0]
        remaining_nodes = list(range(1, n))
        vehicle_load = 0
        current_route = []
        routes = []

        while remaining_nodes:
            probabilities = np.zeros(len(remaining_nodes))
            for i, next_node in enumerate(remaining_nodes):
                if vehicle_load + demands[next_node] <= capacity:
                    probabilities[i] = pheromone_matrix[current_node, next_node]**beta / distance_matrix[current_node, next_node]**alpha
                else:
                    probabilities[i] = 0
            
            if np.sum(probabilities) == 0:
                routes.append(current_route)
                route.append(0)
                current_node = 0
                current_route = []
                vehicle_load = 0
                continue

            probabilities /= np.sum(probabilities)
            next_node = np.random.choice(remaining_nodes, p=probabilities)
            

            if vehicle_load + demands[next_node] <= capacity:
                pass
            else:
                routes.append(current_route)
                route.append(0)
                current_node = 0
                current_route = []
                vehicle_load = 0
                
            route.append(next_node)
            current_route.append(next_node)
            vehicle_load += demands[next_node]

            remaining_nodes.remove(next_node)
            current_node = next_node

        route.append(0)
        routes.append(current_route)

        total_cost = 0
        for current_route in routes:
          if len(current_route) > 0:
            total_cost += distance_matrix[0, current_route[0]]
            total_cost += distance_matrix[current_route[-1], 0]
            for i in range(len(current_route) - 1):
                total_cost += distance_matrix[current_route[i], current_route[i+1]]

        # Dynamic route improvement (simplified, can be enhanced)
        if iteration > num_iterations // 2:
            for i in range(len(routes)):
                if len(routes[i]) > 2:
                    if random.random() < 0.1:  # Small chance to reverse a sub-route
                        routes[i] = routes[i][::-1]
        
        if total_cost < best_cost:
            best_cost = total_cost
            best_route = route

        # Adaptive pheromone evaporation
        rho = rho_initial - (rho_initial - rho_min) * (iteration / num_iterations)

        # Pheromone update
        pheromone_matrix *= (1 - rho)  # Evaporation
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            pheromone_matrix[u, v] += Q / total_cost
            pheromone_matrix[v, u] += Q / total_cost

        # Update heuristics based on pheromone levels
        heuristics_matrix = pheromone_matrix
    return heuristics_matrix
