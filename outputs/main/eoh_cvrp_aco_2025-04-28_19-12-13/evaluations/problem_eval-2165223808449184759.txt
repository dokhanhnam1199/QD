import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs routes by iteratively selecting the nearest feasible node based on distance and remaining capacity, adjusting edge probabilities based on route feasibility and employing a decaying reward/penalty mechanism.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones((n, n))

    num_samples = 1000
    penalty_factor = 5
    reward_factor = 1
    decay_rate = 0.95

    for _ in range(num_samples):
        current_node = 0
        route = [0]
        remaining_nodes = list(range(1, n))
        vehicle_load = 0
        current_route = []

        while remaining_nodes:
            # Select the nearest feasible node
            distances = distance_matrix[current_node, remaining_nodes]
            feasible_nodes = [node for i, node in enumerate(remaining_nodes) if vehicle_load + demands[node] <= capacity]

            if not feasible_nodes:
                # Return to depot
                for node in current_route:
                    heuristics_matrix[current_node, 0] -= penalty_factor
                    heuristics_matrix[0, current_node] -= penalty_factor
                    current_node = 0
                vehicle_load = 0
                current_route = []
                continue

            # Select nearest feasible node
            distances_to_feasible = [distance_matrix[current_node, node] for node in feasible_nodes]
            nearest_node = feasible_nodes[np.argmin(distances_to_feasible)]

            # Update route information
            route.append(nearest_node)
            current_route.append(nearest_node)
            vehicle_load += demands[nearest_node]

            # Update heuristic matrix - reward feasible edges
            heuristics_matrix[current_node, nearest_node] += reward_factor
            heuristics_matrix[nearest_node, current_node] += reward_factor

            # Remove node from remaining nodes
            remaining_nodes.remove(nearest_node)
            current_node = nearest_node

        # Return to depot
        route.append(0)
        heuristics_matrix[current_node, 0] += reward_factor
        heuristics_matrix[0, current_node] += reward_factor

        # Decay reward/penalty factors
        reward_factor *= decay_rate
        penalty_factor *= decay_rate

    return heuristics_matrix
