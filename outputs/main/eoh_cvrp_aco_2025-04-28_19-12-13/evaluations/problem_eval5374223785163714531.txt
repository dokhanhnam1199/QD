import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm combines adaptive large neighborhood search (ALNS) with a shared pheromone matrix across neighborhoods to promote exploration and exploitation of promising edges.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 500
    pheromone_matrix = np.ones_like(distance_matrix) * 0.01  # Initialize pheromone matrix
    decay_factor = 0.9
    alns_iterations = 100

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    def two_opt_swap(route):
        best_route = route[:]
        best_cost = calculate_route_cost(route)
        for i in range(1, len(route) - 2):
            for k in range(i + 1, len(route) - 1):
                new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]
                new_cost = calculate_route_cost(new_route)
                if new_cost < best_cost:
                    best_route = new_route[:]
                    best_cost = new_cost
        return best_route

    def savings_heuristic(i, j):
        return distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]

    def random_removal(routes, removal_percentage=0.2):
        num_nodes_to_remove = int(sum(len(route) - 2 for route in routes) * removal_percentage)
        removed_nodes = []
        
        possible_removals = []
        for route_idx, route in enumerate(routes):
          for node_idx in range(1, len(route) - 1):
            possible_removals.append((route_idx, node_idx))
        
        if not possible_removals:
            return routes, []

        
        nodes_to_remove = random.sample(possible_removals, min(num_nodes_to_remove, len(possible_removals)))
        
        
        new_routes = [route[:] for route in routes]
        for route_idx, node_idx in nodes_to_remove:
            removed_nodes.append(new_routes[route_idx].pop(node_idx))
            
        return new_routes, removed_nodes

    def greedy_insertion(routes, removed_nodes, demands, capacity, distance_matrix):
        for node in removed_nodes:
            best_insertion_route = None
            best_insertion_index = None
            best_insertion_cost = float('inf')

            for route_idx, route in enumerate(routes):
                for i in range(1, len(route)):
                    temp_route = route[:]
                    temp_route.insert(i, node)
                    if calculate_route_load(temp_route) <= capacity:
                        cost = calculate_route_cost(temp_route)
                        if cost < best_insertion_cost:
                            best_insertion_cost = cost
                            best_insertion_route = route_idx
                            best_insertion_index = i
            
            if best_insertion_route is not None:
                routes[best_insertion_route].insert(best_insertion_index, node)
            else:
                # Create new route
                routes.append([0, node, 0])

        return routes

    best_routes = None
    best_cost = float('inf')

    for iteration in range(num_iterations):
        # Initial Solution
        routes = []
        unassigned_nodes = set(range(1, n))

        while unassigned_nodes:
            i = random.choice(list(unassigned_nodes))
            route = [0, i, 0]
            current_load = demands[i]
            unassigned_nodes.remove(i)

            while True:
                eligible_nodes = []
                for j in unassigned_nodes:
                    if current_load + demands[j] <= capacity:
                        eligible_nodes.append(j)

                if not eligible_nodes:
                    break

                probabilities = []
                for node in eligible_nodes:
                    savings = savings_heuristic(route[-2], node)
                    pheromone_value = pheromone_matrix[route[-2], node]
                    probabilities.append(savings * pheromone_value)

                if sum(probabilities) == 0:
                    next_node = random.choice(eligible_nodes)
                else:
                    probabilities = [p / sum(probabilities) for p in probabilities]
                    next_node = random.choices(eligible_nodes, weights=probabilities, k=1)[0]

                route.insert(-1, next_node)
                current_load += demands[next_node]
                unassigned_nodes.remove(next_node)

            routes.append(route)

        # ALNS
        for alns_iter in range(alns_iterations):
            # Removal
            new_routes, removed_nodes = random_removal(routes)

            # Insertion
            new_routes = greedy_insertion(new_routes, removed_nodes, demands, capacity, distance_matrix)

            # 2-Opt
            for i in range(len(new_routes)):
                new_routes[i] = two_opt_swap(new_routes[i])
            
            # Evaluate new solution
            new_cost = sum(calculate_route_cost(route) for route in new_routes)

            # Accept/Reject (Simple acceptance criteria)
            if new_cost < sum(calculate_route_cost(route) for route in routes):
                routes = [route[:] for route in new_routes]
        
        # Evaluate Solution
        current_cost = sum(calculate_route_cost(route) for route in routes)

        # Update Best Solution
        if current_cost < best_cost:
            best_cost = current_cost
            best_routes = [route[:] for route in routes]

            # Pheromone Update (after ALNS)
            delta_pheromone = 1.0 / current_cost
            for route in routes:
                for i in range(len(route) - 1):
                    pheromone_matrix[route[i], route[i+1]] += delta_pheromone
                    pheromone_matrix[route[i+1], route[i]] += delta_pheromone

        # Evaporation
        pheromone_matrix *= decay_factor

    # Heuristic Matrix Update based on best solution
    for route in best_routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1
            
    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits
    
    return heuristics_matrix
