import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs a heuristic matrix by iteratively generating feasible routes based on a cost-benefit ratio, where cost is the distance between nodes and benefit is the reduction in remaining unserved demand if the edge is added to the route.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 500

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    for iteration in range(num_iterations):
        unassigned_nodes = set(range(1, n))
        current_node = 0
        route = [0]
        current_load = 0

        while unassigned_nodes:
            eligible_nodes = []
            for node in unassigned_nodes:
                if current_load + demands[node] <= capacity:
                    eligible_nodes.append(node)

            if not eligible_nodes:
                heuristics_matrix[current_node, 0] += 1
                heuristics_matrix[0, current_node] += 1
                current_node = 0
                route.append(0)
                current_load = 0
                continue

            # Calculate cost-benefit ratio for each eligible node
            cost_benefit_ratios = {}
            remaining_demand = sum([demands[node] for node in unassigned_nodes])
            for node in eligible_nodes:
                cost = distance_matrix[current_node, node]
                benefit = demands[node] / remaining_demand
                if cost == 0:
                    cost_benefit_ratios[node] = float('inf')
                else:
                    cost_benefit_ratios[node] = benefit / cost

            # Select node with highest cost-benefit ratio
            best_node = max(cost_benefit_ratios, key=cost_benefit_ratios.get)

            # Update route and heuristics matrix
            route.append(best_node)
            heuristics_matrix[current_node, best_node] += 1
            heuristics_matrix[best_node, current_node] += 1

            # Update current state
            current_load += demands[best_node]
            unassigned_nodes.remove(best_node)
            current_node = best_node

        route.append(0)
        heuristics_matrix[current_node, 0] += 1
        heuristics_matrix[0, current_node] += 1

    # Normalize the heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
        heuristics_matrix = heuristics_matrix / total_visits
    return heuristics_matrix
