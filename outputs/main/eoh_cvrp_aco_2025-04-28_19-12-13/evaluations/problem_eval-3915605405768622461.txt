import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs multiple solutions by iteratively inserting unassigned nodes into routes based on a weighted combination of distance, demand, and a pheromone-inspired heuristic, and then averages the edge frequencies across these solutions to estimate edge importance.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 500
    pheromone_matrix = np.ones_like(distance_matrix) * 0.01

    def calculate_route_load(route):
        load = 0
        for node in route[1:]:
            load += demands[node]
        return load

    def calculate_insertion_cost(route, node):
        best_insertion_cost = float('inf')
        best_insertion_index = -1
        for i in range(1, len(route)):
            cost = distance_matrix[route[i-1], node] + distance_matrix[node, route[i]] - distance_matrix[route[i-1], route[i]]
            if cost < best_insertion_cost:
                best_insertion_cost = cost
                best_insertion_index = i
        return best_insertion_cost, best_insertion_index

    for iteration in range(num_iterations):
        routes = [[0]]
        unassigned_nodes = set(range(1, n))

        while unassigned_nodes:
            node_to_insert = None
            best_route_index = -1
            best_insertion_index = -1
            best_insertion_cost = float('inf')

            for node in unassigned_nodes:
                best_route_for_node = -1
                best_index_for_node = -1
                min_insertion_cost = float('inf')

                for route_index in range(len(routes)):
                    if calculate_route_load(routes[route_index]) + demands[node] <= capacity:
                        insertion_cost, insertion_index = calculate_insertion_cost(routes[route_index], node)
                        if insertion_cost < min_insertion_cost:
                            min_insertion_cost = insertion_cost
                            best_route_for_node = route_index
                            best_index_for_node = insertion_index

                if best_route_for_node != -1:
                    # Combine distance, demand, and pheromone
                    combined_cost = min_insertion_cost + demands[node] * 0.1 - pheromone_matrix[routes[best_route_for_node][-1], node] * 0.05

                    if combined_cost < best_insertion_cost:
                        best_insertion_cost = combined_cost
                        node_to_insert = node
                        best_route_index = best_route_for_node
                        best_insertion_index = best_index_for_node

            if node_to_insert is None:
                # Start a new route
                routes.append([0])
            else:
                routes[best_route_index].insert(best_insertion_index, node_to_insert)
                unassigned_nodes.remove(node_to_insert)

        #Add depot to the end of each route
        for route in routes:
            route.append(0)

        # Update pheromone matrix
        for route in routes:
            for i in range(len(route) - 1):
                pheromone_matrix[route[i], route[i+1]] *= 0.9
                pheromone_matrix[route[i+1], route[i]] *= 0.9
                pheromone_matrix[route[i], route[i+1]] += 1.0 / (sum(distance_matrix[route[k], route[k+1]] for k in range(len(route) - 1)) + 1e-6)
                pheromone_matrix[route[i+1], route[i]] += 1.0 / (sum(distance_matrix[route[k], route[k+1]] for k in range(len(route) - 1)) + 1e-6)

        # Update heuristic matrix
        for route in routes:
            for i in range(len(route) - 1):
                heuristics_matrix[route[i], route[i+1]] += 1
                heuristics_matrix[route[i+1], route[i]] += 1

    # Normalize
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
