import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm explores a wider range of solutions by adjusting the influence of savings and pheromone in route construction and employing a more aggressive pheromone update strategy.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 500
    pheromone_matrix = np.ones_like(distance_matrix) * 0.01  # Initialize pheromone matrix
    alpha = 0.7  # Weight for savings
    beta = 0.3   # Weight for pheromone
    evaporation_rate = 0.7 # Increased evaporation rate

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    def two_opt_swap(route):
        best_route = route[:]
        best_cost = calculate_route_cost(route)
        for i in range(1, len(route) - 2):
            for k in range(i + 1, len(route) - 1):
                new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]
                new_cost = calculate_route_cost(new_route)
                if new_cost < best_cost:
                    best_route = new_route[:]
                    best_cost = new_cost
        return best_route

    def savings_heuristic(i, j):
        return distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]

    best_routes = None
    best_cost = float('inf')

    for iteration in range(num_iterations):
        routes = []
        unassigned_nodes = set(range(1, n))

        # Randomized Savings-Based Route Construction
        while unassigned_nodes:
            i = random.choice(list(unassigned_nodes))
            route = [0, i, 0]
            current_load = demands[i]
            unassigned_nodes.remove(i)

            while True:
                eligible_nodes = []
                for j in unassigned_nodes:
                    if current_load + demands[j] <= capacity:
                        eligible_nodes.append(j)

                if not eligible_nodes:
                    break

                # Use pheromone and savings to select the next node
                probabilities = []
                for node in eligible_nodes:
                    savings = savings_heuristic(route[-2], node)
                    pheromone = pheromone_matrix[route[-2], node]
                    probabilities.append((savings**alpha) * (pheromone**beta))
                
                if sum(probabilities) == 0:
                    next_node = random.choice(eligible_nodes)
                else:
                    probabilities = [p / sum(probabilities) for p in probabilities]
                    next_node = random.choices(eligible_nodes, weights=probabilities, k=1)[0]
                

                route.insert(-1, next_node)
                current_load += demands[next_node]
                unassigned_nodes.remove(next_node)

            routes.append(route)

        # Route Improvement with 2-Opt
        for i in range(len(routes)):
            routes[i] = two_opt_swap(routes[i])

        # Evaluate Solution
        current_cost = sum(calculate_route_cost(route) for route in routes)

        # Update Best Solution
        if current_cost < best_cost:
            best_cost = current_cost
            best_routes = [route[:] for route in routes]
            
             # Pheromone Update (Aggressive Update)
            delta_pheromone = 1.0 / current_cost
            for route in routes:
                for i in range(len(route) - 1):
                    pheromone_matrix[route[i], route[i+1]] += 2*delta_pheromone # Increased pheromone deposit
                    pheromone_matrix[route[i+1], route[i]] += 2*delta_pheromone # Increased pheromone deposit

        # Evaporation
        pheromone_matrix *= evaporation_rate

    # Heuristic Matrix Update based on best solution
    for route in best_routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1
    
    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
