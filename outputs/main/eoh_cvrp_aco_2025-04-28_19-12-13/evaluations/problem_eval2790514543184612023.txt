import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm starts with a greedy insertion approach for initial routes, then iteratively improves routes using a combination of 2-opt and node relocation local search, while updating edge frequencies.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 50

    # Initial route construction (Greedy Insertion)
    routes = []
    unvisited = set(range(1, n))

    while unvisited:
        route = [0]
        current_load = 0
        last_node = 0
        
        while True:
            best_node = -1
            best_dist = float('inf')

            for node in unvisited:
                if current_load + demands[node] <= capacity:
                    dist = distance_matrix[last_node, node]
                    if dist < best_dist:
                        best_dist = dist
                        best_node = node
            
            if best_node != -1:
                route.append(best_node)
                current_load += demands[best_node]
                unvisited.remove(best_node)
                last_node = best_node
            else:
                route.append(0)
                routes.append(route)
                break
    

    # Iterative Improvement (Local Search - 2-opt and Node Relocation)
    for _ in range(num_iterations):
        # 2-opt within routes
        for route in routes:
            if len(route) <= 3:
                continue
            for i in range(1, len(route) - 2):
                for k in range(i + 1, len(route) - 1):
                    new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]
                    
                    current_cost = 0
                    for j in range(len(route) - 1):
                        current_cost += distance_matrix[route[j], route[j+1]]
                    
                    new_cost = 0
                    for j in range(len(new_route) - 1):
                        new_cost += distance_matrix[new_route[j], new_route[j+1]]

                    if new_cost < current_cost:
                        route[:] = new_route

        # Node relocation between routes
        for r1_idx in range(len(routes)):
            for r2_idx in range(r1_idx + 1, len(routes)):
                route1 = routes[r1_idx]
                route2 = routes[r2_idx]

                if len(route1) <= 2 or len(route2) <= 2:
                    continue
                
                for i in range(1, len(route1) - 1):
                    for j in range(1, len(route2) - 1):
                        node_to_move = route1[i]
                        
                        if demands[node_to_move] + sum([demands[n] for n in route2[1:-1]]) <= capacity:

                            temp_route1 = route1[:i] + route1[i+1:]
                            temp_route2 = route2[:j] + [node_to_move] + route2[j:]

                            current_cost = 0
                            for k in range(len(route1) - 1):
                                current_cost += distance_matrix[route1[k], route1[k+1]]
                            for k in range(len(route2) - 1):
                                current_cost += distance_matrix[route2[k], route2[k+1]]

                            new_cost = 0
                            for k in range(len(temp_route1) - 1):
                                new_cost += distance_matrix[temp_route1[k], temp_route1[k+1]]
                            for k in range(len(temp_route2) - 1):
                                new_cost += distance_matrix[temp_route2[k], temp_route2[k+1]]

                            if new_cost < current_cost:
                                route1[:] = temp_route1
                                route2[:] = temp_route2
    # Update heuristics matrix
    for route in routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1

    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits
    return heuristics_matrix
