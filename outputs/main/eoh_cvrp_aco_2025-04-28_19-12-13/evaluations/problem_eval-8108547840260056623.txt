import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively constructs solutions using a randomized insertion heuristic, followed by route improvement via 3-opt swaps and guided by a pheromone-inspired heuristic matrix updated based on solution quality and edge usage frequency.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 500
    pheromone_matrix = np.ones_like(distance_matrix) * 0.01  # Initialize pheromone matrix

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    def three_opt_swap(route):
        best_route = route[:]
        best_cost = calculate_route_cost(route)
        for i in range(1, len(route) - 3):
            for j in range(i + 1, len(route) - 2):
                for k in range(j + 1, len(route) - 1):
                    # Possible 3-opt swaps (8 variations, including no change)
                    segments = [route[1:i+1], route[i+1:j+1], route[j+1:k+1], route[k+1:-1]]
                    
                    #Try reversing each of the segments independently
                    variations = [
                        segments[0] + segments[1] + segments[2] + segments[3], #Original
                        segments[0][::-1] + segments[1] + segments[2] + segments[3],
                        segments[0] + segments[1][::-1] + segments[2] + segments[3],
                        segments[0] + segments[1] + segments[2][::-1] + segments[3],
                        segments[0] + segments[1] + segments[2] + segments[3][::-1],
                        segments[0][::-1] + segments[1][::-1] + segments[2] + segments[3],
                        segments[0] + segments[1][::-1] + segments[2][::-1] + segments[3],
                        segments[0] + segments[1] + segments[2][::-1] + segments[3][::-1],
                        segments[0][::-1] + segments[1] + segments[2][::-1] + segments[3],
                        segments[0][::-1] + segments[1] + segments[2] + segments[3][::-1],
                        segments[0] + segments[1][::-1] + segments[2] + segments[3][::-1],
                        segments[0][::-1] + segments[1][::-1] + segments[2][::-1] + segments[3],
                        segments[0][::-1] + segments[1][::-1] + segments[2] + segments[3][::-1],
                        segments[0][::-1] + segments[1] + segments[2][::-1] + segments[3][::-1],
                        segments[0] + segments[1][::-1] + segments[2][::-1] + segments[3][::-1],
                        segments[0][::-1] + segments[1][::-1] + segments[2][::-1] + segments[3][::-1],
                    ]
                    
                    for var in variations:
                        new_route = [0] + var + [0]
                        new_cost = calculate_route_cost(new_route)
                        if new_cost < best_cost:
                            best_route = new_route[:]
                            best_cost = new_cost

        return best_route

    best_routes = None
    best_cost = float('inf')

    for iteration in range(num_iterations):
        routes = []
        unassigned_nodes = set(range(1, n))

        # Randomized Insertion Route Construction
        while unassigned_nodes:
            route = [0, 0]  # Start with depot
            current_load = 0
            
            while unassigned_nodes:
                best_node = None
                best_insertion_cost = float('inf')

                for node in unassigned_nodes:
                    if current_load + demands[node] <= capacity:
                        # Find best insertion point
                        for i in range(1, len(route)):
                            insertion_cost = distance_matrix[route[i-1], node] + distance_matrix[node, route[i]] - distance_matrix[route[i-1], route[i]]
                            if insertion_cost < best_insertion_cost:
                                best_insertion_cost = insertion_cost
                                best_node = node
                                best_insertion_index = i

                if best_node is None:
                    break #No more nodes can fit in the current route

                #Insert the best node
                route.insert(best_insertion_index, best_node)
                current_load += demands[best_node]
                unassigned_nodes.remove(best_node)
            
            routes.append(route)

        # Route Improvement with 3-Opt
        for i in range(len(routes)):
            routes[i] = three_opt_swap(routes[i])

        # Evaluate Solution
        current_cost = sum(calculate_route_cost(route) for route in routes)

        # Update Best Solution
        if current_cost < best_cost:
            best_cost = current_cost
            best_routes = [route[:] for route in routes]

            # Pheromone Update
            delta_pheromone = 1.0 / current_cost
            for route in routes:
                for i in range(len(route) - 1):
                    pheromone_matrix[route[i], route[i+1]] += delta_pheromone
                    pheromone_matrix[route[i+1], route[i]] += delta_pheromone

        # Evaporation
        pheromone_matrix *= 0.9

    # Heuristic Matrix Update based on best solution (edge frequency)
    edge_counts = np.zeros_like(distance_matrix, dtype=int)
    for route in best_routes:
        for i in range(len(route) - 1):
            edge_counts[route[i], route[i+1]] += 1
            edge_counts[route[i+1], route[i]] += 1

    # Normalize heuristic matrix
    total_visits = np.sum(edge_counts)
    if total_visits > 0:
        heuristics_matrix = edge_counts / total_visits

    return heuristics_matrix
