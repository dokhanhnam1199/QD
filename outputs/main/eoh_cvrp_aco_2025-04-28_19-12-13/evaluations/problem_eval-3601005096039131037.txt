import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively constructs routes by adaptive large neighborhood search (ALNS) principles, removing and re-inserting nodes based on destroy and repair operators, and updates edge frequencies based on the accepted solutions.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 100
    alns_iterations = 50
    
    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost
    
    def calculate_total_cost(routes):
      total_cost = 0
      for route in routes:
        total_cost += calculate_route_cost(route)
      return total_cost
    
    def initial_solution(distance_matrix, demands, capacity):
      unassigned_nodes = set(range(1, len(demands)))
      routes = []
      while unassigned_nodes:
          route = [0, 0]
          current_load = 0

          while True:
              best_node = -1
              min_dist = float('inf')

              for node in unassigned_nodes:
                  if current_load + demands[node] <= capacity:
                      dist = distance_matrix[route[-2], node] #distance from last node in the route to the candidate node
                      if dist < min_dist:
                          min_dist = dist
                          best_node = node

              if best_node != -1:
                  route.insert(len(route)-1, best_node)
                  current_load += demands[best_node]
                  unassigned_nodes.remove(best_node)
              else:
                  break

          if len(route) > 2: #only append routes with customer nodes
              routes.append(route)
      return routes
    
    def destroy_operator(routes, q = 0.3):
      """Remove q% of total nodes"""
      all_nodes = []
      for route in routes:
        all_nodes.extend(route[1:-1])
      
      num_remove = int(len(all_nodes) * q)
      remove_nodes = random.sample(all_nodes, min(num_remove, len(all_nodes)))
      
      new_routes = []
      for route in routes:
        new_route = [0]
        for node in route[1:-1]:
          if node not in remove_nodes:
            new_route.append(node)
        new_route.append(0)
        if len(new_route) > 2:
          new_routes.append(new_route)
          
      return new_routes, remove_nodes
    
    def repair_operator(routes, removed_nodes, distance_matrix, demands, capacity):
      unassigned_nodes = removed_nodes[:]
      while unassigned_nodes:
          best_node = -1
          best_route_index = -1
          best_insertion_index = -1
          min_insertion_cost = float('inf')

          for node in unassigned_nodes:
              for r_index, route in enumerate(routes):
                  current_load = calculate_route_load(route)
                  if current_load + demands[node] <= capacity:
                      for i in range(1, len(route)):
                          cost = distance_matrix[route[i-1], node] + distance_matrix[node, route[i]] - distance_matrix[route[i-1], route[i]]
                          if cost < min_insertion_cost:
                              min_insertion_cost = cost
                              best_node = node
                              best_route_index = r_index
                              best_insertion_index = i
          
          if best_node != -1:
              routes[best_route_index].insert(best_insertion_index, best_node)
              unassigned_nodes.remove(best_node)
          else:
              # If no feasible insertion is found, create a new route
              new_route = [0, node, 0]
              routes.append(new_route)
              unassigned_nodes.remove(node)
          
      return routes
    
    #ALNS Iteration
    best_routes = []
    best_cost = float('inf')

    for _ in range(num_iterations):
        # Initialize
        current_routes = initial_solution(distance_matrix, demands, capacity)
        current_cost = calculate_total_cost(current_routes)

        for _ in range(alns_iterations):
            # Destroy and Repair
            destroyed_routes, removed_nodes = destroy_operator(current_routes)
            repaired_routes = repair_operator(destroyed_routes, removed_nodes, distance_matrix, demands, capacity)

            # Evaluate
            new_cost = calculate_total_cost(repaired_routes)

            #Acceptance criterion (Greedy)
            if new_cost < current_cost:
                current_routes = repaired_routes
                current_cost = new_cost
                
                if current_cost < best_cost:
                    best_cost = current_cost
                    best_routes = [route[:] for route in current_routes]

    # Heuristic Matrix Update
    for route in best_routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1
    
    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
