import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses a Large Neighborhood Search (LNS) approach to iteratively improve routes by tearing down and rebuilding portions of the current solution, guiding the rebuilding process using a regret heuristic.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 500
    neighborhood_size = int(n * 0.4)  # Percentage of nodes to remove and re-insert
    
    # Initialize a greedy solution
    unvisited = list(range(1, n))
    current_routes = []
    current_route = [0]
    current_capacity = capacity
    while unvisited:
        best_node = None
        best_cost = float('inf')
        for node in unvisited:
            if current_capacity >= demands[node]:
                cost = distance_matrix[current_route[-1], node]
                if cost < best_cost:
                    best_cost = cost
                    best_node = node
        
        if best_node is not None:
            current_route.append(best_node)
            current_capacity -= demands[best_node]
            unvisited.remove(best_node)
        else:
            current_route.append(0)
            current_routes.append(current_route)
            current_route = [0]
            current_capacity = capacity
    current_route.append(0)
    current_routes.append(current_route)
    
    def calculate_cost(routes):
        cost = 0
        for route in routes:
            for i in range(len(route) - 1):
                cost += distance_matrix[route[i], route[i+1]]
        return cost
    
    current_cost = calculate_cost(current_routes)

    for iteration in range(num_iterations):
        # LNS: Tear down part of the solution
        removed_nodes = []
        new_routes = [route[:] for route in current_routes] # Deep copy
        
        # Randomly select routes to tear down from
        routes_to_tear = random.sample(range(len(new_routes)), min(len(new_routes), int(len(new_routes)*0.6))) #Tear down from part of routes
        for route_index in sorted(routes_to_tear, reverse=True):
          num_nodes_to_remove = min(len(new_routes[route_index]) - 2, int(neighborhood_size / len(routes_to_tear) + 1))
          if num_nodes_to_remove > 0:
            nodes_to_remove = random.sample(range(1, len(new_routes[route_index]) - 1), num_nodes_to_remove)
            nodes_to_remove.sort(reverse=True)
            for node_index in nodes_to_remove:
              removed_nodes.append(new_routes[route_index].pop(node_index))
            if len(new_routes[route_index]) <= 2:
              new_routes.pop(route_index)
        
        #Re-insert removed nodes using regret heuristic
        random.shuffle(removed_nodes)
        for node_to_insert in removed_nodes:
          best_insertion_route = None
          best_insertion_index = None
          best_regret = -float('inf')

          for route_index in range(len(new_routes)):
            temp_route = new_routes[route_index][:]
            if capacity - sum(demands[customer] for customer in temp_route[1:-1]) >= demands[node_to_insert]:
              for insert_index in range(1, len(temp_route)):
                temp_route.insert(insert_index, node_to_insert)
                cost_increase = distance_matrix[temp_route[insert_index-1], node_to_insert] + distance_matrix[node_to_insert, temp_route[insert_index+1]] - distance_matrix[temp_route[insert_index-1], temp_route[insert_index+1]]
                
                #Calculate 2nd best insertion cost for regret heuristic
                second_best_cost_increase = float('inf')
                for second_insert_index in range(1, len(new_routes[route_index]) + 1):
                  if second_insert_index != insert_index:
                    temp_route2 = new_routes[route_index][:]
                    temp_route2.insert(second_insert_index, node_to_insert)
                    cost_increase2 = distance_matrix[temp_route2[second_insert_index-1], node_to_insert] + distance_matrix[node_to_insert, temp_route2[second_insert_index+1]] - distance_matrix[temp_route2[second_insert_index-1], temp_route2[second_insert_index+1]]
                    second_best_cost_increase = min(second_best_cost_increase, cost_increase2)
                
                regret = second_best_cost_increase - cost_increase

                if regret > best_regret:
                  best_regret = regret
                  best_insertion_route = route_index
                  best_insertion_index = insert_index
                temp_route.pop(insert_index) #undo insertion

          if best_insertion_route is not None:
            new_routes[best_insertion_route].insert(best_insertion_index, node_to_insert)
          else: #create a new route
            new_routes.append([0, node_to_insert, 0])

        new_cost = calculate_cost(new_routes)

        # Accept if improved
        if new_cost < current_cost:
            current_routes = new_routes
            current_cost = new_cost

            # Update the heuristics matrix
            for route in current_routes:
                for i in range(len(route) - 1):
                    heuristics_matrix[route[i], route[i+1]] += 1
                    heuristics_matrix[route[i+1], route[i]] += 1

    return heuristics_matrix
