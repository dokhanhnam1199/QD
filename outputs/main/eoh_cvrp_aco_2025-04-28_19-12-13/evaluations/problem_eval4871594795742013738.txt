import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs a heuristic matrix by iteratively improving routes using a combination of shortest distance, demand feasibility, and a diversification factor to explore different solution spaces.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones((n, n))

    num_iterations = 1000
    diversification_factor = 0.1

    for _ in range(num_iterations):
        current_node = 0
        route = [0]
        remaining_nodes = list(range(1, n))
        vehicle_load = 0

        while remaining_nodes:
            # Calculate scores based on distance, demand and a diversification factor
            scores = []
            for i, node_idx in enumerate(remaining_nodes):
                demand = demands[node_idx]
                distance = distance_matrix[current_node, node_idx]

                if vehicle_load + demand <= capacity:
                    # Score is the inverse of distance, penalized by demand, and boosted by diversification
                    score = 1 / (distance + 1e-6) - demand * 0.01 + np.random.rand() * diversification_factor
                    scores.append((score, node_idx))
                else:
                    scores.append((-np.inf, node_idx))  # Infeasible node

            # Select the node with the highest score
            best_score, next_node = max(scores, key=lambda x: x[0])

            if best_score == -np.inf:  # No feasible node, return to depot
                route.append(0)
                heuristics_matrix[current_node, 0] += 1
                heuristics_matrix[0, current_node] += 1
                current_node = 0
                vehicle_load = 0
                route.append(0)
                break  # Restart route from depot

            # Update route and vehicle load
            route.append(next_node)
            vehicle_load += demands[next_node]

            # Update heuristic matrix: reward selected edge
            heuristics_matrix[current_node, next_node] += 1
            heuristics_matrix[next_node, current_node] += 1

            # Remove the selected node from remaining nodes
            remaining_nodes.remove(next_node)
            current_node = next_node

        if current_node != 0:  # Ensure return to depot
            route.append(0)
            heuristics_matrix[current_node, 0] += 1
            heuristics_matrix[0, current_node] += 1
    return heuristics_matrix
