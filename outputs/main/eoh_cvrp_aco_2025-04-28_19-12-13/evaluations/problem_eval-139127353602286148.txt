import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm initializes routes randomly, applies iterative improvement via node swaps and 2-opt optimization within and between routes, and updates a heuristic matrix based on edge usage frequency in the best solutions found.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 500
    num_routes = int(np.ceil(sum(demands) / capacity))

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    def two_opt_swap(route):
        best_route = route[:]
        best_cost = calculate_route_cost(route)
        for i in range(1, len(route) - 2):
            for k in range(i + 1, len(route) - 1):
                new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]
                new_cost = calculate_route_cost(new_route)
                if new_cost < best_cost:
                    best_route = new_route[:]
                    best_cost = new_cost
        return best_route

    def initialize_routes():
        unassigned_nodes = set(range(1, n))
        routes = [ [0] for _ in range(num_routes)]
        route_index = 0
        while unassigned_nodes:
            node = random.choice(list(unassigned_nodes))
            if calculate_route_load(routes[route_index]) + demands[node] <= capacity:
                routes[route_index].append(node)
                unassigned_nodes.remove(node)
            else:
                route_index = (route_index + 1) % num_routes
                if len(routes[route_index]) > 1 :
                  routes[route_index] = [0]
            if not unassigned_nodes:
               break
        for i in range(len(routes)):
            routes[i].append(0) 

        return routes

    # Iterative Improvement: Node Swaps and 2-Opt
    best_routes = None
    best_cost = float('inf')
    for _ in range(num_iterations):
      routes = initialize_routes()
      
      for i in range(len(routes)):
          routes[i] = two_opt_swap(routes[i])
      
      
      #Node Swapping
      route1_index = random.randint(0, len(routes) - 1)
      route2_index = random.randint(0, len(routes) - 1)
      while route1_index == route2_index:
            route2_index = random.randint(0, len(routes) - 1)

      if len(routes[route1_index]) > 2 and len(routes[route2_index]) > 2:
            node1_index = random.randint(1, len(routes[route1_index]) - 2)
            node2_index = random.randint(1, len(routes[route2_index]) - 2)
            node1 = routes[route1_index][node1_index]
            node2 = routes[route2_index][node2_index]
        
            load1_without_node1 = calculate_route_load(routes[route1_index]) - demands[node1]
            load2_without_node2 = calculate_route_load(routes[route2_index]) - demands[node2]
      
            if load1_without_node1 + demands[node2] <= capacity and load2_without_node2 + demands[node1] <= capacity:
                  routes[route1_index][node1_index] = node2
                  routes[route2_index][node2_index] = node1

                  for i in range(len(routes)):
                      routes[i] = two_opt_swap(routes[i])
            
      current_cost = sum(calculate_route_cost(route) for route in routes)
      
      if current_cost < best_cost:
            best_cost = current_cost
            best_routes = [route[:] for route in routes]


    # Heuristic Matrix Update
    if best_routes:
      for route in best_routes:
          for i in range(len(route) - 1):
              heuristics_matrix[route[i], route[i+1]] += 1
              heuristics_matrix[route[i+1], route[i]] += 1

    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits
    return heuristics_matrix
