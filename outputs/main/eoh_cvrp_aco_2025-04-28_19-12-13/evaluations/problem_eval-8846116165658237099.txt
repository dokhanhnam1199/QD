import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs initial routes randomly with capacity constraints, then iteratively refines these routes using a combination of 2-opt and node relocation local search, updating edge frequencies based on improved solutions.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 50
    num_initial_routes = 10

    # Initial Route Construction (Random)
    routes = []
    for _ in range(num_initial_routes):
        unvisited = set(range(1, n))
        while unvisited:
            route = [0]
            current_load = 0
            while unvisited:
                possible_nodes = [node for node in unvisited if current_load + demands[node] <= capacity]
                if not possible_nodes:
                    break
                next_node = random.choice(possible_nodes)
                route.append(next_node)
                current_load += demands[next_node]
                unvisited.remove(next_node)
            route.append(0)
            routes.append(route)

    # Iterative Improvement (Local Search)
    for _ in range(num_iterations):
        for route in routes:
            if len(route) <= 3:
                continue

            # 2-opt within routes
            for i in range(1, len(route) - 2):
                for k in range(i + 1, len(route) - 1):
                    new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]
                    
                    current_cost = sum(distance_matrix[route[j], route[j+1]] for j in range(len(route) - 1))
                    new_cost = sum(distance_matrix[new_route[j], new_route[j+1]] for j in range(len(new_route) - 1))

                    if new_cost < current_cost:
                        route[:] = new_route  # Update route in place

            # Node Relocation
            for _ in range(2): #limited relocation attempts
                node_to_relocate_index = random.randint(1, len(route) - 2)
                node_to_relocate = route[node_to_relocate_index]
                
                best_route = route[:]
                best_cost = sum(distance_matrix[route[j], route[j+1]] for j in range(len(route) - 1))

                temp_route = route[:node_to_relocate_index] + route[node_to_relocate_index+1:]
                
                for insert_index in range(1,len(temp_route)):
                    new_route = temp_route[:insert_index] + [node_to_relocate] + temp_route[insert_index:]
                    
                    new_cost = sum(distance_matrix[new_route[j], new_route[j+1]] for j in range(len(new_route) - 1))

                    if new_cost < best_cost:
                        best_cost = new_cost
                        best_route = new_route

                route[:] = best_route

    # Update heuristics matrix
    for route in routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1

    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits
    return heuristics_matrix
