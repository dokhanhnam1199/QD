import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm generates multiple random routes satisfying capacity constraints, evaluates their total distance, and assigns higher probabilities to edges frequently used in shorter routes.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 1000

    for _ in range(num_samples):
        route = [0]  # Start at the depot
        remaining_nodes = list(range(1, n))
        current_capacity = capacity
        current_route = [0]
        all_routes = []

        while remaining_nodes:
            feasible_nodes = [node for node in remaining_nodes if demands[node] <= current_capacity]
            
            if not feasible_nodes:
                all_routes.append(current_route)
                current_capacity = capacity
                current_route = [0]
                continue

            next_node = np.random.choice(feasible_nodes)
            
            current_route.append(next_node)
            current_capacity -= demands[next_node]
            remaining_nodes.remove(next_node)
        
        all_routes.append(current_route)
        all_routes = [r + [0] for r in all_routes]

        total_distance = 0
        for r in all_routes:
            for i in range(len(r) - 1):
                total_distance += distance_matrix[r[i], r[i+1]]
        
        for r in all_routes:
          for i in range(len(r)-1):
            heuristics_matrix[r[i], r[i+1]] += 1/total_distance
            heuristics_matrix[r[i+1], r[i]] += 1/total_distance #Symmetric

    return heuristics_matrix
