import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs an initial solution using a greedy insertion heuristic, then iteratively perturbs and optimizes the solution by randomly swapping nodes between routes, accepting changes that improve cost or satisfy an acceptance criterion based on simulated annealing, and aggregating edge frequencies from accepted solutions to build a heuristic matrix.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 1000
    initial_temperature = 100
    cooling_rate = 0.99
    
    # 1. Initial Solution (Greedy Insertion)
    routes = []
    remaining_nodes = set(range(1, n))
    
    while remaining_nodes:
        route = [0]
        current_capacity = capacity
        
        while True:
            feasible_nodes = [node for node in remaining_nodes if demands[node] <= current_capacity]
            if not feasible_nodes:
                break
            
            # Greedy: choose the nearest feasible node
            nearest_node = min(feasible_nodes, key=lambda node: distance_matrix[route[-1]][node])
            
            route.append(nearest_node)
            current_capacity -= demands[nearest_node]
            remaining_nodes.remove(nearest_node)
        
        route.append(0)
        routes.append(route)

    def calculate_cost(routes):
        cost = 0
        for route in routes:
            for i in range(len(route) - 1):
                cost += distance_matrix[route[i]][route[i+1]]
        return cost

    def is_feasible(routes):
        for route in routes:
            current_capacity = capacity
            for i in range(1,len(route)-1):
                current_capacity -= demands[route[i]]
            if current_capacity < 0:
                return False
        return True
        
    best_routes = routes[:]
    best_cost = calculate_cost(routes)
    
    # 2. Iterative Perturbation and Optimization (Simulated Annealing)
    temperature = initial_temperature
    for iteration in range(num_iterations):
        # a. Perturb: Randomly swap two nodes between routes
        
        routes_copy = [route[:] for route in routes]
        
        if len(routes_copy) > 1:
            route1_idx = random.randint(0, len(routes_copy) - 1)
            route2_idx = random.randint(0, len(routes_copy) - 1)
            while route1_idx == route2_idx:
                route2_idx = random.randint(0, len(routes_copy) - 1)
                
            route1 = routes_copy[route1_idx]
            route2 = routes_copy[route2_idx]
            
            if len(route1) > 2 and len(route2) > 2:
                node1_idx = random.randint(1, len(route1) - 2)
                node2_idx = random.randint(1, len(route2) - 2)
                
                node1 = route1[node1_idx]
                node2 = route2[node2_idx]
                
                route1[node1_idx] = node2
                route2[node2_idx] = node1

                # check capacity constraint
                route1_capacity = capacity
                for i in range(1, len(route1)-1):
                    route1_capacity -= demands[route1[i]]

                route2_capacity = capacity
                for i in range(1, len(route2)-1):
                    route2_capacity -= demands[route2[i]]

                if route1_capacity < 0 or route2_capacity < 0:
                    routes_copy = [route[:] for route in routes]
                else:
                    new_cost = calculate_cost(routes_copy)
                    cost_difference = new_cost - calculate_cost(routes)

                    # b. Acceptance Criterion (Simulated Annealing)
                    if cost_difference < 0 or random.random() < np.exp(-cost_difference / temperature):
                        routes = routes_copy
                        
                        if new_cost < best_cost:
                            best_cost = new_cost
                            best_routes = [route[:] for route in routes]
                            
        # c. Cooling
        temperature *= cooling_rate

    # 3. Heuristic Matrix Construction
    for route in best_routes:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
