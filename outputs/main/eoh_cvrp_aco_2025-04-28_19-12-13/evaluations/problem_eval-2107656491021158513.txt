import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs multiple solutions using a hybrid approach combining a greedy randomized construction and local search improvement, updating edge frequencies based on solution quality and diversity.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 200
    local_search_iterations = 50
    alpha = 0.3  # Randomization parameter for greedy construction
    beta = 0.7 # Weighting factor for solution quality vs. diversity in update

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost
    
    def calculate_total_cost(routes):
      total_cost = 0
      for route in routes:
        total_cost += calculate_route_cost(route)
      return total_cost

    def insertion_cost(route, node, index):
        """Calculates the cost of inserting a node into a route at a specific index."""
        cost = distance_matrix[route[index-1], node] + distance_matrix[node, route[index]] - distance_matrix[route[index-1], route[index]]
        return cost
    
    def local_search(routes):
        """Performs local search to improve the routes."""
        best_routes = [route[:] for route in routes]
        best_cost = calculate_total_cost(routes)

        for _ in range(local_search_iterations):
            # Select two random routes
            if len(routes) < 2:
                break
            route_index1 = random.randint(0, len(routes) - 1)
            route_index2 = random.randint(0, len(routes) - 1)
            if route_index1 == route_index2:
                continue
            
            # Select a random node from each route (excluding depot)
            if len(routes[route_index1]) <= 2 or len(routes[route_index2]) <= 2:
              continue
            node_index1 = random.randint(1, len(routes[route_index1]) - 2)
            node1 = routes[route_index1][node_index1]
            node_index2 = random.randint(1, len(routes[route_index2]) - 2)
            node2 = routes[route_index2][node_index2]

            # Attempt to swap the nodes
            original_cost = calculate_total_cost(routes)

            # Check capacity constraints before swapping
            load1_without_node1 = calculate_route_load(routes[route_index1]) - demands[node1]
            load2_without_node2 = calculate_route_load(routes[route_index2]) - demands[node2]

            if load1_without_node1 + demands[node2] <= capacity and load2_without_node2 + demands[node1] <= capacity:
                # Swap the nodes
                routes[route_index1][node_index1] = node2
                routes[route_index2][node_index2] = node1
                
                new_cost = calculate_total_cost(routes)

                # Accept the swap if it improves the solution
                if new_cost < original_cost:
                    current_cost = new_cost
                    if current_cost < best_cost:
                      best_cost = current_cost
                      best_routes = [route[:] for route in routes]
                else:
                    # Revert the swap if it worsens the solution
                    routes[route_index1][node_index1] = node1
                    routes[route_index2][node_index2] = node2
        
        return best_routes
    

    for _ in range(num_iterations):
        routes = []
        unassigned_nodes = set(range(1, n))

        # Randomized Greedy Construction
        while unassigned_nodes:
            route = [0, 0]
            current_load = 0
            
            while True:
                eligible_nodes = []
                for node in unassigned_nodes:
                    if current_load + demands[node] <= capacity:
                        eligible_nodes.append(node)

                if not eligible_nodes:
                    break
                
                # Randomized selection of the next node
                if random.random() < alpha:
                    # Choose a random node
                    next_node = random.choice(eligible_nodes)
                else:
                    # Choose the nearest node
                    best_node = -1
                    min_insertion_cost = float('inf')
                    for node in eligible_nodes:
                        for i in range(1, len(route)):
                            cost = insertion_cost(route, node, i)
                            if cost < min_insertion_cost:
                                min_insertion_cost = cost
                                best_node = node
                    next_node = best_node

                if next_node != -1:
                    best_insertion_index = -1
                    min_insertion_cost = float('inf')
                    for i in range(1, len(route)):
                        cost = insertion_cost(route, next_node, i)
                        if cost < min_insertion_cost:
                            min_insertion_cost = cost
                            best_insertion_index = i
                    route.insert(best_insertion_index, next_node)
                    current_load += demands[next_node]
                    unassigned_nodes.remove(next_node)
                else:
                    break
            
            if len(route) > 2:
                routes.append(route)

        #Local Search
        routes = local_search(routes)

        # Update Heuristic Matrix
        total_cost = calculate_total_cost(routes)
        
        # Update Heuristic Matrix based on solution quality
        for route in routes:
            for i in range(len(route) - 1):
                heuristics_matrix[route[i], route[i+1]] += beta / (total_cost + 1e-6)
                heuristics_matrix[route[i+1], route[i]] += beta / (total_cost + 1e-6)

        # Update Heuristic Matrix based on solution diversity
        all_edges = set()
        for route in routes:
            for i in range(len(route) - 1):
                all_edges.add((min(route[i], route[i+1]), max(route[i], route[i+1])))

        for edge in all_edges:
            heuristics_matrix[edge[0], edge[1]] += (1 - beta) / num_iterations
            heuristics_matrix[edge[1], edge[0]] += (1 - beta) / num_iterations

    # Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
