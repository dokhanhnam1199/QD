import numpy as np
import random
from collections import defaultdict

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a clustering-first, route-second approach, employing k-means clustering to group nodes based on location and demand, then solving each cluster as a separate TSP with capacity constraints, and finally aggregating the solutions into a combined heuristic matrix.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_clusters = int(np.sqrt(n)) # Heuristic for number of clusters

    def kmeans_clustering(coordinates, demands, num_clusters, capacity):
        # Initialize centroids randomly
        centroids_idx = random.sample(range(1, n), num_clusters)
        centroids = {idx: coordinates[idx] for idx in centroids_idx}
        
        clusters = defaultdict(list)
        
        for _ in range(10): # Iterate a few times for convergence
            clusters = defaultdict(list)
            for i in range(1, n):
                closest_centroid = min(centroids, key=lambda centroid: np.linalg.norm(coordinates[i] - centroids[centroid]))
                clusters[closest_centroid].append(i)
                
            # Recalculate centroids
            for centroid_idx in clusters:
                if clusters[centroid_idx]:
                   centroids[centroid_idx] = np.mean(coordinates[clusters[centroid_idx]], axis=0)

        # Capacity check and adjustment
        valid_clusters = {}
        for centroid_idx, nodes in clusters.items():
            total_demand = sum(demands[node] for node in nodes)
            if total_demand <= capacity:
                valid_clusters[centroid_idx] = nodes
            else:
                # Split large cluster: assign each node to a cluster of size 1
                valid_clusters[centroid_idx] = []
                for node in nodes:
                    valid_clusters[node] = [node]
                    
        return list(valid_clusters.values())


    def solve_tsp_with_capacity(nodes, distance_matrix, demands, capacity):
        if not nodes:
            return []

        # Add depot
        route = [0] + nodes + [0]
        
        # Basic TSP solver (Nearest Neighbor) with capacity constraint
        current_node = 0
        current_load = 0
        final_route = [0]
        remaining_nodes = nodes[:]
        
        while remaining_nodes:
          nearest_node = None
          min_dist = float('inf')
          
          for node in remaining_nodes:
            if current_load + demands[node] <= capacity:
              dist = distance_matrix[current_node, node]
              if dist < min_dist:
                min_dist = dist
                nearest_node = node
          
          if nearest_node is None: # Return to depot if no node can be added
              final_route.append(0)
              current_node = 0
              current_load = 0
              continue
          
          final_route.append(nearest_node)
          current_load += demands[nearest_node]
          current_node = nearest_node
          remaining_nodes.remove(nearest_node)
          
        final_route.append(0)
        return final_route

    # Clustering
    clusters = kmeans_clustering(coordinates, demands, num_clusters, capacity)

    # Solve TSP for each cluster
    cluster_routes = []
    for cluster in clusters:
        route = solve_tsp_with_capacity(cluster, distance_matrix, demands, capacity)
        cluster_routes.append(route)

    # Update heuristic matrix based on cluster routes
    for route in cluster_routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1

    # Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
