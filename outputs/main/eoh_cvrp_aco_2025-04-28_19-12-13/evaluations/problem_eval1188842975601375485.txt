import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes proportionally to the inverse of the distance, penalizing infeasible edge selections.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones((n, n))

    num_samples = 1000
    reward_factor = 1
    penalty_factor = 0.1

    for _ in range(num_samples):
        current_node = 0
        route = [0]
        remaining_nodes = list(range(1, n))
        vehicle_load = 0
        current_route = []

        while remaining_nodes:
            # Select the next node based on a combination of distance, demand
            distances = distance_matrix[current_node, remaining_nodes]
            
            # Create a score based on distance and demand
            scores = []
            for i, node_idx in enumerate(remaining_nodes):
                demand = demands[node_idx]
                distance = distances[i]
                
                if vehicle_load + demand <= capacity:
                    # Calculate score: inverse of the distance
                    score = 1 / (distance + 1e-6)  # Adding a small constant to avoid division by zero
                    scores.append((distance, score, node_idx))
                else:
                    scores.append((float('inf'), 0, node_idx))

            # Find the possible node based on minimum distance and maximum score
            sorted_scores = sorted(scores, key=lambda x: (x[0], -x[1]))

            next_node_found = False
            for distance, score, candidate_node in sorted_scores:
                if distance != float('inf'):
                    next_node = candidate_node
                    next_node_found = True
                    break

            if not next_node_found:
                # Return to depot if no feasible node found
                for node in current_route:
                    heuristics_matrix[current_node, 0] -= penalty_factor * distance_matrix[current_node,0]
                    heuristics_matrix[0, current_node] -= penalty_factor * distance_matrix[0, current_node]
                current_node = 0 # restart current_node from depot
                vehicle_load = 0
                current_route = []
                continue

            # Update route information
            route.append(next_node)
            current_route.append(next_node)
            vehicle_load += demands[next_node]

            # Update heuristic matrix (reward proportional to inverse of distance)
            heuristics_matrix[current_node, next_node] += reward_factor * score
            heuristics_matrix[next_node, current_node] += reward_factor * score

            # Remove node from remaining nodes
            remaining_nodes.remove(next_node)
            current_node = next_node

        # Return to depot
        route.append(0)
        heuristics_matrix[current_node, 0] += reward_factor
        heuristics_matrix[0, current_node] += reward_factor

    return heuristics_matrix
