import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm adaptively combines route construction and local search by probabilistically selecting between insertion heuristics and neighborhood search operators to iteratively refine solutions and update edge frequencies.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 500
    
    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost
    
    def calculate_total_cost(routes):
      total_cost = 0
      for route in routes:
        total_cost += calculate_route_cost(route)
      return total_cost

    def insertion_cost(route, node, index):
        """Calculates the cost of inserting a node into a route at a specific index."""
        cost = distance_matrix[route[index-1], node] + distance_matrix[node, route[index]] - distance_matrix[route[index-1], route[index]]
        return cost

    def two_opt_move(route, i, j):
      """Performs a 2-opt move on a route."""
      new_route = route[:i] + route[i:j+1][::-1] + route[j+1:]
      return new_route
    
    def perform_two_opt(route):
        best_route = route
        best_cost = calculate_route_cost(route)

        for i in range(1, len(route) - 2):
            for j in range(i + 1, len(route) - 1):
                new_route = two_opt_move(route, i, j)
                new_cost = calculate_route_cost(new_route)

                if new_cost < best_cost:
                    best_cost = new_cost
                    best_route = new_route
        return best_route

    #Main Iteration Loop
    for _ in range(num_iterations):
      routes = []
      unassigned_nodes = set(range(1, n))

      # Initial Solution Construction: Greedy Insertion with Capacity Check
      while unassigned_nodes:
          route = [0, 0]
          current_load = 0
          
          while True:
              best_node = -1
              best_insertion_index = -1
              min_insertion_cost = float('inf')
              
              for node in unassigned_nodes:
                  if current_load + demands[node] <= capacity:
                      for i in range(1, len(route)):
                          cost = insertion_cost(route, node, i)
                          if cost < min_insertion_cost:
                              min_insertion_cost = cost
                              best_node = node
                              best_insertion_index = i

              if best_node != -1:
                  route.insert(best_insertion_index, best_node)
                  current_load += demands[best_node]
                  unassigned_nodes.remove(best_node)
              else:
                  break
          
          if len(route) > 2: #only append routes with customer nodes
              routes.append(route)

      #Adaptive Improvement Phase
      for i in range(len(routes)):
          if random.random() < 0.5:
            # Apply Insertion Heuristic
            unassigned_nodes = set(routes[i][1:-1])
            routes[i] = [0,0]
            current_load = 0

            while unassigned_nodes:
              best_node = -1
              best_insertion_index = -1
              min_insertion_cost = float('inf')

              for node in unassigned_nodes:
                  if current_load + demands[node] <= capacity:
                      for j in range(1, len(routes[i])):
                          cost = insertion_cost(routes[i], node, j)
                          if cost < min_insertion_cost:
                              min_insertion_cost = cost
                              best_node = node
                              best_insertion_index = j

              if best_node != -1:
                  routes[i].insert(best_insertion_index, best_node)
                  current_load += demands[best_node]
                  unassigned_nodes.remove(best_node)
              else:
                break
          else:
              # Apply 2-opt local search
              routes[i] = perform_two_opt(routes[i])

      # Heuristic Matrix Update
      for route in routes:
          for i in range(len(route) - 1):
              heuristics_matrix[route[i], route[i+1]] += 1
              heuristics_matrix[route[i+1], route[i]] += 1

    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
