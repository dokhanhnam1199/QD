import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm initializes routes randomly, then iteratively improves them using insertion-based local search while updating edge frequencies based on accepted solutions, and adds diversification by occasionally accepting worse solutions based on a temperature parameter.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 50
    num_routes = 5  # Number of initial random routes

    # Initial route construction (Random)
    routes = []
    for _ in range(num_routes):
        unvisited = list(range(1, n))
        random.shuffle(unvisited)
        
        current_route = [0]
        current_load = 0
        
        route = [0] # Initialize a route with starting depot
        while unvisited:
            node = unvisited[0]
            if current_load + demands[node] <= capacity:
              route.append(node)
              current_load += demands[node]
              unvisited.pop(0)
            else:
              route.append(0)
              routes.append(route)
              route = [0]
              current_load = 0
              
        if len(route) > 1:
          route.append(0)
          routes.append(route)

    # Iterative Improvement (Local Search - insertion within routes with simulated annealing)
    temperature = 1.0
    cooling_rate = 0.95
    
    for _ in range(num_iterations):
        for route in routes:
            if len(route) <= 3:
                continue
            
            for i in range(1, len(route) - 1):
                for j in range(1, len(route) - 1):
                    if i == j:
                        continue

                    # Insertion move
                    node_to_move = route[i]
                    new_route = route[:i] + route[i+1:]  # Remove node at i
                    new_route = new_route[:j] + [node_to_move] + new_route[j:] # Insert at j

                    current_cost = 0
                    for k in range(len(route) - 1):
                        current_cost += distance_matrix[route[k], route[k+1]]
                    
                    new_cost = 0
                    for k in range(len(new_route) - 1):
                        new_cost += distance_matrix[new_route[k], new_route[k+1]]

                    cost_diff = new_cost - current_cost
                    
                    if cost_diff < 0:
                        route[:] = new_route  # Update route in place
                    else:
                        # Simulated annealing: accept worse solution with probability
                        probability = np.exp(-cost_diff / temperature)
                        if random.random() < probability:
                            route[:] = new_route
        temperature *= cooling_rate


    # Update heuristics matrix
    for route in routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1
    
    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits
    return heuristics_matrix
