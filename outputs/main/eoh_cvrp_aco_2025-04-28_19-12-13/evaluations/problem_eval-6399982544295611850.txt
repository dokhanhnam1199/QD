import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm combines stochastic sampling with adaptive route construction, biasing edge selection based on a learned value function that balances distance and demand considerations.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    value_matrix = np.ones_like(distance_matrix) # Initialize value matrix

    num_iterations = 500
    learning_rate = 0.1
    discount_factor = 0.9

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    def route_value(route):
        value = 0
        for i in range(len(route) - 1):
            value += value_matrix[route[i], route[i+1]]
        return value

    for iteration in range(num_iterations):
        routes = []
        unassigned_nodes = set(range(1, n))

        while unassigned_nodes:
            current_node = 0
            route = [0]
            current_load = 0
            
            while True:
                eligible_nodes = []
                for j in unassigned_nodes:
                    if current_load + demands[j] <= capacity:
                        eligible_nodes.append(j)
                
                if not eligible_nodes:
                    route.append(0)
                    routes.append(route)
                    break
                
                # Value-based node selection
                probabilities = [value_matrix[current_node, node] for node in eligible_nodes]
                if sum(probabilities) == 0:
                    next_node = random.choice(eligible_nodes)
                else:
                    probabilities = [p / sum(probabilities) for p in probabilities]
                    next_node = random.choices(eligible_nodes, weights=probabilities, k=1)[0]
                
                route.append(next_node)
                current_load += demands[next_node]
                unassigned_nodes.remove(next_node)
                current_node = next_node
        
        #Value Function Update
        total_cost = sum(calculate_route_cost(route) for route in routes)
        
        for route in routes:
            r_value = calculate_route_cost(route)
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                
                #Update Value function with a reward proportional to route value
                reward = (total_cost - r_value) / total_cost if total_cost > 0 else 0 
                value_matrix[node1, node2] += learning_rate * (reward - value_matrix[node1, node2])
                value_matrix[node2, node1] = value_matrix[node1, node2]
                
    # Heuristic Matrix Update based on learned value function
    for i in range(n):
      for j in range(n):
        heuristics_matrix[i, j] = value_matrix[i, j]

    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits
    
    return heuristics_matrix
