import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewards edges in feasible routes based on a combined score of distance, demand, and pheromone-inspired reinforcement, while penalizing infeasible selections.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones((n, n))

    num_samples = 1000
    reward_factor = 1
    penalty_factor = 0.1
    pheromone_influence = 0.5  # Adjust this parameter

    for _ in range(num_samples):
        current_node = 0
        route = [0]
        remaining_nodes = list(range(1, n))
        vehicle_load = 0
        current_route = []

        while remaining_nodes:
            # Select the next node based on a combination of distance, demand and inverse distance
            distances = distance_matrix[current_node, remaining_nodes]
            
            # Create a score based on distance, demand and inverse distance
            scores = []
            for i, node_idx in enumerate(remaining_nodes):
                demand = demands[node_idx]
                distance = distances[i]
                
                if vehicle_load + demand <= capacity:
                    # Calculate inverse_distance
                    inverse_distance = 1/(distance + 1e-6)  # Adding a small constant to avoid division by zero
                    pheromone_level = heuristics_matrix[current_node, node_idx]  # Get the current "pheromone" level
                    score = (distance, inverse_distance, pheromone_level, node_idx) # combined score
                    scores.append(score)
                else:
                    scores.append((float('inf'),0,0, node_idx))

            #Find the possible node based on minimum distance and maximum inverse distance and pheromone
            sorted_scores = sorted(scores, key=lambda x: (x[0], -x[1] - pheromone_influence * x[2]))

            next_node_found = False
            for distance, inverse_distance, pheromone_level, candidate_node in sorted_scores:
                if distance != float('inf'):
                    next_node = candidate_node
                    next_node_found = True
                    break

            if not next_node_found:
                # Return to depot if no feasible node found
                for node in current_route:
                    heuristics_matrix[current_node, 0] -= penalty_factor * distance_matrix[current_node,0]
                    heuristics_matrix[0, current_node] -= penalty_factor * distance_matrix[0, current_node]
                current_node = 0 # restart current_node from depot
                vehicle_load = 0
                current_route = []
                continue

            # Update route information
            route.append(next_node)
            current_route.append(next_node)
            vehicle_load += demands[next_node]

            # Update heuristic matrix (reward proportional to inverse distance and pheromone update)
            heuristics_matrix[current_node, next_node] += reward_factor * inverse_distance
            heuristics_matrix[next_node, current_node] += reward_factor * inverse_distance

            # Remove node from remaining nodes
            remaining_nodes.remove(next_node)
            current_node = next_node

        # Return to depot
        route.append(0)
        heuristics_matrix[current_node, 0] += reward_factor
        heuristics_matrix[0, current_node] += reward_factor

    return heuristics_matrix
