import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm initializes routes randomly, then iteratively improves them using a combination of 2-opt, node insertion, and route splitting, updating edge frequencies based on the improved solutions.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 50
    num_routes = 5

    # Initial random route generation
    routes = []
    for _ in range(num_routes):
        unvisited = list(range(1, n))
        random.shuffle(unvisited)
        
        current_route = [0]
        current_load = 0
        
        for node in unvisited:
            if current_load + demands[node] <= capacity:
                current_route.append(node)
                current_load += demands[node]
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0, node]
                current_load = demands[node]

        current_route.append(0)
        routes.append(current_route)

    # Iterative Improvement
    for _ in range(num_iterations):
        for route in routes:
            if len(route) <= 3:
                continue

            # 2-opt within routes
            for i in range(1, len(route) - 2):
                for k in range(i + 1, len(route) - 1):
                    new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]

                    current_cost = 0
                    for j in range(len(route) - 1):
                        current_cost += distance_matrix[route[j], route[j+1]]

                    new_cost = 0
                    for j in range(len(new_route) - 1):
                        new_cost += distance_matrix[new_route[j], new_route[j+1]]

                    if new_cost < current_cost:
                        route[:] = new_route

            # Node Insertion (relocate node to best position in another route)
            for _ in range(2):
                route1 = random.choice(routes)
                if len(route1) <= 3:
                    continue

                node_to_move_idx = random.randint(1, len(route1) - 2)
                node_to_move = route1[node_to_move_idx]
                
                original_cost = 0
                original_cost += distance_matrix[route1[node_to_move_idx-1],route1[node_to_move_idx]]
                original_cost += distance_matrix[route1[node_to_move_idx],route1[node_to_move_idx+1]]
                original_cost -= distance_matrix[route1[node_to_move_idx-1],route1[node_to_move_idx+1]]
                
                route1.pop(node_to_move_idx)

                best_route = None
                best_insert_idx = -1
                best_cost_reduction = float('-inf')
                
                for route2 in routes:
                    if route1 == route2 : continue
                    
                    for insert_idx in range(1, len(route2)):
                        if route2[insert_idx-1] == 0 and demands[node_to_move] > capacity:
                            continue
                        
                        temp_load = 0
                        for node in route2[1:]:
                            if node == 0: break
                            temp_load += demands[node]

                        if temp_load + demands[node_to_move] <= capacity or route2[insert_idx-1]==0:
                            
                            new_cost = 0
                            new_cost += distance_matrix[route2[insert_idx-1],node_to_move]
                            new_cost += distance_matrix[node_to_move,route2[insert_idx]]
                            new_cost -= distance_matrix[route2[insert_idx-1],route2[insert_idx]]
                                
                            cost_reduction = original_cost-new_cost
                            
                            if cost_reduction > best_cost_reduction:
                                best_cost_reduction = cost_reduction
                                best_route = route2
                                best_insert_idx = insert_idx
                
                if best_route is not None and best_insert_idx != -1:
                    best_route.insert(best_insert_idx, node_to_move)
    # Update heuristics matrix
    for route in routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1

    # Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
        heuristics_matrix = heuristics_matrix / total_visits
    return heuristics_matrix
