import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge importance by iteratively constructing routes using a savings-based approach with stochastic acceptance, favoring edges that yield high savings and respecting capacity constraints, and updates edge importance based on edge selection frequency and savings value with adjusted weighting.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000

    for _ in range(num_samples):
        # Calculate savings for all possible merges
        savings = np.zeros((n, n), dtype=float)
        for i in range(1, n):
            for j in range(i + 1, n):
                savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
                savings[j, i] = savings[i, j]

        # Initialize routes
        routes = {}
        customer_to_route = {}
        route_id = 0
        for i in range(1, n):
            routes[route_id] = [i]
            customer_to_route[i] = route_id
            route_id += 1
            
        # Merge routes based on savings and capacity constraints
        merged = True
        while merged:
            merged = False
            
            # Create a list of candidate merges with their savings
            candidate_merges = []
            for i in range(1, n):
                for j in range(i + 1, n):
                    if customer_to_route[i] != customer_to_route[j]:
                        route1_id = customer_to_route[i]
                        route2_id = customer_to_route[j]

                        route1_demand = sum(demands[c] for c in routes[route1_id])
                        route2_demand = sum(demands[c] for c in routes[route2_id])
                        
                        if route1_demand + route2_demand <= capacity:
                            candidate_merges.append((i, j, savings[i, j]))
                            
            # Stochastic acceptance of the best merge (if any)
            if candidate_merges:
                # Sort merges by savings in descending order
                candidate_merges.sort(key=lambda x: x[2], reverse=True)
                
                # Create probabilities based on savings
                probabilities = []
                total_savings = sum(merge[2] for merge in candidate_merges)
                if total_savings > 0:
                    for merge in candidate_merges:
                        probabilities.append(merge[2] / total_savings)
                else:
                    probabilities = [1/len(candidate_merges)] * len(candidate_merges)
                    
                # Select merge stochastically
                i, j, _ = random.choices(candidate_merges, weights=probabilities, k=1)[0]
                route1_id = customer_to_route[i]
                route2_id = customer_to_route[j]

                # Merge the routes
                routes[route1_id].extend(routes[route2_id])
                for customer in routes[route2_id]:
                    customer_to_route[customer] = route1_id
                del routes[route2_id]
                
                merged = True

        # Update heuristic matrix based on edges in the routes
        final_routes = []
        for route_id in routes:
            final_route = [0] + routes[route_id] + [0]
            final_routes.append(final_route)

        for route in final_routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1

    # Normalize the heuristic matrix
    heuristics_matrix = heuristics_matrix / num_samples

    # Incorporate savings information (higher savings are better)
    savings_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]
    
    heuristics_matrix = heuristics_matrix * (savings_matrix + 1e-6)**0.5

    return heuristics_matrix
