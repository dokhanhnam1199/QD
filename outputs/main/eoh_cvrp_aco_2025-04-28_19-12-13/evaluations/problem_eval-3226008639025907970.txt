import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs multiple solution samples using a hybrid approach combining shortest distance preference with randomized regret insertion and iteratively updates a heuristic matrix based on edge frequency and solution cost.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 500
    regret_k = 3 #k-regret insertion parameter

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    for _ in range(num_samples):
        routes = []
        unassigned_nodes = set(range(1, n))

        while unassigned_nodes:
            # Initialize a new route
            route = [0, 0]
            current_load = 0
            
            # Nearest neighbor to start the route
            nearest_neighbor = -1
            min_dist = float('inf')
            for node in unassigned_nodes:
                if distance_matrix[0, node] < min_dist and current_load + demands[node] <= capacity:
                    min_dist = distance_matrix[0, node]
                    nearest_neighbor = node

            if nearest_neighbor != -1:
                route.insert(-1, nearest_neighbor)
                current_load += demands[nearest_neighbor]
                unassigned_nodes.remove(nearest_neighbor)
            else:
                routes.append(route)
                continue

            while True:
                # Find potential insertion points
                best_insertion = None
                min_insertion_cost = float('inf')
                
                for node_to_insert in list(unassigned_nodes):
                    if current_load + demands[node_to_insert] <= capacity:
                        # Calculate insertion cost for all possible positions
                        for i in range(1, len(route)): # Do not insert before depot
                            insertion_cost = distance_matrix[route[i-1], node_to_insert] + distance_matrix[node_to_insert, route[i]] - distance_matrix[route[i-1], route[i]]

                            if insertion_cost < min_insertion_cost:
                                min_insertion_cost = insertion_cost
                                best_insertion = (node_to_insert, i)
                                
                if best_insertion:
                    node_to_insert, insert_position = best_insertion
                    route.insert(insert_position, node_to_insert)
                    current_load += demands[node_to_insert]
                    unassigned_nodes.remove(node_to_insert)
                else:
                    break  # No valid insertions possible
                    
            routes.append(route)
            
        # Update heuristic matrix
        total_cost = sum(calculate_route_cost(route) for route in routes)
        
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] += 1.0 / (total_cost + 1e-6) #Weighting by solution cost
                heuristics_matrix[node2, node1] += 1.0 / (total_cost + 1e-6)
    
    # Normalize the heuristic matrix
    total_edge_visits = np.sum(heuristics_matrix)
    if total_edge_visits > 0:
        heuristics_matrix = heuristics_matrix / total_edge_visits
        
    return heuristics_matrix
