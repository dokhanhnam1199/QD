import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively refines routes by probabilistically selecting and merging promising route segments based on their cost and capacity feasibility, guided by a pheromone-inspired edge weighting.}
    """
    n = len(demands)
    heuristics_matrix = np.ones_like(distance_matrix, dtype=float) # Initialize pheromone matrix
    num_iterations = 500
    pheromone_decay = 0.9
    pheromone_deposit = 1.0
    alpha = 1.0 # Influence of pheromone
    beta = 2.0  # Influence of distance

    def calculate_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i]][route[i+1]]
        return cost

    def is_feasible(route):
        current_capacity = capacity
        for i in range(1,len(route)-1):
            current_capacity -= demands[route[i]]
        return current_capacity >= 0

    def construct_route(start_node, unvisited):
        route = [start_node]
        current_capacity = capacity
        while unvisited:
            probabilities = []
            for node in unvisited:
                if demands[node] <= current_capacity:
                    pheromone = heuristics_matrix[route[-1]][node] ** alpha
                    distance = (1.0 / distance_matrix[route[-1]][node]) ** beta if distance_matrix[route[-1]][node] > 0 else (1.0)**beta
                    probabilities.append(pheromone * distance)
                else:
                    probabilities.append(0)

            if sum(probabilities) == 0:
                break

            probabilities = np.array(probabilities) / sum(probabilities)
            next_node = random.choices(unvisited, weights=probabilities)[0]
            route.append(next_node)
            current_capacity -= demands[next_node]
            unvisited.remove(next_node)
        route.append(0)
        return route

    for iteration in range(num_iterations):
        # 1. Route Construction
        routes = []
        unvisited_nodes = set(range(1, n))
        while unvisited_nodes:
            start_node = random.choice(list(unvisited_nodes))
            route = construct_route(0, list(unvisited_nodes))
            
            valid_route = True
            temp_capacity = capacity
            for node_idx in range(1,len(route)-1):
                temp_capacity -= demands[route[node_idx]]
                if route[node_idx] in unvisited_nodes:
                    unvisited_nodes.remove(route[node_idx])
            if temp_capacity < 0:
                valid_route = False
            
            if valid_route:
                routes.append(route)
                

        # 2. Pheromone Update
        # Evaporation
        heuristics_matrix *= pheromone_decay

        # Deposit
        for route in routes:
            route_cost = calculate_cost(route)
            if route_cost > 0:
                pheromone_increase = pheromone_deposit / route_cost
            else:
                pheromone_increase = pheromone_deposit
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] += pheromone_increase
                heuristics_matrix[node2, node1] += pheromone_increase
    
    return heuristics_matrix
