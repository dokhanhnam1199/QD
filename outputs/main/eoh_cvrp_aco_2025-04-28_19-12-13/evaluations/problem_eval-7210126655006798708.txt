import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively constructs routes using a hybrid approach combining savings and nearest neighbor criteria, then refines routes by a combination of node re-insertion and 2-opt swaps within routes, while updating a heuristic matrix based on edge usage frequency in improving solutions.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 500

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    def two_opt_swap(route):
        best_route = route[:]
        best_cost = calculate_route_cost(route)
        for i in range(1, len(route) - 2):
            for k in range(i + 1, len(route) - 1):
                new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]
                new_cost = calculate_route_cost(new_route)
                if new_cost < best_cost:
                    best_route = new_route[:]
                    best_cost = new_cost
        return best_route

    routes = []
    unassigned_nodes = set(range(1, n))

    while unassigned_nodes:
        # Hybrid route construction: Savings + Nearest Neighbor
        route = [0]
        current_load = 0
        last_node = 0

        while True:
            feasible_nodes = [node for node in unassigned_nodes if current_load + demands[node] <= capacity]

            if not feasible_nodes:
                break

            # Combine savings and nearest neighbor
            savings_values = {node: distance_matrix[0, last_node] + distance_matrix[0, node] - distance_matrix[last_node, node] for node in feasible_nodes}
            nearest_neighbors = sorted(feasible_nodes, key=lambda node: distance_matrix[last_node, node])

            candidates = []
            if len(savings_values) > 0:
                max_saving = max(savings_values.values())
                candidates.extend([node for node, saving in savings_values.items() if saving == max_saving])

            candidates.extend(nearest_neighbors[:2]) #add up to 2 nearest neighbours
            
            if len(candidates) > 0:
                 selected_node = random.choice(candidates)
            else:
                 break
           
            route.append(selected_node)
            current_load += demands[selected_node]
            unassigned_nodes.remove(selected_node)
            last_node = selected_node
            

        route.append(0)
        routes.append(route)

    # Iterative Improvement: Re-insertion and 2-Opt
    best_routes = [route[:] for route in routes]
    best_cost = sum(calculate_route_cost(route) for route in routes)

    for _ in range(num_iterations):
        # 1. Node Re-insertion
        route_to_remove_from = random.randint(0, len(routes) - 1)
        if len(routes[route_to_remove_from]) <= 3:
            continue
        node_to_reinsert_index = random.randint(1, len(routes[route_to_remove_from]) - 2)
        node_to_reinsert = routes[route_to_remove_from][node_to_reinsert_index]
        original_load = calculate_route_load(routes[route_to_remove_from])
        routes[route_to_remove_from].pop(node_to_reinsert_index)

        best_insertion_route = -1
        best_insertion_index = -1
        best_insertion_cost = float('inf')

        for i in range(len(routes)):
            for j in range(1, len(routes[i])):
                temp_route = routes[i][:]
                temp_route.insert(j, node_to_reinsert)

                if calculate_route_load(temp_route) <= capacity:
                    new_cost = calculate_route_cost(temp_route)
                    if new_cost < best_insertion_cost:
                        best_insertion_cost = new_cost
                        best_insertion_route = i
                        best_insertion_index = j

        if best_insertion_route != -1:
            routes[best_insertion_route].insert(best_insertion_index, node_to_reinsert)

        # 2. 2-Opt within routes
        for i in range(len(routes)):
            routes[i] = two_opt_swap(routes[i])

        # Check overall solution cost
        current_cost = sum(calculate_route_cost(route) for route in routes)
        if current_cost < best_cost:
            best_cost = current_cost
            best_routes = [route[:] for route in routes]

    # Heuristic Matrix Update
    for route in best_routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1

    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits
    return heuristics_matrix
