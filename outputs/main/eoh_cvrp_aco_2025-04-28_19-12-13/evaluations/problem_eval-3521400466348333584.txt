import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs solutions by iteratively applying a cluster-first, route-second approach, using k-means clustering to group nodes based on location and demand, then solving the TSP within each cluster using a nearest neighbor heuristic to generate routes, and updating edge frequencies.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_clusters = int(np.ceil(np.sum(demands) / capacity)) # Estimating required clusters
    
    # K-Means Clustering
    def kmeans_clustering(coordinates, demands, num_clusters, capacity):
      """Performs k-means clustering with capacity constraints."""
      
      centroids = random.sample(range(1, len(coordinates)), num_clusters)
      clusters = [[] for _ in range(num_clusters)]

      for _ in range(100): #iterations
        clusters = [[] for _ in range(num_clusters)]
        cluster_assignments = [-1] * len(coordinates)
        
        for i in range(1, len(coordinates)):
          best_cluster = -1
          min_distance = float('inf')
          
          for j in range(num_clusters):
              distance = np.linalg.norm(coordinates[i] - coordinates[centroids[j]])
              if distance < min_distance:
                  min_distance = distance
                  best_cluster = j
          
          cluster_assignments[i] = best_cluster

        #Capacity adjustment
        cluster_loads = [sum(demands[i] for i in range(1, len(coordinates)) if cluster_assignments[i] == j) for j in range(num_clusters)]

        for i in range(1, len(coordinates)):
          for j in range(num_clusters):
            if cluster_assignments[i] == j and cluster_loads[j] > capacity:
              min_dist = float('inf')
              closest_cluster = -1

              for k in range(num_clusters):
                if k != j:
                  dist = np.linalg.norm(coordinates[i] - coordinates[centroids[k]])
                  if dist < min_dist and cluster_loads[k] + demands[i] <= capacity:
                    min_dist = dist
                    closest_cluster = k
              
              if closest_cluster != -1:
                cluster_assignments[i] = closest_cluster
                cluster_loads[j] -= demands[i]
                cluster_loads[closest_cluster] += demands[i]
        
        #Recalculate Cluster
        clusters = [[] for _ in range(num_clusters)]
        for i in range(1, len(coordinates)):
            cluster_index = cluster_assignments[i]
            clusters[cluster_index].append(i)
          
        new_centroids = []
        for cluster_index in range(num_clusters):
            cluster_points = [coordinates[i] for i in clusters[cluster_index]]
            if cluster_points:
                new_centroids.append(np.mean(cluster_points, axis=0))
            else:
              new_centroids.append(coordinates[random.choice(range(1,len(coordinates)))] if len(coordinates)>1 else coordinates[0]) #Avoid Empty clusters by assigning new centroids
        
        # Convert centroids to node indices
        centroid_indices = []
        for centroid in new_centroids:
            min_dist = float('inf')
            closest_node = -1
            for i in range(1, len(coordinates)):
                dist = np.linalg.norm(centroid - coordinates[i])
                if dist < min_dist:
                    min_dist = dist
                    closest_node = i
            centroid_indices.append(closest_node)

        centroids = centroid_indices

      return clusters

    clusters = kmeans_clustering(coordinates, demands, num_clusters, capacity)

    # Route Construction (Nearest Neighbor)
    def nearest_neighbor_tsp(distance_matrix, cluster_nodes):
        """Solves the TSP for a given cluster using nearest neighbor."""
        if not cluster_nodes:
            return [0, 0]

        start_node = 0  # Depot
        route = [start_node]
        unvisited_nodes = set(cluster_nodes)

        current_node = start_node
        while unvisited_nodes:
            nearest_node = -1
            min_distance = float('inf')
            
            for neighbor in unvisited_nodes:
                distance = distance_matrix[current_node, neighbor]
                if distance < min_distance:
                    min_distance = distance
                    nearest_node = neighbor

            if nearest_node != -1:
                route.append(nearest_node)
                unvisited_nodes.remove(nearest_node)
                current_node = nearest_node
            else:
                break
        route.append(start_node) #return to depot
        return route

    routes = []
    for cluster in clusters:
      route = nearest_neighbor_tsp(distance_matrix, cluster)
      routes.append(route)

    # Heuristic Matrix Update
    for route in routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1
    
    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
