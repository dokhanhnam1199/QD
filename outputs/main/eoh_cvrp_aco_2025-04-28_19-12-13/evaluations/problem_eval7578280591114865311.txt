import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm emphasizes diversification by reducing pheromone influence, decreasing evaporation, and exploring different route construction strategies with adaptive savings weights.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 500
    pheromone_matrix = np.ones_like(distance_matrix) * 0.01  # Initialize pheromone matrix
    alpha = 0.4  # Weight for savings
    beta = 0.1   # Weight for pheromone
    evaporation_rate = 0.9 # Decreased evaporation rate
    adaptive_savings_weight = 0.5

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    def two_opt_swap(route):
        best_route = route[:]
        best_cost = calculate_route_cost(route)
        for i in range(1, len(route) - 2):
            for k in range(i + 1, len(route) - 1):
                new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]
                new_cost = calculate_route_cost(new_route)
                if new_cost < best_cost:
                    best_route = new_route[:]
                    best_cost = new_cost
        return best_route

    def savings_heuristic(i, j):
        return distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]

    best_routes = None
    best_cost = float('inf')

    for iteration in range(num_iterations):
        routes = []
        unassigned_nodes = set(range(1, n))
        
        if iteration % 2 == 0:
            # Route Construction Strategy 1: Randomized Savings-Based
            while unassigned_nodes:
                i = random.choice(list(unassigned_nodes))
                route = [0, i, 0]
                current_load = demands[i]
                unassigned_nodes.remove(i)

                while True:
                    eligible_nodes = []
                    for j in unassigned_nodes:
                        if current_load + demands[j] <= capacity:
                            eligible_nodes.append(j)

                    if not eligible_nodes:
                        break

                    # Use pheromone and savings to select the next node
                    probabilities = []
                    for node in eligible_nodes:
                        savings = savings_heuristic(route[-2], node)
                        pheromone = pheromone_matrix[route[-2], node]
                        probabilities.append((savings**alpha) * (pheromone**beta))
                    
                    if sum(probabilities) == 0:
                        next_node = random.choice(eligible_nodes)
                    else:
                        probabilities = [p / sum(probabilities) for p in probabilities]
                        next_node = random.choices(eligible_nodes, weights=probabilities, k=1)[0]

                    route.insert(-1, next_node)
                    current_load += demands[next_node]
                    unassigned_nodes.remove(next_node)

            routes.append(route)
        else:
            # Route Construction Strategy 2: Prioritize closest node
             while unassigned_nodes:
                i = random.choice(list(unassigned_nodes))
                route = [0, i, 0]
                current_load = demands[i]
                unassigned_nodes.remove(i)

                while True:
                    eligible_nodes = []
                    for j in unassigned_nodes:
                        if current_load + demands[j] <= capacity:
                            eligible_nodes.append(j)

                    if not eligible_nodes:
                        break
                    
                    # Prioritize closest node
                    distances = [distance_matrix[route[-2], node] for node in eligible_nodes]
                    next_node = eligible_nodes[np.argmin(distances)]

                    route.insert(-1, next_node)
                    current_load += demands[next_node]
                    unassigned_nodes.remove(next_node)
                    
            routes.append(route)

        # Route Improvement with 2-Opt
        for i in range(len(routes)):
            routes[i] = two_opt_swap(routes[i])

        # Evaluate Solution
        current_cost = sum(calculate_route_cost(route) for route in routes)

        # Update Best Solution
        if current_cost < best_cost:
            best_cost = current_cost
            best_routes = [route[:] for route in routes]

            # Pheromone Update (Based on best solution)
            delta_pheromone = 1.0 / current_cost
            for route in routes:
                for i in range(len(route) - 1):
                    pheromone_matrix[route[i], route[i+1]] += delta_pheromone
                    pheromone_matrix[route[i+1], route[i]] += delta_pheromone

        # Evaporation
        pheromone_matrix *= evaporation_rate

    # Heuristic Matrix Update based on best solution
    for route in best_routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1
            
    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
