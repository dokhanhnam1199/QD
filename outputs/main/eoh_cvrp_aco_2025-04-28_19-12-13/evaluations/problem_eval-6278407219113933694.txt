import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge probabilities by iteratively constructing routes based on a combination of distance and demand considerations, rewarding edges used in feasible routes and penalizing those leading to capacity violations, while also incorporating a diversification strategy to explore different route configurations.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones((n, n))

    num_samples = 1000
    penalty_factor = 10
    reward_factor = 2

    for _ in range(num_samples):
        current_node = 0
        route = [0]
        remaining_nodes = list(range(1, n))
        vehicle_load = 0
        current_route = []

        while remaining_nodes:
            # Select the next node based on a combined metric of distance and demand
            # Add a small random factor for diversification
            scores = np.zeros(len(remaining_nodes))
            for i, node in enumerate(remaining_nodes):
              scores[i] = distance_matrix[current_node, node] + (demands[node] / capacity) + np.random.rand() * 0.1

            sorted_indices = np.argsort(scores)
            
            next_node_found = False
            for idx in sorted_indices:
              candidate_node = remaining_nodes[idx]
              if vehicle_load + demands[candidate_node] <= capacity:
                next_node = candidate_node
                next_node_found = True
                break

            if not next_node_found:
              # Return to depot if no feasible node found
              for node in current_route:
                heuristics_matrix[current_node, 0] -= penalty_factor
                heuristics_matrix[0, current_node] -= penalty_factor
                current_node = 0
              vehicle_load = 0
              current_route = []
              continue

            # Update route information
            route.append(next_node)
            current_route.append(next_node)
            vehicle_load += demands[next_node]

            # Update heuristic matrix - reward feasible edges
            heuristics_matrix[current_node, next_node] += reward_factor
            heuristics_matrix[next_node, current_node] += reward_factor

            # Remove node from remaining nodes
            remaining_nodes.remove(next_node)
            current_node = next_node

        # Return to depot
        route.append(0)
        heuristics_matrix[current_node, 0] += reward_factor
        heuristics_matrix[0, current_node] += reward_factor

    return heuristics_matrix
