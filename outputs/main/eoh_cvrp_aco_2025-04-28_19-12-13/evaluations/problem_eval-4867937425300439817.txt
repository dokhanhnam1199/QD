import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs multiple solutions using an ant colony optimization (ACO) approach, where ants probabilistically build routes based on pheromone trails and heuristic information (distance), and the pheromone trails are updated based on the quality of the routes found.}
    """
    n = len(demands)
    heuristics_matrix = np.ones_like(distance_matrix)  # Initialize pheromone trails
    pheromone_decay = 0.1
    alpha = 1  # Pheromone influence
    beta = 2  # Heuristic influence (distance)
    num_ants = n
    num_iterations = 50

    for iteration in range(num_iterations):
        all_routes = []
        for ant in range(num_ants):
            unvisited = set(range(1, n))
            current_node = 0
            route = [0]
            current_load = 0
            
            while unvisited:
                probabilities = []
                for node in unvisited:
                    if current_load + demands[node] <= capacity:
                        pheromone = heuristics_matrix[current_node, node] ** alpha
                        heuristic = (1 / distance_matrix[current_node, node]) ** beta
                        probabilities.append((node, pheromone * heuristic))
                    else:
                        probabilities.append((node, 0))
                
                total_prob = sum(prob for node, prob in probabilities)
                if total_prob == 0:
                    route.append(0)
                    current_node = 0
                    current_load = 0
                    continue

                probabilities = [(node, prob / total_prob) for node, prob in probabilities]
                
                
                nodes = [node for node, prob in probabilities]
                probs = [prob for node, prob in probabilities]
                
                next_node = random.choices(nodes, probs)[0]

                route.append(next_node)
                current_load += demands[next_node]
                unvisited.remove(next_node)
                current_node = next_node
            route.append(0)
            all_routes.append(route)

        # Update pheromone trails
        for i in range(n):
            for j in range(n):
                heuristics_matrix[i, j] *= (1 - pheromone_decay)  # Decay pheromones

        for route in all_routes:
            route_distance = 0
            for i in range(len(route) - 1):
                route_distance += distance_matrix[route[i], route[i+1]]
            
            if route_distance > 0: #to prevent division by zero
                pheromone_deposit = 1 / route_distance
            else:
                pheromone_deposit = 0
            
            for i in range(len(route) - 1):
                heuristics_matrix[route[i], route[i+1]] += pheromone_deposit
                heuristics_matrix[route[i+1], route[i]] += pheromone_deposit

    return heuristics_matrix
