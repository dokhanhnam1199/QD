import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm employs a cluster-first, route-second approach, using k-means clustering to group nodes based on location and demand, followed by a greedy route construction within each cluster to generate initial solutions.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_clusters = int(np.sqrt(n)) # Heuristic to determine the number of clusters
    num_iterations = 300

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost
    
    def k_means_clustering(coordinates, demands, num_clusters, capacity):
        # Initialize centroids randomly
        centroids_idx = random.sample(range(1, n), num_clusters)
        centroids = [coordinates[i] for i in centroids_idx]
        
        clusters = [[] for _ in range(num_clusters)]
        
        # Assign each node to the nearest centroid
        for i in range(1, n):
            min_dist = float('inf')
            closest_cluster = -1
            for j in range(num_clusters):
                dist = np.linalg.norm(coordinates[i] - centroids[j])
                if dist < min_dist:
                    min_dist = dist
                    closest_cluster = j
            clusters[closest_cluster].append(i)
            
        # Check capacity constraint
        valid_clusters = []
        for cluster in clusters:
            total_demand = sum(demands[node] for node in cluster)
            if total_demand <= capacity * 2: # Allow some slack in capacity.
                valid_clusters.append(cluster)
        return valid_clusters

    def greedy_route_construction(cluster, distance_matrix, demands, capacity):
        routes = []
        unvisited = set(cluster)
        while unvisited:
            route = [0]
            current_load = 0
            current_node = 0  # Start from the depot

            while True:
                nearest_node = None
                min_dist = float('inf')
                for node in unvisited:
                    if current_load + demands[node] <= capacity:
                        dist = distance_matrix[current_node, node]
                        if dist < min_dist:
                            min_dist = dist
                            nearest_node = node

                if nearest_node is None:
                    route.append(0)
                    routes.append(route)
                    break  # Route is complete, start a new one

                route.append(nearest_node)
                current_load += demands[nearest_node]
                current_node = nearest_node
                unvisited.remove(nearest_node)

        return routes

    best_routes = None
    best_cost = float('inf')

    for iteration in range(num_iterations):
        clusters = k_means_clustering(coordinates, demands, num_clusters, capacity)
        
        routes = []
        for cluster in clusters:
            routes.extend(greedy_route_construction(cluster, distance_matrix, demands, capacity))
            
        current_cost = sum(calculate_route_cost(route) for route in routes)
        
        if current_cost < best_cost:
            best_cost = current_cost
            best_routes = [route[:] for route in routes]
            
    # Heuristic Matrix Update based on best solution
    for route in best_routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1

    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
