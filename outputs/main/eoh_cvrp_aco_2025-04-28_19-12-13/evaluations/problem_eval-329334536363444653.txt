import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm employs a genetic algorithm to evolve a population of CVRP solutions, using selection, crossover, and mutation to explore the solution space and construct a heuristic matrix based on the frequency of edges in the best solutions.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    population_size = 50
    num_generations = 200
    mutation_rate = 0.05

    def create_individual():
        remaining_nodes = list(range(1, n))
        random.shuffle(remaining_nodes)
        
        routes = []
        current_route = [0]
        current_capacity = capacity
        
        for node in remaining_nodes:
            if demands[node] <= current_capacity:
                current_route.append(node)
                current_capacity -= demands[node]
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0, node]
                current_capacity = capacity - demands[node]
        
        current_route.append(0)
        routes.append(current_route)
        return routes

    def calculate_cost(routes):
        cost = 0
        for route in routes:
            for i in range(len(route) - 1):
                cost += distance_matrix[route[i]][route[i+1]]
        return cost

    def crossover(parent1, parent2):
        # Simple single-point crossover
        route_index = random.randint(0, min(len(parent1), len(parent2)) - 1)
        child1 = parent1[:route_index] + parent2[route_index:]
        child2 = parent2[:route_index] + parent1[route_index:]
        return child1, child2
    
    def mutate(individual):
        if random.random() < mutation_rate:
            route_idx = random.randint(0, len(individual) - 1)
            if len(individual[route_idx]) > 3:
                idx1 = random.randint(1, len(individual[route_idx]) - 2)
                idx2 = random.randint(1, len(individual[route_idx]) - 2)
                individual[route_idx][idx1], individual[route_idx][idx2] = individual[route_idx][idx2], individual[route_idx][idx1]
        return individual

    # Initialize population
    population = [create_individual() for _ in range(population_size)]

    # Genetic algorithm loop
    for _ in range(num_generations):
        # Evaluate fitness
        fitness_scores = [calculate_cost(individual) for individual in population]

        # Selection (Roulette wheel selection)
        total_fitness = sum(fitness_scores)
        selection_probabilities = [(total_fitness - fitness) / (total_fitness * (population_size -1)) for fitness in fitness_scores] # Smaller cost is better
        
        if sum(selection_probabilities) == 0:
            selection_probabilities = [1/population_size] * population_size
        
        selected_indices = random.choices(range(population_size), weights=selection_probabilities, k=population_size)
        selected_population = [population[i] for i in selected_indices]

        # Crossover
        new_population = []
        for i in range(0, population_size, 2):
            if i + 1 < population_size:
                parent1 = selected_population[i]
                parent2 = selected_population[i + 1]
                child1, child2 = crossover(parent1, parent2)
                new_population.append(child1)
                new_population.append(child2)
            else:
                 new_population.append(selected_population[i])

        # Mutation
        mutated_population = [mutate(individual) for individual in new_population]

        # Update population
        population = mutated_population

    # Build heuristic matrix from the best solution
    best_individual = min(population, key=calculate_cost)
    for route in best_individual:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
