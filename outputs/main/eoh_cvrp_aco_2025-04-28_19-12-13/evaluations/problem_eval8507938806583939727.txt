import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively constructs solutions by probabilistically selecting and combining routes generated from both greedy insertion and savings-based approaches, reinforcing edges present in better solutions.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 100

    for _ in range(num_iterations):
        # Generate initial solutions using both methods
        routes_greedy = []
        unvisited = set(range(1, n))
        while unvisited:
            current_route = [0]
            current_load = 0
            
            while unvisited:
                best_customer = None
                best_insertion_cost = float('inf')

                for customer in unvisited:
                    if current_load + demands[customer] <= capacity:
                        insertion_cost = distance_matrix[current_route[-1]][customer] + distance_matrix[customer][0] - distance_matrix[current_route[-1]][0]
                        if insertion_cost < best_insertion_cost:
                            best_insertion_cost = insertion_cost
                            best_customer = customer

                if best_customer is None:
                    break
                current_route.append(best_customer)
                current_load += demands[best_customer]
                unvisited.remove(best_customer)
            
            current_route.append(0)
            routes_greedy.append(current_route)

        routes_savings = []
        unvisited = set(range(1, n))
        savings = np.zeros((n, n), dtype=float)
        for i in range(1, n):
            for j in range(i + 1, n):
                savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
                savings[j, i] = savings[i, j]
        while unvisited:
            best_saving = -1
            best_i = -1
            best_j = -1
            for i in unvisited:
                for j in unvisited:
                    if i != j and savings[i, j] > best_saving:
                        best_saving = savings[i, j]
                        best_i = i
                        best_j = j

            if best_i == -1:
                node = unvisited.pop()
                routes_savings.append([0, node, 0])
                continue
            
            route = [0, best_i, best_j, 0]
            current_load = demands[best_i] + demands[best_j]
            unvisited.remove(best_i)
            unvisited.remove(best_j)

            while True:
                best_add_node = -1
                best_add_saving = -1

                for node in unvisited:
                    if current_load + demands[node] <= capacity:

                        saving_i = savings[best_i, node]
                        saving_j = savings[best_j, node]
                        
                        if saving_i >= saving_j and saving_i > best_add_saving :
                            best_add_node = node
                            best_add_saving = saving_i
                        
                        elif saving_j > saving_i and saving_j > best_add_saving:
                            best_add_node = node
                            best_add_saving = saving_j


                if best_add_node != -1:
                    route.insert(len(route)-1,best_add_node)
                    current_load += demands[best_add_node]
                    unvisited.remove(best_add_node)
                    
                    best_j = route[-2] #update best_j
                    best_i = route[1]
                    

                else:
                    routes_savings.append(route)
                    break
        
        # Calculate the total distance for both routes
        def calculate_total_distance(routes, distance_matrix):
            total_distance = 0
            for route in routes:
                for i in range(len(route) - 1):
                    total_distance += distance_matrix[route[i], route[i+1]]
            return total_distance
        
        total_distance_greedy = calculate_total_distance(routes_greedy, distance_matrix)
        total_distance_savings = calculate_total_distance(routes_savings, distance_matrix)

        # Probabilistic route selection based on distance (lower distance = higher probability)
        if total_distance_greedy < total_distance_savings:
            selected_routes = routes_greedy
        else:
            selected_routes = routes_savings

        # Update heuristics matrix based on selected route
        for route in selected_routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1

    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
