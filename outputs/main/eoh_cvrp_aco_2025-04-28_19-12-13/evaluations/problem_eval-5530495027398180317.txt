import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively builds routes using a regret-2 insertion heuristic, balancing distance and capacity, and refines solutions by swapping nodes between routes, updating edge frequencies based on solution quality.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 200

    def calculate_route_load(route):
        load = 0
        for node in route:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    def regret_insertion(node, route, distance_matrix, demands, capacity):
        """Calculates the regret-2 insertion cost for a node in a route."""
        best_cost = float('inf')
        second_best_cost = float('inf')
        best_index = -1

        for i in range(1, len(route)):
            temp_route = route[:]
            temp_route.insert(i, node)
            if calculate_route_load(temp_route) <= capacity:
                cost = distance_matrix[route[i-1], node] + distance_matrix[node, route[i]] - distance_matrix[route[i-1], route[i]]
                if cost < best_cost:
                    second_best_cost = best_cost
                    best_cost = cost
                    best_index = i
                elif cost < second_best_cost:
                    second_best_cost = cost

        if best_index == -1:
            return float('inf'), -1, 0 #impossible to insert
        regret = second_best_cost - best_cost
        return best_cost, best_index, regret
        
    def swap_nodes(routes):
        """Tries to improve solution by swapping nodes between routes."""
        best_routes = [route[:] for route in routes]
        best_cost = sum(calculate_route_cost(route) for route in routes)

        for i in range(len(routes)):
            for j in range(1, len(routes[i]) - 1):
                for k in range(i, len(routes)):
                    for l in range(1, len(routes[k]) - 1):
                        if i == k and j == l:
                            continue

                        # Copy routes
                        new_routes = [route[:] for route in routes]
                        node1 = new_routes[i][j]
                        node2 = new_routes[k][l]

                        # Swap nodes
                        new_routes[i][j] = node2
                        new_routes[k][l] = node1

                        # Check capacity constraints
                        if calculate_route_load(new_routes[i]) <= capacity and calculate_route_load(new_routes[k]) <= capacity:
                            new_cost = sum(calculate_route_cost(route) for route in new_routes)
                            if new_cost < best_cost:
                                best_cost = new_cost
                                best_routes = [route[:] for route in new_routes]

        return best_routes

    # Iterative Route Construction and Improvement
    best_routes = []
    best_cost = float('inf')

    for _ in range(num_iterations):
        routes = []
        unassigned_nodes = set(range(1, n))

        # Route construction with regret-2 insertion
        while unassigned_nodes:
            seed_node = random.choice(list(unassigned_nodes))
            route = [0, seed_node, 0]
            unassigned_nodes.remove(seed_node)

            while True:
                best_node = -1
                best_route_index = -1
                best_insertion_index = -1
                max_regret = -float('inf')

                for node in unassigned_nodes:
                    best_cost, insert_index, regret = regret_insertion(node, route, distance_matrix, demands, capacity)
                    if insert_index != -1 and regret > max_regret:
                        max_regret = regret
                        best_node = node
                        best_route_index = routes.index(route) if route in routes else -1  # Should always be -1 here.
                        best_insertion_index = insert_index

                if best_node != -1:
                    route.insert(best_insertion_index, best_node)
                    unassigned_nodes.remove(best_node)
                else:
                    break
            routes.append(route)

        # Route Improvement via node swapping
        routes = swap_nodes(routes)

        # Update best solution
        current_cost = sum(calculate_route_cost(route) for route in routes)
        if current_cost < best_cost:
            best_cost = current_cost
            best_routes = [route[:] for route in routes]

    # Heuristic Matrix Update
    for route in best_routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1
            
    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
