import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs solutions by iteratively inserting unrouted nodes into existing partial routes based on a cost-benefit analysis considering distance, remaining capacity, and node proximity, then applies a simplified local search procedure and updates edge frequencies.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 200
    initial_temperature = 50
    cooling_rate = 0.95
    proximity_weight = 0.1

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost
    
    def calculate_total_cost(routes):
      total_cost = 0
      for route in routes:
        total_cost += calculate_route_cost(route)
      return total_cost

    def insertion_cost(route, node, index):
        """Calculates the cost of inserting a node into a route at a specific index, incorporating proximity."""
        cost = distance_matrix[route[index-1], node] + distance_matrix[node, route[index]] - distance_matrix[route[index-1], route[index]]
        
        #Proximity bonus (nodes closer to the center of the route are preferred)
        center_node = route[len(route)//2] if len(route) > 2 else 0
        proximity = distance_matrix[node, center_node]
        cost -= proximity_weight * proximity

        return cost

    routes = []
    unassigned_nodes = set(range(1, n))

    # Initial Solution Construction: Greedy Insertion with Capacity Check
    while unassigned_nodes:
        route = [0, 0]
        current_load = 0
        
        while True:
            best_node = -1
            best_insertion_index = -1
            min_insertion_cost = float('inf')
            
            for node in unassigned_nodes:
                if current_load + demands[node] <= capacity:
                    for i in range(1, len(route)):
                        cost = insertion_cost(route, node, i)
                        if cost < min_insertion_cost:
                            min_insertion_cost = cost
                            best_node = node
                            best_insertion_index = i

            if best_node != -1:
                route.insert(best_insertion_index, best_node)
                current_load += demands[best_node]
                unassigned_nodes.remove(best_node)
            else:
                break
        
        if len(route) > 2: #only append routes with customer nodes
            routes.append(route)

    # Simplified Local Search (swap within route)
    best_routes = [route[:] for route in routes]
    best_cost = calculate_total_cost(routes)
    current_temperature = initial_temperature

    for _ in range(num_iterations):
        # Choose a random route
        route_index = random.randint(0, len(routes) - 1)
        if len(routes[route_index]) <= 3:
            continue

        # Choose two random nodes to swap
        i, j = random.sample(range(1, len(routes[route_index]) - 1), 2)
        
        #Swap nodes
        routes[route_index][i], routes[route_index][j] = routes[route_index][j], routes[route_index][i]
        
        current_cost = calculate_total_cost(routes)
        delta_cost = current_cost - best_cost

        if delta_cost < 0 or random.random() < np.exp(-delta_cost / current_temperature):
          if current_cost < best_cost:
            best_cost = current_cost
            best_routes = [route[:] for route in routes]
        else:
            routes[route_index][i], routes[route_index][j] = routes[route_index][j], routes[route_index][i] #revert swap

        current_temperature *= cooling_rate

    # Heuristic Matrix Update
    for route in best_routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1
    
    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
