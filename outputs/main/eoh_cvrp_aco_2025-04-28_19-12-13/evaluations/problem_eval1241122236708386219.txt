import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs solutions using a modified cost-benefit analysis that prioritizes capacity utilization and applies a more aggressive simulated annealing with dynamic temperature adjustment to diversify the search and updates edge frequencies.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 400
    initial_temperature = 150
    cooling_rate = 0.995
    capacity_penalty_factor = 0.5

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost
    
    def calculate_total_cost(routes):
      total_cost = 0
      for route in routes:
        total_cost += calculate_route_cost(route)
      return total_cost

    def insertion_cost(route, node, index):
        """Calculates the cost of inserting a node into a route at a specific index, with a capacity penalty."""
        cost = distance_matrix[route[index-1], node] + distance_matrix[node, route[index]] - distance_matrix[route[index-1], route[index]]
        remaining_capacity = capacity - calculate_route_load(route)
        # Encourage filling up capacity
        capacity_utilization = 1 - (remaining_capacity - demands[node]) / capacity if remaining_capacity - demands[node] >= 0 else 100
        cost += capacity_penalty_factor * (1 - capacity_utilization)
        return cost

    routes = []
    unassigned_nodes = set(range(1, n))

    # Initial Solution Construction: Greedy Insertion with Capacity Check
    while unassigned_nodes:
        route = [0, 0]
        current_load = 0
        
        while True:
            best_node = -1
            best_insertion_index = -1
            min_insertion_cost = float('inf')
            
            for node in unassigned_nodes:
                if current_load + demands[node] <= capacity:
                    for i in range(1, len(route)):
                        cost = insertion_cost(route, node, i)
                        if cost < min_insertion_cost:
                            min_insertion_cost = cost
                            best_node = node
                            best_insertion_index = i

            if best_node != -1:
                route.insert(best_insertion_index, best_node)
                current_load += demands[best_node]
                unassigned_nodes.remove(best_node)
            else:
                break
        
        if len(route) > 2: #only append routes with customer nodes
            routes.append(route)

    # Simulated Annealing
    best_routes = [route[:] for route in routes]
    best_cost = calculate_total_cost(routes)
    current_temperature = initial_temperature

    for iteration in range(num_iterations):
        # Choose a random route and a random node within that route
        route_index = random.randint(0, len(routes) - 1)
        if len(routes[route_index]) <= 3:
            continue
        node_index = random.randint(1, len(routes[route_index]) - 2)
        node_to_move = routes[route_index][node_index]
        
        #Remove node from the route
        original_load = calculate_route_load(routes[route_index])
        routes[route_index].pop(node_index)

        # Find best insertion point in other routes or the same route
        best_new_route_index = -1
        best_new_index = -1
        best_insertion_cost = float('inf')
        
        for i in range(len(routes)):
            for j in range(1, len(routes[i])):
                temp_route = routes[i][:]
                temp_route.insert(j, node_to_move)
                
                if calculate_route_load(temp_route) <= capacity:
                    new_cost = calculate_route_cost(temp_route)
                    original_cost = calculate_route_cost(routes[i])
                    delta_cost = new_cost - original_cost
                    
                    if delta_cost < best_insertion_cost:
                        best_insertion_cost = delta_cost
                        best_new_route_index = i
                        best_new_index = j
                        
        #Accept or reject move based on simulated annealing criteria
        if best_new_route_index != -1:
            delta_cost = best_insertion_cost
            if delta_cost < 0 or random.random() < np.exp(-delta_cost / current_temperature):
              # Move the node
              if best_new_route_index == route_index:
                  routes[best_new_route_index].insert(best_new_index, node_to_move)
              else:
                routes[best_new_route_index].insert(best_new_index, node_to_move)
                if len(routes[route_index]) <= 2:
                   routes.pop(route_index)
                   if route_index < best_new_route_index:
                     best_new_route_index -=1 #adjust index if route removed before the insertion route
                
              # Check if this is the best solution so far
              current_cost = calculate_total_cost(routes)
              if current_cost < best_cost:
                best_cost = current_cost
                best_routes = [route[:] for route in routes]
            else:
                routes[route_index].insert(node_index, node_to_move) #reinsert if move rejected
        else:
            routes[route_index].insert(node_index, node_to_move) #reinsert if no feasible solution found
        
        #Dynamic temperature adjustment
        if iteration % 50 == 0:
            if calculate_total_cost(routes) > best_cost:
                current_temperature *= 1.1 #Increase temperature to escape local optima
            else:
                current_temperature *= cooling_rate
        else:
             current_temperature *= cooling_rate


    # Heuristic Matrix Update
    for route in best_routes:
        for i in range(len(route) - 1):
            heuristics_matrix[route[i], route[i+1]] += 1
            heuristics_matrix[route[i+1], route[i]] += 1
    
    #Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
