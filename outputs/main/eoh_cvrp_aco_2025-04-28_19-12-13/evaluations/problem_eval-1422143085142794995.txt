import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm combines the iterative route construction of Algorithm 1 with the edge probability estimation of Algorithm 2 by building multiple routes, probabilistically selecting nodes for insertion based on distance and demand while updating edge frequencies proportional to route feasibility and length.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_routes = 500

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    for _ in range(num_routes):
        route = [0, 0]
        current_load = 0
        unassigned_nodes = set(range(1, n))
        
        while unassigned_nodes:
            possible_nodes = []
            for node in unassigned_nodes:
                if current_load + demands[node] <= capacity:
                    possible_nodes.append(node)
            
            if not possible_nodes:
                break

            # Probabilistic node selection based on distance
            probabilities = []
            total_distance = 0
            for node in possible_nodes:
                min_dist_to_route = float('inf')
                for i in range(len(route) - 1):
                    dist = min(distance_matrix[route[i], node], distance_matrix[node, route[i+1]])
                    min_dist_to_route = min(min_dist_to_route, dist)
                
                probabilities.append(1/(min_dist_to_route + 1e-6)) #Inverse distance
                total_distance += 1/(min_dist_to_route + 1e-6)
            
            probabilities = [p/total_distance for p in probabilities]

            # Select a node based on the probabilities
            selected_node = random.choices(possible_nodes, probabilities)[0]

            # Find the best insertion index for the selected node
            best_insertion_index = -1
            min_insertion_cost = float('inf')
            for i in range(1, len(route)):
                cost = distance_matrix[route[i-1], selected_node] + distance_matrix[selected_node, route[i]] - distance_matrix[route[i-1], route[i]]
                if cost < min_insertion_cost:
                    min_insertion_cost = cost
                    best_insertion_index = i
            
            # Insert the selected node into the route
            route.insert(best_insertion_index, selected_node)
            current_load += demands[selected_node]
            unassigned_nodes.remove(selected_node)
        
        if len(route) > 2: # Ensure routes have customers
            # Update heuristic matrix
            route_cost = calculate_route_cost(route)
            for i in range(len(route) - 1):
                heuristics_matrix[route[i], route[i+1]] += 1/route_cost
                heuristics_matrix[route[i+1], route[i]] += 1/route_cost

    # Normalize heuristic matrix
    total_visits = np.sum(heuristics_matrix)
    if total_visits > 0:
      heuristics_matrix = heuristics_matrix / total_visits

    return heuristics_matrix
