import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs routes using a savings-based approach, iteratively merging routes until no further feasible merges exist, then evaluates edge frequency.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    def calculate_savings(distance_matrix):
        savings = np.zeros_like(distance_matrix, dtype=float)
        for i in range(1, n):
            for j in range(i + 1, n):
                savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
                savings[j, i] = savings[i, j]
        return savings
    
    savings_matrix = calculate_savings(distance_matrix)
    
    # Initialize routes - each customer is served by a separate vehicle
    routes = [[0, i, 0] for i in range(1, n)]
    
    # Perform savings-based merging
    merged = True
    while merged:
        merged = False
        best_savings = -1
        best_i = -1
        best_j = -1
        
        for i in range(len(routes)):
            for j in range(i + 1, len(routes)):
                # Check if routes can be merged
                if routes[i][-2] != 0 and routes[j][1] != 0:
                    total_demand = sum(demands[node] for node in routes[i][1:-1]) + sum(demands[node] for node in routes[j][1:-1])
                    if total_demand <= capacity and savings_matrix[routes[i][-2], routes[j][1]] > best_savings:
                        best_savings = savings_matrix[routes[i][-2], routes[j][1]]
                        best_i = i
                        best_j = j
        
        if best_savings > -1:
            # Merge routes
            routes[best_i] = routes[i][:-1] + routes[j][1:]
            del routes[j]
            merged = True
            
    # Update heuristics matrix based on the edges in the routes
    for route in routes:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1
    
    # Normalize the heuristics matrix
    total_routes = len(routes)
    for i in range(n):
        for j in range(n):
            if total_routes > 0:
                heuristics_matrix[i, j] /= total_routes
            else:
                heuristics_matrix[i, j] = 0  # Avoid division by zero

    return heuristics_matrix
