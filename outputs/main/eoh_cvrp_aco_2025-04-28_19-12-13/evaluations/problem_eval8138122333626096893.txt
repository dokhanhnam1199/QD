import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs solution samples using a nearest neighbor approach with capacity constraints and a probabilistic acceptance criterion based on solution cost, updating a heuristic matrix with edge frequencies weighted by accepted solution costs.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 500

    def calculate_route_load(route):
        load = 0
        for node in route[1:-1]:
            load += demands[node]
        return load

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    for _ in range(num_samples):
        routes = []
        unassigned_nodes = set(range(1, n))

        while unassigned_nodes:
            route = [0, 0]
            current_load = 0

            current_node = 0
            while True:
                # Find the nearest neighbor that doesn't exceed capacity
                nearest_neighbor = -1
                min_dist = float('inf')
                for node in unassigned_nodes:
                    if current_load + demands[node] <= capacity and distance_matrix[current_node, node] < min_dist:
                        min_dist = distance_matrix[current_node, node]
                        nearest_neighbor = node
                
                if nearest_neighbor != -1:
                    route.insert(-1, nearest_neighbor)
                    current_load += demands[nearest_neighbor]
                    unassigned_nodes.remove(nearest_neighbor)
                    current_node = nearest_neighbor
                else:
                    # No suitable neighbor found, return to depot
                    break
            routes.append(route)

        total_cost = sum(calculate_route_cost(route) for route in routes)
        
        #Probabilistic acceptance
        acceptance_prob = np.exp(-total_cost / 1000) #adjust the temperature parameter to tune acceptance
        if random.random() < acceptance_prob: #Accept based on probability
            for route in routes:
                for i in range(len(route) - 1):
                    node1 = route[i]
                    node2 = route[i+1]
                    heuristics_matrix[node1, node2] += 1.0 / (total_cost + 1e-6)
                    heuristics_matrix[node2, node1] += 1.0 / (total_cost + 1e-6)

    # Normalize
    total_edge_visits = np.sum(heuristics_matrix)
    if total_edge_visits > 0:
        heuristics_matrix = heuristics_matrix / total_edge_visits

    return heuristics_matrix
