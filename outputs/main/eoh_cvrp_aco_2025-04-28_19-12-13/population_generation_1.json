[
     {
          "algorithm": "This algorithm constructs initial routes using a savings-based approach, then iteratively refines these routes using local search and updates edge frequencies based on the improved solutions.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs initial routes using a savings-based approach, then iteratively refines these routes using local search and updates edge frequencies based on the improved solutions.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 50\n\n    # Savings calculation\n    savings = np.zeros((n, n), dtype=float)\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings[j, i] = savings[i, j]\n\n    # Initial route construction (Savings based)\n    routes = []\n    unvisited = set(range(1, n))\n    while unvisited:\n        best_saving = -1\n        best_i = -1\n        best_j = -1\n        for i in unvisited:\n            for j in unvisited:\n                if i != j and savings[i, j] > best_saving:\n                    best_saving = savings[i, j]\n                    best_i = i\n                    best_j = j\n\n        if best_i == -1:  # If no savings, create a route from depot to any remaining node\n            node = unvisited.pop()\n            routes.append([0, node, 0])\n            continue\n        \n        route = [0, best_i, best_j, 0]\n        current_load = demands[best_i] + demands[best_j]\n        unvisited.remove(best_i)\n        unvisited.remove(best_j)\n\n        # add more nodes until reaching capacity.\n        while True:\n            best_add_node = -1\n            best_add_saving = -1\n\n            for node in unvisited:\n                if current_load + demands[node] <= capacity:\n\n                    saving_i = savings[best_i, node]\n                    saving_j = savings[best_j, node]\n                    \n                    if saving_i >= saving_j and saving_i > best_add_saving :\n                        best_add_node = node\n                        best_add_saving = saving_i\n                    \n                    elif saving_j > saving_i and saving_j > best_add_saving:\n                        best_add_node = node\n                        best_add_saving = saving_j\n\n\n            if best_add_node != -1:\n                route.insert(len(route)-1,best_add_node)\n                current_load += demands[best_add_node]\n                unvisited.remove(best_add_node)\n                \n                best_j = route[-2] #update best_j\n                best_i = route[1]\n                \n\n            else:\n                routes.append(route)\n                break\n\n    # Iterative Improvement (Local Search - 2-opt within routes)\n    for _ in range(num_iterations):\n        for route in routes:\n            if len(route) <= 3:\n                continue\n            \n            for i in range(1, len(route) - 2):\n                for k in range(i + 1, len(route) - 1):\n                    # 2-opt swap\n                    new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]\n                    \n                    current_cost = 0\n                    for j in range(len(route) - 1):\n                        current_cost += distance_matrix[route[j], route[j+1]]\n                    \n                    new_cost = 0\n                    for j in range(len(new_route) - 1):\n                        new_cost += distance_matrix[new_route[j], new_route[j+1]]\n\n                    if new_cost < current_cost:\n                        route[:] = new_route  # Update route in place\n\n    # Update heuristics matrix\n    for route in routes:\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] += 1\n            heuristics_matrix[route[i+1], route[i]] += 1\n    \n    #Normalize heuristic matrix\n    total_visits = np.sum(heuristics_matrix)\n    if total_visits > 0:\n      heuristics_matrix = heuristics_matrix / total_visits\n    return heuristics_matrix",
          "objective": 13.97251,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively constructs solutions using a randomized Clarke-Wright savings approach, followed by route improvement via 2-opt swaps and guided by a pheromone-inspired heuristic matrix updated based on solution quality.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm iteratively constructs solutions using a randomized Clarke-Wright savings approach, followed by route improvement via 2-opt swaps and guided by a pheromone-inspired heuristic matrix updated based on solution quality.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 500\n    pheromone_matrix = np.ones_like(distance_matrix) * 0.01 # Initialize pheromone matrix\n\n    def calculate_route_load(route):\n        load = 0\n        for node in route[1:-1]:\n            load += demands[node]\n        return load\n\n    def calculate_route_cost(route):\n        cost = 0\n        for i in range(len(route) - 1):\n            cost += distance_matrix[route[i], route[i+1]]\n        return cost\n\n    def two_opt_swap(route):\n        best_route = route[:]\n        best_cost = calculate_route_cost(route)\n        for i in range(1, len(route) - 2):\n            for k in range(i + 1, len(route) - 1):\n                new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]\n                new_cost = calculate_route_cost(new_route)\n                if new_cost < best_cost:\n                    best_route = new_route[:]\n                    best_cost = new_cost\n        return best_route\n\n    def savings_heuristic(i, j):\n        return distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n\n    best_routes = None\n    best_cost = float('inf')\n\n    for iteration in range(num_iterations):\n        routes = []\n        unassigned_nodes = set(range(1, n))\n\n        # Randomized Savings-Based Route Construction\n        while unassigned_nodes:\n            i = random.choice(list(unassigned_nodes))\n            route = [0, i, 0]\n            current_load = demands[i]\n            unassigned_nodes.remove(i)\n\n            while True:\n                eligible_nodes = []\n                for j in unassigned_nodes:\n                    if current_load + demands[j] <= capacity:\n                        eligible_nodes.append(j)\n\n                if not eligible_nodes:\n                    break\n\n                # Use pheromone and savings to select the next node\n                probabilities = []\n                for node in eligible_nodes:\n                    savings = savings_heuristic(route[-2], node)\n                    pheromone = pheromone_matrix[route[-2], node]\n                    probabilities.append(savings * pheromone)\n                \n                if sum(probabilities) == 0:\n                    next_node = random.choice(eligible_nodes)\n                else:\n                    probabilities = [p / sum(probabilities) for p in probabilities]\n                    next_node = random.choices(eligible_nodes, weights=probabilities, k=1)[0]\n                \n\n                route.insert(-1, next_node)\n                current_load += demands[next_node]\n                unassigned_nodes.remove(next_node)\n\n            routes.append(route)\n\n        # Route Improvement with 2-Opt\n        for i in range(len(routes)):\n            routes[i] = two_opt_swap(routes[i])\n\n        # Evaluate Solution\n        current_cost = sum(calculate_route_cost(route) for route in routes)\n\n        # Update Best Solution\n        if current_cost < best_cost:\n            best_cost = current_cost\n            best_routes = [route[:] for route in routes]\n            \n             # Pheromone Update\n            delta_pheromone = 1.0 / current_cost\n            for route in routes:\n                for i in range(len(route) - 1):\n                    pheromone_matrix[route[i], route[i+1]] += delta_pheromone\n                    pheromone_matrix[route[i+1], route[i]] += delta_pheromone\n\n        # Evaporation\n        pheromone_matrix *= 0.9\n\n    # Heuristic Matrix Update based on best solution\n    for route in best_routes:\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] += 1\n            heuristics_matrix[route[i+1], route[i]] += 1\n    \n    #Normalize heuristic matrix\n    total_visits = np.sum(heuristics_matrix)\n    if total_visits > 0:\n      heuristics_matrix = heuristics_matrix / total_visits\n\n    return heuristics_matrix",
          "objective": 14.33413,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and penalizing edges in infeasible routes.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and penalizing edges in infeasible routes.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    penalty_factor = 10\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on shortest distance\n            distances = distance_matrix[current_node, remaining_nodes]\n            sorted_indices = np.argsort(distances)\n            \n            next_node_found = False\n            for idx in sorted_indices:\n              candidate_node = remaining_nodes[idx]\n              if vehicle_load + demands[candidate_node] <= capacity:\n                next_node = candidate_node\n                next_node_found = True\n                break\n\n            if not next_node_found:\n              # Return to depot if no feasible node found\n              for node in current_route:\n                heuristics_matrix[current_node, 0] -= penalty_factor\n                heuristics_matrix[0, current_node] -= penalty_factor\n                current_node = 0 # restart current_node from depot\n              vehicle_load = 0\n              current_route = []\n              \n              continue\n            \n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix\n            heuristics_matrix[current_node, next_node] += 1\n            heuristics_matrix[next_node, current_node] += 1\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += 1\n        heuristics_matrix[0, current_node] += 1\n\n\n    return heuristics_matrix",
          "objective": 14.4825,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge importance by iteratively constructing routes using a nearest neighbor approach with stochastic selection, favoring shorter edges and respecting capacity constraints, and updates edge importance based on route frequency and edge length with adjusted weighting.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge importance by iteratively constructing routes using a nearest neighbor approach with stochastic selection, favoring shorter edges and respecting capacity constraints, and updates edge importance based on route frequency and edge length with adjusted weighting.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Start from the depot\n        current_node = 0\n        current_route = [0]\n        current_load = 0\n        remaining_customers = set(range(1, n))\n        routes = []\n\n        while remaining_customers:\n            # Find nearest neighbors within capacity\n            eligible_neighbors = []\n            for neighbor in remaining_customers:\n                if current_load + demands[neighbor] <= capacity:\n                    eligible_neighbors.append(neighbor)\n\n            if not eligible_neighbors:\n                # Return to depot and start a new route\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0]\n                current_load = 0\n                current_node = 0\n                continue\n            \n            # Stochastic selection of the next node based on distance\n            probabilities = []\n            total_distance = 0\n            for neighbor in eligible_neighbors:\n                total_distance += (1 / (distance_matrix[current_node, neighbor]**2 + 1e-6)) # Square the distance\n\n            for neighbor in eligible_neighbors:\n                probabilities.append((1 / (distance_matrix[current_node, neighbor]**2 + 1e-6)) / total_distance) # Square the distance\n\n            next_node = random.choices(eligible_neighbors, weights=probabilities, k=1)[0]\n            \n            current_route.append(next_node)\n            current_load += demands[next_node]\n            remaining_customers.remove(next_node)\n            current_node = next_node\n        \n        current_route.append(0)\n        routes.append(current_route)\n    \n        # Update heuristic matrix based on edges in the routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n\n    # Normalize the heuristic matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    # Incorporate distance information (shorter distances are better)\n    heuristics_matrix = heuristics_matrix / (distance_matrix**1.5 + 1e-6) # Avoid division by zero and adjust the exponent\n\n    return heuristics_matrix",
          "objective": 14.55165,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewarding edges in feasible routes and penalizing less promising edges based on distance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and rewarding edges in feasible routes and penalizing less promising edges based on distance.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    reward_factor = 1\n    penalty_factor = 0.1\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on a combination of distance and demand\n            distances = distance_matrix[current_node, remaining_nodes]\n            \n            # Create a score based on distance and demand\n            scores = []\n            for i, node_idx in enumerate(remaining_nodes):\n                demand = demands[node_idx]\n                distance = distances[i]\n                \n                if vehicle_load + demand <= capacity:\n                    scores.append((distance, node_idx))\n                else:\n                    scores.append((float('inf'), node_idx))\n\n            #Find the possible node based on minimum distance\n            sorted_scores = sorted(scores, key=lambda x: x[0])\n\n            next_node_found = False\n            for distance, candidate_node in sorted_scores:\n                if distance != float('inf'):\n                    next_node = candidate_node\n                    next_node_found = True\n                    break\n\n            if not next_node_found:\n                # Return to depot if no feasible node found\n                for node in current_route:\n                    heuristics_matrix[current_node, 0] -= penalty_factor * distance_matrix[current_node,0]\n                    heuristics_matrix[0, current_node] -= penalty_factor * distance_matrix[0, current_node]\n                    current_node = 0 # restart current_node from depot\n                vehicle_load = 0\n                current_route = []\n                continue\n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix\n            heuristics_matrix[current_node, next_node] += reward_factor\n            heuristics_matrix[next_node, current_node] += reward_factor\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += reward_factor\n        heuristics_matrix[0, current_node] += reward_factor\n\n    return heuristics_matrix",
          "objective": 14.57733,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs an initial solution using a savings heuristic, then iteratively improves the solution by randomly selecting and re-inserting nodes into different routes, accepting moves based on cost improvement or a simulated annealing criterion, and finally aggregates edge frequencies from the accepted solutions to build a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 1000\n    initial_temperature = 100\n    cooling_rate = 0.99\n\n    # 1. Initial Solution (Savings Heuristic)\n    def calculate_savings(distance_matrix, i, j):\n        return distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n\n    savings = []\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings.append((i, j, calculate_savings(distance_matrix, i, j)))\n    savings.sort(key=lambda x: x[2], reverse=True)\n\n    routes = []\n    node_route = {",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs an initial solution using a savings heuristic, then iteratively improves the solution by randomly selecting and re-inserting nodes into different routes, accepting moves based on cost improvement or a simulated annealing criterion, and finally aggregates edge frequencies from the accepted solutions to build a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 1000\n    initial_temperature = 100\n    cooling_rate = 0.99\n\n    # 1. Initial Solution (Savings Heuristic)\n    def calculate_savings(distance_matrix, i, j):\n        return distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n\n    savings = []\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings.append((i, j, calculate_savings(distance_matrix, i, j)))\n    savings.sort(key=lambda x: x[2], reverse=True)\n\n    routes = []\n    node_route = {}\n    for i in range(1, n):\n        routes.append([0, i, 0])\n        node_route[i] = len(routes) - 1\n\n    for i, j, _ in savings:\n        if node_route.get(i) is not None and node_route.get(j) is not None and node_route[i] != node_route[j]:\n            route_i_idx = node_route[i]\n            route_j_idx = node_route[j]\n            route_i = routes[route_i_idx]\n            route_j = routes[route_j_idx]\n\n            if route_i[-2] != 0 and route_j[1] != 0:\n                total_demand = sum(demands[node] for node in route_i[1:-1]) + sum(demands[node] for node in route_j[1:-1])\n                if total_demand <= capacity:\n                    new_route = route_i[:-1] + route_j[1:]\n                    routes[route_i_idx] = new_route\n                    for node in route_j[1:-1]:\n                        node_route[node] = route_i_idx\n                    routes.pop(route_j_idx)\n                    for node, route_idx in node_route.items():\n                        if route_idx > route_j_idx:\n                            node_route[node] -= 1\n\n    def calculate_cost(routes):\n        cost = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                cost += distance_matrix[route[i]][route[i+1]]\n        return cost\n\n    def is_feasible(routes):\n        for route in routes:\n            current_capacity = capacity\n            for i in range(1,len(route)-1):\n                current_capacity -= demands[route[i]]\n            if current_capacity < 0:\n                return False\n        return True\n\n    best_routes = [route[:] for route in routes]\n    best_cost = calculate_cost(routes)\n\n    # 2. Iterative Improvement (Simulated Annealing with Node Re-insertion)\n    temperature = initial_temperature\n    for iteration in range(num_iterations):\n        # a. Perturb: Randomly select a node and re-insert it into a different route\n        routes_copy = [route[:] for route in routes]\n        if len(routes_copy) > 0:\n            route_idx = random.randint(0, len(routes_copy) - 1)\n            route = routes_copy[route_idx]\n            if len(route) > 2:\n                node_idx = random.randint(1, len(route) - 2)\n                node_to_move = route[node_idx]\n                \n                original_route = route[:]\n                original_route.pop(node_idx)\n                \n                new_route_idx = random.randint(0, len(routes_copy) - 1)\n                while new_route_idx == route_idx and len(routes_copy) > 1:\n                    new_route_idx = random.randint(0, len(routes_copy) - 1)\n\n                new_route = routes_copy[new_route_idx]\n                \n                insert_pos = random.randint(1, len(new_route) - 1)\n                new_route.insert(insert_pos, node_to_move)\n\n                # check capacity\n                original_capacity = capacity\n                for i in range(1, len(original_route)-1):\n                    original_capacity -= demands[original_route[i]]\n\n                new_capacity = capacity\n                for i in range(1, len(new_route)-1):\n                    new_capacity -= demands[new_route[i]]\n\n                if original_capacity < 0 or new_capacity < 0:\n                    routes_copy = [route[:] for route in routes]\n                else:\n                    routes_copy[route_idx] = original_route\n                    routes_copy[new_route_idx] = new_route\n                    new_cost = calculate_cost(routes_copy)\n                    cost_difference = new_cost - calculate_cost(routes)\n\n                    # b. Acceptance Criterion (Simulated Annealing)\n                    if cost_difference < 0 or random.random() < np.exp(-cost_difference / temperature):\n                        routes = routes_copy\n                        if new_cost < best_cost:\n                            best_cost = new_cost\n                            best_routes = [route[:] for route in routes]\n\n        # c. Cooling\n        temperature *= cooling_rate\n\n    # 3. Heuristic Matrix Construction\n    for route in best_routes:\n        for i in range(len(route) - 1):\n            node1 = route[i]\n            node2 = route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    return heuristics_matrix",
          "objective": 14.93217,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm explores a wider range of solutions by adjusting the influence of savings and pheromone in route construction and employing a more aggressive pheromone update strategy.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm explores a wider range of solutions by adjusting the influence of savings and pheromone in route construction and employing a more aggressive pheromone update strategy.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 500\n    pheromone_matrix = np.ones_like(distance_matrix) * 0.01  # Initialize pheromone matrix\n    alpha = 0.7  # Weight for savings\n    beta = 0.3   # Weight for pheromone\n    evaporation_rate = 0.7 # Increased evaporation rate\n\n    def calculate_route_load(route):\n        load = 0\n        for node in route[1:-1]:\n            load += demands[node]\n        return load\n\n    def calculate_route_cost(route):\n        cost = 0\n        for i in range(len(route) - 1):\n            cost += distance_matrix[route[i], route[i+1]]\n        return cost\n\n    def two_opt_swap(route):\n        best_route = route[:]\n        best_cost = calculate_route_cost(route)\n        for i in range(1, len(route) - 2):\n            for k in range(i + 1, len(route) - 1):\n                new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]\n                new_cost = calculate_route_cost(new_route)\n                if new_cost < best_cost:\n                    best_route = new_route[:]\n                    best_cost = new_cost\n        return best_route\n\n    def savings_heuristic(i, j):\n        return distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n\n    best_routes = None\n    best_cost = float('inf')\n\n    for iteration in range(num_iterations):\n        routes = []\n        unassigned_nodes = set(range(1, n))\n\n        # Randomized Savings-Based Route Construction\n        while unassigned_nodes:\n            i = random.choice(list(unassigned_nodes))\n            route = [0, i, 0]\n            current_load = demands[i]\n            unassigned_nodes.remove(i)\n\n            while True:\n                eligible_nodes = []\n                for j in unassigned_nodes:\n                    if current_load + demands[j] <= capacity:\n                        eligible_nodes.append(j)\n\n                if not eligible_nodes:\n                    break\n\n                # Use pheromone and savings to select the next node\n                probabilities = []\n                for node in eligible_nodes:\n                    savings = savings_heuristic(route[-2], node)\n                    pheromone = pheromone_matrix[route[-2], node]\n                    probabilities.append((savings**alpha) * (pheromone**beta))\n                \n                if sum(probabilities) == 0:\n                    next_node = random.choice(eligible_nodes)\n                else:\n                    probabilities = [p / sum(probabilities) for p in probabilities]\n                    next_node = random.choices(eligible_nodes, weights=probabilities, k=1)[0]\n                \n\n                route.insert(-1, next_node)\n                current_load += demands[next_node]\n                unassigned_nodes.remove(next_node)\n\n            routes.append(route)\n\n        # Route Improvement with 2-Opt\n        for i in range(len(routes)):\n            routes[i] = two_opt_swap(routes[i])\n\n        # Evaluate Solution\n        current_cost = sum(calculate_route_cost(route) for route in routes)\n\n        # Update Best Solution\n        if current_cost < best_cost:\n            best_cost = current_cost\n            best_routes = [route[:] for route in routes]\n            \n             # Pheromone Update (Aggressive Update)\n            delta_pheromone = 1.0 / current_cost\n            for route in routes:\n                for i in range(len(route) - 1):\n                    pheromone_matrix[route[i], route[i+1]] += 2*delta_pheromone # Increased pheromone deposit\n                    pheromone_matrix[route[i+1], route[i]] += 2*delta_pheromone # Increased pheromone deposit\n\n        # Evaporation\n        pheromone_matrix *= evaporation_rate\n\n    # Heuristic Matrix Update based on best solution\n    for route in best_routes:\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] += 1\n            heuristics_matrix[route[i+1], route[i]] += 1\n    \n    #Normalize heuristic matrix\n    total_visits = np.sum(heuristics_matrix)\n    if total_visits > 0:\n      heuristics_matrix = heuristics_matrix / total_visits\n\n    return heuristics_matrix",
          "objective": 15.18833,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively constructs routes using a hybrid approach combining savings and nearest neighbor criteria, then refines routes by a combination of node re-insertion and 2-opt swaps within routes, while updating a heuristic matrix based on edge usage frequency in improving solutions.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 500\n\n    def calculate_route_load(route):\n        load = 0\n        for node in route[1:-1]:\n            load += demands[node]\n        return load\n\n    def calculate_route_cost(route):\n        cost = 0\n        for i in range(len(route) - 1):\n            cost += distance_matrix[route[i], route[i+1]]\n        return cost\n\n    def two_opt_swap(route):\n        best_route = route[:]\n        best_cost = calculate_route_cost(route)\n        for i in range(1, len(route) - 2):\n            for k in range(i + 1, len(route) - 1):\n                new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]\n                new_cost = calculate_route_cost(new_route)\n                if new_cost < best_cost:\n                    best_route = new_route[:]\n                    best_cost = new_cost\n        return best_route\n\n    routes = []\n    unassigned_nodes = set(range(1, n))\n\n    while unassigned_nodes:\n        # Hybrid route construction: Savings + Nearest Neighbor\n        route = [0]\n        current_load = 0\n        last_node = 0\n\n        while True:\n            feasible_nodes = [node for node in unassigned_nodes if current_load + demands[node] <= capacity]\n\n            if not feasible_nodes:\n                break\n\n            # Combine savings and nearest neighbor\n            savings_values = {node: distance_matrix[0, last_node] + distance_matrix[0, node] - distance_matrix[last_node, node] for node in feasible_nodes",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm iteratively constructs routes using a hybrid approach combining savings and nearest neighbor criteria, then refines routes by a combination of node re-insertion and 2-opt swaps within routes, while updating a heuristic matrix based on edge usage frequency in improving solutions.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 500\n\n    def calculate_route_load(route):\n        load = 0\n        for node in route[1:-1]:\n            load += demands[node]\n        return load\n\n    def calculate_route_cost(route):\n        cost = 0\n        for i in range(len(route) - 1):\n            cost += distance_matrix[route[i], route[i+1]]\n        return cost\n\n    def two_opt_swap(route):\n        best_route = route[:]\n        best_cost = calculate_route_cost(route)\n        for i in range(1, len(route) - 2):\n            for k in range(i + 1, len(route) - 1):\n                new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]\n                new_cost = calculate_route_cost(new_route)\n                if new_cost < best_cost:\n                    best_route = new_route[:]\n                    best_cost = new_cost\n        return best_route\n\n    routes = []\n    unassigned_nodes = set(range(1, n))\n\n    while unassigned_nodes:\n        # Hybrid route construction: Savings + Nearest Neighbor\n        route = [0]\n        current_load = 0\n        last_node = 0\n\n        while True:\n            feasible_nodes = [node for node in unassigned_nodes if current_load + demands[node] <= capacity]\n\n            if not feasible_nodes:\n                break\n\n            # Combine savings and nearest neighbor\n            savings_values = {node: distance_matrix[0, last_node] + distance_matrix[0, node] - distance_matrix[last_node, node] for node in feasible_nodes}\n            nearest_neighbors = sorted(feasible_nodes, key=lambda node: distance_matrix[last_node, node])\n\n            candidates = []\n            if len(savings_values) > 0:\n                max_saving = max(savings_values.values())\n                candidates.extend([node for node, saving in savings_values.items() if saving == max_saving])\n\n            candidates.extend(nearest_neighbors[:2]) #add up to 2 nearest neighbours\n            \n            if len(candidates) > 0:\n                 selected_node = random.choice(candidates)\n            else:\n                 break\n           \n            route.append(selected_node)\n            current_load += demands[selected_node]\n            unassigned_nodes.remove(selected_node)\n            last_node = selected_node\n            \n\n        route.append(0)\n        routes.append(route)\n\n    # Iterative Improvement: Re-insertion and 2-Opt\n    best_routes = [route[:] for route in routes]\n    best_cost = sum(calculate_route_cost(route) for route in routes)\n\n    for _ in range(num_iterations):\n        # 1. Node Re-insertion\n        route_to_remove_from = random.randint(0, len(routes) - 1)\n        if len(routes[route_to_remove_from]) <= 3:\n            continue\n        node_to_reinsert_index = random.randint(1, len(routes[route_to_remove_from]) - 2)\n        node_to_reinsert = routes[route_to_remove_from][node_to_reinsert_index]\n        original_load = calculate_route_load(routes[route_to_remove_from])\n        routes[route_to_remove_from].pop(node_to_reinsert_index)\n\n        best_insertion_route = -1\n        best_insertion_index = -1\n        best_insertion_cost = float('inf')\n\n        for i in range(len(routes)):\n            for j in range(1, len(routes[i])):\n                temp_route = routes[i][:]\n                temp_route.insert(j, node_to_reinsert)\n\n                if calculate_route_load(temp_route) <= capacity:\n                    new_cost = calculate_route_cost(temp_route)\n                    if new_cost < best_insertion_cost:\n                        best_insertion_cost = new_cost\n                        best_insertion_route = i\n                        best_insertion_index = j\n\n        if best_insertion_route != -1:\n            routes[best_insertion_route].insert(best_insertion_index, node_to_reinsert)\n\n        # 2. 2-Opt within routes\n        for i in range(len(routes)):\n            routes[i] = two_opt_swap(routes[i])\n\n        # Check overall solution cost\n        current_cost = sum(calculate_route_cost(route) for route in routes)\n        if current_cost < best_cost:\n            best_cost = current_cost\n            best_routes = [route[:] for route in routes]\n\n    # Heuristic Matrix Update\n    for route in best_routes:\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] += 1\n            heuristics_matrix[route[i+1], route[i]] += 1\n\n    #Normalize heuristic matrix\n    total_visits = np.sum(heuristics_matrix)\n    if total_visits > 0:\n      heuristics_matrix = heuristics_matrix / total_visits\n    return heuristics_matrix",
          "objective": 15.30544,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm initializes routes randomly, then iteratively improves them using a combination of 2-opt, node insertion, and route splitting, updating edge frequencies based on the improved solutions.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm initializes routes randomly, then iteratively improves them using a combination of 2-opt, node insertion, and route splitting, updating edge frequencies based on the improved solutions.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 50\n    num_routes = 5\n\n    # Initial random route generation\n    routes = []\n    for _ in range(num_routes):\n        unvisited = list(range(1, n))\n        random.shuffle(unvisited)\n        \n        current_route = [0]\n        current_load = 0\n        \n        for node in unvisited:\n            if current_load + demands[node] <= capacity:\n                current_route.append(node)\n                current_load += demands[node]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, node]\n                current_load = demands[node]\n\n        current_route.append(0)\n        routes.append(current_route)\n\n    # Iterative Improvement\n    for _ in range(num_iterations):\n        for route in routes:\n            if len(route) <= 3:\n                continue\n\n            # 2-opt within routes\n            for i in range(1, len(route) - 2):\n                for k in range(i + 1, len(route) - 1):\n                    new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]\n\n                    current_cost = 0\n                    for j in range(len(route) - 1):\n                        current_cost += distance_matrix[route[j], route[j+1]]\n\n                    new_cost = 0\n                    for j in range(len(new_route) - 1):\n                        new_cost += distance_matrix[new_route[j], new_route[j+1]]\n\n                    if new_cost < current_cost:\n                        route[:] = new_route\n\n            # Node Insertion (relocate node to best position in another route)\n            for _ in range(2):\n                route1 = random.choice(routes)\n                if len(route1) <= 3:\n                    continue\n\n                node_to_move_idx = random.randint(1, len(route1) - 2)\n                node_to_move = route1[node_to_move_idx]\n                \n                original_cost = 0\n                original_cost += distance_matrix[route1[node_to_move_idx-1],route1[node_to_move_idx]]\n                original_cost += distance_matrix[route1[node_to_move_idx],route1[node_to_move_idx+1]]\n                original_cost -= distance_matrix[route1[node_to_move_idx-1],route1[node_to_move_idx+1]]\n                \n                route1.pop(node_to_move_idx)\n\n                best_route = None\n                best_insert_idx = -1\n                best_cost_reduction = float('-inf')\n                \n                for route2 in routes:\n                    if route1 == route2 : continue\n                    \n                    for insert_idx in range(1, len(route2)):\n                        if route2[insert_idx-1] == 0 and demands[node_to_move] > capacity:\n                            continue\n                        \n                        temp_load = 0\n                        for node in route2[1:]:\n                            if node == 0: break\n                            temp_load += demands[node]\n\n                        if temp_load + demands[node_to_move] <= capacity or route2[insert_idx-1]==0:\n                            \n                            new_cost = 0\n                            new_cost += distance_matrix[route2[insert_idx-1],node_to_move]\n                            new_cost += distance_matrix[node_to_move,route2[insert_idx]]\n                            new_cost -= distance_matrix[route2[insert_idx-1],route2[insert_idx]]\n                                \n                            cost_reduction = original_cost-new_cost\n                            \n                            if cost_reduction > best_cost_reduction:\n                                best_cost_reduction = cost_reduction\n                                best_route = route2\n                                best_insert_idx = insert_idx\n                \n                if best_route is not None and best_insert_idx != -1:\n                    best_route.insert(best_insert_idx, node_to_move)\n    # Update heuristics matrix\n    for route in routes:\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] += 1\n            heuristics_matrix[route[i+1], route[i]] += 1\n\n    # Normalize heuristic matrix\n    total_visits = np.sum(heuristics_matrix)\n    if total_visits > 0:\n        heuristics_matrix = heuristics_matrix / total_visits\n    return heuristics_matrix",
          "objective": 15.8471,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs an initial solution using a nearest neighbor heuristic, then iteratively improves the solution by swapping nodes between routes and within routes, accepting moves based on cost improvement or a simulated annealing criterion, and finally aggregates edge frequencies from the accepted solutions to build a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs an initial solution using a nearest neighbor heuristic, then iteratively improves the solution by swapping nodes between routes and within routes, accepting moves based on cost improvement or a simulated annealing criterion, and finally aggregates edge frequencies from the accepted solutions to build a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 1000\n    initial_temperature = 50\n    cooling_rate = 0.995\n\n    # 1. Initial Solution (Nearest Neighbor)\n    def create_initial_solution(distance_matrix, demands, capacity):\n        remaining_nodes = set(range(1, len(demands)))\n        routes = []\n        while remaining_nodes:\n            route = [0]\n            current_capacity = capacity\n            current_node = 0\n            while remaining_nodes:\n                nearest_node = None\n                min_distance = float('inf')\n                for neighbor in remaining_nodes:\n                    if distance_matrix[current_node, neighbor] < min_distance and demands[neighbor] <= current_capacity:\n                        nearest_node = neighbor\n                        min_distance = distance_matrix[current_node, neighbor]\n\n                if nearest_node is None:\n                    break\n\n                route.append(nearest_node)\n                current_capacity -= demands[nearest_node]\n                remaining_nodes.remove(nearest_node)\n                current_node = nearest_node\n            route.append(0)\n            routes.append(route)\n        return routes\n\n    routes = create_initial_solution(distance_matrix, demands, capacity)\n\n    def calculate_cost(routes):\n        cost = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                cost += distance_matrix[route[i]][route[i+1]]\n        return cost\n\n    def is_feasible(routes):\n        for route in routes:\n            current_capacity = capacity\n            for i in range(1,len(route)-1):\n                current_capacity -= demands[route[i]]\n            if current_capacity < 0:\n                return False\n        return True\n\n    best_routes = [route[:] for route in routes]\n    best_cost = calculate_cost(routes)\n\n    # 2. Iterative Improvement (Simulated Annealing with Node Swaps)\n    temperature = initial_temperature\n    for iteration in range(num_iterations):\n        routes_copy = [route[:] for route in routes]\n        # a. Perturb: Randomly select a route and perform a swap (within or between routes)\n        if len(routes_copy) > 0:\n            route_idx1 = random.randint(0, len(routes_copy) - 1)\n            route1 = routes_copy[route_idx1]\n\n            # Swap within route\n            if len(route1) > 3:\n                idx1 = random.randint(1, len(route1) - 2)\n                idx2 = random.randint(1, len(route1) - 2)\n                route1[idx1], route1[idx2] = route1[idx2], route1[idx1]\n                routes_copy[route_idx1] = route1\n\n            #Swap between routes\n            else:\n                route_idx2 = random.randint(0, len(routes_copy) - 1)\n                while route_idx2 == route_idx1 and len(routes_copy) > 1:\n                    route_idx2 = random.randint(0, len(routes_copy) - 1)\n                route2 = routes_copy[route_idx2]\n\n                if len(route1) > 2 and len(route2) > 2:\n\n                    node_idx1 = random.randint(1, len(route1) - 2)\n                    node_idx2 = random.randint(1, len(route2) - 2)\n\n                    node1 = route1[node_idx1]\n                    node2 = route2[node_idx2]\n\n                    route1[node_idx1] = node2\n                    route2[node_idx2] = node1\n                    \n                    original_capacity1 = capacity\n                    for i in range(1, len(route1)-1):\n                        original_capacity1 -= demands[route1[i]]\n\n                    original_capacity2 = capacity\n                    for i in range(1, len(route2)-1):\n                        original_capacity2 -= demands[route2[i]]\n\n\n                    if original_capacity1 < 0 or original_capacity2 < 0:\n                        routes_copy = [route[:] for route in routes]\n                    else:\n                        routes_copy[route_idx1] = route1\n                        routes_copy[route_idx2] = route2\n\n            new_cost = calculate_cost(routes_copy)\n            cost_difference = new_cost - calculate_cost(routes)\n\n            # b. Acceptance Criterion (Simulated Annealing)\n            if cost_difference < 0 or random.random() < np.exp(-cost_difference / temperature):\n                routes = routes_copy\n                if new_cost < best_cost:\n                    best_cost = new_cost\n                    best_routes = [route[:] for route in routes]\n\n        # c. Cooling\n        temperature *= cooling_rate\n\n    # 3. Heuristic Matrix Construction\n    for route in best_routes:\n        for i in range(len(route) - 1):\n            node1 = route[i]\n            node2 = route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    return heuristics_matrix",
          "objective": 15.93264,
          "other_inf": null
     }
]