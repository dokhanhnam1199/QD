[
     {
          "algorithm": "This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and penalizing edges in infeasible routes.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by repeatedly sampling random routes that satisfy capacity constraints and penalizing edges in infeasible routes.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    penalty_factor = 10\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on shortest distance\n            distances = distance_matrix[current_node, remaining_nodes]\n            sorted_indices = np.argsort(distances)\n            \n            next_node_found = False\n            for idx in sorted_indices:\n              candidate_node = remaining_nodes[idx]\n              if vehicle_load + demands[candidate_node] <= capacity:\n                next_node = candidate_node\n                next_node_found = True\n                break\n\n            if not next_node_found:\n              # Return to depot if no feasible node found\n              for node in current_route:\n                heuristics_matrix[current_node, 0] -= penalty_factor\n                heuristics_matrix[0, current_node] -= penalty_factor\n                current_node = 0 # restart current_node from depot\n              vehicle_load = 0\n              current_route = []\n              \n              continue\n            \n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix\n            heuristics_matrix[current_node, next_node] += 1\n            heuristics_matrix[next_node, current_node] += 1\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += 1\n        heuristics_matrix[0, current_node] += 1\n\n\n    return heuristics_matrix",
          "objective": 14.4825,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge importance by randomly generating feasible routes\n    and counting how often each edge appears in those routes, favoring shorter edges and\n    routes that respect vehicle capacity limits.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge importance by randomly generating feasible routes\n    and counting how often each edge appears in those routes, favoring shorter edges and\n    routes that respect vehicle capacity limits.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Randomly shuffle customers (excluding the depot)\n        customers = list(range(1, n))\n        random.shuffle(customers)\n\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_load = 0\n\n        for customer in customers:\n            if current_load + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route\n                current_load = demands[customer]\n\n        current_route.append(0)  # Return to depot after last customer\n        routes.append(current_route)\n\n        # Update heuristic matrix based on edges in the routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1 # Symmetric matrix\n\n    # Normalize the heuristic matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    # Incorporate distance information (shorter distances are better)\n    heuristics_matrix = heuristics_matrix / (distance_matrix + 1e-6) # Avoid division by zero\n\n    return heuristics_matrix",
          "objective": 24.73291,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples a set of random routes respecting capacity constraints,\n    and then calculates a matrix where each entry represents the frequency that edge\n    was used in the sampled routes, thus indicating how promising it is to include\n    each edge in the solution.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a set of random routes respecting capacity constraints,\n    and then calculates a matrix where each entry represents the frequency that edge\n    was used in the sampled routes, thus indicating how promising it is to include\n    each edge in the solution.}\n    \"\"\"\n    n = len(demands)\n    num_samples = 100  # Number of random routes to sample\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        unvisited = set(range(1, n))  # Exclude depot (node 0)\n        routes = []\n\n        while unvisited:\n            current_route = [0]  # Start at the depot\n            current_capacity = capacity\n            \n            while unvisited and current_capacity >= min(demands[list(unvisited)]):\n                # Find feasible nodes to add\n                feasible_nodes = [node for node in unvisited if demands[node] <= current_capacity]\n                \n                if not feasible_nodes:\n                    break\n                \n                #Select next node probabilistically favoring close unvisited nodes\n                distances_to_current_node = [distance_matrix[current_route[-1]][node] for node in feasible_nodes]\n                probabilities = [1/d if d > 0 else 1 for d in distances_to_current_node]\n                probabilities = [p / sum(probabilities) for p in probabilities]\n\n                next_node = random.choices(feasible_nodes, weights=probabilities, k=1)[0]\n                \n                current_route.append(next_node)\n                current_capacity -= demands[next_node]\n                unvisited.remove(next_node)\n            \n            current_route.append(0)  # Return to depot\n            routes.append(current_route)\n\n        # Update heuristics matrix based on the edges in the sampled routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n\n    # Normalize the heuristics matrix\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 25.03643,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge inclusion probabilities by repeatedly constructing feasible CVRP solutions using a randomized nearest neighbor approach, biased by distance and demand, and then averaging the edge frequencies across multiple solutions.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge inclusion probabilities by repeatedly constructing feasible CVRP solutions using a randomized nearest neighbor approach, biased by distance and demand, and then averaging the edge frequencies across multiple solutions.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100 # Number of sample solutions to generate\n\n    for _ in range(num_samples):\n        routes = []\n        remaining_nodes = set(range(1, n))  # Exclude depot\n        while remaining_nodes:\n            route = [0]  # Start at the depot\n            current_capacity = capacity\n            last_node = 0\n            \n            while True:\n                # Find feasible neighbors\n                feasible_neighbors = [\n                    node for node in remaining_nodes\n                    if demands[node] <= current_capacity\n                ]\n                \n                if not feasible_neighbors:\n                    break  # No more feasible nodes to add\n\n                # Randomized Nearest Neighbor Selection\n                probabilities = []\n                total_distance = 0\n                for neighbor in feasible_neighbors:\n                    total_distance += distance_matrix[last_node][neighbor]\n                \n                if total_distance > 0:\n                    for neighbor in feasible_neighbors:\n                        probabilities.append( (1 / distance_matrix[last_node][neighbor]) / total_distance) \n                else:\n                     probabilities = [1/len(feasible_neighbors)] * len(feasible_neighbors)\n\n                # Choose the next node based on probability\n                next_node = random.choices(feasible_neighbors, probabilities)[0]\n                \n                route.append(next_node)\n                current_capacity -= demands[next_node]\n                remaining_nodes.remove(next_node)\n                last_node = next_node\n            \n            route.append(0)  # Return to depot\n            routes.append(route)\n\n        # Update heuristics matrix\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n    \n    heuristics_matrix /= num_samples  # Normalize to get edge frequencies\n    return heuristics_matrix",
          "objective": 25.52956,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by sampling random routes, evaluating feasibility and cost, and favoring edges present in good solutions.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by sampling random routes, evaluating feasibility and cost, and favoring edges present in good solutions.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000  # Number of random routes to sample\n    alpha = 1.0  # Parameter to control the influence of route cost\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        # Construct a route based on the random permutation\n        current_route = [0]  # Start at the depot\n        current_capacity = 0\n        routes = []\n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_capacity = demands[customer]\n        current_route.append(0) # end at depot\n        routes.append(current_route)\n        \n        # Calculate the cost of the route\n        total_cost = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_cost += distance_matrix[route[i], route[i+1]]\n\n        # Update the heuristics matrix based on the edges in the route\n        route_cost_factor = np.exp(-alpha * total_cost / np.mean(distance_matrix)) #normalized cost\n        for route in routes:\n            for i in range(len(route) - 1):\n                u = route[i]\n                v = route[i+1]\n                heuristics_matrix[u, v] += route_cost_factor\n                heuristics_matrix[v, u] += route_cost_factor #assumes symmetry\n\n    # Normalize the heuristics matrix\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 26.02886,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random routes respecting capacity constraints,\n    evaluates the cost of each route, and then constructs a heuristic matrix\n    where each entry reflects the frequency with which the corresponding edge\n    appears in the best routes found during the sampling process.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm generates multiple random routes respecting capacity constraints,\n    evaluates the cost of each route, and then constructs a heuristic matrix\n    where each entry reflects the frequency with which the corresponding edge\n    appears in the best routes found during the sampling process.}\n    \"\"\"\n    n = len(demands)\n    num_samples = 1000\n    best_routes = []\n    best_costs = []\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding depot)\n        customer_indices = np.random.permutation(np.arange(1, n))\n        \n        routes = []\n        current_route = [0]  # Start at the depot\n        current_capacity = 0\n\n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer] # Start new route\n                current_capacity = demands[customer]\n\n        current_route.append(0)\n        routes.append(current_route)\n\n\n        # Calculate the total cost of the routes\n        total_cost = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_cost += distance_matrix[route[i], route[i+1]]\n\n        # Keep track of best solutions\n        if len(best_costs) < 10 or total_cost < max(best_costs):\n            if len(best_costs) == 10:\n                max_index = np.argmax(best_costs)\n                best_costs.pop(max_index)\n                best_routes.pop(max_index)\n\n            best_routes.append(routes)\n            best_costs.append(total_cost)\n    \n    # Build the heuristic matrix\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    for routes in best_routes:\n        for route in routes:\n            for i in range(len(route) - 1):\n                heuristics_matrix[route[i], route[i+1]] += 1\n                heuristics_matrix[route[i+1], route[i]] += 1\n\n    return heuristics_matrix",
          "objective": 26.52363,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random routes satisfying capacity constraints, evaluates their cost, and uses the edge frequencies in low-cost routes to construct a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm generates multiple random routes satisfying capacity constraints, evaluates their cost, and uses the edge frequencies in low-cost routes to construct a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n    best_cost = float('inf')\n\n    for _ in range(num_samples):\n        unvisited = list(range(1, n))\n        routes = []\n        current_route = [0]\n        current_capacity = capacity\n\n        while unvisited:\n            next_node = np.random.choice(unvisited)\n            \n            if current_capacity >= demands[next_node]:\n                current_route.append(next_node)\n                current_capacity -= demands[next_node]\n                unvisited.remove(next_node)\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0]\n                current_capacity = capacity\n\n        current_route.append(0)\n        routes.append(current_route)\n\n        cost = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                cost += distance_matrix[route[i], route[i+1]]\n\n        if cost < best_cost:\n            best_cost = cost\n            for route in routes:\n                for i in range(len(route) - 1):\n                    heuristics_matrix[route[i], route[i+1]] += 1\n                    heuristics_matrix[route[i+1], route[i]] += 1\n\n    return heuristics_matrix",
          "objective": 27.24556,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple stochastic routes by iteratively adding nodes based on distance and demand considerations, \n     evaluates their feasibility and cost, and then constructs a heuristic matrix reflecting the frequency with which each edge appears in good solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples multiple stochastic routes by iteratively adding nodes based on distance and demand considerations, \n     evaluates their feasibility and cost, and then constructs a heuristic matrix reflecting the frequency with which each edge appears in good solutions.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 100  # Number of stochastic routes to sample\n\n    for _ in range(num_samples):\n        # Start a new route from the depot\n        current_route = [0]\n        current_load = 0\n        remaining_nodes = set(range(1, n))  # Exclude depot\n        \n        while remaining_nodes:\n            # Find the nearest feasible node to the last node in the current route\n            last_node = current_route[-1]\n            \n            # Candidate nodes: exclude already visited ones, and depot if we need a new route.\n            candidate_nodes = [node for node in remaining_nodes if demands[node] + current_load <= capacity]\n           \n            if not candidate_nodes:  \n                # If no feasible node from the current depot, return to depot and start a new route\n                current_route.append(0)\n                current_load = 0\n                candidate_nodes = [node for node in remaining_nodes if demands[node] + current_load <= capacity]\n\n                if not candidate_nodes:  # Even from the depot no possible nodes, something is wrong.\n                    break\n\n\n            # Select the next node stochastically. Nodes closer in distance have more weight.\n            distances = np.array([distance_matrix[last_node, node] for node in candidate_nodes])\n            probabilities = np.exp(-distances) / np.sum(np.exp(-distances))  # Convert distances to probabilities\n\n            next_node = np.random.choice(candidate_nodes, p=probabilities)\n\n            # Add the next node to the current route and update load\n            current_route.append(next_node)\n            current_load += demands[next_node]\n            remaining_nodes.remove(next_node)\n\n        # Return to depot from last node\n        current_route.append(0)\n\n        # Update the heuristics matrix based on this route\n        for i in range(len(current_route) - 1):\n            node1 = current_route[i]\n            node2 = current_route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1  # Ensure symmetry\n\n    # Normalize the heuristics matrix by the number of samples\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 27.86555,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples a large number of random routes, evaluates their feasibility and cost, and uses the frequency with which each edge appears in feasible routes to build a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm samples a large number of random routes, evaluates their feasibility and cost, and uses the frequency with which each edge appears in feasible routes to build a heuristic matrix.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n    \n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n        \n        # Construct routes\n        routes = []\n        current_route = [0]  # Start at depot\n        current_demand = 0\n        \n        for customer in customer_indices:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route\n                current_demand = demands[customer]\n        \n        current_route.append(0)  # Close the last route\n        routes.append(current_route)\n        \n        # Evaluate feasibility (we've already done this during route construction)\n        \n        # Update heuristics matrix based on edges in feasible routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                u = route[i]\n                v = route[i+1]\n                heuristics_matrix[u, v] += 1\n                heuristics_matrix[v, u] += 1  # Assuming symmetric distance matrix\n                \n    # Normalize heuristics matrix (optional, but can be helpful)\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 29.09227,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses stochastic sampling to explore the solution space by iteratively constructing routes and updating edge frequencies based on route feasibility and cost, thereby building a heuristics matrix that reflects the likelihood of each edge being part of a good CVRP solution.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm uses stochastic sampling to explore the solution space by iteratively constructing routes and updating edge frequencies based on route feasibility and cost, thereby building a heuristics matrix that reflects the likelihood of each edge being part of a good CVRP solution.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 100  # Number of sample routes to generate\n    \n    for _ in range(num_samples):\n        # Initialize route and remaining nodes\n        current_route = [0]  # Start at depot\n        remaining_nodes = set(range(1, n))\n        current_load = 0\n        routes = []\n        \n        while remaining_nodes:\n            # Find the nearest feasible node\n            nearest_node = None\n            min_distance = float('inf')\n\n            possible_nodes = []\n            for node in remaining_nodes:\n                if current_load + demands[node] <= capacity:\n                    possible_nodes.append(node)\n            \n            if not possible_nodes:\n                current_route.append(0) # Return to depot\n                routes.append(current_route)\n                current_route = [0]\n                current_load = 0\n                continue\n\n            #Choose randomly among feasible nodes\n            nearest_node = random.choice(possible_nodes) \n\n            # Update current route, remaining nodes, and current load\n            current_route.append(nearest_node)\n            remaining_nodes.remove(nearest_node)\n            current_load += demands[nearest_node]\n        \n        current_route.append(0)\n        routes.append(current_route)\n\n        # Update heuristics matrix based on the route\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1  # Assuming symmetry\n    \n    #Normalize the heuristics matrix to obtain probabilities\n    total_visits = np.sum(heuristics_matrix)\n    if total_visits > 0:\n        heuristics_matrix = heuristics_matrix / total_visits\n\n    return heuristics_matrix",
          "objective": 29.16167,
          "other_inf": null
     }
]