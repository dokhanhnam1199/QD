{
     "algorithm": "This algorithm constructs initial routes using a savings-based approach, then iteratively refines these routes using local search and updates edge frequencies based on the improved solutions.",
     "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs initial routes using a savings-based approach, then iteratively refines these routes using local search and updates edge frequencies based on the improved solutions.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 50\n\n    # Savings calculation\n    savings = np.zeros((n, n), dtype=float)\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings[j, i] = savings[i, j]\n\n    # Initial route construction (Savings based)\n    routes = []\n    unvisited = set(range(1, n))\n    while unvisited:\n        best_saving = -1\n        best_i = -1\n        best_j = -1\n        for i in unvisited:\n            for j in unvisited:\n                if i != j and savings[i, j] > best_saving:\n                    best_saving = savings[i, j]\n                    best_i = i\n                    best_j = j\n\n        if best_i == -1:  # If no savings, create a route from depot to any remaining node\n            node = unvisited.pop()\n            routes.append([0, node, 0])\n            continue\n        \n        route = [0, best_i, best_j, 0]\n        current_load = demands[best_i] + demands[best_j]\n        unvisited.remove(best_i)\n        unvisited.remove(best_j)\n\n        # add more nodes until reaching capacity.\n        while True:\n            best_add_node = -1\n            best_add_saving = -1\n\n            for node in unvisited:\n                if current_load + demands[node] <= capacity:\n\n                    saving_i = savings[best_i, node]\n                    saving_j = savings[best_j, node]\n                    \n                    if saving_i >= saving_j and saving_i > best_add_saving :\n                        best_add_node = node\n                        best_add_saving = saving_i\n                    \n                    elif saving_j > saving_i and saving_j > best_add_saving:\n                        best_add_node = node\n                        best_add_saving = saving_j\n\n\n            if best_add_node != -1:\n                route.insert(len(route)-1,best_add_node)\n                current_load += demands[best_add_node]\n                unvisited.remove(best_add_node)\n                \n                best_j = route[-2] #update best_j\n                best_i = route[1]\n                \n\n            else:\n                routes.append(route)\n                break\n\n    # Iterative Improvement (Local Search - 2-opt within routes)\n    for _ in range(num_iterations):\n        for route in routes:\n            if len(route) <= 3:\n                continue\n            \n            for i in range(1, len(route) - 2):\n                for k in range(i + 1, len(route) - 1):\n                    # 2-opt swap\n                    new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]\n                    \n                    current_cost = 0\n                    for j in range(len(route) - 1):\n                        current_cost += distance_matrix[route[j], route[j+1]]\n                    \n                    new_cost = 0\n                    for j in range(len(new_route) - 1):\n                        new_cost += distance_matrix[new_route[j], new_route[j+1]]\n\n                    if new_cost < current_cost:\n                        route[:] = new_route  # Update route in place\n\n    # Update heuristics matrix\n    for route in routes:\n        for i in range(len(route) - 1):\n            heuristics_matrix[route[i], route[i+1]] += 1\n            heuristics_matrix[route[i+1], route[i]] += 1\n    \n    #Normalize heuristic matrix\n    total_visits = np.sum(heuristics_matrix)\n    if total_visits > 0:\n      heuristics_matrix = heuristics_matrix / total_visits\n    return heuristics_matrix",
     "objective": 13.97251,
     "other_inf": null
}