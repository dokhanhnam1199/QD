{
     "algorithm": "This algorithm estimates edge probabilities by iteratively constructing routes based on a combination of distance and demand considerations, rewarding edges used in feasible routes and penalizing those leading to capacity violations, while also incorporating a diversification strategy to explore different route configurations.",
     "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge probabilities by iteratively constructing routes based on a combination of distance and demand considerations, rewarding edges used in feasible routes and penalizing those leading to capacity violations, while also incorporating a diversification strategy to explore different route configurations.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones((n, n))\n\n    num_samples = 1000\n    penalty_factor = 10\n    reward_factor = 2\n\n    for _ in range(num_samples):\n        current_node = 0\n        route = [0]\n        remaining_nodes = list(range(1, n))\n        vehicle_load = 0\n        current_route = []\n\n        while remaining_nodes:\n            # Select the next node based on a combined metric of distance and demand\n            # Add a small random factor for diversification\n            scores = np.zeros(len(remaining_nodes))\n            for i, node in enumerate(remaining_nodes):\n              scores[i] = distance_matrix[current_node, node] + (demands[node] / capacity) + np.random.rand() * 0.1\n\n            sorted_indices = np.argsort(scores)\n            \n            next_node_found = False\n            for idx in sorted_indices:\n              candidate_node = remaining_nodes[idx]\n              if vehicle_load + demands[candidate_node] <= capacity:\n                next_node = candidate_node\n                next_node_found = True\n                break\n\n            if not next_node_found:\n              # Return to depot if no feasible node found\n              for node in current_route:\n                heuristics_matrix[current_node, 0] -= penalty_factor\n                heuristics_matrix[0, current_node] -= penalty_factor\n                current_node = 0\n              vehicle_load = 0\n              current_route = []\n              continue\n\n            # Update route information\n            route.append(next_node)\n            current_route.append(next_node)\n            vehicle_load += demands[next_node]\n\n            # Update heuristic matrix - reward feasible edges\n            heuristics_matrix[current_node, next_node] += reward_factor\n            heuristics_matrix[next_node, current_node] += reward_factor\n\n            # Remove node from remaining nodes\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        # Return to depot\n        route.append(0)\n        heuristics_matrix[current_node, 0] += reward_factor\n        heuristics_matrix[0, current_node] += reward_factor\n\n    return heuristics_matrix",
     "objective": 11.10452,
     "other_inf": null
}