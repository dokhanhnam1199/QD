[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Large negative priority to bins that can't fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap - item\n    \n    # Give higher priority to bins where the remaining space is smaller (but positive)\n    priorities[bins_remain_cap >= item] = -np.abs(remaining_space[bins_remain_cap >= item])\n    \n    # Boost the priority for almost full bins (reduces fragmentation)\n    almost_full_threshold = 0.1 * np.max(bins_remain_cap)  # e.g., within 10% of the max capacity\n    almost_full = (bins_remain_cap >= item) & (remaining_space <= almost_full_threshold)\n    priorities[almost_full] += 10  # Arbitrary boost value\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Assign very low priority to bins that cannot fit the item.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Extremely low priority\n    \n    # 2. Fill-rate Priority: Prefer bins where the item fills a significant portion.\n    fill_rate = item / bins_remain_cap\n    \n    # 3. Avoidance of near-empty bins\n    near_empty_threshold = 0.2  # Increased threshold\n    near_empty_mask = bins_remain_cap < near_empty_threshold\n    priorities[near_empty_mask] -= 0.6  # Increased discouragement\n\n    # 4. Encourage nearly full bins.\n    near_full_threshold = 0.8  # Adjusted Threshold\n    remaining_after_fit = bins_remain_cap - item\n    near_full_mask = (remaining_after_fit >=0) & (remaining_after_fit < (bins_remain_cap * (1- near_full_threshold)))\n    priorities[near_full_mask] += 0.8 # Increased encouragement\n\n    # Main priority is fill_rate adjusted by penalty/reward mentioned above.\n    priorities[~infeasible_mask] += fill_rate[~infeasible_mask]\n    \n    # 5. Secondary priority: Minimize wasted space (within feasible bins)\n    waste = bins_remain_cap - item\n    waste[infeasible_mask] = np.inf  # Ignore infeasible bins\n    min_waste = np.min(waste)\n\n    #Add a bonus for bins that leave the least waste, but only if there's a feasible bin available\n    if np.any(~infeasible_mask):\n        min_waste_mask = (waste == min_waste) & (~infeasible_mask)\n        priorities[min_waste_mask] += 0.2\n\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 164.51539013493823,
    "mi": 75.16150329268666,
    "token_count": 161.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility: large negative priority to bins that can't fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Reward tight fits: prioritize bins where the remaining space is small (but positive)\n    remaining_space = bins_remain_cap - item\n    \n    # Original: priorities[bins_remain_cap >= item] = -np.abs(remaining_space[bins_remain_cap >= item])\n    # Adjusted to give higher values for smaller remaining spaces.\n    priorities[bins_remain_cap >= item] = 1.0 / (remaining_space[bins_remain_cap >= item] + 1e-6) # Add a small constant to avoid division by zero.\n\n\n    # Fullness: boost priority for almost full bins (reduces fragmentation). Dynamically scaled boost.\n    almost_full_threshold = 0.2 * np.max(bins_remain_cap)  # e.g., within 20% of the max capacity\n    almost_full = (bins_remain_cap >= item) & (remaining_space <= almost_full_threshold)\n    priorities[almost_full] += 5 * (1 - (remaining_space[almost_full] / almost_full_threshold)) # Boost increases as bin becomes fuller\n\n    # Penalize waste/overflow: give a slight penalty for bins with a lot of remaining space after placement\n    large_space_threshold = 0.5 * np.max(bins_remain_cap)\n    large_space = (bins_remain_cap >= item) & (remaining_space > large_space_threshold)\n    priorities[large_space] -= 1  # Small penalty\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 262.3084942066396,
    "mi": 81.11635879794835,
    "token_count": 184.0,
    "exec_success": true
  }
]