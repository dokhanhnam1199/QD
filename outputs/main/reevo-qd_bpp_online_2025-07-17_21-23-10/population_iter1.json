[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit-Decreasing-like heuristic: Prefer bins with enough space.\n    # Also, slightly penalize bins that are almost full after placing the item,\n    # since it might make it hard to pack subsequent smaller items.\n    # Prioritize bins that fit item such that remaining capacity is reasonably high\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            remaining_after_fit = cap - item\n            if remaining_after_fit > 0:\n              priorities[i] = (1 / (remaining_after_fit + 0.1)) # Avoid division by zero. Higher score if remaining is low.\n            else:\n                priorities[i] = 10 # highest priority if remaining is zero\n\n            priorities[i] += 1  # Baseline priority for bins that can accommodate the item\n\n        else:\n            priorities[i] = -1e9  # Very low priority for bins that cannot fit the item\n\n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996517999898 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Large negative priority to bins that can't fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap - item\n    \n    # Give higher priority to bins where the remaining space is smaller (but positive)\n    priorities[bins_remain_cap >= item] = -np.abs(remaining_space[bins_remain_cap >= item])\n    \n    # Boost the priority for almost full bins (reduces fragmentation)\n    almost_full_threshold = 0.1 * np.max(bins_remain_cap)  # e.g., within 10% of the max capacity\n    almost_full = (bins_remain_cap >= item) & (remaining_space <= almost_full_threshold)\n    priorities[almost_full] += 10  # Arbitrary boost value\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Assign a high priority to bins where the item fits and leaves minimal space.\n    # And a low priority if the item does not fit.\n\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            priorities[i] = (cap - item) / cap  # Remaining capacity ratio.  Smaller is better.\n            priorities[i] = 1 - priorities[i] #Invert it so that higher ratio is better\n            # Boost priority for near-perfect fits.\n            if cap - item < 0.1:\n                 priorities[i]+= 0.5 # Boost for near perfect fit\n\n            #priorities[i]+=1.0/cap #bins with smaller cap are ranked higher.\n        else:\n            priorities[i] = -1e9  # Very low priority if item doesn't fit\n\n    return priorities",
    "response_id": 2,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997321000046 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Calculate the waste if the item is placed in this bin\n            waste = cap - item\n\n            # Prioritize bins that can fit the item with minimal waste.\n            # The smaller the waste, the higher the priority.\n            priorities[i] = 1 / (waste + 1e-9)  # Adding a small constant to avoid division by zero.\n\n            # Further prioritize bins that are close to being full *after* the item is added.\n            fullness_after = (cap - item) / 100 if (cap - item) >= 0 else -1\n            if 0 <= fullness_after < 1: #valid fullnes_after\n              priorities[i] += 1 - fullness_after # give bins nearing full a high score\n\n        else:\n            # If the item doesn't fit, assign a very low priority.\n            priorities[i] = -1e9\n\n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999970330001815 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # High priority if the item fits perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000  # A very high value for perfect fit\n    \n    # Give bins that can accommodate the item a base priority.\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1  \n\n    # Prioritize bins with smaller remaining capacity (but large enough to fit the item) to fill them up.\n    # Use an inverse relationship so that smaller remainders have higher priority.\n    # Avoid division by zero by adding a small constant.\n\n    valid_bins = bins_remain_cap[can_fit]\n    if len(valid_bins) > 0:\n        remainder_priority = 10 / (valid_bins + 0.001)\n        priorities[can_fit] += remainder_priority  # Add to existing priority\n\n    # Penalize bins that are too big for the item. This is less desirable than filling smaller bins.\n    too_big = bins_remain_cap > item\n    too_big_penalty = (bins_remain_cap[too_big] - item) / np.max(bins_remain_cap)\n    priorities[too_big] -= too_big_penalty * 5 # Adjust penalty scale\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing heuristic inspiration\n    possible_bins = bins_remain_cap >= item\n    if np.any(possible_bins):\n        priorities[possible_bins] = bins_remain_cap[possible_bins] - item # Favor bins where item fits with least remaining capacity. Maximize fullness.\n\n    # If no bins can accommodate item, assign negative priority\n    priorities[~possible_bins] = -np.inf\n    return priorities",
    "response_id": 5,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining space after adding the item to each bin\n    remaining_space = bins_remain_cap - item\n\n    # Assign high priority to bins where the item fits, but doesn't leave too much space\n    fit_mask = remaining_space >= 0\n    \n    #Prioritize bins where item fits best without wasting space using a fractional power.  Higher power -> stronger 'best fit' preference.\n    priorities[fit_mask] = (bins_remain_cap[fit_mask] - item)**0.5\n    \n    # Add a small bonus for bins that are already somewhat full\n    priorities += (1 - bins_remain_cap / bins_remain_cap.max()) * 0.1 \n\n    # If item does not fit at all, very low priority.\n    priorities[~fit_mask] = -1e9  # assign very low priority\n\n    return priorities",
    "response_id": 6,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility Check: Only consider bins that can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Remaining Capacity: Prioritize bins with less remaining capacity after adding the item\n    remaining_capacity_after_fit = bins_remain_cap - item\n    remaining_capacity_after_fit[remaining_capacity_after_fit < 0] = np.inf # setting infeasible bins to have infinite remaining capacity\n\n    priorities[feasible_bins] = -remaining_capacity_after_fit[feasible_bins] # Lower remaining capacity is better (higher priority)\n    \n    # 3. Avoidance of Fragmentation: Penalize bins where the item fits almost perfectly but leaves a small gap.\n    gap = bins_remain_cap - item\n    small_gap_penalty = -np.exp(-gap[feasible_bins] * 10) # exponential penalty when the gap is very small (0~0.1). You can adjust 10\n    priorities[feasible_bins] += small_gap_penalty\n\n    # 4. Bonus for Perfect Fit: Reward bins where the item perfectly fits (or almost perfectly).\n\n    perfect_fit = np.abs(gap) < 1e-6 #consider small tolerances to account for floating point precision\n\n    priorities[perfect_fit] += 10 #Large priority boost for perfect fit. This will mostly supercede other penalties.\n\n    #Infeasible bins should have lowest priority\n\n    priorities[~feasible_bins] = -np.inf\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing heuristic adaptation: Prioritize bins that can accommodate the item\n    # Penalize bins that cannot.\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] = 1.0  # Base priority for bins that can fit\n    priorities[~can_fit] = -1000.0  # Very low priority for bins that can't fit\n\n    # Among the bins that can fit, prioritize those where the remaining space after placing the item is minimized\n    remaining_space = bins_remain_cap - item\n    remaining_space[~can_fit] = np.inf  # Set to infinity for bins that can't fit\n\n    priorities[can_fit] += 1.0 / (1e-6 + remaining_space[can_fit]) # Add priority based on remaining space\n\n    # Prioritize bins that are fuller relative to their original capacity\n    original_capacity = bins_remain_cap + 1e-9 # add tiny amount to avoid zero division error\n    priorities += bins_remain_cap / original_capacity\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Feasibility: Can the item fit in the bin?\n    feasible = bins_remain_cap >= item\n    \n    # If no bins are feasible, return a low priority for all bins (making this placement very undesirable).\n    if not np.any(feasible):\n        return priorities - 1e9 # Very low priority\n    \n    # Calculate the remaining capacity after placing the item in feasible bins\n    remaining_capacity = bins_remain_cap - item\n    \n    # Prioritize bins that will have minimal remaining capacity after placement (First Fit Decreasing heuristic inspired)\n    priorities[feasible] = 1 / (remaining_capacity[feasible] + 1e-6)  # Avoid division by zero.  Smaller remaining capacity means higher priority\n    \n    #Prioritize bins with largest capacity closer to item size:\n    diffs = np.abs(bins_remain_cap - item)\n    priorities[feasible] += (1 / (diffs[feasible] + 1e-6)) # Closer to item size = higher priority\n\n    # Penalize bins with very large remaining capacity (avoid creating near-empty bins)\n    priorities[feasible] -= (bins_remain_cap[feasible] / np.max(bins_remain_cap[feasible] + 1e-6)) * 0.1\n\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First-Fit Decreasing inspired heuristic: prioritize bins that can accommodate the item\n    # and have the least remaining capacity after fitting the item.\n    possible_bins = bins_remain_cap >= item\n    if np.any(possible_bins):\n        remaining_space = bins_remain_cap[possible_bins] - item\n        priorities[possible_bins] = 1 / (remaining_space + 0.0001) # Avoid division by zero and prioritize smaller remaining space\n    else:\n        # If no bin can accommodate the item, give all bins equal (low) priority\n        priorities = np.ones_like(bins_remain_cap) * 0.00001\n\n    return priorities",
    "response_id": 10,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing-like heuristic: Prioritize bins that can fit the item well, but not too well.\n    # Penalize bins that are either too full or too empty after placing the item.\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            remaining_space = cap - item\n            # Give a higher priority to bins where the remaining space is small relative to item but not zero.\n            # Avoid bins that lead to significant wastage.\n            if remaining_space > 0:\n                priorities[i] = item / remaining_space if remaining_space <= item else (item / remaining_space) * 0.5 # Scale down the score if remaining space is bigger than item to encourage use other bins first.\n            else:\n                 priorities[i] = 2 # Significantly increase priority if it is an exact fit.\n\n        else:\n            priorities[i] = -1000. # A very low priority if the item doesn't fit.\n\n    return priorities",
    "response_id": 11,
    "obj": 4.876346230554457,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: If the item fits perfectly, highest priority.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000  # A very high priority\n\n    # Rule 2: If item does not fit, lowest priority (or 0).\n    does_not_fit = item > bins_remain_cap\n    priorities[does_not_fit] = -100 # Or a very low negative value, effectively avoiding\n\n    # Rule 3: For bins that the item *can* fit into, prioritize based on remaining space after packing\n    fits = (item <= bins_remain_cap) & (~perfect_fit)\n    remaining_space = bins_remain_cap[fits] - item\n    \n    # Prioritize bins with smaller remaining space (First Fit Decreasing style). Avoid leaving too much space.\n    priorities[fits] = 1 / (remaining_space + 0.00001) # adding small number to avoid divide by zero\n\n    # Rule 4: Also prioritize bins which are near full after addition, as a secondary optimization. This helps consolidate usage.\n    near_full_after_add = (bins_remain_cap - item) > 0 # only for bins where item fits. \n    near_full_threshold = 0.1 # can be experimented. Defines near full as remaining capacity < 10% of original size\n    priorities[near_full_after_add & ((bins_remain_cap - item) / bins_remain_cap < near_full_threshold)] += 50 #Adding some priority weight\n\n    return priorities",
    "response_id": 12,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Feasibility is a major factor\n            remaining_after_fit = cap - item\n            \n            # Prioritize bins with tighter fit\n            priority = (cap - item) / item  #Smaller remain capacity, higher priority after divided by item\n            priority = 1/(priority + 0.000001) # avoid divide by 0 and make priority decrease when remaining capacity increase\n            \n            if remaining_after_fit <= 0.1: # If fit is very tight\n                priority *= 2  #give it higher priority\n                \n            priorities[i] = priority\n        else:\n            # Impossible to fit\n            priorities[i] = -1e9  #Very low priority.\n\n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a high priority to bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1\n\n    # Prioritize bins with smallest remaining capacity that can fit the item,\n    # minimizing wasted space (First-Fit Decreasing heuristic idea)\n    \n    valid_capacities = bins_remain_cap[can_fit]\n    if valid_capacities.size > 0:\n      priorities[can_fit] += (1 / (valid_capacities + 0.00001)) # Avoid div by 0\n\n    # Penalize bins where the item would almost fill the bin, potentially\n    # making future items difficult to place\n    almost_full = (bins_remain_cap - item) < (0.1 * bins_remain_cap) #Almost full if remaining cap after putting the item is less than 10%\n    priorities[almost_full & can_fit] -= 0.5\n    \n    # If no bin can fit, assign low priority for all\n    if not np.any(can_fit):\n      priorities[:] = -100 #Very low score\n\n    return priorities",
    "response_id": 14,
    "obj": 8.067411248504197,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: prioritize bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] += 1\n\n    # 2. Remaining Capacity: prioritize bins with less remaining capacity after placing the item\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[~feasible_bins] = np.inf  # Set to infinity for infeasible bins\n\n    priorities[feasible_bins] += (np.max(remaining_capacity_after_placement[feasible_bins]) - remaining_capacity_after_placement[feasible_bins]) \n\n    #3. Avoidance of fragmentation: give highest priority to bin whose remainig capcity is exactly equal to item size\n    exact_fit = np.abs(bins_remain_cap - item) < 1e-6\n    priorities[exact_fit] += 2\n\n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate remaining capacity after adding the item to each bin.\n    remaining_after_add = bins_remain_cap - item\n    \n    # Give high priority to bins that can fit the item.\n    fit_mask = remaining_after_add >= 0\n    priorities[fit_mask] = 1  # Base priority for fitting\n\n    # Further prioritize bins that result in a small remaining capacity\n    # after adding the item.  This encourages \"almost full\" bins.  We only\n    # consider bins that fit the item here.\n    if np.any(fit_mask):  # check if there is at least one bin that fits\n        priorities[fit_mask] += (bins_remain_cap[fit_mask] - remaining_after_add[fit_mask]) / bins_remain_cap[fit_mask]\n    \n    # Negative priority for bins that cannot fit (discourage putting it there).\n    # This ensures that valid bins are always preferred over invalid ones, and makes \n    # the search focused.\n    priorities[~fit_mask] = -10  # arbitrarily large penalty to discard bins which cannot accommodate\n\n    return priorities",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Assign very low priority to bins that cannot fit the item.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Extremely low priority\n    \n    # 2. Fill-rate Priority: Prefer bins where the item fills a significant portion.\n    fill_rate = item / bins_remain_cap\n    \n    # 3. Avoidance of near-empty bins\n    near_empty_threshold = 0.1\n    near_empty_mask = bins_remain_cap < near_empty_threshold\n    priorities[near_empty_mask] -= 0.5 # Slightly discourage nearly empty bins to increase packing density later.\n\n    # 4. Encourage nearly full bins.\n    near_full_threshold = 0.9\n    near_full_mask = (bins_remain_cap - item) < (bins_remain_cap * (1- near_full_threshold))\n    priorities[near_full_mask] += 0.7\n\n    # Main priority is fill_rate adjusted by penalty/reward mentioned above.\n    priorities[~infeasible_mask] += fill_rate[~infeasible_mask]\n    \n    \n    return priorities",
    "response_id": 17,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First Fit Decreasing variant: Prioritize bins that can fit the item with least wasted space.\n    # Give a high priority to bins that fit and the spare space is low.\n    # If bin cannot fit, then give it a very low priority.\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = (cap - item) / cap # lower waste, higher priority\n        else:\n            priorities[i] = -1e9 # very low priority, making it virtually impossible to select.\n\n    return priorities",
    "response_id": 18,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = (cap - item) / (cap + item)  # Favor bins where the remaining capacity after adding the item is small relative to total occupied space\n        else:\n            priorities[i] = -1000 # Large negative number if item doesn't fit, effectively ruling out the bin\n    return priorities",
    "response_id": 19,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Give -inf priority if the item doesn't fit.\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # 2. Best Fit Criterion: Maximize remaining capacity after placement, but only if it fits\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):  # At least one feasible bin\n        remaining_cap_after_placement = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] = bins_remain_cap[feasible_bins] # original bin capacity\n\n        # Prefer bins with smallest remaining capacity, using inverse for priority\n        priorities[feasible_bins] = bins_remain_cap[feasible_bins] - 10*remaining_cap_after_placement \n\n    return priorities",
    "response_id": 20,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Primary criterion: fit the item\n            remaining_after_fit = cap - item\n            # Prioritize bins that fit the item well,\n            # but also avoid bins that will become nearly full (waste)\n            # The closer to the mean occupancy after fit, the better.\n            priorities[i] = 1.0 / (abs(remaining_after_fit - (np.sum(bins_remain_cap) - item) / bins_remain_cap.size) + 0.0001)\n\n            # Additional consideration: Favour bins with smaller remaining capacity IF the remaining capacity is enough for item, to fill the bin quickly.\n\n            priorities[i] += (1 / (cap + 0.0001)) * 0.1 # Weight = 0.1\n\n        else:\n            # If item doesn't fit, give very low priority (but not zero to avoid zero division if used to create probability distribution downstream).\n            priorities[i] = -1000 # Arbitrarily very low\n    return priorities",
    "response_id": 21,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997663999966 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins that can fit the item snugly\n    fit_threshold = 0.95  # e.g., bin should be at least 95% full after placing item\n    snug_fit = (bins_remain_cap - item) / bins_remain_cap > fit_threshold\n    priorities[snug_fit] += 10.0  # Significant bonus\n\n    # Prioritize bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 5.0\n\n    # Penalize bins where the item would leave too little space.\n    min_remaining = 0.1\n    too_little_space = (bins_remain_cap - item) < min_remaining\n    priorities[too_little_space] -= 2.0\n\n    # Adjust priority based on remaining capacity (normalized)\n    normalized_capacity = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n    priorities += normalized_capacity  # Give preference to bins with high remaining capacity\n    # Normalize priorities to a reasonable range.\n    priorities = np.clip(priorities, -10.0, 10.0)\n\n    return priorities",
    "response_id": 22,
    "obj": 149.10251296370166,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First-Fit Decreasing heuristic inspired priority.\n    # Prefer bins where item fits reasonably well, but not perfectly (to avoid fragmentation if possible).\n    \n    # Give very low priority to bins that are too small\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate the waste if the item is placed in the bin\n    waste = bins_remain_cap - item\n    \n    # Prefer bins where the waste is small relative to the bin size\n    # But avoid bins where the waste is exactly 0.\n    \n    #A very small constant to avoid 0 division.\n    epsilon = 1e-9 \n\n    waste_ratio = waste / (bins_remain_cap + epsilon)\n\n    # A penalty factor, can be tuned\n    penalty_factor = 1.0  # Adjust as needed\n\n    priorities[bins_remain_cap >= item] = np.exp(-penalty_factor * waste_ratio[bins_remain_cap >= item])\n\n    #Reduce priority as the item becomes smaller and the bin gets fuller\n    #relative_item_size = item/(np.mean(bins_remain_cap)+epsilon)\n\n    #priorities = priorities-relative_item_size\n    \n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Very high priority for bins that can fit the item snugly (First-Fit Decreasing heuristic inspired)\n    fit_within = (bins_remain_cap >= item)\n    \n    #Prioritize bins that have little remaining capacity if item fits\n    snug_fit = np.where(fit_within, bins_remain_cap - item, np.inf)\n    \n    priorities[fit_within] = 1 / (1e-6 + snug_fit[fit_within])  # Avoid division by zero\n\n    #Otherwise give a negative priority score which diminishes if the bins are too small (worst-fit inspired)\n    priorities[~fit_within] = -np.abs(bins_remain_cap[~fit_within] - item)\n\n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = cap - item\n            # Prioritize bins where the item fits and minimize waste\n            priorities[i] = (cap - item)**2 / cap # Lower waste and higher cap gives larger priority.\n            # Consider bins with larger remaining capacity a little\n            # Penalize bins that are too full or will become too full\n            # This tries to make things fit well.  Experiment!\n            # Consider waste ratios? Try to balance\n            # Scale by a small factor? Prevents runaway priority?\n        else:\n            # Bin is invalid\n            priorities[i] = -1e9  # Very low priority to discourage use\n    return priorities",
    "response_id": 25,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate remaining capacity after adding the item to each bin\n    remaining_capacities = bins_remain_cap - item\n    \n    # Prioritize bins where the item fits\n    fit_indices = remaining_capacities >= 0\n    \n    if np.any(fit_indices):\n        # Prioritize bins that leave the least space after adding the item\n        priorities[fit_indices] = bins_remain_cap[fit_indices] - item #smaller remaining space => higher priority\n        \n        # Further refine the priorities for bins that fit\n        \n        # Option 1: Prioritize almost full bins (before adding the item)\n        # priorities[fit_indices] += bins_remain_cap[fit_indices] # favors bins with smaller capacity.\n\n        #Option 2: Avoid fragmentation - Prefer filling bins that are close to half-full, but only if it doesn't lead to overfilling\n        #half_full_distance = np.abs(bins_remain_cap[fit_indices] - bins_remain_cap.max()/2 ) #assumes equal bin capacities\n        #priorities[fit_indices] = np.exp(-half_full_distance/ bins_remain_cap.max() )\n        \n        \n        # Normalize priorities to avoid overflow and underflow\n        priorities[fit_indices] = priorities[fit_indices] / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n    else:\n        #If no bin can fit the item, penalize all bins\n        priorities = -np.ones_like(bins_remain_cap) * 1000 # set a very negative priority for all bins\n    \n    return priorities",
    "response_id": 26,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: Highest priority to bins where the item fits best (smallest waste).\n    waste = bins_remain_cap - item\n    fit_indices = waste >= 0\n    \n    if np.any(fit_indices):\n        priorities[fit_indices] = 1 / (waste[fit_indices] + 1e-9)  # Avoid division by zero\n    else:\n        # If item doesn't fit in any bin, give low priority to bins with most space\n        priorities = bins_remain_cap / np.sum(bins_remain_cap)\n        priorities = 1 / (priorities + 1e-9) #Invert this ratio, give priority to bins with the largest waste.\n        return priorities\n    \n    # Rule 2: Give a bonus to bins that are already somewhat full (reduce fragmentation).\n    occupancy = 1 - (bins_remain_cap / np.max(bins_remain_cap)) # Calculate occupancy ratio\n    priorities += occupancy * 0.1 #Add a small fraction of occupancy\n    \n    return priorities",
    "response_id": 27,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Large negative priority for bins that can't fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Higher priority to bins that can fit the item closely (minimize wasted space)\n    remaining_space_after_packing = bins_remain_cap - item\n    \n    # Prioritize bins where remaining_space_after_packing is small, but not negative\n    valid_bins = remaining_space_after_packing >= 0\n    priorities[valid_bins] = -remaining_space_after_packing[valid_bins]\n    \n    # Boost the priority of bins that are almost full (reduces number of bins used)\n    almost_full_threshold = 0.2  # Parameter to tune\n    almost_full = (bins_remain_cap > 0) & (bins_remain_cap <= almost_full_threshold)\n    priorities[almost_full] += 10 # Arbitrary boost value (tune)\n\n    # Optional: slight bonus to bins that were previously empty (encourage re-use)\n    # This requires tracking bin usage history, which isn't part of input.\n    # So, this is ommited\n    \n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Assign -inf priority to bins that cannot fit the item.\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # 2. Remaining capacity: Prioritize bins with enough space for the item but small remaining capacity\n    #    to try and fill them up.  Use a non-linear function to emphasize almost-full bins.\n    feasible_bins = bins_remain_cap >= item\n    remaining_space = bins_remain_cap[feasible_bins] - item\n    # Avoid taking log of 0 or negative numbers. Add a small epsilon to make it positive\n    epsilon = 1e-9\n    priorities[feasible_bins] = -np.log(remaining_space + epsilon)\n\n    # 3. Bonus for bins that fit *relatively* well (avoiding huge gaps). Scale this by total capacity for comparability between bin sizes\n    # relative fit to the current remaining size\n    relative_fit = item / bins_remain_cap[feasible_bins]\n    # using the square to favor values closer to 1 without being a hard constraint.\n    bonus = np.clip(relative_fit**2, 0, 1)  # Clip the bonus value between 0 and 1\n    priorities[feasible_bins] += bonus\n\n    # 4. A small, general prioritization to use near empty bins\n    priorities += (bins_remain_cap / np.max(bins_remain_cap)) *0.1\n\n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 157.89111045234063,
    "mi": 80.08179394022078,
    "token_count": 154.0,
    "exec_success": true
  }
]