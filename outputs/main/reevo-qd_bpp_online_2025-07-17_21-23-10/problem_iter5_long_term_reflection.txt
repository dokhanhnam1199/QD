Prioritize feasibility and fullness. Heavily penalize infeasibility and waste. Reward tight fits and near-full bins. Dynamically scale penalties and exploit "almost full" domain knowledge. Avoid creating near-empty bins.

