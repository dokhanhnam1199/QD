```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Rule 1: Perfect fit - highest priority
    perfect_fit = np.isclose(bins_remain_cap, item)
    priorities[perfect_fit] = 1000

    # Rule 2: Item doesn't fit - lowest priority
    does_not_fit = item > bins_remain_cap
    priorities[does_not_fit] = -100

    # Rule 3: Item fits, prioritize based on remaining space (minimize fragmentation)
    fits = (item <= bins_remain_cap) & (~perfect_fit)
    remaining_space = bins_remain_cap[fits] - item
    priorities[fits] = 1 / (remaining_space + 0.00001)

    # Rule 4: Prioritize bins that become near-full after adding the item (maximize density)
    near_full_threshold = 0.1
    near_full_after_add = fits & ((bins_remain_cap - item) / np.max(bins_remain_cap) < near_full_threshold)  # Normalize by max bin size
    priorities[near_full_after_add] += 50

    # Rule 5: Prefer bins that are already relatively full (avoid spreading items thinly)
    already_full_threshold = 0.7 # Tune this
    already_full = fits & (bins_remain_cap / np.max(bins_remain_cap) < (1 - already_full_threshold)) #Normalize by max bin size
    priorities[already_full] += 25

    return priorities
```
