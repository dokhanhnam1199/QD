[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit-like strategy.\n\n    This strategy aims to leave the smallest possible remaining capacity in a bin after placing the item,\n    thereby 'snugly' fitting items and preserving larger empty spaces in other bins for future larger items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a priority score of 0.\n        For bins that can fit, a higher score indicates a 'tighter' fit (smaller remaining capacity).\n    \"\"\"\n    # Calculate the remaining capacity if the item were to be placed in each bin.\n    # This value indicates how much space would be left after placing the item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priority scores. Default to 0, meaning no priority or cannot fit.\n    priority_scores = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit (remaining space must be non-negative).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins that can fit the item, we want to assign a priority.\n    # In a Best Fit strategy, we prefer bins that leave the *smallest* amount of space remaining.\n    # To translate \"smallest remaining space\" into \"highest priority score\", we use the inverse.\n    # A small epsilon is added to the denominator to prevent division by zero if an item\n    # perfectly fills a bin (potential_remaining_space = 0). It also slightly biases\n    # exact fits to have a finite, very large score.\n    epsilon = 1e-9 # A small positive value to handle exact fits (0 remaining space)\n\n    # Apply the inverse calculation only to the bins where the item fits.\n    # This assigns a high score to bins where the item fits snugly (potential_remaining_space is small).\n    # For example, if potential_remaining_space is 0.1, score is ~10. If it's 0.01, score is ~100.\n    priority_scores[can_fit_mask] = 1.0 / (potential_remaining_space[can_fit_mask] + epsilon)\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit heuristic with a refined emphasis on minimizing\n    remaining capacity, especially for near-perfect fits.\n\n    This strategy aims to minimize the remaining capacity after placing an item\n    (Best Fit principle), but gives an even stronger preference to bins that result\n    in a very small, almost unusable, positive remaining capacity. This encourages\n    'filling up' bins as much as possible, beyond just finding the tightest fit,\n    to reduce overall fragmentation and improve packing density. Perfect fits\n    (0 remaining capacity) remain the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Initialize all priorities to a very low negative number (effectively -infinity)\n    # for bins that cannot accommodate the item.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity after fit for eligible bins\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Define a threshold for what constitutes a \"near-perfect\" fit.\n    # This threshold assumes items and bin capacities are normalized, e.g., to 1.0.\n    # A remaining capacity <= 0.05 (e.g., 5% of a standard bin) is considered near-perfect.\n    near_perfect_threshold = 0.05 \n\n    # Apply a non-linear penalty for remaining capacity.\n    # If remaining_after_fit is within (0, near_perfect_threshold],\n    # the penalty is reduced, making the score less negative (higher priority).\n    # The reduction factor (r / threshold) makes smaller 'r' values result in\n    # even less penalty, smoothly transitioning to 0 for a perfect fit (r=0)\n    # and to standard penalty at the threshold.\n    scaled_remaining = np.where(\n        (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_threshold),\n        remaining_after_fit * (remaining_after_fit / near_perfect_threshold),\n        remaining_after_fit\n    )\n    \n    # If remaining_after_fit is exactly 0, scaled_remaining will be 0, and score will be 0.\n    # Otherwise, the score is the negative of the scaled remaining capacity.\n    scores[can_fit_mask] = -scaled_remaining\n\n    return scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\n# For the purpose of this mutation, we will assume a default BIN_CAPACITY of 1.0.\n# This is a common practice in normalized Bin Packing Problem contexts where\n# item sizes and capacities are scaled between 0 and 1. If your problem\n# uses different absolute capacities (e.g., 100, 500), this constant\n# should ideally be passed as an argument or configured externally.\nBIN_CAPACITY_ASSUMED = 1.0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    using a strategy that combines Best Fit with a preference for filling\n    already-started bins, aiming to optimize overall bin utilization.\n\n    This strategy extends the 'tightest fit' idea from priority_v1 by adding\n    a component that favors bins that are already partially filled. This encourages\n    'completing' existing bins before using empty ones, promoting a more compact\n    overall packing solution.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n                         (Assumed to be relative to a BIN_CAPACITY of 1.0 for\n                         calculating the current fill level.)\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a priority score of 0.\n        For bins that can fit, a higher score indicates a 'tighter' fit,\n        potentially boosted by the bin's current (pre-placement) fill level.\n    \"\"\"\n    # Calculate the remaining capacity if the item were to be placed in each bin.\n    # This indicates how much space would be left after placing the item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priority scores. Default to 0, meaning no priority or cannot fit.\n    priority_scores = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit\n    # (remaining space must be non-negative).\n    can_fit_mask = potential_remaining_space >= 0\n\n    epsilon = 1e-9 # A small positive value to handle exact fits (0 remaining space)\n\n    # --- Component 1: Best Fit (Tightness) ---\n    # This component provides the core 'tightest fit' preference. It assigns a very high\n    # score for bins where the item fits snugly (potential_remaining_space is small),\n    # strongly prioritizing exact or near-exact fits.\n    best_fit_component = np.zeros_like(bins_remain_cap, dtype=float)\n    best_fit_component[can_fit_mask] = 1.0 / (potential_remaining_space[can_fit_mask] + epsilon)\n\n    # --- Component 2: Current Bin Fill Level (Utilization Bias) ---\n    # This component aims to 'optimize overall bin utilization' by giving a slight\n    # preference to bins that are already partially filled (i.e., not empty).\n    # It is calculated as the proportion of the bin's total capacity that is currently\n    # occupied. For an empty bin (bins_remain_cap = BIN_CAPACITY_ASSUMED), this is 0.\n    # For a half-full bin, it's 0.5. For a nearly full bin, it's close to 1.0.\n    # This encourages continuing to fill existing bins before starting new ones,\n    # leading to fewer partially used bins.\n    current_fill_component = np.zeros_like(bins_remain_cap, dtype=float)\n    current_fill_component[can_fit_mask] = (BIN_CAPACITY_ASSUMED - bins_remain_cap[can_fit_mask]) / BIN_CAPACITY_ASSUMED\n\n    # --- Combine Components ---\n    # The total priority score is the sum of the Best Fit component and the current fill component.\n    # The Best Fit component typically provides a much larger value for very tight fits,\n    # ensuring that tightness remains the primary criterion.\n    # The current fill component acts as a tie-breaker or a slight boost,\n    # giving precedence to already-in-use bins when tightness is similar.\n    priority_scores[can_fit_mask] = best_fit_component[can_fit_mask] + current_fill_component[can_fit_mask]\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing an enhanced Best Fit heuristic with a significantly stronger\n    emphasis on minimizing remaining capacity, particularly for near-perfect fits,\n    to aggressively reduce fragmentation.\n\n    This strategy extends the Best Fit principle by applying a more pronounced\n    non-linear penalty reduction for bins that result in a very small positive\n    remaining capacity. Perfect fits (0 remaining capacity) retain the highest\n    priority (score 0). For remaining capacities within a defined 'near-perfect'\n    threshold, the penalty is drastically reduced using a higher-order polynomial\n    decay (e.g., cubic), making these bins highly desirable. For capacities above\n    the threshold, a standard linear Best Fit penalty is applied. This aims to\n    'trap' items efficiently and prevent the creation of many sparsely filled bins,\n    thereby reducing overall fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Initialize all priorities to a very low negative number (effectively -infinity)\n    # for bins that cannot accommodate the item.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity after fit for eligible bins\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Define a threshold for what constitutes a \"near-perfect\" fit.\n    # This threshold assumes items and bin capacities are normalized, e.g., to 1.0.\n    # A remaining capacity <= 0.05 (e.g., 5% of a standard bin) is considered near-perfect.\n    # This value might need tuning based on typical item sizes in a specific problem context.\n    near_perfect_threshold = 0.05\n\n    # Power factor for the non-linear scaling.\n    # A higher power_factor provides a more aggressive incentive for very small\n    # remaining capacities.\n    # k=2 for priority_v1 (quadratic scaling: r^2/T).\n    # k=3 for this improved version (cubic scaling: r^3/T^2).\n    # This makes the penalty for small 'r' values even smaller (closer to 0),\n    # thus making such bins significantly more attractive.\n    power_factor = 3\n    \n    # Apply a non-linear penalty for remaining capacity.\n    # If remaining_after_fit is within (0, near_perfect_threshold],\n    # the penalty is reduced significantly using a cubic function.\n    # The formula (r^k / T^(k-1)) ensures continuity at T (r=T gives T)\n    # and makes smaller 'r' values result in much less penalty (closer to 0).\n    scaled_remaining = np.where(\n        (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_threshold),\n        (remaining_after_fit ** power_factor) / (near_perfect_threshold ** (power_factor - 1)),\n        remaining_after_fit  # Standard linear penalty for remaining > threshold\n    )\n    \n    # If remaining_after_fit is exactly 0, scaled_remaining will be 0, and score will be 0,\n    # making perfect fits the highest priority.\n    # Otherwise, the score is the negative of the scaled remaining capacity.\n    scores[can_fit_mask] = -scaled_remaining\n\n    return scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\n# For the purpose of this mutation, we will assume a default BIN_CAPACITY of 1.0.\n# This is a common practice in normalized Bin Packing Problem contexts where\n# item sizes and capacities are scaled between 0 and 1. If your problem\n# uses different absolute capacities (e.g., 100, 500), this constant\n# should ideally be passed as an argument or configured externally.\nBIN_CAPACITY_ASSUMED = 1.0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    using a strategy that strongly prioritizes Best Fit (maximizing the final\n    fill level of a bin) and secondarily prefers bins that are already\n    partially filled. This aims to improve overall bin utilization and reduce\n    the total number of bins used, aligning with the reflection.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n                         (Assumed to be relative to a BIN_CAPACITY of 1.0 for\n                         calculating the current fill level.)\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a priority score of 0.\n        For bins that can fit, a higher score indicates a combination of\n        tighter fit after placement and a preference for already-started bins.\n    \"\"\"\n    # Initialize priority scores. Default to 0, meaning no priority or cannot fit.\n    priority_scores = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bins can fit, return all zeros as no bin has a valid priority\n    if not np.any(can_fit_mask):\n        return priority_scores\n\n    # Filter capacities for bins that can fit the item\n    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # --- Component 1: Best Fit (Future Fill Level) ---\n    # This component measures how full the bin would be *after* placing the item.\n    # Maximizing this value directly corresponds to choosing the bin that leaves the least\n    # remaining capacity (Best Fit). It's calculated as the proportion of the bin\n    # that would be occupied after the item is placed. Values range from item/BIN_CAPACITY to 1.0.\n    new_potential_fill_level = (BIN_CAPACITY_ASSUMED - (eligible_bins_remain_cap - item)) / BIN_CAPACITY_ASSUMED\n\n    # --- Component 2: Current Bin Fill Level (Utilization Bias) ---\n    # This component measures how full the bin *currently* is, before the new item is placed.\n    # Prioritizing already-filled bins encourages 'completing' existing bins before\n    # opening new ones, which helps reduce the total number of bins used.\n    # Values range from 0.0 (empty) to 1.0 (full).\n    current_fill_level = (BIN_CAPACITY_ASSUMED - eligible_bins_remain_cap) / BIN_CAPACITY_ASSUMED\n\n    # --- Combine Components ---\n    # The total priority score is a weighted sum of the two components.\n    # The 'new_potential_fill_level' (Best Fit) component is given a higher weight\n    # to ensure it serves as the primary criterion. This means that a bin offering\n    # a significantly tighter fit will generally be preferred.\n    # The 'current_fill_level' component acts as a strong secondary criterion or tie-breaker,\n    # boosting the priority of already-in-use bins when the tightness of fit\n    # among candidates is similar.\n    #\n    # A multiplier (e.g., 2.0) ensures that a small difference in the primary\n    # best-fit component can outweigh the entire range of the secondary fill component.\n    BEST_FIT_WEIGHT = 2.0\n    CURRENT_FILL_WEIGHT = 1.0\n\n    priority_scores[can_fit_mask] = (\n        BEST_FIT_WEIGHT * new_potential_fill_level +\n        CURRENT_FILL_WEIGHT * current_fill_level\n    )\n\n    return priority_scores",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing an even more aggressively enhanced Best Fit heuristic\n    compared to priority_v1, focusing on even stronger non-linear rewards\n    for near-perfect fits to minimize fragmentation.\n\n    This version amplifies the Best Fit principle by applying a more\n    pronounced non-linear penalty reduction for bins that result in a\n    very small positive remaining capacity. Perfect fits (0 remaining\n    capacity) retain the highest priority (score 0). For remaining capacities\n    within a defined 'near-perfect' threshold, the penalty is drastically\n    reduced using a higher-order polynomial decay (e.g., quartic), making\n    these bins even more highly desirable. For capacities above the threshold,\n    a standard linear Best Fit penalty is applied. This aims to further\n    'trap' items efficiently and prevent the creation of many sparsely\n    filled bins, thereby reducing overall fragmentation and improving\n    packing density.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Initialize all priorities to a very low negative number (effectively -infinity)\n    # for bins that cannot accommodate the item.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity after fit for eligible bins\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Define a threshold for what constitutes a \"near-perfect\" fit.\n    # This threshold assumes items and bin capacities are normalized, e.g., to 1.0.\n    # A remaining capacity <= 0.05 (e.g., 5% of a standard bin) is considered near-perfect.\n    # This value might need tuning based on typical item sizes in a specific problem context.\n    near_perfect_threshold = 0.05\n\n    # Power factor for the non-linear scaling.\n    # A higher power_factor provides an even more aggressive incentive for very small\n    # remaining capacities.\n    # priority_v1 used power_factor = 3 (cubic).\n    # This version uses power_factor = 4 (quartic) for an even stronger emphasis.\n    power_factor = 4 \n    \n    # Apply a non-linear penalty for remaining capacity.\n    # If remaining_after_fit is within (0, near_perfect_threshold],\n    # the penalty is reduced significantly using a quartic function.\n    # The formula (r^k / T^(k-1)) ensures continuity at T (r=T gives T)\n    # and makes smaller 'r' values result in much less penalty (closer to 0).\n    scaled_remaining = np.where(\n        (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_threshold),\n        (remaining_after_fit ** power_factor) / (near_perfect_threshold ** (power_factor - 1)),\n        remaining_after_fit  # Standard linear penalty for remaining > threshold\n    )\n    \n    # If remaining_after_fit is exactly 0, scaled_remaining will be 0, and score will be 0,\n    # making perfect fits the highest priority.\n    # Otherwise, the score is the negative of the scaled remaining capacity.\n    scores[can_fit_mask] = -scaled_remaining\n\n    return scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit heuristic with distinct priority tiers for\n    perfect fits, near-perfect fits, and general best fits.\n\n    This strategy explicitly assigns the highest priority to bins that result\n    in a perfect fit (remaining capacity of 0). It then gives a significant\n    bonus to 'near-perfect' fits (where the remaining capacity is very small\n    but positive), ensuring these are preferred over general best fits.\n    For all other valid fits, it reverts to the standard Best Fit principle,\n    prioritizing the bin that leaves the smallest positive remaining capacity.\n    This aims to minimize overall fragmentation and improve packing density\n    by strongly encouraging the complete or almost complete filling of bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Calculate potential remaining capacity if the item were placed in each bin\n    potential_remaining = bins_remain_cap - item\n\n    # Initialize scores for all bins to a base value.\n    # Bins that cannot fit the item will eventually get -np.inf.\n    scores = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Define thresholds and constants for scoring tiers\n    # These values define the distinct priority levels.\n    PERFECT_FIT_SCORE = 1000.0  # Score for a perfect fit (remaining == 0)\n    NEAR_PERFECT_BONUS_MAGNITUDE = 100.0  # Maximum bonus for a near-perfect fit (as remaining approaches 0)\n    # Threshold for what constitutes a \"near-perfect\" fit.\n    # Assuming capacities are normalized, e.g., to 1.0, 0.05 means 5% of bin capacity.\n    near_perfect_threshold = 0.05\n\n    # --- Apply scoring logic based on potential_remaining for bins that can fit ---\n\n    # 1. Perfect Fit: If potential_remaining is exactly 0\n    perfect_fit_mask = potential_remaining == 0\n    scores[perfect_fit_mask] = PERFECT_FIT_SCORE\n\n    # 2. Near-Perfect Fit: If 0 < potential_remaining <= near_perfect_threshold\n    near_perfect_mask = (potential_remaining > 0) & (potential_remaining <= near_perfect_threshold)\n    if np.any(near_perfect_mask):\n        # Calculate a bonus that scales linearly from NEAR_PERFECT_BONUS_MAGNITUDE (for remaining close to 0)\n        # down to 0 (for remaining at the threshold).\n        # This bonus is added to the standard Best Fit score (-potential_remaining).\n        scaled_bonus = NEAR_PERFECT_BONUS_MAGNITUDE * (1 - potential_remaining[near_perfect_mask] / near_perfect_threshold)\n        scores[near_perfect_mask] = scaled_bonus - potential_remaining[near_perfect_mask]\n\n    # 3. Standard Best Fit: If potential_remaining > near_perfect_threshold\n    standard_bf_mask = potential_remaining > near_perfect_threshold\n    scores[standard_bf_mask] = -potential_remaining[standard_bf_mask] # Maximize score by minimizing remaining\n\n    # Finally, for any bin where the item simply cannot fit (potential_remaining < 0 or bins_remain_cap < item),\n    # assign a very low (negative infinity) score to ensure they are never chosen.\n    cannot_fit_mask = bins_remain_cap < item\n    scores[cannot_fit_mask] = -np.inf\n\n    return scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using an enhanced Best Fit strategy.\n\n    This strategy aims to strongly prioritize near-perfect fits to minimize fragmentation and maximize\n    the utilization of existing bins. It uses a non-linear reward function to aggressively\n    favor bins that result in very small remaining capacity after placing the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a priority score of 0.\n        For bins that can fit, a higher score indicates a 'tighter' fit (smaller remaining capacity),\n        with a strong emphasis on very tight fits.\n    \"\"\"\n    # Calculate the remaining capacity if the item were to be placed in each bin.\n    # This value indicates how much space would be left after placing the item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priority scores. Default to 0, meaning no priority or cannot fit.\n    priority_scores = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit (remaining space must be non-negative).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins that can fit the item, we assign a priority.\n    # To strongly reward near-perfect fits (i.e., very small potential_remaining_space)\n    # and to minimize fragmentation, we use a non-linear inverse square relation.\n    # This makes the score increase much more rapidly as potential_remaining_space approaches zero.\n    # A small epsilon is added to the denominator to prevent division by zero if an item\n    # perfectly fills a bin (potential_remaining_space = 0) and to provide a finite, very\n    # high score for such cases.\n    epsilon = 1e-9 # A small positive value to handle exact fits (0 remaining space)\n\n    # Apply the non-linear inverse square calculation only to the bins where the item fits.\n    # This ensures that bins offering a near-perfect fit receive a disproportionately\n    # higher score, reflecting the preference for high utilization and reduced fragmentation.\n    priority_scores[can_fit_mask] = 1.0 / (potential_remaining_space[can_fit_mask]**2 + epsilon)\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit heuristic with an enhanced, more aggressive emphasis\n    on minimizing remaining capacity, particularly for near-perfect fits.\n\n    This strategy assigns positive priority scores to perfect or very near-perfect\n    fits, making them strictly preferred. For other fits, it reverts to the\n    standard Best Fit principle (negative score proportional to remaining capacity).\n    The goal is to strongly encourage 'filling up' bins to reduce fragmentation and\n    improve overall packing density by making very tight fits extremely attractive.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Initialize all priorities to a very low negative number (effectively -infinity)\n    # for bins that cannot accommodate the item.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity after fit for eligible bins.\n    # This array `remaining_after_fit_for_valid_bins` now only contains\n    # remaining capacities for bins where the item fits.\n    remaining_after_fit_for_valid_bins = bins_remain_cap[can_fit_mask] - item\n\n    # Define a threshold for what constitutes a \"near-perfect\" fit.\n    # This threshold assumes items and bin capacities are normalized, e.g., to 1.0.\n    # A remaining capacity <= 0.05 (e.g., 5% of a standard bin) is considered near-perfect.\n    near_perfect_threshold = 0.05\n\n    # Create a temporary array for scores of valid bins.\n    # By default, initialize these with the standard Best Fit negative scores.\n    # This covers the `remaining_after_fit_for_valid_bins > near_perfect_threshold` case.\n    temp_scores_for_valid_bins = -remaining_after_fit_for_valid_bins\n\n    # Identify bins within the \"near-perfect\" range from the *filtered* remaining capacities.\n    # This mask applies directly to `remaining_after_fit_for_valid_bins`.\n    near_perfect_mask_in_valid_bins = remaining_after_fit_for_valid_bins <= near_perfect_threshold\n\n    # Apply the aggressive non-linear scoring for near-perfect fits.\n    # The formula `near_perfect_threshold - 2 * remaining` provides:\n    # - `near_perfect_threshold` (e.g., 0.05) for a perfect fit (remaining=0),\n    #   making it the highest possible score.\n    # - A positive score that decreases as remaining capacity increases, reaching 0\n    #   when remaining capacity is `near_perfect_threshold / 2`.\n    # - A negative score (but still better than typical Best Fit) when remaining\n    #   capacity is between `near_perfect_threshold / 2` and `near_perfect_threshold`.\n    temp_scores_for_valid_bins[near_perfect_mask_in_valid_bins] = (\n        near_perfect_threshold - 2 * remaining_after_fit_for_valid_bins[near_perfect_mask_in_valid_bins]\n    )\n\n    # Assign the calculated scores back to the main `scores` array using the original mask.\n    scores[can_fit_mask] = temp_scores_for_valid_bins\n\n    return scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, combining Best Fit\n    with a strategy to maximize bin efficiency and strategically preserve capacity.\n\n    This version aggressively prioritizes near-perfect fits using a non-linear reward\n    and also considers the current utilization (fullness) of bins to encourage closing them.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a priority score of 0.\n        For bins that can fit, a higher score indicates a more desirable placement.\n    \"\"\"\n    # Tunable parameters for the heuristic\n    # WEIGHT_FIT: Emphasizes finding a snug fit (minimizing post-placement remaining space).\n    # WEIGHT_FULLNESS: Emphasizes putting items into bins that are already more full,\n    #                  to help 'close' them and improve overall bin utilization.\n    # FIT_EXPONENT: Makes the reward for very tight fits significantly higher (non-linear).\n    # EPSILON: A small value to prevent division by zero when calculating inverse scores.\n    WEIGHT_FIT = 2.0\n    WEIGHT_FULLNESS = 1.0\n    FIT_EXPONENT = 2.0\n    EPSILON = 1e-9\n\n    # Initialize priority scores. Bins that cannot fit will retain a score of 0.\n    priority_scores = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the remaining space in each bin *after* placing the current item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = potential_remaining_space >= 0\n\n    # Apply calculations only to bins where the item can fit\n    if np.any(can_fit_mask):\n        # 1. Best Fit Component (Aggressive Non-linear Reward for Tight Fits):\n        # This part prioritizes bins that would have the smallest remaining capacity\n        # after the item is placed. The higher exponent (FIT_EXPONENT) makes this\n        # preference for tight fits more pronounced, strongly penalizing larger\n        # remaining spaces and rewarding smaller ones.\n        fit_score_component = 1.0 / ((potential_remaining_space[can_fit_mask] + EPSILON)**FIT_EXPONENT)\n\n        # 2. Bin Fullness Component (Maximizing Bin Efficiency/Utilization):\n        # This part prioritizes bins that are already more utilized (i.e., have less\n        # remaining capacity *before* the item is placed). This encourages filling\n        # up existing bins to their capacity, aiming to 'close' them and minimize\n        # the total number of bins used.\n        fullness_score_component = 1.0 / (bins_remain_cap[can_fit_mask] + EPSILON)\n\n        # Combine the two components using their respective weights.\n        # The sum represents the overall priority score for each fit-able bin.\n        priority_scores[can_fit_mask] = (\n            WEIGHT_FIT * fit_score_component +\n            WEIGHT_FULLNESS * fullness_score_component\n        )\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response0.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, extending v1\n    by further enhancing the non-linear rewards for both snug fits and high bin\n    utilization, and adding an explicit bonus for perfect fits.\n\n    This version aims to be even more aggressive in 'closing' bins by giving a\n    stronger non-linear penalty for less full bins, and explicitly rewarding\n    exact fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a priority score of 0.\n        For bins that can fit, a higher score indicates a more desirable placement.\n    \"\"\"\n    # Tunable parameters for the heuristic\n    # WEIGHT_FIT: Emphasizes finding a snug fit (minimizing post-placement remaining space).\n    # WEIGHT_FULLNESS: Emphasizes putting items into bins that are already more full,\n    #                  to help 'close' them and improve overall bin utilization.\n    # FIT_EXPONENT: Makes the reward for very tight fits significantly higher (non-linear).\n    # FULLNESS_EXPONENT: Makes the reward for very full bins significantly higher (non-linear).\n    # PERFECT_FIT_BONUS: An additional large bonus for an exact fit.\n    # EPSILON: A small value to prevent division by zero or handle near-zero values.\n    WEIGHT_FIT = 2.5 # Slightly increased emphasis on snug fits\n    WEIGHT_FULLNESS = 1.5 # Slightly increased emphasis on fuller bins\n    FIT_EXPONENT = 2.5 # Increased non-linearity for snug fits\n    FULLNESS_EXPONENT = 1.5 # New: non-linearity for bin fullness\n    PERFECT_FIT_BONUS = 1000.0 # Explicit large bonus for a perfect fit\n    EPSILON = 1e-9\n\n    # Initialize priority scores. Bins that cannot fit will retain a score of 0.\n    priority_scores = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the remaining space in each bin *after* placing the current item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item can actually fit.\n    # Using -EPSILON allows for slight floating point inaccuracies near zero.\n    can_fit_mask = potential_remaining_space >= -EPSILON\n\n    # Apply calculations only to bins where the item can fit\n    if np.any(can_fit_mask):\n        # Filter for only the bins that can fit the item\n        fitting_potential_rem_space = potential_remaining_space[can_fit_mask]\n        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n        # 1. Best Fit Component (Aggressively Non-linear Reward for Tight Fits):\n        # This part prioritizes bins that would have the smallest remaining capacity\n        # after the item is placed. The higher exponent (FIT_EXPONENT) makes this\n        # preference for tight fits more pronounced, strongly penalizing larger\n        # remaining spaces and rewarding smaller ones.\n        fit_score_component = 1.0 / ((fitting_potential_rem_space + EPSILON)**FIT_EXPONENT)\n\n        # 2. Bin Fullness Component (Aggressively Maximizing Bin Efficiency/Utilization):\n        # This part prioritizes bins that are already more utilized (i.e., have less\n        # remaining capacity *before* the item is placed). By using FULLNESS_EXPONENT,\n        # it makes the preference for more full bins much stronger, encouraging them to be 'closed'.\n        fullness_score_component = 1.0 / ((fitting_bins_remain_cap + EPSILON)**FULLNESS_EXPONENT)\n\n        # 3. Perfect Fit Bonus:\n        # A significant, explicit bonus for bins where the item perfectly fills the remaining space.\n        # This directly encourages exact fits, which are ideal for minimizing bin count.\n        perfect_fit_mask = np.isclose(fitting_potential_rem_space, 0.0, atol=EPSILON)\n        perfect_fit_bonus_component = np.zeros_like(fitting_potential_rem_space)\n        perfect_fit_bonus_component[perfect_fit_mask] = PERFECT_FIT_BONUS\n\n        # Combine the components using their respective weights and add the perfect fit bonus.\n        priority_scores[can_fit_mask] = (\n            WEIGHT_FIT * fit_score_component +\n            WEIGHT_FULLNESS * fullness_score_component +\n            perfect_fit_bonus_component\n        )\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 22.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response0.txt_stdout.txt",
    "code_path": "problem_iter17_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, combining tight fit and bin fullness.\n\n    This strategy aims to:\n    1. Aggressively reward near-perfect fits to minimize fragmentation (Best Fit-like).\n    2. Strategically consolidate items into existing, already relatively full bins,\n       to improve overall bin utilization (encouraging \"First Fit Decreasing\"-like filling within bins).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a priority score of 0.\n        For bins that can fit, a higher score indicates a more desirable bin.\n    \"\"\"\n    # Assumption for BIN_CAPACITY:\n    # For the 'bin fullness' component, we need the total capacity of a bin.\n    # As this is not passed as an argument, we assume a standard bin capacity.\n    # In many Bin Packing Problem variations, items and capacities are normalized,\n    # so a common choice for BIN_CAPACITY is 1.0. If items or bins can exceed 1.0,\n    # this constant should be adjusted or passed as an explicit argument.\n    BIN_CAPACITY = 1.0 \n    \n    # Heuristic tuning parameters\n    epsilon = 1e-9 # Small value to prevent division by zero for perfect fits and stabilize scores\n    tight_fit_exponent = 2.0 # Exponent to make small remaining spaces (tight fits) disproportionately attractive\n    fullness_exponent = 2.0 # Exponent to make bins that are already relatively full disproportionately attractive\n    fullness_weight = 0.5 # Weight of the fullness component relative to the tight fit component\n\n    # Calculate the remaining capacity if the item were to be placed in each bin.\n    # This value indicates how much space would be left after placing the item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priority scores. Default to 0 for bins that cannot fit the item.\n    priority_scores = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit (remaining space must be non-negative).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # Apply calculations only to bins where the item fits\n    if np.any(can_fit_mask): # Proceed only if at least one bin can accommodate the item\n        \n        # --- Component 1: Tight Fit Score (aggressive Best Fit) ---\n        # This component heavily rewards bins that would have very little space left after placing the item.\n        # The inverse relationship combined with an exponent (tight_fit_exponent) makes this reward non-linear\n        # and very aggressive for near-perfect fits.\n        tight_fit_component = 1.0 / (potential_remaining_space[can_fit_mask] + epsilon)**tight_fit_exponent\n\n        # --- Component 2: Bin Fullness Score (consolidation strategy) ---\n        # This component rewards bins that are already relatively full, promoting consolidation\n        # and preventing unnecessary opening of new bins or leaving many partially filled bins.\n        current_filled_space = BIN_CAPACITY - bins_remain_cap[can_fit_mask]\n        \n        # Ensure filled space is not negative due to floating point inaccuracies, though it should be handled\n        # by BIN_CAPACITY consistency.\n        current_filled_space = np.maximum(current_filled_space, 0)\n        \n        bin_fullness_ratio = current_filled_space / BIN_CAPACITY\n        \n        # Apply an exponent (fullness_exponent) to disproportionately reward bins that are already quite full.\n        fullness_component = bin_fullness_ratio**fullness_exponent\n\n        # --- Combine the scores ---\n        # The overall priority score is a weighted sum of the tight fit and bin fullness components.\n        # The tight_fit_component typically yields much larger values, ensuring that excellent fits\n        # are always highly prioritized. The fullness_weight scales the fullness_component so it acts\n        # as a valuable secondary criterion or tie-breaker, guiding items towards fuller bins among\n        # similarly fitting options.\n        priority_scores[can_fit_mask] = tight_fit_component + (fullness_weight * fullness_component)\n        \n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]