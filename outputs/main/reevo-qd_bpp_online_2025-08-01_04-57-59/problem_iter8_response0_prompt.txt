{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing an enhanced Best Fit heuristic with a significantly stronger\n    emphasis on minimizing remaining capacity, particularly for near-perfect fits,\n    to aggressively reduce fragmentation.\n\n    This strategy extends the Best Fit principle by applying a more pronounced\n    non-linear penalty reduction for bins that result in a very small positive\n    remaining capacity. Perfect fits (0 remaining capacity) retain the highest\n    priority (score 0). For remaining capacities within a defined 'near-perfect'\n    threshold, the penalty is drastically reduced using a higher-order polynomial\n    decay (e.g., cubic), making these bins highly desirable. For capacities above\n    the threshold, a standard linear Best Fit penalty is applied. This aims to\n    'trap' items efficiently and prevent the creation of many sparsely filled bins,\n    thereby reducing overall fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Initialize all priorities to a very low negative number (effectively -infinity)\n    # for bins that cannot accommodate the item.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity after fit for eligible bins\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Define a threshold for what constitutes a \"near-perfect\" fit.\n    # This threshold assumes items and bin capacities are normalized, e.g., to 1.0.\n    # A remaining capacity <= 0.05 (e.g., 5% of a standard bin) is considered near-perfect.\n    # This value might need tuning based on typical item sizes in a specific problem context.\n    near_perfect_threshold = 0.05\n\n    # Power factor for the non-linear scaling.\n    # A higher power_factor provides a more aggressive incentive for very small\n    # remaining capacities.\n    # k=2 for priority_v1 (quadratic scaling: r^2/T).\n    # k=3 for this improved version (cubic scaling: r^3/T^2).\n    # This makes the penalty for small 'r' values even smaller (closer to 0),\n    # thus making such bins significantly more attractive.\n    power_factor = 3\n    \n    # Apply a non-linear penalty for remaining capacity.\n    # If remaining_after_fit is within (0, near_perfect_threshold],\n    # the penalty is reduced significantly using a cubic function.\n    # The formula (r^k / T^(k-1)) ensures continuity at T (r=T gives T)\n    # and makes smaller 'r' values result in much less penalty (closer to 0).\n    scaled_remaining = np.where(\n        (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_threshold),\n        (remaining_after_fit ** power_factor) / (near_perfect_threshold ** (power_factor - 1)),\n        remaining_after_fit  # Standard linear penalty for remaining > threshold\n    )\n    \n    # If remaining_after_fit is exactly 0, scaled_remaining will be 0, and score will be 0,\n    # making perfect fits the highest priority.\n    # Otherwise, the score is the negative of the scaled remaining capacity.\n    scores[can_fit_mask] = -scaled_remaining\n\n    return scores\n\n[Reflection]\nPrioritize by minimizing remaining capacity. Non-linearly reward near-perfect fits to reduce fragmentation and improve packing density.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}