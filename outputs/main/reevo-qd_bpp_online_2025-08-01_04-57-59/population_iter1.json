[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit-like strategy.\n\n    This strategy aims to leave the smallest possible remaining capacity in a bin after placing the item,\n    thereby 'snugly' fitting items and preserving larger empty spaces in other bins for future larger items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a priority score of 0.\n        For bins that can fit, a higher score indicates a 'tighter' fit (smaller remaining capacity).\n    \"\"\"\n    # Calculate the remaining capacity if the item were to be placed in each bin.\n    # This value indicates how much space would be left after placing the item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priority scores. Default to 0, meaning no priority or cannot fit.\n    priority_scores = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit (remaining space must be non-negative).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins that can fit the item, we want to assign a priority.\n    # In a Best Fit strategy, we prefer bins that leave the *smallest* amount of space remaining.\n    # To translate \"smallest remaining space\" into \"highest priority score\", we use the inverse.\n    # A small epsilon is added to the denominator to prevent division by zero if an item\n    # perfectly fills a bin (potential_remaining_space = 0). It also slightly biases\n    # exact fits to have a finite, very large score.\n    epsilon = 1e-9 # A small positive value to handle exact fits (0 remaining space)\n\n    # Apply the inverse calculation only to the bins where the item fits.\n    # This assigns a high score to bins where the item fits snugly (potential_remaining_space is small).\n    # For example, if potential_remaining_space is 0.1, score is ~10. If it's 0.01, score is ~100.\n    priority_scores[can_fit_mask] = 1.0 / (potential_remaining_space[can_fit_mask] + epsilon)\n\n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic, 'Near-Perfect Fit (NPF)', prioritizes bins that will have\n    the smallest possible remaining capacity after the item is placed,\n    giving an exceptionally high priority to a perfect fit (where the bin becomes full).\n    It uses an inverse relationship to emphasize very small remaining spaces.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher score indicates higher priority. Bins where the item does not\n        fit have a score of -np.inf.\n    \"\"\"\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # A very small positive constant to handle potential division by zero\n    # for perfect fits and to ensure finite, large scores for near-perfect fits.\n    epsilon = 1e-9\n\n    # Calculate the remaining capacity if the item were placed in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Identify bins where the item can fit (remaining capacity is non-negative,\n    # allowing for a small floating point tolerance).\n    can_fit_mask = remaining_after_placement >= -epsilon\n\n    # --- Scoring Logic ---\n\n    # 1. Prioritize perfect fits (remaining capacity is effectively zero) with infinite score.\n    #    This ensures they are always chosen if available.\n    perfect_fit_mask = np.isclose(remaining_after_placement, 0.0, atol=epsilon)\n    scores[perfect_fit_mask] = np.inf\n\n    # 2. For bins where the item fits but is not a perfect fit,\n    #    assign a score based on the inverse of the remaining capacity.\n    #    The smaller the remaining capacity, the higher the score.\n    non_perfect_fit_mask = can_fit_mask & ~perfect_fit_mask\n    if np.any(non_perfect_fit_mask): # Only calculate if there are such bins\n        # Adding epsilon prevents division by zero if remaining_after_placement somehow becomes exactly zero\n        # after filtering by perfect_fit_mask (should not happen, but for robustness).\n        scores[non_perfect_fit_mask] = 1.0 / (remaining_after_placement[non_perfect_fit_mask] + epsilon)\n\n    return scores",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit heuristic.\n\n    This function prioritizes bins that, after placing the item, would result in the\n    smallest remaining capacity. This strategy aims to leave larger spaces in other bins\n    for potentially larger future items, or compact items into existing bins efficiently.\n\n    A very low priority (-infinity) is assigned to bins where the item does not fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher score means higher priority.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value here means the item does not fit.\n    potential_leftover = bins_remain_cap - item\n\n    # Initialize priority scores for all bins to a very low value (-infinity).\n    # This ensures that bins where the item cannot fit will never be selected\n    # unless no other bin is available (which would typically trigger opening a new bin).\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n\n    # Create a boolean mask for bins where the item actually fits.\n    # An item fits if the potential remaining capacity is non-negative.\n    fitting_bins_mask = potential_leftover >= 0\n\n    # For bins where the item fits, set the priority.\n    # To implement Best Fit (minimize leftover space), we set the priority\n    # to the negative of the leftover space.\n    # This means:\n    # - A leftover of 0 will get a priority of 0 (highest possible for fitting items).\n    # - A small positive leftover (e.g., 0.1) will get a priority of -0.1.\n    # - A larger positive leftover (e.g., 0.5) will get a priority of -0.5.\n    # Maximizing this priority score will naturally pick the bin with the smallest\n    # positive leftover space, thus implementing Best Fit.\n    priority_scores[fitting_bins_mask] = -potential_leftover[fitting_bins_mask]\n\n    return priority_scores",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version implements a hybrid strategy combining Perfect Fit and Worst Fit principles:\n\n    1.  **Perfect Fit (PF):** Gives the absolute highest priority to any bin that would be\n        exactly filled by the current item (leaving zero remaining capacity). This is\n        highly desirable in bin packing as it effectively \"closes\" a bin optimally.\n    2.  **Worst Fit (WF):** For bins that cannot achieve a perfect fit but can still\n        accommodate the item, this strategy prioritizes the bin that would leave the\n        *largest* amount of remaining space after packing the item. This approach aims\n        to keep bins' remaining capacities as varied as possible, potentially preserving\n        larger empty spaces for future large items or keeping bins \"open\" longer.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority. Bins that cannot fit the item\n        at all will have a very low (negative infinity) priority, ensuring they are not chosen.\n    \"\"\"\n    # Initialize priority scores with a very low value (negative infinity).\n    # This ensures that bins incapable of fitting the item are never chosen\n    # if there's any other viable option.\n    priorities = np.full_like(bins_remain_cap, np.NINF, dtype=float)\n\n    # Calculate the remaining capacity for each bin if the current item were placed in it.\n    # A negative value means the item does not fit.\n    potential_remaining = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item can actually fit (remaining capacity >= 0).\n    can_fit_mask = potential_remaining >= 0\n\n    # --- Apply Worst Fit (WF) logic for all bins that can accommodate the item ---\n    # For bins that can fit, their initial priority is the amount of space left.\n    # We want to maximize this value to achieve the Worst Fit (most remaining space).\n    priorities[can_fit_mask] = potential_remaining[can_fit_mask]\n\n    # --- Apply Perfect Fit (PF) logic to override WF for exact fits ---\n    # Identify bins that would have close to zero remaining capacity after placing the item.\n    # Use a small epsilon for floating point comparisons to account for precision issues.\n    EPSILON = 1e-9\n    perfect_fit_mask = np.abs(potential_remaining) < EPSILON\n\n    # Define a very high priority score for perfect fits. This value must be\n    # significantly larger than any possible Worst Fit score (which would be\n    # at most the bin's total capacity if a single tiny item is placed in an empty bin).\n    # Using half of the maximum float value ensures it's numerically stable and distinct.\n    VERY_HIGH_PRIORITY = np.finfo(float).max / 2.0 \n\n    # Assign the very high priority to bins that are both able to fit the item\n    # AND result in a perfect fit. The `can_fit_mask` check here is technically\n    # redundant because `potential_remaining >= 0` for perfect fits, but good for clarity.\n    priorities[perfect_fit_mask & can_fit_mask] = VERY_HIGH_PRIORITY\n\n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 28, in priority_v2\n    fitting_bins_mask = bins_remain_cap >= item\n  File \"/home/dokhanhnam1199/.local/lib/python3.10/site-packages/numpy/__init__.py\", line 400, in __getattr__\n    raise AttributeError(\nAttributeError: `np.NINF` was removed in the NumPy 2.0 release. Use `-np.inf` instead.\n6\n1\n"
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version implements a Best-Fit heuristic: it prioritizes bins where the\n    item fits most tightly, i.e., leaves the smallest remaining capacity after placement.\n    Bins where the item does not fit are assigned the lowest possible priority.\n\n    In the event of a tie (multiple bins result in the exact same minimal\n    remaining capacity), the bin that appears earliest in the `bins_remain_cap`\n    array (i.e., with a lower index) will implicitly be chosen if the selection\n    mechanism (e.g., `np.argmax`) selects the first occurrence of the maximum value.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    # Initialize all priorities to a very low value (negative infinity).\n    # This ensures bins where the item does not fit will never be chosen\n    # unless no other option exists (which implies a new bin needs to be opened).\n    priorities = np.full_like(bins_remain_cap, fill_value=float('-inf'), dtype=float)\n\n    # Identify which bins can currently accommodate the item.\n    fitting_bins_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity if the item were placed in each fitting bin.\n    # For Best Fit, we want to minimize this remaining capacity.\n    # To convert this into a \"priority\" where higher is better, we take the negative\n    # of the remaining capacity. A smaller positive remaining capacity (e.g., 0.1)\n    # will result in a larger (less negative) priority score (e.g., -0.1) than\n    # a larger remaining capacity (e.g., 0.5 results in -0.5).\n    remaining_after_placement = bins_remain_cap[fitting_bins_mask] - item\n    best_fit_scores = -remaining_after_placement\n\n    # Assign these Best Fit scores to the corresponding fitting bins in the priorities array.\n    priorities[fitting_bins_mask] = best_fit_scores\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit-like heuristic.\n\n    The Best Fit heuristic aims to minimize the unused space in a bin\n    after placing an item, thus leaving larger gaps in new bins for\n    subsequent items.\n\n    This function assigns a higher priority score to bins that:\n    1. Can accommodate the item.\n    2. Would have the smallest remaining capacity after the item is placed\n       (i.e., provide the \"tightest\" fit).\n\n    Invalid bins (where the item does not fit) receive a very low (negative infinity)\n    priority to ensure they are never selected.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest priority score should be chosen.\n    \"\"\"\n    # Initialize all priorities to a very low value (negative infinity).\n    # This ensures that bins where the item cannot fit will have the lowest priority\n    # and will not be selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the remaining capacity if the current 'item' were placed in each bin.\n    # This value will be negative for bins where the item does not fit.\n    potential_remaining_capacities_after_fit = bins_remain_cap - item\n\n    # Create a boolean mask to identify only the valid bins (where the item fits).\n    valid_bins_mask = potential_remaining_capacities_after_fit >= 0\n\n    # For valid bins, we want to prioritize the bin that leaves the least remaining space.\n    # This means we want to maximize -(remaining_space), so smaller remaining space\n    # (e.g., 0.1) gets a priority of -0.1, while larger remaining space (e.g., 0.5)\n    # gets a priority of -0.5.\n    # The `np.argmax` function (or equivalent selection logic) will then correctly\n    # choose the bin with the smallest positive remaining capacity after the item is placed.\n    priorities[valid_bins_mask] = -potential_remaining_capacities_after_fit[valid_bins_mask]\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit (BF) heuristic.\n\n    The Best Fit strategy aims to minimize the remaining capacity in a bin\n    after placing an item. A perfect fit (0 remaining capacity) is ideal.\n    Bins that cannot accommodate the item receive a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Initialize all priorities to a very low negative number (effectively -infinity)\n    # for bins that cannot accommodate the item.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item can fit, calculate the remaining capacity after placing the item.\n    # The Best Fit heuristic prioritizes minimizing this remaining capacity.\n    # To convert this into a maximization problem (highest priority score wins),\n    # we take the negative of the remaining capacity.\n    # A smaller positive remaining capacity (e.g., 1.0) will result in a larger\n    # (less negative) score (e.g., -1.0) compared to a larger positive\n    # remaining capacity (e.g., 10.0), which gets a smaller score (-10.0).\n    # A perfect fit (0 remaining capacity) gets a score of 0.0, which is the highest.\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n    scores[can_fit_mask] = -remaining_after_fit\n\n    return scores",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit (BF) strategy.\n\n    The Best Fit strategy aims to minimize the remaining empty space in a bin\n    after placing an item, among all bins that can accommodate it. This often\n    leads to leaving larger gaps in other bins for potentially larger future items.\n\n    Priority Calculation:\n    1. For bins that *cannot* accommodate the item (remaining capacity < item size),\n       a very low priority (negative infinity) is assigned to ensure they are not chosen.\n    2. For bins that *can* accommodate the item (remaining capacity >= item size),\n       the priority is calculated as the negative of the difference between the\n       bin's remaining capacity and the item's size.\n       This means:\n       - A smaller difference (tighter fit) results in a larger (closer to zero or positive) priority score.\n       - A perfect fit (difference = 0) results in a score of 0, which is the highest possible score\n         for a fitting bin with this formula.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest priority score (closest to 0 or positive) should be selected.\n    \"\"\"\n    # Initialize all priorities to a very low value (negative infinity).\n    # This ensures that bins that cannot fit the item will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins that can accommodate the current item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the priority score.\n    # The score is the negative of the remaining space in the bin after placing the item.\n    # This makes a smaller difference (tighter fit) correspond to a higher score (closer to 0).\n    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a Best-Fit heuristic.\n\n    For each bin, if the item fits, the priority is calculated such that a tighter\n    fit (leaving less remaining space in the bin) results in a higher priority score.\n    Bins where the item cannot fit are assigned a very low (negative infinity) priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value indicates the item does not fit.\n    hypothetical_remaining = bins_remain_cap - item\n\n    # Initialize priority scores for all bins to a very low value.\n    # This ensures that bins that cannot fit the item are effectively deprioritized.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can actually accommodate the item.\n    # These are bins where the hypothetical_remaining capacity is non-negative.\n    can_fit_mask = hypothetical_remaining >= 0\n\n    # For bins where the item can fit, calculate their priority.\n    # In Best-Fit, we want to minimize the remaining space.\n    # To achieve this with a \"highest priority\" selection, we take the negative\n    # of the remaining space. A smaller positive remaining space (tight fit)\n    # will result in a larger (less negative, or even positive if it's a perfect fit)\n    # priority score.\n    # E.g., if remaining is 0.1, priority is -0.1. If remaining is 0.5, priority is -0.5.\n    # -0.1 is greater than -0.5, so the tighter fit gets higher priority.\n    priority_scores[can_fit_mask] = -hypothetical_remaining[can_fit_mask]\n\n    return priority_scores",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This implementation utilizes a \"Squared Best Fit\" heuristic:\n    - Bins that cannot fit the item are assigned the lowest possible priority (-infinity).\n    - For bins where the item can fit, the priority is calculated based on the\n      remaining capacity after the item is placed (remainder = bin_capacity - item_size).\n    - A perfect fit (remainder == 0) results in the highest possible score (0).\n    - For positive remainders, the score is the negative square of the remainder.\n      This non-linear penalty aggressively prioritizes smaller positive remainders,\n      making the heuristic strongly favor \"snug\" fits that leave minimal empty space,\n      while still ensuring perfect fits are top priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Calculate the remaining capacity for each bin if the item were placed in it.\n    remainder_if_placed = bins_remain_cap - item\n    \n    # Initialize all priorities to negative infinity. This ensures that bins\n    # which cannot accommodate the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, fill_value=-np.inf, dtype=float)\n    \n    # Create a boolean mask to identify bins where the item can fit (remainder is non-negative).\n    can_fit_mask = remainder_if_placed >= 0\n    \n    # For bins where the item can fit, calculate their priority score.\n    # The score is the negative square of the remainder.\n    # - If remainder is 0 (perfect fit), score is 0 (highest possible).\n    # - If remainder is small positive (e.g., 0.1), score is -0.01 (very high).\n    # - If remainder is large positive (e.g., 5.0), score is -25.0 (much lower).\n    priorities[can_fit_mask] = -(remainder_if_placed[can_fit_mask] ** 2)\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]