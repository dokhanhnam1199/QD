{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit heuristic.\n\n    This function prioritizes bins that, after placing the item, would result in the\n    smallest remaining capacity. This strategy aims to leave larger spaces in other bins\n    for potentially larger future items, or compact items into existing bins efficiently.\n\n    A very low priority (-infinity) is assigned to bins where the item does not fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher score means higher priority.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value here means the item does not fit.\n    potential_leftover = bins_remain_cap - item\n\n    # Initialize priority scores for all bins to a very low value (-infinity).\n    # This ensures that bins where the item cannot fit will never be selected\n    # unless no other bin is available (which would typically trigger opening a new bin).\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n\n    # Create a boolean mask for bins where the item actually fits.\n    # An item fits if the potential remaining capacity is non-negative.\n    fitting_bins_mask = potential_leftover >= 0\n\n    # For bins where the item fits, set the priority.\n    # To implement Best Fit (minimize leftover space), we set the priority\n    # to the negative of the leftover space.\n    # This means:\n    # - A leftover of 0 will get a priority of 0 (highest possible for fitting items).\n    # - A small positive leftover (e.g., 0.1) will get a priority of -0.1.\n    # - A larger positive leftover (e.g., 0.5) will get a priority of -0.5.\n    # Maximizing this priority score will naturally pick the bin with the smallest\n    # positive leftover space, thus implementing Best Fit.\n    priority_scores[fitting_bins_mask] = -potential_leftover[fitting_bins_mask]\n\n    return priority_scores\n\n[Reflection]\nIncorporate problem-specific objectives and greedy strategies for informed decisions.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}