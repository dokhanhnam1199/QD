{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing an even more aggressively enhanced Best Fit heuristic\n    compared to priority_v1, focusing on even stronger non-linear rewards\n    for near-perfect fits to minimize fragmentation.\n\n    This version amplifies the Best Fit principle by applying a more\n    pronounced non-linear penalty reduction for bins that result in a\n    very small positive remaining capacity. Perfect fits (0 remaining\n    capacity) retain the highest priority (score 0). For remaining capacities\n    within a defined 'near-perfect' threshold, the penalty is drastically\n    reduced using a higher-order polynomial decay (e.g., quartic), making\n    these bins even more highly desirable. For capacities above the threshold,\n    a standard linear Best Fit penalty is applied. This aims to further\n    'trap' items efficiently and prevent the creation of many sparsely\n    filled bins, thereby reducing overall fragmentation and improving\n    packing density.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Initialize all priorities to a very low negative number (effectively -infinity)\n    # for bins that cannot accommodate the item.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity after fit for eligible bins\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Define a threshold for what constitutes a \"near-perfect\" fit.\n    # This threshold assumes items and bin capacities are normalized, e.g., to 1.0.\n    # A remaining capacity <= 0.05 (e.g., 5% of a standard bin) is considered near-perfect.\n    # This value might need tuning based on typical item sizes in a specific problem context.\n    near_perfect_threshold = 0.05\n\n    # Power factor for the non-linear scaling.\n    # A higher power_factor provides an even more aggressive incentive for very small\n    # remaining capacities.\n    # priority_v1 used power_factor = 3 (cubic).\n    # This version uses power_factor = 4 (quartic) for an even stronger emphasis.\n    power_factor = 4 \n    \n    # Apply a non-linear penalty for remaining capacity.\n    # If remaining_after_fit is within (0, near_perfect_threshold],\n    # the penalty is reduced significantly using a quartic function.\n    # The formula (r^k / T^(k-1)) ensures continuity at T (r=T gives T)\n    # and makes smaller 'r' values result in much less penalty (closer to 0).\n    scaled_remaining = np.where(\n        (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_threshold),\n        (remaining_after_fit ** power_factor) / (near_perfect_threshold ** (power_factor - 1)),\n        remaining_after_fit  # Standard linear penalty for remaining > threshold\n    )\n    \n    # If remaining_after_fit is exactly 0, scaled_remaining will be 0, and score will be 0,\n    # making perfect fits the highest priority.\n    # Otherwise, the score is the negative of the scaled remaining capacity.\n    scores[can_fit_mask] = -scaled_remaining\n\n    return scores\n\n[Reflection]\nPrioritize best fit. Amplify non-linear rewards for minimal remaining capacity, especially near-perfect fits, to reduce fragmentation.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}