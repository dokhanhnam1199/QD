```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for packing an item into bins using an Exact Fit First strategy
    with Best Fit as a tie-breaker for non-exact fits, and an exploration component.

    The strategy prioritizes bins that perfectly fit the item (Exact Fit).
    Among bins that do not offer an exact fit but can accommodate the item,
    it prioritizes those that leave the least remaining capacity (Best Fit).
    An epsilon-greedy approach is incorporated to allow for exploration of non-optimal bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    epsilon = 0.05  # Exploration rate
    num_bins = len(bins_remain_cap)
    priorities = np.full(num_bins, -np.inf, dtype=float)  # Initialize with a very low priority

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    fittable_indices = np.where(can_fit_mask)[0]

    if len(fittable_indices) == 0:
        return priorities  # No bin can fit the item

    # Calculate remaining capacities for fittable bins
    remaining_after_fit = bins_remain_cap[fittable_indices] - item

    # Separate exact fits and non-exact fits
    exact_fit_fittable_indices = fittable_indices[remaining_after_fit == 0]
    non_exact_fit_fittable_indices = fittable_indices[remaining_after_fit > 0]

    # --- Assign priorities ---

    # 1. Exact Fits: Highest priority.
    #    Among exact fits, prioritize bins that were initially closer to fitting the item
    #    (i.e., smaller `bins_remain_cap` before placing the item).
    #    A large base priority is used to ensure they are favored.
    base_exact_fit_priority = 1000.0
    if len(exact_fit_fittable_indices) > 0:
        exact_fit_initial_caps = bins_remain_cap[exact_fit_fittable_indices]
        # Score = Base Priority + (Max Initial Capacity among exact fits - Current Initial Capacity)
        # This assigns higher scores to bins that were smaller but still exact fits.
        max_initial_cap_exact_fits = np.max(exact_fit_initial_caps)
        exact_fit_priorities = base_exact_fit_priority + (max_initial_cap_exact_fits - exact_fit_initial_caps)
        priorities[exact_fit_fittable_indices] = exact_fit_priorities

    # 2. Non-Exact Fits (Best Fit): Lower priority than exact fits.
    #    Prioritize bins that leave the least remaining capacity after fitting the item.
    #    The score is derived from `-(remaining_after_fit)` so that smaller remaining capacities
    #    result in higher (less negative) scores. We shift these scores down to be strictly
    #    less than the exact fit priorities.
    offset_for_non_exact_fits = 500.0 # Ensures non-exact fits are lower priority than exact fits
    if len(non_exact_fit_fittable_indices) > 0:
        # Score = Offset - Remaining Capacity after fit
        # Smaller remaining capacity yields a higher score.
        non_exact_fit_priorities = offset_for_non_exact_fits - remaining_after_fit[remaining_after_fit > 0]
        priorities[non_exact_fit_fittable_indices] = non_exact_fit_priorities

    # --- Epsilon-Greedy Exploration ---
    # With probability epsilon, choose a random fittable bin.
    # Otherwise, choose the bin with the highest calculated priority (exploitation).

    if np.random.rand() < epsilon and len(fittable_indices) > 0:
        # Exploration: Choose a random bin among those that can fit the item.
        # Assign it the highest possible priority to ensure it's picked if chosen.
        exploration_bin_index = np.random.choice(fittable_indices)
        # Assign a priority that is guaranteed to be the highest if this bin is chosen
        # A value higher than any possible deterministic priority.
        highest_priority_for_exploration = np.max(priorities[fittable_indices]) + 1.0
        priorities = np.full(num_bins, -np.inf, dtype=float) # Reset priorities for exploration
        priorities[exploration_bin_index] = highest_priority_for_exploration
    else:
        # Exploitation: The priorities are already set based on Exact Fit / Best Fit.
        # If no bin can fit, priorities remain -inf.
        pass

    return priorities
```
