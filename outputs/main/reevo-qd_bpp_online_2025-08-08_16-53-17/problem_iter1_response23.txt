```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using the Almost Full Fit strategy.

    The "Almost Full Fit" strategy prioritizes bins that can accommodate the item
    and have a remaining capacity that is as close as possible to the item's size,
    but not less than the item's size. This aims to leave larger remaining
    capacities in bins that can barely fit the item, potentially allowing
    smaller items to fill them later, thus conserving space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority. Bins that cannot fit the item
        will have a score of -1.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with a low priority

    # Find bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the "gap" (remaining capacity - item size)
    # We want to minimize this gap, meaning the remaining capacity is closest to the item size
    gaps = bins_remain_cap[can_fit_mask] - item

    # Assign priorities: Higher priority to bins with smaller gaps.
    # We use 1 / (1 + gap) to map smaller gaps to higher scores. Adding 1
    # to the denominator avoids division by zero if a bin is exactly full.
    # We also add a small constant to ensure positive priorities.
    if np.any(can_fit_mask):
        priorities[can_fit_mask] = 1.0 / (1.0 + gaps)

    return priorities
```
