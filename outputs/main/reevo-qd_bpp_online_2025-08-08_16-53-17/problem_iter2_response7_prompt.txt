{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 0.1  # Exploration rate\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros(num_bins)\n\n    # Determine which bins can potentially fit the item\n    valid_bins_indices = np.where(bins_remain_cap >= item)[0]\n\n    if len(valid_bins_indices) == 0:\n        # No bin can fit the item, return all zeros (or handle appropriately)\n        return np.zeros(num_bins)\n\n    # Greedy part: prioritize bins that leave the least remaining capacity\n    # This is the \"best fit\" heuristic within the greedy selection.\n    greedy_scores = bins_remain_cap[valid_bins_indices] - item\n\n    # Apply epsilon-greedy strategy\n    if np.random.rand() < epsilon:\n        # Exploration: randomly choose one of the valid bins\n        chosen_bin_index_in_valid = np.random.randint(0, len(valid_bins_indices))\n        chosen_bin_global_index = valid_bins_indices[chosen_bin_index_in_valid]\n        priorities[chosen_bin_global_index] = 1.0  # Assign highest priority to the chosen bin\n    else:\n        # Exploitation: choose the bin that minimizes remaining capacity (best fit)\n        best_fit_index_in_valid = np.argmin(greedy_scores)\n        best_fit_global_index = valid_bins_indices[best_fit_index_in_valid]\n        priorities[best_fit_global_index] = 1.0 # Assign highest priority to the best fit bin\n\n    # For bins that *can* fit the item but are not chosen by epsilon-greedy,\n    # we can assign a small non-zero priority to still allow them a chance,\n    # or simply keep them at zero if we only want one bin to have the highest score.\n    # For simplicity here, we only give priority to the chosen bin.\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n\n    The Softmax-Based Fit strategy assigns higher priorities to bins that can\n    accommodate the item and are \"closer\" to being full after the item is packed.\n    This encourages tighter packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities to negative infinity for bins that cannot fit the item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins that can accommodate the item\n    fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate a score.\n    # The score is based on the remaining capacity *after* the item is packed.\n    # We want to prioritize bins where remaining_capacity - item is small (tighter fit).\n    # A simple approach is to use the negative of the remaining capacity after packing.\n    # Softmax will then turn these scores into probabilities.\n    if np.any(fit_mask):\n        remaining_after_fit = bins_remain_cap[fit_mask] - item\n        # We want smaller remaining capacity to have higher priority.\n        # So, we use the negative of the remaining capacity.\n        # Adding a small epsilon to avoid log(0) issues if remaining capacity becomes exactly 0\n        # or for numerical stability if values are very close to zero.\n        priorities[fit_mask] = -remaining_after_fit + 1e-9\n\n    # Apply softmax to convert scores into probabilities (priorities)\n    # Ensure the exponentiation is stable by subtracting the maximum score\n    # before applying exp, which doesn't change the relative probabilities.\n    if np.any(priorities > -np.inf):\n        max_priority = np.max(priorities[priorities > -np.inf])\n        exp_priorities = np.exp(priorities - max_priority)\n        # Normalize to get probabilities summing to 1 (for the fitting bins)\n        sum_exp_priorities = np.sum(exp_priorities[priorities > -np.inf])\n        if sum_exp_priorities > 0:\n            priorities = exp_priorities / sum_exp_priorities\n        else:\n            # If for some reason sum is zero (e.g., all fitting priorities were -inf),\n            # reset to uniform probability for fitting bins.\n            priorities[priorities > -np.inf] = 1.0 / np.sum(fit_mask)\n    else:\n        # If no bins can fit the item, all priorities remain -inf, or can be set to 0.\n        # For consistency with Softmax, let's keep them as they are.\n        pass\n\n    return priorities\n\n[Reflection]\nPrioritize bins that lead to tighter packing; explore diverse fit strategies beyond simple epsilon-greedy.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}