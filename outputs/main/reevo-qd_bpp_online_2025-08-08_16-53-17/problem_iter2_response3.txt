```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a "best fit" heuristic.

    This heuristic prioritizes bins that can accommodate the item and will have the least
    remaining capacity after the item is placed. This aims to pack items as tightly as possible,
    leaving minimal wasted space in the selected bin, which can help in packing subsequent items
    more efficiently. Bins that cannot fit the item are given a priority of 0, ensuring they
    are only considered if no other bin can fit the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, calculate the remaining capacity *after* placing the item.
    # We want to prioritize bins that result in the smallest positive remaining capacity.
    # This value `remaining_capacity - item` represents the "slack" or wasted space.
    # To maximize priority for minimal slack, we can use the negative of this slack.
    # A smaller slack (closer to 0) will result in a less negative number,
    # hence a higher priority score.
    slack = bins_remain_cap[can_fit_mask] - item
    priorities[can_fit_mask] = -slack

    # The resulting priorities will be non-positive for bins that fit.
    # Since we are seeking the bin with the *highest* priority, and the "best fit"
    # criterion is to minimize slack, the bin with the smallest slack will have
    # the least negative score (closest to 0), thus being selected.
    # Bins that cannot fit remain with a priority of 0.

    return priorities
```
