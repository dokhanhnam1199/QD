```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority score for each bin using a hybrid approach prioritizing good fits and balancing exploration.

    This heuristic prioritizes bins that offer a "good fit" for the item, meaning
    their remaining capacity is slightly larger than the item size. It also
    incorporates an exploration component to occasionally consider less-full bins,
    balancing the "best fit" tendency with exploration of potential future packing
    opportunities.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array containing the remaining capacity of each bin.

    Returns:
        A numpy array of priority scores for each bin. Higher scores indicate a
        higher preference for placing the item in that bin.
    """
    # Tunable parameters
    epsilon = 0.1  # Probability of exploration (choosing a bin less greedily)
    k_steepness = 10.0  # Steepness parameter for the sigmoid function, higher means more emphasis on ideal_gap
    ideal_gap = 0.05  # The preferred remaining capacity beyond the item size

    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins)

    # Identify bins where the item can fit.
    fits_mask = bins_remain_cap >= item
    fitting_bins_indices = np.where(fits_mask)[0]

    # If no bins can fit the item, return all zeros.
    if len(fitting_bins_indices) == 0:
        return priorities

    # --- Exploitation Component: Prioritize Good Fits ---
    # Calculate the "excess capacity" for bins where the item fits.
    excess_capacities = bins_remain_cap[fitting_bins_indices] - item

    # Use a sigmoid function to score the "goodness" of the fit.
    # The argument is designed so that `ideal_gap` results in a score of 0.5.
    # Scores are higher for `excess_capacities` closer to `ideal_gap`.
    sigmoid_argument = k_steepness * (ideal_gap - excess_capacities)
    exploitation_scores = 1 / (1 + np.exp(-sigmoid_argument))

    # Normalize exploitation scores so they sum to 1 among fitting bins.
    # This makes combining with exploration probability more straightforward.
    sum_exploitation_scores = np.sum(exploitation_scores)
    if sum_exploitation_scores > 0:
        normalized_exploitation_scores = exploitation_scores / sum_exploitation_scores
    else:
        # If all exploitation scores are zero (unlikely for valid inputs),
        # assign uniform probability among fitting bins.
        normalized_exploitation_scores = np.ones(len(fitting_bins_indices)) / len(fitting_bins_indices)

    # --- Exploration Component ---
    # Assign a uniform exploration score to all fitting bins.
    # This ensures that even bins with low exploitation scores have a chance.
    uniform_exploration_score = 1.0 / len(fitting_bins_indices)

    # --- Combine Exploitation and Exploration ---
    # The final priority is a weighted average:
    # (1 - epsilon) * exploitation_score + epsilon * uniform_exploration_score
    combined_priorities = (1 - epsilon) * normalized_exploitation_scores + epsilon * uniform_exploration_score

    # Place these combined priorities back into the main priorities array
    priorities[fitting_bins_indices] = combined_priorities

    # Ensure all priorities are non-negative (should already be true due to combination)
    priorities = np.maximum(priorities, 0)

    return priorities
```
