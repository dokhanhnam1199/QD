```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit.

    Almost Full Fit prioritizes bins that have just enough space for the item,
    favoring those that are closer to being full after the item is placed.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Initialize priorities to a very low value for bins that cannot fit the item
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # For bins that can fit the item, calculate the remaining capacity AFTER placing the item
    remaining_capacity_after_placement = bins_remain_cap[can_fit_mask] - item

    # The priority is inversely proportional to the remaining capacity after placement.
    # A smaller remaining capacity (i.e., a fuller bin after placement) gets a higher priority.
    # We add 1 to the remaining capacity to avoid division by zero if remaining_capacity_after_placement is 0,
    # and to ensure smaller remaining capacities yield larger positive priorities.
    # A common way to implement "almost full" is to give a higher score to bins
    # where the remaining space is minimized *after* the item is placed.
    # We can achieve this by taking the negative of the remaining capacity.
    # To further refine and favor bins that are *very* close to full, we can
    # use a score that increases as the remaining capacity decreases.
    # A simple heuristic is to make the priority the negative of the remaining capacity.
    # Or, to make it more robust and avoid extremely large negative numbers if there's large remaining space,
    # we can use 1 / (remaining_capacity_after_placement + epsilon) or a similar scaling.
    # For "almost full fit", we want bins that, after placing the item, leave minimal space.
    # So, the smaller `bins_remain_cap[i] - item` is, the higher the priority.
    # We can use `-(bins_remain_cap[can_fit_mask] - item)` as a simple inverse relationship.
    # To ensure positive scores for ranking or to have a more structured range,
    # we can use `1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)` to give higher priority to smaller remaining capacity.
    # Let's stick to a simpler, direct inverse for "almost full": prioritize bins that become *less* full after placement.
    # A good heuristic for "almost full fit" is to prioritize bins where `remaining_capacity_after_placement` is minimized.
    # This can be represented by taking the negative of this value.

    priorities[can_fit_mask] = -remaining_capacity_after_placement

    return priorities
```
