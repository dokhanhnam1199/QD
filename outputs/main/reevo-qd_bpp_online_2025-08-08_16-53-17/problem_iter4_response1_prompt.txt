{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n\n    The Softmax-Based Fit strategy assigns higher priorities to bins that can\n    accommodate the item and are \"closer\" to being full after the item is packed.\n    This encourages tighter packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities to negative infinity for bins that cannot fit the item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins that can accommodate the item\n    fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate a score.\n    # The score is based on the remaining capacity *after* the item is packed.\n    # We want to prioritize bins where remaining_capacity - item is small (tighter fit).\n    # A simple approach is to use the negative of the remaining capacity after packing.\n    # Softmax will then turn these scores into probabilities.\n    if np.any(fit_mask):\n        remaining_after_fit = bins_remain_cap[fit_mask] - item\n        # We want smaller remaining capacity to have higher priority.\n        # So, we use the negative of the remaining capacity.\n        # Adding a small epsilon to avoid log(0) issues if remaining capacity becomes exactly 0\n        # or for numerical stability if values are very close to zero.\n        priorities[fit_mask] = -remaining_after_fit + 1e-9\n\n    # Apply softmax to convert scores into probabilities (priorities)\n    # Ensure the exponentiation is stable by subtracting the maximum score\n    # before applying exp, which doesn't change the relative probabilities.\n    if np.any(priorities > -np.inf):\n        max_priority = np.max(priorities[priorities > -np.inf])\n        exp_priorities = np.exp(priorities - max_priority)\n        # Normalize to get probabilities summing to 1 (for the fitting bins)\n        sum_exp_priorities = np.sum(exp_priorities[priorities > -np.inf])\n        if sum_exp_priorities > 0:\n            priorities = exp_priorities / sum_exp_priorities\n        else:\n            # If for some reason sum is zero (e.g., all fitting priorities were -inf),\n            # reset to uniform probability for fitting bins.\n            priorities[priorities > -np.inf] = 1.0 / np.sum(fit_mask)\n    else:\n        # If no bins can fit the item, all priorities remain -inf, or can be set to 0.\n        # For consistency with Softmax, let's keep them as they are.\n        pass\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit strategy.\n\n    The Best Fit strategy aims to place the item into the bin where it fits\n    most snugly, leaving the smallest possible remaining capacity. This often\n    helps in leaving larger spaces available for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher priority means a better fit. Bins that cannot accommodate the\n        item are given a priority of -1 (or any value indicating they are invalid).\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with -1 for invalid bins\n\n    # Calculate remaining capacity after placing the item in each bin\n    potential_remaining_capacities = bins_remain_cap - item\n\n    # Consider only bins that can accommodate the item\n    valid_indices = np.where(potential_remaining_capacities >= 0)[0]\n\n    if len(valid_indices) > 0:\n        # The priority is the negative of the remaining capacity.\n        # This is because we want to minimize the remaining capacity (best fit).\n        # A smaller positive remaining capacity (e.g., 0.1) is better than a larger one (e.g., 2.0).\n        # By taking the negative, a smaller positive value becomes a larger negative value,\n        # effectively giving it a higher \"priority\" in a maximization context.\n        # Alternatively, we can think of this as assigning a \"waste\" score, and we want to minimize waste.\n        # For Best Fit, we want the bin with the smallest non-negative remaining capacity.\n        # Assigning priorities as the negative remaining capacity:\n        # A bin with remaining_cap = 1.5 after placing item gets priority -1.5\n        # A bin with remaining_cap = 0.2 after placing item gets priority -0.2\n        # -0.2 > -1.5, so the bin with 0.2 remaining capacity has higher priority.\n        priorities[valid_indices] = -potential_remaining_capacities[valid_indices]\n\n    return priorities\n\n[Reflection]\nFocus on a clear objective for each heuristic. Prioritize bins that minimize waste.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}