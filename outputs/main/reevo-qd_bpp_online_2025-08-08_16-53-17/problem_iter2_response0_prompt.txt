{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 0.1  # Exploration rate\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros(num_bins)\n\n    # Determine which bins can potentially fit the item\n    valid_bins_indices = np.where(bins_remain_cap >= item)[0]\n\n    if len(valid_bins_indices) == 0:\n        # No bin can fit the item, return all zeros (or handle appropriately)\n        return np.zeros(num_bins)\n\n    # Greedy part: prioritize bins that leave the least remaining capacity\n    # This is the \"best fit\" heuristic within the greedy selection.\n    greedy_scores = bins_remain_cap[valid_bins_indices] - item\n\n    # Apply epsilon-greedy strategy\n    if np.random.rand() < epsilon:\n        # Exploration: randomly choose one of the valid bins\n        chosen_bin_index_in_valid = np.random.randint(0, len(valid_bins_indices))\n        chosen_bin_global_index = valid_bins_indices[chosen_bin_index_in_valid]\n        priorities[chosen_bin_global_index] = 1.0  # Assign highest priority to the chosen bin\n    else:\n        # Exploitation: choose the bin that minimizes remaining capacity (best fit)\n        best_fit_index_in_valid = np.argmin(greedy_scores)\n        best_fit_global_index = valid_bins_indices[best_fit_index_in_valid]\n        priorities[best_fit_global_index] = 1.0 # Assign highest priority to the best fit bin\n\n    # For bins that *can* fit the item but are not chosen by epsilon-greedy,\n    # we can assign a small non-zero priority to still allow them a chance,\n    # or simply keep them at zero if we only want one bin to have the highest score.\n    # For simplicity here, we only give priority to the chosen bin.\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First.\n\n    Exact Fit First prioritizes bins that can accommodate the item perfectly,\n    meaning the remaining capacity of the bin after placing the item is zero.\n    Among bins that offer an exact fit, we can further refine the priority.\n    Here, we'll prioritize bins that have a smaller remaining capacity *before*\n    fitting the item (but still large enough to fit it). This strategy\n    aims to \"fill up\" bins more effectively with exact fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins where the item can fit exactly\n    exact_fit_mask = (bins_remain_cap - item) == 0\n\n    # For bins that allow an exact fit, assign a high priority based on their\n    # *current* remaining capacity. We want bins that are *almost* full\n    # (but can still fit the item exactly) to be prioritized.\n    # We can achieve this by assigning a priority score that is inversely\n    # related to their current remaining capacity, or by assigning a score\n    # that increases as remaining capacity decreases towards the item size.\n    # A simple approach is to assign a large base score and then add\n    # a bonus related to how close their current capacity is to the item size.\n    # Let's use a base high priority for exact fits and add a term that\n    # rewards smaller remaining capacities.\n\n    # A large base priority to favor exact fits\n    base_exact_fit_priority = 1000.0\n\n    # Calculate priority for exact fit bins: higher score for bins that were\n    # closer to exactly fitting the item (i.e., smaller current remaining_cap).\n    # We add a small value related to (bins_remain_cap - item) to ensure\n    # that among exact fits, those with smaller initial capacity get a slight edge.\n    # Since for exact fits, bins_remain_cap - item is 0, this term is effectively 0.\n    # Let's consider a slightly different approach: prioritize exact fits,\n    # and among those, pick the one that leaves the smallest remaining space\n    # if we consider the *exact* remaining space after fitting.\n    # So, if bins_remain_cap[i] == item, then bins_remain_cap[i] - item is 0.\n    # To favor those closer to the item size, we can use something like\n    # 1 / (epsilon + bins_remain_cap[i]) or a similar inverse relationship.\n    # A simpler heuristic for exact fit is to give a high score to those\n    # where bins_remain_cap == item. We can then add a penalty for\n    # bins that would have excess capacity even with an exact fit.\n\n    # Let's refine the exact fit priority:\n    # Assign a very high priority to bins that can fit the item perfectly.\n    # To break ties among exact fits, we can prioritize the bin that currently\n    # has the least remaining capacity (closest to the item size without being smaller).\n    # If bins_remain_cap[i] == item, then bins_remain_cap[i] - item = 0.\n    # We want higher priority for smaller `bins_remain_cap` among exact fits.\n    # So, `1 / bins_remain_cap[i]` would work, but we need to avoid division by zero\n    # if bin capacity could be 0, or if the item size is 0.\n    # Assuming item > 0 and bin capacities are positive.\n    # A safer approach might be to use the difference `bins_remain_cap[i] - item`.\n    # For exact fits, this is 0. For non-exact fits, it's > 0.\n    # We can assign a score that is inversely proportional to the remaining capacity\n    # *after* fitting the item, for those bins that have an exact fit.\n\n    # Assign a high score to bins that can fit the item exactly.\n    # Among those, give preference to the bin with the smallest remaining capacity *after* fitting.\n    # This means prioritizing bins where `bins_remain_cap[i]` is closest to `item`.\n    # If `bins_remain_cap[i] == item`, the remaining capacity after fit is 0.\n    # We can use `1 / (item + epsilon)` for exact fits.\n\n    # Let's create a priority based on:\n    # 1. A large bonus for exact fits.\n    # 2. Among exact fits, a smaller value for `bins_remain_cap[i]` gets a higher score.\n\n    # For bins that fit the item (i.e., bins_remain_cap >= item):\n    can_fit_mask = bins_remain_cap >= item\n    fittable_capacities = bins_remain_cap[can_fit_mask]\n    fittable_indices = np.where(can_fit_mask)[0]\n\n    # Calculate the remaining capacity after placing the item.\n    remaining_after_fit = fittable_capacities - item\n\n    # Priority for fittable bins:\n    # We want to prioritize bins that result in *zero* remaining capacity (exact fits).\n    # For non-exact fits, we want to prioritize bins that result in *less* remaining capacity.\n    # A common heuristic is to sort by remaining capacity after fitting.\n    # The \"Exact Fit\" strategy specifically looks for `remaining_after_fit == 0`.\n\n    # Let's implement a strict Exact Fit First:\n    # Highest priority to bins where `bins_remain_cap == item`.\n    # For these, the remaining capacity after fitting is 0.\n    # To break ties among exact fits, we can pick the one with the smallest initial capacity.\n    # Or, we can simply assign them all a high uniform priority and then potentially\n    # use a secondary criterion if needed, but the prompt implies a single priority score.\n\n    # Strategy:\n    # 1. Bins with `bins_remain_cap == item` get a very high priority.\n    # 2. Bins with `bins_remain_cap > item` (but not exact fit) get a lower priority.\n    # 3. Bins with `bins_remain_cap < item` get zero priority (cannot fit).\n\n    # Assigning priority:\n    # Use a large multiplier for exact fits.\n    # For bins that are not exact fits but can fit the item, we can assign a score\n    # that decreases as their remaining capacity (after fitting) increases.\n    # The smaller the `bins_remain_cap[i] - item` for non-exact fits, the higher the priority.\n    # This makes it a \"Best Fit\" if no exact fit exists.\n\n    # A high score for exact fits\n    exact_fit_bonus = 100.0\n\n    # For bins that fit, calculate a score that is higher for those with smaller remaining capacity *after* fitting.\n    # We can use a large negative number for non-fitting bins to ensure they are least prioritized.\n    priorities[can_fit_mask] = -remaining_after_fit # Higher score for smaller remaining capacity\n\n    # Now, adjust for exact fits. We want exact fits to be *higher* than any non-exact fit.\n    # If `remaining_after_fit` is 0, we want a score that is > any negative number.\n    # Let's assign a fixed high score to exact fits.\n    # The indices where exact fit happens are `fittable_indices[remaining_after_fit == 0]`.\n    exact_fit_indices = fittable_indices[remaining_after_fit == 0]\n\n    # For exact fits, set a very high priority. If there are multiple exact fits,\n    # their scores here would be the same. If a secondary criterion is needed,\n    # it could be incorporated into this score, e.g., `-bins_remain_cap[exact_fit_indices]`.\n    # For this implementation, let's assign a high base priority to all exact fits.\n    priorities[exact_fit_indices] = exact_fit_bonus\n\n    # For bins that can fit but are not exact fits, their priority is `-remaining_after_fit`.\n    # Since `remaining_after_fit` is positive, these scores will be negative.\n    # The largest negative score (closest to zero) will be for the smallest `remaining_after_fit`.\n\n    # Final priority adjustment:\n    # If an exact fit exists, all exact fits should have the highest priority.\n    # Among exact fits, let's favor those that were closer to the item size initially.\n    # If `bins_remain_cap[i] == item`, its score is `exact_fit_bonus`.\n    # If `bins_remain_cap[i] > item`, its score is `-(bins_remain_cap[i] - item)`.\n\n    # To ensure exact fits are strictly preferred over best-fit (among non-exact fits):\n    # We can scale the exact fit bonus to be significantly larger than the\n    # maximum possible score from the best-fit part.\n    # The best-fit scores range from approximately -(BIN_CAPACITY - ITEM_SIZE) to slightly less than 0.\n    # So, `exact_fit_bonus` should be greater than `BIN_CAPACITY`.\n    # Let's use `np.max(bins_remain_cap)` as a safe upper bound for remaining capacity.\n\n    scaled_priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_possible_best_fit_score = -np.min(remaining_after_fit) if len(remaining_after_fit) > 0 else 0\n    exact_fit_priority_value = exact_fit_bonus # or something larger like 2 * np.max(bins_remain_cap) if we know capacity limits\n\n    # Apply priorities:\n    # Exact fits get the highest priority\n    exact_fit_locations = (bins_remain_cap - item) == 0\n    scaled_priorities[exact_fit_locations] = exact_fit_priority_value\n\n    # For bins that can fit but not exactly, assign a priority based on minimizing\n    # the remaining space. The smaller the remaining space, the higher the priority.\n    # Since `remaining_after_fit` is always >= 0, and we want higher priority for smaller values,\n    # a negative sign and then the value works for sorting.\n    # For example, if item=3 and capacities are 7, 8, 10:\n    # Remaining after fit: 4, 5, 7.\n    # Scores: -4, -5, -7. Higher score is -4 (bin with capacity 7).\n    # This would mean it's a \"Best Fit\" strategy.\n\n    # To ensure Exact Fit First:\n    # Set exact fits to a high constant value.\n    # Set non-exact fits to a lower range of values.\n    # The best fit criterion can be used to order within non-exact fits.\n\n    # Let's assign a score that is simply `exact_fit_priority_value` for exact fits.\n    # For bins that fit but not exactly, we want them to be strictly lower priority.\n    # We can assign them a priority based on the *negative* of their remaining capacity.\n    # The smaller the remaining capacity, the higher (less negative) the score.\n\n    # Initialize all to a very low priority (unusable bins)\n    scaled_priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    fittable_indices = np.where(can_fit_mask)[0]\n\n    # Calculate remaining capacities for fittable bins\n    remaining_after_fit = bins_remain_cap[fittable_indices] - item\n\n    # Find exact fit indices within the fittable ones\n    exact_fit_fittable_indices = fittable_indices[remaining_after_fit == 0]\n    non_exact_fit_fittable_indices = fittable_indices[remaining_after_fit > 0]\n\n    # Assign highest priority to exact fits.\n    # Among exact fits, we can choose the one that was closest to the item size.\n    # If we simply assign the same high score to all exact fits, then it becomes\n    # a matter of which one is encountered first.\n    # A common tie-breaker is the bin with the minimum remaining capacity before fitting,\n    # so `bins_remain_cap[exact_fit_fittable_indices]` would be the tie-breaker.\n    # A higher score for smaller remaining capacity.\n    if len(exact_fit_fittable_indices) > 0:\n        # Let's assign a base high score and add a term that prioritizes smaller initial capacities.\n        # A good tie-breaker is often to pick the one that was closest to being full.\n        # So, `1 / bins_remain_cap` for the exact fits.\n        # Or, use the negative of their current capacity, then sort.\n        # The problem requires a priority score, so higher means better.\n        # Max score for exact fit: `base_exact_fit_priority + (max_initial_cap - current_initial_cap)`\n        # This gives higher score to smaller `current_initial_cap`.\n        base_exact_fit_priority = 1000.0\n        exact_fit_initial_caps = bins_remain_cap[exact_fit_fittable_indices]\n        # Prioritize smaller initial capacities for exact fits\n        exact_fit_priorities = base_exact_fit_priority + (np.max(exact_fit_initial_caps) - exact_fit_initial_caps)\n        scaled_priorities[exact_fit_fittable_indices] = exact_fit_priorities\n    else:\n        # If there are no exact fits, we might fall back to Best Fit.\n        # However, the strategy is strictly Exact Fit First. If no exact fit, then what?\n        # The prompt implies that we always return a priority for *each* bin.\n        # If no exact fit, these bins still might fit. The priority should reflect\n        # that they are *not* exact fits.\n        pass # This section will handle non-exact fits later.\n\n    # Assign priorities to bins that fit but not exactly (Best Fit heuristic for secondary preference)\n    # These should have lower priorities than exact fits.\n    # Priority is inversely related to remaining capacity after fit.\n    # Higher priority for smaller `remaining_after_fit`.\n    if len(non_exact_fit_fittable_indices) > 0:\n        # Assign priorities that are lower than exact fits.\n        # The value `-remaining_after_fit` would be negative.\n        # We want higher score for smaller `remaining_after_fit`.\n        # Example: if remaining_after_fit are 1, 2, 3 -> scores are -1, -2, -3.\n        # The largest score is -1, which corresponds to the smallest remaining capacity.\n        # We need to shift these values so they are still lower than the exact fit priorities.\n        # We can subtract a large constant to ensure they are always lower.\n        offset_for_non_exact_fits = 500.0 # Must be less than base_exact_fit_priority\n        non_exact_fit_priorities = offset_for_non_exact_fits - remaining_after_fit[remaining_after_fit > 0]\n        scaled_priorities[non_exact_fit_fittable_indices] = non_exact_fit_priorities\n\n    # Bins that cannot fit the item retain their initial -inf priority.\n\n    return scaled_priorities\n\n[Reflection]\nPrioritize exact fits, then best fit. Explore varied tie-breakers and exploration strategies.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}