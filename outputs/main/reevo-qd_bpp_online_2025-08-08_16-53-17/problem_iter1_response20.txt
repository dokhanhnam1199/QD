```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a First Fit Decreasing-like strategy.

    This heuristic prioritizes bins that have just enough space for the item,
    favoring those with less remaining capacity after the item is placed.
    This aims to "fill up" bins more efficiently.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Only consider bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return all zeros (though in a real scenario,
    # a new bin would be created)
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the remaining capacity *after* placing the item
    remaining_after_placement = bins_remain_cap[can_fit_mask] - item

    # The priority is inversely proportional to the remaining capacity after placement.
    # A smaller remaining capacity (meaning the bin is now closer to full) gets a higher priority.
    # We use the negative of the remaining capacity to achieve this.
    # Adding a small constant to avoid division by zero if remaining_after_placement can be 0.
    priorities[can_fit_mask] = -remaining_after_placement + 1e-6

    return priorities
```
