```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Exact Fit First.

    Exact Fit First prioritizes bins that can accommodate the item with the least remaining capacity.
    This is achieved by assigning a high priority to bins where (remaining_capacity - item_size) is minimized,
    but only if the item fits. For items that don't fit, a very low priority is assigned.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Find bins where the item fits
    can_fit_mask = bins_remain_cap >= item

    # For bins where the item fits, calculate the "exactness" score.
    # A smaller difference means a better fit. We want to prioritize smaller differences.
    # So, we take the negative of the difference.
    # The ideal fit would have a difference of 0.
    if np.any(can_fit_mask):
        remaining_capacities_for_fitting_bins = bins_remain_cap[can_fit_mask]
        differences = remaining_capacities_for_fitting_bins - item
        # We want to prioritize smaller differences, so we use the negative difference.
        # A difference of 0 (perfect fit) will give a priority of 0.
        # A small positive difference (e.g., 0.1) will give a priority of -0.1.
        # A large positive difference (e.g., 2) will give a priority of -2.
        # This ensures bins with minimal leftover space are preferred.
        priorities[can_fit_mask] = -differences
    
    # Bins where the item does not fit get a very low priority score
    # to ensure they are never chosen if a fitting bin exists.
    priorities[~can_fit_mask] = -np.inf

    return priorities
```
