```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Minimal Waste.

    This strategy, also known as Best Fit, prioritizes bins that will have the
    least amount of remaining capacity after the item is packed. This aims to
    minimize wasted space, which is crucial for efficient bin packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins that cannot accommodate the item will have a priority of 0.
        Among bins that can accommodate the item, higher priority is given to
        bins that result in less remaining capacity after placing the item.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, calculate the remaining capacity after placing the item.
    # This represents the 'waste' or 'slack' in the bin.
    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item

    # We want to select the bin with the minimum remaining capacity (minimum waste).
    # To turn this minimization problem into a maximization problem for priority,
    # we can use a score that is inversely related to the remaining capacity.
    # A simple approach is to use the negative of the remaining capacity.
    # The smallest positive remaining capacity will yield the largest (least negative) score.
    # For example, if remaining capacities after fit are [0.1, 0.5, 0.05],
    # their negative values are [-0.1, -0.5, -0.05]. The highest priority is -0.05.

    # Assign priorities: higher priority for smaller remaining capacity after fit.
    priorities[can_fit_mask] = -remaining_capacity_after_fit

    return priorities
```
