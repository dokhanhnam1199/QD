```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Sigmoid Fit Score.

    The Sigmoid Fit Score strategy aims to prioritize bins that have remaining capacity
    close to the item size, favoring a tight fit while penalizing bins with excessive
    slack. This implementation uses a sigmoid function on the "gap" (remaining capacity - item size).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to 0 for all bins.
    # Bins that don't fit the item will retain a priority of 0.
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item

    # Proceed only if there are bins that can fit the item.
    if np.any(can_fit_mask):
        # Calculate the "gap" for fitting bins: remaining_capacity - item_size.
        # We want this gap to be small and positive for the best fit.
        gap = bins_remain_cap[can_fit_mask] - item

        # Parameters for the sigmoid function:
        # `constant_bias`: Shifts the sigmoid curve horizontally, influencing the "ideal gap".
        #                  A higher bias effectively means a larger gap is considered "ideal".
        # `scale_factor`: Controls the steepness of the sigmoid curve. A higher value
        #                 makes the priority drop off more rapidly as the gap increases.
        # `max_gap_clip`: Caps the gap to prevent extreme values from causing numerical
        #                 instability and to treat very large gaps similarly.
        constant_bias = 3.0
        scale_factor = 5.0
        max_gap_clip = 50.0

        # Clip the gap to the maximum reasonable slack. Gaps larger than this are treated the same.
        # The gap is always non-negative due to `can_fit_mask`.
        clipped_gap = np.clip(gap, 0.0, max_gap_clip)

        # Calculate the argument for the sigmoid function:
        # The sigmoid function `1 / (1 + exp(-x))` is high for large positive `x`.
        # We want high priority when `clipped_gap` is small (close to 0).
        # Thus, we use `Constant - scale_factor * clipped_gap`.
        # - If `clipped_gap` is small (near 0), `sigmoid_arg` is large positive (near `constant_bias`),
        #   resulting in a high priority score (close to 1).
        # - If `clipped_gap` is large, `sigmoid_arg` becomes smaller (or negative),
        #   resulting in a lower priority score.
        sigmoid_arg = constant_bias - scale_factor * clipped_gap

        # To ensure numerical stability for the exponential function, we can clip the argument.
        # The effective range for `exp(y)` is typically up to `y ~ 700-710`.
        # Thus, `exp(-y)` needs `-y` to be within a similar range for positive `y`.
        # We are concerned about `exp(-sigmoid_arg)` overflowing. This happens when
        # `-sigmoid_arg` is large positive, i.e., `sigmoid_arg` is large negative.
        # `sigmoid_arg` is `Constant - scale_factor * clipped_gap`.
        # The most negative `sigmoid_arg` occurs at `max_gap_clip`, which is `constant_bias - scale_factor * max_gap_clip`.
        # With the chosen parameters (3.0, 5.0, 50.0), this is `3.0 - 5.0 * 50.0 = 3.0 - 250.0 = -247.0`.
        # `-sigmoid_arg` is then `247.0`, which is well within the stable range for `exp`.
        # However, for general robustness, clipping the argument to a safe range is good practice.
        # For `1/(1+exp(-x))`, clipping `x` to `[-700, 700]` is common.
        clipped_sigmoid_arg = np.clip(sigmoid_arg, -700.0, 700.0)

        # Apply the sigmoid function to calculate the priorities for fitting bins.
        priorities[can_fit_mask] = 1.0 / (1.0 + np.exp(-clipped_sigmoid_arg))

    return priorities
```
