```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit) strategy.

    The Inverse Distance (Proximity Fit) strategy prioritizes bins that are
    "closest" to fitting the item without overflow. This means bins with
    remaining capacity just slightly larger than the item's size are preferred.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # We only consider bins that have enough capacity to fit the item
    valid_bins_mask = bins_remain_cap >= item

    # Calculate the difference between remaining capacity and item size
    # A smaller difference indicates a "closer fit"
    differences = bins_remain_cap - item

    # Initialize priorities to a very low value (or zero)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # For valid bins, calculate the priority.
    # We want higher priority for smaller differences (closer fits).
    # To avoid division by zero and to make smaller differences result in higher scores,
    # we can use 1 / (difference + epsilon) where epsilon is a small constant.
    # Alternatively, we can use a function like exp(-difference) or other decaying functions.
    # For Inverse Distance, 1 / (difference) is a direct interpretation.
    # A small epsilon is added to the denominator to prevent division by zero if a bin
    # has exactly enough capacity for the item.
    epsilon = 1e-9
    priorities[valid_bins_mask] = 1.0 / (differences[valid_bins_mask] + epsilon)

    # To further refine the "proximity fit", we might want to strongly penalize
    # bins that have a lot of excess capacity if there are bins that fit it
    # much more snugly. The inverse of the difference handles this to some extent.

    # Let's consider a slight modification to emphasize bins that are *just* enough.
    # A very simple heuristic might be to prioritize bins with remaining capacity
    # that is *closest* to the item size.
    # For example, if item=3 and bin capacities are [5, 4, 10],
    # differences are [2, 1, 7]. We want bin with capacity 4 (diff=1) to be highest.
    # Then bin with capacity 5 (diff=2), and bin with capacity 10 (diff=7) would have
    # lower priority. The 1/(diff+eps) approach achieves this.

    return priorities
```
