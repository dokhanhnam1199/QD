```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for bins based on Best Fit heuristic.

    The Best Fit heuristic aims to pack an item into the bin where it leaves
    the smallest positive remaining capacity. This often results in better
    packing density over time by utilizing space efficiently and leaving larger
    bins available for larger items.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array representing the current remaining capacity
                         of each bin.

    Returns:
        A numpy array of the same shape as bins_remain_cap, where each element
        represents the priority score for packing the item into the corresponding
        bin. Higher scores indicate higher priority. Bins that cannot accommodate
        the item are assigned a very low priority (e.g., -infinity or a large
        negative number).
    """
    # Initialize priorities with a very low value for bins that cannot fit the item.
    # Using -np.inf ensures these bins will never be chosen if any valid bin exists.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Calculate the remaining capacity if the item is placed in each bin.
    # We are only interested in bins where the item fits, i.e., remaining capacity >= item size.
    potential_remaining_capacities = bins_remain_cap - item

    # Identify bins where the item can fit.
    can_fit_mask = potential_remaining_capacities >= 0

    # For bins that can fit the item, the priority is inversely related to the remaining capacity.
    # The "best fit" is the bin with the smallest non-negative remaining capacity.
    # To achieve this with a maximization priority scheme, we can assign a high priority
    # to bins with small remaining capacities.
    # A simple way to achieve this is to use the negative of the remaining capacity.
    # For example:
    # Bin A: remaining_cap = 1.5, item = 1.0. Remaining after fit = 0.5. Priority = -0.5
    # Bin B: remaining_cap = 1.1, item = 1.0. Remaining after fit = 0.1. Priority = -0.1
    # Since -0.1 > -0.5, Bin B (the tighter fit) gets a higher priority score.
    # This naturally favors bins with minimal slack.

    # Apply the priority calculation only to the bins that can fit the item.
    # We use the negative of the potential remaining capacity.
    priorities[can_fit_mask] = -potential_remaining_capacities[can_fit_mask]

    return priorities
```
