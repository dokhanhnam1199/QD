```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Epsilon-Greedy.

    The strategy aims to balance exploration (trying less-full bins) and exploitation
    (preferring bins that are a good fit).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.2  # Probability of exploration

    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins)

    # Find bins where the item can fit
    suitable_bins_indices = np.where(bins_remain_cap >= item)[0]

    if len(suitable_bins_indices) == 0:
        # If no bin can fit the item, return all zeros (or handle this case as needed)
        return priorities

    # Exploitation: Prioritize bins that have just enough space (best fit)
    # Calculate a "fit score": closer to 0 means better fit (remaining_cap - item)
    fit_scores = bins_remain_cap[suitable_bins_indices] - item
    # We want lower fit_scores to have higher priority, so we can invert them or use a
    # transformation that makes smaller positive values larger.
    # A simple approach: 1 / (1 + fit_score) which maps [0, inf) to (0, 1]
    exploitation_priorities = 1 / (1 + fit_scores)
    exploitation_priorities = exploitation_priorities / np.sum(exploitation_priorities) # Normalize for softmax-like behavior

    # Exploration: Randomly choose among suitable bins with probability epsilon
    # Assign a small, uniform priority to all suitable bins for exploration
    exploration_priority_value = epsilon / len(suitable_bins_indices)

    # Combine exploitation and exploration
    # For suitable bins, the priority will be (1-epsilon) * exploitation_priority + epsilon * exploration_priority_value
    # For unsuitable bins, priority is 0.
    priorities[suitable_bins_indices] = (1 - epsilon) * exploitation_priorities + epsilon * exploration_priority_value

    # Ensure priorities sum to approximately 1 if needed, or simply return the scores.
    # Here, we are returning raw scores reflecting preference.

    return priorities
```
