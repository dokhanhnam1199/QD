```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Exact Fit First.

    Exact Fit First strategy prioritizes bins that have a remaining capacity
    exactly equal to the item's size. Among bins with exact fits, it
    further prioritizes bins that are "tighter" (i.e., have less remaining
    capacity after the item is placed). If no exact fit is found, it
    falls back to selecting a bin that can accommodate the item and
    minimizes the remaining capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Find bins that have an exact fit
    exact_fit_mask = bins_remain_cap == item
    if np.any(exact_fit_mask):
        # Among exact fits, prefer the one with least remaining capacity (which is 0 after fit)
        # So we can give a high positive score, higher for those that would become exactly full.
        # Since all exact fits will have 0 remaining capacity after the item,
        # we can assign a high, uniform score to them to prioritize them.
        # We add a small penalty to break ties in a deterministic way, although for exact fit,
        # any exact fit is generally considered equal.
        priorities[exact_fit_mask] = 1.0

        # To further differentiate among exact fits and prioritize the "tightest"
        # (which in this case, after placing the item, all exact fits leave 0 space),
        # we can assign a small negative bonus based on their original remaining capacity.
        # This might seem counterintuitive for "exact fit", but if we interpret
        # "exact fit" more broadly as "closest to item size", this would matter.
        # For strict "exact fit = item size", all exact fits are equally good.
        # For this implementation, let's prioritize exact fits and then by how
        # little extra space is left. For exact fits, this extra space is 0.
        # So, let's assign a higher priority to exact fits by simply making them positive.
        # To make them *more* priority, we can give them a higher score.
        # Let's assign a score that reflects "best fit" if it's an exact fit.
        # We can think of this as `(bin_capacity - item) + penalty_for_exact_fit`.
        # For exact fits, `bin_capacity - item` is 0.

        # A more sophisticated approach for "tightest" exact fit would involve
        # looking at bins that are *almost* exact fits if we allowed a small epsilon,
        # but for strict exact fit, we assign a high priority.
        # Let's assign a score that is higher than any non-exact fit score.
        priorities[exact_fit_mask] = 1000.0  # High priority for exact fits
    else:
        # If no exact fit, find bins that can fit the item
        can_fit_mask = bins_remain_cap >= item
        if np.any(can_fit_mask):
            # For bins that can fit, prioritize those with the smallest remaining capacity
            # after placing the item (i.e., the "tightest" fit).
            # The score is inversely related to the remaining capacity after placement.
            # A bin with remaining capacity `c` for item `i` will have `c - i` remaining.
            # We want to minimize `c - i`.
            # So, higher priority for smaller `c - i`.
            # Let's use `-(bins_remain_cap[can_fit_mask] - item)` as a priority score.
            # Higher values of this (less negative) are better.
            priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)

    # For any bins that cannot fit the item, their priority remains 0.
    return priorities
```
