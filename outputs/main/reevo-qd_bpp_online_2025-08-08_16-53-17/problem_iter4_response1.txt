```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit approach.

    This heuristic prioritizes bins that, after packing the item, leave the
    smallest possible remaining capacity. This strategy aims to minimize
    "waste" within bins, potentially leading to better overall packing efficiency.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins that can accommodate the item are scored based on the remaining
        capacity after fitting. Lower remaining capacity results in a higher
        priority score. Bins that cannot fit the item receive a score of -infinity.
    """
    # Initialize priorities to negative infinity for bins that cannot fit the item
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that can accommodate the item
    fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity after packing
    # We want to prioritize bins with the smallest remaining capacity.
    # A simple way to achieve this is to assign a score that is the negative of
    # the remaining capacity. This way, smaller positive remaining capacities
    # (which are better fits) become larger negative numbers, thus having higher priority.
    if np.any(fit_mask):
        remaining_after_fit = bins_remain_cap[fit_mask] - item
        # Higher priority for smaller remaining capacities.
        priorities[fit_mask] = -remaining_after_fit

    return priorities
```
