```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Sigmoid-based Best Fit strategy.

    This strategy aims to prioritize bins that leave the smallest positive remaining
    capacity after the item is placed (Best Fit). It uses a sigmoid function to
    map this "goodness of fit" to a priority score, where tighter fits (smaller
    positive remaining capacity) receive higher scores.

    The function `sigmoid(Constant - scale_factor * gap)` is used, where `gap` is
    the remaining capacity after placing the item (`bins_remain_cap - item`).
    - `Constant` biases the sigmoid, allowing scores above 0.5 for good fits.
    - `scale_factor` controls the steepness of the priority drop-off as the gap increases.
    - A clipping mechanism (`max_gap_clip`) is used to prevent extreme gaps from
      causing numerical instability and to treat very large gaps similarly.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate a higher priority for that bin. Bins that cannot
        accommodate the item are given a priority score of 0.
    """
    priorities = np.zeros_like(bins_remain_cap)  # Initialize with 0 for non-fitting bins

    # Calculate the potential remaining capacity if the item is placed in each bin.
    # We are interested in cases where the item fits, so remaining capacity >= 0.
    potential_remaining_capacities = bins_remain_cap - item

    # Identify bins where the item can fit.
    can_fit_mask = potential_remaining_capacities >= 0

    # Get the remaining capacities for only the bins that can fit the item.
    fitting_bins_remain_cap = potential_remaining_capacities[can_fit_mask]

    # Calculate the 'gap' or 'slack' for fitting bins: remaining_capacity - item_size.
    # We want this gap to be as small and positive as possible.
    gap = fitting_bins_remain_cap

    # --- Heuristic Parameters ---
    # These parameters can be tuned for performance.
    constant_bias = 3.0  # Shifts the sigmoid curve; higher values mean higher priority for tighter fits.
    scale_factor = 5.0   # Controls the steepness of the priority drop-off for larger gaps.
    max_gap_clip = 50.0  # Caps the gap to prevent extreme values from dominating or causing numerical issues.
                         # Gaps larger than this are treated equally poorly.
    # --------------------------

    # Clip the gap values to the maximum defined clip value.
    # This ensures that extremely large gaps don't cause numerical instability
    # in the sigmoid calculation and are penalized consistently.
    clipped_gap = np.clip(gap, 0.0, max_gap_clip)

    # Calculate the argument for the sigmoid function.
    # We want higher priority (higher sigmoid output) for smaller gaps.
    # Sigmoid(x) = 1 / (1 + exp(-x)) is highest for large positive 'x'.
    # So, we want 'x' to be large positive when 'clipped_gap' is small.
    # The form `Constant - scale_factor * clipped_gap` achieves this:
    # - If clipped_gap is small (near 0), arg is ~Constant (positive, large sigmoid output).
    # - If clipped_gap is large, arg is smaller (negative, smaller sigmoid output).
    sigmoid_arg = constant_bias - scale_factor * clipped_gap

    # Apply the sigmoid function to calculate priorities for fitting bins.
    # np.exp() can overflow if the argument to `exp` is too large positive.
    # Here, the argument to `exp` is `-sigmoid_arg`.
    # `-sigmoid_arg = -constant_bias + scale_factor * clipped_gap`.
    # Maximum value of `clipped_gap` is `max_gap_clip`.
    # Max value of `-sigmoid_arg` is `-constant_bias + scale_factor * max_gap_clip`.
    # With parameters: `-3.0 + 5.0 * 50.0 = -3.0 + 250.0 = 247.0`.
    # np.exp(247.0) is large but generally within numerical limits for standard floats.
    # If `sigmoid_arg` becomes extremely negative (due to very large original gaps that were clipped),
    # `-sigmoid_arg` will be very positive, `exp(-sigmoid_arg)` might approach infinity,
    # making the sigmoid value approach 0, which is the desired behavior for bad fits.
    priorities[can_fit_mask] = 1.0 / (1.0 + np.exp(-sigmoid_arg))

    return priorities
```
