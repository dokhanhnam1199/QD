```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit.

    The Best Fit strategy aims to place the item into the bin that has the
    least remaining capacity *after* the item is placed, such that the item fits.
    This minimizes wasted space in the bins. This priority function directly
    assigns a higher score to bins that result in a smaller remaining capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins that cannot accommodate the item will have a priority of 0.
        Among bins that can accommodate the item, higher priority is given to
        bins that result in less remaining capacity after placing the item.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        # Calculate the remaining capacity for bins that can fit the item.
        remaining_after_fit = bins_remain_cap[can_fit_mask] - item

        # For Best Fit, we want to minimize `remaining_after_fit`.
        # To convert this minimization objective into a maximization priority score,
        # we can assign a higher score to smaller values of `remaining_after_fit`.
        # A simple way to do this is to use the negative of the remaining capacity.
        # The smaller the non-negative `remaining_after_fit`, the larger (less negative)
        # its negative will be.
        # For example, if remaining capacities after fit are [0.1, 0.02, 0.5],
        # the priorities will be [-0.1, -0.02, -0.5].
        # The highest priority is -0.02, corresponding to the smallest remaining capacity.
        priorities[can_fit_mask] = -remaining_after_fit

    return priorities
```
