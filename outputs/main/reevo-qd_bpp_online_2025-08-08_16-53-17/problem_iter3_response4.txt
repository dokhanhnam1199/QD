```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a tunable sigmoid.

    This heuristic prioritizes bins that offer the "best fit" for the item,
    defined as bins with minimal residual space after packing. It uses a sigmoid
    function where the steepness and center are tunable parameters to control
    the sensitivity to the remaining capacity.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array where each element is the remaining capacity of a bin.

    Returns:
        A numpy array of the same size as `bins_remain_cap`, containing the priority
        score for each bin. Higher scores indicate a more desirable bin for the item.
    """

    def tunable_sigmoid(x, steepness=10.0, center=0.0):
        """A tunable sigmoid function."""
        return 1 / (1 + np.exp(-steepness * (x - center)))

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit.
    fits_mask = bins_remain_cap >= item

    if np.any(fits_mask):
        # Calculate the "gap" or excess capacity after placing the item.
        gaps = bins_remain_cap[fits_mask] - item

        # Tunable parameters for the sigmoid function:
        # `steepness`: Controls how quickly the priority drops as the gap increases.
        #              Higher steepness means the priority is more sensitive to small changes in gap.
        # `center`: The gap value at which the sigmoid function's output is 0.5.
        #           This can be used to tune what is considered an "ideal" gap.
        #           For example, setting `center=0` would mean the highest priority is for bins
        #           that fit the item exactly. Setting `center` to a small positive value
        #           prioritizes bins with a small leftover space.

        steepness = 15.0  # Increased steepness to make the fit more critical.
        ideal_gap_center = 0.02  # Slightly favor bins that leave a small positive residual.

        # The argument for the sigmoid is designed such that when `gaps` equals `ideal_gap_center`,
        # the argument is 0, and the sigmoid output is 0.5 (midpoint).
        # Gaps smaller than `ideal_gap_center` will result in arguments > 0, leading to scores > 0.5.
        # Gaps larger than `ideal_gap_center` will result in arguments < 0, leading to scores < 0.5.
        argument_values = steepness * (ideal_gap_center - gaps)

        priorities[fits_mask] = tunable_sigmoid(argument_values, steepness=steepness, center=0.0)

        # Softmax normalization for scores (optional, if you want probabilities):
        # This can be useful for probabilistic selection strategies.
        # If not using probabilistic selection, raw sigmoid scores are fine.
        # if np.sum(priorities) > 0:
        #     priorities = np.exp(priorities) / np.sum(np.exp(priorities))

    return priorities
```
