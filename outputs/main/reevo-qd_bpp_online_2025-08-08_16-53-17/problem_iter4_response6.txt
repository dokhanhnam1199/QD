```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Gaussian-like priority.

    This heuristic aims to prioritize bins that offer the "best fit" for the item.
    A "best fit" is defined as a bin where the remaining capacity is only slightly
    larger than the item's size. This strategy tries to fill bins as much as possible
    without leaving excessive empty space, thereby minimizing fragmentation.

    The priority is calculated using a Gaussian-like function. The function is designed
    to peak when the remaining capacity (`bins_remain_cap`) is close to the item's size,
    and the priority decreases as the remaining capacity deviates more significantly.
    Bins where the item doesn't fit at all are assigned a zero priority.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array where each element is the remaining capacity of a bin.

    Returns:
        A numpy array of the same size as `bins_remain_cap`, containing the priority
        score for each bin. Higher scores indicate a more desirable bin for the item.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit.
    fits_mask = bins_remain_cap >= item

    if np.any(fits_mask):
        # Calculate the excess capacity for fitting bins.
        excess_capacities = bins_remain_cap[fits_mask] - item

        # We want to prioritize small, non-negative excess capacities.
        # A Gaussian-like function can achieve this: it peaks at 0 excess capacity
        # and decays as the excess capacity increases.
        # The formula `exp(-k * x^2)` where `x` is the excess capacity works well.
        # We can also consider `exp(-k * (x - target_x)^2)` if we have a slight preference
        # for a small positive excess capacity. Let's aim for near-zero excess.

        # Parameter `k` controls the width of the Gaussian. A smaller `k` means a wider
        # bell curve, so bins with larger excess capacities still get relatively high scores.
        # A larger `k` means a narrower curve, focusing priority only on bins with very
        # small excess capacities.
        k = 50.0  # Controls the 'sharpness' of the preference for minimal excess capacity.

        # Calculate priorities using a Gaussian-like function centered at 0 excess capacity.
        # The argument to exp is `-k * excess_capacities^2`.
        # This ensures that when excess_capacities is 0, the priority is `exp(0) = 1`.
        # As excess_capacities increases (or decreases, though we only care about >=0),
        # the priority smoothly drops towards 0.
        priorities[fits_mask] = np.exp(-k * (excess_capacities ** 2))

    # Bins that do not fit the item will have a priority of 0.

    return priorities
```
