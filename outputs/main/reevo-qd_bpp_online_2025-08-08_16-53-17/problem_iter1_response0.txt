```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using First Fit strategy.

    In this First Fit strategy, we prioritize bins that can exactly fit the item,
    giving them the highest priority. Among bins that can fit the item, we prioritize
    those with the least remaining capacity after placing the item (tightest fit).
    Bins that cannot fit the item are given a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, calculate a priority score
    # We want to prioritize bins where the remaining capacity is as close to zero as possible after placing the item.
    # This encourages using up space efficiently.
    # A bin that fits perfectly gets a higher score (closer to 0 for remaining capacity, meaning higher priority)
    # We can achieve this by using a negative of the remaining capacity after placing the item.
    # A higher (less negative) value means the item fits more snugly.
    # We add a small offset to bins that perfectly fit to make them strictly higher priority than
    # bins that would have a small remaining capacity after fitting.
    # We can achieve this by adding a large positive number if the remaining capacity after fitting is 0.

    priorities[can_fit_mask] = - (bins_remain_cap[can_fit_mask] - item)

    # Boost priority for bins that fit perfectly
    perfect_fit_mask = (bins_remain_cap == item)
    priorities[perfect_fit_mask] += 1e6  # A large constant to ensure perfect fits are prioritized

    # Now, convert to a convention where higher priority is better.
    # We can simply return the priorities as calculated, as higher (less negative) values are preferred.
    # However, to strictly adhere to "highest priority score", we can invert it.
    # Let's invert so that higher values mean higher priority.
    # A negative value for remaining capacity implies it fits, and smaller negative value means tighter fit.
    # So, `-(remaining_capacity - item)` is better if it's closer to 0.
    # The added constant for perfect fit ensures they are the highest.
    # If we want strictly increasing priority score, we can do something like:
    # For bins that can fit: priority = - (bins_remain_cap - item)
    # For perfect fits: priority = very_large_number

    # Let's refine this for clearer "highest priority score" interpretation.
    # We want to pick the bin with the LEAST remaining capacity AFTER placing the item, among those that can fit.
    # If multiple bins can fit, the one with the smallest `bins_remain_cap - item` is best.
    # This is equivalent to the one with the smallest `bins_remain_cap` among those that fit.
    # So, we can prioritize by `bins_remain_cap` directly for fitting bins.

    priorities = np.full_like(bins_remain_cap, -np.inf) # Initialize with lowest possible priority

    # For bins that can fit the item
    fitting_bins_indices = np.where(bins_remain_cap >= item)[0]

    if fitting_bins_indices.size > 0:
        # Among fitting bins, select those with the minimum remaining capacity.
        # This is the First Fit strategy: pick the first available bin that fits.
        # For an online setting where bins are indexed, this means the bin with the smallest index
        # that can accommodate the item.
        #
        # The prompt asks for a PRIORITY function. So, the "first fit" in terms of index
        # needs to be encoded. The *first* bin in the `bins_remain_cap` array that can fit the item
        # should have the highest priority.

        # Let's re-interpret "First Fit" in the context of a priority function.
        # The First Fit strategy means we iterate through the bins in order and pick the *first* one
        # that has enough capacity. So, the bin at index `i` has a higher priority than bin `j` if `i < j`
        # AND bin `i` can fit the item, and bin `j` also can fit the item.

        # Assign priority based on index: earlier bins get higher priority.
        # We can assign priority based on `-(index)` so that smaller indices have larger negative numbers,
        # which would then be mapped to higher positive priority.

        # Assign highest priority to the *first* bin that fits.
        first_fitting_bin_index = -1
        for i, capacity in enumerate(bins_remain_cap):
            if capacity >= item:
                first_fitting_bin_index = i
                break

        if first_fitting_bin_index != -1:
            # Assign a very high priority to this first fitting bin
            priorities[first_fitting_bin_index] = 1e9
            # Lower priorities for other fitting bins that come after the first fitting one.
            # This makes sure that if multiple bins can fit, the one encountered first gets picked.
            # However, if we want to represent "priority score", we need to assign scores to all
            # potentially valid bins.
            #
            # A simpler interpretation for a priority *function* that returns scores for *all* bins:
            # The "First Fit" spirit is about *selection order*. The priority function should reflect this.
            #
            # Strategy: Give a high priority to any bin that fits.
            # Among bins that fit, the earlier ones should have higher priority.
            # The actual "selection" happens after this priority list is generated.
            # So, we want a score for each bin that, when sorted or `argmax`-ed, selects the first fit.

            # Let's assign priority such that the first fitting bin has the highest score.
            # If a bin can fit, its priority should be positive and related to its position.
            # The earlier the bin, the higher the priority.
            # The priority can be inversely related to its index.

            priorities = np.zeros_like(bins_remain_cap)
            for i in range(len(bins_remain_cap)):
                if bins_remain_cap[i] >= item:
                    # Assign a priority based on the index, so earlier bins are preferred.
                    # We want higher scores for smaller indices.
                    # A simple way is to use a large number minus the index.
                    priorities[i] = 1.0 / (i + 1) # Or some other decreasing function of index
                else:
                    priorities[i] = 0.0 # Cannot fit

            # A common approach in heuristic design is to prioritize based on some secondary criteria
            # if multiple options exist. For "First Fit", the primary criterion is the order of bins.
            # If we want to combine "First Fit" with something else (like "Best Fit" as a tie-breaker
            # for scenarios where we need to choose between multiple first-fitting bins due to how the
            # function is used), then we might add more complexity.

            # For a pure First Fit priority function that results in selecting the *first* bin:
            # We can assign a score that ensures the first bin that fits is selected.
            # A very high score for the first bin that fits, and lower scores for subsequent bins.
            #
            # Let's create a priority list where the FIRST bin that satisfies the condition
            # has the highest priority.

            priorities = np.zeros_like(bins_remain_cap)
            found_first_fit = False
            for i in range(len(bins_remain_cap)):
                if bins_remain_cap[i] >= item:
                    if not found_first_fit:
                        priorities[i] = 1000.0  # Highest priority
                        found_first_fit = True
                    else:
                        # Any other bin that also fits gets a lower priority.
                        # The exact value doesn't matter as much as it being lower than the first.
                        priorities[i] = 1.0
                else:
                    priorities[i] = 0.0 # Does not fit

    return priorities
```
