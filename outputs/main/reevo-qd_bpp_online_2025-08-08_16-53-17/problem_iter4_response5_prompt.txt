{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 0.1  # Exploration rate\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros(num_bins)\n\n    # Determine which bins can potentially fit the item\n    valid_bins_indices = np.where(bins_remain_cap >= item)[0]\n\n    if len(valid_bins_indices) == 0:\n        # No bin can fit the item, return all zeros (or handle appropriately)\n        return np.zeros(num_bins)\n\n    # Greedy part: prioritize bins that leave the least remaining capacity\n    # This is the \"best fit\" heuristic within the greedy selection.\n    greedy_scores = bins_remain_cap[valid_bins_indices] - item\n\n    # Apply epsilon-greedy strategy\n    if np.random.rand() < epsilon:\n        # Exploration: randomly choose one of the valid bins\n        chosen_bin_index_in_valid = np.random.randint(0, len(valid_bins_indices))\n        chosen_bin_global_index = valid_bins_indices[chosen_bin_index_in_valid]\n        priorities[chosen_bin_global_index] = 1.0  # Assign highest priority to the chosen bin\n    else:\n        # Exploitation: choose the bin that minimizes remaining capacity (best fit)\n        best_fit_index_in_valid = np.argmin(greedy_scores)\n        best_fit_global_index = valid_bins_indices[best_fit_index_in_valid]\n        priorities[best_fit_global_index] = 1.0 # Assign highest priority to the best fit bin\n\n    # For bins that *can* fit the item but are not chosen by epsilon-greedy,\n    # we can assign a small non-zero priority to still allow them a chance,\n    # or simply keep them at zero if we only want one bin to have the highest score.\n    # For simplicity here, we only give priority to the chosen bin.\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a combination of Best Fit and a novel 'Worst Fit Reduction' strategy.\n\n    This heuristic aims to:\n    1. Favor bins that result in a tight fit (similar to Best Fit).\n    2. Introduce a secondary preference for bins that, after packing, still have substantial remaining capacity,\n       thereby \"reserving\" tighter-fitting bins for potentially smaller future items. This is a form of\n       \"Worst Fit Reduction\" in that we reduce the \"waste\" by not over-filling bins that could\n       accommodate more.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros(num_bins)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bins can fit the item, return all zeros\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Calculate scores for bins that can fit the item\n    fitting_bins_indices = np.where(can_fit_mask)[0]\n    fitting_bins_remain_cap = bins_remain_cap[fitting_bins_indices]\n\n    # Score 1: Best Fit component - prioritize bins that leave less remaining capacity\n    # We use the negative of remaining capacity to make larger negative values (smaller remaining capacity) higher.\n    best_fit_scores = -(fitting_bins_remain_cap - item)\n\n    # Score 2: Worst Fit Reduction component - penalize bins that are too \"full\" after packing,\n    # giving a slight preference to bins that have more remaining capacity.\n    # This can be achieved by adding a small factor of the remaining capacity.\n    # We add a small constant to avoid division by zero if remaining capacity is 0.\n    # This term should be smaller than the best_fit_scores to ensure best fit is dominant.\n    # The scale of this term needs careful tuning; a small positive value is used here.\n    worst_fit_reduction_scores = (fitting_bins_remain_cap - item) * 0.1\n\n    # Combine scores. We want to maximize the combined score.\n    # Prioritize bins that are a good fit AND don't become too full.\n    # Higher scores mean higher priority.\n    combined_scores = best_fit_scores + worst_fit_reduction_scores\n\n    # Normalize scores to a probability distribution using softmax.\n    # Subtract max to prevent overflow during exponentiation and ensure numerical stability.\n    max_score = np.max(combined_scores)\n    exp_scores = np.exp(combined_scores - max_score)\n    sum_exp_scores = np.sum(exp_scores)\n\n    if sum_exp_scores > 0:\n        normalized_priorities = exp_scores / sum_exp_scores\n    else:\n        # If all scores are effectively -inf after subtractions, assign uniform probability.\n        normalized_priorities = np.ones_like(combined_scores) / len(combined_scores)\n\n    # Assign the calculated priorities to the original bins array\n    priorities[fitting_bins_indices] = normalized_priorities\n\n    return priorities\n\n[Reflection]\nCombine 'best fit' with 'worst fit reduction' for better online bin packing.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}