```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Softmax-Based Fit strategy.

    The Softmax-Based Fit strategy prioritizes bins that have remaining capacity
    just enough to fit the item. It uses a softmax function to convert these
    "fit" capacities into probabilities (priorities).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the "gap" for each bin: how much capacity is left after fitting the item.
    # We are interested in bins where the item fits, so negative gaps mean the item doesn't fit.
    gaps = bins_remain_cap - item

    # We want to prioritize bins that have a small positive gap (i.e., a tight fit).
    # A gap of 0 means a perfect fit. Larger positive gaps are less desirable.
    # We'll transform these gaps into a "fitness" score.
    # A common approach for Softmax-Based Fit is to use an exponential function
    # of the negative gap. This emphasizes smaller positive gaps.
    # We need to handle cases where the item doesn't fit (gap < 0). We can assign
    # a very low fitness (or 0) to these bins.

    # Create a fitness score: exponential of negative gap, but only for bins where item fits.
    # We add a small epsilon to avoid issues with exp(0) and to ensure a positive base.
    fitness_scores = np.zeros_like(bins_remain_cap)
    can_fit_mask = gaps >= 0
    fitness_scores[can_fit_mask] = np.exp(-gaps[can_fit_mask])

    # Normalize the fitness scores using the softmax function to get probabilities (priorities).
    # The softmax function ensures that the output values are between 0 and 1
    # and sum up to 1 across all bins.
    # Add a small constant to the denominator to prevent division by zero if all fitness scores are zero.
    sum_fitness = np.sum(fitness_scores)
    if sum_fitness == 0:
        # If no bin can fit the item, assign equal (but low) priority to all bins.
        # This scenario might occur if the item is larger than all remaining capacities.
        # In such cases, returning zeros is also an option, indicating no suitable bin.
        # For a heuristic that must pick a bin, equal probability makes sense.
        priorities = np.ones_like(bins_remain_cap) / len(bins_remain_cap)
    else:
        priorities = fitness_scores / sum_fitness

    return priorities
```
