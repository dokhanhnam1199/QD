{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Newton, I observe that nature abhors a vacuum and tends towards the most\n    efficient arrangement, minimizing wasted space. For our bins, this translates\n    to the principle of 'Best Fit'. We seek to place an item into the bin where it\n    will occupy the space most compactly, leaving the smallest possible remainder.\n    This action effectively \"fills\" the bin most completely, making it less likely\n    to accommodate future large items and pushing it towards completion, thereby\n    conserving the larger, more versatile spaces in other bins.\n\n    A bin that precisely fits an item (leaving zero remaining capacity) is akin to\n    matter perfectly settling into its equilibrium position, achieving maximum density.\n    Thus, such a fit should be of paramount priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher score indicates higher priority.\n    \"\"\"\n    \n    # Initialize priorities. Bins that cannot fit the item are assigned a\n    # very low priority, effectively making them ineligible.\n    # This prevents the item from being \"forced\" into an incompatible space.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify all bins where the item can physically fit.\n    # This is our domain of possible interactions.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the 'residual space' if the item were placed into the bins\n    # that can accommodate it. This is the \"void\" left behind.\n    residual_space = bins_remain_cap[can_fit_mask] - item\n\n    # To ensure perfect fits (residual_space == 0) receive an extremely high,\n    # but finite, priority without causing division by zero, we add a tiny epsilon.\n    # This models an infinite preference for perfect compaction.\n    epsilon = 1e-9 \n\n    # The priority is inversely proportional to the residual space.\n    # A smaller residual space indicates a 'tighter fit' and thus a higher priority.\n    # This mirrors the natural tendency towards minimum potential energy or maximum density.\n    priorities[can_fit_mask] = 1.0 / (residual_space + epsilon)\n    \n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    As a black hole theorist, I seek to maximize the 'density' of our bins,\n    minimizing the 'cosmic voids' (empty space) within them. This heuristic\n    aims for a 'Best Fit' approach by prioritizing bins that will result in\n    the smallest remaining capacity, much like matter striving to coalesce\n    into the densest possible configuration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities. Bins that cannot fit the item are given an\n    # infinitely low priority, ensuring they are not considered.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'event horizons' where an item can be pulled in.\n    # These are the bins with sufficient remaining capacity.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins that can accommodate the item, calculate the 'residual energy'\n    # \u2013 the capacity that would remain after the item is placed.\n    # Our goal is to minimize this residual space, creating a tighter,\n    # more efficient packing.\n    residual_capacity = bins_remain_cap[can_fit_mask] - item\n\n    # To select the bin with the smallest residual capacity (the 'Best Fit'),\n    # we assign a priority that is the negative of this residual.\n    # Thus, a smaller positive residual results in a larger (less negative) priority.\n    # This reflects our cosmic imperative: to pack things as densely as possible.\n    priorities[can_fit_mask] = -residual_capacity\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic aims to implement a variant of the \"Best Fit\" strategy,\n    prioritizing bins that, after accommodating the item, would have the\n    smallest remaining capacity (i.e., the tightest fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates higher priority. Bins that cannot fit the item\n        are assigned a very low (negative infinity) priority.\n    \"\"\"\n    # Initialize priorities for all bins to a very low value.\n    # This ensures bins that cannot fit the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can accommodate the current item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit, calculate the \"slack\" \u2013 the remaining capacity\n    # after the item is placed.\n    slack = bins_remain_cap[can_fit_mask] - item\n\n    # For a Best Fit strategy, we want to minimize this slack.\n    # To convert this into a priority score where higher is better (for np.argmax),\n    # we can use the negative of the slack.\n    # A smaller (closer to zero) positive slack will result in a larger\n    # (closer to zero or positive) priority score.\n    # For example, if slack is 0.1, priority is -0.1. If slack is 0.0 (perfect fit),\n    # priority is 0.0 (the highest possible for this scheme).\n    # If slack is 0.5, priority is -0.5.\n    priorities[can_fit_mask] = -slack\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic aims to implement a variant of the \"Best Fit\" strategy,\n    prioritizing bins that, after accommodating the item, would have the\n    smallest remaining capacity (i.e., the tightest fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates higher priority. Bins that cannot fit the item\n        are assigned a very low (negative infinity) priority.\n    \"\"\"\n    # Initialize priorities for all bins to a very low value.\n    # This ensures bins that cannot fit the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can accommodate the current item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit, calculate the \"slack\" \u2013 the remaining capacity\n    # after the item is placed.\n    slack = bins_remain_cap[can_fit_mask] - item\n\n    # For a Best Fit strategy, we want to minimize this slack.\n    # To convert this into a priority score where higher is better (for np.argmax),\n    # we can use the negative of the slack.\n    # A smaller (closer to zero) positive slack will result in a larger\n    # (closer to zero or positive) priority score.\n    # For example, if slack is 0.1, priority is -0.1. If slack is 0.0 (perfect fit),\n    # priority is 0.0 (the highest possible for this scheme).\n    # If slack is 0.5, priority is -0.5.\n    priorities[can_fit_mask] = -slack\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic implements a \"Best Fit\" strategy, prioritizing bins\n    that, after accommodating the item, would leave the smallest amount of\n    remaining space. This aims to keep bins as \"tightly packed\" as possible,\n    reserving larger empty spaces for potentially larger future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining space in each bin if the item were placed there.\n    # A negative value here means the item does not fit.\n    potential_remain_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores.\n    # We use a float array to allow for -np.inf.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify which bins can actually fit the item (remaining capacity >= 0).\n    can_fit_mask = potential_remain_after_placement >= 0\n\n    # For bins that can fit the item:\n    # The priority is the negative of the remaining space.\n    # A smaller remaining space (e.g., 0.1) will result in a larger negative score (-0.1).\n    # A larger remaining space (e.g., 0.5) will result in a smaller negative score (-0.5).\n    # Since we want to choose the bin with the HIGHEST priority score,\n    # minimizing `potential_remain_after_placement` corresponds to maximizing\n    # `-potential_remain_after_placement`. This is the core of Best Fit.\n    priorities[can_fit_mask] = -potential_remain_after_placement[can_fit_mask]\n\n    # For bins that cannot fit the item:\n    # Assign a very low priority (negative infinity) to ensure they are never\n    # selected if there is any bin that can accommodate the item.\n    priorities[~can_fit_mask] = -np.inf\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic implements a \"Best Fit\" strategy, prioritizing bins\n    that, after accommodating the item, would leave the smallest amount of\n    remaining space. This aims to keep bins as \"tightly packed\" as possible,\n    reserving larger empty spaces for potentially larger future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining space in each bin if the item were placed there.\n    # A negative value here means the item does not fit.\n    potential_remain_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores.\n    # We use a float array to allow for -np.inf.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify which bins can actually fit the item (remaining capacity >= 0).\n    can_fit_mask = potential_remain_after_placement >= 0\n\n    # For bins that can fit the item:\n    # The priority is the negative of the remaining space.\n    # A smaller remaining space (e.g., 0.1) will result in a larger negative score (-0.1).\n    # A larger remaining space (e.g., 0.5) will result in a smaller negative score (-0.5).\n    # Since we want to choose the bin with the HIGHEST priority score,\n    # minimizing `potential_remain_after_placement` corresponds to maximizing\n    # `-potential_remain_after_placement`. This is the core of Best Fit.\n    priorities[can_fit_mask] = -potential_remain_after_placement[can_fit_mask]\n\n    # For bins that cannot fit the item:\n    # Assign a very low priority (negative infinity) to ensure they are never\n    # selected if there is any bin that can accommodate the item.\n    priorities[~can_fit_mask] = -np.inf\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by the principle of elegant efficiency and the 'relativity'\n    of an item's volume to the available space within a container, this\n    heuristic aims for the 'best fit'. We seek to minimize the void space\n    that remains after an item is placed, thereby ensuring the most\n    compact packing possible for the individual placement decision.\n\n    A bin is prioritized if, after accommodating the item, it leaves the\n    smallest positive residual capacity. This preserves larger gaps in other\n    bins for future, potentially larger, items, or simply achieves a tighter\n    overall packing. Bins that cannot fit the item are given an infinitesimally\n    small priority, effectively disqualifying them.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A lower positive difference (bins_remain_cap - item) results in a\n        higher (less negative) priority score.\n    \"\"\"\n    # Calculate the theoretical remaining capacity for each bin after placing the item.\n    # This is a measure of the \"excess space\" or \"tightness of fit\".\n    remaining_after_fit = bins_remain_cap - item\n\n    # Initialize all scores to a very low value. This effectively disqualifies\n    # any bin that cannot accommodate the item, as their remaining_after_fit\n    # would be negative, and we only update positive or zero remaining_after_fit.\n    # We choose a sufficiently small negative number to ensure it's always lower\n    # than any valid score.\n    scores = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify which bins can actually fit the item.\n    # These are the bins where remaining_after_fit is non-negative.\n    can_fit_mask = remaining_after_fit >= 0\n\n    # For the bins that can fit the item, we assign a score.\n    # The score is the negative of the remaining space.\n    # This means a smaller remaining space (e.g., 0.1) yields a higher score (-0.1)\n    # compared to a larger remaining space (e.g., 0.5 which yields -0.5).\n    # The bin with the largest (least negative) score will be the one\n    # with the smallest positive remaining capacity after placement (the best fit).\n    scores[can_fit_mask] = -remaining_after_fit[can_fit_mask]\n\n    return scores\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by the principle of elegant efficiency and the 'relativity'\n    of an item's volume to the available space within a container, this\n    heuristic aims for the 'best fit'. We seek to minimize the void space\n    that remains after an item is placed, thereby ensuring the most\n    compact packing possible for the individual placement decision.\n\n    A bin is prioritized if, after accommodating the item, it leaves the\n    smallest positive residual capacity. This preserves larger gaps in other\n    bins for future, potentially larger, items, or simply achieves a tighter\n    overall packing. Bins that cannot fit the item are given an infinitesimally\n    small priority, effectively disqualifying them.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A lower positive difference (bins_remain_cap - item) results in a\n        higher (less negative) priority score.\n    \"\"\"\n    # Calculate the theoretical remaining capacity for each bin after placing the item.\n    # This is a measure of the \"excess space\" or \"tightness of fit\".\n    remaining_after_fit = bins_remain_cap - item\n\n    # Initialize all scores to a very low value. This effectively disqualifies\n    # any bin that cannot accommodate the item, as their remaining_after_fit\n    # would be negative, and we only update positive or zero remaining_after_fit.\n    # We choose a sufficiently small negative number to ensure it's always lower\n    # than any valid score.\n    scores = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify which bins can actually fit the item.\n    # These are the bins where remaining_after_fit is non-negative.\n    can_fit_mask = remaining_after_fit >= 0\n\n    # For the bins that can fit the item, we assign a score.\n    # The score is the negative of the remaining space.\n    # This means a smaller remaining space (e.g., 0.1) yields a higher score (-0.1)\n    # compared to a larger remaining space (e.g., 0.5 which yields -0.5).\n    # The bin with the largest (least negative) score will be the one\n    # with the smallest positive remaining capacity after placement (the best fit).\n    scores[can_fit_mask] = -remaining_after_fit[can_fit_mask]\n\n    return scores\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Newton, I observe that nature abhors a vacuum and tends towards the most\n    efficient arrangement, minimizing wasted space. For our bins, this translates\n    to the principle of 'Best Fit'. We seek to place an item into the bin where it\n    will occupy the space most compactly, leaving the smallest possible remainder.\n    This action effectively \"fills\" the bin most completely, making it less likely\n    to accommodate future large items and pushing it towards completion, thereby\n    conserving the larger, more versatile spaces in other bins.\n\n    A bin that precisely fits an item (leaving zero remaining capacity) is akin to\n    matter perfectly settling into its equilibrium position, achieving maximum density.\n    Thus, such a fit should be of paramount priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher score indicates higher priority.\n    \"\"\"\n    \n    # Initialize priorities. Bins that cannot fit the item are assigned a\n    # very low priority, effectively making them ineligible.\n    # This prevents the item from being \"forced\" into an incompatible space.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify all bins where the item can physically fit.\n    # This is our domain of possible interactions.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the 'residual space' if the item were placed into the bins\n    # that can accommodate it. This is the \"void\" left behind.\n    residual_space = bins_remain_cap[can_fit_mask] - item\n\n    # To ensure perfect fits (residual_space == 0) receive an extremely high,\n    # but finite, priority without causing division by zero, we add a tiny epsilon.\n    # This models an infinite preference for perfect compaction.\n    epsilon = 1e-9 \n\n    # The priority is inversely proportional to the residual space.\n    # A smaller residual space indicates a 'tighter fit' and thus a higher priority.\n    # This mirrors the natural tendency towards minimum potential energy or maximum density.\n    priorities[can_fit_mask] = 1.0 / (residual_space + epsilon)\n    \n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic aims to implement a variant of the \"Best Fit\" strategy,\n    prioritizing bins that, after accommodating the item, would have the\n    smallest remaining capacity (i.e., the tightest fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates higher priority. Bins that cannot fit the item\n        are assigned a very low (negative infinity) priority.\n    \"\"\"\n    # Initialize priorities for all bins to a very low value.\n    # This ensures bins that cannot fit the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can accommodate the current item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit, calculate the \"slack\" \u2013 the remaining capacity\n    # after the item is placed.\n    slack = bins_remain_cap[can_fit_mask] - item\n\n    # For a Best Fit strategy, we want to minimize this slack.\n    # To convert this into a priority score where higher is better (for np.argmax),\n    # we can use the negative of the slack.\n    # A smaller (closer to zero) positive slack will result in a larger\n    # (closer to zero or positive) priority score.\n    # For example, if slack is 0.1, priority is -0.1. If slack is 0.0 (perfect fit),\n    # priority is 0.0 (the highest possible for this scheme).\n    # If slack is 0.5, priority is -0.5.\n    priorities[can_fit_mask] = -slack\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 12th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 15th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 17th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}