{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best-Fit-like heuristic.\n    Bins that fit the item are prioritized based on how little space\n    would be left after placing the item (i.e., tighter fits get higher scores).\n    Bins that cannot fit the item receive a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low number. This ensures that\n    # bins which cannot accommodate the item are effectively deprioritized.\n    # Using -np.inf makes them guaranteed to not be chosen if any valid bin exists.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the remaining capacity after placement.\n    # We want to minimize this remaining capacity to achieve a \"best fit\".\n    # By taking the negative of the remaining capacity, a smaller positive remainder\n    # (i.e., a tighter fit) results in a larger (less negative) priority score.\n    # A perfect fit (remaining_capacity == 0) results in a score of 0.\n    # A bin that is barely larger than the item will get a score close to 0.\n    # A bin much larger than the item will get a more negative score.\n    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = -remaining_capacity_after_fit\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see that the simpler linear Best-Fit (Heuristic 1) outperforms the more complex non-linear approach with perfect fit bonus (Heuristic 2). This suggests that while perfect fits are intuitively desirable and can reduce fragmentation, an overly aggressive non-linear weighting or bonus might not lead to globally optimal solutions for the specific problem instances tested. This could be due to the bonus causing an item to be placed in a bin for a perfect fit, even if that bin could have held a larger future item, leading to worse overall packing.\n\nComparing (2nd) vs (3rd), Heuristic 2 (non-linear with bonus) is better than Heuristic 3 (parameterized linear Best-Fit). This indicates that the specific hardcoded parameters in Heuristic 3 (`default_low_priority`, `fit_score_weight`) likely lead to suboptimal behavior for the problem at hand, or that the non-linear weighting of Heuristic 2, despite being less effective than Heuristic 1, is still more robust than a poorly tuned linear model. The `fit_score_weight` of -4.72 likely amplifies the best-fit preference more aggressively than necessary.\n\nComparing the \"Best-Fit\" variants (1st, 2nd, 3rd) vs the \"Worst\" (11th-20th), it's evident that any attempt to prioritize bins based on a \"best fit\" criterion, even if the specific scoring function is not perfectly optimal (as in 2nd and 3rd), provides significantly better results than a heuristic that assigns uniform priority to all bins (Heuristics 11-20). The latter simply returns zero priorities, effectively making the choice arbitrary among valid bins, demonstrating a complete lack of strategic intelligence.\n\nOverall: The ranking implies that a straightforward, well-understood heuristic like simple linear Best-Fit can be highly effective and robust. Introducing complexity (non-linear scoring, perfect-fit bonuses) or untuned parameters can unexpectedly degrade performance, potentially due to over-specialization, sub-optimal trade-offs, or an inability to generalize across problem instances.\n- \n*   **Keywords**: Simplicity, Robustness, Global Flexibility, Domain Intelligence.\n*   **Advice**: Favor simple, resilient designs over intricate ones. Prioritize overall solution quality, not just perfect sub-solutions that limit future options. Parameterization must be context-driven, not arbitrary. Always infuse problem-specific insights.\n*   **Avoid**: Prescribing specific scoring methodologies, comparing particular algorithms (e.g., Best Fit vs. First Fit), or incentivizing specific outcomes with complex non-linear scoring.\n*   **Explanation**: This promotes heuristics that are adaptable, less prone to over-fitting, and maintain a broad solution space, preventing premature commitment to local optima through rigid, component-level scoring.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}