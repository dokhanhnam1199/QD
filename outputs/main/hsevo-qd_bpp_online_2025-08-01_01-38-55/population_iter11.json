[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best-Fit-like heuristic.\n    Bins that fit the item are prioritized based on how little space\n    would be left after placing the item (i.e., tighter fits get higher scores).\n    Bins that cannot fit the item receive a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low number. This ensures that\n    # bins which cannot accommodate the item are effectively deprioritized.\n    # Using -np.inf makes them guaranteed to not be chosen if any valid bin exists.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the remaining capacity after placement.\n    # We want to minimize this remaining capacity to achieve a \"best fit\".\n    # By taking the negative of the remaining capacity, a smaller positive remainder\n    # (i.e., a tighter fit) results in a larger (less negative) priority score.\n    # A perfect fit (remaining_capacity == 0) results in a score of 0.\n    # A bin that is barely larger than the item will get a score close to 0.\n    # A bin much larger than the item will get a more negative score.\n    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = -remaining_capacity_after_fit\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing an enhanced Best-Fit-like heuristic with a non-linear\n    scoring function that strongly incentivizes perfect fits and applies\n    a decaying reward for other tight fits.\n\n    This version goes beyond a simple linear 'minimizing leftover space'\n    by introducing a multi-objective perspective through:\n    1. A significant bonus for perfect utilization of a bin.\n    2. A non-linear (inverse) reward for non-perfect fits,\n       making very tight fits significantly more desirable than slightly looser ones.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low number. This ensures that\n    # bins which cannot accommodate the item are effectively deprioritized.\n    # Using -np.inf makes them guaranteed to not be chosen if any valid bin exists.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity after placing the item for fitting bins.\n    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Define a small epsilon for robust floating-point comparisons\n    # and to prevent division by zero for actual perfect fits.\n    epsilon = 1e-9\n\n    # --- Multi-Objective / Non-Linear Scoring Strategy ---\n\n    # 1. Identify \"perfect fits\" (remaining capacity is effectively zero).\n    #    These are critical outcomes as they fully utilize a bin and reduce fragmentation.\n    is_perfect_fit = remaining_capacity_after_fit < epsilon\n\n    # 2. Calculate scores for non-perfect fits using an inverse relationship.\n    #    This ensures a non-linear decay: smaller remaining capacities get\n    #    disproportionately higher positive scores. Adding epsilon to the denominator\n    #    ensures numerical stability and provides a very high but finite score\n    #    for nearly perfect non-zero fits.\n    scores_for_non_perfect_fits = 1.0 / (remaining_capacity_after_fit + epsilon)\n\n    # Initialize combined scores with the non-perfect fit calculations.\n    combined_scores = scores_for_non_perfect_fits\n\n    # 3. Apply a significant, overriding bonus for truly perfect fits.\n    #    This ensures that a perfect fit is always chosen over any non-perfect fit,\n    #    no matter how small the remaining capacity in other bins might be.\n    #    The value (e.g., 2.0 / epsilon) is chosen to be orders of magnitude\n    #    larger than the highest possible score from `1.0 / (remaining + epsilon)`.\n    PERFECT_FIT_SCORE_BONUS = 2.0 / epsilon\n    combined_scores[is_perfect_fit] = PERFECT_FIT_SCORE_BONUS\n\n    # Assign the calculated scores to the bins that can fit the item.\n    priorities[can_fit_mask] = combined_scores\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                default_low_priority: float = -13.732882263687515,\n                fit_score_weight: float = -4.7273623240749325) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best-Fit-like heuristic.\n    Bins that fit the item are prioritized based on how little space\n    would be left after placing the item (i.e., tighter fits get higher scores).\n    Bins that cannot fit the item receive a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        default_low_priority: The priority assigned to bins that cannot accommodate the item.\n                              Should be a very low number (e.g., -np.inf) to ensure they are\n                              not chosen if any valid bin exists.\n        fit_score_weight: A multiplier applied to the negative remaining capacity after fit.\n                          A negative value (e.g., -1.0) ensures that tighter fits (smaller\n                          remaining capacity) receive higher scores.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low number. This ensures that\n    # bins which cannot accommodate the item are effectively deprioritized.\n    # Using default_low_priority makes them guaranteed to not be chosen if any valid bin exists.\n    priorities = np.full_like(bins_remain_cap, default_low_priority, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the remaining capacity after placement.\n    # We want to minimize this remaining capacity to achieve a \"best fit\".\n    # By taking the remaining capacity and multiplying by fit_score_weight,\n    # a smaller positive remainder (i.e., a tighter fit) results in a larger priority score\n    # when fit_score_weight is negative.\n    # A perfect fit (remaining_capacity == 0) results in a score of 0.\n    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = remaining_capacity_after_fit * fit_score_weight\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version enhances the Best-Fit heuristic by incorporating a \"consolidation\"\n    bias. It subtly prioritizes placing items into bins that are already partially\n    filled, over opening entirely new bins (or using effectively \"new\" bins that are\n    still at their maximum initial capacity), provided the fit is comparable.\n    This promotes filling existing bins first to reduce the total bin count,\n    aligning with the goal of \"Global Flexibility\" and \"overall solution quality\"\n    by preventing fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low number. Bins that cannot fit\n    # the item will effectively not be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bins can fit the item, return the deprioritized array.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # --- Best-Fit (Base Logic) ---\n    # Calculate the remaining capacity if the item is placed.\n    # A smaller remaining capacity indicates a tighter fit.\n    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # The base score is the negative of the remaining capacity.\n    # A perfect fit (0 remaining) gets a score of 0. Tighter fits (smaller positive\n    # remaining capacity) get scores closer to 0 (less negative), making them higher priority.\n    base_scores = -remaining_capacity_after_fit\n\n    # --- Consolidation Bias (Domain Intelligence & Global Flexibility) ---\n    # To encourage consolidation, we add a small bonus to bins that are already\n    # partially filled. This nudges the algorithm to prefer an existing bin\n    # over a new one (or one that's still at its maximum capacity) if the\n    # Best-Fit scores are very close.\n\n    # Infer \"newly opened\" bins: We assume that any bin whose remaining capacity\n    # is equal to the maximum remaining capacity among all *currently available*\n    # bins (that can fit the item) is considered effectively \"new\" or \"empty\".\n    # This heuristic works well if bins are opened with a fixed capacity.\n    max_current_capacity = np.max(bins_remain_cap[can_fit_mask])\n\n    # Identify bins that are NOT \"newly opened\" (i.e., they are already partially filled).\n    # This is true if their current capacity is strictly less than the maximum observed capacity.\n    is_partially_filled = bins_remain_cap[can_fit_mask] < max_current_capacity\n\n    # Define a small positive bonus. This value should be small enough not to\n    # override a significantly better Best-Fit score, but large enough to\n    # differentiate between closely scoring bins or break ties.\n    # The choice of 0.01 is a simple, robust constant for floating-point comparisons.\n    consolidation_bonus = 0.01\n\n    # Apply the bonus to partially filled bins.\n    adjusted_scores = base_scores\n    adjusted_scores[is_partially_filled] += consolidation_bonus\n\n    # Assign the calculated scores to the fitting bins in the main priority array.\n    priorities[can_fit_mask] = adjusted_scores\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, unfit_bin_priority_value: float = -7523322707.098899, fit_score_weight: float = -5.045411058574856) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best-Fit-like heuristic.\n    Bins that fit the item are prioritized based on how little space\n    would be left after placing the item (i.e., tighter fits get higher scores).\n    Bins that cannot fit the item receive a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        unfit_bin_priority_value: The priority score assigned to bins that\n                                   cannot accommodate the item. Default is -np.inf,\n                                   ensuring they are never chosen if any valid bin exists.\n        fit_score_weight: A weighting factor applied to the remaining capacity\n                          of fitting bins. A negative value ensures that tighter fits\n                          (smaller remaining capacity) result in higher priority scores.\n                          Default is -1.0, which means a perfect fit (0 remaining capacity)\n                          scores 0, and larger remaining capacities get more negative scores.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low number. This ensures that\n    # bins which cannot accommodate the item are effectively deprioritized.\n    priorities = np.full_like(bins_remain_cap, unfit_bin_priority_value, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the remaining capacity after placement.\n    # We want to minimize this remaining capacity to achieve a \"best fit\".\n    # By applying the fit_score_weight to the remaining capacity, a smaller positive remainder\n    # (i.e., a tighter fit) results in a larger priority score when fit_score_weight is negative.\n    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = fit_score_weight * remaining_capacity_after_fit\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                fit_score_weight: float = 1.0,\n                consolidation_bonus_weight: float = 0.01,\n                default_low_priority: float = -np.inf) -> np.ndarray:\n    \"\"\"Returns priority for adding an item, combining Best-Fit with a tunable consolidation bias.\n    Prioritizes tight fits and rewards using existing, partially-filled bins to consolidate space,\n    enhancing global flexibility through adaptable parameters.\n    \"\"\"\n    # Initialize all priorities to a very low number for bins that cannot fit.\n    priorities = np.full_like(bins_remain_cap, default_low_priority, dtype=float)\n\n    # Identify bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bins can fit the item, return the deprioritized array.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # --- Tunable Best-Fit Logic ---\n    # Calculate the remaining capacity if the item is placed in fitting bins.\n    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Base score: Smaller remaining capacity means a tighter fit, which is better.\n    # The score is amplified by 'fit_score_weight', which should be positive to\n    # promote tighter fits (i.e., a smaller negative value is a higher priority).\n    base_scores = fit_score_weight * (-remaining_capacity_after_fit)\n\n    # --- Tunable Consolidation Bias ---\n    # Identify bins that are NOT \"newly opened\" (i.e., they are already partially filled).\n    # This is true if their current capacity is strictly less than the maximum observed capacity\n    # among *currently available* bins that can fit the item.\n    max_current_capacity_among_fitting_bins = np.max(bins_remain_cap[can_fit_mask])\n    is_partially_filled = bins_remain_cap[can_fit_mask] < max_current_capacity_among_fitting_bins\n\n    # Apply a tunable bonus to partially filled bins to encourage consolidation.\n    adjusted_scores = base_scores\n    adjusted_scores[is_partially_filled] += consolidation_bonus_weight\n\n    # Assign the calculated scores to the fitting bins in the main priority array.\n    priorities[can_fit_mask] = adjusted_scores\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                w_tight_fit: float = 1.0, w_fullness: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a tunable heuristic combining a Best-Fit-like approach with a\n    preference for fuller bins.\n\n    Bins that fit the item are prioritized based on two weighted components:\n    1.  **Tight Fit:** How little space would be left after placing the item (i.e., tighter fits get higher scores).\n        This component directly relates to the Best-Fit heuristic.\n    2.  **Bin Fullness:** How full the bin already is (i.e., smaller remaining capacity means a fuller bin, getting a higher score).\n        This component encourages \"closing\" bins by filling those that are already significantly utilized.\n\n    Bins that cannot fit the item receive a very low priority, effectively preventing their selection.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        w_tight_fit: Weight for the \"tight fit\" component. A higher value emphasizes\n                     minimizing leftover space after placement.\n        w_fullness: Weight for the \"bin fullness\" component. A higher value emphasizes\n                    using bins that are already more filled.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low number. This ensures that\n    # bins which cannot accommodate the item are effectively deprioritized.\n    # Using -np.inf makes them guaranteed to not be chosen if any valid bin exists.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate scores only for bins that can fit the item\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # Component 1: Tight Fit (Best-Fit-like)\n    # The goal is to minimize (bins_remain_cap - item), which is the space left after placement.\n    # To maximize this, we use the negative: -(bins_remain_cap - item) = item - bins_remain_cap.\n    # A smaller remaining capacity after fit results in a higher score.\n    score_tight_fit = item - fitting_bins_remain_cap\n\n    # Component 2: Bin Fullness\n    # The goal is to prefer bins that already have a smaller remaining capacity\n    # (i.e., are closer to being full).\n    # To maximize this, we use the negative of remaining capacity: -fitting_bins_remain_cap.\n    # A smaller current remaining capacity results in a higher score.\n    score_fullness = -fitting_bins_remain_cap\n\n    # Combine the scores using tunable weights.\n    # The overall priority is a weighted sum of these two components.\n    combined_score = (w_tight_fit * score_tight_fit) + (w_fullness * score_fullness)\n\n    # Apply the calculated scores to the valid bins in the priorities array.\n    priorities[can_fit_mask] = combined_score\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 24.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                default_low_priority: float = float('-inf'),\n                fit_score_weight: float = -4.7273623240749325,\n                current_fullness_weight: float = -1.0) -> np.ndarray:\n    \"\"\"Returns priority for each bin, combining Best-Fit with a preference for already fuller bins.\n    Uses tunable weights for adaptive control, promoting tight fits and bin consolidation for efficient packing.\n    \"\"\"\n    # Initialize all priorities to a very low number for bins that cannot fit.\n    # Using float('-inf') ensures they are never chosen if any valid bin exists.\n    priorities = np.full_like(bins_remain_cap, default_low_priority, dtype=float)\n\n    # Identify bins where the item can fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate scores only for bins that can fit the item.\n    if np.any(can_fit_mask):\n        # Component 1: Best-Fit score (prioritizing tightest fits)\n        # Calculates the remaining capacity after placing the item.\n        # A negative fit_score_weight makes smaller remaining_capacity_after_fit (tighter fits) result in higher scores.\n        remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item\n        fit_score = remaining_capacity_after_fit * fit_score_weight\n\n        # Component 2: Current Bin Fullness score (prioritizing already fuller bins)\n        # Uses the current remaining capacity. A smaller current_remaining_capacity means the bin is fuller.\n        # A negative current_fullness_weight makes smaller current_remaining_capacity (fuller bins) result in higher scores.\n        current_remaining_capacity = bins_remain_cap[can_fit_mask]\n        fullness_score = current_remaining_capacity * current_fullness_weight\n\n        # Combine the scores using a weighted sum for continuous integration.\n        priorities[can_fit_mask] = fit_score + fullness_score\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]