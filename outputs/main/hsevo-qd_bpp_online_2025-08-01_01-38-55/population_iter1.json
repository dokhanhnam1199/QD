[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best-Fit-like heuristic.\n    Bins that fit the item are prioritized based on how little space\n    would be left after placing the item (i.e., tighter fits get higher scores).\n    Bins that cannot fit the item receive a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low number. This ensures that\n    # bins which cannot accommodate the item are effectively deprioritized.\n    # Using -np.inf makes them guaranteed to not be chosen if any valid bin exists.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the remaining capacity after placement.\n    # We want to minimize this remaining capacity to achieve a \"best fit\".\n    # By taking the negative of the remaining capacity, a smaller positive remainder\n    # (i.e., a tighter fit) results in a larger (less negative) priority score.\n    # A perfect fit (remaining_capacity == 0) results in a score of 0.\n    # A bin that is barely larger than the item will get a score close to 0.\n    # A bin much larger than the item will get a more negative score.\n    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = -remaining_capacity_after_fit\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by the principle of elegant efficiency and the 'relativity'\n    of an item's volume to the available space within a container, this\n    heuristic aims for the 'best fit'. We seek to minimize the void space\n    that remains after an item is placed, thereby ensuring the most\n    compact packing possible for the individual placement decision.\n\n    A bin is prioritized if, after accommodating the item, it leaves the\n    smallest positive residual capacity. This preserves larger gaps in other\n    bins for future, potentially larger, items, or simply achieves a tighter\n    overall packing. Bins that cannot fit the item are given an infinitesimally\n    small priority, effectively disqualifying them.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A lower positive difference (bins_remain_cap - item) results in a\n        higher (less negative) priority score.\n    \"\"\"\n    # Calculate the theoretical remaining capacity for each bin after placing the item.\n    # This is a measure of the \"excess space\" or \"tightness of fit\".\n    remaining_after_fit = bins_remain_cap - item\n\n    # Initialize all scores to a very low value. This effectively disqualifies\n    # any bin that cannot accommodate the item, as their remaining_after_fit\n    # would be negative, and we only update positive or zero remaining_after_fit.\n    # We choose a sufficiently small negative number to ensure it's always lower\n    # than any valid score.\n    scores = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify which bins can actually fit the item.\n    # These are the bins where remaining_after_fit is non-negative.\n    can_fit_mask = remaining_after_fit >= 0\n\n    # For the bins that can fit the item, we assign a score.\n    # The score is the negative of the remaining space.\n    # This means a smaller remaining space (e.g., 0.1) yields a higher score (-0.1)\n    # compared to a larger remaining space (e.g., 0.5 which yields -0.5).\n    # The bin with the largest (least negative) score will be the one\n    # with the smallest positive remaining capacity after placement (the best fit).\n    scores[can_fit_mask] = -remaining_after_fit[can_fit_mask]\n\n    return scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Newton, I observe that nature abhors a vacuum and tends towards the most\n    efficient arrangement, minimizing wasted space. For our bins, this translates\n    to the principle of 'Best Fit'. We seek to place an item into the bin where it\n    will occupy the space most compactly, leaving the smallest possible remainder.\n    This action effectively \"fills\" the bin most completely, making it less likely\n    to accommodate future large items and pushing it towards completion, thereby\n    conserving the larger, more versatile spaces in other bins.\n\n    A bin that precisely fits an item (leaving zero remaining capacity) is akin to\n    matter perfectly settling into its equilibrium position, achieving maximum density.\n    Thus, such a fit should be of paramount priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher score indicates higher priority.\n    \"\"\"\n    \n    # Initialize priorities. Bins that cannot fit the item are assigned a\n    # very low priority, effectively making them ineligible.\n    # This prevents the item from being \"forced\" into an incompatible space.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify all bins where the item can physically fit.\n    # This is our domain of possible interactions.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the 'residual space' if the item were placed into the bins\n    # that can accommodate it. This is the \"void\" left behind.\n    residual_space = bins_remain_cap[can_fit_mask] - item\n\n    # To ensure perfect fits (residual_space == 0) receive an extremely high,\n    # but finite, priority without causing division by zero, we add a tiny epsilon.\n    # This models an infinite preference for perfect compaction.\n    epsilon = 1e-9 \n\n    # The priority is inversely proportional to the residual space.\n    # A smaller residual space indicates a 'tighter fit' and thus a higher priority.\n    # This mirrors the natural tendency towards minimum potential energy or maximum density.\n    priorities[can_fit_mask] = 1.0 / (residual_space + epsilon)\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin.\n\n    Drawing inspiration from Marie Curie's pursuit of efficiency and the\n    meticulous handling of resources, this function aims to minimize \"radioactive\n    waste\" \u2013 the unused capacity left in a bin after an item is placed.\n\n    This heuristic prioritizes bins that offer the 'snuggest' fit, ideally\n    leaving zero or very little remaining space. Such a fit is akin to achieving\n    a stable, perfectly utilized structure.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities remaining in each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin for the item.\n    \"\"\"\n    # Calculate the hypothetical remaining capacity after placing the item in each bin.\n    # This represents the 'potential waste' or unutilized space.\n    potential_waste = bins_remain_cap - item\n\n    # Initialize priority scores. Bins that cannot fit the item are assigned\n    # the lowest possible priority (-infinity) to ensure they are never chosen\n    # if a valid option exists.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'stable' candidates: bins where the item can actually fit.\n    fitting_bins_mask = potential_waste >= 0\n\n    # A very small epsilon is added to the denominator to prevent division by zero\n    # in the case of a perfect fit (where potential_waste is exactly 0).\n    # This ensures a finite, yet extremely high, priority for a perfect fit.\n    epsilon = 1e-9  # A microscopic allowance, like background radiation\n\n    # For bins that can fit the item, assign priority based on the inverse\n    # of the potential waste. A smaller waste implies a higher priority.\n    # This effectively implements a 'Best Fit' strategy, but with a non-linear\n    # scaling that greatly rewards tighter fits.\n    priority_scores[fitting_bins_mask] = 1.0 / (potential_waste[fitting_bins_mask] + epsilon)\n\n    return priority_scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Nikola Tesla, I perceive this as the elegant coupling of an incoming\n    quantum of energy (the item) into an existing electrical resonator (the bin).\n    My objective is to achieve the most resonant frequency, the most efficient\n    transfer, leaving minimal disruptive residual potential (unused capacity).\n\n    Bins that cannot contain the item are akin to broken circuits; they receive\n    an infinitely low priority. For those that can, the priority is inversely\n    proportional to the \"electrical noise\" (the remaining empty space) they\n    would generate after receiving the item. A perfect fit, where the item\n    consumes all available capacity, is the ideal state, yielding the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all bins with a critically low priority. They are effectively\n    # \"closed circuits\" until proven otherwise, or incapable of conducting this item.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Identify the \"active conduits\" - bins with sufficient remaining capacity.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For these active conduits, calculate the \"residual energy\" (remaining capacity)\n    # after the item is placed. Our aim is to minimize this residue.\n    residual_energy = bins_remain_cap[can_fit_mask] - item\n\n    # To convert \"minimal residual energy\" into \"maximal priority\", we negate it.\n    # A perfect fit (0 residual energy) yields a priority of 0 (the highest possible in this scheme).\n    # Larger residuals yield more negative priorities, making them less desirable.\n    # This precisely embodies the 'Best Fit' principle, ensuring the most\n    # precise and least wasteful allocation of energy.\n    priorities[can_fit_mask] = -residual_energy\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    Inspired by the celestial dance where each body finds its most precise orbit,\n    this heuristic, Best Fit, seeks the bin that provides the tightest possible\n    fit for the item, leaving the minimum remaining space. This aims to conserve\n    larger empty spaces for future, potentially larger, items, much like\n    observing the efficient ordering of the cosmos.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable bin. Bins where the item\n        cannot fit will have a very low (negative infinity) priority.\n    \"\"\"\n    # Initialize all priorities to a very low value. Bins where the item\n    # cannot fit should essentially be disqualified.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins have sufficient remaining capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item can fit, calculate the \"goodness\" of the fit.\n    # We desire the bin that leaves the smallest amount of free space after\n    # the item is placed (i.e., (remaining_capacity - item) is minimized).\n    # To achieve this with a maximum priority score, we use the negative of\n    # this difference. A smaller positive difference results in a larger\n    # (less negative, closer to zero) priority score.\n    # For example:\n    #   - If remaining_capacity - item = 0 (perfect fit), priority = 0.\n    #   - If remaining_capacity - item = 5 (loose fit), priority = -5.\n    #   - If remaining_capacity - item = 1 (tight fit), priority = -1.\n    # The maximum priority will correspond to the tightest fit.\n    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    As a black hole theorist, I seek to maximize the 'density' of our bins,\n    minimizing the 'cosmic voids' (empty space) within them. This heuristic\n    aims for a 'Best Fit' approach by prioritizing bins that will result in\n    the smallest remaining capacity, much like matter striving to coalesce\n    into the densest possible configuration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities. Bins that cannot fit the item are given an\n    # infinitely low priority, ensuring they are not considered.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'event horizons' where an item can be pulled in.\n    # These are the bins with sufficient remaining capacity.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins that can accommodate the item, calculate the 'residual energy'\n    # \u2013 the capacity that would remain after the item is placed.\n    # Our goal is to minimize this residual space, creating a tighter,\n    # more efficient packing.\n    residual_capacity = bins_remain_cap[can_fit_mask] - item\n\n    # To select the bin with the smallest residual capacity (the 'Best Fit'),\n    # we assign a priority that is the negative of this residual.\n    # Thus, a smaller positive residual results in a larger (less negative) priority.\n    # This reflects our cosmic imperative: to pack things as densely as possible.\n    priorities[can_fit_mask] = -residual_capacity\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    My boys, we want to pack these little items like electrons finding their lowest energy states!\n    We're looking for stability here. When a particle (our 'item') settles into a potential well (a 'bin'),\n    it seeks to minimize its potential energy. In bin packing, this means minimizing the 'waste'\n    or the 'void' left in the bin. A bin that's nearly full or perfectly filled after receiving an item?\n    That's a stable, low-energy state, and that's where we want our particle to go!\n\n    So, let's quantify this 'stability'. The less capacity left over, the more stable the bin's state.\n    A perfect fit, leaving zero capacity, is the absolute ground state, score 1!\n    As the leftover space increases, the \"energy\" of that state rises, and its probability (or priority)\n    of being chosen should drop sharply. An exponential decay feels right here \u2013 like probabilities in\n    a Boltzmann distribution, favoring the lower energy configurations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score means higher priority.\n    \"\"\"\n    # First, let's assume no bin is suitable (very low priority, like an infinitely high energy barrier).\n    # We use -np.inf to ensure that if a valid bin exists, it will always be chosen over an invalid one.\n    # Ensure the scores array is float to accommodate -np.inf and exp results.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the \"quantum wells\" where our \"item-particle\" can actually fit.\n    # No quantum tunneling here, folks; if it doesn't fit, it just doesn't fit!\n    can_fit_mask = bins_remain_cap >= item\n\n    # For those bins where the item *can* fit, let's calculate the 'energy' of the new state.\n    # This 'energy' is simply the leftover space. We want to minimize this.\n    remaining_after_placement = bins_remain_cap[can_fit_mask] - item\n\n    # Now, assign the priority based on this energy.\n    # The lower the 'energy' (less remaining_after_placement), the higher the priority.\n    # The exponential function `exp(-x)` means:\n    # - If `x` (leftover) is 0 (perfect fit), score is `exp(0) = 1.0`. Highest priority!\n    # - If `x` is small, score is close to 1.0.\n    # - If `x` is large, score rapidly drops towards 0.\n    # This precisely mimics our quantum intuition: perfect fits are paramount,\n    # and \"good\" fits are heavily preferred over \"okay\" fits.\n    scores[can_fit_mask] = np.exp(-remaining_after_placement)\n\n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic aims to implement a variant of the \"Best Fit\" strategy,\n    prioritizing bins that, after accommodating the item, would have the\n    smallest remaining capacity (i.e., the tightest fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates higher priority. Bins that cannot fit the item\n        are assigned a very low (negative infinity) priority.\n    \"\"\"\n    # Initialize priorities for all bins to a very low value.\n    # This ensures bins that cannot fit the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can accommodate the current item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit, calculate the \"slack\" \u2013 the remaining capacity\n    # after the item is placed.\n    slack = bins_remain_cap[can_fit_mask] - item\n\n    # For a Best Fit strategy, we want to minimize this slack.\n    # To convert this into a priority score where higher is better (for np.argmax),\n    # we can use the negative of the slack.\n    # A smaller (closer to zero) positive slack will result in a larger\n    # (closer to zero or positive) priority score.\n    # For example, if slack is 0.1, priority is -0.1. If slack is 0.0 (perfect fit),\n    # priority is 0.0 (the highest possible for this scheme).\n    # If slack is 0.5, priority is -0.5.\n    priorities[can_fit_mask] = -slack\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic implements a \"Best Fit\" strategy, prioritizing bins\n    that, after accommodating the item, would leave the smallest amount of\n    remaining space. This aims to keep bins as \"tightly packed\" as possible,\n    reserving larger empty spaces for potentially larger future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining space in each bin if the item were placed there.\n    # A negative value here means the item does not fit.\n    potential_remain_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores.\n    # We use a float array to allow for -np.inf.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify which bins can actually fit the item (remaining capacity >= 0).\n    can_fit_mask = potential_remain_after_placement >= 0\n\n    # For bins that can fit the item:\n    # The priority is the negative of the remaining space.\n    # A smaller remaining space (e.g., 0.1) will result in a larger negative score (-0.1).\n    # A larger remaining space (e.g., 0.5) will result in a smaller negative score (-0.5).\n    # Since we want to choose the bin with the HIGHEST priority score,\n    # minimizing `potential_remain_after_placement` corresponds to maximizing\n    # `-potential_remain_after_placement`. This is the core of Best Fit.\n    priorities[can_fit_mask] = -potential_remain_after_placement[can_fit_mask]\n\n    # For bins that cannot fit the item:\n    # Assign a very low priority (negative infinity) to ensure they are never\n    # selected if there is any bin that can accommodate the item.\n    priorities[~can_fit_mask] = -np.inf\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]