[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is closest to the remaining capacity, thereby minimizing waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Give higher priority to bins with more remaining capacity and smaller differences\n    priority_scores = bins_remain_cap / (capacity_diff + 1e-8)\n    \n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 23.264662506490403,
    "mi": 75.16242651678003,
    "token_count": 53.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on how close their remaining capacity is to the item size.\n    Bins with a remaining capacity closest to the item size get the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins with smaller differences\n                              1 / (1 + diff))\n    return priority_score",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 23.264662506490403,
    "mi": 75.16242651678003,
    "token_count": 53.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on minimizing waste and \n    optimizing item-bin size ratios, encouraging efficient packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste that would be left in each bin if the item were added\n    waste = np.maximum(bins_remain_cap - item, 0)\n    \n    # Calculate the ratio of the item size to the remaining capacity of each bin\n    ratio = np.abs(1 - (item / (bins_remain_cap + 1e-9)))  # Add a small value to avoid division by zero\n    \n    # Calculate the priority score for each bin based on the waste and ratio\n    priority = 1 / (waste + 1e-9 + ratio)  \n    \n    # Ensure that bins with insufficient capacity have a priority of zero\n    priority[bins_remain_cap < item] = 0\n    \n    return priority",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 23.264662506490403,
    "mi": 75.16242651678003,
    "token_count": 53.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins that can fit the item and have the most remaining capacity \n    closest to the item size, thereby minimizing waste and reducing the number of bins needed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the number of bins\n    num_bins = len(bins_remain_cap)\n    \n    # Initialize the priority array with negative infinity values\n    priority = np.full(num_bins, -np.inf)\n    \n    # For each bin\n    for i in range(num_bins):\n        # If the bin can fit the item\n        if bins_remain_cap[i] >= item:\n            # Prioritize bins with remaining capacity closest to the item size\n            priority[i] = -np.abs(bins_remain_cap[i] - item)\n    \n    return priority",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999968280004396 seconds"
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity to the item size.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is the ratio of the item size to the remaining capacity\n                              item / (bins_remain_cap + 1e-6))\n    return priority_score",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 23.264662506490403,
    "mi": 75.16242651678003,
    "token_count": 53.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins that have the least amount of remaining capacity \n    and can still fit the item. If a bin cannot fit the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # Bins that can fit the item have a priority score that is the negative of their remaining capacity\n    # Bins that cannot fit the item have a priority score of negative infinity\n    priority_scores = np.where(bins_remain_cap >= item, -bins_remain_cap, -np.inf)\n    \n    # Return the priority scores\n    return priority_scores",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 23.264662506490403,
    "mi": 75.16242651678003,
    "token_count": 53.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on how close their remaining capacity is to the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    # This gives us a measure of how close each bin's capacity is to the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + diff))\n    \n    # To break ties, prioritize bins with more remaining capacity\n    max_priority = np.max(priority_score)\n    priority_score = np.where(priority_score == max_priority, \n                              priority_score * (1 + bins_remain_cap / (1 + np.sum(bins_remain_cap))), \n                              priority_score)\n    \n    return priority_score",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 23.264662506490403,
    "mi": 75.16242651678003,
    "token_count": 53.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the absolute difference between the remaining capacity and the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate a mask to avoid adding the item to a bin where it doesn't fit\n    item_fits = bins_remain_cap >= item\n    \n    # Invert the differences to give higher priority to bins with smaller differences\n    priority_scores = np.where(item_fits, 1 / (capacity_diff + 1e-8), 0)\n    \n    return priority_scores",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 23.264662506490403,
    "mi": 75.16242651678003,
    "token_count": 53.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function favors bins that have enough capacity to hold the item and \n    also prefer bins with the least remaining capacity, which indicates that the bin is almost full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity that is enough to hold the item\n    valid_cap = np.where(bins_remain_cap >= item, bins_remain_cap - item, np.inf)\n    \n    # Set the priority score as the inverse of the valid capacity, favoring bins with the least remaining capacity\n    priority_score = 1 / np.maximum(valid_cap, 1e-6)\n    \n    # Return the priority scores for each bin\n    return priority_score",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 23.264662506490403,
    "mi": 75.16242651678003,
    "token_count": 53.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity to the item size.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              item / (bins_remain_cap + item))\n    return priority_score",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 23.264662506490403,
    "mi": 75.16242651678003,
    "token_count": 53.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have the least remaining capacity but can still accommodate the item.\n    It favors bins with remaining capacity closest to the item size, to minimize waste and maximize bin utilization.\n    For bins with the same remaining capacity, it prioritizes bins with capacity closest to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the mask for feasible bins (bins that can accommodate the item)\n    feasible_mask = bins_remain_cap >= item\n\n    # Calculate the difference between the remaining capacity of each feasible bin and the item size\n    diff = np.abs(bins_remain_cap - item)\n\n    # Calculate the priority score for each feasible bin\n    priority = feasible_mask.astype(float) / (1 + diff)\n\n    # Add an additional factor to prioritize bins with the least remaining capacity\n    priority[feasible_mask] *= (1 / (1 + (bins_remain_cap[feasible_mask] - item) / item))\n\n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 110.36149671375918,
    "mi": 63.201435402773406,
    "token_count": 95.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have the least remaining capacity but can still accommodate the item.\n    It favors bins with remaining capacity closest to the item size, to minimize waste and maximize bin utilization.\n    For bins with the same remaining capacity, it prioritizes bins with capacity closest to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the mask for feasible bins (bins that can accommodate the item)\n    feasible_mask = bins_remain_cap >= item\n\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    diff = np.abs(bins_remain_cap - item)\n\n    # Calculate the ratio of the remaining capacity to the item size for each bin\n    ratio = bins_remain_cap / item\n\n    # Calculate the priority score for each bin\n    # Higher scores indicate a better fit\n    priority = np.where(feasible_mask, \n                        1 / (1 + diff) * (1 / (1 + np.abs(ratio - 1))), \n                        0)\n\n    return priority",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 110.36149671375918,
    "mi": 63.201435402773406,
    "token_count": 95.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have the least remaining capacity but can still accommodate the item.\n    It favors bins with remaining capacity closest to the item size, to minimize waste and maximize bin utilization.\n    For bins with the same remaining capacity, it prioritizes bins with capacity closest to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the mask for feasible bins (bins that can accommodate the item)\n    feasible_mask = bins_remain_cap >= item\n\n    # Calculate the difference between the remaining capacity of each feasible bin and the item size\n    diff = np.abs(bins_remain_cap - item)\n\n    # Calculate the priority score for each feasible bin\n    priority = feasible_mask.astype(int) / (1 + diff)\n\n    # To break ties, use the ratio of the item size to the remaining capacity\n    ratio = bins_remain_cap / item\n    ratio = np.where(ratio > 1, ratio, 1)  # Clip ratio to be at least 1\n    priority += feasible_mask.astype(int) / (1 + ratio)\n\n    # For bins that can't accommodate the item, set their priority score to 0\n    priority[bins_remain_cap < item] = 0\n\n    return priority",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 110.36149671375918,
    "mi": 63.201435402773406,
    "token_count": 95.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to accommodate the item.\n    It favors bins with remaining capacity closest to the item size, to minimize waste and maximize bin utilization.\n    Additionally, it prioritizes feasible bins with the least remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    diff = np.abs(bins_remain_cap - item)\n\n    # Calculate the ratio of the item size to the remaining capacity of each bin\n    ratio = np.where(bins_remain_cap == 0, 0, item / bins_remain_cap)\n\n    # Calculate the priority score for each bin, with higher scores indicating a better fit\n    priority = np.where(bins_remain_cap < item, 0, 1 / (1 + diff) * ratio)\n\n    # If there are multiple bins with the same priority score, prioritize the one with the least remaining capacity\n    max_priority = np.max(priority)\n    if max_priority > 0:\n        least_cap_bins = np.where(priority == max_priority)[0]\n        min_cap = np.min(bins_remain_cap[least_cap_bins])\n        priority[np.where(bins_remain_cap > min_cap)[0]] = 0\n\n    return priority",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 110.36149671375918,
    "mi": 63.201435402773406,
    "token_count": 95.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have the least remaining capacity but can still accommodate the item.\n    It favors bins with remaining capacity closest to the item size, to minimize waste and maximize bin utilization.\n    For bins with the same remaining capacity, it prioritizes bins with capacity closest to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the mask for feasible bins (bins that can accommodate the item)\n    feasible_mask = bins_remain_cap >= item\n\n    # Calculate the difference between the remaining capacity of each feasible bin and the item size\n    diff = np.abs(bins_remain_cap - item)\n\n    # Calculate the priority score for each feasible bin\n    priority = feasible_mask.astype(float) / (1 + diff)\n\n    # Add an additional factor to prioritize bins with the least remaining capacity\n    priority[feasible_mask] *= (1 / (1 + (bins_remain_cap[feasible_mask] - item) / item))\n\n    return priority",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 110.36149671375918,
    "mi": 63.201435402773406,
    "token_count": 95.0,
    "exec_success": true
  }
]