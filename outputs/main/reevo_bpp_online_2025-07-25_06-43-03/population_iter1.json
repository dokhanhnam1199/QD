[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to accommodate the item.\n    It favors bins with remaining capacity closest to the item size, to minimize waste and maximize bin utilization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    diff = np.abs(bins_remain_cap - item)\n\n    # Calculate the priority score for each bin, with higher scores indicating a better fit\n    priority = 1 / (1 + diff)\n\n    # For bins that can't accommodate the item, set their priority score to 0\n    priority[bins_remain_cap < item] = 0\n\n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins that have the least amount of remaining capacity and \n    can still fit the item. If a bin cannot fit the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the minimum remaining capacity for each bin that can still fit the item\n    min_remain_cap = np.where(bins_remain_cap >= item, bins_remain_cap, np.inf)\n    \n    # Calculate the priority score for each bin based on the minimum remaining capacity\n    priority_scores = np.where(bins_remain_cap >= item, -min_remain_cap, -np.inf)\n    \n    # Return the priority scores\n    return priority_scores\n\ndef priority_v3(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins that have the least amount of remaining capacity \n    relative to the item size and can still fit the item. If a bin cannot fit the item, its \n    priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the ratio of remaining capacity to item size for each bin that can still fit the item\n    ratio = np.where(bins_remain_cap >= item, bins_remain_cap / (bins_remain_cap + item), np.inf)\n    \n    # Calculate the priority score for each bin based on the ratio\n    priority_scores = np.where(bins_remain_cap >= item, -ratio, -np.inf)\n    \n    # Return the priority scores\n    return priority_scores",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has a higher remaining capacity compared to the item size, it gets a higher priority.\n    Additionally, bins with lower remaining capacities are prioritized over those with higher remaining capacities,\n    to ensure that bins are fully utilized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    with np.errstate(divide='ignore', invalid='ignore'):\n        # Calculate the ratio of the remaining capacity and the item size\n        ratios = bins_remain_cap / (item + 1e-9)  # Add a small value to item to avoid division by zero\n\n        # Calculate a mask to avoid adding the item to a bin where it doesn't fit\n        item_fits = bins_remain_cap >= item\n\n        # Calculate the priority score as the ratio of item size and the remaining capacity of the bin,\n        # if the item fits in the bin\n        priority_scores = np.where(item_fits, ratios, 0)\n\n        # Lower remaining capacity bins get more priority\n        priority_scores = np.where(item_fits, priority_scores * (1 / (bins_remain_cap + 1e-9)), 0)\n\n    return priority_scores",
    "response_id": 3,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the minimum remaining capacity required to pack the item\n    min_required_cap = item\n    \n    # Identify bins that have just enough capacity to pack the item\n    exact_fit_bins = bins_remain_cap >= min_required_cap\n    \n    # Prioritize exact fit bins\n    priority = np.where(exact_fit_bins, 1 / (bins_remain_cap + 1e-6), 0)\n    \n    # For bins that are not exact fit, prioritize bins with the least remaining capacity\n    priority = np.where(~exact_fit_bins, 1 / (bins_remain_capauss[:, np.newaxis] + 1e-6), priority)\n    \n    return priority",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 28, in priority_v2\n    non_exact_fit_bins = ~exact_fit_bins\nNameError: name 'bins_remain_capauss' is not defined. Did you mean: 'bins_remain_cap'?\n5\n1\n38.03910001730775\n69.87170528764138\n60\n"
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the minimum remaining capacity required to pack the item\n    min_required_cap = item\n    \n    # Identify bins that have just enough capacity to pack the item\n    exact_fit_bins = bins_remain_cap >= min_required_cap\n    \n    # Prioritize exact fit bins\n    priority = np.where(exact_fit_bins, 1 / (bins_remain_cap + 1e-6), 0)\n    \n    # For bins that are not exact fit, prioritize bins with the least remaining capacity\n    non_exact_fit_bins = ~exact_fit_bins\n    priority_non_exact_fit = (-bins_remain_cap) * non_exact_fit_bins\n    \n    # Combine the two priorities\n    priority[non_exact_fit_bins] = priority_non_exact_fit[non_exact_fit_bins]\n    \n    # Ensure all selected bins have at least the required capacity to pack the item\n    valid_bins = bins_remain_cap >= item\n    priority[~valid_bins] = -np.inf\n    \n    return priority",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins that have the least amount of remaining capacity and \n    can still fit the item. If a bin cannot fit the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the number of bins\n    num_bins = len(bins_remain_cap)\n    \n    # Initialize the priority array with negative infinity values\n    priority = np.full(num_bins, -np.inf)\n    \n    # For each bin\n    for i in range(num_bins):\n        # If the item can fit in the bin\n        if bins_remain_cap[i] >= item:\n            # Calculate the priority score as the negative of the remaining capacity\n            # This prioritizes bins with less remaining capacity\n            priority[i] = -bins_remain_cap[i]\n    \n    return priority",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is close to the remaining capacity, thereby minimizing \n    waste and reducing the number of bins needed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste that would be left in each bin if the item were added\n    waste = np.maximum(bins_remain_cap - item, 0)\n    \n    # Calculate the ratio of the item size to the remaining capacity of each bin\n    ratio = item / (bins_remain_cap + 1e-9)  # Add a small value to avoid division by zero\n    \n    # Calculate the priority score for each bin based on the waste and ratio\n    priority = 1 / (waste + 1e-9) + 1 / (1 + np.abs(ratio - 1))  \n    \n    # Ensure that bins with insufficient capacity have a priority of zero\n    priority[bins_remain_cap < item] = 0\n    \n    return priority",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the minimum remaining capacity required to pack the item\n    min_required_cap = item\n    \n    # Identify bins that have just enough capacity to pack the item\n    exact_fit_bins = bins_remain_cap >= min_required_cap\n    \n    # Prioritize exact fit bins\n    priority = np.where(exact_fit_bins, 1 / (bins_remain_cap + 1e-6), 0)\n    \n    # For bins that are not exact fit, prioritize bins with the least remaining capacity\n    priority = np.where(~exact_fit_bins, 1 / (bins_remain_capauss[:, np.newaxis] + 1e-6), priority)\n    \n    return priority",
    "response_id": 10,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 28, in priority_v2\nNameError: name 'bins_remain_capauss' is not defined. Did you mean: 'bins_remain_cap'?\n5\n1\n38.03910001730775\n69.87170528764138\n60\n"
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has a higher remaining capacity compared to the item size, it gets a higher priority.\n    Additionally, bins with lower remaining capacities are prioritized over those with higher remaining capacities,\n    to ensure that bins are fully utilized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    priority_scores = np.where(valid_bins, (bins_remain_cap / item) * (1 - (bins_remain_cap / 1)), 0)\n    return priority_scores",
    "response_id": 12,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has a higher remaining capacity compared to the item size, it gets a higher priority.\n    Additionally, bins with lower remaining capacities are prioritized over those with higher remaining capacities,\n    to ensure that bins are fully utilized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    priority_scores = np.where(valid_bins, (bins_remain_cap - item) / bins_remain_cap, 0)\n    adjusted_priority_scores = np.where(valid_bins, 1 / (1 + (priority_scores / item) ** 2), 0)\n    return adjusted_priority_scores",
    "response_id": 13,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the minimum remaining capacity required to pack the item\n    min_required_cap = item\n    \n    # Identify bins that have just enough capacity to pack the item\n    exact_fit_bins = bins_remain_cap >= min_required_cap\n    \n    # Prioritize exact fit bins\n    priority = np.where(exact_fit_bins, 1 / (bins_remain_cap + 1e-6), 0)\n    \n    # For bins that are not exact fit, prioritize bins with the least remaining capacity\n    priority = np.where(~exact_fit_bins, 1 / (bins_remain_capauss[:, np.newaxis] + 1e-6), priority)\n    \n    return priority",
    "response_id": 14,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 28, in priority_v2\nNameError: name 'bins_remain_capauss' is not defined. Did you mean: 'bins_remain_cap'?\n5\n1\n38.03910001730775\n69.87170528764138\n60\n"
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have enough capacity to hold the item and \n    also prefer bins with the least remaining capacity, which indicates that the bin is almost full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity that is enough to hold the item\n    valid_cap = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Set the priority score as the inverse of the valid capacity, favoring bins with the least remaining capacity\n    priority_score = -valid_cap\n    \n    # Replace -inf (indicating invalid bins) with very low priority scores\n    priority_score = np.where(priority_score == np.inf, -1e6, priority_score)\n    \n    # Return the priority scores for each bin\n    return priority_score",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the minimum remaining capacity required to pack the item\n    min_required_cap = item\n    \n    # Identify bins that have just enough capacity to pack the item\n    exact_fit_bins = bins_remain_cap >= min_required_cap\n    \n    # Prioritize exact fit bins\n    priority = np.where(exact_fit_bins, 1 / (bins_remain_cap + 1e-6), 0)\n    \n    # For bins that are not exact fit, prioritize bins with the least remaining capacity\n    priority = np.where(~exact_fit_bins, 1 / (bins_remain_capauss[:, np.newaxis] + 1e-6), priority)\n    \n    return priority",
    "response_id": 16,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 28, in priority_v2\n    priority[i] = -bins_remain_cap[i]\nNameError: name 'bins_remain_capauss' is not defined. Did you mean: 'bins_remain_cap'?\n5\n1\n38.03910001730775\n69.87170528764138\n60\n"
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins that have the least amount of remaining capacity and \n    can still fit the item. If a bin cannot fit the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the number of bins\n    num_bins = len(bins_remain_cap)\n    \n    # Initialize the priority array with negative infinity values\n    priority = np.full(num_bins, -np.inf)\n    \n    # For each bin\n    for i in range(num_bins):\n        # If the bin can fit the item\n        if bins_remain_cap[i] >= item:\n            # Prioritize bins with less remaining capacity\n            priority[i] = -bins_remain_cap[i]\n    \n    return priority",
    "response_id": 17,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is close to the remaining capacity, thereby minimizing \n    waste and reducing the number of bins needed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste that would result from adding the item to each bin\n    waste = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score as the inverse of the waste\n    # Add a small value to avoid division by zero\n    priority = 1 / (waste + 1e-6)\n    \n    # Give higher priority to bins with less remaining capacity\n    priority *= (bins_remain_cap - item + 1e-6)\n    \n    # Ensure that bins with more than enough capacity get higher priority\n    priority[bins_remain_cap >= item] *= 2\n    \n    # Return the priority scores\n    return priority",
    "response_id": 18,
    "obj": 4.417630634224167,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the minimum remaining capacity required to pack the item\n    min_required_cap = item\n    \n    # Identify bins that have just enough capacity to pack the item\n    exact_fit_bins = bins_remain_cap >= min_required_cap\n    \n    # Prioritize exact fit bins\n    priority = np.where(exact_fit_bins, 1 / (bins_remain_cap + 1e-6), 0)\n    \n    # For bins that are not exact fit, prioritize bins with the least remaining capacity\n    priority = np.where(~exact_fit_bins, 1 / (bins_remain_capauss[:, np.newaxis] + 1e-6), priority)\n    \n    return priority",
    "response_id": 19,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 28, in priority_v2\nNameError: name 'bins_remain_capauss' is not defined. Did you mean: 'bins_remain_cap'?\n5\n1\n38.03910001730775\n69.87170528764138\n60\n"
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is closest to the remaining capacity, thereby minimizing waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    \n    # Invert the differences to give higher priority to bins with smaller differences\n    priority_scores = 1 / (capacity_diff + 1e-8)  # add a small value to avoid division by zero\n    \n    # Give higher priority to bins with more remaining capacity to discourage overfilling\n    priority_scores *= bins_remain_cap\n    \n    return priority_scores",
    "response_id": 20,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins with the most remaining capacity,\n    while minimizing the waste of space (by adding the item to the bin with the smallest remaining capacity that can still fit the item).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the maximum possible priority for each bin\n    max_priority = np.where(bins_remain_cap >= item, bins_remain_cap, np.iinfo(np.int64).min)\n    \n    # Apply a Gaussian penalty to the priority, favoring bins with more remaining capacity\n    priorities = max_priority - (np.abs(max_priority - item) ** 2) / (2 * np.ones_like(max_priority))\n    \n    return priorities",
    "response_id": 22,
    "obj": 4.457518946948548,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the minimum remaining capacity required to pack the item\n    min_required_cap = item\n    \n    # Identify bins that have just enough capacity to pack the item\n    exact_fit_bins = bins_remain_cap >= min_required_cap\n    \n    # Prioritize exact fit bins\n    priority = np.where(exact_fit_bins, 1 / (bins_remain_cap + 1e-6), 0)\n    \n    # For bins that are not exact fit, prioritize bins with the least remaining capacity\n    priority = np.where(~exact_fit_bins, 1 / (bins_remain_capauss[:, np.newaxis] + 1e-6), priority)\n    \n    return priority",
    "response_id": 23,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 28, in priority_v2\nNameError: name 'bins_remain_capauss' is not defined. Did you mean: 'bins_remain_cap'?\n5\n1\n38.03910001730775\n69.87170528764138\n60\n"
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins that have the least amount of remaining capacity and \n    can still fit the item. If a bin cannot fit the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the number of bins\n    num_bins = len(bins_remain_cap)\n    \n    # Initialize the priority array with negative infinity values\n    priority = np.full(num_bins, -np.inf)\n    \n    # For each bin\n    for i in range(num_bins):\n        # If the bin can fit the item\n        if bins_remain_cap[i] >= item:\n            # Prioritize bins with less remaining capacity\n            priority[i] = -bins_remain_cap[i]\n    \n    return priority",
    "response_id": 25,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is close to the remaining capacity, thereby minimizing \n    waste and reducing the number of bins needed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste if the item is added to each bin\n    waste = np.maximum(0, bins_remain_cap - item)\n    # Calculate the utilization if the item is added to each bin\n    utilization = bins_remain_cap / (bins_remain_cap + item)\n    # Calculate the priority score as the inverse of waste and the utilization\n    priority = 1 / (1 + waste) * utilization\n    return priority",
    "response_id": 27,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is close to the remaining capacity, thereby minimizing \n    waste and reducing the number of bins needed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the waste if the item is added to each bin\n    waste = np.maximum(0, bins_remain_cap - item)\n    \n    # Calculate the priority score as the inverse of the waste\n    # A higher priority is assigned to bins with less waste\n    priority_scores = 1 / (1 + waste)\n    \n    # If the item cannot fit into a bin, set its priority score to 0\n    priority_scores[item > bins_remain_cap] = 0\n    \n    return priority_scores",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 29,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "mi": 69.87170528764138,
    "token_count": 60.0,
    "exec_success": true
  }
]