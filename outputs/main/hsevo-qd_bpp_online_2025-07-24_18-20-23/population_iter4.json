[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin, \n    prioritizing bins with the least remaining capacity after addition.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign priority based on remaining capacity after addition\n    priority = np.where(remaining_cap_after_addition >= 0, \n                        -remaining_cap_after_addition,  # Prioritize bins with least remaining capacity\n                        -np.inf)  # Penalize bins that cannot accommodate the item\n    \n    # Scale priorities to enhance differentiation among viable bins\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  \n        priority = np.where(priority != -np.inf, np.exp(-(priority - max_priority)), priority)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins that can fit the item and have remaining capacity closest to the item size.\n    \"\"\"\n    # Check if bins can fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate the absolute difference between remaining capacity and item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign high priority to valid bins with remaining capacity closest to the item size\n    priority = np.where(valid_bins, -diff + 1 / (bins_remain_cap + 1e-6), -np.inf)\n    \n    return priority",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins that can fit the item with minimal remaining capacity.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap = bins_remain_cap - item\n    \n    # Bins that can fit the item have higher priority based on remaining capacity\n    valid_bins = remaining_cap >= 0\n    \n    # Assign high priority to valid bins with minimal remaining capacity\n    priority = np.where(valid_bins, -remaining_cap, -np.inf)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    Combines elements of 'First-Fit Decreasing' and 'Best-Fit' heuristics.\n    \"\"\"\n    # Prioritize bins where the item fits and leaves minimal remaining capacity\n    priorities = np.where(bins_remain_cap >= item, \n                          1 / (bins_remain_cap - item + 1e-6),  # Best-Fit element: prioritize bins with least remaining capacity\n                          -1.0)  # Penalize bins that can't fit the item\n    \n    # Adjust priorities to ensure bins that can't fit the item have lower priority\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins with remaining capacity closest to the item size and minimizes waste.\n    \"\"\"\n    # Calculate priority based on the absolute difference between remaining capacity and item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Set priority to negative infinity for bins that cannot fit the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores for bins that can fit the item\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(priority[valid_bins] - max_priority))\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining the 'best fit' and 'valid bin' heuristics.\n    Prioritizes bins that are closest to being full and can still hold the item.\n    \"\"\"\n    # Calculate 'best fit' score: higher for bins with remaining capacity closest to the item size\n    best_fit_scores = np.where(bins_remain_cap >= item, 1 / (np.abs(bins_remain_cap - item) + 1e-6), 0)\n    \n    # Normalize the scores\n    max_score = np.max(best_fit_scores)\n    if max_score > 0:\n        best_fit_scores /= max_score\n    \n    # Combine with 'valid bin' indicator to ensure only valid bins are considered\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    priority = best_fit_scores * valid_bins\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Combines the benefits of prioritizing bins with enough capacity and minimizing waste.\n    \"\"\"\n    # Check if the item can fit in each bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Higher priority for bins with less remaining capacity after adding the item\n    priority_scores = np.where(valid_bins == 1, 1 / (bins_remain_cap + 1e-6), -1.0)\n    \n    # Modify the priority scores to also consider the fullness of the bin\n    fullness_factor = 1 + (1 - (bins_remain_cap - item) / bins_remain_cap)\n    priority_scores = np.where(valid_bins == 1, priority_scores * fullness_factor, priority_scores)\n    \n    return priority_scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and fullness.\n    \n    Combines the benefits of minimizing waste and prioritizing almost full bins.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Mask out bins that cannot hold the item\n    valid_bins = remaining_capacity_after_addition >= 0\n    \n    # Priority score is a combination of remaining capacity and fullness\n    priority_scores = np.where(valid_bins, np.exp(-remaining_capacity_after_addition) + bins_remain_cap / (item + 1e-9), -1e10)\n    \n    return priority_scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 88.05345033905067,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity after adding the item.\n    Combines elements of minimizing waste and prioritizing almost full bins.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Prioritize bins that can hold the item and will have the least remaining capacity\n    priority = np.where(remaining_cap_after_addition >= 0, \n                        # Combine the negative remaining capacity with a fullness factor\n                        -remaining_cap_after_addition + bins_remain_cap / (item + 1e-9), \n                        -np.inf)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Prioritizes bins that are almost full and can fit the item, minimizing waste.\n    \"\"\"\n    # Check if the item can fit in each bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate priority based on remaining capacity after adding the item\n    priority_scores = np.where(valid_bins > 0, 1 / (bins_remain_cap + 1e-6), 0)\n    \n    # Combine the two priorities, giving higher priority to valid bins that are almost full\n    priority = valid_bins * (1 + priority_scores)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a combination of prioritization strategies.\n\n    The heuristic used here combines multiple strategies to prioritize bins that have just enough capacity for the item, \n    and penalizes bins that would be left with too much or too little remaining capacity. It also considers the relative \n    remaining capacity of the bins to diversify the prioritization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    fit_priority = np.where(bins_remain_cap >= item, \n                            1 - np.abs(bins_remain_cap - item) / item,  # Prioritize bins with remaining capacity close to the item size\n                            -1.0)  # Penalize bins that can't fit the item\n    \n    # Calculate a secondary priority based on the relative remaining capacity after adding the item\n    relative_cap_priority = np.where(bins_remain_cap >= item, \n                                     (bins_remain_cap - item) / bins_remain_cap,  # Prioritize bins that are filled to a high level\n                                     -1.0)  # Penalize bins that can't fit the item\n    \n    # Combine the two priorities using a weighted sum\n    priorities = 0.7 * fit_priority + 0.3 * relative_cap_priority\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 227.5489532989615,
    "mi": 71.05680482672973,
    "token_count": 139.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a more advanced heuristic.\n\n    The heuristic used here combines multiple prioritization strategies to adapt to various scenarios.\n    It prioritizes bins that have just enough capacity for the item, leaves a reasonable remainder, and considers the bin's fill level.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the capacity remaining after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Prioritize bins where the item fits and leaves a reasonable remainder (not too much or too little)\n    fit_priority = np.where(bins_remain_cap >= item, \n                            1 - np.abs(remaining_after_addition) / (bins_remain_cap + 1e-9),  # Avoid division by zero\n                            -1.0)  # Penalize bins that can't fit the item\n    \n    # Encourage filling bins that are nearly empty (to reduce fragmentation) and penalize bins that are too full\n    fill_level_priority = np.where(bins_remain_cap >= item, \n                                   1 - (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-9),  # Normalize fill level\n                                   0.0)  # Neutral for bins that can't fit the item\n    \n    # Combine the two priorities, giving more weight to the fit priority\n    priorities = 0.7 * fit_priority + 0.3 * fill_level_priority\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 227.5489532989615,
    "mi": 71.05680482672973,
    "token_count": 139.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a more sophisticated heuristic.\n\n    The heuristic used here combines multiple prioritization strategies to adapt to various scenarios.\n    It prioritizes bins that have just enough capacity for the item, penalizes bins that would be left with too much or too little remaining capacity,\n    and also considers the relative remaining capacity to encourage a more balanced bin utilization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    fit_priority = np.where(bins_remain_cap >= item, \n                            1 - np.abs(bins_remain_cap - item) / item,  # Prioritize bins with remaining capacity close to the item size\n                            -1.0)  # Penalize bins that can't fit the item\n    \n    # Calculate a secondary priority based on the relative remaining capacity after adding the item\n    # This encourages using bins in a way that balances their remaining capacities\n    relative_cap_priority = np.where(bins_remain_cap >= item, \n                                      (bins_remain_cap - item) / bins_remain_cap,  # Higher priority for bins that are more full after adding the item\n                                      -1.0)\n    \n    # Combine the two priorities\n    # The first priority ensures we prefer bins that fit the item well, and the second priority helps in balancing the bin usage\n    priorities = fit_priority + 0.5 * relative_cap_priority\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 227.5489532989615,
    "mi": 71.05680482672973,
    "token_count": 139.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a more sophisticated heuristic.\n\n    The heuristic used here combines multiple prioritization strategies to adapt to different scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    fit_priority = np.where(bins_remain_cap >= item, \n                            1 - np.abs(bins_remain_cap - item) / item,  # Prioritize bins with remaining capacity close to the item size\n                            -1.0)  # Penalize bins that can't fit the item\n    \n    # Prioritize bins that are relatively full to minimize the number of bins used\n    fullness_priority = np.where(bins_remain_cap >= item, \n                                 1 - bins_remain_cap / (item + bins_remain_cap - item + 1e-6),  # Avoid division by zero\n                                 -1.0)\n    \n    # Combine the two prioritization strategies\n    priorities = 0.6 * fit_priority + 0.4 * fullness_priority\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 227.5489532989615,
    "mi": 71.05680482672973,
    "token_count": 139.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a combination of multiple heuristics.\n\n    The heuristic used here combines the 'First-Fit Decreasing' algorithm with a 'Best-Fit' strategy, \n    and adds an additional term to prioritize bins that are more full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the 'Best-Fit' score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits and leaves a small remainder\n    best_fit_scores = np.where(bins_remain_cap >= item, \n                               1 - np.abs(bins_remain_cap - item) / item,  # Prioritize bins with remaining capacity close to the item size\n                               -1.0)  # Penalize bins that can't fit the item\n\n    # Calculate the 'Fullness' score for each bin based on its remaining capacity\n    # We want to prioritize bins that are more full (i.e., have less remaining capacity)\n    fullness_scores = np.where(bins_remain_cap >= item, \n                               1 - bins_remain_cap / (item + bins_remain_cap - item + 1e-6),  # Prioritize bins that are more full\n                               -1.0)  # Penalize bins that can't fit the item\n\n    # Combine the 'Best-Fit' and 'Fullness' scores into a single priority score\n    priorities = 0.7 * best_fit_scores + 0.3 * fullness_scores\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 227.5489532989615,
    "mi": 71.05680482672973,
    "token_count": 139.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0005808774091321647) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins that can fit the item and have remaining capacity closest to the item size.\n    \"\"\"\n    # Check if bins can fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate the absolute difference between remaining capacity and item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign high priority to valid bins with remaining capacity closest to the item size\n    priority = np.where(valid_bins, -diff + 1 / (bins_remain_cap + epsilon), -np.inf)\n    \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 88.48095635181713,
    "token_count": 84.0,
    "exec_success": true
  }
]