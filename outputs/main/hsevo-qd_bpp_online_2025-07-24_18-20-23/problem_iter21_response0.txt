```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using an enhanced heuristic.

    The heuristic combines relative fit, proportion of capacity used, and nuanced normalization to prioritize bins.
    It differentiates among viable options and handles edge cases effectively.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the priority score for each bin based on the remaining capacity
    # Prioritize bins where the item fits, considering both relative fit and capacity utilization
    priorities = np.where(bins_remain_cap >= item,
                          (1 - np.abs(bins_remain_cap - item) / (bins_remain_cap + item)) * (item / bins_remain_cap),
                          -1.0)  # Penalize bins that can't fit the item

    # Normalize the priorities to ensure numerical stability and enhance differentiation
    max_priority = np.max(priorities)
    min_priority = np.min(priorities)
    if max_priority > -1.0:  # Check if there are bins that can fit the item
        priorities = np.where(priorities > -1.0, (priorities - min_priority) / (max_priority - min_priority), -1.0)

    # Differentiate among bins that can fit the item by adjusting priorities based on remaining capacity
    priorities = np.where((bins_remain_cap >= item) & (bins_remain_cap < 2 * item),
                          priorities * 1.1,  # Boost priority for bins with relatively low remaining capacity
                          np.where((bins_remain_cap >= item) & (bins_remain_cap >= 2 * item),
                                   priorities * 0.9,  # Slightly reduce priority for bins with high remaining capacity
                                   priorities))

    return priorities
```
