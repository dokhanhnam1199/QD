```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using an enhanced heuristic.

    The heuristic combines multiple strategies to prioritize bins based on their remaining capacity,
    focusing on nuanced prioritization, normalization, and differentiation among viable options.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # First, identify bins that can fit the item
    can_fit = bins_remain_cap >= item
    
    # Calculate a 'fit score' that rewards bins where the item fits snugly
    fit_score = np.where(can_fit, 1 - np.abs(bins_remain_cap - item) / (bins_remain_cap + item + 1e-9), 0)
    
    # Calculate a 'utilization score' that rewards bins that will have a high utilization after adding the item
    utilization_score = np.where(can_fit, item / (bins_remain_cap + 1e-9), 0)
    
    # Combine the fit score and utilization score into a single priority score
    priorities = fit_score * utilization_score
    
    # Normalize the priorities for numerical stability
    max_priority = np.max(priorities)
    if max_priority > 0:
        priorities = np.where(can_fit, priorities / max_priority, -1.0)
    else:
        priorities = np.where(can_fit, 1.0, -1.0)  # All bins that can fit get equal priority if max_priority is 0
    
    # Slightly penalize bins with very high remaining capacity to encourage packing items tightly
    priorities = np.where((can_fit) & (bins_remain_cap > item * 2), priorities * 0.8, priorities)
    
    return priorities
```
