{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(remaining_cap_after_addition >= 0, \n                        # For bins that can accommodate the item, prioritize those with the least remaining capacity\n                        -remaining_cap_after_addition, \n                        # For bins that cannot accommodate the item, assign a very low priority\n                        -np.inf)\n    \n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin. \n    Bins with remaining capacity closest to the item size are given the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Bins that can fit the item have higher priority\n    valid_bins = bins_remain_cap >= item\n    \n    # Assign high priority to valid bins with remaining capacity closest to the item size\n    priority = np.where(valid_bins, -diff, -np.inf)\n    \n    return priority\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin. \n    Bins with remaining capacity closest to the item size are given the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Bins that can fit the item have higher priority\n    valid_bins = bins_remain_cap >= item\n    \n    # Assign high priority to valid bins with remaining capacity closest to the item size\n    priority = np.where(valid_bins, -diff, -np.inf)\n    \n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a more sophisticated heuristic.\n\n    The heuristic used here is a variant of the 'First-Fit Decreasing' algorithm adapted for online bin packing.\n    It prioritizes bins that have just enough capacity for the item, and penalizes bins that would be left with too much or too little remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    priorities = np.where(bins_remain_cap >= item, \n                          1 - np.abs(bins_remain_cap - item) / item,  # Prioritize bins with remaining capacity close to the item size\n                          -1.0)  # Penalize bins that can't fit the item\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n    If a bin cannot fit the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin with remaining capacity closest to the item size gets the highest priority\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # If a bin cannot fit the item, set its priority to negative infinity\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still hold the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high when the bin has just enough capacity for the item\n    scores = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1e-6), 0)\n    \n    # Normalize the scores to avoid division by zero and ensure they are within a comparable range\n    max_score = np.max(scores)\n    if max_score > 0:\n        scores /= max_score\n    \n    return scores\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item and have less remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high when the bin has enough capacity and low remaining capacity\n    priority_scores = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap + 1e-6), -1.0)\n    \n    # Return the priority scores\n    return priority_scores\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Mask out bins that cannot hold the item (i.e., remaining capacity would be negative)\n    valid_bins = remaining_capacity_after_addition >= 0\n    \n    # Priority score is the remaining capacity after addition for valid bins, \n    # and a very low score for bins that cannot hold the item\n    priority_scores = np.where(valid_bins, remaining_capacity_after_addition, -1e10)\n    \n    # To encourage packing items tightly, we can use a non-linear scoring function, \n    # e.g., exp(-remaining_capacity_after_addition) for valid bins\n    priority_scores = np.where(valid_bins, np.exp(-remaining_capacity_after_addition), -1e10)\n    \n    return priority_scores\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin after adding the item.\n    The bin that will have the least remaining capacity after adding the item will have the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Set the priority to negative infinity for bins that cannot hold the item\n    priority = np.where(remaining_cap_after_addition >= 0, -remaining_cap_after_addition, -np.inf)\n    \n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # If the item can fit in the bin, the priority score is inversely proportional to the remaining capacity\n    # If the item cannot fit in the bin, the priority score is 0\n    priority_scores = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap + 1e-6), 0)\n    \n    return priority_scores\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # For each bin, check if the item can fit\n    # Assign high priority to bins that can fit the item and have the least remaining capacity\n    # Assign low priority (negative infinity) to bins that cannot fit the item\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap + 1e-6), -np.inf)\n    \n    # To avoid division by zero, we add a small value (1e-6) to bins_remain_cap\n    \n    # Normalize the priority scores to be between 0 and 1 for bins that can fit the item\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  # Check if there is at least one bin that can fit the item\n        priority = np.where(priority != -np.inf, (priority - (-np.inf)) / (max_priority - (-np.inf)), -np.inf)\n    \n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # For each bin, check if the item can fit\n    # Assign high priority to bins that can fit the item and have the least remaining capacity\n    # Assign low priority (negative infinity) to bins that cannot fit the item\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap + 1e-6), -np.inf)\n    \n    # To avoid division by zero, we add a small value (1e-6) to bins_remain_cap\n    \n    # Normalize the priority scores to be between 0 and 1 for bins that can fit the item\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  # Check if there is at least one bin that can fit the item\n        priority = np.where(priority != -np.inf, (priority - (-np.inf)) / (max_priority - (-np.inf)), -np.inf)\n    \n    return priority\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # For each bin, check if the item can fit\n    # Assign high priority to bins that can fit the item and have the least remaining capacity\n    # Assign low priority (negative infinity) to bins that cannot fit the item\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap + 1e-6), -np.inf)\n    \n    # To avoid division by zero, we add a small value (1e-6) to bins_remain_cap\n    \n    # Normalize the priority scores to be between 0 and 1 for bins that can fit the item\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  # Check if there is at least one bin that can fit the item\n        priority = np.where(priority != -np.inf, (priority - (-np.inf)) / (max_priority - (-np.inf)), -np.inf)\n    \n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority (negative infinity) to bins that cannot accommodate the item\n    priority = np.where(remaining_capacity_after_addition >= 0, -remaining_capacity_after_addition, -np.inf)\n    \n    # Normalize the priority scores to make them more comparable\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  # Check if there are bins that can accommodate the item\n        priority = np.where(priority != -np.inf, np.exp(-(priority - max_priority)), priority)\n    return priority\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority (negative infinity) to bins that cannot accommodate the item\n    priority = np.where(remaining_capacity_after_addition >= 0, -remaining_capacity_after_addition, -np.inf)\n    \n    # Normalize the priority scores to make them more comparable\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  # Check if there are bins that can accommodate the item\n        priority = np.where(priority != -np.inf, np.exp(-(priority - max_priority)), priority)\n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # For each bin, check if the item can fit\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Higher priority for bins that are almost full (to minimize waste)\n    fullness_priority = bins_remain_cap / (item + 1e-9)\n    \n    # Combine the two priorities, giving higher priority to valid bins that are almost full\n    priority = valid_bins * (1 + fullness_priority)\n    \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # For each bin, check if the item can fit\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Higher priority for bins that are almost full (to minimize waste)\n    fullness_priority = bins_remain_cap / (item + 1e-9)\n    \n    # Combine the two priorities, giving higher priority to valid bins that are almost full\n    priority = valid_bins * (1 + fullness_priority)\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # For each bin, check if the item can fit\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Higher priority for bins that are almost full (to minimize waste)\n    fullness_priority = bins_remain_cap / (item + 1e-9)\n    \n    # Combine the two priorities, giving higher priority to valid bins that are almost full\n    priority = valid_bins * (1 + fullness_priority)\n    \n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # For each bin, check if the item can fit\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Higher priority for bins that are almost full (to minimize waste)\n    fullness_priority = bins_remain_cap / (item + 1e-9)\n    \n    # Combine the two priorities, giving higher priority to valid bins that are almost full\n    priority = valid_bins * (1 + fullness_priority)\n    \n    return priority\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # For each bin, check if the item can fit\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Higher priority for bins that are almost full (to minimize waste)\n    fullness_priority = bins_remain_cap / (item + 1e-9)\n    \n    # Combine the two priorities, giving higher priority to valid bins that are almost full\n    priority = valid_bins * (1 + fullness_priority)\n    \n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}