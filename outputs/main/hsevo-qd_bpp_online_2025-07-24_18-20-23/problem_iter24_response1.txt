```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using an advanced heuristic.

    The heuristic used here enhances the prioritization strategy by considering not just the fit and proportion of capacity used,
    but also introduces a new dimension - the 'waste' or remaining capacity after placing the item. It further refines the differentiation
    among viable bins by applying a non-linear transformation to the priority scores.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # First, identify bins that can fit the item
    can_fit = bins_remain_cap >= item
    
    # Calculate the 'relative fit' - how well the item fits into the bin's remaining capacity
    relative_fit = 1 - np.abs(bins_remain_cap - item) / (bins_remain_cap + item + 1e-9)  # Added a small epsilon to avoid division by zero
    
    # Calculate the 'utilization ratio' - proportion of the bin that will be occupied by the item
    utilization_ratio = item / (bins_remain_cap + 1e-9)
    
    # For bins that can fit the item, compute a 'waste ratio' - the proportion of the bin that remains empty after placing the item
    waste_ratio = (bins_remain_cap - item) / (bins_remain_cap + 1e-9)
    
    # Combine the relative fit, utilization ratio, and waste ratio into a single priority score for bins that can fit the item
    priorities = np.where(can_fit, relative_fit * utilization_ratio * (1 - waste_ratio ** 2), -1.0)
    
    # Apply a non-linear transformation to further differentiate among viable bins
    priorities = np.where(can_fit, np.tanh(priorities * 2), priorities)  # Using tanh to saturate high priorities
    
    # Normalize the priorities to ensure they are within a comparable range
    max_priority = np.max(priorities)
    if max_priority > -1.0:  
        priorities = np.where(priorities > -1.0, priorities / max_priority, priorities)
    
    # Slightly penalize bins with very high remaining capacity after placing the item
    priorities = np.where(can_fit & (bins_remain_cap > item * 1.5), priorities * 0.8, priorities)
    
    return priorities
```
