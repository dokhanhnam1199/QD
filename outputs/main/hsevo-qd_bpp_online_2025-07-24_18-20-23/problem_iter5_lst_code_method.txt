{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0005808774091321647) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins that can fit the item and have remaining capacity closest to the item size.\n    \"\"\"\n    # Check if bins can fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate the absolute difference between remaining capacity and item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign high priority to valid bins with remaining capacity closest to the item size\n    priority = np.where(valid_bins, -diff + 1 / (bins_remain_cap + epsilon), -np.inf)\n    \n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a more sophisticated heuristic.\n\n    The heuristic used here combines multiple prioritization strategies to adapt to different scenarios.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    fit_priority = np.where(bins_remain_cap >= item, \n                            1 - np.abs(bins_remain_cap - item) / item,  # Prioritize bins with remaining capacity close to the item size\n                            -1.0)  # Penalize bins that can't fit the item\n    \n    # Prioritize bins that are relatively full to minimize the number of bins used\n    fullness_priority = np.where(bins_remain_cap >= item, \n                                 1 - bins_remain_cap / (item + bins_remain_cap - item + 1e-6),  # Avoid division by zero\n                                 -1.0)\n    \n    # Combine the two prioritization strategies\n    priorities = 0.6 * fit_priority + 0.4 * fullness_priority\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity after adding the item.\n    Combines elements of minimizing waste and prioritizing almost full bins.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Prioritize bins that can hold the item and will have the least remaining capacity\n    priority = np.where(remaining_cap_after_addition >= 0, \n                        # Combine the negative remaining capacity with a fullness factor\n                        -remaining_cap_after_addition + bins_remain_cap / (item + 1e-9), \n                        -np.inf)\n    \n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining the 'best fit' and 'valid bin' heuristics.\n    Prioritizes bins that are closest to being full and can still hold the item.\n    \"\"\"\n    # Calculate 'best fit' score: higher for bins with remaining capacity closest to the item size\n    best_fit_scores = np.where(bins_remain_cap >= item, 1 / (np.abs(bins_remain_cap - item) + 1e-6), 0)\n    \n    # Normalize the scores\n    max_score = np.max(best_fit_scores)\n    if max_score > 0:\n        best_fit_scores /= max_score\n    \n    # Combine with 'valid bin' indicator to ensure only valid bins are considered\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    priority = best_fit_scores * valid_bins\n    \n    return priority\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a more sophisticated heuristic.\n\n    The heuristic used here combines multiple prioritization strategies to adapt to various scenarios.\n    It prioritizes bins that have just enough capacity for the item, penalizes bins that would be left with too much or too little remaining capacity,\n    and also considers the relative remaining capacity to encourage a more balanced bin utilization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    fit_priority = np.where(bins_remain_cap >= item, \n                            1 - np.abs(bins_remain_cap - item) / item,  # Prioritize bins with remaining capacity close to the item size\n                            -1.0)  # Penalize bins that can't fit the item\n    \n    # Calculate a secondary priority based on the relative remaining capacity after adding the item\n    # This encourages using bins in a way that balances their remaining capacities\n    relative_cap_priority = np.where(bins_remain_cap >= item, \n                                      (bins_remain_cap - item) / bins_remain_cap,  # Higher priority for bins that are more full after adding the item\n                                      -1.0)\n    \n    # Combine the two priorities\n    # The first priority ensures we prefer bins that fit the item well, and the second priority helps in balancing the bin usage\n    priorities = fit_priority + 0.5 * relative_cap_priority\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    Combines elements of 'First-Fit Decreasing' and 'Best-Fit' heuristics.\n    \"\"\"\n    # Prioritize bins where the item fits and leaves minimal remaining capacity\n    priorities = np.where(bins_remain_cap >= item, \n                          1 / (bins_remain_cap - item + 1e-6),  # Best-Fit element: prioritize bins with least remaining capacity\n                          -1.0)  # Penalize bins that can't fit the item\n    \n    # Adjust priorities to ensure bins that can't fit the item have lower priority\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    Combines elements of 'First-Fit Decreasing' and 'Best-Fit' heuristics.\n    \"\"\"\n    # Prioritize bins where the item fits and leaves minimal remaining capacity\n    priorities = np.where(bins_remain_cap >= item, \n                          1 / (bins_remain_cap - item + 1e-6),  # Best-Fit element: prioritize bins with least remaining capacity\n                          -1.0)  # Penalize bins that can't fit the item\n    \n    # Adjust priorities to ensure bins that can't fit the item have lower priority\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    Combines elements of 'First-Fit Decreasing' and 'Best-Fit' heuristics.\n    \"\"\"\n    # Prioritize bins where the item fits and leaves minimal remaining capacity\n    priorities = np.where(bins_remain_cap >= item, \n                          1 / (bins_remain_cap - item + 1e-6),  # Best-Fit element: prioritize bins with least remaining capacity\n                          -1.0)  # Penalize bins that can't fit the item\n    \n    # Adjust priorities to ensure bins that can't fit the item have lower priority\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Combines the benefits of prioritizing bins with enough capacity and minimizing waste.\n    \"\"\"\n    # Check if the item can fit in each bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Higher priority for bins with less remaining capacity after adding the item\n    priority_scores = np.where(valid_bins == 1, 1 / (bins_remain_cap + 1e-6), -1.0)\n    \n    # Modify the priority scores to also consider the fullness of the bin\n    fullness_factor = 1 + (1 - (bins_remain_cap - item) / bins_remain_cap)\n    priority_scores = np.where(valid_bins == 1, priority_scores * fullness_factor, priority_scores)\n    \n    return priority_scores\n\n[Heuristics 10th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins that can fit the item with minimal remaining capacity.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap = bins_remain_cap - item\n    \n    # Bins that can fit the item have higher priority based on remaining capacity\n    valid_bins = remaining_cap >= 0\n    \n    # Assign high priority to valid bins with minimal remaining capacity\n    priority = np.where(valid_bins, -remaining_cap, -np.inf)\n    \n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and fullness.\n    \n    Combines the benefits of minimizing waste and prioritizing almost full bins.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Mask out bins that cannot hold the item\n    valid_bins = remaining_capacity_after_addition >= 0\n    \n    # Priority score is a combination of remaining capacity and fullness\n    priority_scores = np.where(valid_bins, np.exp(-remaining_capacity_after_addition) + bins_remain_cap / (item + 1e-9), -1e10)\n    \n    return priority_scores\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and fullness.\n    \n    Combines the benefits of minimizing waste and prioritizing almost full bins.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Mask out bins that cannot hold the item\n    valid_bins = remaining_capacity_after_addition >= 0\n    \n    # Priority score is a combination of remaining capacity and fullness\n    priority_scores = np.where(valid_bins, np.exp(-remaining_capacity_after_addition) + bins_remain_cap / (item + 1e-9), -1e10)\n    \n    return priority_scores\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and fullness.\n    \n    Combines the benefits of minimizing waste and prioritizing almost full bins.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Mask out bins that cannot hold the item\n    valid_bins = remaining_capacity_after_addition >= 0\n    \n    # Priority score is a combination of remaining capacity and fullness\n    priority_scores = np.where(valid_bins, np.exp(-remaining_capacity_after_addition) + bins_remain_cap / (item + 1e-9), -1e10)\n    \n    return priority_scores\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and fullness.\n    \n    Combines the benefits of minimizing waste and prioritizing almost full bins.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Mask out bins that cannot hold the item\n    valid_bins = remaining_capacity_after_addition >= 0\n    \n    # Priority score is a combination of remaining capacity and fullness\n    priority_scores = np.where(valid_bins, np.exp(-remaining_capacity_after_addition) + bins_remain_cap / (item + 1e-9), -1e10)\n    \n    return priority_scores\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins with remaining capacity closest to the item size and minimizes waste.\n    \"\"\"\n    # Calculate priority based on the absolute difference between remaining capacity and item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Set priority to negative infinity for bins that cannot fit the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores for bins that can fit the item\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(priority[valid_bins] - max_priority))\n    \n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin, \n    prioritizing bins with the least remaining capacity after addition.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign priority based on remaining capacity after addition\n    priority = np.where(remaining_cap_after_addition >= 0, \n                        -remaining_cap_after_addition,  # Prioritize bins with least remaining capacity\n                        -np.inf)  # Penalize bins that cannot accommodate the item\n    \n    # Scale priorities to enhance differentiation among viable bins\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  \n        priority = np.where(priority != -np.inf, np.exp(-(priority - max_priority)), priority)\n    \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins with remaining capacity closest to the item size and minimizes waste.\n    \"\"\"\n    # Calculate priority based on the absolute difference between remaining capacity and item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Set priority to negative infinity for bins that cannot fit the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores for bins that can fit the item\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(priority[valid_bins] - max_priority))\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins with remaining capacity closest to the item size and minimizes waste.\n    \"\"\"\n    # Calculate priority based on the absolute difference between remaining capacity and item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Set priority to negative infinity for bins that cannot fit the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores for bins that can fit the item\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(priority[valid_bins] - max_priority))\n    \n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin, \n    prioritizing bins with the least remaining capacity after addition.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign priority based on remaining capacity after addition\n    priority = np.where(remaining_cap_after_addition >= 0, \n                        -remaining_cap_after_addition,  # Prioritize bins with least remaining capacity\n                        -np.inf)  # Penalize bins that cannot accommodate the item\n    \n    # Scale priorities to enhance differentiation among viable bins\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  \n        priority = np.where(priority != -np.inf, np.exp(-(priority - max_priority)), priority)\n    \n    return priority\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins with remaining capacity closest to the item size and minimizes waste.\n    \"\"\"\n    # Calculate priority based on the absolute difference between remaining capacity and item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Set priority to negative infinity for bins that cannot fit the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores for bins that can fit the item\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(priority[valid_bins] - max_priority))\n    \n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}