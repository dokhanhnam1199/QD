```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using an advanced heuristic.

    The heuristic combines multiple strategies to prioritize bins based on their remaining capacity,
    focusing on the best fit, proportion of capacity used, and penalizing bins that are too large or too small.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the priority score for each bin based on the remaining capacity
    # Prioritize bins where the item fits and leaves a minimal remainder
    priorities = np.where(bins_remain_cap >= item,
                          # Combine the relative fit (how close the remaining capacity is to the item size)
                          # with a penalty for bins that are too large
                          (1 - np.abs(bins_remain_cap - item) / (bins_remain_cap + item)) * np.exp(-(bins_remain_cap - item) / item),
                          -1.0)  # Penalize bins that can't fit the item

    # Normalize the priorities to ensure numerical stability and enhance differentiation
    max_priority = np.max(priorities)
    if max_priority > -1.0:  # Check if there are bins that can fit the item
        priorities = np.where(priorities > -1.0, priorities / max_priority, priorities)

    # Introduce a slight penalty for bins that are more than half empty after adding the item
    priorities = np.where((bins_remain_cap >= item) & ((bins_remain_cap - item) > bins_remain_cap / 2),
                          priorities * 0.8,  # Reduce priority for bins that will be more than half empty
                          priorities)

    return priorities
```
