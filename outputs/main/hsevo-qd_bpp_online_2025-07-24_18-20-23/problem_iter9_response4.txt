```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a nuanced heuristic.

    The heuristic used here combines multiple strategies to prioritize bins based on their remaining capacity.
    It not only considers whether the item fits and the remaining capacity after placement but also differentiates among viable bins more effectively.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # First, identify bins that can fit the item
    can_fit = bins_remain_cap >= item
    
    # For bins that can fit the item, calculate a priority score based on how well the item fills the bin
    # We want bins where the item leaves a small remainder (but not too small) to have higher priority
    fill_ratio = item / bins_remain_cap  # Ratio of item size to bin's remaining capacity
    priorities = np.where(can_fit, 
                          # Prioritize bins that are filled to a reasonable level (not too empty, not too full)
                          1 - np.abs(0.5 - fill_ratio),  
                          -1.0)  # Penalize bins that can't fit the item
    
    # To enhance differentiation among viable bins, add a small random noise to the priorities
    # This helps in breaking ties and exploring different packing configurations
    priorities = np.where(can_fit, priorities + np.random.uniform(0, 0.01, size=len(bins_remain_cap)), priorities)
    
    # Ensure that bins that can't fit the item have a significantly lower priority than any bin that can fit the item
    priorities = np.where(~can_fit, priorities - np.max(priorities) - 1, priorities)
    
    return priorities
```
