```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a nuanced heuristic.

    The heuristic used here combines multiple strategies to prioritize bins based on their remaining capacity.
    It considers both the absolute remaining capacity and the relative remaining capacity after packing the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the absolute remaining capacity after packing the item
    remaining_after_packing = bins_remain_cap - item
    
    # Prioritize bins where the item fits and leaves a reasonable remaining capacity
    priorities = np.where(bins_remain_cap >= item, 
                          # Combine the relative remaining capacity and the normalized remaining capacity
                          0.5 * (1 - remaining_after_packing / bins_remain_cap) + 
                          0.5 * np.exp(-remaining_after_packing / item),  
                          -1.0)  # Penalize bins that can't fit the item
    
    # Ensure numerical stability by avoiding division by zero or negative values
    priorities = np.where(bins_remain_cap <= 0, -1.0, priorities)
    
    # Normalize the priorities to ensure differentiation among viable options
    max_priority = np.max(priorities)
    if max_priority > -1.0:  # Check if there are bins that can fit the item
        priorities = np.where(priorities > -1.0, priorities - np.min(priorities[p Priorities > -1.0]), priorities)
    
    return priorities
```
