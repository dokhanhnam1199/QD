{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines strategies: prioritizes bins with remaining capacity closest to item size,\n    ensures numerical stability with epsilon, and normalizes valid bin priorities.\n    \"\"\"\n    epsilon = 1e-6  # Small value for numerical stability\n    # Check if bins can fit the item and calculate priority\n    valid_bins = bins_remain_cap >= item\n    diff = np.abs(bins_remain_cap - item)\n    priority = np.where(valid_bins, -diff + 1 / (bins_remain_cap + epsilon), -np.inf)\n    \n    # Normalize priority scores for valid bins\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(max_priority - priority[valid_bins]))\n    \n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines 'best fit' and 'valid bin' heuristics with numerical stability for online Bin Packing Problem.\n    Prioritizes bins closest to being full and can hold the item.\n    \"\"\"\n    # Calculate 'best fit' score with epsilon for numerical stability\n    best_fit_scores = np.where(bins_remain_cap >= item, 1 / (np.abs(bins_remain_cap - item) + 1e-6), 0)\n    \n    # Normalize the scores\n    max_score = np.max(best_fit_scores)\n    if max_score > 0:\n        best_fit_scores /= max_score\n    \n    # Set priority to negative infinity for bins that cannot fit the item\n    priority = np.where(bins_remain_cap >= item, best_fit_scores, -np.inf)\n    \n    # Normalize priority scores for valid bins using exponential function\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(max_priority - priority[valid_bins]))\n    \n    return priority\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines nuanced remaining capacity prioritization with fullness consideration and numerical stability.\n    \"\"\"\n    # Check if the item can fit in each bin with a small epsilon for numerical stability\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Priority score based on remaining capacity after addition, with a small epsilon\n    remaining_capacity_after_addition = bins_remain_cap - item + 1e-6\n    priority_scores = np.where(valid_bins == 1, 1 / remaining_capacity_after_addition, -1.0)\n    \n    # Modify the priority scores to consider the fullness of the bin, similar to priority_v0\n    fullness_factor = 1 + (1 - (remaining_capacity_after_addition) / (bins_remain_cap + 1e-6))\n    priority_scores = np.where(valid_bins == 1, priority_scores * fullness_factor, priority_scores)\n    \n    # Additional exponential factor to prioritize bins that are almost full, inspired by priority_v1\n    priority_scores = np.where(valid_bins == 1, priority_scores * np.exp(-remaining_capacity_after_addition), priority_scores)\n    \n    return priority_scores\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines nuanced remaining capacity prioritization with fullness consideration and numerical stability.\n    \"\"\"\n    # Check if the item can fit in each bin with a small epsilon for numerical stability\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Priority score based on remaining capacity after addition, with a small epsilon\n    remaining_capacity_after_addition = bins_remain_cap - item + 1e-6\n    priority_scores = np.where(valid_bins == 1, 1 / remaining_capacity_after_addition, -1.0)\n    \n    # Modify the priority scores to consider the fullness of the bin, similar to priority_v0\n    fullness_factor = 1 + (1 - (remaining_capacity_after_addition) / (bins_remain_cap + 1e-6))\n    priority_scores = np.where(valid_bins == 1, priority_scores * fullness_factor, priority_scores)\n    \n    # Additional exponential factor to prioritize bins that are almost full, inspired by priority_v1\n    priority_scores = np.where(valid_bins == 1, priority_scores * np.exp(-remaining_capacity_after_addition), priority_scores)\n    \n    return priority_scores\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines strategies: prioritizes bins with remaining capacity closest to item size,\n    ensures numerical stability with epsilon, and normalizes valid bin priorities.\n    \"\"\"\n    epsilon = 1e-6  # Small value for numerical stability\n    # Check if bins can fit the item and calculate priority\n    valid_bins = bins_remain_cap >= item\n    diff = np.abs(bins_remain_cap - item)\n    priority = np.where(valid_bins, -diff + 1 / (bins_remain_cap + epsilon), -np.inf)\n    \n    # Normalize priority scores for valid bins\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(max_priority - priority[valid_bins]))\n    \n    return priority\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines 'best fit' and 'valid bin' heuristics with numerical stability for online Bin Packing Problem.\n    Prioritizes bins closest to being full and can hold the item.\n    \"\"\"\n    # Calculate 'best fit' score with epsilon for numerical stability\n    best_fit_scores = np.where(bins_remain_cap >= item, 1 / (np.abs(bins_remain_cap - item) + 1e-6), 0)\n    \n    # Normalize the scores\n    max_score = np.max(best_fit_scores)\n    if max_score > 0:\n        best_fit_scores /= max_score\n    \n    # Set priority to negative infinity for bins that cannot fit the item\n    priority = np.where(bins_remain_cap >= item, best_fit_scores, -np.inf)\n    \n    # Normalize priority scores for valid bins using exponential function\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(max_priority - priority[valid_bins]))\n    \n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines 'best fit' and 'valid bin' heuristics with numerical stability for online Bin Packing Problem.\n    Prioritizes bins closest to being full and can hold the item.\n    \"\"\"\n    # Calculate 'best fit' score with epsilon for numerical stability\n    best_fit_scores = np.where(bins_remain_cap >= item, 1 / (np.abs(bins_remain_cap - item) + 1e-6), 0)\n    \n    # Normalize the scores\n    max_score = np.max(best_fit_scores)\n    if max_score > 0:\n        best_fit_scores /= max_score\n    \n    # Set priority to negative infinity for bins that cannot fit the item\n    priority = np.where(bins_remain_cap >= item, best_fit_scores, -np.inf)\n    \n    # Normalize priority scores for valid bins using exponential function\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(max_priority - priority[valid_bins]))\n    \n    return priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a more sophisticated heuristic.\n\n    The heuristic used here is a variant of the 'First-Fit Decreasing' algorithm adapted for online bin packing.\n    It prioritizes bins that have just enough capacity for the item, and penalizes bins that would be left with too much or too little remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    priorities = np.where(bins_remain_cap >= item, \n                          1 - np.abs(bins_remain_cap - item) / item,  # Prioritize bins with remaining capacity close to the item size\n                          -1.0)  # Penalize bins that can't fit the item\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines 'best fit' and 'valid bin' heuristics with numerical stability for online Bin Packing Problem.\n    Prioritizes bins closest to being full and can hold the item.\n    \"\"\"\n    # Calculate 'best fit' score with epsilon for numerical stability\n    best_fit_scores = np.where(bins_remain_cap >= item, 1 / (np.abs(bins_remain_cap - item) + 1e-6), 0)\n    \n    # Normalize the scores\n    max_score = np.max(best_fit_scores)\n    if max_score > 0:\n        best_fit_scores /= max_score\n    \n    # Set priority to negative infinity for bins that cannot fit the item\n    priority = np.where(bins_remain_cap >= item, best_fit_scores, -np.inf)\n    \n    # Normalize priority scores for valid bins using exponential function\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(max_priority - priority[valid_bins]))\n    \n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines 'Best-Fit' and nuanced prioritization strategies with numerical stability.\n    \"\"\"\n    # Calculate priority using 'Best-Fit' strategy with epsilon for stability\n    priorities = np.where(bins_remain_cap >= item, \n                          1 / (bins_remain_cap - item + 1e-6),  # Best-Fit with epsilon\n                          -np.inf)  # Penalize bins that can't fit the item\n    \n    # Scale priorities to enhance differentiation among viable bins\n    max_priority = np.max(priorities)\n    if max_priority != -np.inf:  \n        priorities = np.where(priorities != -np.inf, np.exp(priorities - max_priority), priorities)\n    \n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a more sophisticated heuristic.\n\n    The heuristic used here combines multiple strategies to create a robust solution. It prioritizes bins that have \n    just enough capacity for the item, penalizes bins that would be left with too much or too little remaining capacity, \n    and ensures numerical stability.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    priorities = np.where(bins_remain_cap >= item, \n                          np.exp(-((bins_remain_cap - item) / item) ** 2),  # Gaussian prioritization for bins with remaining capacity close to the item size\n                          -1.0)  # Penalize bins that can't fit the item\n    \n    # Add a small random noise to the priorities to avoid ties and ensure exploration\n    priorities += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities) - 1e-6, priorities)\n    \n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a more advanced heuristic.\n\n    The heuristic used here combines multiple strategies to create a robust solution.\n    It prioritizes bins that have just enough capacity for the item, penalizes bins that would be left with too much or too little remaining capacity,\n    and ensures numerical stability by avoiding division by zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    priorities = np.where(bins_remain_cap >= item, \n                          np.exp(-((bins_remain_cap - item) / item) ** 2),  # Use a Gaussian-like function to prioritize bins with remaining capacity close to the item size\n                          -1.0)  # Penalize bins that can't fit the item\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities[bins_remain_cap >= item]) - 1e-6, priorities)\n    \n    # Add a small random noise to the priorities to avoid tie-breaking issues\n    priorities += np.random.uniform(-1e-6, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a more advanced heuristic.\n\n    The heuristic used here combines multiple strategies to create a robust solution.\n    It prioritizes bins that have just enough capacity for the item, penalizes bins that would be left with too much or too little remaining capacity,\n    and ensures numerical stability by avoiding division by zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    priorities = np.where(bins_remain_cap >= item, \n                          np.exp(-((bins_remain_cap - item) / item) ** 2),  # Use a Gaussian-like function to prioritize bins with remaining capacity close to the item size\n                          -1.0 - 1e-6 * bins_remain_cap)  # Penalize bins that can't fit the item, with a small additional penalty for bins with larger remaining capacity\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities[bins_remain_cap >= item]) - 1, priorities)\n    \n    # Add a small random noise to the priorities to avoid tie-breaking issues\n    priorities += 1e-8 * np.random.rand(*priorities.shape)\n    \n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a more advanced heuristic.\n\n    The heuristic used here combines multiple strategies to create a robust solution.\n    It prioritizes bins that have just enough capacity for the item, penalizes bins that would be left with too much or too little remaining capacity,\n    and ensures numerical stability by avoiding division by zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    priorities = np.where(bins_remain_cap >= item, \n                          np.exp(-((bins_remain_cap - item) / item) ** 2),  # Use a Gaussian-like function to prioritize bins with remaining capacity close to the item size\n                          -1.0 - 1e-6 * bins_remain_cap)  # Penalize bins that can't fit the item, with a small additional penalty for bins with larger remaining capacity\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities[bins_remain_cap >= item]) - 1, priorities)\n    \n    # Add a small random noise to the priorities to avoid tie-breaking issues\n    priorities += 1e-8 * np.random.rand(*priorities.shape)\n    \n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a more sophisticated heuristic.\n\n    The heuristic used here combines multiple strategies to create a robust solution. It prioritizes bins that have \n    just enough capacity for the item, penalizes bins that would be left with too much or too little remaining capacity, \n    and ensures numerical stability.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    priorities = np.where(bins_remain_cap >= item, \n                          np.exp(-((bins_remain_cap - item) / item) ** 2),  # Gaussian prioritization for bins with remaining capacity close to the item size\n                          -1.0)  # Penalize bins that can't fit the item\n    \n    # Add a small random noise to the priorities to avoid ties and ensure exploration\n    priorities += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities) - 1e-6, priorities)\n    \n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a more sophisticated heuristic.\n\n    The heuristic used here combines multiple strategies to create a robust solution.\n    It prioritizes bins that have just enough capacity for the item, penalizes bins that would be left with too much or too little remaining capacity,\n    and ensures numerical stability by avoiding division by zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    priorities = np.where(bins_remain_cap >= item, \n                          np.exp(-((bins_remain_cap - item) / item) ** 2),  # Prioritize bins with remaining capacity close to the item size using a Gaussian function\n                          -1.0)  # Penalize bins that can't fit the item\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities[bins_remain_cap >= item]) - 1e-6, priorities)\n    \n    # Add a small random noise to the priorities to avoid tie-breaking issues\n    priorities += np.random.uniform(-1e-6, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a more sophisticated heuristic.\n\n    The heuristic used here combines multiple strategies to create a robust solution.\n    It prioritizes bins that have just enough capacity for the item, penalizes bins that would be left with too much or too little remaining capacity,\n    and ensures numerical stability by avoiding division by zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    priorities = np.where(bins_remain_cap >= item, \n                          np.exp(-((bins_remain_cap - item) / item) ** 2),  # Prioritize bins with remaining capacity close to the item size using a Gaussian function\n                          -1.0)  # Penalize bins that can't fit the item\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities[bins_remain_cap >= item]) - 1e-6, priorities)\n    \n    # Add a small random noise to the priorities to avoid tie-breaking issues\n    priorities += np.random.uniform(-1e-6, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a more sophisticated heuristic.\n\n    The heuristic used here combines multiple strategies to create a robust solution.\n    It prioritizes bins that have just enough capacity for the item, penalizes bins that would be left with too much or too little remaining capacity,\n    and ensures numerical stability by avoiding division by zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    priorities = np.where(bins_remain_cap >= item, \n                          np.exp(-((bins_remain_cap - item) / item) ** 2),  # Prioritize bins with remaining capacity close to the item size using a Gaussian function\n                          -1.0)  # Penalize bins that can't fit the item\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities[bins_remain_cap >= item]) - 1e-6, priorities)\n    \n    # Add a small random noise to the priorities to avoid tie-breaking issues\n    priorities += np.random.uniform(-1e-6, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a more advanced heuristic.\n\n    The heuristic used here combines multiple strategies to create a robust solution.\n    It prioritizes bins that have just enough capacity for the item, penalizes bins that would be left with too much or too little remaining capacity,\n    and ensures numerical stability by avoiding division by zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    priorities = np.where(bins_remain_cap >= item, \n                          np.exp(-((bins_remain_cap - item) / item) ** 2),  # Use a Gaussian-like function to prioritize bins with remaining capacity close to the item size\n                          -1.0 - 1e-6 * bins_remain_cap)  # Penalize bins that can't fit the item, with a small additional penalty for bins with larger remaining capacity\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities[bins_remain_cap >= item]) - 1, priorities)\n    \n    # Add a small random noise to the priorities to avoid tie-breaking issues\n    priorities += 1e-8 * np.random.rand(*priorities.shape)\n    \n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit priority and fullness priority with numerical stability for online bin packing.\n\n    Args:\n        item: Size of item to be added.\n        bins_remain_cap: Array of remaining capacities.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Calculate fit priority and fullness priority\n    fit_priority = np.where(bins_remain_cap >= item, \n                            1 - np.abs(bins_remain_cap - item) / (item + 1e-6),  # Prioritize bins with capacity close to item size\n                            -1.0)  # Penalize bins that can't fit the item\n    \n    fullness_priority = np.where(bins_remain_cap >= item, \n                                 1 - bins_remain_cap / (item + bins_remain_cap - item + 1e-6),  # Avoid division by zero\n                                 -1.0)\n    \n    # Combine priorities with scaling for differentiation\n    priorities = 0.6 * fit_priority + 0.4 * fullness_priority\n    \n    # Ensure bins that can't fit the item have lower priority\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    # Scale priorities to enhance differentiation among viable bins\n    max_priority = np.max(priorities)\n    if max_priority != -1.0:  \n        priorities = np.where(priorities != -1.0 - np.max(priorities), np.exp(-(priorities - max_priority)), priorities)\n    \n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}