```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using an advanced heuristic.

    The heuristic used here combines multiple strategies to prioritize bins based on their remaining capacity.
    It considers the relative fit, the proportion of capacity used, and introduces a new strategy to handle bins with very high remaining capacity.
    The function ensures nuanced prioritization, normalization for numerical stability, and differentiation among viable options.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the priority score for each bin based on the remaining capacity
    # We want to prioritize bins where the item fits and leaves a reasonable remainder
    priorities = np.where(bins_remain_cap >= item,
                          # Combine the relative fit (how close the remaining capacity is to the item size)
                          # with the proportion of the bin that will be used after adding the item
                          (1 - np.abs(bins_remain_cap - item) / (bins_remain_cap + 1e-8)) * (item / bins_remain_cap),
                          -1.0)  # Penalize bins that can't fit the item

    # Normalize the priorities to ensure numerical stability and enhance differentiation
    max_priority = np.max(priorities)
    if max_priority > -1.0:  # Check if there are bins that can fit the item
        priorities = np.where(priorities > -1.0, priorities / max_priority, priorities)

    # Introduce a new strategy to further differentiate among bins that can fit the item
    # by penalizing those with very low utilization rate after adding the item
    utilization_rate = item / bins_remain_cap
    priorities = np.where((bins_remain_cap >= item) & (utilization_rate < 0.5),
                          priorities * 0.8,  # Penalize bins that will have low utilization rate
                          priorities)

    # Slightly boost the priority of bins that will be almost full after adding the item
    priorities = np.where((bins_remain_cap >= item) & (utilization_rate > 0.8),
                          priorities * 1.1,  # Boost priority for bins that will be almost full
                          priorities)

    return priorities
```
