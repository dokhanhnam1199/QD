```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a nuanced heuristic.

    The heuristic used here combines multiple strategies to prioritize bins based on their remaining capacity.
    It considers both the absolute difference between the remaining capacity and the item size, as well as the relative remaining capacity after packing the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the absolute difference between the remaining capacity and the item size
    abs_diff = np.abs(bins_remain_cap - item)
    
    # Calculate the relative remaining capacity after packing the item
    rel_remain_cap = (bins_remain_cap - item) / bins_remain_cap
    
    # Prioritize bins where the item fits and the remaining capacity is small
    priorities = np.where(bins_remain_cap >= item, 
                          0.5 * (1 - abs_diff / np.max(bins_remain_cap)) +  # Prioritize bins with remaining capacity close to the item size
                          0.5 * (1 - rel_remain_cap),  # Prioritize bins that will be relatively empty after packing the item
                          -1.0)  # Penalize bins that can't fit the item
    
    # Normalize the priorities to ensure numerical stability
    priorities = priorities - np.max(priorities)
    priorities = np.exp(priorities) / np.sum(np.exp(priorities))
    
    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item
    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities[bins_remain_cap >= item]), priorities)
    
    return priorities
```
