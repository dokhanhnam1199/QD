```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines nuanced remaining capacity prioritization with fullness consideration, 
    numerical stability, and prioritizes bins with remaining capacity closest to the item size.
    """
    # Check if the item can fit in each bin with a small epsilon for numerical stability
    valid_bins = (bins_remain_cap >= item).astype(float)
    
    # Priority score based on remaining capacity after addition, with a small epsilon
    remaining_capacity_after_addition = bins_remain_cap - item + 1e-6
    priority_scores = np.where(valid_bins == 1, np.exp(-((remaining_capacity_after_addition) / item) ** 2), -1.0)
    
    # Modify the priority scores to consider the fullness of the bin
    fullness_factor = 1 + (1 - (remaining_capacity_after_addition) / (bins_remain_cap + 1e-6))
    priority_scores = np.where(valid_bins == 1, priority_scores * fullness_factor, priority_scores)
    
    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item
    priority_scores = np.where(bins_remain_cap < item, priority_scores - np.max(priority_scores[bins_remain_cap >= item]) - 1, priority_scores)
    
    # Add a small random noise to the priorities to avoid tie-breaking issues
    priority_scores += 1e-8 * np.random.rand(*priority_scores.shape)
    
    return priority_scores
```
