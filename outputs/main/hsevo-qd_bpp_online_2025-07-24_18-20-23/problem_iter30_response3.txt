```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using an advanced heuristic.

    The heuristic combines multiple factors for nuanced prioritization, including the relative fit of the item,
    the proportion of the bin's capacity that will be used, and a penalty for bins with very high remaining capacity.
    It also employs sophisticated normalization to enhance differentiation among viable bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # First, identify bins that can fit the item
    fit_bins = bins_remain_cap >= item
    
    # Calculate the relative fit of the item in each bin
    relative_fit = 1 - np.abs(bins_remain_cap - item) / np.maximum(bins_remain_cap, item)
    
    # Calculate the proportion of the bin that will be used after adding the item
    usage_proportion = item / (bins_remain_cap - item + item)
    
    # Combine relative fit and usage proportion to get an initial priority score
    priorities = np.where(fit_bins, relative_fit * usage_proportion, -1.0)
    
    # Normalize the priorities of viable bins to the range [0, 1]
    viable_priorities = priorities[fit_bins]
    if len(viable_priorities) > 0:
        min_priority = np.min(viable_priorities)
        max_priority = np.max(viable_priorities)
        if max_priority > min_priority:
            priorities[fit_bins] = (viable_priorities - min_priority) / (max_priority - min_priority)
    
    # Apply a penalty to bins with very high remaining capacity relative to the item size
    high_capacity_bins = (bins_remain_cap >= item) & (bins_remain_cap > 2 * item)
    priorities[high_capacity_bins] *= 0.8  # Adjust the penalty factor as needed
    
    return priorities
```
