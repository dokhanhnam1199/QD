```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using an advanced heuristic.

    The heuristic combines relative fit, proportion of capacity used, and remaining capacity to prioritize bins.
    It normalizes priorities using a softmax function to enhance differentiation and stability.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the priority score for each bin based on the remaining capacity
    # Prioritize bins where the item fits, considering relative fit and proportion of capacity used
    priorities = np.where(bins_remain_cap >= item,
                          # Relative fit and proportion of capacity used
                          (1 - np.abs(bins_remain_cap - item) / (bins_remain_cap + 1e-8)) * np.log(item / (bins_remain_cap - item + item) + 1),
                          -1e8)  # Penalize bins that can't fit the item with a very low priority

    # Apply softmax normalization to enhance differentiation and numerical stability
    max_priority = np.max(priorities)
    if max_priority > -1e8:  # Check if there are bins that can fit the item
        exp_priorities = np.exp(priorities - max_priority)
        priorities = np.where(priorities > -1e8, exp_priorities / (np.sum(exp_priorities) + 1e-8), 0)

    # Further differentiate among bins that can fit the item by slightly penalizing those with very high remaining capacity
    priorities = np.where((bins_remain_cap >= item) & (bins_remain_cap > item * 2),
                          priorities * 0.8,  # Reduce priority for bins with high remaining capacity
                          priorities)

    return priorities
```
