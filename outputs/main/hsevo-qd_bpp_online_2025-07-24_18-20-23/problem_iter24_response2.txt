```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using an advanced heuristic.

    The heuristic used here enhances the prioritization by considering not just the fit and proportion of capacity used,
    but also introduces a more nuanced differentiation among bins based on their remaining capacities and the item size.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the priority score for each bin based on the remaining capacity
    # We want to prioritize bins where the item fits and leaves a reasonable remainder
    priorities = np.where(bins_remain_cap >= item,
                          # Introduce a more nuanced scoring by considering the relative fit and the proportion of bin used
                          (1 - np.abs(bins_remain_cap - item) / (bins_remain_cap + item)) * np.exp(-(bins_remain_cap - item) / item),
                          -1.0)  # Penalize bins that can't fit the item

    # Normalize the priorities to ensure they are within a comparable range
    max_priority = np.max(priorities)
    if max_priority > -1.0:  # Check if there are bins that can fit the item
        priorities = np.where(priorities > -1.0, priorities / max_priority, priorities)

    # Further differentiate among bins that can fit the item by adjusting priorities based on remaining capacity
    priorities = np.where((bins_remain_cap >= item) & (bins_remain_cap > item * 1.5),
                          priorities * np.exp(-(bins_remain_cap - item) / (item * 2)),  # Adjust priority based on excess capacity
                          priorities)

    return priorities
```
