[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines strategies: prioritizes bins with remaining capacity closest to item size,\n    ensures numerical stability with epsilon, and normalizes valid bin priorities.\n    \"\"\"\n    epsilon = 1e-6  # Small value for numerical stability\n    # Check if bins can fit the item and calculate priority\n    valid_bins = bins_remain_cap >= item\n    diff = np.abs(bins_remain_cap - item)\n    priority = np.where(valid_bins, -diff + 1 / (bins_remain_cap + epsilon), -np.inf)\n    \n    # Normalize priority scores for valid bins\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(max_priority - priority[valid_bins]))\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 88.48095635181713,
    "token_count": 73.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit priority and fullness priority with numerical stability for online bin packing.\n\n    Args:\n        item: Size of item to be added.\n        bins_remain_cap: Array of remaining capacities.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Calculate fit priority and fullness priority\n    fit_priority = np.where(bins_remain_cap >= item, \n                            1 - np.abs(bins_remain_cap - item) / (item + 1e-6),  # Prioritize bins with capacity close to item size\n                            -1.0)  # Penalize bins that can't fit the item\n    \n    fullness_priority = np.where(bins_remain_cap >= item, \n                                 1 - bins_remain_cap / (item + bins_remain_cap - item + 1e-6),  # Avoid division by zero\n                                 -1.0)\n    \n    # Combine priorities with scaling for differentiation\n    priorities = 0.6 * fit_priority + 0.4 * fullness_priority\n    \n    # Ensure bins that can't fit the item have lower priority\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    # Scale priorities to enhance differentiation among viable bins\n    max_priority = np.max(priorities)\n    if max_priority != -1.0:  \n        priorities = np.where(priorities != -1.0 - np.max(priorities), np.exp(-(priorities - max_priority)), priorities)\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 88.48095635181713,
    "token_count": 73.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of minimizing waste and prioritizing almost full bins with numerical stability.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Prioritize bins that can hold the item and will have the least remaining capacity\n    # while also considering the fullness factor\n    priority = np.where(remaining_cap_after_addition >= 0, \n                        # Combine the negative remaining capacity with a fullness factor\n                        # and a term that prioritizes bins with remaining capacity closest to the item size\n                        -remaining_cap_after_addition + bins_remain_cap / (item + 1e-9) - np.abs(bins_remain_cap - item) / (bins_remain_cap.max() + 1e-9), \n                        -np.inf)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 88.48095635181713,
    "token_count": 73.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines 'best fit' and 'valid bin' heuristics with numerical stability for online Bin Packing Problem.\n    Prioritizes bins closest to being full and can hold the item.\n    \"\"\"\n    # Calculate 'best fit' score with epsilon for numerical stability\n    best_fit_scores = np.where(bins_remain_cap >= item, 1 / (np.abs(bins_remain_cap - item) + 1e-6), 0)\n    \n    # Normalize the scores\n    max_score = np.max(best_fit_scores)\n    if max_score > 0:\n        best_fit_scores /= max_score\n    \n    # Set priority to negative infinity for bins that cannot fit the item\n    priority = np.where(bins_remain_cap >= item, best_fit_scores, -np.inf)\n    \n    # Normalize priority scores for valid bins using exponential function\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(max_priority - priority[valid_bins]))\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 88.48095635181713,
    "token_count": 73.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines nuanced fit priority and relative capacity priority for robust bin selection.\n    \"\"\"\n    # Calculate fit priority with numerical stability\n    fit_priority = np.where(bins_remain_cap >= item, 1 - np.abs(bins_remain_cap - item) / (item + 1e-9), -1.0)\n    \n    # Calculate relative capacity priority after adding the item\n    relative_cap_priority = np.where(bins_remain_cap >= item, (bins_remain_cap - item) / (bins_remain_cap + 1e-9), -1.0)\n    \n    # Combine priorities with a weighted sum\n    priorities = fit_priority + 0.5 * relative_cap_priority\n    \n    # Ensure bins that can't fit the item have lower priority\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 88.48095635181713,
    "token_count": 73.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines 'Best-Fit' and nuanced prioritization strategies with numerical stability.\n    \"\"\"\n    # Prioritize bins where the item fits, using Best-Fit element with epsilon for stability\n    priorities = np.where(bins_remain_cap >= item, \n                          np.exp(-(bins_remain_cap - item)) + 1 / (bins_remain_cap - item + 1e-6), \n                          -1e10)  # Penalize bins that can't fit the item\n    \n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 88.48095635181713,
    "token_count": 73.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines 'Best-Fit' and nuanced prioritization strategies with numerical stability.\n    \"\"\"\n    # Calculate priority using 'Best-Fit' strategy with epsilon for stability\n    priorities = np.where(bins_remain_cap >= item, \n                          1 / (bins_remain_cap - item + 1e-6),  # Best-Fit with epsilon\n                          -np.inf)  # Penalize bins that can't fit the item\n    \n    # Scale priorities to enhance differentiation among viable bins\n    max_priority = np.max(priorities)\n    if max_priority != -np.inf:  \n        priorities = np.where(priorities != -np.inf, np.exp(priorities - max_priority), priorities)\n    \n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 88.48095635181713,
    "token_count": 73.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines 'Best-Fit' and 'First-Fit Decreasing' heuristics with numerical stability.\n    Prioritizes bins where the item fits with minimal remaining capacity.\n    \"\"\"\n    # Calculate priority based on remaining capacity and item size\n    priorities = np.where(bins_remain_cap >= item, \n                          np.exp(-np.abs(bins_remain_cap - item)) / (bins_remain_cap - item + 1e-6),  # Combine Best-Fit and numerical stability\n                          -np.inf)  # Penalize bins that can't fit the item\n    \n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 88.48095635181713,
    "token_count": 73.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines nuanced remaining capacity prioritization with fullness consideration and numerical stability.\n    \"\"\"\n    # Check if the item can fit in each bin with a small epsilon for numerical stability\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Priority score based on remaining capacity after addition, with a small epsilon\n    remaining_capacity_after_addition = bins_remain_cap - item + 1e-6\n    priority_scores = np.where(valid_bins == 1, 1 / remaining_capacity_after_addition, -1.0)\n    \n    # Modify the priority scores to consider the fullness of the bin, similar to priority_v0\n    fullness_factor = 1 + (1 - (remaining_capacity_after_addition) / (bins_remain_cap + 1e-6))\n    priority_scores = np.where(valid_bins == 1, priority_scores * fullness_factor, priority_scores)\n    \n    # Additional exponential factor to prioritize bins that are almost full, inspired by priority_v1\n    priority_scores = np.where(valid_bins == 1, priority_scores * np.exp(-remaining_capacity_after_addition), priority_scores)\n    \n    return priority_scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 88.48095635181713,
    "token_count": 73.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines prioritization strategies: prioritizing bins with minimal remaining capacity and fullness.\n    Ensures numerical stability with epsilon.\n    \"\"\"\n    # Calculate remaining capacity after adding item\n    remaining_cap = bins_remain_cap - item\n    \n    # Mask out bins that cannot hold the item\n    valid_bins = remaining_cap >= 0\n    \n    # Priority score combines remaining capacity and fullness with numerical stability\n    priority = np.where(valid_bins, -remaining_cap + bins_remain_cap / (item + 1e-9), -np.inf)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 88.48095635181713,
    "token_count": 73.0,
    "exec_success": true
  }
]