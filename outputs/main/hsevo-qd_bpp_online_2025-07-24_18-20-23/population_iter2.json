[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin, \n    prioritizing bins with the least remaining capacity after addition.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign priority based on remaining capacity after addition\n    priority = np.where(remaining_cap_after_addition >= 0, \n                        -remaining_cap_after_addition,  # Prioritize bins with least remaining capacity\n                        -np.inf)  # Penalize bins that cannot accommodate the item\n    \n    # Scale priorities to enhance differentiation among viable bins\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  \n        priority = np.where(priority != -np.inf, np.exp(-(priority - max_priority)), priority)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins that can fit the item and have remaining capacity closest to the item size.\n    \"\"\"\n    # Check if bins can fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate the absolute difference between remaining capacity and item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign high priority to valid bins with remaining capacity closest to the item size\n    priority = np.where(valid_bins, -diff + 1 / (bins_remain_cap + 1e-6), -np.inf)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins that can fit the item with minimal remaining capacity.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap = bins_remain_cap - item\n    \n    # Bins that can fit the item have higher priority based on remaining capacity\n    valid_bins = remaining_cap >= 0\n    \n    # Assign high priority to valid bins with minimal remaining capacity\n    priority = np.where(valid_bins, -remaining_cap, -np.inf)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    Combines elements of 'First-Fit Decreasing' and 'Best-Fit' heuristics.\n    \"\"\"\n    # Prioritize bins where the item fits and leaves minimal remaining capacity\n    priorities = np.where(bins_remain_cap >= item, \n                          1 / (bins_remain_cap - item + 1e-6),  # Best-Fit element: prioritize bins with least remaining capacity\n                          -1.0)  # Penalize bins that can't fit the item\n    \n    # Adjust priorities to ensure bins that can't fit the item have lower priority\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities), priorities)\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins with remaining capacity closest to the item size and minimizes waste.\n    \"\"\"\n    # Calculate priority based on the absolute difference between remaining capacity and item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Set priority to negative infinity for bins that cannot fit the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores for bins that can fit the item\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(priority[valid_bins] - max_priority))\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining the 'best fit' and 'valid bin' heuristics.\n    Prioritizes bins that are closest to being full and can still hold the item.\n    \"\"\"\n    # Calculate 'best fit' score: higher for bins with remaining capacity closest to the item size\n    best_fit_scores = np.where(bins_remain_cap >= item, 1 / (np.abs(bins_remain_cap - item) + 1e-6), 0)\n    \n    # Normalize the scores\n    max_score = np.max(best_fit_scores)\n    if max_score > 0:\n        best_fit_scores /= max_score\n    \n    # Combine with 'valid bin' indicator to ensure only valid bins are considered\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    priority = best_fit_scores * valid_bins\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Combines the benefits of prioritizing bins with enough capacity and minimizing waste.\n    \"\"\"\n    # Check if the item can fit in each bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Higher priority for bins with less remaining capacity after adding the item\n    priority_scores = np.where(valid_bins == 1, 1 / (bins_remain_cap + 1e-6), -1.0)\n    \n    # Modify the priority scores to also consider the fullness of the bin\n    fullness_factor = 1 + (1 - (bins_remain_cap - item) / bins_remain_cap)\n    priority_scores = np.where(valid_bins == 1, priority_scores * fullness_factor, priority_scores)\n    \n    return priority_scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and fullness.\n    \n    Combines the benefits of minimizing waste and prioritizing almost full bins.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Mask out bins that cannot hold the item\n    valid_bins = remaining_capacity_after_addition >= 0\n    \n    # Priority score is a combination of remaining capacity and fullness\n    priority_scores = np.where(valid_bins, np.exp(-remaining_capacity_after_addition) + bins_remain_cap / (item + 1e-9), -1e10)\n    \n    return priority_scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 88.05345033905067,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity after adding the item.\n    Combines elements of minimizing waste and prioritizing almost full bins.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Prioritize bins that can hold the item and will have the least remaining capacity\n    priority = np.where(remaining_cap_after_addition >= 0, \n                        # Combine the negative remaining capacity with a fullness factor\n                        -remaining_cap_after_addition + bins_remain_cap / (item + 1e-9), \n                        -np.inf)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Prioritizes bins that are almost full and can fit the item, minimizing waste.\n    \"\"\"\n    # Check if the item can fit in each bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate priority based on remaining capacity after adding the item\n    priority_scores = np.where(valid_bins > 0, 1 / (bins_remain_cap + 1e-6), 0)\n    \n    # Combine the two priorities, giving higher priority to valid bins that are almost full\n    priority = valid_bins * (1 + priority_scores)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.53238859703687,
    "mi": 88.64537129369165,
    "token_count": 80.0,
    "exec_success": true
  }
]