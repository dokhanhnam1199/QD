```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using an enhanced heuristic.

    The heuristic combines strategies to prioritize bins based on their remaining capacity, 
    focusing on the best fit and the proportion of capacity used, with improved normalization.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the priority score for each bin based on the remaining capacity
    # Prioritize bins where the item fits, using a combination of best fit and capacity usage proportion
    priorities = np.where(bins_remain_cap >= item,
                          # Use a harmonic mean-like approach to balance best fit and capacity usage
                          2 / ((1 / (1 - (bins_remain_cap - item) / bins_remain_cap)) + (1 / (item / bins_remain_cap))),
                          -1.0)  # Penalize bins that can't fit the item

    # Normalize the priorities using a softmax-like function to enhance differentiation
    max_priority = np.max(priorities)
    if max_priority > -1.0:  # Check if there are bins that can fit the item
        exp_priorities = np.exp(priorities - max_priority)
        sum_exp_priorities = np.sum(exp_priorities)
        priorities = np.where(priorities > -1.0, exp_priorities / sum_exp_priorities, priorities)

    # Slightly penalize bins with very high remaining capacity among those that can fit the item
    priorities = np.where((bins_remain_cap >= item) & (bins_remain_cap > item * 1.5),
                          priorities * 0.8,  # Adjust the penalty factor as needed
                          priorities)

    return priorities
```
