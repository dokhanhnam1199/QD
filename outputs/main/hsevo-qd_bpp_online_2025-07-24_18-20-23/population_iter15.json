[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines strategies: prioritizes bins with remaining capacity closest to item size,\n    ensures numerical stability with epsilon, and normalizes valid bin priorities.\n    \"\"\"\n    epsilon = 1e-6  # Small value for numerical stability\n    # Check if bins can fit the item and calculate priority\n    valid_bins = bins_remain_cap >= item\n    diff = np.abs(bins_remain_cap - item)\n    priority = np.where(valid_bins, -diff + 1 / (bins_remain_cap + epsilon), -np.inf)\n    \n    # Normalize priority scores for valid bins\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(max_priority - priority[valid_bins]))\n    \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 88.48095635181713,
    "token_count": 73.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a more advanced heuristic.\n\n    The heuristic used here combines multiple strategies to create a robust solution.\n    It prioritizes bins that have just enough capacity for the item, penalizes bins that would be left with too much or too little remaining capacity,\n    and ensures numerical stability by avoiding division by zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits exactly or leaves a small remainder\n    priorities = np.where(bins_remain_cap >= item, \n                          np.exp(-((bins_remain_cap - item) / item) ** 2),  # Use a Gaussian-like function to prioritize bins with remaining capacity close to the item size\n                          -1.0)  # Penalize bins that can't fit the item\n    \n    # Ensure that bins that can't fit the item have a lower priority than any bin that can fit the item\n    priorities = np.where(bins_remain_cap < item, priorities - np.max(priorities[bins_remain_cap >= item]) - 1e-6, priorities)\n    \n    # Add a small random noise to the priorities to avoid tie-breaking issues\n    priorities += np.random.uniform(-1e-6, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 140.1816079436383,
    "mi": 65.30430505362567,
    "token_count": 125.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0005239665344428647) -> np.ndarray:\n    \"\"\"\n    Combines strategies: prioritizes bins with remaining capacity closest to item size,\n    ensures numerical stability with epsilon, and normalizes valid bin priorities.\n    \"\"\"\n    # Check if bins can fit the item and calculate priority\n    valid_bins = bins_remain_cap >= item\n    diff = np.abs(bins_remain_cap - item)\n    priority = np.where(valid_bins, -diff + 1 / (bins_remain_cap + epsilon), -np.inf)\n    \n    # Normalize priority scores for valid bins\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(max_priority - priority[valid_bins]))\n    \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 125.33591475173351,
    "mi": 92.25208272562202,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit priority with nuanced normalization for online bin packing.\n    Prioritizes bins with remaining capacity closest to item size and ensures numerical stability.\n    \"\"\"\n    # Check if bins can fit the item and calculate priority\n    epsilon = 1e-6  # Small value for numerical stability\n    valid_bins = bins_remain_cap >= item\n    diff = np.abs(bins_remain_cap - item)\n    priority = np.where(valid_bins, -diff + 1 / (bins_remain_cap + epsilon), -np.inf)\n    \n    # Combine fit priority with fullness priority\n    fullness_priority = np.where(valid_bins, 1 - bins_remain_cap / (bins_remain_cap + item + epsilon), 0)\n    priority = np.where(valid_bins, priority + 0.4 * fullness_priority, priority)\n    \n    # Normalize priority scores for valid bins\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priority[valid_bins])\n        priority[valid_bins] = np.exp(-(max_priority - priority[valid_bins]))\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 165.05865002596164,
    "mi": 90.37601511771273,
    "token_count": 144.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a nuanced heuristic.\n\n    The heuristic used here combines multiple strategies to prioritize bins based on their remaining capacity.\n    It not only considers bins that have just enough capacity for the item but also differentiates among viable options\n    by taking into account the proportion of capacity used and the absolute remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits and leaves a reasonable remainder\n    priorities = np.where(bins_remain_cap >= item,\n                          # Combine the relative fit (how close the remaining capacity is to the item size)\n                          # with the proportion of the bin that will be used\n                          (1 - np.abs(bins_remain_cap - item) / item) * (item / (bins_remain_cap - item + item)),\n                          -1.0)  # Penalize bins that can't fit the item\n\n    # Normalize the priorities to ensure numerical stability and enhance differentiation\n    max_priority = np.max(priorities)\n    if max_priority > -1.0:  # Check if there are bins that can fit the item\n        priorities = np.where(priorities > -1.0, priorities / max_priority, priorities)\n\n    # Further differentiate among bins that can fit the item by slightly penalizing those with very high remaining capacity\n    priorities = np.where((bins_remain_cap >= item) & (bins_remain_cap > item * 2),\n                          priorities * 0.9,  # Slightly reduce priority for bins with high remaining capacity\n                          priorities)\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 3.8492221779018885,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 102.1865710312585,
    "mi": 74.32874709091739,
    "token_count": 139.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines relative fit and proportion of capacity used with nuanced normalization for online bin packing.\n    Prioritizes bins where the item fits with a reasonable remainder and differentiates among viable options.\n    \"\"\"\n    # Calculate priority score based on relative fit and proportion of capacity used\n    epsilon = 1e-6  # Small value for numerical stability\n    valid_bins = bins_remain_cap >= item\n    relative_fit = 1 - np.abs(bins_remain_cap - item) / (item + epsilon)\n    proportion_used = item / (bins_remain_cap + epsilon)\n    priority = np.where(valid_bins, relative_fit * proportion_used, -1.0)\n    \n    # Normalize priority scores for valid bins\n    max_priority = np.max(priority)\n    if max_priority > -1.0:  \n        priority = np.where(priority > -1.0, priority / max_priority, priority)\n    \n    # Further differentiate among bins that can fit the item\n    priority = np.where((bins_remain_cap >= item) & (bins_remain_cap > item * 2),\n                        priority * 0.9,  # Slightly reduce priority for bins with high remaining capacity\n                        priority)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 3.8492221779018885,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 216.22022703449025,
    "mi": 91.7073636370051,
    "token_count": 145.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using an advanced heuristic.\n\n    The heuristic combines multiple strategies to prioritize bins based on their remaining capacity,\n    focusing on the best fit, proportion of capacity used, and avoiding unnecessary complexity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the priority score for each bin based on the remaining capacity\n    # Prioritize bins where the item fits and leaves a minimal remainder (best fit)\n    priorities = np.where(bins_remain_cap >= item,\n                          # Combine the relative fit with the proportion of the bin that will be used after adding the item\n                          (1 - (bins_remain_cap - item) / bins_remain_cap) * (item / bins_remain_cap),\n                          -1.0)  # Penalize bins that can't fit the item\n\n    # Normalize the priorities to ensure numerical stability and enhance differentiation\n    max_priority = np.max(priorities)\n    if max_priority > -1.0:  # Check if there are bins that can fit the item\n        priorities = np.where(priorities > -1.0, priorities / max_priority, priorities)\n\n    # Slightly penalize bins with very low utilization after adding the item to encourage packing efficiency\n    priorities = np.where((bins_remain_cap >= item) & ((item / bins_remain_cap) < 0.5),\n                          priorities * 0.8,  # Reduce priority for bins that will be less than half full after adding the item\n                          priorities)\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 283.6339404013986,
    "mi": 80.23812498313649,
    "token_count": 164.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines relative fit, proportion of capacity used, and nuanced normalization for online bin packing.\n    Prioritizes bins with remaining capacity closest to item size and differentiates among viable options.\n    \"\"\"\n    epsilon = 1e-6  # Small value for numerical stability\n    valid_bins = bins_remain_cap >= item\n    # Relative fit strategy from priority_v0\n    relative_fit = 1 - np.abs(bins_remain_cap - item) / (item + epsilon)\n    proportion_used = item / (bins_remain_cap + epsilon)\n    priority = np.where(valid_bins, relative_fit * proportion_used, -1.0)\n    \n    # Normalization and differentiation strategy inspired by priority_v1\n    if np.any(valid_bins):\n        max_priority = np.max(priority)\n        if max_priority > -1.0:  \n            priority = np.where(priority > -1.0, priority / max_priority, priority)\n        # Further differentiate among bins that can fit the item with high remaining capacity\n        priority = np.where((bins_remain_cap >= item) & (bins_remain_cap > item * 2),\n                            priority * 0.9,  # Slightly reduce priority for bins with high remaining capacity\n                            priority)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 3.8492221779018885,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 362.1069984276074,
    "mi": 85.27871372840569,
    "token_count": 232.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin using an advanced heuristic.\n\n    The heuristic combines multiple strategies to prioritize bins based on their remaining capacity,\n    focusing on nuanced prioritization, normalization, and differentiation among viable options.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the priority score for each bin based on the remaining capacity\n    # We want to prioritize bins where the item fits and leaves a reasonable remainder\n    priorities = np.where(bins_remain_cap >= item,\n                          # Combine the relative fit (how close the remaining capacity is to the item size)\n                          # with the proportion of the bin that will be used after adding the item\n                          (1 - (bins_remain_cap - item) / bins_remain_cap) * np.log(item / (bins_remain_cap - item + item) + 1),\n                          -1.0)  # Penalize bins that can't fit the item\n\n    # Normalize the priorities to ensure numerical stability and enhance differentiation\n    max_priority = np.max(priorities)\n    if max_priority > -1.0:  # Check if there are bins that can fit the item\n        priorities = np.where(priorities > -1.0, priorities / max_priority, priorities)\n\n    # Introduce a slight penalty for bins with very low utilization after adding the item\n    priorities = np.where((bins_remain_cap >= item) & ((item / (bins_remain_cap - item + item)) < 0.5),\n                          priorities * 0.8,  # Reduce priority for bins that will be less than half full\n                          priorities)\n\n    # Further differentiate among bins that can fit the item by slightly rewarding those with lower remaining capacity\n    priorities = np.where((bins_remain_cap >= item) & (bins_remain_cap <= item * 2),\n                          priorities * 1.1,  # Slightly increase priority for bins with relatively low remaining capacity\n                          priorities)\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.07820003461552,
    "mi": 81.12183185644896,
    "token_count": 156.0,
    "exec_success": true
  }
]