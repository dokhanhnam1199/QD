```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins where the item fits, favoring bins with
    less wasted space, but also slightly penalizing near-full bins to
    encourage packing smaller items into those. If the item doesn't fit,
    the priority is a large negative value, scaling inversely with
    the bin's remaining capacity (larger bins get a slightly less harsh penalty).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Give a large negative priority to bins where the item doesn't fit.
    no_fit_mask = item > bins_remain_cap
    priorities[no_fit_mask] = -1000 * (1 + 1/(bins_remain_cap[no_fit_mask]+0.0001))  # Adding small value for stability

    # Calculate priority for bins where the item fits.
    fit_mask = ~no_fit_mask
    remaining_after_fit = bins_remain_cap[fit_mask] - item

    # Prioritize bins with less wasted space. A smaller remaining_after_fit is better.
    priorities[fit_mask] = 1 / (remaining_after_fit + 0.0001)  # Adding small value for stability

    # Slightly penalize near-full bins (e.g., remaining capacity close to the item size).
    # This encourages filling more empty bins when small items are encountered.
    near_full_mask = (remaining_after_fit / bins_remain_cap[fit_mask]) < 0.1
    priorities[fit_mask][near_full_mask] *= 0.5 # Reduce priority by a factor of 2 if near full

    return priorities
```
