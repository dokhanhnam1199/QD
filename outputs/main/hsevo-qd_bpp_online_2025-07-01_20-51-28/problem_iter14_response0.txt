```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Calculate bin priorities based on near-fit, fragmentation, and utilization."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    bin_capacity = bins_remain_cap[0] 

    # Heuristic weights (tunable)
    near_fit_weight = 10.0
    fragmentation_penalty_weight = -5.0
    complete_fill_weight = 20.0
    utilization_penalty_weight = -2.0
    empty_bin_bonus_weight = 5.0

    for i, remaining_cap in enumerate(bins_remain_cap):
        if remaining_cap < item:
            priorities[i] = -np.inf
            continue

        # Near-fit bonus
        near_fit_ratio = item / remaining_cap
        if 0.9 <= near_fit_ratio <= 1.0:  # Check ratio within reasonable bounds
            priorities[i] += near_fit_weight * near_fit_ratio

        # Complete fill bonus
        if item == remaining_cap:
            priorities[i] += complete_fill_weight

        # Fragmentation penalty
        new_remaining = remaining_cap - item
        if 0 < new_remaining / bin_capacity < 0.1:
            priorities[i] += fragmentation_penalty_weight

        # Utilization penalty
        utilization = 1 - (remaining_cap / bin_capacity)
        if utilization > 0.75:
            priorities[i] += utilization_penalty_weight * (utilization**2) #square the effect

        # Empty bin bonus
        if remaining_cap == bin_capacity:
            priorities[i] += empty_bin_bonus_weight

    # Small bias to valid bins if no other bins are favorable.
    possible_bins = bins_remain_cap >= item
    if not np.any(priorities[possible_bins] > -np.inf):
        priorities[possible_bins] += 0.001

    return priorities
```
