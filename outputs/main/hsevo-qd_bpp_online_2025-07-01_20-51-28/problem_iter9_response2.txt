```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    num_bins = len(bins_remain_cap)
    
    # --- Adaptive Parameters ---
    near_fit_threshold_high = 0.95
    near_fit_threshold_low = 0.8
    near_fit_bonus_base = 10.0
    complete_fill_bonus_base = 20.0
    fragmentation_penalty_exponent = 2
    small_fragment_threshold = 0.1
    large_fragment_penalty_base = -5.0
    bin_utilization_threshold = 0.7 # Threshold to consider a bin as highly utilized
    
    # --- State-Dependent Adjustments ---
    avg_bin_capacity = np.mean(bins_remain_cap) if num_bins > 0 else 1.0  # Avoid division by zero
    
    # Adjust near fit bonus based on overall bin utilization.  If bins are generally full, be more aggressive with near fits.
    utilization_factor = np.mean((bins_remain_cap[bins_remain_cap > 0])/bins_remain_cap[0]) if num_bins > 0 else 0.0
    near_fit_bonus = near_fit_bonus_base * (1 + utilization_factor)
    
    # Adjust fragmentation penalty.  Increase the penalty if there are already many small fragments.
    num_small_fragments = np.sum(bins_remain_cap[bins_remain_cap > 0] / bins_remain_cap[0] < small_fragment_threshold)
    fragment_penalty_multiplier = 1 + (num_small_fragments / num_bins) if num_bins > 0 else 1.0
    large_fragment_penalty = large_fragment_penalty_base * fragment_penalty_multiplier
    
    #Complete fill bonus
    complete_fill_bonus = complete_fill_bonus_base * (1 + utilization_factor)

    # --- Priority Calculation ---
    valid_bins = bins_remain_cap > 0
    if not np.any(valid_bins):
        return priorities
    
    possible_bins = bins_remain_cap >= item

    for i, remaining_cap in enumerate(bins_remain_cap):
        if remaining_cap < item:
            priorities[i] = -np.inf
            continue

        # Near Fit: Adaptive threshold based on item size relative to average bin size
        near_fit_threshold = near_fit_threshold_high if item > avg_bin_capacity else near_fit_threshold_low
        if item / remaining_cap >= near_fit_threshold:
            priorities[i] += near_fit_bonus
            
        if item == remaining_cap:
            priorities[i] += complete_fill_bonus

        # Fragmentation: Adaptive penalty based on remaining capacity
        new_remaining = remaining_cap - item
        if new_remaining > 0 and (new_remaining / bins_remain_cap[0]) < small_fragment_threshold:
            priorities[i] += large_fragment_penalty
            
        #Preferentially place item in bins that are already highly utilized
        if (remaining_cap / bins_remain_cap[0]) < bin_utilization_threshold:
            priorities[i] += (bin_utilization_threshold - (remaining_cap / bins_remain_cap[0])) * 2 #Small bonus
            

    # If no bins can contain the item (after applying fragmentation penalty), slightly raise score of potential bins for placement
    if not np.any(priorities[possible_bins] > -np.inf):
        priorities[possible_bins] += 0.001

    return priorities
```
