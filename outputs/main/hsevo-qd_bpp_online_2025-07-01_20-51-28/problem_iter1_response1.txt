```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    A more sophisticated approach considering both space utilization and fragmentation.
    It prioritizes bins that can accommodate the item with minimal wasted space,
    while also penalizing bins that would be left with very small remaining capacities
    (likely leading to fragmentation). The function also incorporates a 'desperation'
    factor to encourage placing items in almost-full bins when necessary.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap >= item

    if not np.any(valid_bins):  # Desperation move: if no bin fits, find the least filled bin and place it there
        priorities = -bins_remain_cap
        return priorities
        

    remaining_after_fit = bins_remain_cap - item
    
    # Heuristic 1: Space Utilization (higher remaining capacity after placement, lower score)
    priorities[valid_bins] -= remaining_after_fit[valid_bins]
    
    # Heuristic 2: Fragmentation Penalty (small remaining capacity is bad - higher penalty)
    priorities[valid_bins] -= np.where(remaining_after_fit[valid_bins] < 0.1, 10, 0) # Heavily penalize small fragments. Change 0.1 & 10 if necessary
    
    # Heuristic 3: Proportional Fullness reward (Encourage filling bins more completely, but not too close.)
    priorities[valid_bins] += (item / bins_remain_cap[valid_bins])**2

    return priorities
```
