```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version considers:
        1. Remaining capacity. Favor bins with more remaining capacity, but only if the item fits.
        2. Waste minimization. Prefer bins that, when filled, result in the least amount of waste.
        3. Avoidance of near-full bins after packing. Discourage filling a bin to almost full capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate the space left after potentially placing the item in each bin
    remaining_space = bins_remain_cap - item

    # Invalidate bins where the item doesn't fit
    infeasible = remaining_space < 0
    priorities[infeasible] = -np.inf  # Ensures these bins are never selected

    # Reward fitting bins, higher remaining space preferred (within fitting bins)
    feasible = remaining_space >= 0
    priorities[feasible] = bins_remain_cap[feasible]  # Prefer higher initial capacity


    # Penalize bins which are nearly full after packing
    nearly_full = (remaining_space[feasible] / bins_remain_cap[feasible] < 0.1) # less than 10% left
    priorities[feasible][nearly_full] -= (bins_remain_cap[feasible][nearly_full] * 0.5) # reduce priority. Large initial capacity means large priority reduction if filled.

    # Reward bins with lower waste (smaller remaining space after packing if fitting)
    priorities[feasible] -= np.abs(remaining_space[feasible]) * 0.1 # slight waste minimization bias.

    return priorities
```
