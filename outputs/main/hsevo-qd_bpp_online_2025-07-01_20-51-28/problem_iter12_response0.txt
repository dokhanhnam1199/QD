```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A priority function for online bin packing that combines near-fit,
    fragmentation avoidance, capacity ratio, and dynamic adjustments.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # --- Parameters (with reasonable defaults) ---
    near_fit_threshold = 0.95
    near_fit_bonus = 15.0
    small_fragment_threshold = 0.1
    large_fragment_penalty = -7.0
    complete_fill_bonus = 25.0
    capacity_ratio_weight = 3.0
    bin_balance_weight = 1.5  # Encourage filling bins somewhat evenly
    waste_penalty_exponent = 2.0  # Emphasize avoiding larger waste

    # --- Pre-calculations ---
    valid_bins = bins_remain_cap > 0
    if not np.any(valid_bins):
        return priorities

    possible_bins = bins_remain_cap >= item
    
    if not np.any(possible_bins):
        return priorities # No possible bin.

    avg_bin_capacity = np.mean(bins_remain_cap[valid_bins])
    max_bin_capacity = np.max(bins_remain_cap[valid_bins])

    # --- Scoring Logic ---
    for i, remaining_cap in enumerate(bins_remain_cap):
        if remaining_cap < item:
            priorities[i] = -np.inf
            continue

        # --- Near Fit ---
        near_fit_ratio = item / remaining_cap
        if near_fit_ratio >= near_fit_threshold:
            priorities[i] += near_fit_bonus

        if item == remaining_cap:
            priorities[i] += complete_fill_bonus

        # --- Fragmentation ---
        new_remaining = remaining_cap - item
        if new_remaining > 0 and (new_remaining / avg_bin_capacity) < small_fragment_threshold:
            priorities[i] += large_fragment_penalty

        # --- Capacity Ratio ---
        priorities[i] += near_fit_ratio * capacity_ratio_weight

        # --- Bin Balance ---
        # Encourage filling bins roughly evenly to avoid extreme imbalances
        priorities[i] += (remaining_cap / max_bin_capacity) * bin_balance_weight

        # --- Waste Penalty ---
        # Penalize bins that would leave a large relative amount of waste
        waste_ratio = new_remaining / avg_bin_capacity if new_remaining > 0 and avg_bin_capacity > 0 else 0
        priorities[i] -= (waste_ratio ** waste_penalty_exponent) 
            
    # --- Handling Edge Cases / Adjustments ---
    # If no "good" bins, make all possible bins minimally acceptable.
    if not np.any(priorities[possible_bins] > -np.inf):
        priorities[possible_bins] += 0.001

    return priorities
```
