{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates dynamic adaptation based on bin utilization\n    and more nuanced fragmentation handling, along with a first-fit consideration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n\n    # --- Heuristic Parameters (Tunable) ---\n    near_fit_threshold = 0.9\n    near_fit_bonus = 15.0  # Increased bonus for near fit\n\n    fragmentation_penalty_exponent = 2.0\n    small_fragment_threshold = 0.1\n    large_fragment_penalty = -10.0 # Increased penalty for small fragments\n\n    complete_fill_bonus = 25.0 # Increased bonus for complete fill\n    first_fit_bonus = 5.0  # Bonus for placing in the first available bin\n\n    # Bin Utilization Awareness: Adjust near_fit_threshold based on avg bin capacity\n    avg_bin_capacity = np.mean(bins_remain_cap) if num_bins > 0 else 1.0 # avoid division by zero\n    if avg_bin_capacity < 0.3:\n      near_fit_threshold = 0.85 # be more aggressive if bins are filling up\n    elif avg_bin_capacity > 0.7:\n      near_fit_threshold = 0.95 # be stricter if bins are mostly empty\n\n    # --- Heuristic Logic ---\n\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return priorities\n\n    possible_bins = bins_remain_cap >= item\n\n    first_possible_bin_index = -1\n    for i in range(num_bins):\n        if bins_remain_cap[i] >= item:\n            first_possible_bin_index = i\n            break\n\n    for i, remaining_cap in enumerate(bins_remain_cap):\n        if remaining_cap < item:\n            priorities[i] = -np.inf\n            continue\n\n        # Near Fit\n        if item / remaining_cap >= near_fit_threshold:\n            priorities[i] += near_fit_bonus\n\n        if item == remaining_cap:\n            priorities[i] += complete_fill_bonus\n            \n\n        # Fragmentation - More nuanced penalty calculation\n        new_remaining = remaining_cap - item\n        if new_remaining > 0:\n            fragment_ratio = new_remaining / bins_remain_cap[0]\n            if fragment_ratio < small_fragment_threshold:\n                priorities[i] += large_fragment_penalty  # Strong penalty\n\n        # First Fit Preference (slight nudge, if applicable)\n        if i == first_possible_bin_index and first_possible_bin_index != -1:\n            priorities[i] += first_fit_bonus\n\n    # If no bins can contain the item, slightly raise score of potential bins\n    if not np.any(priorities[possible_bins] > -np.inf):\n        priorities[possible_bins] += 0.001\n\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}