```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers several factors:
    1. Can the item fit in the bin? If not, priority is -infinity.
    2. Waste minimization: Prioritizes bins with remaining capacity closest to the item size.
    3. Bin Utilization: Prioritizes bins that are already relatively full (high utilization).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf  # Initialize with -inf

    # Filter out bins that cannot accommodate the item
    valid_bins = bins_remain_cap >= item

    if not np.any(valid_bins):
        return priorities

    # Calculate waste (remaining capacity after adding item) for valid bins
    waste = bins_remain_cap[valid_bins] - item

    # Waste Minimization (lower waste is better, avoid fragmentation)
    waste_priority = -np.abs(waste)

    # Bin Utilization (prefer bins that are already relatively full).  Add a small constant to remaining capacity to avoid division by zero if a bin has zero remaining capacity.
    utilization_priority = 1 - (bins_remain_cap[valid_bins] / (bins_remain_cap[valid_bins] + 0.0001).max()) # Scales from 0 to 1
    
    #Combine priorities, weight them according to observed performance.
    combined_priority = waste_priority + 0.5 * utilization_priority

    # Assign priorities to the original array.
    priorities[valid_bins] = combined_priority

    return priorities
```
