```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    num_bins = len(bins_remain_cap)

    # Heuristic 1: "Near Fit" - Prefer bins where the item fills a significant portion
    near_fit_threshold_high = 0.95  # Tighter upper bound for near fit
    near_fit_threshold_low = 0.7 # Add a lower bound
    near_fit_bonus = 15.0  # Increased bonus for near fits

    # Heuristic 2: Avoid Fragmentation - Penalize bins that would become highly fragmented
    fragmentation_penalty_exponent = 2.5  # Stronger penalty
    small_fragment_threshold = 0.08  # Smaller fragment threshold
    large_fragment_penalty = -10.0  # Larger penalty

    # Heuristic 3: Complete Fill
    complete_fill_bonus = 25.0

    # Heuristic 4: Bin Usage - Prefer bins that are already partially filled (reduce bin count)
    already_used_bonus = 5.0
    empty_bin_penalty = -2.0 # Discourage opening new bins if better options exist

    # Heuristic 5: Item size relative to average remaining capacity
    item_vs_avg_threshold = 0.8 # If the item size is a large fraction of the average remaining capacity, prioritize better fit
    large_item_bonus = 3.0

    # Handle zero remaining capacity
    valid_bins = bins_remain_cap > 0
    if not np.any(valid_bins):
        return priorities

    possible_bins = bins_remain_cap >= item

    # Calculate average remaining capacity
    avg_remaining_capacity = np.mean(bins_remain_cap[valid_bins])

    for i, remaining_cap in enumerate(bins_remain_cap):

        if remaining_cap < item:
            priorities[i] = -np.inf
            continue

        # Near Fit (stricter)
        if near_fit_threshold_low <= (item / remaining_cap) <= near_fit_threshold_high:
            priorities[i] += near_fit_bonus

        if item == remaining_cap:
            priorities[i] += complete_fill_bonus

        # Fragmentation (stronger)
        new_remaining = remaining_cap - item
        if new_remaining > 0 and (new_remaining / bins_remain_cap[0]) < small_fragment_threshold:  # Compare against a base capacity
            priorities[i] += large_fragment_penalty

        # Bin Usage
        if remaining_cap < bins_remain_cap[0]: # crude way to determine if a bin has been used
            priorities[i] += already_used_bonus
        else:
             priorities[i] += empty_bin_penalty

        # Item size vs average remaining capacity
        if item / avg_remaining_capacity > item_vs_avg_threshold:
            # Prioritize bins with better fits to reduce overall fragmentation
            priorities[i] += large_item_bonus


    # Slightly raise score of potential bins for placement if nothing looks good
    if not np.any(priorities[possible_bins] > -np.inf):
        priorities[possible_bins] += 0.001

    return priorities
```
