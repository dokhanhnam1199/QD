```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Dynamic priority: near-fit, capacity ratio, prevent fragmentation."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap >= item  # Only consider bins that can fit the item

    if not np.any(valid_bins):
        return priorities  # No valid bins, all priorities remain zero

    # Near-fit bonus, scale by remaining capacity ratio
    near_fit_threshold = 0.2 # Adjust as needed
    near_fit_bonus = 15      # Adjust as needed
    near_fit = (bins_remain_cap - item) / bins_remain_cap <= near_fit_threshold
    priorities[valid_bins & near_fit] += near_fit_bonus * (bins_remain_cap[valid_bins & near_fit]/np.max(bins_remain_cap[valid_bins]))

    # Capacity ratio - prioritize bins with higher remaining capacity relative to item size
    capacity_ratio = item / bins_remain_cap
    priorities[valid_bins] += (1 - capacity_ratio[valid_bins]) * 5  #Scale added

    # Fragmentation penalty - prefer bins that won't leave tiny fragments
    fragment_threshold = 0.1 #adjust as needed
    large_fragment_penalty = -7 #adjust as needed
    fragment_size = (bins_remain_cap - item) / np.max(bins_remain_cap)
    priorities[valid_bins & (fragment_size <= fragment_threshold)] += large_fragment_penalty
    
    return priorities
```
