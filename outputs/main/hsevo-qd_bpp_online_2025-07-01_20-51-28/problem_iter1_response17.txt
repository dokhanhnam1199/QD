```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the energy levels in quantum mechanics, we introduce a "potential well"
    around bins that are just slightly larger than the item. This encourages filling those bins.
    We also penalize bins that are too small (repulsive force) or too large (less attractive).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 1e-6  # Small constant to avoid division by zero and log of zero
    potential_well_width = 0.2 * item  # Adjust this for different performance

    priorities = np.zeros_like(bins_remain_cap)

    for i, cap in enumerate(bins_remain_cap):
        if cap < item:  # Repulsion: Bin is too small
            priorities[i] = -1000 * (item - cap)  # Strong negative priority
        else:
            # "Potential well": Bins slightly larger than the item are preferred.
            # Gaussian-like function centered around item + potential_well_width / 2
            # Penalize bins with too much empty space.

            well_center = item + potential_well_width / 2
            deviation = abs(cap - well_center)

            priorities[i] = np.exp(-(deviation**2) / (2 * (potential_well_width/2)**2))
            # Further refine with log and inverse proportion to remaining cap to avoid over-filling optimal bins
            # This can be interpreted as minimizing waste while still considering the potential well.
            priorities[i] += np.log(item / (cap + epsilon)) * 0.5 # Add epsilon for safety.

    return priorities
```
