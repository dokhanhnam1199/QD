```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by gravitational attraction and minimizing wasted space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Gravitational Attraction: Larger remaining capacity, stronger initial attraction
    attraction = bins_remain_cap  # Directly proportional to remaining capacity

    # Penalty for exceeding capacity: avoid overflows at all cost
    penalty = np.where(bins_remain_cap < item, -np.inf, 0)

    # Waste Minimization: Prefer bins that fit snugly to minimize space wastage.
    # Use an exponential term to favour near-perfect fits more strongly
    space_waste = bins_remain_cap - item
    fit_preference = np.exp(-np.abs(space_waste) / item) if item > 0 else np.zeros_like(bins_remain_cap)
    fit_preference[space_waste<0] = 0 # ensure we don't add a positive contribution for bins that can't fit it

    # Combining factors with suitable weights.  Empirically tuned.
    priority = 0.5 * attraction + 0.7 * fit_preference + penalty

    return priority
```
