```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version considers:
        1. The absolute remaining capacity.
        2. The proportion of the item's size relative to the remaining capacity.
        3. A 'gravitational' pull towards bins that are nearly full.
        4. Penalizes bins that cannot accommodate the item (setting priority to -inf).
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Invalidate bins that cannot accommodate the item
    infeasible_bins = bins_remain_cap < item
    priorities[infeasible_bins] = -np.inf

    # Calculate priorities for feasible bins
    feasible_bins = ~infeasible_bins
    if np.any(feasible_bins):
        remaining_capacity = bins_remain_cap[feasible_bins]
        capacity_ratio = item / remaining_capacity
        # Ensure capacity_ratio is finite (avoid division by zero, though ideally `remaining_capacity` shouldn't be zero)
        capacity_ratio = np.where(remaining_capacity > 0, capacity_ratio, np.inf)
        capacity_ratio = np.clip(capacity_ratio, 0, 10)  # prevent inf or huge values

        # 'Gravitational' pull towards more full bins
        fullness_factor = 1 / (remaining_capacity + 0.001)  # Adding a small value to prevent division by zero
        
        # Combine factors. Adjust weights as needed based on experimental results.
        priorities[feasible_bins] = 0.5 * (1 - capacity_ratio) + 0.5 * fullness_factor # Higher means better fit
    
    return priorities
```
