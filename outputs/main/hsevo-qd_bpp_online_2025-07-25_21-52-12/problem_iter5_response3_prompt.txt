{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Balanced heuristic combining remaining space, compactness, and adaptive penalties.\"\"\"\n    \n    # High priority if adding this item leaves minimal space in the bin (similar to v1)\n    close_fit_priority = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Ward priority from v0: target filling tighter bins first\n    ward_priority = (bins_remain_cap - item) / bins_remain_cap\n    \n    # Compactness priority from v0: prefer bins that are already more filled\n    compactness_priority = np.ones_like(bins_remain_cap) - 1 / np.clip(bins_remain_cap, a_min=1e-3, a_max=None)\n    \n    # Size penalty from v0: penalize large items that would nearly fill a bin\n    size_penalty = np.where(bins_remain_cap < 2 * item, bins_remain_cap ** item / 50, 0)\n    \n    # Combine priorities: close fit, ward priority, compactness, and size penalties\n    priorities = close_fit_priority + ward_priority + compactness_priority - size_penalty\n    \n    # Ensure dynamic adjustment by normalizing priorities based on current state\n    priorities /= np.max(priorities, initial=1.0)\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Balanced heuristic combining remaining capacity and waste reduction with dynamic adjustments.\"\"\"\n    # Calculate waste reduction if item is added to each bin\n    waste_reduction = bins_remain_cap - item\n    # Penalize bins that cannot fit the item\n    priority_score = np.where(waste_reduction >= 0, waste_reduction, -1000)\n    # Encourage using less full bins with a sinusoidal function\n    capacity_factor = np.sin(np.pi / 2 * (bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)))\n    # Combine waste reduction with capacity factor\n    combined_score = priority_score * (1 + capacity_factor)\n    return combined_score\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristic (Heuristic 1st) integrates dynamic weighting and clipping for close fitting scenarios, which adds nuanced logic for prioritization based on remaining capacity and leftover space. The worst (Heuristic 20th) only penalizes non-fitting bins and encourages less full bins with a sinusoidal function, lacking depth in dynamic adjustments. \n\n(Second best) vs (second worst): The second-best heuristic (Heuristic 2nd) mirrors Heuristic 1st's base logic but without the clipping and dynamic weighting, indicating a simpler yet less effective strategy. The second-worst heuristic (Heuristic 19th) repeats logic from the worst, showing redundancy without improvement.\n\nComparing (1st) vs (2nd): Heuristic 1st adds a significant layer of dynamic weighting and clipping, offering a more adaptive and balanced approach than Heuristic 2nd\u2019s straightforward penalty mechanism.\n\n(3rd) vs (4th): Both heuristics are identical and represent a less flexible approach due to static penalty application, lacking the adaptability found in Heuristic 1st. \n\nComparing (second worst) vs (worst): Heuristic 19th and 20th are the same, highlighting the lack of improvement by sticking to a single sinusoidal approach without considering dynamic adjustments or penalties for large remaining spaces.\n\nOverall: The best heuristics exhibit adaptability with dynamic weighting and nuanced penalty mechanisms, which are lacking in the worst-performing heuristics, which tend to rely on simplistic and repetitive models.\n- \n- **Keywords:** Dynamic Adaptation, Nuanced Strategies, Logistic Balance, Avoid Simplism\n- **Advice:** Continuously refine heuristic algorithms through feedback loops, emphasizing adaptability and sophisticated penalty/reward structures.\n- **Avoid:** Rigid weighting schemes, overcomplicated penalties, disjointed algorithms, and static decision-making frameworks.\n- **Explanation:** Effective self-reflection involves creating heuristics that can adapt to new information and changing conditions, using balanced and logically structured penalties to guide improvement. Avoiding simplism ensures the heuristics can handle the complexity of real-world scenarios without becoming overly complicated or ineffective.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}