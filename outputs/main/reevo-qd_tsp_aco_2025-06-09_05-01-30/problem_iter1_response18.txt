```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) that estimates the
    likelihood of an edge being part of an optimal or near-optimal tour.

    This version incorporates multiple factors: distance, degree centrality, and
    a local search approximation.  It aims to be more sophisticated than a simple
    inverse distance heuristic. It also introduces sparsification.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i, j]
            represents the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing
            the heuristic values for each edge. Higher values indicate a greater
            likelihood of the edge being in a good TSP tour.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance component
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # 2. Degree centrality component (favor edges connecting to less-connected nodes)
    degree_centrality = np.sum(inverse_distance, axis=0) # Sum of inverse distances
    degree_matrix = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            degree_matrix[i, j] = degree_centrality[i] + degree_centrality[j]

    # 3. Local search approximation (2-opt improvement possibility)
    local_search_matrix = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i == j:
                local_search_matrix[i,j] = 0
                continue
            potential_improvement = 0
            for k in range(n):
                if k != i and k!= j:
                   for l in range(n):
                      if l != i and l != j and l != k:
                         original_distance = distance_matrix[i,k] + distance_matrix[j,l]
                         new_distance = distance_matrix[i,j] + distance_matrix[k,l]
                         potential_improvement = max(potential_improvement, original_distance - new_distance)
            local_search_matrix[i,j] = potential_improvement

    # Combine components (weighted sum)
    heuristic_matrix = (0.6 * inverse_distance +
                          0.2 * degree_matrix +
                          0.2 * local_search_matrix)

    # Sparsification: Set values below a threshold to zero.  This can help focus
    # stochastic sampling on more promising edges.
    threshold = np.mean(heuristic_matrix) * 0.2  # Dynamic threshold based on the mean
    heuristic_matrix[heuristic_matrix < threshold] = 0

    #Normalize heuristic_matrix so the values are between 0 and 1.
    max_val = np.max(heuristic_matrix)
    if max_val > 0:  # Avoid division by zero if all values are zero.
        heuristic_matrix = heuristic_matrix / max_val
    return heuristic_matrix
```
