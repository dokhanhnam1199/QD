```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using a combination of factors:
    - Inverse distance
    - Nearest neighbor consideration
    - Randomness (exploration)

    Args:
        distance_matrix (np.ndarray): Distance matrix of the TSP problem.

    Returns:
        np.ndarray: Heuristic matrix indicating the promise of each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance: More weight to shorter distances
    heuristic_matrix = 1 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero

    # 2. Nearest Neighbor Consideration: Prioritize edges connecting to nearby nodes
    for i in range(n):
        distances_from_i = distance_matrix[i, :]
        nearest_neighbors_indices = np.argsort(distances_from_i)[1:4]  # Top 3 nearest neighbors (excluding itself)
        for neighbor_index in nearest_neighbors_indices:
            heuristic_matrix[i, neighbor_index] *= 2  # Boost the heuristic value
            heuristic_matrix[neighbor_index, i] *= 2 # Ensure symmetry

    # 3. Randomness (Exploration): Introduce some noise to avoid local optima
    random_matrix = np.random.rand(n, n) * 0.1  # Small random values
    heuristic_matrix += random_matrix
    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T)/2 #ensure symmetry

    # 4. Sparsification: Zero out less promising edges.
    threshold = np.percentile(heuristic_matrix[np.triu_indices_from(heuristic_matrix, k=1)], 30)  # Keep top 70% edges

    heuristic_matrix[heuristic_matrix < threshold] = 0

    # Ensure symmetry
    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2

    # Normalize to have values between 0 and 1 (optional)
    max_val = np.max(heuristic_matrix)
    if max_val > 0:
        heuristic_matrix /= max_val
    
    return heuristic_matrix
```
