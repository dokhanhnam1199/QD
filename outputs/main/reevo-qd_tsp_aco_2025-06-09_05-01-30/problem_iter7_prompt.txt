{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Prior reflection]\nPrioritize nearest neighbors with a sharper decay (e.g., squared inverse rank). Sparsify connections and normalize probabilities carefully. Robustly handle average distances for global context. Omit centrality; focus on simplicity and direct inverse rank.\n- Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\n\n[Code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for TSP using a combination of factors and sparsification,\n    with improved nearest neighbor consideration and normalization.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n                    representing the heuristic values (prior indicators) for each edge.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Calculate nearest neighbors for each node\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                distance = distance_matrix[i, j]\n\n                # Heuristic factor 1: Inverse distance\n                heuristic_factor_1 = 1 / distance if distance > 0 else 0  # Avoid division by zero\n\n                # Heuristic factor 2:  Is j among i's nearest neighbors? Prioritize connections to nearer neighbours.\n                # The nearer the neighbor, the higher the value. Use a sharper decay.\n                nn_rank = np.where(nearest_neighbors[i] == j)[0][0] + 1 # Rank from 1 to N-1\n                heuristic_factor_2 = np.exp(-nn_rank/2) # Sharper decay than 1/rank\n\n                # Heuristic factor 3: Consider the \"average distance\" of the nodes involved\n                # If both i and j are relatively \"close\" to other nodes, connect them early.\n                # Averaging accounts for scenarios where one node is generally very far away from everything.\n                avg_dist_i = np.mean(distance_matrix[i, :])\n                avg_dist_j = np.mean(distance_matrix[j, :])\n                heuristic_factor_3 = 1 / (avg_dist_i + avg_dist_j) if (avg_dist_i + avg_dist_j) > 0 else 0\n\n                # Combine the factors\n                heuristic_matrix[i, j] = heuristic_factor_1 * heuristic_factor_2 * heuristic_factor_3\n\n    # Sparsify the matrix: keep only top K edges for each node (or edges below a certain threshold)\n    k = int(np.sqrt(n))  # Keep sqrt(n) nearest edges to each node (parameter can be tuned)\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        indices = np.argsort(row)[::-1]  # Indices of the highest values in descending order\n        keep_indices = indices[:k]       #Indices to retain\n\n        mask = np.ones(n, dtype=bool)\n        mask[keep_indices] = True\n        heuristic_matrix[i, ~mask] = 0  # Set other entries to zero, to allow efficient sampling later\n\n    # Normalize the heuristic values for better sampling behavior. This can potentially\n    # improve the initial probabilities when sampling for the solution. Robustly handle the case where all values are zero\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix = heuristic_matrix / max_heuristic\n    else:\n        # If all heuristic values are zero, set them to a small uniform value to allow for some exploration\n        heuristic_matrix = np.ones_like(heuristic_matrix) * 1e-9\n\n    return heuristic_matrix\n\n[Improved code]\nPlease write a mutated function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}