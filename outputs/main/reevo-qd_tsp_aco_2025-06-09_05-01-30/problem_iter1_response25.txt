```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This version combines several factors to estimate the desirability of including each edge
    in the solution: inverse distance, a "sparsification" based on median distance,
    and a penalty for edges connecting nodes with already many close neighbors.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix
                                      between cities.  distance_matrix[i][j] is the
                                      distance between city i and city j.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix, representing
                    the heuristic values for each edge. Higher values indicate a more
                    promising edge.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # 1. Inverse Distance: Shorter distances are generally better.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero.

    # 2. Sparsification:  Zero out edges that are longer than the median distance.
    median_distance = np.median(distance_matrix[distance_matrix > 0])  # exclude 0 from calculation
    sparse_matrix = np.where(distance_matrix <= median_distance, 1, 0)
    #3. Penalize already well connected edges
    connection_penalty = np.zeros_like(distance_matrix, dtype=float)

    # Iterate to apply penalty for nodes already connected by good edges
    for i in range(n):
        # Compute number of nearby cities
        nearby_cities = np.sum(sparse_matrix[i,:]) - 1  # subtract self-connection

        # Define a penalty factor, could be based on number of already connected nodes.
        penalty_factor = nearby_cities / (n - 1) # Higher for nodes with many nearby neighbors

        #Apply the penalty
        for j in range(n):
            connection_penalty[i, j] = penalty_factor

    # 4. Combine the factors:

    heuristics = inverse_distance * sparse_matrix * (1 - connection_penalty)

    return heuristics
```
