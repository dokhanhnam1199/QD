```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using stochastic solution sampling principles.

    Combines several factors to determine the promise of each edge and sparsifies the matrix.
    """
    n = distance_matrix.shape[0]

    # Avoid division by zero.  Set diagonal elements to a large value.
    temp_matrix = distance_matrix.copy()
    np.fill_diagonal(temp_matrix, np.inf)

    # 1. Inverse distance: Shorter edges are generally better.
    inverse_distance = 1 / temp_matrix

    # 2. Nearest neighbor heuristic: Edges to closer neighbors are better.
    nearest_neighbors = np.argsort(temp_matrix, axis=1)
    nearest_neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if j in nearest_neighbors[i, :5]:  # Top 5 nearest neighbors
                nearest_neighbor_bonus[i, j] = 1  # Or a value proportional to the rank
    
    # 3. Avoid long edges that connect distant clusters early.
    median_distance = np.median(distance_matrix[~np.isinf(distance_matrix)])
    avoid_long_edges = (distance_matrix <= median_distance).astype(float)  #Prefer short edges early
    
    # 4. Combining factors
    heuristic_matrix = inverse_distance * (0.5 + nearest_neighbor_bonus * 0.5) * (0.5 + avoid_long_edges * 0.5)
    

    # 5. Sparsification:  Set elements below a threshold to zero.
    threshold = np.quantile(heuristic_matrix[~np.isinf(heuristic_matrix)], 0.2)  #Keep top 80% values
    heuristic_matrix[heuristic_matrix < threshold] = 0

    #Set diagonal elements to zero, since TSP does not consider self-loops
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
