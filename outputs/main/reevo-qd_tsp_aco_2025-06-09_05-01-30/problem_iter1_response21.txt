```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP that combines multiple factors to estimate
    the desirability of including each edge in a solution.

    Args:
        distance_matrix (np.ndarray): A square matrix where element (i, j)
            represents the distance between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix,
            where each element (i, j) represents a heuristic score
            indicating how promising it is to include the edge (i, j)
            in a TSP solution. Higher scores indicate more promising edges.
    """

    n = distance_matrix.shape[0]

    # Initialize the heuristic matrix with the inverse distance.
    heuristic_matrix = 1 / (distance_matrix + 1e-9)  # Add a small value to avoid division by zero

    # Factor 1: Nearest neighbor heuristic. Nodes with shorter distances
    # to many other nodes should be prioritized.
    nearest_neighbors = np.argsort(distance_matrix, axis=1)
    for i in range(n):
        for j_index in range(1, min(4,n)):
            j = nearest_neighbors[i,j_index]
            heuristic_matrix[i, j] += 0.5 / (distance_matrix[i, j] + 1e-9) # Add some bonuses to top j neighbors

    # Factor 2: Penalty for edges connecting to already highly connected nodes.
    # (Avoid hubs initially.)  We approximate node connectivity by simply summing the
    # inverse distances for now, but more sophisticated approximations of
    # connectivity (e.g., PageRank) are also possible.
    node_connectivity = np.sum(1 / (distance_matrix + 1e-9), axis=0)
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] /= (node_connectivity[i] + node_connectivity[j])**0.3  # Avoid nodes with already high connectivity


    # Factor 3: Sparsification - set elements below a threshold to zero.
    # Only keep top k nearest neighbors
    k = int(np.sqrt(n)) # adaptive k based on problem size.
    for i in range(n):
        row = heuristic_matrix[i, :]
        threshold = np.sort(row)[-k]
        heuristic_matrix[i, row < threshold] = 0  # Sparsify the matrix


    # Return the heuristic matrix.
    return heuristic_matrix
```
