```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling.

    This version combines several factors to determine the promise of including each edge in a solution
    and sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): A 2D NumPy array representing the distance matrix.
                                         distance_matrix[i, j] is the distance between city i and city j.

    Returns:
        np.ndarray: A 2D NumPy array of the same shape as the distance matrix,
                    where each element indicates the "promise" of including the corresponding edge
                    in a TSP solution. Higher values indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance: Shorter edges are generally more promising.
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # 2. Node Degree: Prefer nodes with fewer close neighbors to avoid clustering.
    node_degree = np.sum(inverse_distance, axis=0)
    degree_factor = 1.0 / (node_degree[None, :] + node_degree[:, None] + 1e-9)

    # 3. Global Average Distance: Normalize by average distance in the matrix.
    avg_distance = np.mean(distance_matrix)
    normalized_distance = distance_matrix / avg_distance

    # 4. Combined Heuristic: Combine the factors.  Experiment with weights.
    heuristic_matrix = (0.6 * inverse_distance + 0.2 * degree_factor + 0.2 / (normalized_distance + 1e-9))

    # 5. Sparsification: Zero out edges that are deemed unpromising based on threshold
    threshold = np.percentile(heuristic_matrix[np.triu_indices_from(heuristic_matrix, k=1)], 20) # Keep top 80%
    heuristic_matrix[heuristic_matrix < threshold] = 0
    
    # Ensure diagonal elements are 0. Helpful for preventing self loops in solvers.
    np.fill_diagonal(heuristic_matrix, 0)
    
    return heuristic_matrix
```
