```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on distance,
    node degree (implicitly), and randomness.  Sparsifies the result.

    Args:
        distance_matrix: A numpy array representing the distance matrix between cities.

    Returns:
        A numpy array of the same shape as distance_matrix, representing the
        heuristic values for each edge.  Higher values indicate a more promising edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate a base heuristic based on inverse distance.  Add a small epsilon
    # to avoid division by zero and to make even distant edges slightly possible
    epsilon = 1e-9
    base_heuristic = 1 / (distance_matrix + epsilon)

    # Incorporate randomness to allow for exploration of less obvious edges.
    randomness = np.random.rand(n, n) * 0.1  # Adjust magnitude for importance

    # Combine the base heuristic with the randomness.
    heuristic_matrix = base_heuristic + randomness


    #Adjustments based on node proximity to multiple other nodes
    neighbor_bonus = np.zeros((n,n))
    for i in range(n):
        sorted_indices = np.argsort(distance_matrix[i,:])
        for j in sorted_indices[1:min(4,n)]: #top 3 closest neighbours (excluding itself)
            neighbor_bonus[i,j] = 0.1

    heuristic_matrix += neighbor_bonus

    # Sparsify the matrix.  Only keep edges with heuristic values above a threshold.
    # This helps to reduce the search space and focus on the most promising edges.

    threshold = np.percentile(heuristic_matrix[np.triu_indices_from(heuristic_matrix, k=1)], 40)  #Keep top 60% upper tri edges
    heuristic_matrix[heuristic_matrix < threshold] = 0



    # Ensure diagonal elements are zero to prevent self-loops.
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
