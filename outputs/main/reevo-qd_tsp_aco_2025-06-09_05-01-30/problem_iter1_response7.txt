```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This function combines multiple factors to estimate the likelihood of
    an edge being part of an optimal TSP tour. It incorporates inverse
    distance, nearest neighbor information, and a simple measure of centrality.
    Edges considered less promising are assigned a value of zero to sparsify
    the search space.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances
                                       between cities. distance_matrix[i][j] is
                                       the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each
                      element represents the heuristic value (promisingness) of
                      the corresponding edge.  Higher values indicate a more
                      promising edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # 1. Inverse Distance: Shorter edges are generally more desirable.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small value to avoid division by zero

    # 2. Nearest Neighbor: Edges connecting to nearby cities are also important
    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:4] #exclude self
    nearest_neighbor_bonus = np.zeros((n, n))
    for i in range(n):
        for neighbor in nearest_neighbors[i]:
            nearest_neighbor_bonus[i, neighbor] = 1
            nearest_neighbor_bonus[neighbor, i] = 1 # ensure symmetry

    # 3. Centrality: Cities closer to the "center" of the problem may be important.
    #    This is a very rudimentary measure; more sophisticated centrality measures could be used.
    city_centrality = np.sum(distance_matrix, axis=1)
    centrality_bonus = np.zeros((n, n))

    for i in range(n):
        for j in range(n):
            centrality_bonus[i, j] = (city_centrality[i] + city_centrality[j])

    # 4. Combine Factors (with some scaling)
    heuristic_matrix = (
        0.5 * inverse_distance +
        0.3 * nearest_neighbor_bonus +
        0.2 * (1 / (centrality_bonus + 1e-9))
    )

    # 5. Sparsify: Set values below a threshold to zero.
    threshold = np.mean(heuristic_matrix) * 0.2  # dynamic threshold based on mean
    heuristic_matrix[heuristic_matrix < threshold] = 0
    
    np.fill_diagonal(heuristic_matrix, 0) #remove self loops.
    return heuristic_matrix
```
