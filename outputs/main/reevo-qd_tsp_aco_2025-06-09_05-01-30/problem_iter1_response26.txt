```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) that combines
    multiple factors to determine the promise of including each edge in a solution.
    It sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): A square matrix where element [i, j]
                                      represents the distance between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing
                    the "promise" or prior indicator for each edge. Higher values
                    indicate more promising edges.  Unpromising edges are set to zero.
    """

    n = distance_matrix.shape[0]

    # 1. Inverse Distance: Shorter distances are generally better.
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Adding a small value to avoid division by zero

    # 2. Nearest Neighbor heuristic. Give higher score to edges connecting to the nearest neighbors.
    nearest_neighbor = np.zeros_like(distance_matrix)
    for i in range(n):
        # Find the indices of the k-nearest neighbors (excluding itself)
        distances_from_i = distance_matrix[i, :]
        nearest_neighbor_indices = np.argsort(distances_from_i)[1:4] # Consider top 3 nearest neighbors
        nearest_neighbor[i, nearest_neighbor_indices] = 1
        nearest_neighbor[nearest_neighbor_indices, i] = 1 # Ensure symmetry


    # 3. Node Degree Regularization:  Encourage edges to connect to nodes with fewer connections.
    degree_centrality = np.sum(inverse_distance, axis=0) # Sum of inverse distance represents the connectivity degree
    degree_matrix = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                degree_matrix[i, j] = (1 / (degree_centrality[i] + degree_centrality[j] + 1e-9))

    # 4. Combine the heuristics with weights
    combined_heuristic = (0.6 * inverse_distance +
                           0.2 * nearest_neighbor +
                           0.2 * degree_matrix)

    # 5. Sparsify: Zero out edges that are likely not to be in the optimal tour
    #    (e.g., based on a threshold relative to the mean heuristic value).
    threshold = 0.3 * np.mean(combined_heuristic) # dynamically chosen threshold

    sparse_heuristic = np.where(combined_heuristic > threshold, combined_heuristic, 0)

    return sparse_heuristic
```
