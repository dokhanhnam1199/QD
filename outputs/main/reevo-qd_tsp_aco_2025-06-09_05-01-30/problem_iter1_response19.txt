```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP that combines multiple factors to estimate edge promise.

    Args:
        distance_matrix: A numpy ndarray representing the distance matrix.

    Returns:
        A numpy ndarray of the same shape as distance_matrix,
        representing the prior indicators of edge inclusion.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # 1. Inverse Distance: Shorter distances are more promising.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # 2. Node Degree Preference: Prefer edges connecting to nodes with fewer connections to prevent subcycles early on.
    degree_preference = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                degree_preference[i, j] = 1.0  # initially, all edges are possible

    # 3. Sparsification: Remove long edges early.  Only consider edges shorter than the average.
    avg_distance = np.mean(distance_matrix)
    sparse_mask = distance_matrix <= avg_distance

    # 4. Combination: Combine the factors.  Inverse distance is the primary driver,
    #    but degree and sparsification help refine the search.
    heuristics = inverse_distance * degree_preference * sparse_mask

    # 5. Normalize
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    return heuristics
```
