```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This function estimates the "promise" of including each edge in a TSP solution.
    It combines several factors:

    1.  Inverse distance: Shorter distances are generally more desirable.
    2.  Node degree bias: Encourage edges connecting nodes with fewer connections,
        as nodes with many connections have more options for different edges in the optimal solution.
        The more 'constrained' are the nodes, the better the specific edge is in the solution
    3. Sparsification: Sets unpromising edges (long distances relative to average) to zero.

    Args:
        distance_matrix (np.ndarray): A square matrix where `distance_matrix[i][j]`
            represents the distance between node `i` and node `j`.

    Returns:
        np.ndarray: A matrix of the same shape as `distance_matrix` representing the
            heuristic scores (edge prior indicators).  Higher values indicate a more
            promising edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate average distance to sparsify
    avg_distance = np.mean(distance_matrix[distance_matrix != 0])

    # Compute a degree-like metric (inverse sum of distances to each node)
    node_degrees = np.zeros(n)
    for i in range(n):
        node_degrees[i] = 1 / np.sum(distance_matrix[i, :]) if np.sum(distance_matrix[i,:])>0 else 0 #Added check to avoid dividing by 0
    
    for i in range(n):
        for j in range(n):
            if i != j and distance_matrix[i, j] != 0:
                # Inverse distance
                heuristic_score = 1 / distance_matrix[i, j]
                # Node degree bias. Encouraging "constrained" nodes
                heuristic_score *= (node_degrees[i] + node_degrees[j])

                #sparsification based on distance
                if distance_matrix[i,j] > 2* avg_distance: #making sparsification not too aggresive
                    heuristic_score = 0
                
                heuristic_matrix[i, j] = heuristic_score
    
    # Normalize to ensure values are not too large or small which might cause problems in further usage of this heuristic matrix
    if np.max(heuristic_matrix) > 0:
      heuristic_matrix /= np.max(heuristic_matrix)
    

    return heuristic_matrix
```
