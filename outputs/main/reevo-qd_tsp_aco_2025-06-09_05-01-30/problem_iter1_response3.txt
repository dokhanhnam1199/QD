```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This function calculates a heuristic matrix that indicates the
    promise of including each edge in a TSP solution. It combines
    several factors:

    1.  Inverse Distance: Edges with shorter distances are more promising.
    2.  Node Degree: Nodes with fewer nearby neighbors are considered
        more important to connect. This promotes exploration of less
        dense areas of the graph.  Implemented via inverse row sum and inverse column sum.
    3.  Randomness: A small amount of randomness to encourage exploration.

    Args:
        distance_matrix (np.ndarray): A 2D NumPy array representing the
            distance matrix for the TSP.  distance_matrix[i, j] is the
            distance between node i and node j.

    Returns:
        np.ndarray: A 2D NumPy array of the same shape as the distance
            matrix, where each element represents the heuristic value
            for the corresponding edge.  Higher values indicate more
            promising edges.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance (MOST IMPORTANT)
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Avoid division by zero

    # 2. Node Degree (Implemented via inverse row & column sums)
    row_sums = np.sum(distance_matrix, axis=1, keepdims=True)
    col_sums = np.sum(distance_matrix, axis=0, keepdims=True)

    inverse_row_sums = 1 / (row_sums + 1e-9)
    inverse_col_sums = 1 / (col_sums + 1e-9)

    # Calculate Node Degree effect (product of inverse row and column sums)
    node_degree_effect = inverse_row_sums * inverse_col_sums

    # 3. Randomness (for exploration)
    randomness = np.random.rand(n, n) * 0.1  # Small random values


    # Combine the factors
    heuristic_matrix = (0.7 * inverse_distance +
                          0.2 * node_degree_effect +
                          0.1 * randomness)

    # Sparsify the matrix (optional, but can improve performance in some cases)
    threshold = np.percentile(heuristic_matrix[np.triu_indices_from(heuristic_matrix, k=1)], 20) # Only consider upper triangle
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
