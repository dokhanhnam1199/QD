```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).
    This version combines several factors to determine how promising it is to
    include each edge in a solution and sparsifies the matrix.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix.
                                         distance_matrix[i][j] is the distance between city i and city j.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix,
                    representing the prior indicators of how promising it is to
                    include each edge in a solution. Higher values indicate a more
                    promising edge.  Unpromising edges are set to 0.
    """
    n = distance_matrix.shape[0]

    # Initialize the heuristic matrix with inverse distance
    heuristic_matrix = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # Normalize the heuristic matrix
    heuristic_matrix = heuristic_matrix / np.max(heuristic_matrix)

    # Consider node degree: nodes with fewer nearby neighbors should be prioritized.
    degree_penalty = np.zeros_like(distance_matrix)
    for i in range(n):
        # For each node, find the closest k neighbors (excluding self)
        distances = distance_matrix[i].copy()
        distances[i] = np.inf  # Exclude self-loop

        #Find median distance of outgoing edges
        median_distance = np.median(distances[np.isfinite(distances)])

        for j in range(n):
              if distance_matrix[i,j] > median_distance:
                 degree_penalty[i,j] = 0.1  # Small penalty for edges to distant nodes.
              else:
                 degree_penalty[i,j] = 0 # No penalty

    heuristic_matrix = heuristic_matrix - degree_penalty

    # Sparsify the matrix: remove edges that are unlikely to be in the optimal tour.
    # Remove long edges and edges based on percentile of values.
    percentile_threshold = 75  # Remove edges below this percentile in attractiveness
    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], percentile_threshold) #Ignore 0 distance.

    heuristic_matrix[heuristic_matrix < threshold] = 0

    # Zero out diagonal elements to prevent self-loops
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
