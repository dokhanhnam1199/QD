{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Worse code]\ndef heuristics_v0(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for TSP using a combination of factors and sparsification.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n                    representing the heuristic values (prior indicators) for each edge.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Calculate nearest neighbors for each node\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                distance = distance_matrix[i, j]\n\n                # Heuristic factor 1: Inverse distance\n                heuristic_factor_1 = 1 / distance if distance > 0 else 0  # Avoid division by zero\n\n                # Heuristic factor 2:  Is j among i's nearest neighbors?  Prioritize connections to nearer neighbours.\n                # The nearer the neighbor, the higher the value.\n                nn_rank = np.where(nearest_neighbors[i] == j)[0][0] + 1 # Rank from 1 to N-1\n                heuristic_factor_2 = 1 / nn_rank\n\n                # Heuristic factor 3:  Consider the \"average distance\" of the nodes involved\n                # If both i and j are relatively \"close\" to other nodes, connect them early.\n                # Averaging accounts for scenarios where one node is generally very far away from everything.\n                avg_dist_i = np.mean(distance_matrix[i, :])\n                avg_dist_j = np.mean(distance_matrix[j, :])\n                heuristic_factor_3 = 1 / (avg_dist_i + avg_dist_j)\n\n                # Combine the factors\n                heuristic_matrix[i, j] = heuristic_factor_1 * heuristic_factor_2 * heuristic_factor_3\n\n    # Sparsify the matrix: keep only top K edges for each node (or edges below a certain threshold)\n    k = int(np.sqrt(n))  # Keep sqrt(n) nearest edges to each node (parameter can be tuned)\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        indices = np.argsort(row)[::-1]  # Indices of the highest values in descending order\n        keep_indices = indices[:k]       #Indices to retain\n\n        mask = np.ones(n, dtype=bool)\n        mask[keep_indices] = True\n        heuristic_matrix[i, ~mask] = 0  # Set other entries to zero, to allow efficient sampling later\n\n\n    # Normalize the heuristic values for better sampling behavior.  This can potentially\n    # improve the initial probabilities when sampling for the solution.\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n      heuristic_matrix = heuristic_matrix / max_heuristic\n\n\n    return heuristic_matrix\n\n[Better code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for TSP using a combination of factors and sparsification,\n    with improved nearest neighbor consideration, handling of edge cases, and robust normalization.\n    This version incorporates a global distance context and handles zero heuristic values more gracefully.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n                    representing the heuristic values (prior indicators) for each edge.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Calculate nearest neighbors for each node\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)\n\n    # Global distance context: average distance across the entire matrix.\n    global_avg_distance = np.mean(distance_matrix)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                distance = distance_matrix[i, j]\n\n                # Heuristic factor 1: Inverse distance, scaled by global average\n                heuristic_factor_1 = (global_avg_distance / distance) if distance > 0 else 0\n\n                # Heuristic factor 2: Exponential decay based on nearest neighbor rank\n                nn_rank = np.where(nearest_neighbors[i] == j)[0][0] + 1 if j in nearest_neighbors[i] else n\n                heuristic_factor_2 = np.exp(-nn_rank / 1.5)  # Tunable decay rate.  Higher value -> slower decay\n\n                # Heuristic factor 3: Combined average distance for both nodes, relative to the global average\n                avg_dist_i = np.mean(distance_matrix[i, :])\n                avg_dist_j = np.mean(distance_matrix[j, :])\n                heuristic_factor_3 = (2 * global_avg_distance) / (avg_dist_i + avg_dist_j) if (avg_dist_i + avg_dist_j) > 0 else 0\n\n                # Combine factors\n                heuristic_matrix[i, j] = heuristic_factor_1 * heuristic_factor_2 * heuristic_factor_3\n\n    # Adaptive Sparsification: Keep top K edges based on a fraction of N, ensuring at least 1\n    k = max(1, int(np.sqrt(n))) # Ensure at least one edge is kept.\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        indices = np.argsort(row)[::-1]  # Indices of the highest values in descending order\n        keep_indices = indices[:k]       # Indices to retain\n\n        mask = np.ones(n, dtype=bool)\n        mask[keep_indices] = True\n        heuristic_matrix[i, ~mask] = 0\n\n    # Robust Normalization with small default value for exploration.\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix = heuristic_matrix / max_heuristic\n    else:\n        heuristic_matrix = np.full_like(heuristic_matrix, 1e-6) # Set all to a small constant for exploration\n\n    return heuristic_matrix\n\n[Reflection]\nConsider global context, exponential neighbor ranking, adaptive sparsification, and normalization with default exploration.\n\n\n[Improved code]\nPlease write an improved function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}