```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using stochastic solution sampling with combined factors and sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix representing the distances between cities.

    Returns:
        np.ndarray: Heuristic matrix indicating the desirability of including each edge in the solution.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance: Shorter distances are generally more desirable.
    inverse_distance = 1 / (distance_matrix + 1e-6)  # Add a small constant to avoid division by zero.

    # 2. Nearest neighbor desirability:  Nodes with fewer close neighbors are more "critical" and edges
    #    connected to them should be favored to ensure these critical nodes are included early.
    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:4]  # Top 3 nearest neighbors
    neighbor_distance_sum = np.sum(np.take_along_axis(distance_matrix, nearest_neighbors, axis=1), axis=1)

    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] = inverse_distance[i, j] + 1.0/(neighbor_distance_sum[i] + neighbor_distance_sum[j] + 1e-6) # higher value is desirable
               
    # 3. Sparsification:  Zero out edges that are likely not part of a good solution.
    #    Keep only a certain percentage of the most promising edges for each node.
    percentage_to_keep = 0.3 # Keep top 30%
    for i in range(n):
        row = heuristic_matrix[i, :].copy() # make a copy before modification
        sorted_indices = np.argsort(row)[::-1]
        cutoff_index = int(n * percentage_to_keep)
        indices_to_zero = sorted_indices[cutoff_index:]
        for j in indices_to_zero:
            heuristic_matrix[i, j] = 0.0


    # Ensure symmetry (TSP is undirected, distances should be the same both ways).  Remove this
    # if you deal with directed problems
    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2

    np.fill_diagonal(heuristic_matrix, 0)  # No self-loops.

    return heuristic_matrix
```
