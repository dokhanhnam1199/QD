```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This version combines several factors to estimate the promise of each edge:
    1. Inverse distance: Shorter edges are generally more desirable.
    2. Node degree: Nodes with fewer close neighbors are encouraged to connect to the
       current node to avoid isolated clusters. This can be approximated by
       penalizing edges connecting to nodes that have many very short edges to other nodes.
    3. Sparsification: Set values for edges that are very long to zero.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances
                                       between cities. distance_matrix[i, j] is the
                                       distance from city i to city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each
                    element indicates the "promise" of including that edge in a TSP
                    solution. Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance (primary factor)
    heuristic_matrix = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # 2. Node degree adjustment (discourage high-degree nodes for initial connections)
    degree_penalty = np.zeros((n, n))
    for i in range(n):
        # Find indices of the k nearest neighbors of node i
        k = min(5, n - 1)  # Consider up to 5 nearest neighbors
        nearest_neighbors_indices = np.argsort(distance_matrix[i, :])[1:k+1] # exclude itself

        for j in range(n):

            #Penalize node i connecting to j if j is already connected to many nodes
            nearest_neighbors_of_j = np.argsort(distance_matrix[j, :])[1:k + 1]
            degree_penalty[i,j] = np.sum(1 / (distance_matrix[j, nearest_neighbors_of_j] + 1e-9))


    #Combine factor 1 and 2, but make sure it does not overshadow factor 1

    heuristic_matrix = heuristic_matrix / (degree_penalty + 1e-9)**0.2



    #3. Sparsification (remove very long edges)
    threshold = np.mean(distance_matrix) * 2  # Remove edges significantly longer than average.
    heuristic_matrix[distance_matrix > threshold] = 0


    return heuristic_matrix
```
