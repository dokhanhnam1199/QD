[
  {
    "stdout_filepath": "problem_iter24_response0.txt_stdout.txt",
    "code_path": "problem_iter24_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit_bonus = 1.0 / (remaining_after_item + 1e-6)\n    priorities = utilization + fit_bonus\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 0,
    "obj": 4.038691663342641,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response1.txt_stdout.txt",
    "code_path": "problem_iter24_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n\n    # Normalize the remaining capacity to [0, 1]\n    normalized_remaining = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Reward for fullness (inverse of remaining capacity)\n    fullness = 1.0 - normalized_remaining\n\n    # Reward for tight fit (inverse of remaining space after adding the item)\n    fit = 1.0 / (remaining_after_item + 1e-6)\n\n    # Combine the rewards with tuned weights\n    priorities = 0.7 * fullness + 0.3 * fit\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.32351694048162,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response2.txt_stdout.txt",
    "code_path": "problem_iter24_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n\n    # Reward fullness (higher is better)\n    fullness = remaining_after_item / bins_remain_cap[possible_bins]\n    fullness = 1.0 - fullness\n\n    # Reward tight fit (higher is better)\n    fit = 1.0 / (remaining_after_item + 1e-6)\n\n    # Combine rewards, weighting fit higher\n    priorities = 0.6 * fullness + 0.4 * fit\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 2,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 127.37720526058406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response3.txt_stdout.txt",
    "code_path": "problem_iter24_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n\n    # Normalize to ratios\n    fullness = remaining_after_item / bins_remain_cap[possible_bins]\n    fit = 1.0 / (remaining_after_item + 1e-6)\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Combine the factors with tuned coefficients\n    priorities = (1.0 - fullness) + (0.5 * fit) - (2.0 * wasted_space_ratio)\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 3,
    "obj": 4.068607897885915,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 162.53496664211536,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response4.txt_stdout.txt",
    "code_path": "problem_iter24_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n\n    # Reward near-full bins (smaller remaining capacity is better)\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Reward tight fits (smaller wasted space ratio is better)\n    fit = 1.0 / (remaining_after_item + 1e-6)\n\n    # Penalize large wasted space (larger wasted space ratio is worse)\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Combine the factors with adjusted weights\n    priorities = fullness + fit - (2.0 * wasted_space_ratio)\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 4,
    "obj": 4.028719585161557,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 144.75398259382442,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response5.txt_stdout.txt",
    "code_path": "problem_iter24_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit = 1.0 / (remaining_after_item + 1e-6)\n\n    priorities = 0.7 * fullness + 0.3 * fit\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 5,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.32351694048162,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response6.txt_stdout.txt",
    "code_path": "problem_iter24_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    \n    # Normalize remaining capacity to get fullness\n    fullness = remaining_after_item / bins_remain_cap[possible_bins]\n    fullness = 1.0 - fullness\n    \n    # Reward tight fits. Add a small constant to avoid division by zero\n    fit = 1.0 / (remaining_after_item + 1e-6)\n\n    # Combine the factors with adjusted weights\n    priorities = 0.7 * fullness + 0.3 * fit\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 6,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 127.37720526058406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response7.txt_stdout.txt",
    "code_path": "problem_iter24_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n\n    # Reward near-full bins (smaller remaining capacity is better)\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Reward tight fits (smaller wasted space ratio is better)\n    fit = 1.0 / (remaining_after_item + 1e-6)\n\n    # Penalize large wasted space (larger wasted space ratio is worse)\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Combine the factors, emphasizing fullness and fit, and penalizing wasted space\n    priorities = fullness + fit - (2.0 * wasted_space_ratio)\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 7,
    "obj": 4.028719585161557,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 144.75398259382442,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response8.txt_stdout.txt",
    "code_path": "problem_iter24_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Prioritize high utilization, small remaining space, and low wasted space\n    priorities = utilization - wasted_space_ratio\n\n    # Add a bonus for bins that are almost full\n    almost_full_bonus = np.where(bins_remain_cap[possible_bins] - remaining_after_item < 0.1 * bins_remain_cap[possible_bins], 0.1, 0.0)\n    priorities += almost_full_bonus\n\n    # Add a bonus for tight fits\n    tight_fit_bonus = np.exp(-abs(bins_remain_cap[possible_bins] - item) / (bins_remain_cap[possible_bins] + 1e-6)) * 0.1\n    priorities += tight_fit_bonus\n    \n    # Penalize if item completely fills the bin, but only slightly\n    completely_fills_penalty = np.where(remaining_after_item == 0, -0.01, 0.0)\n    priorities += completely_fills_penalty\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 8,
    "obj": 4.13841244515357,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 299.13186826628436,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response9.txt_stdout.txt",
    "code_path": "problem_iter24_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n\n    # Reward near-full bins (higher fullness is better)\n    fullness = remaining_after_item / bins_remain_cap[possible_bins]\n    fullness = 1.0 - fullness\n\n    # Reward tight fits (smaller remaining capacity after adding item is better)\n    fit = 1.0 / (remaining_after_item + 1e-6)\n\n    # Combine rewards (prioritize both fullness and fit)\n    priorities = fullness + fit\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 9,
    "obj": 4.038691663342641,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 92.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter25_response0.txt_stdout.txt",
    "code_path": "problem_iter25_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    \n    # Normalized reward for fullness (higher is better)\n    fullness = (bins_remain_cap[possible_bins] - remaining_after_item) / bins_remain_cap[possible_bins]\n    \n    # Normalized reward for fit (higher is better, penalizing wasted space)\n    fit = 1.0 / (remaining_after_item + 1e-6)\n    \n    # Combine the factors with weights.  Adjust weights as needed.\n    priorities = 0.6 * fullness + 0.4 * fit\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 131.18329672565338,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter25_response1.txt_stdout.txt",
    "code_path": "problem_iter25_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    \n    # Density: Combine fullness and fit\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit = item / bins_remain_cap[possible_bins]  # Reward tighter fits.\n\n    # Penalize wasted space (inverse residual capacity)\n    wasted_space = remaining_after_item\n    \n    # Combine factors with weights\n    priorities = (0.6 * fullness) + (0.4 * fit) - (0.2 * (wasted_space / bins_remain_cap[possible_bins]))\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 166.4210625757214,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter25_response2.txt_stdout.txt",
    "code_path": "problem_iter25_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    \n    # Reward near-full bins (smaller remaining capacity is better)\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Reward tight fits (smaller wasted space ratio is better)\n    fit = 1.0 / (remaining_after_item + 1e-6)\n\n    # Combine the factors with tuned weights\n    priorities = 0.6 * fullness + 0.4 * fit\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 2,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.32351694048162,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter25_response3.txt_stdout.txt",
    "code_path": "problem_iter25_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n\n    # Reward near-full bins (smaller remaining capacity is better)\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Reward tight fits (smaller wasted space ratio is better)\n    fit = 1.0 / (remaining_after_item + 1e-6)\n\n    # Combine the factors\n    priorities = 0.6 * fullness + 0.4 * fit  # Adjusted weights\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 3,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.32351694048162,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter25_response4.txt_stdout.txt",
    "code_path": "problem_iter25_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    \n    # Normalized reward for fullness (higher is better)\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    # Normalized reward for fit (higher is better)\n    fit = 1.0 / (remaining_after_item + 1e-6)\n    \n    # Penalty for wasted space (lower is better) - Inverse residual capacity\n    wasted_space = 1.0 / (bins_remain_cap[possible_bins] - item + 1e-6)\n    \n    # Combine factors with weights\n    priorities = 0.5 * fullness + 0.4 * fit - 0.1 * wasted_space \n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 4,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 213.7511637856132,
    "exec_success": true
  }
]