[
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    diff = bins_remain_cap - item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Prioritize exact fits\n    exact_fit = (diff == 0) & (diff >= 0)\n    priorities[exact_fit] = 2.0\n\n    # Prioritize bins where item fits, with preference for nearly full bins\n    possible_bins = diff >= 0\n    remaining_space = np.where(possible_bins, diff, np.inf)\n    priorities[possible_bins] = 1.0 / (remaining_space[possible_bins] + 1e-6)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 84.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    diff = bins_remain_cap - item\n    valid_bins = diff >= 0\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(valid_bins):\n        # Prioritize bins where the item fits well, but avoid *too* tight fits\n        # and don't strongly penalize nearly full bins.\n        priorities[valid_bins] = 1.0 / (np.sqrt(diff[valid_bins]) + 1e-6)\n\n        # Slightly boost bins that have very little remaining capacity,\n        # to try and close them off quickly. This helps with number of bins used.\n        priorities[bins_remain_cap < item * 2] += 0.1\n\n    return priorities",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 24, in priority_v2\n    result[possible_bins] = priorities\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n8\n2\n87.56842503028855\n"
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit) with a small addition to avoid zero division.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    diff = bins_remain_cap - item\n    priorities = np.where(diff < 0, 0.0, 1.0 / (diff + 1e-9))\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    # Combine utilization and inverse of remaining space for a more balanced priority\n    priorities = utilization + (1.0 / (remaining_after_item + 1e-6))\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    \n    return result",
    "response_id": 3,
    "obj": 4.038691663342641,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    diff = bins_remain_cap - item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Prioritize bins where the item fits\n    fit_indices = diff >= 0\n    priorities[fit_indices] = 1.0 / (diff[fit_indices] + 1e-6)\n\n    # Boost priority for nearly full bins\n    nearly_full_boost = 0.1  # Adjust this value as needed\n    nearly_full_indices = (bins_remain_cap > item * 0.9) & fit_indices\n    priorities[nearly_full_indices] += nearly_full_boost\n\n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 23, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n9\n1\n105.41561814669026\n"
  },
  {
    "stdout_filepath": "problem_iter12_response5.txt_stdout.txt",
    "code_path": "problem_iter12_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    diff = bins_remain_cap - item\n    diff = np.where(diff <= 0, 1e-6, diff)  # Avoid zero division and negative remain capacity\n    priorities = 1.0 / diff\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response6.txt_stdout.txt",
    "code_path": "problem_iter12_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    diff = bins_remain_cap - item\n    diff = np.where(diff <= 0, 1e-6, diff)  # Avoid division by zero and negative capacities\n\n    # Combine tighter fit (inverse of difference) with bin utilization\n    priorities = (1.0 / diff) * (bins_remain_cap / 1.0)  # Assuming bin capacity is 1.0\n\n    # Add a small bonus for bins that are already relatively full.\n    # This encourages filling up existing bins before opening new ones.\n    priorities = priorities + 0.1 * (bins_remain_cap / 1.0)\n\n    return priorities",
    "response_id": 6,
    "obj": 69.0765855604308,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response7.txt_stdout.txt",
    "code_path": "problem_iter12_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap)\n\n    # Combine utilization and remaining space.  Higher utilization is good,\n    # and smaller remaining space (but still positive) is also good.\n    priorities = utilization * (bins_remain_cap - item > 0)\n    priorities[~possible_bins] = 0.0\n\n    return priorities",
    "response_id": 7,
    "obj": 5.195452732349436,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 104.2481250360578,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response8.txt_stdout.txt",
    "code_path": "problem_iter12_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit) with a small addition to avoid zero division.\n    Also includes a bonus for bins that are close to being full (but still have capacity).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    diff = bins_remain_cap - item\n    diff = np.where(diff < 0, np.nan, diff)\n    \n    # Proximity fit (inverse distance)\n    priorities = np.where(diff < 0, 0.0, 1.0 / (diff + 1e-6))\n    \n    # Bonus for bins that are almost full\n    fullness = bins_remain_cap\n    bonus = fullness / (np.max(bins_remain_cap) + 1e-6)  # Scale to [0, 1]\n    priorities = priorities + 0.1 * bonus  # Add a small bonus\n    \n    return priorities",
    "response_id": 8,
    "obj": 35.63023534104507,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 114.6940428629768,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response9.txt_stdout.txt",
    "code_path": "problem_iter12_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit)\n    with a penalty for very full bins, considering item size relative to bin capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    diff = bins_remain_cap - item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize bins where the item fits\n    fits = diff >= 0\n    priorities[fits] = 1.0 / (np.abs(diff[fits]) + 1e-6)\n\n    # Penalize almost full bins based on the ratio of item size to bin capacity.\n    # More aggressive penalty as bin gets fuller.\n    fullness = bins_remain_cap\n    penalty = np.ones_like(bins_remain_cap)\n    penalty[fullness < item * 0.2] = 0.1  # Significant penalty if item occupies > 80% of bin\n    penalty[fullness < item * 0.5] = 0.5  # Moderate penalty if item occupies > 50% of bin\n    penalty[fullness < item] = 0.8 #Small penalty if item occupies > 0% of bin\n\n    priorities = priorities * penalty\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 131.76952268336282,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    Prioritizes tightest, near-full fits based on residual capacity & utilization.\n    Favor bins avoiding fragmentation. Penalize near-saturation proactively.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Prioritize near-full bins, but penalize very near-saturated bins\n    priority = utilization - 0.5 * (remaining_after_item / bins_remain_cap[possible_bins])**2\n    \n    # Add a small bonus for bins with very little remaining capacity (tight fit)\n    priority += 0.1 / (remaining_after_item + 1e-6)\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priority\n    return result",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 166.4210625757214,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response1.txt_stdout.txt",
    "code_path": "problem_iter13_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    Favors tight fits and avoids fragmentation. Penalizes near-saturation proactively.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    # Prioritize tighter fits (higher utilization)\n    priority = utilization\n\n    # Penalize near-saturation proactively (lower priority when remaining space is very small)\n    priority -= 0.1 * (1.0 / (remaining_after_item + 1e-6))\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priority\n    return result",
    "response_id": 1,
    "obj": 5.534503390506582,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response2.txt_stdout.txt",
    "code_path": "problem_iter13_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tighter fits and avoiding fragmentation.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    # Prioritize tighter fits (higher utilization) and avoid near-saturation.\n    # A small penalty is added if the bin is almost full.\n    priority = utilization - 0.1 * (1 - (remaining_after_item / bins_remain_cap[possible_bins]))\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priority\n    return result",
    "response_id": 2,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 110.44611534953322,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response3.txt_stdout.txt",
    "code_path": "problem_iter13_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tighter fits and avoiding fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Prioritize tighter fits (higher utilization) and avoid near-saturation\n    priorities = utilization - 0.1 * (1.0 - (remaining_after_item / (bins_remain_cap[possible_bins] + 1e-6))) \n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 3,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.32351694048162,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response4.txt_stdout.txt",
    "code_path": "problem_iter13_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tighter fits and avoiding fragmentation.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    \n    # Prioritize tighter fits (smaller remaining capacity)\n    fit_score = 1.0 / (remaining_after_item + 1e-6)\n    \n    # Penalize near-saturation (lower remaining capacity) - scaled to avoid dominance\n    saturation_penalty = np.exp(-remaining_after_item) * 0.5 \n\n    # Combine fit and saturation penalty\n    priorities = fit_score - saturation_penalty\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 4,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 93.45440529575887,
    "exec_success": true
  }
]