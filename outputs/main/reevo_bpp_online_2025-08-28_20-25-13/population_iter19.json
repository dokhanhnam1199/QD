[
  {
    "stdout_filepath": "problem_iter18_response0.txt_stdout.txt",
    "code_path": "problem_iter18_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    This version aims to reduce fragmentation by penalizing bins with large remaining capacities after packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    # Penalize bins with large remaining capacity *after* adding the item\n    fragmentation_penalty = 1.0 / (remaining_after_item + 1e-6)\n    \n    # Combine utilization and fragmentation penalty\n    priorities = utilization + fragmentation_penalty\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 0,
    "obj": 4.038691663342641,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response1.txt_stdout.txt",
    "code_path": "problem_iter18_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    # Combine utilization and inverse of remaining space for a more balanced priority\n    priorities = 0.6 * utilization + 0.4 * (1.0 / (remaining_after_item + 1e-6))\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.32351694048162,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response2.txt_stdout.txt",
    "code_path": "problem_iter18_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = bins_remain_cap[possible_bins] - remaining_after_item\n    priorities = utilization + (1.0 / (remaining_after_item + 1e-6))\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 2,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response3.txt_stdout.txt",
    "code_path": "problem_iter18_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    priorities = utilization + (1.0 / (remaining_after_item + 1e-6))\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 3,
    "obj": 4.038691663342641,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response4.txt_stdout.txt",
    "code_path": "problem_iter18_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    priorities = utilization + (1.0 / (remaining_after_item + 1e-6))\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 4,
    "obj": 4.038691663342641,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response5.txt_stdout.txt",
    "code_path": "problem_iter18_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing minimizing future waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    diff = bins_remain_cap - item\n    priorities = np.where(diff < 0, 0.0, np.sqrt(diff))  # Use square root for diminishing returns\n    return priorities",
    "response_id": 5,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 15.509775004326936,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response6.txt_stdout.txt",
    "code_path": "problem_iter18_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, item_frequency: float = 1.0) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit,\n    and considering item frequency. Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        item_frequency: A weight representing how often this item size appears. Higher frequency means more important.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Combine utilization, inverse of remaining space, and item frequency\n    priorities = item_frequency * (utilization + (1.0 / (remaining_after_item + 1e-6)))\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 6,
    "obj": 4.038691663342641,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response7.txt_stdout.txt",
    "code_path": "problem_iter18_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    diff = bins_remain_cap - item\n    diff = np.where(diff <= 0, 1e-9, diff)\n    priorities = 1.0 / diff\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response8.txt_stdout.txt",
    "code_path": "problem_iter18_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    # Wasted space ratio: remaining space after item / bin capacity\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Combine utilization, inverse of remaining space, and penalty for high wasted space\n    priorities = utilization + (1.0 / (remaining_after_item + 1e-6)) - (2 * wasted_space_ratio)\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 8,
    "obj": 4.028719585161557,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 144.75398259382442,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response9.txt_stdout.txt",
    "code_path": "problem_iter18_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization,\n    proximity fit, and minimizing future fragmentation.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Fragmentation penalty: Higher penalty for larger remaining space after packing\n    fragmentation_penalty = 1.0 / (remaining_after_item + 1e-6)\n\n    # Combine utilization, fragmentation penalty, and a small bonus for tighter fit\n    fit_bonus = 1.0 - abs(bins_remain_cap[possible_bins] - item) / bins_remain_cap[possible_bins]\n\n    priorities = (utilization * fragmentation_penalty) * fit_bonus\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 9,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.4736875252405,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response0.txt_stdout.txt",
    "code_path": "problem_iter19_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Prioritize high utilization directly, minimize wasted space\n    priorities = utilization - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 78.13781191217038,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response1.txt_stdout.txt",
    "code_path": "problem_iter19_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    priorities = utilization - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 78.13781191217038,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response2.txt_stdout.txt",
    "code_path": "problem_iter19_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    # Simplified priority: prioritize utilization directly\n    priorities = utilization\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 2,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 50.18947501009619,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response3.txt_stdout.txt",
    "code_path": "problem_iter19_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    # Prioritize high utilization directly.  Slightly penalize larger remaining spaces\n    priorities = utilization - 0.1 * (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 3,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 95.90827503317318,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response4.txt_stdout.txt",
    "code_path": "problem_iter19_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    # Prioritize bins with less remaining capacity (higher utilization)\n    priorities = 1.0 / (remaining_after_item + 1e-6)  # Inverse of remaining capacity\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 4,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  }
]