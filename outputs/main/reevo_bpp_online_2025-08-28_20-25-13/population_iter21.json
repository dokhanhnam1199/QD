[
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n    \n    # Prioritize high utilization, small remaining space, and low wasted space\n    priorities = utilization + (1.0 / (remaining_after_item + 1e-6)) - (2 * wasted_space_ratio)\n\n    # Add a small bonus for bins that are almost full\n    almost_full_bonus = np.where(bins_remain_cap[possible_bins] - remaining_after_item < 0.1 * bins_remain_cap[possible_bins], 0.1, 0.0)\n    priorities += almost_full_bonus\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 0,
    "obj": 4.028719585161557,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 217.98463765702255,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, item_frequency: float = 1.0) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and considering item frequency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        item_frequency: A weight representing how often this item size appears. Higher frequency means more important.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit_score = 1.0 - abs(bins_remain_cap[possible_bins] - item) / bins_remain_cap[possible_bins]\n\n    priorities = item_frequency * (utilization + fit_score)\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.32351694048162,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    diff = bins_remain_cap - item\n    diff = np.where(diff < 0, np.inf, diff)\n    priorities = 1.0 / diff\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response3.txt_stdout.txt",
    "code_path": "problem_iter20_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    This version aims to reduce fragmentation by penalizing bins with large remaining capacities after packing,\n    and also considers the relative size of the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Penalize bins with large remaining capacity *after* adding the item.\n    fragmentation_penalty = 1.0 / (remaining_after_item + 1e-6)\n\n    # Adjust penalty based on item size relative to bin capacity.  Smaller items\n    # should be penalized less for leaving space.\n    item_ratio = item / bins_remain_cap[possible_bins]\n    size_penalty = item_ratio  # Simple penalty, larger items get higher penalty\n\n    priorities = utilization + fragmentation_penalty - size_penalty\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 3,
    "obj": 4.198244914240141,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 125.33591475173351,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    # Combine utilization and inverse remaining capacity\n    priorities = utilization * (1.0 / (remaining_after_item + 1e-6))\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 4,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 95.90827503317318,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    priorities = utilization + (1.0 / (remaining_after_item + 1e-6))\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 5,
    "obj": 4.038691663342641,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    priorities = utilization + (1.0 / (remaining_after_item + 1e-6))\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 6,
    "obj": 4.038691663342641,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response7.txt_stdout.txt",
    "code_path": "problem_iter20_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and minimizing fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    # Penalize fragmentation: bins with very small remaining capacity after adding the item get lower priority\n    fragmentation_penalty = np.where(remaining_after_item < item * 0.2, 0.5, 0.0)\n    \n    # Combine utilization, inverse of remaining space, and fragmentation penalty\n    priorities = 0.5 * utilization + 0.3 * (1.0 / (remaining_after_item + 1e-6)) - 0.2 * fragmentation_penalty\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 7,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 197.10155180436175,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    # Combine utilization and inverse of remaining space to prioritize both fit and fragmentation avoidance\n    priorities = utilization + (1.0 / (remaining_after_item + 1e-6))\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 8,
    "obj": 4.038691663342641,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    priorities = utilization + (1.0 / (remaining_after_item + 1e-6)) + (0.5 * (1 - (remaining_after_item / bins_remain_cap[possible_bins])))\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 9,
    "obj": 4.307937774232155,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.4736875252405,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response0.txt_stdout.txt",
    "code_path": "problem_iter21_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    \n    # Reward near-full bins (smaller remaining capacity is better)\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Reward tight fits (smaller wasted space ratio is better)\n    fit = 1.0 / (remaining_after_item + 1e-6)\n\n    # Penalize large wasted space (larger wasted space ratio is worse)\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Combine the factors\n    priorities = fullness + fit - (1.5 * wasted_space_ratio)\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 0,
    "obj": 3.9988033506182825,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 144.75398259382442,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response1.txt_stdout.txt",
    "code_path": "problem_iter21_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    # Reward near-full bins: smaller remaining capacity is better\n    near_full_reward = 1.0 / (remaining_after_item + 1e-6)\n    # Tight fit: smaller difference between item and remaining capacity is better\n    tight_fit_reward = 1.0 / (np.abs(bins_remain_cap[possible_bins] - item) + 1e-6)\n\n    # Combine rewards\n    priorities = near_full_reward + tight_fit_reward\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 108.41805003750011,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response2.txt_stdout.txt",
    "code_path": "problem_iter21_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    # Reward near-full bins: prioritize bins where remaining capacity is small after adding item.\n    near_full_reward = 1.0 / (remaining_after_item + 1e-6)\n    # Tight fit reward: prioritize bins where the item fits snugly.\n    tight_fit_reward = 1.0 / (item + 1e-6)\n\n    # Combine rewards\n    priorities = near_full_reward + tight_fit_reward\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 2,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 92.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response3.txt_stdout.txt",
    "code_path": "problem_iter21_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    \n    # Reward near-full bins (small remaining capacity after adding item)\n    near_full_reward = 1.0 / (remaining_after_item + 1e-6)\n    \n    # Reward tight fits (small difference between item size and bin capacity)\n    tight_fit_reward = 1.0 / (item + 1e-6)\n\n    # Penalize wasted space (large remaining capacity after adding item)\n    wasted_space_penalty = remaining_after_item / (bins_remain_cap[possible_bins] + 1e-6)\n    \n    priorities = near_full_reward + tight_fit_reward - wasted_space_penalty\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 3,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 138.3016990363956,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response4.txt_stdout.txt",
    "code_path": "problem_iter21_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    \n    # Prioritize near-full bins (small remaining capacity)\n    near_full_bonus = 1.0 / (bins_remain_cap[possible_bins] + 1e-6)\n\n    # Prioritize tight fits (small remaining after item)\n    tight_fit_bonus = 1.0 / (remaining_after_item + 1e-6)\n\n    # Penalize wasted space (large remaining after item relative to bin size)\n    wasted_space_penalty = remaining_after_item / bins_remain_cap[possible_bins]\n\n    priorities = near_full_bonus + tight_fit_bonus - wasted_space_penalty\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 4,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 125.33591475173351,
    "exec_success": true
  }
]