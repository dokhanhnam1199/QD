[
  {
    "stdout_filepath": "problem_iter26_response0.txt_stdout.txt",
    "code_path": "problem_iter26_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit = 1.0 / (remaining_after_item + 1e-6)\n\n    priorities = fullness + fit\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 0,
    "obj": 4.038691663342641,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response1.txt_stdout.txt",
    "code_path": "problem_iter26_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit_bonus = 1.0 / (remaining_after_item + 1e-6)\n    priorities = utilization + fit_bonus\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 1,
    "obj": 4.038691663342641,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response2.txt_stdout.txt",
    "code_path": "problem_iter26_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Prioritize high utilization, small remaining space, and low wasted space\n    priorities = utilization - wasted_space_ratio\n\n    # Add a bonus for bins that are almost full (using a sigmoid function)\n    almost_full_bonus = 0.2 / (1 + np.exp(-10 * (bins_remain_cap[possible_bins] - remaining_after_item) / bins_remain_cap[possible_bins]))\n    priorities += almost_full_bonus\n\n    # Add a bonus for tight fits (exponentially decaying bonus)\n    tight_fit_bonus = np.exp(-abs(bins_remain_cap[possible_bins] - item) / (bins_remain_cap[possible_bins] + 1e-6)) * 0.1\n    priorities += tight_fit_bonus\n\n    # Penalize if item completely fills the bin, but only slightly\n    completely_fills_penalty = np.where(remaining_after_item == 0, -0.05, 0.0)\n    priorities += completely_fills_penalty\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 2,
    "obj": 4.13841244515357,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 350.50063248061946,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response3.txt_stdout.txt",
    "code_path": "problem_iter26_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    # Reward near-full bins (smaller remaining capacity is better)\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    # Reward tight fits (smaller wasted space ratio is better)\n    fit = 1.0 / (remaining_after_item + 1e-6)\n    # Penalize large wasted space (larger wasted space ratio is worse)\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Combine the factors with adjusted weights\n    priorities = 0.4 * fullness + 0.4 * fit - 0.2 * wasted_space_ratio\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 3,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 178.61670928936152,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response4.txt_stdout.txt",
    "code_path": "problem_iter26_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit = 1.0 / (remaining_after_item + 1e-6)\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    priorities = fullness + fit - wasted_space_ratio\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 4,
    "obj": 3.9888312724371757,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 125.33591475173351,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response5.txt_stdout.txt",
    "code_path": "problem_iter26_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n\n    # Reward near-full bins (smaller remaining capacity is better)\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Reward tight fits (larger item-to-capacity ratio is better)\n    fit = item / (bins_remain_cap[possible_bins] + 1e-6)  # Avoid division by zero\n\n    # Penalize larger remaining capacity ratio\n    remaining_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Combine factors with adjusted weights\n    priorities = (0.5 * fullness) + (0.4 * fit) - (0.1 * remaining_ratio)\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 5,
    "obj": 4.487435181491823,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 182.67948703818894,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response6.txt_stdout.txt",
    "code_path": "problem_iter26_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n\n    # Calculate wasted space ratio\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Calculate a fit score (inverse of wasted space)\n    fit_score = 1.0 / (wasted_space_ratio + 1e-6)\n\n    # Combine factors with tuned coefficients\n    priorities = fit_score - (0.5 * wasted_space_ratio)\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 6,
    "obj": 3.9988033506182825,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 97.70233280920246,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response7.txt_stdout.txt",
    "code_path": "problem_iter26_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n\n    # Reward near-full bins (higher fullness is better)\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Reward tight fits (smaller remaining capacity after adding item is better)\n    fit = 1.0 / (remaining_after_item + 1e-6)\n\n    # Combine rewards (prioritize both fullness and fit)\n    priorities = fullness + fit\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 7,
    "obj": 4.038691663342641,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response8.txt_stdout.txt",
    "code_path": "problem_iter26_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n\n    # Normalize to ratios\n    fullness = remaining_after_item / bins_remain_cap[possible_bins]\n    fit = 1.0 / (remaining_after_item + 1e-6)\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Combine the factors with tuned coefficients\n    priorities = (1.0 - fullness) + (0.5 * fit) - (1.5 * wasted_space_ratio)\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 8,
    "obj": 4.058635819704831,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 162.53496664211536,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response9.txt_stdout.txt",
    "code_path": "problem_iter26_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n\n    # Reward near-full bins (smaller remaining capacity is better)\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Reward tight fits (smaller wasted space ratio is better)\n    fit = 1.0 / (remaining_after_item + 1e-6)\n\n    # Penalize large wasted space (larger wasted space ratio is worse)\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Combine the factors with tuned weights\n    priorities = 0.6 * fullness + 0.4 * fit - 0.3 * wasted_space_ratio\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 9,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 180.68572508221183,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response0.txt_stdout.txt",
    "code_path": "problem_iter27_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit = 1.0 / (remaining_after_item + 1e-6)\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    priorities = 0.5 * fullness + 0.4 * fit - 0.1 * wasted_space_ratio\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 180.68572508221183,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response1.txt_stdout.txt",
    "code_path": "problem_iter27_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit = 1.0 / (remaining_after_item + 1e-6)\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n    \n    priorities = 0.6 * fullness + 0.4 * fit \n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 144.75398259382442,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response2.txt_stdout.txt",
    "code_path": "problem_iter27_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit = 1.0 / (remaining_after_item + 1e-6)  # Proximity fit\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    priorities = 0.6 * fullness + 0.4 * fit  # Direct reward for fullness & fit\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 2,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 144.75398259382442,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response3.txt_stdout.txt",
    "code_path": "problem_iter27_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    fullness = remaining_after_item / bins_remain_cap[possible_bins]\n    fit = 1.0 / (remaining_after_item + 1e-6)\n    priorities = fullness + fit\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 3,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response4.txt_stdout.txt",
    "code_path": "problem_iter27_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit = 1.0 / (remaining_after_item + 1e-6)\n    \n    priorities = 0.6 * fullness + 0.4 * fit  # Weighted combination\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 4,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.32351694048162,
    "exec_success": true
  }
]