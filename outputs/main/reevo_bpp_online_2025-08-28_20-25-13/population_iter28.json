[
  {
    "stdout_filepath": "problem_iter28_response0.txt_stdout.txt",
    "code_path": "problem_iter28_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    bin_capacities = bins_remain_cap[possible_bins]\n\n    # Normalize to ratios [0, 1]\n    fullness = 1.0 - (remaining_after_item / bin_capacities)\n    fit = 1.0 / (remaining_after_item + 1e-6)\n    wasted_space_ratio = remaining_after_item / bin_capacities\n\n    # Combine the factors with tuned coefficients.\n    # Prioritize fullness and fit, heavily penalize wasted space.\n    priorities = fullness + (0.7 * fit) - (2.0 * wasted_space_ratio)\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 0,
    "obj": 4.068607897885915,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.4736875252405,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response1.txt_stdout.txt",
    "code_path": "problem_iter28_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Prioritize high utilization, small remaining space, and low wasted space\n    priorities = 0.6 * utilization - 0.4 * wasted_space_ratio\n\n    # Add a bonus for bins that are almost full (using a sigmoid function)\n    almost_full_bonus = 0.3 / (1 + np.exp(-8 * (bins_remain_cap[possible_bins] - remaining_after_item) / bins_remain_cap[possible_bins]))\n    priorities += almost_full_bonus\n\n    # Add a bonus for tight fits (exponentially decaying bonus)\n    tight_fit_bonus = np.exp(-abs(bins_remain_cap[possible_bins] - item) / (bins_remain_cap[possible_bins] + 1e-6)) * 0.2\n    priorities += tight_fit_bonus\n\n    # Penalize if item completely fills the bin, but only slightly\n    completely_fills_penalty = np.where(remaining_after_item == 0, -0.1, 0.0)\n    priorities += completely_fills_penalty\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 1,
    "obj": 4.577183885121669,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 392.1728988800479,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response2.txt_stdout.txt",
    "code_path": "problem_iter28_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Prioritize high utilization, small remaining space, and low wasted space\n    priorities = utilization - wasted_space_ratio\n\n    # Add a bonus for bins that are almost full (using a sigmoid function)\n    almost_full_bonus = 0.3 / (1 + np.exp(-10 * (bins_remain_cap[possible_bins] - remaining_after_item) / bins_remain_cap[possible_bins]))\n    priorities += almost_full_bonus\n\n    # Add a bonus for tight fits (exponentially decaying bonus)\n    tight_fit_bonus = np.exp(-abs(bins_remain_cap[possible_bins] - item) / (bins_remain_cap[possible_bins] + 1e-6)) * 0.2\n    priorities += tight_fit_bonus\n\n    # Penalize if item completely fills the bin, but only slightly\n    completely_fills_penalty = np.where(remaining_after_item == 0, -0.1, 0.0)\n    priorities += completely_fills_penalty\n\n    # Add a small penalty for very large remaining capacity after adding item\n    large_remaining_penalty = np.where(remaining_after_item > 0.8 * bins_remain_cap[possible_bins], -0.05, 0.0)\n    priorities += large_remaining_penalty\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 2,
    "obj": 4.287993617869964,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 424.4571500548079,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response3.txt_stdout.txt",
    "code_path": "problem_iter28_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n    fit_score = 1.0 / (wasted_space_ratio + 1e-6)\n    priorities = fit_score - (0.2 * wasted_space_ratio)  # Adjusted coefficient\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 3,
    "obj": 3.9788591942560925,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 97.70233280920246,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response4.txt_stdout.txt",
    "code_path": "problem_iter28_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n\n    # Reward near-full bins (smaller remaining capacity is better)\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Reward tight fits (smaller wasted space ratio is better)\n    fit = 1.0 / (remaining_after_item + 1e-6)\n\n    # Penalize large wasted space (larger wasted space ratio is worse)\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n\n    # Combine the factors with tuned weights\n    priorities = 0.5 * fullness + 0.4 * fit - 0.2 * wasted_space_ratio\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 4,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 180.68572508221183,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response5.txt_stdout.txt",
    "code_path": "problem_iter28_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit = 1.0 / (remaining_after_item + 1e-6)\n    priorities = fullness + fit\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 5,
    "obj": 4.038691663342641,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response6.txt_stdout.txt",
    "code_path": "problem_iter28_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space. Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n    fit_score = 1.0 / (wasted_space_ratio + 1e-6)\n    priorities = fit_score - (0.2 * wasted_space_ratio)  # Adjusted coefficient\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 6,
    "obj": 3.9788591942560925,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 97.70233280920246,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response7.txt_stdout.txt",
    "code_path": "problem_iter28_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit = 1.0 / (remaining_after_item + 1e-6)\n    priorities = fullness + fit\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 7,
    "obj": 4.038691663342641,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response8.txt_stdout.txt",
    "code_path": "problem_iter28_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit = 1.0 / (remaining_after_item + 1e-6)\n    priorities = fullness + fit\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 8,
    "obj": 4.038691663342641,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response9.txt_stdout.txt",
    "code_path": "problem_iter28_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    fullness = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit = 1.0 / (remaining_after_item + 1e-6)\n    priorities = fullness + fit\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 9,
    "obj": 4.038691663342641,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  }
]