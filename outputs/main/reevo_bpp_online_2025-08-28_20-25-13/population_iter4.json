[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    diff = bins_remain_cap - item\n    diff = np.where(diff <= 0, 1e-6, diff)\n    priorities = 1.0 / diff\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Exact fit gets highest priority\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    if len(exact_fit_bins) > 0:\n        priorities[exact_fit_bins] = 1.0\n\n    # Next, prioritize bins that can fit the item, by smallest remaining capacity\n    possible_bins = np.where(bins_remain_cap >= item)[0]\n    if len(possible_bins) > 0:\n        remaining_capacities = bins_remain_cap[possible_bins]\n        sorted_indices = np.argsort(remaining_capacities)\n        priorities[possible_bins[sorted_indices]] = 0.5 - 0.4 * (sorted_indices / len(sorted_indices))\n\n    return priorities",
    "response_id": 1,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 85.83671966625714,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate fit score, penalizing impossible fits\n    fit_scores = np.full_like(bins_remain_cap, -np.inf)  # Initialize with -inf for impossible fits\n    feasible_bins = bins_remain_cap >= item\n    fit_scores[feasible_bins] = bins_remain_cap[feasible_bins] / item  # Higher ratio is better\n\n    # Apply sigmoid function for smoother prioritization\n    # Scaling factor and shift can be tuned for better performance\n    priorities = 1.0 / (1.0 + np.exp(-5.0 * (fit_scores - 1.0)))\n\n    return priorities",
    "response_id": 2,
    "obj": 35.380933386517746,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    waste = bins_remain_cap - item\n    waste = np.where(waste < 0, np.inf, waste)  # Penalize bins that are too small\n    priorities = 1.0 / waste\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    fit_scores = np.full_like(bins_remain_cap, 0.0)\n    fit_scores[possible_bins] = 1.0 - (item / bins_remain_cap[possible_bins])\n    priorities = 1.0 / (1.0 + np.exp(-3.0 * fit_scores))\n    return priorities",
    "response_id": 4,
    "obj": 4.487435181491823,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit_bins = (bins_remain_cap == item)\n    priorities[exact_fit_bins] = 1.0\n    # If no exact fit, prioritize bins where the item fits with minimum waste\n    fitting_bins = (bins_remain_cap >= item)\n    if np.any(fitting_bins):\n        waste = bins_remain_cap[fitting_bins] - item\n        priorities[fitting_bins] = 1.0 / (waste + 1e-6)  # Adding a small value to avoid division by zero\n    return priorities",
    "response_id": 5,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Exact fit gets highest priority.\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    if len(exact_fit_bins) > 0:\n        priorities[exact_fit_bins] = 1.0\n\n    # Then bins that can accommodate the item, sorted by remaining capacity.\n    possible_bins = np.where(bins_remain_cap >= item)[0]\n    if len(possible_bins) > 0:\n        remaining_capacities = bins_remain_cap[possible_bins]\n        sorted_indices = np.argsort(remaining_capacities)\n        priorities[possible_bins[sorted_indices]] = 0.5 - 0.4 * (sorted_indices / len(sorted_indices))\n\n    return priorities",
    "response_id": 6,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 85.83671966625714,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Exact fit gets highest priority\n    exact_fit = (bins_remain_cap == item)\n    priorities = np.where(exact_fit, 1000.0, 0.0)\n\n    # Calculate the difference between the item size and the remaining capacity of each bin\n    diff = bins_remain_cap - item\n\n    # Avoid division by zero and negative differences\n    diff = np.where(diff <= 0, 1e-6, diff)\n\n    # Sigmoid function to prioritize tighter fits\n    sigmoid_strength = 3.0  # Adjust for sensitivity\n    sigmoid_score = 1.0 / (1.0 + np.exp(-sigmoid_strength * (bins_remain_cap - item)))\n\n    # Combine scores: Prioritize sigmoid score where there's no exact fit.\n    priorities = np.where(exact_fit, priorities, sigmoid_score)\n\n    # Add a small bonus for bins that are already somewhat full (exploration).\n    # Scale the bonus to be relative to the maximum bin capacity.\n    bin_fullness = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n    priorities += 0.1 * bin_fullness\n\n    # Add a small penalty for almost empty bins to prevent creating too many bins\n    almost_empty_penalty = np.where(bins_remain_cap > 0.9 * np.max(bins_remain_cap), 0.05, 0.0)\n    priorities -= almost_empty_penalty\n\n    return priorities",
    "response_id": 7,
    "obj": 4.337854008775429,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 211.52361657053456,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    distances = np.abs(bins_remain_cap - item)\n    distances = np.where(distances == 0, 1e-6, distances)\n    priorities = 1.0 / distances\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    diff = bins_remain_cap - item\n    diff = np.where(diff <= 0, 1e-6, diff)\n    priorities = 1.0 / diff\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 27.0,
    "exec_success": true
  }
]