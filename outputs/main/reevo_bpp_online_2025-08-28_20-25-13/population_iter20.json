[
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and minimizing wasted space.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    wasted_space_ratio = remaining_after_item / bins_remain_cap[possible_bins]\n    \n    # Prioritize high utilization, small remaining space, and low wasted space\n    priorities = utilization + (1.0 / (remaining_after_item + 1e-6)) - (2 * wasted_space_ratio)\n\n    # Add a small bonus for bins that are almost full\n    almost_full_bonus = np.where(bins_remain_cap[possible_bins] - remaining_after_item < 0.1 * bins_remain_cap[possible_bins], 0.1, 0.0)\n    priorities += almost_full_bonus\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 0,
    "obj": 4.028719585161557,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 217.98463765702255,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, item_frequency: float = 1.0) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit, and considering item frequency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        item_frequency: A weight representing how often this item size appears. Higher frequency means more important.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    fit_score = 1.0 - abs(bins_remain_cap[possible_bins] - item) / bins_remain_cap[possible_bins]\n\n    priorities = item_frequency * (utilization + fit_score)\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.32351694048162,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    diff = bins_remain_cap - item\n    diff = np.where(diff < 0, np.inf, diff)\n    priorities = 1.0 / diff\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response3.txt_stdout.txt",
    "code_path": "problem_iter20_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    This version aims to reduce fragmentation by penalizing bins with large remaining capacities after packing,\n    and also considers the relative size of the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n\n    # Penalize bins with large remaining capacity *after* adding the item.\n    fragmentation_penalty = 1.0 / (remaining_after_item + 1e-6)\n\n    # Adjust penalty based on item size relative to bin capacity.  Smaller items\n    # should be penalized less for leaving space.\n    item_ratio = item / bins_remain_cap[possible_bins]\n    size_penalty = item_ratio  # Simple penalty, larger items get higher penalty\n\n    priorities = utilization + fragmentation_penalty - size_penalty\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 3,
    "obj": 4.198244914240141,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 125.33591475173351,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    # Combine utilization and inverse remaining capacity\n    priorities = utilization * (1.0 / (remaining_after_item + 1e-6))\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 4,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 95.90827503317318,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    priorities = utilization + (1.0 / (remaining_after_item + 1e-6))\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 5,
    "obj": 4.038691663342641,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    priorities = utilization + (1.0 / (remaining_after_item + 1e-6))\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 6,
    "obj": 4.038691663342641,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response7.txt_stdout.txt",
    "code_path": "problem_iter20_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and minimizing fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    # Penalize fragmentation: bins with very small remaining capacity after adding the item get lower priority\n    fragmentation_penalty = np.where(remaining_after_item < item * 0.2, 0.5, 0.0)\n    \n    # Combine utilization, inverse of remaining space, and fragmentation penalty\n    priorities = 0.5 * utilization + 0.3 * (1.0 / (remaining_after_item + 1e-6)) - 0.2 * fragmentation_penalty\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 7,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 197.10155180436175,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    \n    # Combine utilization and inverse of remaining space to prioritize both fit and fragmentation avoidance\n    priorities = utilization + (1.0 / (remaining_after_item + 1e-6))\n\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 8,
    "obj": 4.038691663342641,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing higher space utilization and proximity fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_after_item = bins_remain_cap[possible_bins] - item\n    utilization = 1.0 - (remaining_after_item / bins_remain_cap[possible_bins])\n    priorities = utilization + (1.0 / (remaining_after_item + 1e-6)) + (0.5 * (1 - (remaining_after_item / bins_remain_cap[possible_bins])))\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 9,
    "obj": 4.307937774232155,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.4736875252405,
    "exec_success": true
  }
]