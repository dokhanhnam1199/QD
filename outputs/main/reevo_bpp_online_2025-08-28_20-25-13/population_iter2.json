[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Only consider bins that can fit the item\n    valid_bins = remaining_after_placement >= 0\n\n    # Initialize priorities to a low value for invalid bins\n    priorities = np.full_like(bins_remain_cap, -1.0)\n\n    # For valid bins, prioritize tighter fits (smaller remaining capacity)\n    priorities[valid_bins] = 1.0 / (remaining_after_placement[valid_bins] + 1e-9)\n\n    # Further prioritize bins with higher initial remaining capacity (better utilization)\n    priorities[valid_bins] *= bins_remain_cap[valid_bins]\n\n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    distances = np.abs(bins_remain_cap - item)\n    distances = np.where(distances == 0, 1e-6, distances)\n    priorities = 1.0 / distances\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Exact fit gets highest priority.\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    if len(exact_fit_bins) > 0:\n        priorities[exact_fit_bins] = 100  # High priority for exact fit.\n\n    # Then bins that can accommodate the item, sorted by remaining capacity.\n    possible_bins = np.where(bins_remain_cap >= item)[0]\n    if len(possible_bins) > 0:\n        remaining_capacities = bins_remain_cap[possible_bins]\n        sorted_indices = np.argsort(remaining_capacities)\n        priorities[possible_bins[sorted_indices]] = 0.5 - 0.4 * (sorted_indices / len(sorted_indices))\n\n    return priorities",
    "response_id": 2,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 85.83671966625714,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Exploitation: Best-Fit Decreasing with Density Consideration\n    for i, remain_cap in enumerate(bins_remain_cap):\n        if item <= remain_cap:\n            density = item / remain_cap  # Item density in this bin\n            priorities[i] = -density # Lower density is better\n            \n    # Exploration: Random bin with remaining capacity\n    eligible_bins = np.where(bins_remain_cap >= item)[0]\n    if np.random.random() < epsilon and len(eligible_bins) > 0:\n        random_bin_index = np.random.choice(eligible_bins)\n        priorities[random_bin_index] += 1.0  # Boost priority for exploration\n\n    return priorities",
    "response_id": 3,
    "obj": 15.935380933386515,
    "SLOC": 11.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 99.40434618240934,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Sigmoid Fit Score with a preference for tighter fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate the remaining capacity after placing the item\n    remaining_after_pack = bins_remain_cap - item\n\n    # Identify bins where the item fits\n    valid_bins = remaining_after_pack >= 0\n\n    if not np.any(valid_bins):\n        return priorities  # No suitable bin\n\n    # Calculate the 'tightness' of the fit:  smaller remaining space is better\n    fit_scores = remaining_after_pack[valid_bins]\n\n    # Normalize the fit scores to a 0-1 range, so that the sigmoid function can work properly\n    min_fit = np.min(fit_scores)\n    max_fit = np.max(fit_scores)\n    normalized_fit_scores = (fit_scores - min_fit) / (max_fit - min_fit + 1e-9)\n\n    # Apply sigmoid function with a steeper slope to emphasize tighter fits\n    # Adjust parameters to control the shape of the sigmoid\n    scale = 5.0  # Controls the steepness of the sigmoid\n    shift = 0.2  # Shifts the sigmoid curve\n    priorities[valid_bins] = 1.0 / (1.0 + np.exp(-scale * (normalized_fit_scores - shift)))\n    \n    return priorities",
    "response_id": 4,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 161.66617507355795,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate fit score, penalizing impossible fits\n    fit_scores = np.full_like(bins_remain_cap, np.inf)\n    fit_scores[bins_remain_cap >= item] = item / bins_remain_cap[bins_remain_cap >= item]\n    \n    # Apply sigmoid function for smoother prioritization\n    # Scaling factor and shift can be tuned for better performance\n    priorities = 1.0 / (1.0 + np.exp(-2.0 * (fit_scores - 0.5)))\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.198244914240141,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit_bins = (bins_remain_cap == item)\n    priorities[exact_fit_bins] = 1.0\n\n    # If no exact fit, prioritize bins where the item fits with minimum waste\n    if not np.any(exact_fit_bins):\n        fitting_bins = (bins_remain_cap >= item)\n        if np.any(fitting_bins):\n            waste = bins_remain_cap[fitting_bins] - item\n            priorities[fitting_bins] = 1.0 / (waste + 1e-6)  # Adding a small value to avoid division by zero\n    return priorities",
    "response_id": 6,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 64.72503367497926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin. Args: item: Size of item to be added to the bin. bins_remain_cap: Array of capacities for each bin. Return: Array of same size as bins_remain_cap with priority score of each bin. \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit_bins = (bins_remain_cap == item)\n    priorities[exact_fit_bins] = 2.0  # Highest priority\n\n    # If no exact fit, prioritize bins where the item fits with minimum waste\n    if not np.any(exact_fit_bins):\n        fitting_bins = (bins_remain_cap >= item)\n        if np.any(fitting_bins):\n            waste = bins_remain_cap[fitting_bins] - item\n            priorities[fitting_bins] = 1.0 / (waste + 1e-6)  # Higher priority for less waste\n\n    # Additionally, prioritize fuller bins (to reduce fragmentation)\n    bin_fullness = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n    priorities = priorities + 0.1 * bin_fullness # Add a bonus for fuller bins\n\n    return priorities",
    "response_id": 7,
    "obj": 86.58755484643,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 131.18329672565338,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Prioritize bins where the item fits exactly\n    exact_fit_bins = (bins_remain_cap == item)\n    priorities[exact_fit_bins] = 1.0\n\n    # If no exact fit, prioritize bins where the item fits with minimum waste\n    if not np.any(exact_fit_bins):\n        fitting_bins = (bins_remain_cap >= item)\n        if np.any(fitting_bins):\n            waste = bins_remain_cap[fitting_bins] - item\n            priorities[fitting_bins] = 1.0 / (waste + 1e-6)  # Adding a small value to avoid division by zero\n\n    return priorities",
    "response_id": 8,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 64.72503367497926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate greedy priority (Best Fit Decreasing)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        priorities[eligible_bins] = bins_remain_cap[eligible_bins] - item\n\n    # Epsilon-Greedy exploration\n    if np.random.rand() < epsilon:\n        # Assign random priorities to all bins that can fit the item\n        if np.any(eligible_bins):\n            random_priorities = np.random.rand(np.sum(eligible_bins))\n            priorities[eligible_bins] = random_priorities\n    else:\n        # Add a small bonus to bins that are nearly full\n        nearly_full_bins = (bins_remain_cap > 0) & (bins_remain_cap <= item)\n        priorities[nearly_full_bins] += 0.1  # Small bonus\n\n    return priorities",
    "response_id": 9,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 31, in priority_v2\n    priorities[nearly_full_bins] += 0.1  # Small bonus\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n14\n4\n85.83671966625714\n"
  }
]