```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines exact fit prioritization with scaled normalized slack for non-exact fits,
    and uses a tie-breaker based on initial bin capacity to favor fuller bins.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
        
        # --- Primary objective: Exact Fit ---
        # High priority for bins that perfectly fit the item.
        exact_fit_mask = np.isclose(fitting_bins_remain_cap, item)
        priorities[can_fit_mask][exact_fit_mask] = 1.0
        
        # --- Secondary objective: Scaled Normalized Slack ---
        # For bins that can fit but are not exact fits.
        non_exact_fit_mask = ~exact_fit_mask
        
        if np.any(non_exact_fit_mask):
            eligible_bins_for_non_exact = fitting_bins_remain_cap[non_exact_fit_mask]
            
            # Calculate remaining capacity after placing the item
            remaining_capacities_if_fit = eligible_bins_for_non_exact - item
            
            # Normalized slack: remaining capacity / original bin capacity. Smaller is better.
            epsilon = 1e-9
            normalized_slack = remaining_capacities_if_fit / (eligible_bins_for_non_exact + epsilon)
            
            # Priority: Higher score for smaller normalized slack (closer to 1.0).
            # Scale these scores to be distinct from exact fits, e.g., between 0.5 and 0.99.
            non_exact_priorities = 0.5 + 0.49 * (1.0 - normalized_slack)
            
            # --- Tertiary objective: Tie-breaking with initial bin fullness ---
            # For bins with similar normalized slack, prefer those that were initially fuller.
            # This means bins with less remaining capacity before fitting the item.
            # We incorporate this by slightly adjusting priorities based on the original remaining capacity.
            # A smaller original remaining capacity (i.e., a fuller bin) gets a slight boost.
            # This boost is scaled to be less significant than normalized slack.
            initial_capacities_for_non_exact = eligible_bins_for_non_exact
            
            # Add a small positive value for fuller bins.
            # The term -initial_capacities_for_non_exact directly penalizes bins with large remaining capacity.
            # By adding this term (which is negative), we effectively boost fuller bins.
            # A small scale factor ensures it's a tie-breaker.
            tie_breaker_scale = 0.001
            priorities[can_fit_mask][non_exact_fit_mask] = non_exact_priorities + tie_breaker_scale * (-initial_capacities_for_non_exact)

    return priorities
```
