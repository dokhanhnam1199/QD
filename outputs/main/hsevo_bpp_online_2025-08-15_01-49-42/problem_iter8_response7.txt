```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid heuristic: exact fit, then best-fit by minimizing remaining capacity,
    with a secondary preference for bins with less initial slack.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]
        eligible_indices = np.where(can_fit_mask)[0]

        # Exact fit: highest priority
        exact_fit_mask = (eligible_bins_remain_cap == item)
        if np.any(exact_fit_mask):
            priorities[eligible_indices[exact_fit_mask]] = 1.0
        
        # For non-exact fits, prioritize bins that leave the minimum remaining capacity.
        # This is equivalent to maximizing -(remaining_capacity - item).
        # To ensure these scores are distinct from exact fits (1.0) and
        # to provide a meaningful range for best-fit, we scale this value.
        non_exact_fit_mask = (eligible_bins_remain_cap > item)
        
        if np.any(non_exact_fit_mask):
            non_exact_indices = eligible_indices[non_exact_fit_mask]
            non_exact_remain_caps = eligible_bins_remain_cap[non_exact_fit_mask]
            
            # Calculate scores for non-exact fits: maximize ( -(remaining_capacity - item) )
            # Score is higher for smaller remaining capacity after fitting.
            # Scale these scores to be less than 1.0, e.g., in the range [0.5, 0.95].
            
            remaining_after_fit = non_exact_remain_caps - item
            
            # Normalize residuals to [0, 1], where 0 is best (min residual)
            max_remaining_after_fit = np.max(remaining_after_fit)
            # Add epsilon for stability if all residuals are the same
            normalized_remaining = remaining_after_fit / (max_remaining_after_fit + 1e-9)
            
            # Scale to a range below 1.0, e.g., [0.5, 0.95].
            # This maps best-fit (normalized_remaining near 0) to ~0.95
            # and worst-fit (normalized_remaining near 1) to ~0.5.
            best_fit_scores = 0.5 + (1.0 - normalized_remaining) * 0.45
            
            # Assign these scores to the non-exact fits
            priorities[non_exact_indices] = best_fit_scores

    return priorities
```
