{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements a priority function based on the First Fit strategy for the online Bin Packing Problem.\n    This heuristic prioritizes bins that can accommodate the item and have the least remaining capacity\n    after fitting the item (i.e., bins that will be \"most full\" after packing).\n    It returns a priority score for each bin.\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A NumPy array representing the remaining capacity of each bin.\n\n    Returns:\n        A NumPy array of the same size as bins_remain_cap, where each element is the priority score\n        for the corresponding bin. Bins that cannot fit the item are given a priority of 0.\n        Among the bins that can fit the item, a higher priority is given to bins that will have\n        less remaining capacity after the item is placed.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            \n            remaining_after_fit = capacity - item\n            \n            \n            priorities[i] = 1.0 / (remaining_after_fit + 1e-9)  \n            \n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins_mask = bins_remain_cap >= item\n    suitable_bins = bins_remain_cap[suitable_bins_mask]\n    if suitable_bins.size > 0:\n        differences = suitable_bins - item\n        min_diff = np.min(differences)\n        priorities[suitable_bins_mask] = 1.0 / (differences - min_diff + 1e-9)\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    suitable_bins_mask = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n    \n    if suitable_bins_remain_cap.size > 0:\n        # Inverse distance (proximity fit): prioritize bins that are closer to fitting the item\n        # A smaller remaining capacity (but still fitting) is better\n        # We want to invert this, so larger values mean higher priority\n        # Using (1 / (remaining_capacity - item + epsilon)) to avoid division by zero and heavily favor bins with minimal leftover space.\n        # Adding a small constant to remaining capacity before inversion to push smaller leftover spaces to higher priorities\n        \n        # Option 1: Simple inverse of remaining capacity, emphasizing tighter fits\n        # priorities[suitable_bins_mask] = 1.0 / (suitable_bins_remain_cap + 1e-9)\n        \n        # Option 2: Prioritize bins that leave minimal waste, which means remaining_capacity is closest to item size\n        # Difference from item size: (remaining_capacity - item)\n        # Smaller difference is better, so we want to invert it for higher priority.\n        # Add a small constant to avoid division by zero and to ensure that bins that exactly fit get a high priority.\n        differences = suitable_bins_remain_cap - item\n        priorities[suitable_bins_mask] = 1.0 / (differences + 1.0 + 1e-9) \n\n        # Option 3: Weighted inverse distance - could consider how \"full\" the bin is relative to its initial capacity if that info was available.\n        # For now, sticking to relative to item size.\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Almost Full Fit priority function.\n\n    This strategy prioritizes bins that will be \"almost full\" after placing the item.\n    A bin is considered \"almost full\" if its remaining capacity after placing the item\n    is small. We want to select the bin that leaves the minimum remaining capacity,\n    provided it can accommodate the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin. Bins that cannot accommodate the item\n        receive a priority of -1. Higher scores indicate higher priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        remaining_capacities_if_fit = bins_remain_cap[can_fit_mask] - item\n        \n        # We want to prioritize bins where the remaining capacity is *minimal* after fitting.\n        # So, a smaller remaining capacity should yield a higher priority.\n        # We can invert the remaining capacity values and then scale them or just use\n        # a value inversely proportional to the remaining capacity.\n        # Here, we'll use 1 / (remaining_capacity + epsilon) to avoid division by zero\n        # and to ensure smaller remaining capacities get higher scores.\n        # A simple approach is to subtract from a large number or use a negative linear function.\n        # Let's use a value that is inversely proportional to remaining capacity.\n        # However, to keep it simpler and still capture the \"almost full\" idea,\n        # we can assign a higher priority to bins that leave a smaller remainder.\n        # A very direct interpretation of \"almost full\" is to prioritize the bin\n        # that, after placing the item, has the smallest *positive* remaining capacity.\n        # This can be achieved by minimizing `bins_remain_cap - item`.\n        # So, we want to *maximize* the negative of `bins_remain_cap - item`.\n        \n        priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)\n        \n        # Alternative: Use a small epsilon to make it robust\n        # epsilon = 1e-9\n        # priorities[can_fit_mask] = 1.0 / (remaining_capacities_if_fit + epsilon)\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    for i, remaining_cap in enumerate(bins_remain_cap):\n        if remaining_cap >= item:\n            exact_fit_diff = remaining_cap - item\n            priorities[i] = -exact_fit_diff  # Prioritize bins with minimal remaining space after fitting\n    \n    # Among bins that can fit the item, we want to prioritize the one\n    # that leaves the least amount of remaining space (exact fit).\n    # Negative value for priority implies that smaller remaining capacity is better.\n    # If multiple bins offer the exact same smallest remaining capacity,\n    # the one that appears first in the array will be chosen due to the loop's nature.\n    \n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    available_bins_mask = bins_remain_cap >= item\n    available_bins_caps = bins_remain_cap[available_bins_mask]\n    if available_bins_caps.size > 0:\n        priorities[available_bins_mask] = 1.0 / (available_bins_caps - item + 1e-9)\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Exact Fit First heuristic priority function.\n    Prioritizes bins that can exactly fit the item.\n    Among those that can exactly fit, it prioritizes the one that leaves the least remaining capacity.\n    If no bin can exactly fit, it prioritizes the bin that leaves the least positive remaining capacity after placing the item (Best Fit).\n    If no bin can fit the item, all priorities will be zero.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Identify bins that can exactly fit the item\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n\n    if len(exact_fit_indices) > 0:\n        # Among exact fits, pick the one that leaves least residual capacity (which is 0 in this case)\n        # This is an arbitrary choice as all exact fits result in 0 residual.\n        # We'll just give them the highest priority.\n        priorities[exact_fit_indices] = 1.0\n    else:\n        # If no exact fit, use a Best Fit approach\n        # Find bins where the item can fit\n        fit_indices = np.where(bins_remain_cap >= item)[0]\n\n        if len(fit_indices) > 0:\n            # Calculate remaining capacity for bins that can fit the item\n            residual_capacities = bins_remain_cap[fit_indices] - item\n\n            # Assign priorities based on smallest residual capacity (Best Fit)\n            # We want to prioritize smaller residuals, so we can invert them or subtract from a max value\n            # A simple way is to assign a higher score to smaller residuals.\n            # Let's use a scale that makes smaller residuals higher priority.\n            # Max possible residual is related to bin capacity, but we don't know that.\n            # Let's use inverse of residual + a small epsilon to avoid division by zero if residual is 0.\n            # However, since we handled exact fit, residual will be > 0 here.\n            # Let's assign priority such that smaller positive residual gets higher priority.\n            # A linear mapping could work: priority = MaxPossibleResidual - Residual.\n            # Since we don't know MaxPossibleResidual, let's try a large number minus the residual.\n            # Or simply, we can assign priorities inversely proportional to residual capacity.\n            # To make it a \"priority score\" that's higher for better fits:\n            # Consider a value inversely proportional to the *excess* capacity above the item.\n            # Let's use a score such that 1 / (residual + epsilon) or similar.\n            # A simpler approach for 'best fit' in a priority system:\n            # Maximize -(residual capacity)\n            # So, we want the bin where residual_capacity is minimized.\n            # We can map this to a positive priority score.\n            # For example, map the minimum residual to the highest score.\n\n            # Let's define a scaling factor or a base priority for fitting.\n            # Give a base priority for fitting, then enhance it for better fit.\n            base_priority = 0.5\n            fit_priorities = base_priority + (1 - base_priority) * (1 - residual_capacities / np.max(residual_capacities + 1e-9))\n            # Adding 1e-9 to denominator to avoid division by zero if all residuals are identical and maximal.\n            # The term (1 - residual_capacities / np.max(residual_capacities + 1e-9))\n            # will range from 0 (for max residual) to near 1 (for min residual).\n            # So, fit_priorities will range from 0.5 to 1.0.\n\n            priorities[fit_indices] = fit_priorities\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1 / (bins_remain_cap[i] - item + 1e-9)\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    available_bins_mask = bins_remain_cap >= item\n    available_bins_caps = bins_remain_cap[available_bins_mask]\n    if available_bins_caps.size > 0:\n        priorities[available_bins_mask] = 1.0 / (available_bins_caps - item + 1e-9)\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1 / (bins_remain_cap[i] - item + 1e-9)\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins_mask = bins_remain_cap >= item\n    priorities[suitable_bins_mask] = 1 / (bins_remain_cap[suitable_bins_mask] - item + 1e-9)\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    available_bins_mask = bins_remain_cap >= item\n    available_bins_caps = bins_remain_cap[available_bins_mask]\n    if available_bins_caps.size > 0:\n        priorities[available_bins_mask] = 1.0 / (available_bins_caps - item + 1e-9)\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins_mask = bins_remain_cap >= item\n    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n\n    if valid_bins_remain_cap.size == 0:\n        return np.zeros_like(bins_remain_cap)\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    feasible_bins_mask = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if not np.any(feasible_bins_mask):\n        return priorities\n\n    feasible_bins_remain_cap = bins_remain_cap[feasible_bins_mask]\n    \n    diffs = feasible_bins_remain_cap - item\n    \n    scaled_diffs = diffs / np.max(feasible_bins_remain_cap) if np.max(feasible_bins_remain_cap) > 0 else np.zeros_like(diffs)\n    \n    sigmoid_scores = 1 / (1 + np.exp(-5 * (scaled_diffs - 0.5)))\n    \n    priorities[feasible_bins_mask] = sigmoid_scores\n    \n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    feasible_bins_mask = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if not np.any(feasible_bins_mask):\n        return priorities\n\n    feasible_bins_remain_cap = bins_remain_cap[feasible_bins_mask]\n    \n    diffs = feasible_bins_remain_cap - item\n    \n    scaled_diffs = diffs / np.max(feasible_bins_remain_cap) if np.max(feasible_bins_remain_cap) > 0 else np.zeros_like(diffs)\n    \n    sigmoid_scores = 1 / (1 + np.exp(-5 * (scaled_diffs - 0.5)))\n    \n    priorities[feasible_bins_mask] = sigmoid_scores\n    \n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    feasible_bins_mask = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if not np.any(feasible_bins_mask):\n        return priorities\n\n    feasible_bins_remain_cap = bins_remain_cap[feasible_bins_mask]\n    \n    diffs = feasible_bins_remain_cap - item\n    \n    scaled_diffs = diffs / np.max(feasible_bins_remain_cap) if np.max(feasible_bins_remain_cap) > 0 else np.zeros_like(diffs)\n    \n    sigmoid_scores = 1 / (1 + np.exp(-5 * (scaled_diffs - 0.5)))\n    \n    priorities[feasible_bins_mask] = sigmoid_scores\n    \n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    eligible_bins_mask = bins_remain_cap >= item\n    \n    if not np.any(eligible_bins_mask):\n        return np.zeros_like(bins_remain_cap)\n        \n    eligible_bins_remain_cap = bins_remain_cap[eligible_bins_mask]\n    \n    \n    differences = eligible_bins_remain_cap - item\n    \n    \n    scaled_differences = differences / np.max(eligible_bins_remain_cap)\n    \n    \n    exponentiated_priorities = np.exp(scaled_differences)\n    \n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[eligible_bins_mask] = exponentiated_priorities\n    \n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    eligible_bins_mask = bins_remain_cap >= item\n    \n    if not np.any(eligible_bins_mask):\n        return np.zeros_like(bins_remain_cap)\n        \n    eligible_bins_remain_cap = bins_remain_cap[eligible_bins_mask]\n    \n    \n    differences = eligible_bins_remain_cap - item\n    \n    \n    scaled_differences = differences / np.max(eligible_bins_remain_cap)\n    \n    \n    exponentiated_priorities = np.exp(scaled_differences)\n    \n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[eligible_bins_mask] = exponentiated_priorities\n    \n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Worst Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    fitting_bins_capacities = bins_remain_cap[can_fit_mask]\n    \n    if fitting_bins_capacities.size > 0:\n        \n        priorities[can_fit_mask] = fitting_bins_capacities - item\n        \n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Worst Fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask] - item\n    priorities[~can_fit_mask] = -np.inf\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}