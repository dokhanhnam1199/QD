```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive Slack Fit priority function.

    This strategy prioritizes bins by considering the slack remaining after
    placing the item, normalized by the item's size. It aims to find bins
    that are a good fit, penalizing overly large remaining capacities.
    Exact fits are highly prioritized.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of priority scores for each bin. Bins that cannot accommodate the item
        receive a priority of -1. Higher scores indicate higher priority.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
        
        # Calculate slack for bins that can fit the item
        slack = fitting_bins_remain_cap - item
        
        # Prioritize exact fits (slack is 0) with a high score
        exact_fit_mask = (slack == 0)
        priorities[can_fit_mask][exact_fit_mask] = 1000.0 # High priority for exact fits
        
        # For bins that are not exact fits, calculate a priority based on normalized slack.
        # We want to minimize slack, so a lower slack should give a higher score.
        # We can use a score that is inversely related to the slack relative to the item size.
        # A common approach is to use a form like C - slack / item_size.
        # Let's use a score that is larger for smaller slack.
        # We use a small epsilon to avoid division by zero if item size is very small,
        # and to ensure that even with very small items, the relative slack is meaningful.
        epsilon = 1e-9
        non_exact_fit_mask = ~exact_fit_mask
        
        if np.any(non_exact_fit_mask):
            normalized_slack = slack[non_exact_fit_mask] / (item + epsilon)
            
            # To prioritize bins with less slack, we can use a score like 1 / (normalized_slack + 1)
            # or a linear function that decreases with normalized slack.
            # Let's aim for a score that is high when normalized slack is low.
            # We can map the normalized slack to a priority score.
            # A simple mapping: Max possible priority (for exact fit) - normalized slack.
            # Or, we can scale it to a range.
            
            # A strategy: prioritize bins that leave the smallest *normalized* remainder.
            # This means we want to maximize `-(slack / item)`.
            # Adding a constant to ensure positive scores or using exponential decay could also work.
            # Let's assign a score that's higher for smaller normalized slack.
            # We can take the negative of the normalized slack, and then potentially add a base score.
            # To differentiate from exact fits, we ensure these scores are lower.
            
            # Let's use a score that decreases as normalized slack increases.
            # We can use a score like: BaseScore - Factor * normalized_slack
            # For example, BaseScore = 500, Factor = 500.
            # So, if normalized_slack = 0.1, score = 500 - 50 = 450.
            # If normalized_slack = 1.0, score = 500 - 500 = 0.
            
            base_score = 500.0
            decay_factor = 500.0
            
            priorities[can_fit_mask][non_exact_fit_mask] = base_score - decay_factor * normalized_slack
            
            # Ensure no negative priorities for non-exact fits, unless they are extremely bad fits
            # that would otherwise get positive scores.
            priorities[can_fit_mask][non_exact_fit_mask] = np.maximum(priorities[can_fit_mask][non_exact_fit_mask], 0.0)


    return priorities
```
