```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Normalized Best Fit priority function.

    This strategy aims to place the item into the bin where it fits best,
    meaning the bin that has just enough capacity to hold the item, minimizing
    waste. It normalizes the remaining capacity relative to the bin's original
    capacity (assuming a standard bin size, which is implicit here as we're
    only given remaining capacities).

    The priority is calculated as:
    priority = (bin_remaining_capacity - item) / bin_capacity
    We want to minimize this value (i.e., get close to 0).
    Therefore, we maximize the negative of this value.

    However, since we don't have the original bin capacity, we can approximate
    this by considering the *relative tightness* of the fit. A good fit is
    when `item` is close to `bins_remain_cap`.

    To create a score where higher is better, we can:
    1. Identify bins that can fit the item.
    2. For those bins, calculate a score that rewards a tight fit.
       A tight fit means `bins_remain_cap - item` is small and non-negative.
       We want to *minimize* `bins_remain_cap - item`.
    3. To make it a "higher is better" score, we can use a transformation
       that gives higher scores to smaller non-negative remainders.
       A simple approach is to use `1.0 / (remainder + epsilon)` or
       `-(remainder)`. We will use `-(remainder)` for simplicity, similar to v1,
       but with a slight modification to emphasize tighter fits.

    This version prioritizes bins that leave a *smaller* remaining capacity after
    the item is placed, aiming for a tighter fit. It uses a transformation
    that amplifies the preference for tighter fits.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of priority scores for each bin. Bins that cannot accommodate the item
        receive a priority of -1. Higher scores indicate higher priority.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf) # Use -inf for non-fittable bins

    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        remaining_capacities_if_fit = bins_remain_cap[can_fit_mask] - item

        # We want to prioritize bins where the remaining capacity is minimal.
        # This means we want to maximize the negative of the remaining capacity.
        # To further emphasize tighter fits (smaller remainders), we can square
        # the negative remainder. This makes smaller remainders contribute
        # proportionally more to the priority than larger remainders.
        # Example: remainders [0.1, 0.5] -> scores [-0.01, -0.25]. Higher score is -0.01.
        # Using negative values, so -0.01 > -0.25.
        priorities[can_fit_mask] = -(remaining_capacities_if_fit ** 2)

        # Alternative with a linear relationship (similar to v1 but explicitly negative)
        # priorities[can_fit_mask] = -remaining_capacities_if_fit

    return priorities
```
