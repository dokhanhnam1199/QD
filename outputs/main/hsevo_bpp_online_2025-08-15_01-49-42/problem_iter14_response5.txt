```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid heuristic prioritizing exact fits and then using scaled inverse
    remaining capacity for differentiation among near-fits, ensuring robustness.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        fitting_bins_indices = np.where(can_fit_mask)[0]
        remaining_capacities_if_fit = bins_remain_cap[can_fit_mask] - item
        
        epsilon = 1e-9
        
        # Assign a very high priority to exact fits (remaining capacity is zero)
        exact_fit_mask = remaining_capacities_if_fit == 0
        exact_fit_indices = fitting_bins_indices[exact_fit_mask]
        priorities[exact_fit_indices] = 1.0  # High priority for exact fits
        
        # For non-exact fits, prioritize bins with the smallest remaining capacity
        # using an inverse relationship for stronger differentiation of "near-fits".
        non_exact_fit_mask = ~exact_fit_mask
        non_exact_fitting_indices = fitting_bins_indices[non_exact_fit_mask]
        
        if non_exact_fitting_indices.size > 0:
            remaining_for_non_exact = remaining_capacities_if_fit[non_exact_fit_mask]
            
            # Score is inversely proportional to remaining capacity,
            # ensuring smaller remaining capacities get higher scores.
            # Add epsilon for numerical stability.
            scores_for_non_exact = 1.0 / (remaining_for_non_exact + epsilon)
            
            # Scale these scores to be less than the exact fit priority but still high.
            # We map them to a range like [0.5, 0.99] (or similar lower range).
            # Let's use a range slightly below the exact fit priority for clear hierarchy.
            # A simple linear scaling can achieve this.
            
            # Find min and max of these new scores to normalize them into a desired range, e.g., [0.5, 0.99]
            min_score = np.min(scores_for_non_exact)
            max_score = np.max(scores_for_non_exact)
            
            if max_score - min_score > epsilon: # Avoid division by zero if all are same
                scaled_scores = 0.5 + 0.49 * (scores_for_non_exact - min_score) / (max_score - min_score)
            else: # If all remaining capacities are the same, assign a middle score
                scaled_scores = 0.75 # Any value between 0.5 and 0.99 is fine
            
            priorities[non_exact_fitting_indices] = scaled_scores

    return priorities
```
