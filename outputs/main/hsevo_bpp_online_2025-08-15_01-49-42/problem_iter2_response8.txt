```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit and a scaled inverse for prioritized bin selection.

    Prioritizes bins that perfectly fit the item (exact fit). For bins
    that can fit but not perfectly, it assigns a priority inversely
    proportional to the remaining capacity after packing, scaled by a
    small constant to avoid extreme values and ensure numerical stability.
    Bins that cannot fit receive a priority of -1.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        suitable_bins_remain_cap = bins_remain_cap[can_fit_mask]
        exact_fit_mask = suitable_bins_remain_cap == item
        
        # Prioritize exact fits with a high score (e.g., 1.0)
        priorities[can_fit_mask][exact_fit_mask] = 1.0
        
        # For bins that can fit but not exactly, use an inverse of remaining capacity
        # scaled to avoid numerical issues and give a smooth priority ranking.
        # Adding 1 to the remaining capacity before inversion helps to avoid division by zero
        # and slightly de-emphasizes very small remainders compared to a direct 1/x.
        # A small epsilon is also added for robustness.
        non_exact_fit_mask = ~exact_fit_mask
        
        if np.any(non_exact_fit_mask):
            remaining_after_fit = suitable_bins_remain_cap[non_exact_fit_mask] - item
            # Using 1.0 / (remaining_capacity + constant) to prioritize smaller remainders
            # The constant (e.g., 1.0) makes the priority less extreme for small remainders.
            # Adding a small epsilon for numerical stability.
            priorities[can_fit_mask][non_exact_fit_mask] = 1.0 / (remaining_after_fit + 1.0 + 1e-9)
            
    return priorities
```
