```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes exact fits, then bins with minimal normalized slack, offering robust differentiation.
    Combines exact fit priority with scaled normalized slack for non-exact fits.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    # High priority for exact fits
    exact_fit_mask = np.isclose(bins_remain_cap, item)
    priorities[exact_fit_mask] = 1.0

    # For bins that can fit but are not exact fits
    can_fit_and_not_exact_mask = bins_remain_cap > item
    
    if np.any(can_fit_and_not_exact_mask):
        eligible_bins_remain_cap = bins_remain_cap[can_fit_and_not_exact_mask]
        
        # Calculate remaining capacity after placing the item
        remaining_capacities_if_fit = eligible_bins_remain_cap - item
        
        # Normalized slack: remaining capacity / current bin capacity. Smaller is better.
        # This is similar to "Normalized Fit" or "Normalized Slack" strategy.
        epsilon = 1e-9
        normalized_slack = remaining_capacities_if_fit / (eligible_bins_remain_cap + epsilon)
        
        # Priority: Higher score for smaller normalized slack.
        # We use 1.0 - normalized_slack to map smaller slack to higher priority (closer to 1.0).
        # Scale these scores to be distinct from exact fits, e.g., between 0.5 and 0.99.
        # This strategy provides a good differentiation for non-exact fits.
        non_exact_priorities = 0.5 + 0.49 * (1.0 - normalized_slack)
        
        priorities[can_fit_and_not_exact_mask] = non_exact_priorities

    return priorities
```
