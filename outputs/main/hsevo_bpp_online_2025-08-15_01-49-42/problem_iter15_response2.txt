```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Normalized Slack Fit priority function.

    This strategy prioritizes bins that are "tight fits" after placing the item,
    while also considering the overall "slack" in the bin relative to the item size.
    It aims to fill bins as much as possible without leaving excessive empty space,
    and also gives a premium to bins that are perfectly filled.

    The priority is calculated as:
    1. A high score if the item exactly fits the bin (remaining capacity is 0).
    2. For bins that can fit the item but not exactly, the priority is based on
       the "normalized slack". Normalized slack is the remaining capacity after
       placing the item, divided by the original remaining capacity of the bin.
       A lower normalized slack is preferred (meaning the item takes up a larger
       proportion of the bin's remaining space).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of priority scores for each bin. Bins that cannot accommodate the item
        receive a priority of -1. Higher scores indicate higher priority.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)

    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        eligible_bins_indices = np.where(can_fit_mask)[0]
        eligible_bins_remain_cap = bins_remain_cap[eligible_bins_indices]

        # Calculate remaining capacities after placing the item
        remaining_capacities_after_fit = eligible_bins_remain_cap - item

        # Assign very high priority to exact fits
        exact_fit_mask = remaining_capacities_after_fit == 0
        priorities[eligible_bins_indices[exact_fit_mask]] = 1e6  # High priority for exact fits

        # For bins that are not exact fits, calculate normalized slack
        non_exact_fit_mask = ~exact_fit_mask
        
        if np.any(non_exact_fit_mask):
            non_exact_indices_in_eligible = np.where(non_exact_fit_mask)[0]
            
            original_remaining_for_non_exact = eligible_bins_remain_cap[non_exact_indices_in_eligible]
            remaining_after_fit_for_non_exact = remaining_capacities_after_fit[non_exact_indices_in_eligible]

            # Calculate normalized slack: remaining_after_fit / original_remaining
            # We want to minimize this ratio. So, higher priority for smaller ratios.
            # Use a small epsilon to avoid division by zero if original_remaining_for_non_exact is 0
            # (though this case should be covered by exact_fit_mask if item > 0).
            # Adding item to a bin with 0 remaining capacity means item must be 0, which is unlikely.
            # A better way to incentivize smaller remaining capacity is to use the inverse.
            # Priority = 1 / (normalized_slack + epsilon)
            # Or simply maximize the negative of normalized slack.
            
            # Use the negative of the normalized slack for prioritization (smaller slack = higher priority)
            normalized_slack = remaining_after_fit_for_non_exact / original_remaining_for_non_exact
            priorities[eligible_bins_indices[non_exact_fit_mask]] = -normalized_slack

    return priorities
```
