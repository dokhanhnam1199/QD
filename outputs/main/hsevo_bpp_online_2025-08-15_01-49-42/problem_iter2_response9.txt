```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best Fit (exact fit prioritization) with a scaled Worst Fit approach for remaining bins."""
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    
    if fitting_bins_caps.size > 0:
        exact_fit_diff = fitting_bins_caps - item
        
        # Prioritize exact fits first by assigning a high positive score
        exact_fit_mask = (exact_fit_diff == 0)
        priorities[can_fit_mask][exact_fit_mask] = 1.0 
        
        # For bins that don't offer an exact fit, use the inverse of the remaining capacity 
        # (closer to exact fit is better) to prioritize them.
        # This is similar to Best Fit, but we are not strictly enforcing exact fit as the *only* option.
        non_exact_fit_mask = ~exact_fit_mask
        non_exact_fit_caps = fitting_bins_caps[non_exact_fit_mask]
        
        # If there are non-exact fits, assign priorities based on how much space is left.
        # A smaller remaining capacity after fitting (i.e., closer to exact fit) gets a higher priority.
        # We use a scaled inverse to avoid extreme values and ensure a good distribution.
        if non_exact_fit_caps.size > 0:
            # We want to prioritize bins with less remaining capacity after fitting
            # Using 1 / (remaining_capacity_after_fit + 1e-9) means smaller remaining capacity is better
            priorities[can_fit_mask][non_exact_fit_mask] = 1.0 / (non_exact_fit_caps - item + 1e-9)

    return priorities
```
