```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid heuristic: Exact fit, then Best Fit with normalized slack penalty.
    Prioritizes exact fits, then favors bins with minimal remaining capacity after fit,
    penalizing bins that leave disproportionately large remaining space relative to item size.
    """
    priorities = np.full_like(bins_remain_cap, -1.0, dtype=float)
    epsilon = 1e-9
    exact_fit_score = 1e9  # High score for exact fits
    slack_penalty_factor = 0.1  # Penalty for large relative slack

    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        available_bins_indices = np.where(can_fit_mask)[0]
        
        # Calculate remaining capacity after fitting for potential bins
        remaining_after_fit = bins_remain_cap[available_bins_indices] - item
        
        # --- Scoring Logic ---
        
        # 1. Prioritize exact fits (remaining_after_fit is close to zero)
        exact_fit_indices_local = np.where(remaining_after_fit < epsilon)[0]
        if exact_fit_indices_local.size > 0:
            priorities[available_bins_indices[exact_fit_indices_local]] = exact_fit_score
            
            # Filter out exact fits for secondary scoring to maintain highest priority
            non_exact_fit_local_indices = np.setdiff1d(np.arange(len(available_bins_indices)), exact_fit_indices_local)
            
            if non_exact_fit_local_indices.size == 0:
                return priorities # All fitting bins were exact fits

            available_bins_indices = available_bins_indices[non_exact_fit_local_indices]
            remaining_after_fit = remaining_after_fit[non_exact_fit_local_indices]
        
        # 2. For non-exact fits, prioritize Best Fit (minimize remaining_after_fit)
        # Score is negative remaining capacity, so smaller remaining capacity means higher score.
        best_fit_scores = -remaining_after_fit
        
        # 3. Add a penalty for large slack relative to the item size.
        # This discourages bins that remain too empty after packing.
        # Relative slack = remaining_after_fit / item. Use item + epsilon for stability.
        relative_slack = remaining_after_fit / (item + epsilon)
        
        # Combine Best Fit score with penalty. Subtract penalty to reduce score for high relative slack.
        combined_scores = best_fit_scores - slack_penalty_factor * relative_slack
        
        priorities[available_bins_indices] = combined_scores

    return priorities
```
