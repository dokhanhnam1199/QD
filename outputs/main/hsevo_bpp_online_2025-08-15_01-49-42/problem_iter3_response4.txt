```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive Almost Full Fit with Normalized Slack priority function.

    This strategy prioritizes bins that will be "almost full" after placing the item,
    but it adapts to the item's size relative to the bin's capacity and normalizes
    the slack to avoid issues with vastly different bin capacities.

    The priority is calculated based on the *normalized slack* after placing the item.
    A smaller normalized slack (meaning the bin is closer to being full relative
    to its remaining capacity before the item) indicates higher priority.
    We also incorporate a slight penalty for bins that are too large relative to the item
    to encourage tighter packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of priority scores for each bin. Bins that cannot accommodate the item
        receive a priority of -1. Higher scores indicate higher priority.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        current_bin_capacities = bins_remain_cap[can_fit_mask]
        
        # Calculate remaining capacity after placing the item
        remaining_capacities_if_fit = current_bin_capacities - item
        
        # Calculate a measure of "how full" the bin will be relative to its original capacity
        # We use the capacity *before* placing the item for normalization.
        # If a bin has capacity C, and we place item I, it leaves C-I remaining.
        # The "fullness" is related to (C-I)/C. We want to minimize this ratio.
        # To avoid division by zero if original capacity was 0 (shouldn't happen in BPP but for robustness),
        # we can use the capacity *before* placing the item for normalization.
        # A smaller remaining capacity relative to the original bin capacity is better.
        # We are prioritizing bins that will be "almost full" after placement.
        # This means the remaining capacity (current_bin_capacities - item) should be small.
        
        # Normalize the remaining capacity by the capacity *before* placing the item.
        # This gives a measure of slack relative to the bin's size.
        # We use the capacity of the bin *before* the item is placed for normalization.
        # A smaller normalized remaining capacity (slack) is better.
        
        # Using `current_bin_capacities` for normalization:
        # slack_ratio = remaining_capacities_if_fit / current_bin_capacities
        
        # A more robust normalization would be to use the capacity *of the bin*.
        # However, since we only have remaining capacities, we can proxy this by
        # `current_bin_capacities + item` (the capacity the bin *had* before this item).
        # But a simpler and often effective approach for "almost full" is to focus on
        # minimizing `remaining_capacities_if_fit`.
        
        # Let's define priority as inversely proportional to remaining capacity,
        # but also consider how large the remaining capacity is relative to the item.
        # A common heuristic is to prioritize the bin with the smallest *positive* remainder.
        # This means maximizing -(remaining_capacities_if_fit).
        
        # To make it "better" and "adaptive":
        # We want to penalize bins that are excessively large for the item.
        # Consider a bin with capacity 100 and item 1. Remaining is 99.
        # Consider a bin with capacity 10 and item 1. Remaining is 9.
        # The second bin is relatively fuller.
        
        # Let's use the ratio of (item size / bin capacity before placing item)
        # Higher ratio means the item takes up more of the bin's original capacity.
        # Then, subtract this ratio from 1 to get a measure of how much capacity is *left* relative to item size.
        # Or, simply prioritize bins that minimize (remaining_capacity_if_fit).

        # Refined approach: Prioritize bins that minimize remaining capacity.
        # To make it adaptive, let's use the ratio of the *remaining capacity after fit*
        # to the *capacity of the bin before the item*.
        # We want to *minimize* this ratio.
        # So, priority will be `-(remaining_capacities_if_fit / current_bin_capacities)`.
        # This normalizes the remaining capacity by the bin's available space.
        
        # Add a small epsilon to the denominator to avoid division by zero for bins with zero capacity.
        epsilon = 1e-9
        
        # Calculate normalized slack: remaining capacity after fitting / current bin capacity.
        # A smaller normalized slack is preferred.
        normalized_slack = remaining_capacities_if_fit / (current_bin_capacities + epsilon)
        
        # The priority should be higher for smaller normalized_slack.
        # So, we can use -normalized_slack.
        # To ensure positive scores for fitting bins and to differentiate them clearly from non-fitting bins,
        # we can add a base score.
        # Let's aim for higher scores for better fits.
        # We want to maximize `1 - normalized_slack`. This means minimizing `normalized_slack`.
        # So, `priority = 1.0 - normalized_slack`.
        
        # Consider the case where `current_bin_capacities` is very large compared to `item`.
        # `normalized_slack` will be close to 1.0, and `1 - normalized_slack` will be close to 0.
        # If `current_bin_capacities` is just slightly larger than `item`,
        # `remaining_capacities_if_fit` is small, `normalized_slack` is small,
        # and `1 - normalized_slack` is close to 1.0. This is good.
        
        priorities[can_fit_mask] = 1.0 - normalized_slack

        # Alternative: Prioritize the bin with the minimum remaining capacity directly.
        # This is the core of "almost full fit".
        # To make it adaptive, we can scale this minimum remaining capacity.
        # However, the normalized slack approach is generally more robust across different bin scales.
        
        # Let's refine the score to ensure it's always positive and higher for better fits,
        # and clearly distinguishable from non-fitting bins.
        # We want to maximize the "fitness", where fitness is inversely related to slack.
        # Fitness = 1 / (normalized_slack + epsilon)
        # However, this can lead to very large numbers if normalized_slack is tiny.
        
        # A simpler, robust approach:
        # Maximize -(remaining_capacities_if_fit). This favors bins that become most full.
        # To make it adaptive, normalize this difference by the original capacity.
        # Priority = -(remaining_capacities_if_fit / (current_bin_capacities + epsilon))
        # This is essentially `normalized_slack` but negated. Higher values are better.
        
        priorities[can_fit_mask] = -normalized_slack
        
        # To ensure positive scores and to distinguish from the "-1" for non-fitting bins,
        # and to make the "best fit" have the highest score, we can transform this.
        # For example, map the range of potential `-normalized_slack` values to a positive range.
        # The range of `normalized_slack` is [0, 1]. So, `-normalized_slack` is [-1, 0].
        # We want to map this to a positive score, where 0 maps to the highest score.
        # So, we can use `1 + normalized_slack` (range [0, 1]) or `1 - normalized_slack` (range [0, 1]).
        # `1 - normalized_slack` means smaller normalized slack -> higher priority. This is aligned.
        
        priorities[can_fit_mask] = 1.0 - normalized_slack
        
        # Let's consider the heuristic advice: "Focus on precisely defining objective functions (e.g., exact fit satisfaction, minimizing slack), and consistently normalize or scale capacities to create a common comparison basis."
        # Minimizing slack is key. `remaining_capacities_if_fit` is the slack.
        # Normalizing it by `current_bin_capacities` gives `normalized_slack`.
        # We want to minimize `normalized_slack`.
        # Therefore, we want to maximize `1 - normalized_slack`.
        # This seems to be a good implementation of the advice.

    return priorities
```
