```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Normalized Slack Fit priority function.

    This strategy prioritizes bins based on the 'slack' remaining after placing the item,
    normalized by the item's size. It aims to find bins where the remaining capacity
    is as close as possible to the item's size, while also considering the absolute
    remaining capacity. A bin is preferred if it's a near-exact fit (low slack)
    or if it's a very tight fit (low remaining capacity), normalized to avoid
    bias towards larger items dominating the scoring.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of priority scores for each bin. Bins that cannot accommodate the item
        receive a priority of -1. Higher scores indicate higher priority.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        remaining_capacities_if_fit = bins_remain_cap[can_fit_mask] - item
        
        # Calculate normalized slack: slack / item_size.
        # A smaller normalized slack means a better fit relative to the item's size.
        # Add a small epsilon to the denominator to prevent division by zero for items of size 0,
        # though in BPP item sizes are typically positive.
        epsilon = 1e-9
        normalized_slack = remaining_capacities_if_fit / (item + epsilon)
        
        # The priority should be higher for smaller normalized slack.
        # We can use the negative of normalized_slack.
        # Additionally, we want to give a slight preference to bins with less *absolute*
        # remaining capacity even if normalized slack is similar, as this might indicate
        # a more "full" bin. So, we can combine the normalized slack with the negative
        # of the absolute remaining capacity.
        # A simple combination: -normalized_slack - (remaining_capacities_if_fit / bin_capacity_if_fit)
        # Or, to keep it simpler and focus on minimal remaining capacity in case of tie in normalized slack:
        # prioritize bins with smaller remaining capacity *after* fitting.
        
        # Let's prioritize bins where normalized slack is minimized.
        # For bins that are exact fits (remaining_capacities_if_fit == 0),
        # we give them the highest priority by assigning a very large positive value.
        # For near fits, we use a score inversely proportional to normalized slack.
        
        # Assign a very high priority for exact fits.
        exact_fit_mask = (remaining_capacities_if_fit < epsilon) & can_fit_mask
        priorities[exact_fit_mask] = 1e9  # High priority for exact fits

        # For bins that are not exact fits but can accommodate the item,
        # calculate priority based on normalized slack.
        # A higher priority for smaller normalized slack.
        # We want to maximize -(normalized_slack).
        non_exact_fit_mask = ~exact_fit_mask & can_fit_mask
        priorities[non_exact_fit_mask] = -normalized_slack[non_exact_fit_mask]

        # Further refinement: if normalized slack is very close for multiple bins,
        # break ties by choosing the bin with the minimal absolute remaining capacity.
        # This can be achieved by adding a small term related to the negative of remaining capacity.
        # However, to keep priority_v2 distinct and focused on normalized slack primarily,
        # we'll stick to the normalized slack scoring. The exact fit bonus already handles
        # the most desirable outcome.

    return priorities
```
