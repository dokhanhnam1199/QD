```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid Exact-Fit and Scaled Slack priority.
    Prioritizes exact fits with a high score, then uses scaled remaining capacity
    for non-exact fits to differentiate between bins, favoring tighter fits.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        available_bins_remain_cap = bins_remain_cap[can_fit_mask]
        
        # Exact fit: Highest priority (e.g., 1.0)
        exact_fit_mask = available_bins_remain_cap == item
        
        # Non-exact fit: Scale remaining capacity to a range, e.g., [0.5, 0.99]
        # We want to minimize remaining capacity, so we map small remainders to higher scores.
        non_exact_fit_mask = ~exact_fit_mask
        
        if np.any(exact_fit_mask):
            priorities[can_fit_mask][exact_fit_mask] = 1.0
            
        if np.any(non_exact_fit_mask):
            non_exact_bins_remain_cap = available_bins_remain_cap[non_exact_fit_mask]
            # Scale remaining capacity: Higher score for smaller remaining capacity.
            # Map the minimum possible remaining capacity (just above 0) to ~0.99
            # and the maximum possible remaining capacity (bins_remain_cap[non_exact_fit_mask] - item)
            # to ~0.5.
            # Simple linear scaling: priority = min_score + (max_score - min_score) * (1 - normalized_slack)
            # where normalized_slack = (current_slack - min_slack) / (max_slack - min_slack)
            # For simplicity and robustness, let's use a direct inverse relationship within a range.
            # Let's map remaining capacity (r) to a score. We want smaller r to have higher score.
            # Score ~ 1 - (r / max_possible_remainder_in_this_set)
            # A more stable approach might be to use a monotonic function that maps to [0.5, 0.99]
            
            # Let's take the range of remaining capacities for non-exact fits
            min_rem_non_exact = np.min(non_exact_bins_remain_cap)
            max_rem_non_exact = np.max(non_exact_bins_remain_cap)
            
            # If all non-exact fits have the same remaining capacity, assign a mid-range score
            if min_rem_non_exact == max_rem_non_exact:
                non_exact_priorities = np.full(non_exact_bins_remain_cap.shape, 0.75) # Mid-range score
            else:
                # Scale remaining capacity to [0, 1] where 0 is min_rem, 1 is max_rem
                normalized_rem = (non_exact_bins_remain_cap - min_rem_non_exact) / (max_rem_non_exact - min_rem_non_exact)
                # Invert and scale to [0.5, 0.99]: Higher score for smaller remaining capacity
                # Score = 0.5 + (0.99 - 0.5) * (1 - normalized_rem)
                non_exact_priorities = 0.5 + 0.49 * (1.0 - normalized_rem)

            priorities[can_fit_mask][non_exact_fit_mask] = non_exact_priorities
            
    return priorities
```
