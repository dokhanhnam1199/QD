```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid Best Fit with Differentiated Slack Prioritization.

    Combines prioritizing exact fits with a strong preference for bins leaving minimal
    absolute remaining capacity, enhanced by a penalty for large residual space.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    eligible_bins_indices = np.where(can_fit_mask)[0]
    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    remaining_after_fit = eligible_bins_remain_cap - item
    
    # High priority for exact fits (score = 1.0)
    exact_fit_mask = remaining_after_fit == 0
    priorities[eligible_bins_indices[exact_fit_mask]] = 1.0
    
    # For non-exact fits, prioritize minimal remaining capacity (Best Fit).
    # Use a score inversely proportional to the remaining capacity.
    # Add a small epsilon for numerical stability and to avoid division by zero.
    non_exact_fit_mask = ~exact_fit_mask
    
    if np.any(non_exact_fit_mask):
        non_exact_indices = eligible_bins_indices[non_exact_fit_mask]
        non_exact_remaining = remaining_after_fit[non_exact_fit_mask]
        
        # Base score for best fit: higher for smaller remaining capacity.
        # Using 1 / (slack + epsilon) prioritizes minimal absolute slack.
        base_best_fit_scores = 1.0 / (non_exact_remaining + 1e-9)
        
        # Introduce a penalty for bins that remain too empty relative to the item size.
        # This helps to avoid spreading items too thinly if possible.
        # Calculate relative slack: slack / item size.
        # A higher relative slack should result in a lower priority.
        # We subtract a penalty proportional to this relative slack.
        relative_slack = non_exact_remaining / (item + 1e-9)
        
        # Penalty factor: Adjust this to control how strongly large relative slack is penalized.
        # A factor of 0.1 is a common starting point, similar to heuristic 7.
        slack_penalty_factor = 0.1
        slack_penalty = slack_penalty_factor * relative_slack
        
        # Combined score: Best Fit score minus slack penalty.
        # We want to prioritize bins that are nearly full AND don't leave excessive slack.
        final_scores = base_best_fit_scores - slack_penalty
        
        # Ensure scores for non-exact fits are less than the exact fit score (1.0)
        # Also, ensure scores are not excessively negative. A minimum score can be set.
        # For this heuristic, we aim for scores that are positive and differentiated.
        # The base_best_fit_scores are typically > 1 (e.g., 1/(0.1) = 10).
        # The slack penalty is typically < 1 (e.g., 0.1 * (0.1/0.5) = 0.02).
        # So scores should remain high but differentiated.
        
        priorities[non_exact_indices] = final_scores

    return priorities
```
