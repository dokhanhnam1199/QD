[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by rewarding exact fits and then minimizing normalized slack\n    for non-exact fits, ensuring stability.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities\n\n    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    # Prioritize exact fits with a high score\n    exact_fit_mask = np.isclose(eligible_bins_remain_cap, item)\n    priorities[can_fit_mask][exact_fit_mask] = 1.0\n    \n    # For non-exact fits, minimize normalized slack (remaining capacity after fit / original bin capacity)\n    non_exact_fit_mask = ~exact_fit_mask\n    if np.any(non_exact_fit_mask):\n        non_exact_eligible_bins_remain_cap = eligible_bins_remain_cap[non_exact_fit_mask]\n        \n        # Calculate remaining capacity after placing the item\n        remaining_after_fit = non_exact_eligible_bins_remain_cap - item\n        \n        # Original capacities for the eligible non-exact fit bins\n        original_capacities = bins_remain_cap[can_fit_mask][non_exact_fit_mask]\n        \n        # Calculate normalized slack. Add epsilon to denominator for stability.\n        # Higher priority for smaller normalized slack.\n        normalized_slack = remaining_after_fit / (original_capacities + 1e-9)\n        \n        # Invert normalized slack to get priority, so smaller slack gets higher priority\n        # Add 1 to inverted slack to shift values and ensure positive priorities,\n        # making them distinct from exact fit score of 1.0.\n        priorities[can_fit_mask][non_exact_fit_mask] = 1.0 + (1.0 / (normalized_slack + 1e-9))\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "cyclomatic_complexity": 3.0,
    "halstead": 106.19818783608963,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines exact fit priority with normalized slack for effective online bin packing.\n\n    Prioritizes bins that achieve an exact fit with a high score (1.0). For other\n    bins, it calculates priority based on minimizing normalized slack, ensuring\n    better-fitting bins receive higher scores.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        current_bin_capacities = bins_remain_cap[can_fit_mask]\n        remaining_capacities_if_fit = current_bin_capacities - item\n        \n        # Exact fit has the highest priority\n        exact_fit_mask = remaining_capacities_if_fit == 0\n        priorities[can_fit_mask][exact_fit_mask] = 1.0\n        \n        # For non-exact fits, calculate priority based on normalized slack\n        # Minimized normalized slack means higher priority.\n        # We use 1.0 - normalized_slack to map smaller slack to higher priority.\n        non_exact_fit_mask = ~exact_fit_mask\n        if np.any(non_exact_fit_mask):\n            non_exact_bins_capacities = current_bin_capacities[non_exact_fit_mask]\n            non_exact_bins_remaining = remaining_capacities_if_fit[non_exact_fit_mask]\n            \n            # Add epsilon for numerical stability, avoid division by zero\n            epsilon = 1e-9\n            normalized_slack = non_exact_bins_remaining / (non_exact_bins_capacities + epsilon)\n            \n            # Priority is higher for smaller normalized slack\n            # Assign priorities in the range (0, 1) to distinguish from exact fits\n            priorities[can_fit_mask][non_exact_fit_mask] = 0.5 * (1.0 - normalized_slack)\n            \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.487435181491823,
    "cyclomatic_complexity": 3.0,
    "halstead": 111.48579046593244,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes exact fits, then bins with minimal normalized slack using a stable scoring.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact Fit: Highest priority (1.0)\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1.0\n\n    # Best Fit: Prioritize bins with minimal positive remaining capacity after fitting.\n    # Consider bins that can fit the item and are not exact fits.\n    can_fit_mask = (bins_remain_cap >= item) & (bins_remain_cap != item)\n    fit_indices = np.where(can_fit_mask)[0]\n\n    if len(fit_indices) > 0:\n        remaining_after_fit = bins_remain_cap[fit_indices] - item\n        current_capacities = bins_remain_cap[fit_indices]\n\n        # Calculate normalized slack: (remaining_capacity_after_fit) / (current_bin_capacity)\n        # Smaller normalized slack is better. Add epsilon for numerical stability.\n        normalized_slack = remaining_after_fit / (current_capacities + 1e-9)\n\n        # Assign priorities that are higher for smaller normalized slack.\n        # We use 1.0 - normalized_slack to map smaller slack to higher scores.\n        # Scale these scores to be clearly less than 1.0, e.g., into the range [0.5, 0.99].\n        # A linear scaling: 0.5 + (1.0 - normalized_slack) * 0.49\n        best_fit_scores = 1.0 - normalized_slack\n        scaled_best_fit_priorities = 0.5 + best_fit_scores * 0.49\n\n        priorities[fit_indices] = scaled_best_fit_priorities\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.198244914240141,
    "cyclomatic_complexity": 2.0,
    "halstead": 155.11451069865606,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes exact fits and then applies a scaled inverse slack for remaining bins.\n\n    This heuristic rewards bins that perfectly accommodate the item with a score of 1.0.\n    For other bins, it calculates a priority based on the inverse of the remaining\n    capacity after fitting, ensuring numerical stability and favoring tighter fits.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n\n    if not np.any(can_fit_mask):\n        return priorities\n\n    suitable_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    suitable_bins_indices = np.where(can_fit_mask)[0]\n\n    # Prioritize exact fits with a score of 1.0\n    exact_fit_mask = suitable_bins_remain_cap == item\n    priorities[suitable_bins_indices[exact_fit_mask]] = 1.0\n\n    # For non-exact fits, use a scaled inverse of the remaining capacity after fitting\n    non_exact_fit_mask = ~exact_fit_mask\n    if np.any(non_exact_fit_mask):\n        non_exact_bins_remain_cap = suitable_bins_remain_cap[non_exact_fit_mask]\n        # Calculate the remaining capacity after fitting the item\n        remaining_after_fit = non_exact_bins_remain_cap - item\n        # Assign priorities: inverse of (remaining_after_fit + 1.0 + epsilon)\n        # Adding 1.0 ensures bins that exactly fit (remaining_after_fit=0) get a high priority (1/1).\n        # A small epsilon (1e-9) prevents division by zero and handles floating-point issues.\n        priorities[suitable_bins_indices[non_exact_fit_mask]] = 1.0 / (remaining_after_fit + 1.0 + 1e-9)\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 3.0,
    "halstead": 91.73835003173087,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes exact fits, then bins with minimal normalized slack.\n\n    Combines a high score for exact fits with a normalized slack measure\n    for non-exact fits to effectively rank bins.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n        remaining_after_fit = eligible_bins_remain_cap - item\n        \n        # Prioritize exact fits with a high score\n        exact_fit_mask = remaining_after_fit == 0\n        priorities[can_fit_mask][exact_fit_mask] = 1.0\n        \n        # For non-exact fits, prioritize minimizing normalized slack\n        non_exact_fit_mask = ~exact_fit_mask\n        if np.any(non_exact_fit_mask):\n            non_exact_eligible_bins_remain_cap = eligible_bins_remain_cap[non_exact_fit_mask]\n            \n            # Calculate normalized slack: slack / original capacity (approximated by current remaining)\n            # Adding epsilon to denominator for numerical stability and to slightly prefer fuller bins\n            epsilon = 1e-9 \n            normalized_slack = remaining_after_fit[non_exact_fit_mask] / (non_exact_eligible_bins_remain_cap + epsilon)\n            \n            # To maximize priority, we minimize normalized slack. So, we use 1.0 - normalized_slack.\n            # This maps smaller normalized slack to higher priority.\n            priorities[can_fit_mask][non_exact_fit_mask] = 1.0 - normalized_slack\n            \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.487435181491823,
    "cyclomatic_complexity": 3.0,
    "halstead": 93.45440529575887,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes exact fits, then bins with minimal normalized slack.\n\n    This heuristic combines the \"exact fit\" strategy with a \"best fit\"\n    approach normalized by remaining capacity, ensuring clear ranking.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    exact_fit_mask = bins_remain_cap == item\n    non_exact_fit_mask = bins_remain_cap > item\n    \n    # Prioritize exact fits with a score of 1.0\n    priorities[exact_fit_mask] = 1.0\n    \n    # For non-exact fits, calculate priority based on normalized slack\n    if np.any(non_exact_fit_mask):\n        eligible_bins_remain_cap = bins_remain_cap[non_exact_fit_mask]\n        \n        # Calculate remaining capacity after placing the item\n        remaining_capacities_if_fit = eligible_bins_remain_cap - item\n        \n        # Calculate normalized slack: remaining capacity / current bin capacity\n        # Add epsilon for numerical stability for bins that might have 0 capacity (though unlikely in BPP)\n        epsilon = 1e-9\n        normalized_slack = remaining_capacities_if_fit / (eligible_bins_remain_cap + epsilon)\n        \n        # Priority is 1 - normalized_slack: smaller slack means higher priority (closer to 1.0)\n        # This maps the best fit (smallest normalized slack) to a score close to 1.0,\n        # and progressively lower scores for bins with larger normalized slack.\n        # This also ensures scores are positive and distinct from exact fits (1.0).\n        priorities[non_exact_fit_mask] = 1.0 - normalized_slack\n\n    # If there are exact fits, they are already set to 1.0.\n    # For non-exact fits, scores will be in the range [0, 1).\n    # We can shift non-exact fit scores slightly lower if we want exact fits to be strictly dominant.\n    # For example, subtract a small value from non-exact fit scores if any exact fits exist.\n    # However, the current scheme where exact fits are 1.0 and others are < 1.0 naturally handles this.\n    \n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.198244914240141,
    "cyclomatic_complexity": 2.0,
    "halstead": 76.14709844115208,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Hybrid heuristic: exact fit first, then best-fit by minimizing normalized slack.\n    Prioritizes exact fits with a score of 1.0, then bins that minimize\n    (remaining_capacity - item) / original_bin_capacity.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    # Mask for bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n        eligible_indices = np.where(can_fit_mask)[0]\n\n        # Exact fit: highest priority\n        exact_fit_mask = (eligible_bins_remain_cap == item)\n        if np.any(exact_fit_mask):\n            priorities[eligible_indices[exact_fit_mask]] = 1.0\n        \n        # Best fit for non-exact fits: minimize normalized slack\n        # Slack = remaining_capacity - item\n        # Normalized slack = slack / current_bin_capacity\n        # We want to MINIMIZE normalized slack, so HIGHER priority for smaller normalized slack.\n        non_exact_fit_mask = (eligible_bins_remain_cap > item)\n        \n        if np.any(non_exact_fit_mask):\n            non_exact_indices = eligible_indices[non_exact_fit_mask]\n            non_exact_remain_caps = eligible_bins_remain_cap[non_exact_fit_mask]\n            \n            # To get original bin capacities, we'd need to know them.\n            # Assuming the provided 'bins_remain_cap' are from a full set of bins,\n            # and we don't have the original capacities here.\n            # A practical proxy: use the current remaining capacity if it's not too small,\n            # or a fixed large number for normalization if capacity is not available.\n            # However, the prompt implies 'bins_remain_cap' IS the state.\n            # Let's redefine based on common best-fit: minimize remaining capacity after packing.\n            # This is a common \"best-fit\" interpretation.\n            \n            # If we strictly want \"normalized slack\" (slack / original_capacity),\n            # we'd need original capacities. Without it, we fall back to minimizing slack.\n            # The \"Better code\" example used negative slack. Let's refine that.\n            \n            # Strategy: Prioritize bins that leave the LEAST remaining capacity.\n            # This is equivalent to maximizing -(remaining_capacity - item).\n            # To avoid large negative numbers and ensure stable ranking, we can normalize.\n            # Let's use the \"Better code\" logic as it's clean for Best Fit: minimize residual.\n            \n            # Let's take the 'priority_v0' approach of minimizing remaining capacity after fit\n            # but ensure it's distinct from exact fit.\n            \n            # For non-exact fits, score based on how much capacity is left after fitting.\n            # Lower remaining capacity after fitting = higher priority.\n            remaining_after_fit = non_exact_remain_caps - item\n            \n            # To make scores distinct and avoid issues with very small residuals,\n            # we can use a scaled inverse. A common approach is to subtract from a constant\n            # or use a decreasing function.\n            # Let's use a score that is inversely proportional to the residual capacity,\n            # but scaled to be less than 1.0.\n            # Example: 0.5 + 0.4 * (1 - normalized_residual)\n            # Where normalized_residual = residual / max_residual\n            \n            if len(remaining_after_fit) > 0:\n                max_remaining_after_fit = np.max(remaining_after_fit)\n                # Normalize residuals to [0, 1], where 0 is best (min residual)\n                # Add epsilon for stability if all residuals are same\n                normalized_remaining = remaining_after_fit / (max_remaining_after_fit + 1e-9)\n                \n                # Scale to a range below 1.0, e.g., [0.5, 0.95].\n                # This maps best-fit (normalized_remaining near 0) to ~0.95\n                # and worst-fit (normalized_remaining near 1) to ~0.5.\n                best_fit_scores = 0.5 + (1.0 - normalized_remaining) * 0.45\n                \n                priorities[non_exact_indices] = best_fit_scores\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.198244914240141,
    "cyclomatic_complexity": 5.0,
    "halstead": 146.71880002307702,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes exact fits, then bins with minimal normalized slack.\n    Uses a stable inverse relationship for non-exact fits.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n    \n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n    \n    # Calculate slack for suitable bins\n    slack = suitable_bins_remain_cap - item\n\n    # Prioritize exact fits with a score of 1.0\n    exact_fit_mask_local = slack == 0\n    priorities[suitable_bins_mask][exact_fit_mask_local] = 1.0\n\n    # For non-exact fits, use inverse of slack + 1 to give higher priority to smaller slack\n    # This is similar to priority_v0 but ensures exact fits are handled separately and more favorably.\n    non_exact_fit_mask_local = slack > 0\n    if np.any(non_exact_fit_mask_local):\n        # Adding 1.0 to the slack ensures that bins with zero slack (already handled)\n        # would get a score of 1.0 if they were in this calculation.\n        # Adding a small epsilon prevents division by zero for floating point inaccuracies.\n        priorities[suitable_bins_mask][non_exact_fit_mask_local] = 1.0 / (slack[non_exact_fit_mask_local] + 1.0 + 1e-9)\n\n    # Normalize the priorities of non-exact fits so the highest non-exact fit priority is capped below 1.0\n    # This ensures exact fits remain distinctly prioritized.\n    if np.any(non_exact_fit_mask_local):\n        max_non_exact_priority = np.max(priorities[suitable_bins_mask][non_exact_fit_mask_local])\n        if max_non_exact_priority > 0:\n            priorities[suitable_bins_mask][non_exact_fit_mask_local] /= max_non_exact_priority\n            # Scale down non-exact fits to be clearly less than exact fits (if any exact fits exist)\n            if np.any(exact_fit_mask_local):\n                priorities[suitable_bins_mask][non_exact_fit_mask_local] *= 0.9 \n            # Ensure exact fits are still 1.0\n            priorities[suitable_bins_mask][exact_fit_mask_local] = 1.0\n\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.487435181491823,
    "cyclomatic_complexity": 6.0,
    "halstead": 144.75398259382442,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by favoring exact fits, then best fits by minimizing normalized slack.\n    This hybrid approach ensures precise packing and robustly handles near-fits.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities\n\n    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    # Score 1.0 for exact fits to give them the highest priority\n    exact_fit_mask = np.isclose(eligible_bins_remain_cap, item)\n    priorities[can_fit_mask][exact_fit_mask] = 1.0\n    \n    # For non-exact fits, calculate normalized slack and use it to prioritize\n    non_exact_fit_mask = ~exact_fit_mask\n    if np.any(non_exact_fit_mask):\n        non_exact_eligible_bins_remain_cap = eligible_bins_remain_cap[non_exact_fit_mask]\n        \n        # Calculate slack after placing the item\n        slack = non_exact_eligible_bins_remain_cap - item\n        \n        # Normalized slack: slack / original remaining capacity. Smaller is better.\n        # Add epsilon for numerical stability and to prevent division by zero.\n        # Invert normalized slack to get a priority score (higher is better).\n        epsilon = 1e-9\n        normalized_slack_priorities = 1.0 / (slack / (non_exact_eligible_bins_remain_cap + epsilon) + epsilon)\n        \n        # Normalize these priorities so the maximum is less than 1.0 (to distinguish from exact fits)\n        if np.max(normalized_slack_priorities) > epsilon:\n            normalized_slack_priorities = 0.5 + 0.5 * (normalized_slack_priorities / np.max(normalized_slack_priorities))\n        else:\n            normalized_slack_priorities = np.full_like(normalized_slack_priorities, 0.5) # Assign a mid-range score if all are near zero\n\n        priorities[can_fit_mask][non_exact_fit_mask] = normalized_slack_priorities\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.487435181491823,
    "cyclomatic_complexity": 4.0,
    "halstead": 157.89111045234063,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by favoring exact fits, then minimizing normalized slack\n    for remaining bins, ensuring stable and distinct rankings.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit_mask = bins_remain_cap >= item\n    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    if eligible_bins_remain_cap.size > 0:\n        remaining_after_fit = eligible_bins_remain_cap - item\n        \n        # Prioritize exact fits with a high score (e.g., 1.0)\n        exact_fit_mask = remaining_after_fit == 0\n        priorities[can_fit_mask][exact_fit_mask] = 1.0\n        \n        # For non-exact fits, prioritize bins with minimal normalized slack\n        non_exact_fit_mask = ~exact_fit_mask\n        \n        if np.any(non_exact_fit_mask):\n            non_exact_bins_remaining = remaining_after_fit[non_exact_fit_mask]\n            # Calculate normalized slack: (remaining_cap - item) / initial_bin_cap\n            # Using original eligible_bins_remain_cap for normalization\n            normalized_slack = non_exact_bins_remaining / eligible_bins_remain_cap[non_exact_fit_mask]\n            \n            # Score is 1 - normalized_slack: higher score for lower normalized slack.\n            # Add a small epsilon to the denominator for stability in normalization,\n            # though for non-zero capacities, it's less critical than inverse.\n            # Scale the score to be less than 1.0, to clearly distinguish from exact fits.\n            priorities[can_fit_mask][non_exact_fit_mask] = 0.5 + 0.5 * (1.0 - normalized_slack)\n            \n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.487435181491823,
    "cyclomatic_complexity": 3.0,
    "halstead": 115.94522208456974,
    "exec_success": true
  }
]