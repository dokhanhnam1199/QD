```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive Best Fit with Capacity Normalization priority function.

    This strategy aims to find the "best" bin for the item by considering both
    how well the item fits and the current state of the bins.
    It normalizes remaining capacities to compare bins across different states
    and prioritizes bins that leave minimal remaining capacity (best fit),
    but also considers bins that are relatively emptier if a good fit is not available.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of priority scores for each bin. Bins that cannot accommodate the item
        receive a priority of -1. Higher scores indicate higher priority.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        valid_bins_remain_cap = bins_remain_cap[can_fit_mask]
        
        # Calculate remaining capacity if the item is placed
        remaining_capacities_if_fit = valid_bins_remain_cap - item
        
        # Normalize remaining capacities for comparison.
        # A small epsilon is added to avoid division by zero and to ensure
        # bins with zero remaining capacity get a very high score.
        epsilon = 1e-9
        normalized_remaining = remaining_capacities_if_fit / (valid_bins_remain_cap + epsilon)
        
        # Prioritize bins that are "almost full" (i.e., leave small remaining capacity).
        # We want to maximize the negative of the remaining capacity to get a higher score
        # for smaller remaining capacities.
        # Using the normalized remaining capacity provides a relative measure.
        # A higher score means a better fit.
        # A simple way to achieve this is to use the negative of the normalized remaining capacity.
        # Or, to make it more robust, we can use a transformation like 1 - normalized_remaining,
        # which maps 0 remaining capacity to 1, and larger remaining capacity to smaller values.
        # Let's use the idea of minimizing slack, so higher priority for smaller slack.
        
        # We want to maximize (1 - normalized_remaining_after_fit).
        # This means bins with almost zero remaining capacity get scores close to 1.
        # Bins with a lot of remaining capacity get scores close to 0.
        priorities[can_fit_mask] = 1.0 - normalized_remaining

        # Optionally, add a small bonus for bins that are already relatively full
        # to encourage packing denser bins first.
        # This could be a small positive value if the bin's remaining capacity
        # is significantly less than the max capacity (assuming a common max capacity,
        # or normalizing by the *original* capacity if known, which is not available here).
        # Without original capacity, we can use the current remaining capacity itself
        # as a proxy for how "full" it might be relative to its potential.
        # However, prioritizing minimal remaining capacity already implicitly favors fuller bins.
        
        # Let's refine the scoring to strongly favor near-perfect fits.
        # We can assign a score based on how close `bins_remain_cap[i] - item` is to 0.
        # A common strategy is to use `1 / (slack + epsilon)`.
        # Let's use a slightly different approach: maximize `-(slack)^2`. This penalizes
        # larger slacks more heavily.

        slacks = valid_bins_remain_cap - item
        priorities[can_fit_mask] = - (slacks**2)

        # To combine "best fit" with a general preference for any fitting bin,
        # we can add a small baseline score to all fitting bins and then the best-fit component.
        # Or, focus purely on the best-fit aspect as it implicitly handles using existing bins well.

        # Let's ensure that the highest priority is given to the smallest slack.
        # The current priority of `-(slacks**2)` achieves this.
        # To make it more distinct from v1's negative linear, squared penalizes
        # larger gaps more aggressively.

    return priorities
```
