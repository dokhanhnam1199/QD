```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid Prioritization: Best Fit + Nearly Exact Fit.

    This heuristic combines the strengths of Best Fit (minimizing remaining capacity)
    with a preference for bins that can *exactly* fit the item or leave a very small
    positive remainder. It aims for a more decisive prioritization.

    The scoring works as follows:
    1. Bins that can exactly fit the item (remaining capacity == item) get the highest priority.
    2. Bins that can fit the item and leave a small positive remaining capacity (item < remaining_capacity < item + epsilon)
       get a high priority, inversely proportional to the remaining capacity. This is prioritized over larger remainders.
    3. Bins that can fit the item but leave a larger remaining capacity get a lower priority, still inversely proportional
       to the remaining capacity to favor tighter fits.
    4. Bins that cannot accommodate the item receive a priority of -1.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of priority scores for each bin. Bins that cannot accommodate the item
        receive a priority of -1. Higher scores indicate higher priority.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]
        
        # Calculate remaining capacities if the item fits
        remaining_capacities_if_fit = eligible_bins_remain_cap - item
        
        # Define a small tolerance for "nearly exact" fits
        epsilon = 1e-6  # A small positive value

        # Priority 1: Exact Fit (remaining capacity is 0)
        exact_fit_mask = (remaining_capacities_if_fit == 0)
        priorities[can_fit_mask][exact_fit_mask] = 1e10 # Very high score for exact fit

        # Priority 2: Nearly Exact Fit (small positive remaining capacity)
        # These bins are good as they leave minimal waste, but not perfect.
        # We want to prioritize smaller positive remainders.
        nearly_exact_fit_mask = (remaining_capacities_if_fit > 0) & (remaining_capacities_if_fit < epsilon)
        if np.any(nearly_exact_fit_mask):
            # Assign scores inversely proportional to the small remainder
            # Add a base score to differentiate from larger remainders
            priorities[can_fit_mask][nearly_exact_fit_mask] = 1e9 - remaining_capacities_if_fit[nearly_exact_fit_mask] * 1e8

        # Priority 3: Standard Best Fit (larger positive remaining capacity)
        # These are bins that fit, but leave more space. We still prefer tighter fits.
        standard_fit_mask = (remaining_capacities_if_fit >= epsilon)
        if np.any(standard_fit_mask):
            # Assign scores that are inversely proportional to remaining capacity.
            # Using `1 / (remainder + small_constant)` to avoid division by zero
            # and to ensure larger remainders get smaller scores.
            # Add a large offset to ensure these scores are lower than exact/nearly exact fits.
            small_constant = 1e-9
            priorities[can_fit_mask][standard_fit_mask] = 1e8 - (remaining_capacities_if_fit[standard_fit_mask] / (remaining_capacities_if_fit[standard_fit_mask] + small_constant)) * 1e7

    return priorities
```
