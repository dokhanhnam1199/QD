{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins that offer the tightest fit using a combination of inverse scaling and offset for numerical stability.\n\n    This heuristic aims to give higher priority to bins where the remaining capacity is just enough to fit the item,\n    using an inverse relationship with the difference between bin capacity and item size. A small offset is added\n    to the denominator to prevent division by zero and to ensure bins that exactly fit receive a very high priority.\n    \"\"\"\n    suitable_bins_mask = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n\n    if suitable_bins_remain_cap.size > 0:\n        # Calculate the difference between remaining capacity and item size for suitable bins.\n        differences = suitable_bins_remain_cap - item\n        # Assign priorities: inverse of (difference + 1.0 + epsilon).\n        # Adding 1.0 to the difference ensures that bins with zero difference (exact fits)\n        # get a high priority (1/1). Adding a small epsilon (1e-9) handles potential\n        # floating-point issues and ensures non-zero denominators.\n        priorities[suitable_bins_mask] = 1.0 / (differences + 1.0 + 1e-9)\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines Best Fit and Sigmoid Fit Score.\n    Prioritizes bins that are closest to fitting the item (Best Fit)\n    and uses a sigmoid to smooth prioritization among them.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities\n        \n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    # Best Fit component: Calculate difference for bins that can fit\n    differences = fitting_bins_remain_cap - item\n    \n    # Sigmoid scaling for smoother prioritization among fitting bins\n    # Normalize differences to a [0, 1] range for sigmoid input\n    # Avoid division by zero if all fitting bins have the same remaining capacity\n    max_diff = np.max(differences)\n    min_diff = np.min(differences)\n    \n    if max_diff == min_diff:\n        scaled_diffs = np.zeros_like(differences) # All fitting bins are equally \"best\"\n    else:\n        scaled_diffs = (differences - min_diff) / (max_diff - min_diff)\n        \n    # Sigmoid function to transform scaled differences into priorities\n    # Steepness parameter (e.g., 5) can be tuned\n    sigmoid_scores = 1 / (1 + np.exp(-5 * (1 - scaled_diffs))) # Invert so smaller diffs get higher scores\n    \n    priorities[can_fit_mask] = sigmoid_scores\n    \n    return priorities\n\n### Analyze & experience\n- Comparing Heuristic 1 ([Heuristics 1st]) and Heuristic 7 ([Heuristics 7th]), they are functionally identical, both using `1.0 / (remaining_after_fit + epsilon)` with `epsilon=1.0` in Heuristic 1 and `epsilon=0.8954438612151145` in Heuristic 7. The choice of `epsilon` is a hyperparameter.\n\nComparing Heuristic 2 ([Heuristics 2nd]) and Heuristic 6 ([Heuristics 6th]), they are identical implementations using `1.0 / (differences + 1.0 + 1e-9)`.\n\nComparing Heuristic 3 ([Heuristics 3rd]) and Heuristic 11 ([Heuristics 11th]), both aim to minimize normalized slack `remaining_capacities_if_fit / current_bin_capacities`. Heuristic 3 uses `-(remaining_capacities_if_fit) - epsilon * eligible_bins_remain_cap` while Heuristic 11 uses `1.0 - normalized_slack`. Heuristic 11's `1.0 - normalized_slack` is a clearer objective function for minimizing slack. Heuristic 3's approach of penalizing already fuller bins might be an interesting secondary objective but adds complexity.\n\nComparing Heuristic 9 ([Heuristics 9th]) and Heuristic 11 ([Heuristics 11th]), they are identical, both implementing `1.0 - normalized_slack` where `normalized_slack` is `remaining_capacities_if_fit / (current_bin_capacities + epsilon)`.\n\nComparing Heuristic 10 ([Heuristics 10th]) and Heuristic 12 ([Heuristics 12th]), they are identical, implementing an exact fit priority of 1.0 and then scaling best fit priorities to a range like [0.5, 0.9].\n\nComparing Heuristic 13 ([Heuristics 13th]) and Heuristic 19 ([Heuristics 19th]), they are identical. They prioritize exact fits with 1.0 and then normalize other scaled inverse priorities so the highest is 1.0.\n\nComparing Heuristic 14 ([Heuristics 14th]) and Heuristic 17 ([Heuristics 17th]) and Heuristic 20 ([Heuristics 20th]), they are identical. They prioritize exact fits with 1.0 and then apply `0.1 / (non_exact_bins_remaining + 1.0)` for non-exact fits.\n\nComparing Heuristic 5 ([Heuristics 5th]) and Heuristic 16 ([Heuristics 16th]): Heuristic 5 directly uses `-(bins_remain_cap[can_fit_mask] - item)` which is equivalent to maximizing the negative slack. Heuristic 16 uses a sigmoid function on normalized differences, which is a more complex approach to prioritize smaller differences.\n\nOverall, heuristics that directly prioritize minimizing slack (like `1.0 - normalized_slack` or negative slack) or exact fits with a clear scoring are generally better. The use of `epsilon` or other constants for stability and scaling is important. Combinations of exact fit with best fit are common and effective.\n- \nHere's a redefinition of \"Current self-reflection\" to inform heuristic design, avoiding the pitfalls of \"Ineffective self-reflection\":\n\n*   **Keywords:** Exact fit, slack minimization, normalized slack, stable scoring, distinct ranking.\n*   **Advice:** Design scoring functions that explicitly reward exact fits, and for imperfect fits, prioritize minimizing normalized slack (slack / bin capacity) to robustly compare options across different bin sizes.\n*   **Avoid:** Direct comparisons of raw slack, numerical instability from division by zero or very small capacities, and overly complex scaling that obscures underlying trade-offs.\n*   **Explanation:** Clear, stable scoring ensures the heuristic reliably identifies the best available bin without getting bogged down by numerical quirks or losing interpretability, crucial for effective optimization.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}