import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1.531086448586848e-09, exact_fit_priority: float = 0.9279014510466894, base_non_exact_priority: float = 0.48177756370448555, slack_priority_weight: float = 0.40128001597924545, tiebreaker_weight: float = 0.013147132796939371) -> np.ndarray:
    """
    Prioritizes exact fits, then bins with minimal normalized slack,
    and uses initial bin capacity as a tie-breaker for bins with similar slack.
    This combines the robustness of normalized slack with a tie-breaking mechanism
    to favor bins that were fuller initially.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    fit_indices = np.where(can_fit_mask)[0]

    if len(fit_indices) == 0:
        return priorities

    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]
    original_eligible_bins_cap = bins_remain_cap[can_fit_mask] # Keep original capacities for tie-breaking

    # High priority for exact fits
    exact_fit_mask_in_eligible = np.abs(eligible_bins_remain_cap - item) < epsilon
    exact_fit_indices_filtered = np.where(exact_fit_mask_in_eligible)[0]
    actual_exact_fit_indices = fit_indices[exact_fit_indices_filtered]
    priorities[actual_exact_fit_indices] = exact_fit_priority

    # For non-exact fits, prioritize minimal normalized slack
    non_exact_fit_mask_in_eligible = ~exact_fit_mask_in_eligible
    non_exact_fit_indices_filtered = np.where(non_exact_fit_mask_in_eligible)[0]
    actual_non_exact_fit_indices = fit_indices[non_exact_fit_indices_filtered]

    if len(actual_non_exact_fit_indices) > 0:
        eligible_bins_for_slack_subset = eligible_bins_remain_cap[non_exact_fit_indices_filtered]
        original_capacities_for_slack_subset = original_eligible_bins_cap[non_exact_fit_indices_filtered]
        
        # Calculate remaining capacity after fitting the item
        remaining_after_fit = eligible_bins_for_slack_subset - item
        
        # Normalized slack: remaining capacity / original bin capacity. Smaller is better.
        normalized_remaining_capacity = remaining_after_fit / (original_capacities_for_slack_subset + epsilon)
        
        # Score based on inverse normalized slack (higher for smaller slack)
        # Scale to be less than 1.0
        best_fit_scores = 1.0 - normalized_remaining_capacity
        scaled_best_fit_priorities = base_non_exact_priority + best_fit_scores * slack_priority_weight

        # Tie-breaker: prioritize bins that were fuller initially if normalized slack is similar
        # This can be achieved by adding a small value proportional to original capacity, scaled appropriately.
        # We use original capacity directly here as a secondary score component.
        # Normalize original capacity to avoid dominating the primary slack score.
        normalized_original_capacity = (original_capacities_for_slack_subset / np.max(original_capacities_for_slack_subset + epsilon)) * tiebreaker_weight
        
        final_non_exact_priorities = scaled_best_fit_priorities - normalized_original_capacity # Subtract to favor smaller slack, but use original capacity as a penalty for larger initial bins

        priorities[actual_non_exact_fit_indices] = final_non_exact_priorities

    return priorities
