[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by rewarding exact fits and then minimizing normalized slack\n    for non-exact fits, ensuring stability.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities\n\n    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    # Prioritize exact fits with a high score\n    exact_fit_mask = np.isclose(eligible_bins_remain_cap, item)\n    priorities[can_fit_mask][exact_fit_mask] = 1.0\n    \n    # For non-exact fits, minimize normalized slack (remaining capacity after fit / original bin capacity)\n    non_exact_fit_mask = ~exact_fit_mask\n    if np.any(non_exact_fit_mask):\n        non_exact_eligible_bins_remain_cap = eligible_bins_remain_cap[non_exact_fit_mask]\n        \n        # Calculate remaining capacity after placing the item\n        remaining_after_fit = non_exact_eligible_bins_remain_cap - item\n        \n        # Original capacities for the eligible non-exact fit bins\n        original_capacities = bins_remain_cap[can_fit_mask][non_exact_fit_mask]\n        \n        # Calculate normalized slack. Add epsilon to denominator for stability.\n        # Higher priority for smaller normalized slack.\n        normalized_slack = remaining_after_fit / (original_capacities + 1e-9)\n        \n        # Invert normalized slack to get priority, so smaller slack gets higher priority\n        # Add 1 to inverted slack to shift values and ensure positive priorities,\n        # making them distinct from exact fit score of 1.0.\n        priorities[can_fit_mask][non_exact_fit_mask] = 1.0 + (1.0 / (normalized_slack + 1e-9))\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "cyclomatic_complexity": 3.0,
    "halstead": 106.19818783608963,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines exact fit priority with normalized slack for effective online bin packing.\n\n    Prioritizes bins that achieve an exact fit with a high score (1.0). For other\n    bins, it calculates priority based on minimizing normalized slack, ensuring\n    better-fitting bins receive higher scores.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        current_bin_capacities = bins_remain_cap[can_fit_mask]\n        remaining_capacities_if_fit = current_bin_capacities - item\n        \n        # Exact fit has the highest priority\n        exact_fit_mask = remaining_capacities_if_fit == 0\n        priorities[can_fit_mask][exact_fit_mask] = 1.0\n        \n        # For non-exact fits, calculate priority based on normalized slack\n        # Minimized normalized slack means higher priority.\n        # We use 1.0 - normalized_slack to map smaller slack to higher priority.\n        non_exact_fit_mask = ~exact_fit_mask\n        if np.any(non_exact_fit_mask):\n            non_exact_bins_capacities = current_bin_capacities[non_exact_fit_mask]\n            non_exact_bins_remaining = remaining_capacities_if_fit[non_exact_fit_mask]\n            \n            # Add epsilon for numerical stability, avoid division by zero\n            epsilon = 1e-9\n            normalized_slack = non_exact_bins_remaining / (non_exact_bins_capacities + epsilon)\n            \n            # Priority is higher for smaller normalized slack\n            # Assign priorities in the range (0, 1) to distinguish from exact fits\n            priorities[can_fit_mask][non_exact_fit_mask] = 0.5 * (1.0 - normalized_slack)\n            \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.487435181491823,
    "cyclomatic_complexity": 3.0,
    "halstead": 111.48579046593244,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes exact fits, then bins with minimal normalized slack using a stable scoring.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact Fit: Highest priority (1.0)\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1.0\n\n    # Best Fit: Prioritize bins with minimal positive remaining capacity after fitting.\n    # Consider bins that can fit the item and are not exact fits.\n    can_fit_mask = (bins_remain_cap >= item) & (bins_remain_cap != item)\n    fit_indices = np.where(can_fit_mask)[0]\n\n    if len(fit_indices) > 0:\n        remaining_after_fit = bins_remain_cap[fit_indices] - item\n        current_capacities = bins_remain_cap[fit_indices]\n\n        # Calculate normalized slack: (remaining_capacity_after_fit) / (current_bin_capacity)\n        # Smaller normalized slack is better. Add epsilon for numerical stability.\n        normalized_slack = remaining_after_fit / (current_capacities + 1e-9)\n\n        # Assign priorities that are higher for smaller normalized slack.\n        # We use 1.0 - normalized_slack to map smaller slack to higher scores.\n        # Scale these scores to be clearly less than 1.0, e.g., into the range [0.5, 0.99].\n        # A linear scaling: 0.5 + (1.0 - normalized_slack) * 0.49\n        best_fit_scores = 1.0 - normalized_slack\n        scaled_best_fit_priorities = 0.5 + best_fit_scores * 0.49\n\n        priorities[fit_indices] = scaled_best_fit_priorities\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.198244914240141,
    "cyclomatic_complexity": 2.0,
    "halstead": 155.11451069865606,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes exact fits and then applies a scaled inverse slack for remaining bins.\n\n    This heuristic rewards bins that perfectly accommodate the item with a score of 1.0.\n    For other bins, it calculates a priority based on the inverse of the remaining\n    capacity after fitting, ensuring numerical stability and favoring tighter fits.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n\n    if not np.any(can_fit_mask):\n        return priorities\n\n    suitable_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    suitable_bins_indices = np.where(can_fit_mask)[0]\n\n    # Prioritize exact fits with a score of 1.0\n    exact_fit_mask = suitable_bins_remain_cap == item\n    priorities[suitable_bins_indices[exact_fit_mask]] = 1.0\n\n    # For non-exact fits, use a scaled inverse of the remaining capacity after fitting\n    non_exact_fit_mask = ~exact_fit_mask\n    if np.any(non_exact_fit_mask):\n        non_exact_bins_remain_cap = suitable_bins_remain_cap[non_exact_fit_mask]\n        # Calculate the remaining capacity after fitting the item\n        remaining_after_fit = non_exact_bins_remain_cap - item\n        # Assign priorities: inverse of (remaining_after_fit + 1.0 + epsilon)\n        # Adding 1.0 ensures bins that exactly fit (remaining_after_fit=0) get a high priority (1/1).\n        # A small epsilon (1e-9) prevents division by zero and handles floating-point issues.\n        priorities[suitable_bins_indices[non_exact_fit_mask]] = 1.0 / (remaining_after_fit + 1.0 + 1e-9)\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 3.0,
    "halstead": 91.73835003173087,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes exact fits, then bins with minimal normalized slack.\n\n    Combines a high score for exact fits with a normalized slack measure\n    for non-exact fits to effectively rank bins.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n        remaining_after_fit = eligible_bins_remain_cap - item\n        \n        # Prioritize exact fits with a high score\n        exact_fit_mask = remaining_after_fit == 0\n        priorities[can_fit_mask][exact_fit_mask] = 1.0\n        \n        # For non-exact fits, prioritize minimizing normalized slack\n        non_exact_fit_mask = ~exact_fit_mask\n        if np.any(non_exact_fit_mask):\n            non_exact_eligible_bins_remain_cap = eligible_bins_remain_cap[non_exact_fit_mask]\n            \n            # Calculate normalized slack: slack / original capacity (approximated by current remaining)\n            # Adding epsilon to denominator for numerical stability and to slightly prefer fuller bins\n            epsilon = 1e-9 \n            normalized_slack = remaining_after_fit[non_exact_fit_mask] / (non_exact_eligible_bins_remain_cap + epsilon)\n            \n            # To maximize priority, we minimize normalized slack. So, we use 1.0 - normalized_slack.\n            # This maps smaller normalized slack to higher priority.\n            priorities[can_fit_mask][non_exact_fit_mask] = 1.0 - normalized_slack\n            \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.487435181491823,
    "cyclomatic_complexity": 3.0,
    "halstead": 93.45440529575887,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes exact fits, then bins with minimal normalized slack.\n\n    This heuristic combines the \"exact fit\" strategy with a \"best fit\"\n    approach normalized by remaining capacity, ensuring clear ranking.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    exact_fit_mask = bins_remain_cap == item\n    non_exact_fit_mask = bins_remain_cap > item\n    \n    # Prioritize exact fits with a score of 1.0\n    priorities[exact_fit_mask] = 1.0\n    \n    # For non-exact fits, calculate priority based on normalized slack\n    if np.any(non_exact_fit_mask):\n        eligible_bins_remain_cap = bins_remain_cap[non_exact_fit_mask]\n        \n        # Calculate remaining capacity after placing the item\n        remaining_capacities_if_fit = eligible_bins_remain_cap - item\n        \n        # Calculate normalized slack: remaining capacity / current bin capacity\n        # Add epsilon for numerical stability for bins that might have 0 capacity (though unlikely in BPP)\n        epsilon = 1e-9\n        normalized_slack = remaining_capacities_if_fit / (eligible_bins_remain_cap + epsilon)\n        \n        # Priority is 1 - normalized_slack: smaller slack means higher priority (closer to 1.0)\n        # This maps the best fit (smallest normalized slack) to a score close to 1.0,\n        # and progressively lower scores for bins with larger normalized slack.\n        # This also ensures scores are positive and distinct from exact fits (1.0).\n        priorities[non_exact_fit_mask] = 1.0 - normalized_slack\n\n    # If there are exact fits, they are already set to 1.0.\n    # For non-exact fits, scores will be in the range [0, 1).\n    # We can shift non-exact fit scores slightly lower if we want exact fits to be strictly dominant.\n    # For example, subtract a small value from non-exact fit scores if any exact fits exist.\n    # However, the current scheme where exact fits are 1.0 and others are < 1.0 naturally handles this.\n    \n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.198244914240141,
    "cyclomatic_complexity": 2.0,
    "halstead": 76.14709844115208,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Hybrid heuristic: exact fit first, then best-fit by minimizing normalized slack.\n    Prioritizes exact fits with a score of 1.0, then bins that minimize\n    (remaining_capacity - item) / original_bin_capacity.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    # Mask for bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n        eligible_indices = np.where(can_fit_mask)[0]\n\n        # Exact fit: highest priority\n        exact_fit_mask = (eligible_bins_remain_cap == item)\n        if np.any(exact_fit_mask):\n            priorities[eligible_indices[exact_fit_mask]] = 1.0\n        \n        # Best fit for non-exact fits: minimize normalized slack\n        # Slack = remaining_capacity - item\n        # Normalized slack = slack / current_bin_capacity\n        # We want to MINIMIZE normalized slack, so HIGHER priority for smaller normalized slack.\n        non_exact_fit_mask = (eligible_bins_remain_cap > item)\n        \n        if np.any(non_exact_fit_mask):\n            non_exact_indices = eligible_indices[non_exact_fit_mask]\n            non_exact_remain_caps = eligible_bins_remain_cap[non_exact_fit_mask]\n            \n            # To get original bin capacities, we'd need to know them.\n            # Assuming the provided 'bins_remain_cap' are from a full set of bins,\n            # and we don't have the original capacities here.\n            # A practical proxy: use the current remaining capacity if it's not too small,\n            # or a fixed large number for normalization if capacity is not available.\n            # However, the prompt implies 'bins_remain_cap' IS the state.\n            # Let's redefine based on common best-fit: minimize remaining capacity after packing.\n            # This is a common \"best-fit\" interpretation.\n            \n            # If we strictly want \"normalized slack\" (slack / original_capacity),\n            # we'd need original capacities. Without it, we fall back to minimizing slack.\n            # The \"Better code\" example used negative slack. Let's refine that.\n            \n            # Strategy: Prioritize bins that leave the LEAST remaining capacity.\n            # This is equivalent to maximizing -(remaining_capacity - item).\n            # To avoid large negative numbers and ensure stable ranking, we can normalize.\n            # Let's use the \"Better code\" logic as it's clean for Best Fit: minimize residual.\n            \n            # Let's take the 'priority_v0' approach of minimizing remaining capacity after fit\n            # but ensure it's distinct from exact fit.\n            \n            # For non-exact fits, score based on how much capacity is left after fitting.\n            # Lower remaining capacity after fitting = higher priority.\n            remaining_after_fit = non_exact_remain_caps - item\n            \n            # To make scores distinct and avoid issues with very small residuals,\n            # we can use a scaled inverse. A common approach is to subtract from a constant\n            # or use a decreasing function.\n            # Let's use a score that is inversely proportional to the residual capacity,\n            # but scaled to be less than 1.0.\n            # Example: 0.5 + 0.4 * (1 - normalized_residual)\n            # Where normalized_residual = residual / max_residual\n            \n            if len(remaining_after_fit) > 0:\n                max_remaining_after_fit = np.max(remaining_after_fit)\n                # Normalize residuals to [0, 1], where 0 is best (min residual)\n                # Add epsilon for stability if all residuals are same\n                normalized_remaining = remaining_after_fit / (max_remaining_after_fit + 1e-9)\n                \n                # Scale to a range below 1.0, e.g., [0.5, 0.95].\n                # This maps best-fit (normalized_remaining near 0) to ~0.95\n                # and worst-fit (normalized_remaining near 1) to ~0.5.\n                best_fit_scores = 0.5 + (1.0 - normalized_remaining) * 0.45\n                \n                priorities[non_exact_indices] = best_fit_scores\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.198244914240141,
    "cyclomatic_complexity": 5.0,
    "halstead": 146.71880002307702,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes exact fits, then bins with minimal normalized slack.\n    Uses a stable inverse relationship for non-exact fits.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n    \n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n    \n    # Calculate slack for suitable bins\n    slack = suitable_bins_remain_cap - item\n\n    # Prioritize exact fits with a score of 1.0\n    exact_fit_mask_local = slack == 0\n    priorities[suitable_bins_mask][exact_fit_mask_local] = 1.0\n\n    # For non-exact fits, use inverse of slack + 1 to give higher priority to smaller slack\n    # This is similar to priority_v0 but ensures exact fits are handled separately and more favorably.\n    non_exact_fit_mask_local = slack > 0\n    if np.any(non_exact_fit_mask_local):\n        # Adding 1.0 to the slack ensures that bins with zero slack (already handled)\n        # would get a score of 1.0 if they were in this calculation.\n        # Adding a small epsilon prevents division by zero for floating point inaccuracies.\n        priorities[suitable_bins_mask][non_exact_fit_mask_local] = 1.0 / (slack[non_exact_fit_mask_local] + 1.0 + 1e-9)\n\n    # Normalize the priorities of non-exact fits so the highest non-exact fit priority is capped below 1.0\n    # This ensures exact fits remain distinctly prioritized.\n    if np.any(non_exact_fit_mask_local):\n        max_non_exact_priority = np.max(priorities[suitable_bins_mask][non_exact_fit_mask_local])\n        if max_non_exact_priority > 0:\n            priorities[suitable_bins_mask][non_exact_fit_mask_local] /= max_non_exact_priority\n            # Scale down non-exact fits to be clearly less than exact fits (if any exact fits exist)\n            if np.any(exact_fit_mask_local):\n                priorities[suitable_bins_mask][non_exact_fit_mask_local] *= 0.9 \n            # Ensure exact fits are still 1.0\n            priorities[suitable_bins_mask][exact_fit_mask_local] = 1.0\n\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.487435181491823,
    "cyclomatic_complexity": 6.0,
    "halstead": 144.75398259382442,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by favoring exact fits, then best fits by minimizing normalized slack.\n    This hybrid approach ensures precise packing and robustly handles near-fits.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities\n\n    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    # Score 1.0 for exact fits to give them the highest priority\n    exact_fit_mask = np.isclose(eligible_bins_remain_cap, item)\n    priorities[can_fit_mask][exact_fit_mask] = 1.0\n    \n    # For non-exact fits, calculate normalized slack and use it to prioritize\n    non_exact_fit_mask = ~exact_fit_mask\n    if np.any(non_exact_fit_mask):\n        non_exact_eligible_bins_remain_cap = eligible_bins_remain_cap[non_exact_fit_mask]\n        \n        # Calculate slack after placing the item\n        slack = non_exact_eligible_bins_remain_cap - item\n        \n        # Normalized slack: slack / original remaining capacity. Smaller is better.\n        # Add epsilon for numerical stability and to prevent division by zero.\n        # Invert normalized slack to get a priority score (higher is better).\n        epsilon = 1e-9\n        normalized_slack_priorities = 1.0 / (slack / (non_exact_eligible_bins_remain_cap + epsilon) + epsilon)\n        \n        # Normalize these priorities so the maximum is less than 1.0 (to distinguish from exact fits)\n        if np.max(normalized_slack_priorities) > epsilon:\n            normalized_slack_priorities = 0.5 + 0.5 * (normalized_slack_priorities / np.max(normalized_slack_priorities))\n        else:\n            normalized_slack_priorities = np.full_like(normalized_slack_priorities, 0.5) # Assign a mid-range score if all are near zero\n\n        priorities[can_fit_mask][non_exact_fit_mask] = normalized_slack_priorities\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.487435181491823,
    "cyclomatic_complexity": 4.0,
    "halstead": 157.89111045234063,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by favoring exact fits, then minimizing normalized slack\n    for remaining bins, ensuring stable and distinct rankings.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit_mask = bins_remain_cap >= item\n    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    if eligible_bins_remain_cap.size > 0:\n        remaining_after_fit = eligible_bins_remain_cap - item\n        \n        # Prioritize exact fits with a high score (e.g., 1.0)\n        exact_fit_mask = remaining_after_fit == 0\n        priorities[can_fit_mask][exact_fit_mask] = 1.0\n        \n        # For non-exact fits, prioritize bins with minimal normalized slack\n        non_exact_fit_mask = ~exact_fit_mask\n        \n        if np.any(non_exact_fit_mask):\n            non_exact_bins_remaining = remaining_after_fit[non_exact_fit_mask]\n            # Calculate normalized slack: (remaining_cap - item) / initial_bin_cap\n            # Using original eligible_bins_remain_cap for normalization\n            normalized_slack = non_exact_bins_remaining / eligible_bins_remain_cap[non_exact_fit_mask]\n            \n            # Score is 1 - normalized_slack: higher score for lower normalized slack.\n            # Add a small epsilon to the denominator for stability in normalization,\n            # though for non-zero capacities, it's less critical than inverse.\n            # Scale the score to be less than 1.0, to clearly distinguish from exact fits.\n            priorities[can_fit_mask][non_exact_fit_mask] = 0.5 + 0.5 * (1.0 - normalized_slack)\n            \n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.487435181491823,
    "cyclomatic_complexity": 3.0,
    "halstead": 115.94522208456974,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Improved priority function for Online Bin Packing.\n\n    This heuristic prioritizes bins that offer an \"exact fit\" or, failing that,\n    minimizes the normalized slack. Normalized slack is defined as the remaining\n    capacity after placing the item, divided by the original capacity of that bin.\n    This approach aims to provide a more stable and meaningful comparison across\n    bins of potentially different original capacities (though in standard BPP,\n    all bins have the same capacity, this design is more robust to variations).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin. Bins that cannot accommodate the item\n        receive a priority of -1. Higher scores indicate higher priority.\n        Exact fits receive the highest priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        # Calculate remaining capacities for bins that can fit the item\n        remaining_capacities_if_fit = bins_remain_cap[can_fit_mask] - item\n        \n        # Assign a very high priority for exact fits\n        exact_fit_mask = remaining_capacities_if_fit == 0\n        priorities[can_fit_mask][exact_fit_mask] = float('inf') # Maximize exact fits\n\n        # For bins that don't offer an exact fit, prioritize minimizing normalized slack\n        # Normalized slack = (remaining_capacity_after_fit) / (original_bin_capacity)\n        # Since all bins have the same capacity in standard BPP, we can assume a\n        # constant original bin capacity. However, for generality, let's consider\n        # a scenario where bins might have slightly different conceptual capacities\n        # or if we're generalizing. If we stick to the standard BPP, then the\n        # normalized slack is simply (remaining_capacity_after_fit) / (bin_capacity_constant).\n        # To prioritize MINIMIZING normalized slack, we MAXIMIZE the NEGATIVE of it.\n        \n        # In standard BPP, the bin capacity is constant. Let's assume bin_capacity is known\n        # or can be inferred (e.g., from the maximum capacity observed or a problem parameter).\n        # For simplicity and to follow the \"normalized slack\" idea even if capacities are the same,\n        # we can conceptually think of the \"slack\" itself as the value we want to minimize.\n        # Prioritizing the minimum remaining capacity is equivalent to minimizing normalized slack\n        # when the denominator (bin capacity) is constant.\n        \n        # We want to maximize the negative of the remaining capacity to find the minimum.\n        # Higher negative values mean smaller remaining capacity, hence higher priority.\n        \n        non_exact_fit_mask = ~exact_fit_mask\n        \n        if np.any(can_fit_mask[can_fit_mask][non_exact_fit_mask]):\n            # Calculate priorities for non-exact fits: prioritize smaller remaining capacities\n            # We want to maximize -(remaining_capacity).\n            # A more stable approach than 1/x is to use a linear score where smaller values are better.\n            # For instance, priority = C - remaining_capacity. To maximize, we use -(remaining_capacity).\n            \n            priorities[can_fit_mask][non_exact_fit_mask] = -remaining_capacities_if_fit[non_exact_fit_mask]\n            \n            # If we were to strictly use normalized slack with a known bin capacity:\n            # bin_capacity = some_constant_or_inferred_value\n            # normalized_slacks = remaining_capacities_if_fit[non_exact_fit_mask] / bin_capacity\n            # priorities[can_fit_mask][non_exact_fit_mask] = -normalized_slacks\n            \n            # To ensure exact fits are always preferred over any non-exact fit, and\n            # among non-exact fits, those with smaller remaining capacity are preferred,\n            # the current assignment of 'inf' for exact fits and negative remaining capacity\n            # for others works. The negative values for non-exact fits will always be less than 'inf'.\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 33, in priority_v2\n    exact_fit_mask = (slack == 0)\nOverflowError: cannot convert float infinity to integer\n3\n55.506595772116384\n"
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacities: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Improved priority function for online Bin Packing Problem.\n\n    This strategy prioritizes bins based on a combination of exact fit and\n    minimized normalized slack. It aims to find bins that are either an\n    exact fit or, failing that, minimize the \"wasted space\" relative to the\n    bin's original capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacities: Array of original capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin. Bins that cannot accommodate\n        the item receive a priority of -1. Higher scores indicate higher priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0, dtype=float)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n        fitting_bins_original_cap = bin_capacities[can_fit_mask]\n        \n        # Calculate slack for bins that can fit the item\n        slack = fitting_bins_remain_cap - item\n        \n        # Prioritize exact fits with a high score\n        exact_fit_mask = (slack == 0)\n        priorities[can_fit_mask][exact_fit_mask] = 1e9  # High score for exact fits\n\n        # For non-exact fits, prioritize minimizing normalized slack\n        non_exact_fit_mask = ~exact_fit_mask\n        \n        if np.any(non_exact_fit_mask):\n            non_exact_slack = slack[non_exact_fit_mask]\n            non_exact_original_cap = fitting_bins_original_cap[non_exact_fit_mask]\n            \n            # Normalized slack: slack / original_capacity\n            # Add a small epsilon to the denominator to prevent division by zero\n            # and to ensure stable scoring even for very small capacities.\n            epsilon = 1e-9\n            normalized_slack = non_exact_slack / (non_exact_original_cap + epsilon)\n            \n            # We want to MINIMIZE normalized slack, so we assign a priority\n            # that is inversely proportional to it (e.g., negative normalized slack).\n            # A smaller normalized slack means a larger negative value, thus higher priority.\n            priorities[can_fit_mask][non_exact_fit_mask] = -normalized_slack\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacities'\n3\n89.20647778231529\n"
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function focusing on exact fits and normalized slack minimization.\n\n    This strategy prioritizes bins that can accommodate the item. Among those,\n    it gives the highest priority to bins that result in an exact fit (zero remaining capacity).\n    For bins that do not result in an exact fit, it prioritizes those with the\n    minimum normalized slack. Normalized slack is defined as (remaining_capacity - item) / original_bin_capacity.\n    Since original bin capacities are not directly available, we approximate this by\n    minimizing (remaining_capacity - item) / (remaining_capacity - item + item),\n    which is (remaining_capacity - item) / remaining_capacity.\n    A higher score indicates a higher priority. Bins that cannot accommodate the item receive -1.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin. Bins that cannot accommodate the item\n        receive a priority of -1. Higher scores indicate higher priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n        \n        # Calculate the remaining capacity after placing the item\n        remaining_capacity_after_fit = eligible_bins_remain_cap - item\n        \n        # Assign highest priority to exact fits (remaining capacity is 0)\n        exact_fit_mask = remaining_capacity_after_fit == 0\n        priorities[can_fit_mask][exact_fit_mask] = 1e6 # A very high score for exact fits\n        \n        # For bins that are not an exact fit, calculate normalized slack\n        non_exact_fit_mask = ~exact_fit_mask\n        \n        if np.any(non_exact_fit_mask):\n            non_exact_bins_remain_cap = eligible_bins_remain_cap[non_exact_fit_mask]\n            non_exact_remaining_after_fit = remaining_capacity_after_fit[non_exact_fit_mask]\n            \n            # Calculate normalized slack: (remaining_capacity - item) / remaining_capacity\n            # Using bins_remain_cap[can_fit_mask][non_exact_fit_mask] as proxy for original capacity\n            # to normalize the slack.\n            # We want to minimize this normalized slack, so we'll take its negative\n            # to turn minimization into maximization.\n            epsilon = 1e-9 # To avoid division by zero or very small numbers for remaining capacity\n            normalized_slack = non_exact_remaining_after_fit / (non_exact_bins_remain_cap + epsilon)\n            \n            # Assign priorities inversely proportional to normalized slack (higher score for smaller slack)\n            # Scale to ensure it's distinct from exact fit scores but still significant\n            priorities[can_fit_mask][non_exact_fit_mask] = -normalized_slack * 1e5 \n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.487435181491823,
    "cyclomatic_complexity": 3.0,
    "halstead": 107.02635884729514,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best Fit Decreasing (BFD) inspired priority for Online Bin Packing.\n\n    This strategy aims to find a bin that can accommodate the item and, among those,\n    selects the one that leaves the minimum remaining capacity (Best Fit principle).\n    To enhance robustness and handle cases where multiple bins might leave the same\n    minimal remaining capacity, a tie-breaking mechanism is introduced by prioritizing\n    bins with less initial slack (i.e., those that were already closer to being full).\n    This encourages packing larger items into bins that can better accommodate them\n    without wasting much space, aligning with the spirit of BFD for improved packing density.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin. Bins that cannot accommodate the item\n        receive a priority of -1. Higher scores indicate higher priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n        \n        # Calculate remaining capacity after placing the item\n        remaining_after_fit = fitting_bins_remain_cap - item\n        \n        # Priority 1: Minimize remaining capacity after fitting (Best Fit).\n        # We want to maximize the negative of remaining_after_fit.\n        # A large negative number means a small positive remaining capacity.\n        priority_score_bf = -remaining_after_fit\n        \n        # Priority 2: Tie-breaking - prioritize bins that were closer to full *before* fitting.\n        # This means prioritizing bins with smaller *original* remaining capacity\n        # among those that can fit the item and result in the same minimum 'remaining_after_fit'.\n        # To achieve this, we can penalize bins that have a larger original remaining capacity.\n        # We'll subtract the original remaining capacity from a large number, or simply\n        # use its negative value. Using the negative of the original remaining capacity\n        # means smaller original remaining capacities get higher (less negative) scores.\n        priority_score_tiebreaker = -fitting_bins_remain_cap\n\n        # Combine priorities: Primarily Best Fit, secondarily prefer bins with less initial slack.\n        # A simple way to combine is to use a weighted sum or lexicographical ordering.\n        # Lexicographical ordering is often preferred: sort by the primary criterion first,\n        # then by the secondary criterion for ties.\n        # To implement this with a single score, we can use a scaled value.\n        # For example, score = primary_value * large_constant + secondary_value\n        # Here, we want to maximize `priority_score_bf` and then `priority_score_tiebreaker`.\n        # We can achieve this by: score = priority_score_bf + (priority_score_tiebreaker / scale)\n        # where scale is chosen such that priority_score_bf always dominates priority_score_tiebreaker.\n        # A simpler way if we want to assign higher score:\n        # Let's assign a large multiplier to the primary goal (minimizing remaining capacity).\n        # The secondary goal (less initial slack) will be added.\n        # The primary goal is maximizing -(remaining_after_fit).\n        # The secondary goal is maximizing -(fitting_bins_remain_cap).\n\n        # We want to maximize the \"goodness\".\n        # Goodness is primarily determined by minimizing remaining_after_fit.\n        # So, a higher value of -remaining_after_fit is better.\n        # Secondarily, among bins with the same remaining_after_fit, we want to pick\n        # the one with smaller original fitting_bins_remain_cap. This means a higher\n        # value of -fitting_bins_remain_cap is better.\n\n        # To combine these, we can use a scoring system where the primary factor has\n        # a much larger weight.\n        # Let's scale the tie-breaking score to be much smaller than the primary score.\n        # The range of `remaining_after_fit` could be up to the bin capacity.\n        # The range of `fitting_bins_remain_cap` could also be up to the bin capacity.\n        # If we simply add them, they might interfere.\n        # A common technique is to use a large number for scaling.\n        # Let's assume max bin capacity is M.\n        # A score like: `-(remaining_after_fit) * (M + 1) + -(fitting_bins_remain_cap)`\n        # This ensures that minimizing `remaining_after_fit` is the dominant factor.\n        # The tie-breaker `-(fitting_bins_remain_cap)` ensures that among bins with\n        # the same `remaining_after_fit`, we pick the one with the smallest original capacity.\n\n        # To avoid hardcoding M, we can use a relative scaling.\n        # The maximum possible value for `remaining_after_fit` is bounded by the\n        # maximum possible bin capacity. Let's use a sufficiently large constant,\n        # or estimate a maximum possible capacity if known, or use a very large number.\n        # A safe bet is a number larger than any expected `fitting_bins_remain_cap`.\n        # Let's assume a large constant for scaling.\n        # A very large multiplier ensures that the primary objective (minimizing remaining space)\n        # completely dominates the secondary objective (minimizing initial slack).\n        scale_factor = 1e6 # Sufficiently large to dominate any difference in initial capacities\n\n        combined_priorities = priority_score_bf * scale_factor + priority_score_tiebreaker\n        \n        priorities[can_fit_mask] = combined_priorities\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 2.0,
    "halstead": 68.53238859703687,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Exact Fit with Normalized Slack Minimization priority function.\n\n    This strategy prioritizes bins that provide an exact fit for the item.\n    If no exact fit is available, it prioritizes bins that minimize the\n    \"normalized slack\" after placing the item. Normalized slack is defined\n    as (remaining_capacity - item) / original_bin_capacity. This helps\n    to favor bins that have a smaller relative waste, regardless of their\n    absolute remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacities: Array of original capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin. Bins that cannot accommodate the item\n        receive a priority of -1. Higher scores indicate higher priority.\n        Exact fits receive the highest possible score (e.g., a large positive number).\n        Other fits are ranked by the negative of their normalized slack (to maximize).\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    # Assume bin_capacities are available or can be inferred/passed.\n    # For this example, let's assume a constant bin capacity of 1.0 if not provided.\n    # In a real scenario, bin_capacities would likely be an input or stored with bins.\n    # We'll use a placeholder if bin_capacities is not passed implicitly.\n    # A more robust implementation would pass bin_capacities explicitly.\n    \n    # Placeholder for original bin capacities. In a real application, this would be known.\n    # Let's assume for demonstration purposes that all bins have a capacity of 1.0\n    # or that this information is accessible. If not, this heuristic needs adaptation.\n    # A practical approach would be to pass `bin_capacities` as an argument.\n    # For this problem, we'll simulate it assuming a fixed capacity for all bins\n    # to make the \"normalized slack\" concept work. A better design would pass it.\n    \n    # If `bins_remain_cap` were derived from `original_capacity - current_fill`,\n    # then `original_capacity` would be available. For a standalone function,\n    # we'll use a proxy: assume original capacity is related to current fill + remaining.\n    # A common simplification is to assume a standard bin capacity if not explicitly given.\n    # Let's assume a nominal bin capacity for the normalization.\n    # A safer approach is to actually pass the original bin capacities.\n    # For this exercise, we'll make a simplifying assumption:\n    # If item <= 1.0, and bins_remain_cap are used, it implies bins of capacity >= 1.0.\n    # Let's assume all bins have an implicit capacity of 1.0 for normalization purposes.\n    # If the actual bin capacities vary and are not provided, this normalization is problematic.\n    # Assuming a fixed conceptual bin capacity for normalization.\n    \n    # Let's try to infer a capacity if possible or use a default.\n    # A more robust way is to pass `original_bin_capacities` to the function.\n    # For the purpose of this example, we will assume a common bin capacity\n    # if bin_capacities is not an explicit parameter.\n    # If we can't assume a fixed capacity, the normalization needs careful handling.\n\n    # A common pattern in BPP is that items are a fraction of bin capacity,\n    # so if item sizes are like 0.5, 0.2, etc., bin capacity is often 1.0.\n    # Let's use 1.0 as the *reference* capacity for normalization if no better info.\n    # This is a critical assumption.\n    reference_capacity = 1.0 # This should ideally be passed as an argument\n\n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        # Prioritize exact fits with a high score\n        exact_fit_mask = (bins_remain_cap == item) & can_fit_mask\n        priorities[exact_fit_mask] = 1e9  # High priority for exact fits\n\n        # For bins that can fit but are not exact fits\n        non_exact_fit_mask = can_fit_mask & ~exact_fit_mask\n        \n        if np.any(non_exact_fit_mask):\n            remaining_after_fit = bins_remain_cap[non_exact_fit_mask] - item\n            \n            # Calculate normalized slack: (remaining_capacity - item) / reference_capacity\n            # We want to MINIMIZE normalized slack, so we maximize its negative.\n            # Add a small epsilon to the denominator to avoid division by zero if reference_capacity is 0\n            # or if we were normalizing by `bins_remain_cap[non_exact_fit_mask]` itself.\n            # Using a fixed reference capacity avoids issues with bins that are already very full.\n            \n            # Normalized slack = (bins_remain_cap[non_exact_fit_mask] - item) / reference_capacity\n            # We want to maximize -(normalized slack)\n            \n            # Using a simple inversion strategy for non-exact fits, prioritizing smaller remainders.\n            # The key is to make it stable and distinct from exact fits.\n            # We can scale the negative remainder.\n            # Maximizing the negative of the slack.\n            \n            # A common way to implement \"minimize slack\" is to use `-(slack)` where slack is positive.\n            # So, for `bins_remain_cap[non_exact_fit_mask] - item`, we want to maximize this value if it's negative,\n            # or minimize it if it's positive.\n            # The \"slack\" is `bins_remain_cap[non_exact_fit_mask] - item`.\n            # We want to minimize this slack. Thus, we maximize `- (slack)`.\n            \n            # Let's prioritize bins that leave smaller positive remaining capacity.\n            # If we want to prioritize MINIMIZING the slack `(bins_remain_cap[non_exact_fit_mask] - item)`\n            # we maximize `-(bins_remain_cap[non_exact_fit_mask] - item)`.\n            \n            # To incorporate \"normalized slack\" and avoid issues with very small bins,\n            # we normalize the slack by a reference capacity.\n            # slack = bins_remain_cap[non_exact_fit_mask] - item\n            # normalized_slack = slack / reference_capacity\n            # priority = -normalized_slack\n            \n            normalized_slack = (bins_remain_cap[non_exact_fit_mask] - item) / reference_capacity\n            priorities[non_exact_fit_mask] = -normalized_slack\n            \n            # A small adjustment to ensure non-exact fits are always less than exact fits,\n            # and to make scores more distinct if needed.\n            # Adding a large offset to the non-exact fit scores ensures they are distinct\n            # from the exact fit scores, but still ordered by their slack.\n            # However, -normalized_slack already achieves ordering.\n            # The key is that `1e9` is significantly larger than any possible `-normalized_slack`.\n            \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 3.0,
    "halstead": 114.6940428629768,
    "exec_success": true
  }
]