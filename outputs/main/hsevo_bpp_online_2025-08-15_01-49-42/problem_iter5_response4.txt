```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes exact fits, then bins with minimal normalized slack.

    Combines a high score for exact fits with a normalized slack measure
    for non-exact fits to effectively rank bins.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]
        remaining_after_fit = eligible_bins_remain_cap - item
        
        # Prioritize exact fits with a high score
        exact_fit_mask = remaining_after_fit == 0
        priorities[can_fit_mask][exact_fit_mask] = 1.0
        
        # For non-exact fits, prioritize minimizing normalized slack
        non_exact_fit_mask = ~exact_fit_mask
        if np.any(non_exact_fit_mask):
            non_exact_eligible_bins_remain_cap = eligible_bins_remain_cap[non_exact_fit_mask]
            
            # Calculate normalized slack: slack / original capacity (approximated by current remaining)
            # Adding epsilon to denominator for numerical stability and to slightly prefer fuller bins
            epsilon = 1e-9 
            normalized_slack = remaining_after_fit[non_exact_fit_mask] / (non_exact_eligible_bins_remain_cap + epsilon)
            
            # To maximize priority, we minimize normalized slack. So, we use 1.0 - normalized_slack.
            # This maps smaller normalized slack to higher priority.
            priorities[can_fit_mask][non_exact_fit_mask] = 1.0 - normalized_slack
            
    return priorities
```
