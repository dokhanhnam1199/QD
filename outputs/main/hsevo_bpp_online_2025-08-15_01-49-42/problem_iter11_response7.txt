```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes exact fits with a high score, then uses scaled negative remaining
    capacity (Best Fit) for differentiation, offering robust bin selection.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)

    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]
        remaining_capacities_if_fit = eligible_bins_remain_cap - item

        # Assign highest priority to exact fits
        exact_fit_mask = remaining_capacities_if_fit == 0
        priorities[can_fit_mask][exact_fit_mask] = 1.0

        # For non-exact fits, prioritize those with smallest remaining capacity (Best Fit)
        # Use a score that differentiates well for small remaining capacities.
        # A linear scale `C - remaining_capacity` works, but `-log(remaining_capacity + epsilon)`
        # offers better differentiation for near-perfect fits.
        # Let's use `-remaining_capacity` for simplicity and robustness, scaled to be
        # clearly less than the exact fit score.
        non_exact_priorities = -remaining_capacities_if_fit
        
        # Scale these scores to be distinct from exact fits (e.g., between 0 and 0.99)
        # We can normalize the `non_exact_priorities` or simply shift them.
        # Let's map the best non-exact fit (smallest positive remaining capacity) to 0.99
        # and the worst non-exact fit (largest remaining capacity) to a lower value.
        
        if np.any(~exact_fit_mask):
            non_exact_eligible_indices = np.where(can_fit_mask)[0][~exact_fit_mask]
            
            # Find the range of non-exact remaining capacities
            min_non_exact_rem = np.min(remaining_capacities_if_fit[~exact_fit_mask])
            max_non_exact_rem = np.max(remaining_capacities_if_fit[~exact_fit_mask])

            # Map the remaining capacities to a [0, 0.99] range
            # Best Fit (min remaining) maps to 0.99, worst Fit (max remaining) maps to a lower value.
            if max_non_exact_rem > min_non_exact_rem: # Avoid division by zero if all non-exact fits are identical
                scaled_non_exact_priorities = 0.99 * (1.0 - (remaining_capacities_if_fit[~exact_fit_mask] - min_non_exact_rem) / (max_non_exact_rem - min_non_exact_rem))
            else: # All non-exact fits have the same remaining capacity
                scaled_non_exact_priorities = np.full_like(remaining_capacities_if_fit[~exact_fit_mask], 0.5) # Assign a medium score

            priorities[non_exact_eligible_indices] = scaled_non_exact_priorities

    # Ensure bins that cannot fit have the lowest possible priority
    priorities[~can_fit_mask] = -np.inf 
    
    return priorities
```
