```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines exact fit priority with scaled inverse normalized slack for non-exact fits.
    Prioritizes bins that perfectly fit the item, then bins that leave minimal normalized slack.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities # No bins can fit the item

    # Calculate remaining capacities for bins that can fit the item
    remaining_after_fit = bins_remain_cap[can_fit_mask] - item
    
    # Assign high priority to exact fits (remaining capacity is zero)
    exact_fit_mask = remaining_after_fit == 0
    priorities[can_fit_mask][exact_fit_mask] = 1.0

    # Assign scores to non-exact fits based on normalized slack (inverse)
    # Higher score for smaller remaining capacity relative to original capacity.
    # Normalized slack = (bin_capacity - item) / bin_capacity
    # We want to maximize 1 - normalized_slack, which means minimizing normalized slack.
    # Smaller slack -> higher priority.
    # Score range for non-exact fits: [0.5, 0.99] to be less than exact fits.
    non_exact_fit_indices = np.where(can_fit_mask)[0][~exact_fit_mask]
    
    if non_exact_fit_indices.size > 0:
        bins_for_non_exact = bins_remain_cap[can_fit_mask][~exact_fit_mask]
        remaining_for_non_exact = remaining_after_fit[~exact_fit_mask]

        # Calculate normalized slack: remaining_capacity / original_capacity
        # Use a small epsilon to avoid division by zero if original capacity was 0 (should not happen if item fits)
        epsilon = 1e-9
        normalized_slack = remaining_for_non_exact / (bins_for_non_exact + epsilon)
        
        # Scale scores for non-exact fits to be between 0.5 and 0.99
        # We want to maximize (1 - normalized_slack), so we scale (1 - normalized_slack)
        # The value (1 - normalized_slack) ranges from approximately 0 (for large slack) to 1 (for very small slack).
        # We map this to [0.5, 0.99].
        # Scale factor: 0.49 (range of 0.99 - 0.5)
        # Offset: 0.5
        scaled_scores = 0.5 + 0.49 * (1.0 - normalized_slack)
        
        priorities[can_fit_mask][~exact_fit_mask] = scaled_scores

    return priorities
```
