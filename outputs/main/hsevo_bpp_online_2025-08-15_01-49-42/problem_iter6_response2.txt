```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Enhanced priority function focusing on exact fits and normalized slack minimization.

    This strategy prioritizes bins that can accommodate the item. Among those,
    it gives the highest priority to bins that result in an exact fit (zero remaining capacity).
    For bins that do not result in an exact fit, it prioritizes those with the
    minimum normalized slack. Normalized slack is defined as (remaining_capacity - item) / original_bin_capacity.
    Since original bin capacities are not directly available, we approximate this by
    minimizing (remaining_capacity - item) / (remaining_capacity - item + item),
    which is (remaining_capacity - item) / remaining_capacity.
    A higher score indicates a higher priority. Bins that cannot accommodate the item receive -1.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of priority scores for each bin. Bins that cannot accommodate the item
        receive a priority of -1. Higher scores indicate higher priority.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]
        
        # Calculate the remaining capacity after placing the item
        remaining_capacity_after_fit = eligible_bins_remain_cap - item
        
        # Assign highest priority to exact fits (remaining capacity is 0)
        exact_fit_mask = remaining_capacity_after_fit == 0
        priorities[can_fit_mask][exact_fit_mask] = 1e6 # A very high score for exact fits
        
        # For bins that are not an exact fit, calculate normalized slack
        non_exact_fit_mask = ~exact_fit_mask
        
        if np.any(non_exact_fit_mask):
            non_exact_bins_remain_cap = eligible_bins_remain_cap[non_exact_fit_mask]
            non_exact_remaining_after_fit = remaining_capacity_after_fit[non_exact_fit_mask]
            
            # Calculate normalized slack: (remaining_capacity - item) / remaining_capacity
            # Using bins_remain_cap[can_fit_mask][non_exact_fit_mask] as proxy for original capacity
            # to normalize the slack.
            # We want to minimize this normalized slack, so we'll take its negative
            # to turn minimization into maximization.
            epsilon = 1e-9 # To avoid division by zero or very small numbers for remaining capacity
            normalized_slack = non_exact_remaining_after_fit / (non_exact_bins_remain_cap + epsilon)
            
            # Assign priorities inversely proportional to normalized slack (higher score for smaller slack)
            # Scale to ensure it's distinct from exact fit scores but still significant
            priorities[can_fit_mask][non_exact_fit_mask] = -normalized_slack * 1e5 

    return priorities
```
