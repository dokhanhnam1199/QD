```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid heuristic prioritizing exact fits and then Best Fit with a penalty for extreme slack.

    This heuristic assigns the highest priority to bins that perfectly fit the item.
    For bins that do not offer an exact fit, it prioritizes those with the smallest
    remaining capacity (Best Fit). Additionally, it penalizes bins that would leave
    a disproportionately large amount of remaining capacity relative to the item size,
    promoting more balanced utilization.
    """
    priorities = np.full_like(bins_remain_cap, -1.0, dtype=float)
    
    # Define a score for exact fits to give them highest priority
    exact_fit_score = 1e6  # A very high score for perfect matches

    # Define a penalty factor for large slack relative to the item size.
    # This encourages more balanced packing by down-weighting bins that become too empty.
    slack_penalty_factor = 0.1
    
    # Define a small epsilon to handle potential division by zero or near-zero item sizes
    epsilon = 1e-9

    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        available_bins_indices = np.where(can_fit_mask)[0]
        
        # Calculate slack for bins that can fit the item
        slack = bins_remain_cap[available_bins_indices] - item
        
        # --- Scoring Logic ---
        
        # 1. Prioritize exact fits
        exact_fit_indices = np.where(slack < epsilon)[0]
        if exact_fit_indices.size > 0:
            priorities[available_bins_indices[exact_fit_indices]] = exact_fit_score
            
            # Remove exact fits from further consideration for secondary scoring
            # to ensure they retain the highest priority.
            non_exact_fit_indices = np.delete(np.arange(len(available_bins_indices)), exact_fit_indices)
            if non_exact_fit_indices.size == 0:
                return priorities # All fitting bins were exact fits

            # Update available_bins_indices to only include non-exact fits
            available_bins_indices = available_bins_indices[non_exact_fit_indices]
            slack = slack[non_exact_fit_indices]
        
        # 2. For non-exact fits, use Best Fit (minimize slack) as primary
        # Score is proportional to negative slack. Higher value for smaller slack.
        best_fit_scores = -slack
        
        # 3. Add a penalty for large slack relative to item size.
        # This discourages bins that remain too empty after packing.
        # Penalty is proportional to `slack / item` (or just `slack` if item is zero)
        # We use `slack / (item + epsilon)` to avoid division by zero.
        relative_slack = slack / (item + epsilon)
        
        # The penalty reduces the score for bins with high relative slack.
        # We subtract the penalty term.
        combined_scores = best_fit_scores - slack_penalty_factor * relative_slack
        
        priorities[available_bins_indices] = combined_scores

    return priorities
```
