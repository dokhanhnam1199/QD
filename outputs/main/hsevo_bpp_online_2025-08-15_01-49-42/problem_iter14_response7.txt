```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines exact fit priority with scaled inverse normalized slack, using tunable parameters.
    Prioritizes exact fits, then bins with minimal normalized slack for balanced packing.
    """
    exact_fit_priority = 1.0
    non_exact_fit_min_priority = 0.5
    non_exact_fit_max_priority = 0.99
    epsilon = 1e-9 # For numerical stability

    priorities = np.full_like(bins_remain_cap, -1.0, dtype=float)
    
    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    eligible_bins_indices = np.where(can_fit_mask)[0]
    
    if len(eligible_bins_indices) == 0:
        return priorities # No bins can fit the item

    eligible_bins_remain_cap = bins_remain_cap[eligible_bins_indices]
    
    # Prioritize exact fits
    exact_fit_mask = np.isclose(eligible_bins_remain_cap, item, atol=epsilon)
    priorities[eligible_bins_indices[exact_fit_mask]] = exact_fit_priority
    
    # Process non-exact fits
    non_exact_fit_indices_in_eligible = np.where(~exact_fit_mask)[0]
    
    if len(non_exact_fit_indices_in_eligible) > 0:
        non_exact_eligible_bins_remain_cap = eligible_bins_remain_cap[non_exact_fit_indices_in_eligible]
        
        # Calculate remaining capacity after placing the item
        remaining_after_fit = non_exact_eligible_bins_remain_cap - item
        
        # Calculate normalized slack: (remaining_capacity_after_fit) / (current_bin_capacity)
        # Smaller normalized slack is better (means the item fills more of the bin proportionally)
        normalized_slack = remaining_after_fit / (non_exact_eligible_bins_remain_cap + epsilon)
        
        # Create priority scores for non-exact fits:
        # We want smaller normalized_slack to result in higher scores.
        # Use 1.0 - normalized_slack to invert the desirability.
        # Scale these scores to be less than exact_fit_priority and within a defined range.
        best_fit_scores = 1.0 - normalized_slack
        
        # Scale scores to the range [non_exact_fit_min_priority, non_exact_fit_max_priority]
        # This maps normalized_slack=0 (best non-exact) to max_priority and normalized_slack=1 (worst non-exact) to min_priority.
        scaled_priorities = non_exact_fit_min_priority + np.clip(best_fit_scores, 0.0, 1.0) * (non_exact_fit_max_priority - non_exact_fit_min_priority)
        
        # Ensure non-exact fit priorities are strictly less than exact_fit_priority
        scaled_priorities = np.clip(scaled_priorities, non_exact_fit_min_priority, min(non_exact_fit_max_priority, exact_fit_priority - epsilon))
        
        priorities[eligible_bins_indices[non_exact_fit_indices_in_eligible]] = scaled_priorities
        
    return priorities
```
