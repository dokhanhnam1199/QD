```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive Best Fit Decreasing-like priority function with capacity normalization.

    This strategy prioritizes bins that are a "good fit" for the item,
    aiming to minimize wasted space. It considers bins that can fit the item
    and assigns higher priority to those where the remaining capacity after
    placement is relatively small compared to the bin's original capacity.
    This aims to utilize bins more efficiently and potentially leave larger
    remaining spaces in other bins for future larger items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of priority scores for each bin. Bins that cannot accommodate the item
        receive a priority of -1. Higher scores indicate higher priority.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)

    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
        
        # Calculate remaining capacity after placing the item
        remaining_if_fit = fitting_bins_remain_cap - item

        # Normalize remaining capacity by the bin's *original* capacity (approximated by current remaining capacity)
        # to get a relative measure of wasted space.
        # A lower relative remaining capacity (less waste) gets a higher score.
        # We use bins_remain_cap which is the capacity *before* fitting.
        # To avoid division by zero if a bin is exactly full (though this shouldn't happen if item > 0),
        # we add a small epsilon.
        epsilon = 1e-9
        
        # Higher priority for bins that leave *less* relative slack.
        # The slack is (bin_capacity - item). We want to minimize this slack relative to bin_capacity.
        # So we maximize -(slack / bin_capacity).
        # We use fitting_bins_remain_cap as an approximation of bin_capacity if it's not empty.
        # If a bin has 0 remaining capacity, it means it's full. If an item fits, the remaining capacity is 0.
        # The relative slack is 0 / bin_capacity = 0.
        
        # Calculate the "goodness of fit" by minimizing the remaining capacity relative to the bin's capacity.
        # A smaller `remaining_if_fit / fitting_bins_remain_cap` indicates a better fit.
        # We want to maximize the negative of this value to get higher priorities for better fits.
        relative_slack = remaining_if_fit / (fitting_bins_remain_cap + epsilon)
        priorities[can_fit_mask] = -relative_slack

        # An alternative that might be more direct about minimizing wasted space:
        # Prioritize bins that are "almost full" after fitting, but consider the original capacity.
        # We want to maximize `1 - (remaining_if_fit / fitting_bins_remain_cap)` which is `(fitting_bins_remain_cap - remaining_if_fit) / fitting_bins_remain_cap`.
        # This is equivalent to maximizing `item / fitting_bins_remain_cap`, which prioritizes bins
        # where the item takes up a larger proportion of the *available* capacity.
        # priorities[can_fit_mask] = item / (fitting_bins_remain_cap + epsilon)
        
    return priorities
```
