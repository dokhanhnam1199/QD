```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using an epsilon-greedy approach favoring bins with less remaining capacity."""
    epsilon = 0.1
    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins)

    available_bins_mask = bins_remain_cap >= item
    available_bins_indices = np.where(available_bins_mask)[0]

    if len(available_bins_indices) == 0:
        return np.zeros(num_bins)

    if np.random.rand() < epsilon:
        chosen_bin_index = np.random.choice(available_bins_indices)
        priorities[chosen_bin_index] = 1.0
    else:
        remaining_capacities_for_available_bins = bins_remain_cap[available_bins_mask]
        
        # Calculate priorities: favor bins with less remaining capacity
        # Inverting the remaining capacity to make smaller capacities have higher priority
        # Add a small epsilon to avoid division by zero if any remaining capacity is zero
        inverted_capacities = 1.0 / (remaining_capacities_for_available_bins - item + 1e-9)
        
        # Normalize priorities to sum to 1, so it can be interpreted as a probability distribution
        normalized_priorities = inverted_capacities / np.sum(inverted_capacities)
        
        # Assign these normalized priorities to the original bins
        priorities[available_bins_mask] = normalized_priorities
        
        # Select the bin with the highest priority (largest inverted capacity)
        best_bin_original_index = available_bins_indices[np.argmax(normalized_priorities)]
        priorities = np.zeros(num_bins) # Reset priorities to ensure only the best bin gets high priority
        priorities[best_bin_original_index] = 1.0 # Set the best bin to have the highest priority

    return priorities
```
