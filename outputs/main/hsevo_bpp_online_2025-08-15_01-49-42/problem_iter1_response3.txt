```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Almost Full Fit priority function.

    This strategy prioritizes bins that will be "almost full" after placing the item.
    A bin is considered "almost full" if its remaining capacity after placing the item
    is small. We want to select the bin that leaves the minimum remaining capacity,
    provided it can accommodate the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of priority scores for each bin. Bins that cannot accommodate the item
        receive a priority of -1. Higher scores indicate higher priority.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        remaining_capacities_if_fit = bins_remain_cap[can_fit_mask] - item
        
        # We want to prioritize bins where the remaining capacity is *minimal* after fitting.
        # So, a smaller remaining capacity should yield a higher priority.
        # We can invert the remaining capacity values and then scale them or just use
        # a value inversely proportional to the remaining capacity.
        # Here, we'll use 1 / (remaining_capacity + epsilon) to avoid division by zero
        # and to ensure smaller remaining capacities get higher scores.
        # A simple approach is to subtract from a large number or use a negative linear function.
        # Let's use a value that is inversely proportional to remaining capacity.
        # However, to keep it simpler and still capture the "almost full" idea,
        # we can assign a higher priority to bins that leave a smaller remainder.
        # A very direct interpretation of "almost full" is to prioritize the bin
        # that, after placing the item, has the smallest *positive* remaining capacity.
        # This can be achieved by minimizing `bins_remain_cap - item`.
        # So, we want to *maximize* the negative of `bins_remain_cap - item`.
        
        priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)
        
        # Alternative: Use a small epsilon to make it robust
        # epsilon = 1e-9
        # priorities[can_fit_mask] = 1.0 / (remaining_capacities_if_fit + epsilon)

    return priorities
```
