```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid heuristic prioritizing exact fits, then Best Fit, and finally penalizing extreme slack.

    This heuristic assigns the highest priority to exact fits. For non-exact fits,
    it prioritizes bins with minimal remaining capacity (Best Fit) and applies a
    penalty to bins that would leave disproportionately large residual capacity,
    promoting more balanced bin utilization.
    """
    priorities = np.full_like(bins_remain_cap, -1.0, dtype=float)
    
    # Define a high score for exact fits to ensure they are prioritized.
    exact_fit_score = 1e9
    
    # Define a penalty factor for large relative slack. This discourages packing
    # into bins that would remain excessively empty compared to the item size.
    slack_penalty_factor = 0.1
    
    # Epsilon to prevent division by zero or near-zero values.
    epsilon = 1e-9

    # Identify bins that can accommodate the item.
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        fitting_bins_indices = np.where(can_fit_mask)[0]
        
        # Calculate the remaining capacity for bins that can fit the item.
        remaining_capacities_if_fit = bins_remain_cap[fitting_bins_indices] - item
        
        # --- Scoring Logic ---
        
        # 1. Prioritize exact fits.
        exact_fit_mask = np.abs(remaining_capacities_if_fit) < epsilon
        
        if np.any(exact_fit_mask):
            priorities[fitting_bins_indices[exact_fit_mask]] = exact_fit_score
            
            # Filter out exact fits to process non-exact fits separately.
            non_exact_fit_indices_in_fitting = np.where(~exact_fit_mask)[0]
            
            if non_exact_fit_indices_in_fitting.size > 0:
                # Get the actual indices and remaining capacities for non-exact fits.
                actual_non_exact_indices = fitting_bins_indices[non_exact_fit_indices_in_fitting]
                non_exact_remaining_capacities = remaining_capacities_if_fit[non_exact_fit_indices_in_fitting]
                
                # 2. For non-exact fits, use Best Fit: higher score for smaller remaining capacity.
                # Score is inversely proportional to the remaining capacity.
                best_fit_scores = 1.0 / (non_exact_remaining_capacities + epsilon)
                
                # 3. Apply a penalty for large slack relative to item size.
                # Calculate relative slack to penalize bins that become disproportionately empty.
                # Use item size plus epsilon to avoid division by zero for small items.
                relative_slack = non_exact_remaining_capacities / (item + epsilon)
                
                # The penalty reduces the score. A higher relative slack leads to a larger penalty.
                penalty = slack_penalty_factor * relative_slack
                
                # Combine Best Fit score with the penalty.
                combined_scores = best_fit_scores - penalty
                
                # Assign the combined scores to the priorities array.
                priorities[actual_non_exact_indices] = combined_scores

        else: # If no exact fits, process all fitting bins as non-exact fits.
            # 2. For non-exact fits, use Best Fit: higher score for smaller remaining capacity.
            best_fit_scores = 1.0 / (remaining_capacities_if_fit + epsilon)
            
            # 3. Apply a penalty for large slack relative to item size.
            relative_slack = remaining_capacities_if_fit / (item + epsilon)
            penalty = slack_penalty_factor * relative_slack
            combined_scores = best_fit_scores - penalty
            
            priorities[fitting_bins_indices] = combined_scores

    return priorities
```
