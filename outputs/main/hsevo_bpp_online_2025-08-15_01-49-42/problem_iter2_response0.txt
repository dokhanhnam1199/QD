```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best Fit and a scaled inverse for robust prioritization.

    Prioritizes bins that result in the smallest remaining capacity after packing (Best Fit),
    and for other bins, uses an inverse of the remaining capacity scaled by a small constant
    to avoid extreme values and provide smoother ranking.
    """
    priorities = np.zeros_like(bins_remain_cap)
    available_bins_mask = bins_remain_cap >= item
    available_bins_caps = bins_remain_cap[available_bins_mask]

    if available_bins_caps.size > 0:
        remaining_after_fit = available_bins_caps - item
        
        # Prioritize exact fits (remaining capacity is 0) with a high score
        exact_fit_mask = remaining_after_fit == 0
        priorities[available_bins_mask][exact_fit_mask] = 1.0

        # For non-exact fits, use a scaled inverse to prioritize bins with less remaining space
        non_exact_fit_mask = ~exact_fit_mask
        non_exact_bins_remaining = remaining_after_fit[non_exact_fit_mask]
        
        if non_exact_bins_remaining.size > 0:
            # Add a small constant to avoid division by zero and to smooth priorities
            # Scale by a factor to differentiate non-exact fits without overpowering exact fits
            scaled_inverse = 0.1 / (non_exact_bins_remaining + 1.0) 
            priorities[available_bins_mask][non_exact_fit_mask] = scaled_inverse
            
    return priorities
```
