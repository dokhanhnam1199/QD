{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins that offer the tightest fit using a combination of inverse scaling and offset for numerical stability.\n\n    This heuristic aims to give higher priority to bins where the remaining capacity is just enough to fit the item,\n    using an inverse relationship with the difference between bin capacity and item size. A small offset is added\n    to the denominator to prevent division by zero and to ensure bins that exactly fit receive a very high priority.\n    \"\"\"\n    suitable_bins_mask = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n\n    if suitable_bins_remain_cap.size > 0:\n        # Calculate the difference between remaining capacity and item size for suitable bins.\n        differences = suitable_bins_remain_cap - item\n        # Assign priorities: inverse of (difference + 1.0 + epsilon).\n        # Adding 1.0 to the difference ensures that bins with zero difference (exact fits)\n        # get a high priority (1/1). Adding a small epsilon (1e-9) handles potential\n        # floating-point issues and ensures non-zero denominators.\n        priorities[suitable_bins_mask] = 1.0 / (differences + 1.0 + 1e-9)\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Prioritizes bins that are closest to fitting the item (best fit),\n    while also giving a strong preference to exact fits.\n    It uses inverse of slack for non-exact fits, with a bonus for exact matches.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Mask for bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    # Calculate slack for bins that can fit\n    slack = bins_remain_cap[can_fit_mask] - item\n    \n    # Exact fit bonus: prioritize bins with zero slack\n    exact_fit_mask_local = slack == 0\n    if np.any(exact_fit_mask_local):\n        # Assign a high priority to exact fits\n        priorities[can_fit_mask][exact_fit_mask_local] = 1.0\n    \n    # Non-exact fits: prioritize those with smaller slack (closer to fitting)\n    non_exact_fit_mask_local = slack > 0\n    if np.any(non_exact_fit_mask_local):\n        # Use inverse of slack + 1 to avoid division by zero and give higher priority to smaller slack\n        # Add a small epsilon for numerical stability, though slack > 0 should handle it.\n        priorities[can_fit_mask][non_exact_fit_mask_local] = 1.0 / (slack[non_exact_fit_mask_local] + 1e-9)\n        \n    # Normalize priorities to ensure a consistent scale, giving a slight boost to exact fits\n    # This is inspired by prioritizing exact fits with a score of 1.0 and scaled inverse for others\n    # We can scale non-exact fits relative to the best non-exact fit to make them more distinguishable\n    if np.any(priorities[can_fit_mask][non_exact_fit_mask_local]):\n        max_non_exact_priority = np.max(priorities[can_fit_mask][non_exact_fit_mask_local])\n        if max_non_exact_priority > 0: # Avoid division by zero if only exact fits exist\n            priorities[can_fit_mask][non_exact_fit_mask_local] /= max_non_exact_priority\n            priorities[can_fit_mask][non_exact_fit_mask_local] *= 0.9 # Scale down non-exact fits\n            \n    # Ensure exact fits (priority 1.0) still stand out\n    if np.any(priorities[can_fit_mask][exact_fit_mask_local]):\n         priorities[can_fit_mask][exact_fit_mask_local] = 1.0\n            \n    return priorities\n\n### Analyze & experience\n- Comparing Heuristic 1 ([Heuristics 1st]) and Heuristic 7 ([Heuristics 7th]), they are functionally identical, both using `1.0 / (remaining_after_fit + epsilon)` with `epsilon=1.0` in Heuristic 1 and `epsilon=0.8954438612151145` in Heuristic 7. The choice of `epsilon` is a hyperparameter.\n\nComparing Heuristic 2 ([Heuristics 2nd]) and Heuristic 6 ([Heuristics 6th]), they are identical implementations using `1.0 / (differences + 1.0 + 1e-9)`.\n\nComparing Heuristic 3 ([Heuristics 3rd]) and Heuristic 11 ([Heuristics 11th]), both aim to minimize normalized slack `remaining_capacities_if_fit / current_bin_capacities`. Heuristic 3 uses `-(remaining_capacities_if_fit) - epsilon * eligible_bins_remain_cap` while Heuristic 11 uses `1.0 - normalized_slack`. Heuristic 11's `1.0 - normalized_slack` is a clearer objective function for minimizing slack. Heuristic 3's approach of penalizing already fuller bins might be an interesting secondary objective but adds complexity.\n\nComparing Heuristic 9 ([Heuristics 9th]) and Heuristic 11 ([Heuristics 11th]), they are identical, both implementing `1.0 - normalized_slack` where `normalized_slack` is `remaining_capacities_if_fit / (current_bin_capacities + epsilon)`.\n\nComparing Heuristic 10 ([Heuristics 10th]) and Heuristic 12 ([Heuristics 12th]), they are identical, implementing an exact fit priority of 1.0 and then scaling best fit priorities to a range like [0.5, 0.9].\n\nComparing Heuristic 13 ([Heuristics 13th]) and Heuristic 19 ([Heuristics 19th]), they are identical. They prioritize exact fits with 1.0 and then normalize other scaled inverse priorities so the highest is 1.0.\n\nComparing Heuristic 14 ([Heuristics 14th]) and Heuristic 17 ([Heuristics 17th]) and Heuristic 20 ([Heuristics 20th]), they are identical. They prioritize exact fits with 1.0 and then apply `0.1 / (non_exact_bins_remaining + 1.0)` for non-exact fits.\n\nComparing Heuristic 5 ([Heuristics 5th]) and Heuristic 16 ([Heuristics 16th]): Heuristic 5 directly uses `-(bins_remain_cap[can_fit_mask] - item)` which is equivalent to maximizing the negative slack. Heuristic 16 uses a sigmoid function on normalized differences, which is a more complex approach to prioritize smaller differences.\n\nOverall, heuristics that directly prioritize minimizing slack (like `1.0 - normalized_slack` or negative slack) or exact fits with a clear scoring are generally better. The use of `epsilon` or other constants for stability and scaling is important. Combinations of exact fit with best fit are common and effective.\n- \nHere's a redefinition of \"Current self-reflection\" to inform heuristic design, avoiding the pitfalls of \"Ineffective self-reflection\":\n\n*   **Keywords:** Exact fit, slack minimization, normalized slack, stable scoring, distinct ranking.\n*   **Advice:** Design scoring functions that explicitly reward exact fits, and for imperfect fits, prioritize minimizing normalized slack (slack / bin capacity) to robustly compare options across different bin sizes.\n*   **Avoid:** Direct comparisons of raw slack, numerical instability from division by zero or very small capacities, and overly complex scaling that obscures underlying trade-offs.\n*   **Explanation:** Clear, stable scoring ensures the heuristic reliably identifies the best available bin without getting bogged down by numerical quirks or losing interpretability, crucial for effective optimization.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}