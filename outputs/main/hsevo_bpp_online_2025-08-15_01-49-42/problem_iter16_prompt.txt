{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes exact fits, then bins with minimal normalized slack,\n    and uses initial bin capacity as a tie-breaker for bins with similar slack.\n    This combines the robustness of normalized slack with a tie-breaking mechanism\n    to favor bins that were fuller initially.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    # Mask for bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    fit_indices = np.where(can_fit_mask)[0]\n\n    if len(fit_indices) == 0:\n        return priorities\n\n    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    original_eligible_bins_cap = bins_remain_cap[can_fit_mask] # Keep original capacities for tie-breaking\n\n    # High priority for exact fits\n    exact_fit_mask_in_eligible = np.abs(eligible_bins_remain_cap - item) < epsilon\n    exact_fit_indices_filtered = np.where(exact_fit_mask_in_eligible)[0]\n    actual_exact_fit_indices = fit_indices[exact_fit_indices_filtered]\n    priorities[actual_exact_fit_indices] = 1.0\n\n    # For non-exact fits, prioritize minimal normalized slack\n    non_exact_fit_mask_in_eligible = ~exact_fit_mask_in_eligible\n    non_exact_fit_indices_filtered = np.where(non_exact_fit_mask_in_eligible)[0]\n    actual_non_exact_fit_indices = fit_indices[non_exact_fit_indices_filtered]\n\n    if len(actual_non_exact_fit_indices) > 0:\n        eligible_bins_for_slack_subset = eligible_bins_remain_cap[non_exact_fit_indices_filtered]\n        original_capacities_for_slack_subset = original_eligible_bins_cap[non_exact_fit_indices_filtered]\n        \n        # Calculate remaining capacity after fitting the item\n        remaining_after_fit = eligible_bins_for_slack_subset - item\n        \n        # Normalized slack: remaining capacity / original bin capacity. Smaller is better.\n        normalized_remaining_capacity = remaining_after_fit / (original_capacities_for_slack_subset + epsilon)\n        \n        # Score based on inverse normalized slack (higher for smaller slack)\n        # Scale to be less than 1.0\n        best_fit_scores = 1.0 - normalized_remaining_capacity\n        scaled_best_fit_priorities = 0.5 + best_fit_scores * 0.49\n\n        # Tie-breaker: prioritize bins that were fuller initially if normalized slack is similar\n        # This can be achieved by adding a small value proportional to original capacity, scaled appropriately.\n        # We use original capacity directly here as a secondary score component.\n        # Normalize original capacity to avoid dominating the primary slack score.\n        normalized_original_capacity = (original_capacities_for_slack_subset / np.max(original_capacities_for_slack_subset + epsilon)) * 0.01\n        \n        final_non_exact_priorities = scaled_best_fit_priorities - normalized_original_capacity # Subtract to favor smaller slack, but use original capacity as a penalty for larger initial bins\n\n        priorities[actual_non_exact_fit_indices] = final_non_exact_priorities\n\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}