```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_original_caps: np.ndarray) -> np.ndarray:
    """
    Combines exact fit, minimized normalized slack, and a tie-breaker.
    Prioritizes exact fits, then bins with minimal normalized slack, using
    remaining capacity as a tie-breaker.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    # Mask for bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        eligible_indices = np.where(can_fit_mask)[0]
        eligible_bins_remain_cap = bins_remain_cap[eligible_indices]
        eligible_bins_original_caps = bin_original_caps[eligible_indices]

        # 1. Exact Fit: Highest Priority
        exact_fit_mask = (eligible_bins_remain_cap == item)
        if np.any(exact_fit_mask):
            priorities[eligible_indices[exact_fit_mask]] = 1e9  # Very high score for exact fits

        # 2. Non-Exact Fits: Minimize Normalized Slack
        # Normalized slack = (remaining_capacity - item) / original_bin_capacity
        # We want to maximize -(normalized_slack) to prioritize smaller slack.
        non_exact_fit_mask = ~exact_fit_mask
        
        if np.any(non_exact_fit_mask):
            non_exact_indices = eligible_indices[non_exact_fit_mask]
            current_remain_caps = eligible_bins_remain_cap[non_exact_fit_mask]
            original_caps = eligible_bins_original_caps[non_exact_fit_mask]

            # Calculate normalized slack. Add epsilon to denominator for stability.
            normalized_slack = (current_remain_caps - item) / (original_caps + 1e-9)
            
            # To make scores distinct from exact fits and order them,
            # we use a scaled negative normalized slack.
            # The scale factor ensures they are lower than exact fits.
            # We also add a term based on remaining capacity as a tie-breaker:
            # Larger remaining capacity after fit is worse, so we use negative remaining capacity.
            # The overall score for non-exact fits: -normalized_slack - (remaining_after_fit / original_capacity)
            # We want to maximize this score.
            
            remaining_after_fit = current_remain_caps - item
            
            # Score combines minimizing normalized slack and minimizing residual capacity.
            # The goal is to maximize the combined score.
            # Higher priority for lower normalized slack and lower residual capacity after fit.
            # Using negative values to maximize.
            score_normalized_slack = -normalized_slack
            score_residual = -(remaining_after_fit / (original_caps + 1e-9))

            # Combine scores: Prioritize normalized slack more, then residual capacity.
            # Scale normalized slack to have a larger impact.
            combined_score = score_normalized_slack * 100 + score_residual
            
            priorities[non_exact_indices] = combined_score

    return priorities
```
