```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Almost Full Fit strategy for online Bin Packing Problem.
    Prioritizes bins that are almost full but can still accommodate the item.
    A small capacity difference is preferred over a large one,
    while ensuring the item fits.
    """
    # Find bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item

    # Calculate the remaining capacity after placing the item
    remaining_capacities_if_placed = bins_remain_cap[suitable_bins_mask] - item

    # Calculate the "tightness" of the fit. Smaller is better.
    # Add a small epsilon to avoid division by zero if remaining capacity is exactly 0
    tightness = remaining_capacities_if_placed / (bins_remain_cap[suitable_bins_mask] + 1e-9)

    # Higher priority for bins that are tighter fits (closer to 1 after fitting)
    # We want bins that are almost full but can still take the item.
    # A good heuristic is to give priority based on how little is left over.
    # A bin with remaining_capacity = 0.1 for an item of size 0.9 (original bin 1.0) is
    # a better fit than a bin with remaining_capacity = 0.5 for an item of size 0.5 (original bin 1.0)
    # We can invert the remaining capacity or use 1 - tightness.
    # A higher value indicates a better fit.
    priorities = np.zeros_like(bins_remain_cap)
    
    # We use 1 - tightness as the priority score. A smaller remaining space after fitting
    # means a higher priority.
    # Let's try to prioritize bins where the remaining capacity after placing the item
    # is as small as possible.
    # So, a bin where `bins_remain_cap - item` is small gets a high score.
    # We can use `1 / (bins_remain_cap - item + epsilon)` but this might favor bins with very small capacities.
    # A better approach for "Almost Full Fit" is to give priority to bins where the remaining capacity
    # *after* placing the item is minimized, but not negative.
    
    # Let's calculate a score that is higher for bins that are "more full" after the item is placed.
    # This means `bins_remain_cap - item` should be small.
    # We can use the negative of the remaining capacity as a simple measure.
    # More negative means smaller remaining capacity, thus higher priority.
    
    priorities[suitable_bins_mask] = -(remaining_capacities_if_placed)
    
    # To make sure we prioritize bins that are *almost* full, we can penalize bins
    # that have a lot of space left.
    # Consider the difference between the original capacity and the remaining capacity *after* placement.
    # We want this difference to be close to the bin's original capacity.
    
    # Let's reconsider. The goal is to place the item in a bin such that the remaining space
    # in that bin is minimized. This means `bins_remain_cap - item` should be minimal (but non-negative).
    # So, the priority should be proportional to `-(bins_remain_cap - item)`.
    
    # Let's define priority as a value that we want to maximize.
    # If a bin has very little space left *after* placing the item, it's a good fit.
    # So, priority is inversely related to `bins_remain_cap - item`.
    # A simple way: `1.0 / (bins_remain_cap - item + epsilon)`.
    # However, this could be problematic if the original capacities vary widely.
    
    # The "Almost Full Fit" implies we want to find a bin that is *just* large enough,
    # or as close to full as possible after the item is placed.
    # So, `bins_remain_cap - item` should be small.
    # Let's try priority = 1 / (1 + (bins_remain_cap - item))
    # This gives a higher score to smaller (bins_remain_cap - item).
    
    # Re-calculating the priority for suitable bins
    priorities[suitable_bins_mask] = 1.0 / (1.0 + (bins_remain_cap[suitable_bins_mask] - item))
    
    # To ensure "Almost Full Fit" specifically, we might want to emphasize bins that are already quite full.
    # This can be achieved by multiplying the score by how full the bin already is (before placing the item).
    # However, "Almost Full Fit" typically focuses on the *remaining capacity after placement*.
    
    # Let's use a strategy that favors bins with the smallest remaining capacity *after* the item is placed.
    # This means we want to minimize `bins_remain_cap - item`.
    # So, the priority score should be high when `bins_remain_cap - item` is low.
    # We can use `-(bins_remain_cap - item)` as a proxy for higher priority for lower remaining capacity.
    
    priorities[suitable_bins_mask] = -(bins_remain_cap[suitable_bins_mask] - item)

    return priorities
```
