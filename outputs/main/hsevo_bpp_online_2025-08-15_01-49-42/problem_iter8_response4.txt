```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best Fit with a penalty for large initial slacks, prioritizing exact fits.

    This heuristic prioritizes exact fits with a high score. For non-exact fits,
    it favors bins with minimal remaining capacity, applying a penalty based on
    the bin's original slack to encourage using bins that were already fuller.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
        
        # Score 1: Prioritize exact fits with a very high score.
        exact_fit_mask = fitting_bins_remain_cap == item
        priorities[can_fit_mask][exact_fit_mask] = 1e6 

        # Score 2: For non-exact fits, prioritize minimizing remaining capacity (Best Fit).
        # We want to maximize -(remaining_after_fit).
        non_exact_fit_mask = ~exact_fit_mask
        if np.any(non_exact_fit_mask):
            non_exact_fitting_bins_remain_cap = fitting_bins_remain_cap[non_exact_fit_mask]
            remaining_after_fit = non_exact_fitting_bins_remain_cap - item
            
            # Score 3: Tie-breaking - penalize bins with large initial slack.
            # This encourages using bins that were already closer to full.
            # We use the negative of original remaining capacity as a secondary scoring metric.
            # A smaller initial remaining capacity (larger negative value) is better.
            
            # Combine Best Fit score and initial slack penalty.
            # Maximize -(remaining_after_fit) for Best Fit.
            # Maximize -(fitting_bins_remain_cap) for secondary tie-breaking.
            # Use a large scale factor to ensure Best Fit dominates.
            scale_factor = 1e6  # Ensures Best Fit objective is dominant
            
            # Priorities for non-exact fits: max(-remaining_after_fit * scale_factor - fitting_bins_remain_cap)
            combined_priorities = -remaining_after_fit * scale_factor - non_exact_fitting_bins_remain_cap
            
            priorities[can_fit_mask][non_exact_fit_mask] = combined_priorities

    return priorities
```
