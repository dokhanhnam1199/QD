[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes exact fits, then bins with minimal normalized slack,\n    and uses initial bin capacity as a tie-breaker for bins with similar slack.\n    This combines the robustness of normalized slack with a tie-breaking mechanism\n    to favor bins that were fuller initially.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    # Mask for bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    fit_indices = np.where(can_fit_mask)[0]\n\n    if len(fit_indices) == 0:\n        return priorities\n\n    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    original_eligible_bins_cap = bins_remain_cap[can_fit_mask] # Keep original capacities for tie-breaking\n\n    # High priority for exact fits\n    exact_fit_mask_in_eligible = np.abs(eligible_bins_remain_cap - item) < epsilon\n    exact_fit_indices_filtered = np.where(exact_fit_mask_in_eligible)[0]\n    actual_exact_fit_indices = fit_indices[exact_fit_indices_filtered]\n    priorities[actual_exact_fit_indices] = 1.0\n\n    # For non-exact fits, prioritize minimal normalized slack\n    non_exact_fit_mask_in_eligible = ~exact_fit_mask_in_eligible\n    non_exact_fit_indices_filtered = np.where(non_exact_fit_mask_in_eligible)[0]\n    actual_non_exact_fit_indices = fit_indices[non_exact_fit_indices_filtered]\n\n    if len(actual_non_exact_fit_indices) > 0:\n        eligible_bins_for_slack_subset = eligible_bins_remain_cap[non_exact_fit_indices_filtered]\n        original_capacities_for_slack_subset = original_eligible_bins_cap[non_exact_fit_indices_filtered]\n        \n        # Calculate remaining capacity after fitting the item\n        remaining_after_fit = eligible_bins_for_slack_subset - item\n        \n        # Normalized slack: remaining capacity / original bin capacity. Smaller is better.\n        normalized_remaining_capacity = remaining_after_fit / (original_capacities_for_slack_subset + epsilon)\n        \n        # Score based on inverse normalized slack (higher for smaller slack)\n        # Scale to be less than 1.0\n        best_fit_scores = 1.0 - normalized_remaining_capacity\n        scaled_best_fit_priorities = 0.5 + best_fit_scores * 0.49\n\n        # Tie-breaker: prioritize bins that were fuller initially if normalized slack is similar\n        # This can be achieved by adding a small value proportional to original capacity, scaled appropriately.\n        # We use original capacity directly here as a secondary score component.\n        # Normalize original capacity to avoid dominating the primary slack score.\n        normalized_original_capacity = (original_capacities_for_slack_subset / np.max(original_capacities_for_slack_subset + epsilon)) * 0.01\n        \n        final_non_exact_priorities = scaled_best_fit_priorities - normalized_original_capacity # Subtract to favor smaller slack, but use original capacity as a penalty for larger initial bins\n\n        priorities[actual_non_exact_fit_indices] = final_non_exact_priorities\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 3.0,
    "halstead": 237.08652360984732,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Hybrid heuristic: Prioritizes exact fits, then Best Fit, with a penalty for extreme slack.\n    Combines the exact fit priority of v0 with the normalized slack of v1, and adds a penalty.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float) # Initialize with negative infinity for non-fitting bins\n    epsilon = 1e-9\n\n    # --- Exact Fit Priority (High Priority) ---\n    exact_fit_mask = np.isclose(bins_remain_cap, item)\n    exact_fit_score = 1e6  # High score for perfect matches\n    priorities[exact_fit_mask] = exact_fit_score\n\n    # --- Non-Exact Fit Priorities ---\n    can_fit_mask = bins_remain_cap > item\n    fitting_bins_indices = np.where(can_fit_mask)[0]\n\n    if fitting_bins_indices.size > 0:\n        fitting_bins_remain_cap = bins_remain_cap[fitting_bins_indices]\n        \n        # Calculate remaining capacity after placing the item\n        remaining_capacities_after_fit = fitting_bins_remain_cap - item\n        \n        # --- Best Fit Component (Minimize remaining capacity) ---\n        # Prioritize bins with less remaining capacity. Score is inverse of remaining capacity.\n        best_fit_score_component = 1.0 / (remaining_capacities_after_fit + epsilon)\n        \n        # --- Slack Penalty Component (Discourage extreme slack) ---\n        # Penalty for bins that would have a large amount of remaining capacity relative to the item size.\n        # This term is subtracted, so a larger penalty means a lower score.\n        slack_penalty_factor = 0.05 # Tunable parameter for penalty strength\n        relative_slack = remaining_capacities_after_fit / (item + epsilon)\n        slack_penalty_component = slack_penalty_factor * relative_slack\n\n        # Combine scores: Prioritize small remaining capacity, then penalize large relative slack.\n        # Scale Best Fit component to differentiate from exact fits, but be lower.\n        # Use a factor to keep it below exact_fit_score.\n        scaled_best_fit = 1000.0 * best_fit_score_component\n        combined_non_exact_score = scaled_best_fit - slack_penalty_component\n\n        # Assign scores to priorities array for fitting bins\n        priorities[fitting_bins_indices] = combined_non_exact_score\n        \n        # Ensure that exact fits (already assigned exact_fit_score) are still higher.\n        # This is implicitly handled by the high exact_fit_score value.\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 2.0,
    "halstead": 144.75398259382442,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes exact fits, then bins with minimal normalized slack,\n    using a tiered scoring system with robust normalization.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    fit_indices = np.where(can_fit_mask)[0]\n\n    if len(fit_indices) == 0:\n        return priorities  # No bins can fit the item\n\n    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # Tier 1: Exact fits receive the highest priority\n    exact_fit_mask_local = np.abs(eligible_bins_remain_cap - item) < epsilon\n    exact_fit_indices_global = fit_indices[exact_fit_mask_local]\n    priorities[exact_fit_indices_global] = 1.0\n\n    # Tier 2: Non-exact fits, prioritizing those with minimal normalized slack\n    # Calculate slack after fitting the item\n    remaining_after_fit = eligible_bins_remain_cap - item\n\n    # Normalize slack relative to the bin's original remaining capacity\n    # This gives a measure of how \"full\" the bin will be after fitting\n    # Higher score for bins that will be more full (less normalized slack)\n    normalized_slack = remaining_after_fit / (eligible_bins_remain_cap + epsilon)\n    \n    # Invert normalized slack to prioritize smaller slack (higher score)\n    # Scale the score to a range below 1.0 to clearly differentiate from exact fits\n    # Using a range like [0.5, 0.99] provides good differentiation\n    non_exact_fit_priorities = 0.5 + (1.0 - normalized_slack) * 0.49\n\n    # Update priorities for bins that are not exact fits\n    non_exact_fit_indices_global = fit_indices[~exact_fit_mask_local]\n    priorities[non_exact_fit_indices_global] = non_exact_fit_priorities\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 41, in priority_v2\n    # This means bins with less remaining capacity before fitting the item.\nValueError: shape mismatch: value array of shape (4988,) could not be broadcast to indexing result of shape (4987,)\n2\n146.71880002307702\n"
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines exact fit prioritization with scaled normalized slack for non-exact fits,\n    and uses a tie-breaker based on initial bin capacity to favor fuller bins.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    # Mask for bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n        \n        # --- Primary objective: Exact Fit ---\n        # High priority for bins that perfectly fit the item.\n        exact_fit_mask = np.isclose(fitting_bins_remain_cap, item)\n        priorities[can_fit_mask][exact_fit_mask] = 1.0\n        \n        # --- Secondary objective: Scaled Normalized Slack ---\n        # For bins that can fit but are not exact fits.\n        non_exact_fit_mask = ~exact_fit_mask\n        \n        if np.any(non_exact_fit_mask):\n            eligible_bins_for_non_exact = fitting_bins_remain_cap[non_exact_fit_mask]\n            \n            # Calculate remaining capacity after placing the item\n            remaining_capacities_if_fit = eligible_bins_for_non_exact - item\n            \n            # Normalized slack: remaining capacity / original bin capacity. Smaller is better.\n            epsilon = 1e-9\n            normalized_slack = remaining_capacities_if_fit / (eligible_bins_for_non_exact + epsilon)\n            \n            # Priority: Higher score for smaller normalized slack (closer to 1.0).\n            # Scale these scores to be distinct from exact fits, e.g., between 0.5 and 0.99.\n            non_exact_priorities = 0.5 + 0.49 * (1.0 - normalized_slack)\n            \n            # --- Tertiary objective: Tie-breaking with initial bin fullness ---\n            # For bins with similar normalized slack, prefer those that were initially fuller.\n            # This means bins with less remaining capacity before fitting the item.\n            # We incorporate this by slightly adjusting priorities based on the original remaining capacity.\n            # A smaller original remaining capacity (i.e., a fuller bin) gets a slight boost.\n            # This boost is scaled to be less significant than normalized slack.\n            initial_capacities_for_non_exact = eligible_bins_for_non_exact\n            \n            # Add a small positive value for fuller bins.\n            # The term -initial_capacities_for_non_exact directly penalizes bins with large remaining capacity.\n            # By adding this term (which is negative), we effectively boost fuller bins.\n            # A small scale factor ensures it's a tie-breaker.\n            tie_breaker_scale = 0.001\n            priorities[can_fit_mask][non_exact_fit_mask] = non_exact_priorities + tie_breaker_scale * (-initial_capacities_for_non_exact)\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.487435181491823,
    "cyclomatic_complexity": 3.0,
    "halstead": 153.24725426256592,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Hybrid heuristic prioritizing exact fits, then Best Fit, and finally penalizing extreme slack.\n\n    This heuristic assigns the highest priority to exact fits. For non-exact fits,\n    it prioritizes bins with minimal remaining capacity (Best Fit) and applies a\n    penalty to bins that would leave disproportionately large residual capacity,\n    promoting more balanced bin utilization.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0, dtype=float)\n    \n    # Define a high score for exact fits to ensure they are prioritized.\n    exact_fit_score = 1e9\n    \n    # Define a penalty factor for large relative slack. This discourages packing\n    # into bins that would remain excessively empty compared to the item size.\n    slack_penalty_factor = 0.1\n    \n    # Epsilon to prevent division by zero or near-zero values.\n    epsilon = 1e-9\n\n    # Identify bins that can accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        fitting_bins_indices = np.where(can_fit_mask)[0]\n        \n        # Calculate the remaining capacity for bins that can fit the item.\n        remaining_capacities_if_fit = bins_remain_cap[fitting_bins_indices] - item\n        \n        # --- Scoring Logic ---\n        \n        # 1. Prioritize exact fits.\n        exact_fit_mask = np.abs(remaining_capacities_if_fit) < epsilon\n        \n        if np.any(exact_fit_mask):\n            priorities[fitting_bins_indices[exact_fit_mask]] = exact_fit_score\n            \n            # Filter out exact fits to process non-exact fits separately.\n            non_exact_fit_indices_in_fitting = np.where(~exact_fit_mask)[0]\n            \n            if non_exact_fit_indices_in_fitting.size > 0:\n                # Get the actual indices and remaining capacities for non-exact fits.\n                actual_non_exact_indices = fitting_bins_indices[non_exact_fit_indices_in_fitting]\n                non_exact_remaining_capacities = remaining_capacities_if_fit[non_exact_fit_indices_in_fitting]\n                \n                # 2. For non-exact fits, use Best Fit: higher score for smaller remaining capacity.\n                # Score is inversely proportional to the remaining capacity.\n                best_fit_scores = 1.0 / (non_exact_remaining_capacities + epsilon)\n                \n                # 3. Apply a penalty for large slack relative to item size.\n                # Calculate relative slack to penalize bins that become disproportionately empty.\n                # Use item size plus epsilon to avoid division by zero for small items.\n                relative_slack = non_exact_remaining_capacities / (item + epsilon)\n                \n                # The penalty reduces the score. A higher relative slack leads to a larger penalty.\n                penalty = slack_penalty_factor * relative_slack\n                \n                # Combine Best Fit score with the penalty.\n                combined_scores = best_fit_scores - penalty\n                \n                # Assign the combined scores to the priorities array.\n                priorities[actual_non_exact_indices] = combined_scores\n\n        else: # If no exact fits, process all fitting bins as non-exact fits.\n            # 2. For non-exact fits, use Best Fit: higher score for smaller remaining capacity.\n            best_fit_scores = 1.0 / (remaining_capacities_if_fit + epsilon)\n            \n            # 3. Apply a penalty for large slack relative to item size.\n            relative_slack = remaining_capacities_if_fit / (item + epsilon)\n            penalty = slack_penalty_factor * relative_slack\n            combined_scores = best_fit_scores - penalty\n            \n            priorities[fitting_bins_indices] = combined_scores\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 4.0,
    "halstead": 249.9824559469954,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Hybrid heuristic prioritizing exact fits and then using scaled inverse\n    remaining capacity for differentiation among near-fits, ensuring robustness.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if np.any(can_fit_mask):\n        fitting_bins_indices = np.where(can_fit_mask)[0]\n        remaining_capacities_if_fit = bins_remain_cap[can_fit_mask] - item\n        \n        epsilon = 1e-9\n        \n        # Assign a very high priority to exact fits (remaining capacity is zero)\n        exact_fit_mask = remaining_capacities_if_fit == 0\n        exact_fit_indices = fitting_bins_indices[exact_fit_mask]\n        priorities[exact_fit_indices] = 1.0  # High priority for exact fits\n        \n        # For non-exact fits, prioritize bins with the smallest remaining capacity\n        # using an inverse relationship for stronger differentiation of \"near-fits\".\n        non_exact_fit_mask = ~exact_fit_mask\n        non_exact_fitting_indices = fitting_bins_indices[non_exact_fit_mask]\n        \n        if non_exact_fitting_indices.size > 0:\n            remaining_for_non_exact = remaining_capacities_if_fit[non_exact_fit_mask]\n            \n            # Score is inversely proportional to remaining capacity,\n            # ensuring smaller remaining capacities get higher scores.\n            # Add epsilon for numerical stability.\n            scores_for_non_exact = 1.0 / (remaining_for_non_exact + epsilon)\n            \n            # Scale these scores to be less than the exact fit priority but still high.\n            # We map them to a range like [0.5, 0.99] (or similar lower range).\n            # Let's use a range slightly below the exact fit priority for clear hierarchy.\n            # A simple linear scaling can achieve this.\n            \n            # Find min and max of these new scores to normalize them into a desired range, e.g., [0.5, 0.99]\n            min_score = np.min(scores_for_non_exact)\n            max_score = np.max(scores_for_non_exact)\n            \n            if max_score - min_score > epsilon: # Avoid division by zero if all are same\n                scaled_scores = 0.5 + 0.49 * (scores_for_non_exact - min_score) / (max_score - min_score)\n            else: # If all remaining capacities are the same, assign a middle score\n                scaled_scores = 0.75 # Any value between 0.5 and 0.99 is fine\n            \n            priorities[non_exact_fitting_indices] = scaled_scores\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.198244914240141,
    "cyclomatic_complexity": 4.0,
    "halstead": 210.99629561116632,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Hybrid heuristic: Exact fit, then Best Fit with normalized slack penalty.\n    Prioritizes exact fits, then favors bins with minimal remaining capacity after fit,\n    penalizing bins that leave disproportionately large remaining space relative to item size.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0, dtype=float)\n    epsilon = 1e-9\n    exact_fit_score = 1e9  # High score for exact fits\n    slack_penalty_factor = 0.1  # Penalty for large relative slack\n\n    can_fit_mask = bins_remain_cap >= item\n\n    if np.any(can_fit_mask):\n        available_bins_indices = np.where(can_fit_mask)[0]\n        \n        # Calculate remaining capacity after fitting for potential bins\n        remaining_after_fit = bins_remain_cap[available_bins_indices] - item\n        \n        # --- Scoring Logic ---\n        \n        # 1. Prioritize exact fits (remaining_after_fit is close to zero)\n        exact_fit_indices_local = np.where(remaining_after_fit < epsilon)[0]\n        if exact_fit_indices_local.size > 0:\n            priorities[available_bins_indices[exact_fit_indices_local]] = exact_fit_score\n            \n            # Filter out exact fits for secondary scoring to maintain highest priority\n            non_exact_fit_local_indices = np.setdiff1d(np.arange(len(available_bins_indices)), exact_fit_indices_local)\n            \n            if non_exact_fit_local_indices.size == 0:\n                return priorities # All fitting bins were exact fits\n\n            available_bins_indices = available_bins_indices[non_exact_fit_local_indices]\n            remaining_after_fit = remaining_after_fit[non_exact_fit_local_indices]\n        \n        # 2. For non-exact fits, prioritize Best Fit (minimize remaining_after_fit)\n        # Score is negative remaining capacity, so smaller remaining capacity means higher score.\n        best_fit_scores = -remaining_after_fit\n        \n        # 3. Add a penalty for large slack relative to the item size.\n        # This discourages bins that remain too empty after packing.\n        # Relative slack = remaining_after_fit / item. Use item + epsilon for stability.\n        relative_slack = remaining_after_fit / (item + epsilon)\n        \n        # Combine Best Fit score with penalty. Subtract penalty to reduce score for high relative slack.\n        combined_scores = best_fit_scores - slack_penalty_factor * relative_slack\n        \n        priorities[available_bins_indices] = combined_scores\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 4.0,
    "halstead": 138.24238017775622,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines exact fit priority with scaled inverse normalized slack, using tunable parameters.\n    Prioritizes exact fits, then bins with minimal normalized slack for balanced packing.\n    \"\"\"\n    exact_fit_priority = 1.0\n    non_exact_fit_min_priority = 0.5\n    non_exact_fit_max_priority = 0.99\n    epsilon = 1e-9 # For numerical stability\n\n    priorities = np.full_like(bins_remain_cap, -1.0, dtype=float)\n    \n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    eligible_bins_indices = np.where(can_fit_mask)[0]\n    \n    if len(eligible_bins_indices) == 0:\n        return priorities # No bins can fit the item\n\n    eligible_bins_remain_cap = bins_remain_cap[eligible_bins_indices]\n    \n    # Prioritize exact fits\n    exact_fit_mask = np.isclose(eligible_bins_remain_cap, item, atol=epsilon)\n    priorities[eligible_bins_indices[exact_fit_mask]] = exact_fit_priority\n    \n    # Process non-exact fits\n    non_exact_fit_indices_in_eligible = np.where(~exact_fit_mask)[0]\n    \n    if len(non_exact_fit_indices_in_eligible) > 0:\n        non_exact_eligible_bins_remain_cap = eligible_bins_remain_cap[non_exact_fit_indices_in_eligible]\n        \n        # Calculate remaining capacity after placing the item\n        remaining_after_fit = non_exact_eligible_bins_remain_cap - item\n        \n        # Calculate normalized slack: (remaining_capacity_after_fit) / (current_bin_capacity)\n        # Smaller normalized slack is better (means the item fills more of the bin proportionally)\n        normalized_slack = remaining_after_fit / (non_exact_eligible_bins_remain_cap + epsilon)\n        \n        # Create priority scores for non-exact fits:\n        # We want smaller normalized_slack to result in higher scores.\n        # Use 1.0 - normalized_slack to invert the desirability.\n        # Scale these scores to be less than exact_fit_priority and within a defined range.\n        best_fit_scores = 1.0 - normalized_slack\n        \n        # Scale scores to the range [non_exact_fit_min_priority, non_exact_fit_max_priority]\n        # This maps normalized_slack=0 (best non-exact) to max_priority and normalized_slack=1 (worst non-exact) to min_priority.\n        scaled_priorities = non_exact_fit_min_priority + np.clip(best_fit_scores, 0.0, 1.0) * (non_exact_fit_max_priority - non_exact_fit_min_priority)\n        \n        # Ensure non-exact fit priorities are strictly less than exact_fit_priority\n        scaled_priorities = np.clip(scaled_priorities, non_exact_fit_min_priority, min(non_exact_fit_max_priority, exact_fit_priority - epsilon))\n        \n        priorities[eligible_bins_indices[non_exact_fit_indices_in_eligible]] = scaled_priorities\n        \n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 3.0,
    "halstead": 175.93083758004835,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Hybrid Best Fit with Differentiated Slack Prioritization.\n\n    Combines prioritizing exact fits with a strong preference for bins leaving minimal\n    absolute remaining capacity, enhanced by a penalty for large residual space.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities\n\n    eligible_bins_indices = np.where(can_fit_mask)[0]\n    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    remaining_after_fit = eligible_bins_remain_cap - item\n    \n    # High priority for exact fits (score = 1.0)\n    exact_fit_mask = remaining_after_fit == 0\n    priorities[eligible_bins_indices[exact_fit_mask]] = 1.0\n    \n    # For non-exact fits, prioritize minimal remaining capacity (Best Fit).\n    # Use a score inversely proportional to the remaining capacity.\n    # Add a small epsilon for numerical stability and to avoid division by zero.\n    non_exact_fit_mask = ~exact_fit_mask\n    \n    if np.any(non_exact_fit_mask):\n        non_exact_indices = eligible_bins_indices[non_exact_fit_mask]\n        non_exact_remaining = remaining_after_fit[non_exact_fit_mask]\n        \n        # Base score for best fit: higher for smaller remaining capacity.\n        # Using 1 / (slack + epsilon) prioritizes minimal absolute slack.\n        base_best_fit_scores = 1.0 / (non_exact_remaining + 1e-9)\n        \n        # Introduce a penalty for bins that remain too empty relative to the item size.\n        # This helps to avoid spreading items too thinly if possible.\n        # Calculate relative slack: slack / item size.\n        # A higher relative slack should result in a lower priority.\n        # We subtract a penalty proportional to this relative slack.\n        relative_slack = non_exact_remaining / (item + 1e-9)\n        \n        # Penalty factor: Adjust this to control how strongly large relative slack is penalized.\n        # A factor of 0.1 is a common starting point, similar to heuristic 7.\n        slack_penalty_factor = 0.1\n        slack_penalty = slack_penalty_factor * relative_slack\n        \n        # Combined score: Best Fit score minus slack penalty.\n        # We want to prioritize bins that are nearly full AND don't leave excessive slack.\n        final_scores = base_best_fit_scores - slack_penalty\n        \n        # Ensure scores for non-exact fits are less than the exact fit score (1.0)\n        # Also, ensure scores are not excessively negative. A minimum score can be set.\n        # For this heuristic, we aim for scores that are positive and differentiated.\n        # The base_best_fit_scores are typically > 1 (e.g., 1/(0.1) = 10).\n        # The slack penalty is typically < 1 (e.g., 0.1 * (0.1/0.5) = 0.02).\n        # So scores should remain high but differentiated.\n        \n        priorities[non_exact_indices] = final_scores\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.198244914240141,
    "cyclomatic_complexity": 3.0,
    "halstead": 153.24725426256592,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Hybrid heuristic: Exact fit, then best fit with normalized slack penalty.\n    Prioritizes exact fits, then minimal remaining capacity, penalizing large relative slack.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0, dtype=float)\n    epsilon = 1e-9\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities\n\n    eligible_bins_indices = np.where(can_fit_mask)[0]\n    \n    # High score for exact fits\n    exact_fit_score = 1e9\n    \n    # Score for non-exact fits: prioritize minimal remaining capacity (Best Fit)\n    # Use negative remaining capacity so higher value means less remaining space.\n    remaining_after_fit = bins_remain_cap[eligible_bins_indices] - item\n    best_fit_scores = -remaining_after_fit\n\n    # Penalty for large slack relative to item size.\n    # Encourage more balanced packing.\n    slack_penalty_factor = 0.1 \n    relative_slack = remaining_after_fit / (item + epsilon)\n    penalty = slack_penalty_factor * relative_slack\n\n    # Combine Best Fit score with penalty.\n    # Best Fit is primary (higher value for smaller remaining capacity),\n    # penalty reduces score for bins with high relative slack.\n    combined_scores = best_fit_scores - penalty\n\n    # Assign priorities\n    # Exact fits get the highest score\n    exact_fit_indices_mask = (remaining_after_fit < epsilon)\n    priorities[eligible_bins_indices[exact_fit_indices_mask]] = exact_fit_score\n    \n    # Non-exact fits get the combined score. Ensure they are lower than exact fits.\n    non_exact_fit_indices_mask = ~exact_fit_indices_mask\n    \n    # Ensure scores are always less than the exact fit score.\n    # Even the highest combined score should be less than exact_fit_score.\n    # The scaling of best_fit_scores is inherently negative, making them lower than exact_fit_score.\n    # The penalty further reduces these scores.\n    priorities[eligible_bins_indices[non_exact_fit_indices_mask]] = combined_scores[non_exact_fit_indices_mask]\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.32351694048162,
    "exec_success": true
  }
]