```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines exact fit, minimized residual capacity, and normalized slack for robust prioritization.
    Prioritizes exact fits (score 1.0), then bins with minimal remaining capacity after fit,
    using normalized slack as a tie-breaker.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        eligible_indices = np.where(can_fit_mask)[0]
        eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]
        
        remaining_after_fit = eligible_bins_remain_cap - item
        
        # Exact fit: highest priority
        exact_fit_mask = (remaining_after_fit == 0)
        priorities[eligible_indices[exact_fit_mask]] = 1.0
        
        # Non-exact fits
        non_exact_fit_mask = ~exact_fit_mask
        if np.any(non_exact_fit_mask):
            non_exact_indices = eligible_indices[non_exact_fit_mask]
            non_exact_remain_caps_after_fit = remaining_after_fit[non_exact_fit_mask]
            non_exact_current_caps = eligible_bins_remain_cap[non_exact_fit_mask]
            
            # Normalize remaining capacity after fit to rank non-exact fits.
            # Smaller remaining capacity gets higher priority.
            # Use a score that's inversely related to normalized remaining capacity.
            # This combines the "minimize residual" idea with normalization.
            epsilon = 1e-9
            # To avoid division by zero or very small numbers, and to make scores distinct
            # we can use a transformation that maps smaller values to larger scores.
            # A simple approach is to use the negative of the normalized remaining capacity
            # and scale it to be less than 1.0.
            
            # Let's try prioritizing bins that leave the *least* amount of space.
            # This is minimizing `remaining_after_fit`.
            # We want higher priority for smaller `remaining_after_fit`.
            
            # Using a score derived from inverse of remaining capacity after fit.
            # Higher score for smaller remaining capacity after fit.
            # Scale to differentiate from exact fits. A range like [0.5, 0.95] is good.
            
            # Normalize remaining capacity after fit to a [0, 1] range where 0 is best.
            max_remaining_after_fit = np.max(non_exact_remain_caps_after_fit)
            normalized_remaining_after_fit = non_exact_remain_caps_after_fit / (max_remaining_after_fit + epsilon)
            
            # Map normalized remaining capacity to a priority score.
            # 0 (best residual) -> ~0.95, 1 (worst residual) -> ~0.5
            best_fit_scores = 0.5 + (1.0 - normalized_remaining_after_fit) * 0.45
            
            priorities[non_exact_indices] = best_fit_scores

    return priorities
```
