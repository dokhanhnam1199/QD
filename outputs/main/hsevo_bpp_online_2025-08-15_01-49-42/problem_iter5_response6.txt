```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid heuristic: exact fit first, then best-fit by minimizing normalized slack.
    Prioritizes exact fits with a score of 1.0, then bins that minimize
    (remaining_capacity - item) / original_bin_capacity.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)
    
    # Mask for bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]
        eligible_indices = np.where(can_fit_mask)[0]

        # Exact fit: highest priority
        exact_fit_mask = (eligible_bins_remain_cap == item)
        if np.any(exact_fit_mask):
            priorities[eligible_indices[exact_fit_mask]] = 1.0
        
        # Best fit for non-exact fits: minimize normalized slack
        # Slack = remaining_capacity - item
        # Normalized slack = slack / current_bin_capacity
        # We want to MINIMIZE normalized slack, so HIGHER priority for smaller normalized slack.
        non_exact_fit_mask = (eligible_bins_remain_cap > item)
        
        if np.any(non_exact_fit_mask):
            non_exact_indices = eligible_indices[non_exact_fit_mask]
            non_exact_remain_caps = eligible_bins_remain_cap[non_exact_fit_mask]
            
            # To get original bin capacities, we'd need to know them.
            # Assuming the provided 'bins_remain_cap' are from a full set of bins,
            # and we don't have the original capacities here.
            # A practical proxy: use the current remaining capacity if it's not too small,
            # or a fixed large number for normalization if capacity is not available.
            # However, the prompt implies 'bins_remain_cap' IS the state.
            # Let's redefine based on common best-fit: minimize remaining capacity after packing.
            # This is a common "best-fit" interpretation.
            
            # If we strictly want "normalized slack" (slack / original_capacity),
            # we'd need original capacities. Without it, we fall back to minimizing slack.
            # The "Better code" example used negative slack. Let's refine that.
            
            # Strategy: Prioritize bins that leave the LEAST remaining capacity.
            # This is equivalent to maximizing -(remaining_capacity - item).
            # To avoid large negative numbers and ensure stable ranking, we can normalize.
            # Let's use the "Better code" logic as it's clean for Best Fit: minimize residual.
            
            # Let's take the 'priority_v0' approach of minimizing remaining capacity after fit
            # but ensure it's distinct from exact fit.
            
            # For non-exact fits, score based on how much capacity is left after fitting.
            # Lower remaining capacity after fitting = higher priority.
            remaining_after_fit = non_exact_remain_caps - item
            
            # To make scores distinct and avoid issues with very small residuals,
            # we can use a scaled inverse. A common approach is to subtract from a constant
            # or use a decreasing function.
            # Let's use a score that is inversely proportional to the residual capacity,
            # but scaled to be less than 1.0.
            # Example: 0.5 + 0.4 * (1 - normalized_residual)
            # Where normalized_residual = residual / max_residual
            
            if len(remaining_after_fit) > 0:
                max_remaining_after_fit = np.max(remaining_after_fit)
                # Normalize residuals to [0, 1], where 0 is best (min residual)
                # Add epsilon for stability if all residuals are same
                normalized_remaining = remaining_after_fit / (max_remaining_after_fit + 1e-9)
                
                # Scale to a range below 1.0, e.g., [0.5, 0.95].
                # This maps best-fit (normalized_remaining near 0) to ~0.95
                # and worst-fit (normalized_remaining near 1) to ~0.5.
                best_fit_scores = 0.5 + (1.0 - normalized_remaining) * 0.45
                
                priorities[non_exact_indices] = best_fit_scores

    return priorities
```
