```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit and Sigmoid Fit Score.
    Prioritizes bins that are closest to fitting the item (Best Fit)
    and uses a sigmoid to smooth prioritization among them.
    """
    priorities = np.zeros_like(bins_remain_cap)
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities
        
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # Best Fit component: Calculate difference for bins that can fit
    differences = fitting_bins_remain_cap - item
    
    # Sigmoid scaling for smoother prioritization among fitting bins
    # Normalize differences to a [0, 1] range for sigmoid input
    # Avoid division by zero if all fitting bins have the same remaining capacity
    max_diff = np.max(differences)
    min_diff = np.min(differences)
    
    if max_diff == min_diff:
        scaled_diffs = np.zeros_like(differences) # All fitting bins are equally "best"
    else:
        scaled_diffs = (differences - min_diff) / (max_diff - min_diff)
        
    # Sigmoid function to transform scaled differences into priorities
    # Steepness parameter (e.g., 5) can be tuned
    sigmoid_scores = 1 / (1 + np.exp(-5 * (1 - scaled_diffs))) # Invert so smaller diffs get higher scores
    
    priorities[can_fit_mask] = sigmoid_scores
    
    return priorities
```
