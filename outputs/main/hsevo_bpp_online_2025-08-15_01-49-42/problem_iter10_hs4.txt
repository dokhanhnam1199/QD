import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, exact_fit_priority: float = 0.7184305170450925, non_exact_fit_scale: float = -0.17561168598728483, epsilon: float = 8.014369019206948e-07) -> np.ndarray:
    """Combines exact fit preference with scaled inverse normalized slack for non-exact fits."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]
    eligible_bins_indices = np.where(can_fit_mask)[0]

    # Prioritize exact fits with a high score
    exact_fit_mask = np.isclose(eligible_bins_remain_cap, item)
    priorities[eligible_bins_indices[exact_fit_mask]] = exact_fit_priority

    # For non-exact fits, prioritize bins with smaller normalized slack
    non_exact_fit_mask = ~exact_fit_mask
    if np.any(non_exact_fit_mask):
        non_exact_eligible_bins_remain_cap = eligible_bins_remain_cap[non_exact_fit_mask]
        
        # Calculate remaining capacity after placing the item
        remaining_after_fit = non_exact_eligible_bins_remain_cap - item
        
        # Original capacities for the eligible non-exact fit bins
        original_capacities = bins_remain_cap[eligible_bins_indices[non_exact_fit_mask]]
        
        # Calculate normalized slack, ensuring stability with epsilon
        normalized_slack = remaining_after_fit / (original_capacities + epsilon)
        
        # Assign priorities as 1.0 minus normalized slack, scaled to be less than 1.0
        # This rewards smaller normalized slack with higher priority values closer to 1.0.
        priorities[eligible_bins_indices[non_exact_fit_mask]] = non_exact_fit_scale * (1.0 - normalized_slack)

    return priorities
