```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins by favoring exact fits, then minimizing normalized slack
    for remaining bins, ensuring stable and distinct rankings.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    if eligible_bins_remain_cap.size > 0:
        remaining_after_fit = eligible_bins_remain_cap - item
        
        # Prioritize exact fits with a high score (e.g., 1.0)
        exact_fit_mask = remaining_after_fit == 0
        priorities[can_fit_mask][exact_fit_mask] = 1.0
        
        # For non-exact fits, prioritize bins with minimal normalized slack
        non_exact_fit_mask = ~exact_fit_mask
        
        if np.any(non_exact_fit_mask):
            non_exact_bins_remaining = remaining_after_fit[non_exact_fit_mask]
            # Calculate normalized slack: (remaining_cap - item) / initial_bin_cap
            # Using original eligible_bins_remain_cap for normalization
            normalized_slack = non_exact_bins_remaining / eligible_bins_remain_cap[non_exact_fit_mask]
            
            # Score is 1 - normalized_slack: higher score for lower normalized slack.
            # Add a small epsilon to the denominator for stability in normalization,
            # though for non-zero capacities, it's less critical than inverse.
            # Scale the score to be less than 1.0, to clearly distinguish from exact fits.
            priorities[can_fit_mask][non_exact_fit_mask] = 0.5 + 0.5 * (1.0 - normalized_slack)
            
    return priorities
```
