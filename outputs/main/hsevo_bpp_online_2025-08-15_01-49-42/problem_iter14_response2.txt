```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes exact fits, then bins with minimal normalized slack,
    using a tiered scoring system with robust normalization.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    fit_indices = np.where(can_fit_mask)[0]

    if len(fit_indices) == 0:
        return priorities  # No bins can fit the item

    eligible_bins_remain_cap = bins_remain_cap[can_fit_mask]

    # Tier 1: Exact fits receive the highest priority
    exact_fit_mask_local = np.abs(eligible_bins_remain_cap - item) < epsilon
    exact_fit_indices_global = fit_indices[exact_fit_mask_local]
    priorities[exact_fit_indices_global] = 1.0

    # Tier 2: Non-exact fits, prioritizing those with minimal normalized slack
    # Calculate slack after fitting the item
    remaining_after_fit = eligible_bins_remain_cap - item

    # Normalize slack relative to the bin's original remaining capacity
    # This gives a measure of how "full" the bin will be after fitting
    # Higher score for bins that will be more full (less normalized slack)
    normalized_slack = remaining_after_fit / (eligible_bins_remain_cap + epsilon)
    
    # Invert normalized slack to prioritize smaller slack (higher score)
    # Scale the score to a range below 1.0 to clearly differentiate from exact fits
    # Using a range like [0.5, 0.99] provides good differentiation
    non_exact_fit_priorities = 0.5 + (1.0 - normalized_slack) * 0.49

    # Update priorities for bins that are not exact fits
    non_exact_fit_indices_global = fit_indices[~exact_fit_mask_local]
    priorities[non_exact_fit_indices_global] = non_exact_fit_priorities

    return priorities
```
