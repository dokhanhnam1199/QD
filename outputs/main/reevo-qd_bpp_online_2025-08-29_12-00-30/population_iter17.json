[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 0.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # First Fit: Prefer bins where the item fits exactly\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1.0\n\n    # Then, prefer bins where the item fits with the least remaining space\n    remaining_space = bins_remain_cap - item\n    valid_bins = remaining_space >= 0\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1.0 / (remaining_space[valid_bins] + 1e-6)  # Add a small epsilon to avoid division by zero\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities  # No bin can fit the item\n\n    # Calculate the remaining capacity after placing the item\n    remaining_after_placement = bins_remain_cap[valid_bins] - item\n\n    # Best Fit: Minimize the remaining capacity (most filled bin)\n    priorities[valid_bins] = -remaining_after_placement\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 31.699250014423125,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Worst Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n\n    priorities[valid_bins] = bins_remain_cap[valid_bins] - item\n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Exact fit has highest priority\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1000  # High priority for exact fit\n\n    # Next best fit has lower priority\n    best_fit_indices = np.where(bins_remain_cap >= item)[0]\n    if len(best_fit_indices) > 0:\n        priorities[best_fit_indices] = 1 / (bins_remain_cap[best_fit_indices] - item + 1e-6) #avoid division by zero\n\n    return priorities",
    "response_id": 4,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 70.32403072095333,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the distance between the item size and the remaining capacity of each bin.\n    distances = np.abs(bins_remain_cap - item)\n\n    # Avoid division by zero by adding a small constant to distances\n    distances = np.where(distances == 0, 1e-6, distances)\n\n    # Calculate the inverse distance (proximity fit).  Higher priority for bins closer in capacity.\n    priorities = 1.0 / distances\n\n    # Optional: You might want to cap the priority score to avoid extremely high values\n    # priorities = np.clip(priorities, 0, 100)\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure bins_remain_cap is a numpy array\n    bins_remain_cap = np.array(bins_remain_cap)\n\n    # Calculate fit score for each bin\n    fit_scores = item / bins_remain_cap\n\n    # Apply sigmoid function to the fit scores\n    # A larger item in a smaller bin gets a higher score. We will use a scale factor of 1.5 to sharpen the sigmoid.\n    priorities = 1 / (1 + np.exp(-1.5 * (fit_scores - 0.5)))\n\n    #Handle the cases where bin capacity is zero.\n    priorities[bins_remain_cap == 0] = 0\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 81.7492568250068,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate the \"greedy\" priority: how well the item fits in each bin\n    greedy_priorities = np.where(bins_remain_cap >= item, bins_remain_cap - item, -1)\n\n    # Epsilon-Greedy: With probability epsilon, choose a bin randomly\n    if np.random.rand() < epsilon:\n        # Assign random priorities\n        priorities = np.random.rand(n_bins)\n    else:\n        # Otherwise, use the greedy priorities\n        priorities = greedy_priorities\n\n    return priorities",
    "response_id": 8,
    "obj": 138.36258476266457,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 34.86917501586544,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin.  A higher fit score means the item\n    # fits better in the bin (less waste).\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n\n    # Apply Softmax to the fit scores to get probabilities.\n    # Add a small temperature parameter to control the sharpness of the distribution.\n    temperature = 1.0\n    exp_fit_scores = np.exp(fit_scores / temperature)\n    probabilities = exp_fit_scores / np.sum(exp_fit_scores)\n\n    # Handle the case where no bins can fit the item (all fit_scores are -inf).\n    if np.all(fit_scores == -np.inf):\n      probabilities = np.zeros_like(bins_remain_cap)\n    \n    return probabilities",
    "response_id": 9,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 70.30835464468075,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on Best Fit strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between item size and bin remaining capacity\n    diff = bins_remain_cap - item\n    # Assign priority: higher priority for bins with smaller difference (best fit)\n    # But only if the item can fit in the bin (diff >= 0)\n    priorities[diff >= 0] = diff[diff >= 0]\n    return priorities",
    "response_id": 11,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 23.264662506490403,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities  # No bin can fit the item\n\n    diffs = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (diffs + 1e-6)  # Adding a small value to avoid division by zero\n\n    return priorities",
    "response_id": 15,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate how much space will be left after placing the item in each bin\n    remaining_space = bins_remain_cap - item\n\n    # Give higher priority to bins where the remaining space is small\n    # i.e., bins that are almost full\n    priorities = 1.0 / (remaining_space + 1e-6)  # Adding a small value to avoid division by zero\n\n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.529325012980813,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Assign highest priority to bins where item exactly fits\n    exact_fit_mask = (bins_remain_cap == item)\n    priorities[exact_fit_mask] = 1.0\n\n    # If no exact fit, assign priority based on remaining capacity.\n    # More remaining capacity is less preferred, so we use the inverse.\n    remaining_capacities = bins_remain_cap[~exact_fit_mask]\n    if remaining_capacities.size > 0:\n      priorities[~exact_fit_mask] = 1.0 / (remaining_capacities + 1e-6) # Adding a small epsilon to avoid division by zero\n    \n    return priorities",
    "response_id": 14,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 60.91767875292166,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the fit score for each bin using a sigmoid function.\n    # The sigmoid function maps the ratio of item size to remaining capacity\n    # to a value between 0 and 1, where a higher value indicates a better fit.\n\n    # Avoid division by zero.\n    valid_bins = bins_remain_cap > 0\n    bins_remain_cap_safe = bins_remain_cap[valid_bins]\n    item_safe = item * np.ones_like(bins_remain_cap_safe) #avoid broadcasting issues\n    \n    fit_scores = 1 / (1 + np.exp(-5 * (item_safe / bins_remain_cap_safe - 0.5))) # Adjust parameters 5 and 0.5 as needed\n\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = fit_scores\n    \n    return priorities",
    "response_id": 16,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 99.40434618240934,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Random Fit strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the 'fitness' of each bin - how well the item fits\n    fitness = bins_remain_cap - item\n    \n    # Only consider bins where the item fits\n    valid_bins = fitness >= 0\n    \n    if np.sum(valid_bins) > 0:\n        # Assign random priorities within valid bins\n        priorities[valid_bins] = np.random.rand(np.sum(valid_bins))\n    \n    return priorities",
    "response_id": 17,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon=0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Probability of choosing a random bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate best fit priority\n    best_fit_priority = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + 1e-6), 0.0)\n\n    # Apply epsilon-greedy strategy\n    if np.random.rand() < epsilon:\n        # Choose a random bin with uniform probability\n        priorities = np.random.rand(len(bins_remain_cap))\n    else:\n        # Choose the bin with the best fit\n        priorities = best_fit_priority\n\n    return priorities",
    "response_id": 18,
    "obj": 4.058635819704831,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate fit scores: how well the item fits in each bin\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n\n    # Normalize fit scores using Softmax\n    exp_fit = np.exp(fit_scores)\n    sum_exp_fit = np.sum(exp_fit)\n    if sum_exp_fit == 0:\n        priorities = np.zeros_like(bins_remain_cap)\n    else:\n        priorities = exp_fit / sum_exp_fit\n\n    return priorities",
    "response_id": 19,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 38.03910001730775,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000  # High priority for exact fit\n\n    # Then, prioritize bins where the item fits with minimal remaining capacity\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        remaining_after_fit = bins_remain_cap[fits] - item\n        priorities[fits] = 1.0 / (remaining_after_fit + 1e-6) # Avoid division by zero\n\n    return priorities",
    "response_id": 20,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Best Fit strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between the item size and the remaining capacity of each bin.\n    # We want to minimize this difference, so a smaller difference means a higher priority.\n    diffs = bins_remain_cap - item\n\n    # Only consider bins that have enough capacity for the item.\n    valid_bins = diffs >= 0\n\n    if np.any(valid_bins):\n        # Calculate the minimum difference among the valid bins.\n        min_diff = np.min(diffs[valid_bins])\n\n        # Assign priority based on how close the remaining capacity is to the item size.\n        # Bins with smaller differences (closer fit) get higher priority.\n        priorities[valid_bins] = -diffs[valid_bins] + min_diff\n    else:\n        #If no bin has enough capacity, assign 0 priority.\n        pass\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 38.053747805010275,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Worst Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Worst Fit: prioritize bins with the most remaining capacity\n    priorities = bins_remain_cap - item\n    priorities[priorities < 0] = -np.inf  # Penalize bins that are too small\n    return priorities",
    "response_id": 22,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 24.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, remain_cap in enumerate(bins_remain_cap):\n        if item <= remain_cap:\n            priorities[i] = remain_cap - item\n    return priorities",
    "response_id": 23,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 12.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fitness of each bin based on how well the item fits.\n    # A higher fitness means the item fits better in that bin.\n    fitness = item / bins_remain_cap\n    fitness = np.where(bins_remain_cap == 0, 0, fitness)  # Avoid division by zero\n\n    # Apply Sigmoid function to the fitness scores to normalize them\n    # into a probability distribution.\n    # The Sigmoid function squashes the fitness values between 0 and 1.\n    # We use a scaling factor to adjust the steepness of the sigmoid curve.\n    # A larger scaling factor makes the sigmoid curve steeper.\n    scaling_factor = 10.0\n    sigmoid_scores = 1 / (1 + np.exp(-scaling_factor * (1 - fitness)))\n\n    # Return the sigmoid scores as the priority scores for each bin.\n    return sigmoid_scores",
    "response_id": 26,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 80.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the fitness of each bin: how well the item fits\n    fitness = bins_remain_cap - item\n    \n    # If the item doesn't fit in a bin, set its priority to 0\n    priorities = np.where(fitness >= 0, 1.0, 0.0)\n\n    # Give bins with smaller remaining capacity a slightly higher priority.\n    # This encourages filling up bins quickly to minimize the number of open bins.\n    \n    remaining_capacity_penalty = np.where(fitness > 0, 1.0 / (fitness + 1e-6), 0.0)\n    priorities += remaining_capacity_penalty\n    \n    #Randomize a bit to avoid always picking the first fit:\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.01\n\n    return priorities",
    "response_id": 27,
    "obj": 5.155564419625055,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 100.07820003461549,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Probability of exploration.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate the 'greedy' priority - the best fit\n    best_fit_bin = np.argmin(bins_remain_cap - item)\n    greedy_priority = 1.0 / (bins_remain_cap[best_fit_bin] - item + 1e-6) if bins_remain_cap[best_fit_bin] >= item else 0.0\n    \n    # Exploration phase - assign random priority to some bins with probability epsilon\n    for i in range(n_bins):\n        if np.random.rand() < epsilon and bins_remain_cap[i] >= item:\n            priorities[i] = np.random.rand()\n\n    # Exploitation phase - assign a priority based on fit to other bins\n    for i in range(n_bins):\n        if bins_remain_cap[i] >= item:\n             priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-6) # higher priority for better fit \n\n    \n    # If all priorities are zero due to item size or exploration, prioritize the best_fit_bin\n    if np.sum(priorities) == 0.0 and bins_remain_cap[best_fit_bin] >= item:\n        priorities[best_fit_bin] = 1.0\n    \n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 9.0,
    "halstead": 218.60914478074076,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Softmax-Based Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin: how much space is left after adding the item\n    fit_scores = np.maximum(0, bins_remain_cap - item)\n\n    # Use a softmax function to convert the fit scores into probabilities\n    # A temperature parameter is used to control the \"softness\" of the probabilities\n    temperature = 1.0  # Adjust as needed. Higher temp = more exploration.\n\n    # Apply softmax function\n    exp_fit_scores = np.exp(fit_scores / temperature)\n    priorities = exp_fit_scores / np.sum(exp_fit_scores)\n\n    return priorities",
    "response_id": 29,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities  # No bin can fit the item\n\n    diffs = bins_remain_cap[valid_bins] - item\n    # Combine inverse distance (proximity fit) with a fullness factor\n    fullness = 1 - (bins_remain_cap[valid_bins] / np.max(bins_remain_cap))\n    priorities[valid_bins] = (1.0 / (diffs + 1e-6)) * (1 + fullness)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap > 0\n    bins_remain_cap_safe = bins_remain_cap[valid_bins]\n    item_safe = item * np.ones_like(bins_remain_cap_safe)\n\n    # Sigmoid function with parameters adjusted for better scaling\n    fit_scores = 1 / (1 + np.exp(-8 * (item_safe / bins_remain_cap_safe - 0.6)))\n\n    # Incorporate bin fullness: prefer bins that are more full (up to a point)\n    fullness = 1 - (bins_remain_cap_safe / np.max(bins_remain_cap[valid_bins]))  # Normalize fullness\n    combined_scores = 0.7 * fit_scores + 0.3 * fullness  # Adjust weights as needed\n\n    priorities[valid_bins] = combined_scores\n    return priorities",
    "response_id": 3,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 182.67948703818894,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Probability of exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact fit: highest priority\n    exact_fit_mask = (bins_remain_cap == item)\n    priorities[exact_fit_mask] = 1.0\n\n    # Available bins (excluding those that are too small)\n    available_bins = bins_remain_cap[bins_remain_cap >= item]\n    available_bin_indices = np.where(bins_remain_cap >= item)[0]\n\n    if available_bins.size > 0:\n        # Greedy priority: inverse of remaining capacity\n        remaining_capacities = available_bins - item\n        greedy_priorities = 1.0 / (remaining_capacities + 1e-6)\n\n        # Exploration: random priority with probability epsilon\n        exploration_mask = np.random.rand(len(available_bin_indices)) < epsilon\n        exploration_priorities = np.random.rand(len(available_bin_indices))[exploration_mask]\n\n        # Combine greedy and exploration\n        combined_priorities = np.zeros_like(greedy_priorities)\n        combined_priorities[~exploration_mask] = greedy_priorities[~exploration_mask]\n        combined_priorities[exploration_mask] = exploration_priorities\n\n        # Assign combined priorities to the original array\n        priorities[available_bin_indices] = combined_priorities\n\n    return priorities",
    "response_id": 4,
    "obj": 4.208216992421225,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 121.01398665684616,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities  # No bin can fit the item\n\n    # Calculate the remaining capacity after placing the item\n    remaining_after_placement = bins_remain_cap[valid_bins] - item\n\n    # Prioritize bins minimizing wasted space (Best Fit Decreasing)\n    priorities[valid_bins] = -remaining_after_placement\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 31.699250014423125,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    # Avoid division by zero and handle bins with no capacity\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    # Calculate fit score, normalizing by item size and bin capacity\n    fit_scores = item / bins_remain_cap\n    fit_scores[~valid_bins] = 0  # Ensure invalid bins have 0 score\n\n    # Apply sigmoid function with a sharper slope\n    priorities = 1 / (1 + np.exp(-3 * (fit_scores - 0.5)))\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 105.41561814669026,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    remaining_space = bins_remain_cap - item\n    valid_bins = remaining_space >= 0\n    priorities[valid_bins] = 1.0 / (remaining_space[valid_bins] + 1e-6)\n    return priorities",
    "response_id": 7,
    "obj": 4.198244914240141,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 43.01955000865388,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a combination of exact fit and scaled fit score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize exact fits\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000.0\n\n    # Prioritize bins where the item fits with minimal remaining capacity\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        remaining_after_fit = bins_remain_cap[fits] - item\n        # Use a scaled fit score based on remaining capacity\n        priorities[fits] = 1.0 / (remaining_after_fit + 1e-6)  # Avoid division by zero\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Assign highest priority to bins where item exactly fits\n    exact_fit_mask = (bins_remain_cap == item)\n    priorities[exact_fit_mask] = 1.0\n\n    # If no exact fit, assign priority based on remaining capacity and item density\n    remaining_capacities = bins_remain_cap[~exact_fit_mask]\n    if remaining_capacities.size > 0:\n        # Calculate density (item size / bin remaining capacity)\n        densities = item / (remaining_capacities + 1e-6)\n        # Inverse density to prioritize bins where the item occupies a smaller proportion\n        priorities[~exact_fit_mask] = 1.0 / (densities + 1e-6)\n\n    return priorities",
    "response_id": 9,
    "obj": 34.942161946549675,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 88.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities  # No bin can fit the item\n\n    # Exact fit gets highest priority\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    if len(exact_fit_bins) > 0:\n        priorities[exact_fit_bins] = 1000  # Very high priority\n\n    # For other bins, use a combination of inverse remaining capacity and item density\n    remaining_after_placement = bins_remain_cap[valid_bins] - item\n    item_density = item  # Simply the item size\n    \n    # Sharpened sigmoid to favor nearly full bins. Avoid zero division.\n    priority_component = (bins_remain_cap[valid_bins] / item)\n    priority_component = 1 / (1 + np.exp(-5 * (priority_component - 1)))\n    \n    priorities[valid_bins] = priority_component\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.786597526924611,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 140.2304206377674,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities  # No bin can fit the item\n\n    # Exact fit gets highest priority\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    if len(exact_fit_bins) > 0:\n        priorities[exact_fit_bins] = 1000  # High priority for exact fits\n\n    # For other bins, use a combination of inverse remaining capacity and item density\n    remaining_after_placement = bins_remain_cap[valid_bins] - item\n    item_density = item / bins_remain_cap[valid_bins] #density of item w.r.t bin\n    \n    # Avoid division by zero\n    safe_item_density = np.where(item_density == 0, 0.0001, item_density)\n\n    # Sharpened sigmoid for nuanced fit, favoring nearly-full bins\n    sigmoid_factor = 1 / (1 + np.exp(-10 * (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]))\n\n    priorities[valid_bins] = (1 / (remaining_after_placement + 1e-6)) * safe_item_density * sigmoid_factor\n\n    return priorities",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 247.1753118485642,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    # Exact fit gets highest priority\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    if len(exact_fit_bins) > 0:\n        priorities[exact_fit_bins] = 1e9  # A very high priority\n\n    # For other bins, use a combination of inverse remaining capacity and item density\n    remaining_after_placement = bins_remain_cap[valid_bins] - item\n    item_density = item  # Simplify: item size is its density\n    \n    # Sharpened sigmoid for nuanced fit (avoiding zero division and favoring nearly-full bins)\n    priority_scores = (bins_remain_cap[valid_bins] / item)\n    priority_scores = 1 / (1 + np.exp(-5 * (priority_scores - 1)))\n\n    priorities[valid_bins] = priority_scores\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.786597526924611,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 140.2304206377674,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    # Exact fit gets highest priority\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    if len(exact_fit_bins) > 0:\n        priorities[exact_fit_bins] = 1e9  # A very high priority\n\n    # For other bins, use a combination of inverse remaining capacity and item density\n    remaining_after_placement = bins_remain_cap[valid_bins] - item\n    item_density = item  # Density is just the item size in this context\n\n    # Avoid division by zero\n    safe_remaining_after_placement = np.where(remaining_after_placement > 0, remaining_after_placement, 1e-6)\n\n    # Sharpened sigmoid to favor nearly-full bins. A higher value indicates higher priority\n    sigmoid_values = 1 / (1 + np.exp(-10 * (bins_remain_cap[valid_bins] - item) / item))\n\n    # Combine priority scores\n    priorities[valid_bins] = sigmoid_values\n\n    return priorities",
    "response_id": 3,
    "obj": 7.7881930594336,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 155.88872502451935,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact fit has highest priority\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1000.0\n\n    # Next best fit has lower priority\n    best_fit_indices = np.where(bins_remain_cap >= item)[0]\n    if len(best_fit_indices) > 0:\n        priorities[best_fit_indices] = 1.0 / (bins_remain_cap[best_fit_indices] - item + 1e-6)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 70.32403072095333,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    fitness = bins_remain_cap - item\n    valid_bins = fitness >= 0\n\n    if np.sum(valid_bins) > 0:\n        # Assign random priorities within valid bins, scaled by how well the item fits\n        priorities[valid_bins] = fitness[valid_bins] + np.random.rand(np.sum(valid_bins)) * 0.1\n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    diffs = bins_remain_cap[valid_bins] - item\n    remaining_capacity_score = np.log(bins_remain_cap[valid_bins] + 1e-6) #prioritize bins with more remaining capacity.\n    fit_score = -diffs #smaller diffs are better.\n    \n    priorities[valid_bins] = remaining_capacity_score + fit_score\n\n    return priorities",
    "response_id": 3,
    "obj": 3.9988033506182825,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 60.91767875292166,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a combination of exact fit,\n    scaled fit score, and a bonus for nearly full bins.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Prioritize exact fits\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000.0\n\n    # Prioritize bins where the item fits with minimal remaining capacity\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        remaining_after_fit = bins_remain_cap[fits] - item\n        priorities[fits] = 1.0 / (remaining_after_fit + 1e-6)\n\n    # Bonus for nearly full bins (encourages filling bins completely)\n    nearly_full = (bins_remain_cap > 0) & (bins_remain_cap < item * 2) # bins that can fit the item are considered\n    priorities[nearly_full] += 0.5 # add a bonus\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 135.7068586817104,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    # Calculate fit score, normalizing by item size and bin capacity\n    fit_scores = item / bins_remain_cap\n    fit_scores[~valid_bins] = 0  # Ensure invalid bins have 0 score\n\n    # Apply sigmoid function with a tunable steepness parameter\n    steepness = 5  # Adjust for sharper/flatter slope\n    priorities = 1 / (1 + np.exp(-steepness * (fit_scores - 0.5)))\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 105.41561814669026,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a weighted combination of Inverse Distance and Fill Ratio.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Inverse Distance (proximity fit)\n    distances = np.abs(bins_remain_cap - item)\n    distances = np.where(distances == 0, 1e-6, distances)\n    inverse_distance = 1.0 / distances\n\n    # Fill Ratio (encourages using bins that are already partially full)\n    fill_ratio = bins_remain_cap / 1.0  # Assuming bin capacity is 1.0; adjust if needed\n\n    # Weighted combination (adjust weights as needed)\n    priority = 0.7 * inverse_distance + 0.3 * fill_ratio\n\n    return priority",
    "response_id": 8,
    "obj": 86.58755484643,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 84.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure bins_remain_cap is a numpy array\n    bins_remain_cap = np.array(bins_remain_cap)\n\n    # Calculate fit score for each bin, handling zero capacity\n    fit_scores = np.where(bins_remain_cap > 0, item / bins_remain_cap, 0)\n\n    # Apply sigmoid function to the fit scores. Adjust the scale and shift for better performance.\n    # Larger item in smaller bin => higher score.\n    priorities = 1 / (1 + np.exp(-2.0 * (fit_scores - 0.6)))\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 81.7492568250068,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    diffs = bins_remain_cap[valid_bins] - item\n    \n    # Exact fit gets highest priority\n    exact_fit_bins = np.isclose(diffs, 0)\n    if np.any(exact_fit_bins):\n        priorities[valid_bins][exact_fit_bins] = 1000  # High priority for exact fits\n\n    remaining_capacity_score = np.log(bins_remain_cap[valid_bins] + 1e-6)\n    item_density = item #item / some_constant # No need of some constant, item size itself can be used to represent density\n    \n    density_score = np.exp(- (bins_remain_cap[valid_bins] / item_density)**2)\n    \n    fit_score = -diffs \n\n    priorities[valid_bins] = remaining_capacity_score + fit_score + density_score\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.028719585161557,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 122.13617281353935,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    # Calculate fill ratio (item size / bin remaining capacity)\n    fill_ratio = item / bins_remain_cap\n    fill_ratio[~valid_bins] = 0  # Set invalid bins to 0\n\n    # Apply sigmoid function to prioritize bins closer to full, but not overfull\n    steepness = 7  # Adjust for sharper/flatter slope\n    midpoint = 0.5 # Adjust to shift the sigmoid curve\n    priorities = 1 / (1 + np.exp(-steepness * (fill_ratio - midpoint)))\n\n    # Boost priority for exact fits\n    exact_fit_bins = np.where(np.isclose(bins_remain_cap, item))[0]\n    if len(exact_fit_bins) > 0:\n        priorities[exact_fit_bins] *= 10  # Increase priority significantly\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 139.31568569324173,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = np.abs(bins_remain_cap[valid_bins] - item)\n    distances = np.where(distances == 0, 1e-7, distances)\n    inverse_distance = 1.0 / distances\n\n    fullness = 1.0 - (bins_remain_cap[valid_bins] / np.max(bins_remain_cap))\n    fullness_score = np.abs(fullness - 0.5)\n    fullness_score = np.where(fullness_score == 0, 1e-7, fullness_score)\n    fullness_priority = 1.0 / fullness_score\n\n    # Combine proximity fit and bin fullness\n    priorities[valid_bins] = 0.8 * inverse_distance + 0.2 * fullness_priority\n\n    return priorities",
    "response_id": 8,
    "obj": 3.669724770642197,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 178.61670928936152,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1, decay_rate: float = 0.99) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Epsilon-Greedy with dynamic epsilon.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Initial probability of choosing a random bin.\n        decay_rate: Rate at which epsilon decays.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate best fit priority\n    best_fit_priority = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + 1e-6), 0.0)\n\n    # Apply epsilon-greedy strategy\n    if np.random.rand() < epsilon:\n        # Choose a random bin with uniform probability\n        priorities = np.random.rand(len(bins_remain_cap))\n    else:\n        # Choose the bin with the best fit\n        priorities = best_fit_priority\n\n    # Decay epsilon for the next item\n    epsilon = max(0.01, epsilon * decay_rate)  # Ensure epsilon doesn't become too small\n\n    return priorities",
    "response_id": 3,
    "obj": 4.1284403669724865,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 70.32403072095333,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities  # No bin can fit the item\n    diffs = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (diffs + 1e-6)  # Inverse of wasted space\n    return priorities",
    "response_id": 4,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response5.txt_stdout.txt",
    "code_path": "problem_iter6_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities  # No bin can fit the item\n\n    # Calculate the remaining capacity after placing the item\n    remaining_after_placement = bins_remain_cap[valid_bins] - item\n\n    # Prioritize bins that leave the least amount of empty space\n    priorities[valid_bins] = 1.0 / (remaining_after_placement + 1e-6)\n\n    return priorities",
    "response_id": 5,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response7.txt_stdout.txt",
    "code_path": "problem_iter6_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Prioritize bins where the item fits exactly\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000  # High priority for exact fit\n\n    # Then, prioritize bins where the item fits with minimal remaining capacity\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        remaining_after_fit = bins_remain_cap[fits] - item\n        # Calculate inverse distance to prioritize tightest fits\n        distances = np.abs(remaining_after_fit)\n        distances = np.where(distances == 0, 1e-6, distances)  # Avoid division by zero\n        priorities[fits] = 1.0 / distances\n\n    return priorities",
    "response_id": 7,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 49.82892142331044,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response9.txt_stdout.txt",
    "code_path": "problem_iter6_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate the difference between the item size and the remaining capacity of each bin.\n    diffs = bins_remain_cap - item\n\n    # Only consider bins that have enough capacity for the item.\n    valid_bins = diffs >= 0\n\n    if np.any(valid_bins):\n        # Calculate the minimum difference among the valid bins.\n        min_diff = np.min(diffs[valid_bins])\n\n        # Assign priority based on how close the remaining capacity is to the item size.\n        # Bins with smaller differences (closer fit) get higher priority.\n        # Add a small bonus for bins that are more full (smaller remain_cap)\n        priorities[valid_bins] = -diffs[valid_bins] + min_diff + (1 / (bins_remain_cap[valid_bins] + 1e-6))\n    else:\n        # If no bin has enough capacity, assign a small negative priority to all bins\n        # to discourage using them. This helps prevent getting stuck.\n        priorities[:] = -1\n\n    return priorities",
    "response_id": 9,
    "obj": 4.108496210610296,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 91.73835003173087,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = np.abs(bins_remain_cap[valid_bins] - item)\n    distances = np.where(distances == 0, 1e-9, distances)\n    inverse_distance = 1.0 / distances\n\n    fullness = 1.0 - (bins_remain_cap[valid_bins] / np.max(bins_remain_cap))\n    fullness_score = np.abs(fullness - 0.5)\n    fullness_score = np.where(fullness_score == 0, 1e-9, fullness_score)\n    fullness_priority = 1.0 / fullness_score\n\n    # Combine with a small exploration factor\n    epsilon = 0.05  # Exploration rate\n    exploration_bonus = np.random.rand(len(valid_bins)) * epsilon\n    \n    priorities[valid_bins] = 0.6 * inverse_distance + 0.3 * fullness_priority + 0.1 * exploration_bonus\n\n    return priorities",
    "response_id": 0,
    "obj": 3.8292780215396984,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 235.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    # Calculate the 'tightness' of fit - how close the item is to filling the bin.\n    fit_score = 1.0 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n    fit_score = np.where(bins_remain_cap[valid_bins] == 0, 0, fit_score) # Avoid division by zero\n\n    # Prioritize bins that are somewhat full, but not completely full.\n    fullness = 1.0 - (bins_remain_cap[valid_bins] / np.max(bins_remain_cap))\n    fullness_score = np.abs(fullness - 0.5)\n    fullness_score = np.where(fullness_score == 0, 1e-9, fullness_score)  # Prevent division by zero\n    fullness_priority = 1.0 / fullness_score\n\n    # Add a small amount of randomness for exploration.\n    epsilon = 0.05\n    exploration_bonus = np.random.rand(len(valid_bins)) * epsilon\n\n    # Combine the scores.  Fit is most important, then fullness, then exploration.\n    priorities[valid_bins] = 0.6 * fit_score + 0.3 * fullness_priority + 0.1 * exploration_bonus\n\n    return priorities",
    "response_id": 2,
    "obj": 10.700039888312721,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 256.46415084724833,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Prioritize exact fits with very high priority\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000.0\n\n    # For bins where the item fits, calculate a sigmoid-based fit score\n    fits = bins_remain_cap >= item\n    fits = np.logical_and(fits, ~exact_fit)  # Exclude exact fits already prioritized\n\n    if np.any(fits):\n        fit_scores = item / bins_remain_cap[fits]\n        # Use a scale factor to sharpen the sigmoid\n        priorities[fits] = 1.0 / (1 + np.exp(-1.5 * (fit_scores - 0.5)))\n\n    return priorities",
    "response_id": 3,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 108.04820237218406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response5.txt_stdout.txt",
    "code_path": "problem_iter12_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, combining best fit, a bonus for nearly full bins,\n    an exploration bonus, and a consideration of the item's relative size.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize exact fits\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000.0\n\n    # Prioritize bins where the item fits with minimal remaining capacity (Best Fit)\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        remaining_after_fit = bins_remain_cap[fits] - item\n        priorities[fits] = 1.0 / (remaining_after_fit + 1e-6)\n\n    # Bonus for nearly full bins (encourages filling bins completely)\n    nearly_full = (bins_remain_cap > 0) & (bins_remain_cap < item * 2)\n    priorities[nearly_full] += 0.5\n\n    # Add a small exploration bonus to bins with some remaining capacity\n    # to avoid getting stuck in local optima.\n    available_bins = bins_remain_cap > 0\n    priorities[available_bins] += 0.1 * np.random.rand(len(bins_remain_cap))[available_bins]\n\n    # Item size consideration: smaller items get a slightly larger exploration bonus\n    if item < 0.2:  # Assuming bins have capacity 1.0\n        priorities[available_bins] += 0.2 * np.random.rand(len(bins_remain_cap))[available_bins]\n\n    return priorities",
    "response_id": 5,
    "obj": 3.7794176306342333,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 237.80142289857002,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using First Fit Decreasing (FFD) inspired priority.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Assign priority based on how well the item fits into each bin.\n    # Higher priority to bins where item fits exactly or with minimal waste.\n    valid_bins = bins_remain_cap >= item\n    priorities[valid_bins] = 1.0 / (bins_remain_cap[valid_bins] - item + 1e-6)\n    return priorities",
    "response_id": 7,
    "obj": 4.198244914240141,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    diffs = bins_remain_cap - item\n    valid_bins = diffs >= 0\n\n    if np.any(valid_bins):\n        # Prioritize bins with the smallest difference (best fit)\n        fit_priority = -diffs[valid_bins]\n\n        # Add a bonus for bins that are more full (smaller remaining capacity)\n        fullness_priority = 1 / (bins_remain_cap[valid_bins] + 1e-6)\n\n        # Add a small penalty for bins with very large remaining capacity\n        # to encourage using more full bins first\n        # Large capacity bins will have a smaller fullness_priority\n\n        # Combine fit and fullness priorities\n        priorities[valid_bins] = fit_priority + fullness_priority\n    else:\n        # If no bin has enough capacity, assign a small negative priority to all bins\n        # to discourage using them. This helps prevent getting stuck.\n        priorities[:] = -1\n\n    return priorities",
    "response_id": 9,
    "obj": 4.11846828879138,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 76.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response3.txt_stdout.txt",
    "code_path": "problem_iter9_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = np.abs(bins_remain_cap[valid_bins] - item)\n    distances = np.where(distances == 0, 1e-6, distances)\n    inverse_distance = 1.0 / (distances + 1e-6)  # Add small value to avoid division by zero\n\n    fullness = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n    fullness_score = np.log(1.0 + 1.0 / (1.0 - fullness))  # Log-scaled fullness\n    \n    # Blend best-fit exploitation with decaying randomness\n    randomness = np.random.rand(len(valid_bins)) * 0.1  # Controlled randomness\n    \n    priorities[valid_bins] = 0.6 * inverse_distance + 0.4 * fullness_score + randomness\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.11846828879138,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 217.98463765702255,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = bins_remain_cap[valid_bins] - item\n    exact_fit = (distances == 0).astype(float) * 10  # High priority for exact fits\n\n    distances = np.abs(distances)\n    distances = np.where(distances == 0, 1e-6, distances)  # Avoid division by zero\n    inverse_distance = 1.0 / distances\n\n    fullness = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n    fullness_score = np.abs(fullness - 0.7)  # Prefer bins around 70% full\n    fullness_score = np.where(fullness_score == 0, 1e-6, fullness_score)\n    fullness_priority = 1.0 / fullness_score\n\n    # Add a decaying random factor for exploration\n    randomness = np.random.rand(len(valid_bins)) * (0.1 / (len(bins_remain_cap) + 1))  # Decay randomness\n\n    priorities[valid_bins] = (0.5 * inverse_distance + 0.3 * fullness_priority + exact_fit + randomness)\n    return priorities",
    "response_id": 0,
    "obj": 3.131232548863192,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 289.5158000807695,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response2.txt_stdout.txt",
    "code_path": "problem_iter10_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = bins_remain_cap[valid_bins] - item\n    exact_fit = (distances == 0)\n    fit_score = np.zeros_like(bins_remain_cap[valid_bins])\n    fit_score[exact_fit] = 10.0  # High priority for exact fit\n    remaining_capacity = bins_remain_cap[valid_bins]\n    fullness = 1.0 - (remaining_capacity / np.max(bins_remain_cap))\n    fullness_score = np.abs(fullness - 0.5)\n    fullness_score = np.where(fullness_score == 0, 1e-6, fullness_score)\n    fullness_priority = 1.0 / fullness_score  # Higher priority for bins closer to 50% full\n\n    # Blend fit score and fullness priorities\n    priorities[valid_bins] = 0.7 * fit_score + 0.3 * fullness_priority\n\n    # Add a small amount of randomness for exploration\n    noise = np.random.rand(len(bins_remain_cap)) * 0.05\n    priorities = priorities + noise\n\n    return priorities",
    "response_id": 2,
    "obj": 4.028719585161557,
    "SLOC": 18.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 201.18251441994926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response4.txt_stdout.txt",
    "code_path": "problem_iter9_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = bins_remain_cap[valid_bins] - item\n    exact_fit_bonus = np.where(np.abs(distances) < 1e-6, 10.0, 0.0)  # Huge bonus for exact fit\n\n    # Log-scaled fullness: prioritize bins closer to full\n    fullness = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n    fullness_score = np.log(1.0 / (1.0 - fullness + 1e-9)) # Avoid log(0)\n\n    # Best-fit exploitation: inverse of remaining space\n    inverse_distance = 1.0 / (distances + 1e-9)\n\n    # Blend exploitation (best fit) and fullness, with a touch of randomness\n    priorities[valid_bins] = 0.6 * inverse_distance + 0.4 * fullness_score + exact_fit_bonus\n\n    return priorities",
    "response_id": 4,
    "obj": 86.58755484643,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 201.18251441994926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response1.txt_stdout.txt",
    "code_path": "problem_iter10_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    diffs = bins_remain_cap - item\n    valid_bins = diffs >= 0\n\n    if np.any(valid_bins):\n        # Calculate how much space is left after adding the item\n        remaining_space = diffs[valid_bins]\n\n        # Encourage fitting into nearly full bins\n        fullness_bonus = 1.0 / (bins_remain_cap[valid_bins] + 1e-6)\n\n        # Prefer bins with the smallest remaining space (best fit)\n        fit_priority = -remaining_space\n\n        # Combine fit and fullness\n        priorities[valid_bins] = fit_priority + fullness_bonus\n\n    else:\n        # If no bin can fit the item, assign a very low priority\n        priorities[:] = -10  # A significantly negative value\n\n    return priorities",
    "response_id": 1,
    "obj": 4.11846828879138,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 77.66179398375645,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response4.txt_stdout.txt",
    "code_path": "problem_iter10_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    valid_bins = bins_remain_cap > 0\n\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    # Calculate fit score, normalizing by item size and bin capacity\n    fit_scores = item / bins_remain_cap\n    fit_scores[~valid_bins] = 0  # Ensure invalid bins have 0 score\n\n    # Apply a modified sigmoid function with a tunable steepness parameter\n    steepness = 7  # Adjust for sharper/flatter slope\n    priorities = 1 / (1 + np.exp(-steepness * (1 - fit_scores)))\n\n    # Boost bins that are nearly full to discourage fragmentation.\n    nearly_full_boost = 0.1  # Adjust boost value as needed\n    fullness = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    priorities[valid_bins] += nearly_full_boost * fullness[valid_bins]\n\n    return priorities",
    "response_id": 4,
    "obj": 54.85640207419228,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 169.21582985307933,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response5.txt_stdout.txt",
    "code_path": "problem_iter10_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    diffs = bins_remain_cap - item\n    valid_bins = diffs >= 0\n\n    if np.any(valid_bins):\n        # Prioritize bins with the smallest difference (best fit)\n        fit_priority = -diffs[valid_bins]\n\n        # Add a bonus for bins that are more full (smaller remaining capacity)\n        fullness_priority = 1 / (bins_remain_cap[valid_bins] + 1e-6)\n\n        # Penalize nearly-empty bins\n        empty_penalty = np.exp(-bins_remain_cap[valid_bins] / (np.max(bins_remain_cap) + 1e-6))\n\n        # Combine fit and fullness priorities\n        priorities[valid_bins] = fit_priority + fullness_priority - 0.1 * empty_penalty\n    else:\n        # If no bin has enough capacity, assign a small negative priority to all bins\n        # to discourage using them. This helps prevent getting stuck.\n        priorities[:] = -1\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 153.24725426256592,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response8.txt_stdout.txt",
    "code_path": "problem_iter10_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Prioritize exact fits with very high priority\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000.0\n\n    # For bins where the item fits, calculate a fit score\n    fits = bins_remain_cap >= item\n    fits = np.logical_and(fits, ~exact_fit)  # Exclude exact fits already prioritized\n\n    if np.any(fits):\n        # Calculate remaining capacity after placing the item\n        remaining_after_item = bins_remain_cap[fits] - item\n\n        # Calculate a score based on how well the item utilizes the bin\n        utilization = item / bins_remain_cap[fits]\n\n        # Add a small value to avoid division by zero and improve stability\n        remaining_after_item = np.where(remaining_after_item <= 0, 1e-6, remaining_after_item)\n\n        # Combine utilization and remaining capacity to prioritize bins\n        # where the item fits well and leaves a reasonable amount of space\n        fit_scores = utilization - (1 - (remaining_after_item / bins_remain_cap[fits]))\n        fit_scores = np.clip(fit_scores, 0, 1)  # Ensure scores are between 0 and 1\n\n        # Use a sigmoid-like function to create a non-linear priority\n        priorities[fits] = np.exp(5 * fit_scores)\n\n    return priorities",
    "response_id": 8,
    "obj": 4.198244914240141,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 127.37720526058406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = bins_remain_cap[valid_bins] - item\n    exact_fit = (distances == 0).astype(float) * 20  # Higher priority for exact fits\n    distances = np.abs(distances)\n    distances = np.where(distances == 0, 1e-6, distances)\n    inverse_distance = 1.0 / distances\n    fullness = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n    fullness_score = np.abs(fullness - 0.7)  # Prefer bins around 70% full\n    fullness_score = np.where(fullness_score == 0, 1e-6, fullness_score)\n    fullness_priority = 1.0 / fullness_score\n\n    # Add a bonus for bins that aren't empty\n    bin_is_empty = bins_remain_cap == np.max(bins_remain_cap)\n    empty_bin_bonus = np.where(bin_is_empty[valid_bins], 0.0, 5.0)\n\n    # Combine with some randomness for exploration, decaying over time\n    randomness = np.random.rand(len(valid_bins)) * 0.05  # Reduced random factor\n\n    priorities[valid_bins] = (0.4 * inverse_distance + 0.3 * fullness_priority + exact_fit + empty_bin_bonus + randomness)\n    return priorities",
    "response_id": 0,
    "obj": 3.520143597925803,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 289.5158000807695,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = bins_remain_cap[valid_bins] - item\n    exact_fit = (distances == 0).astype(float) * 20  # High priority for exact fits\n    distances = np.abs(distances)\n    distances = np.where(distances == 0, 1e-6, distances)\n    inverse_distance = 1.0 / distances\n    fullness = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n    fullness_score = np.abs(fullness - 0.7)  # Prefer bins around 70% full\n    fullness_score = np.where(fullness_score == 0, 1e-6, fullness_score)\n    fullness_priority = 1.0 / fullness_score\n\n    # Add bonus for non-empty bins\n    non_empty_bonus = (bins_remain_cap[valid_bins] < np.max(bins_remain_cap)).astype(float) * 5\n\n    # Combine with some randomness for exploration\n    randomness = np.random.rand(len(valid_bins)) * 0.05  # Reduced random factor\n\n    priorities[valid_bins] = (0.4 * inverse_distance + 0.3 * fullness_priority + exact_fit + non_empty_bonus + randomness)\n    return priorities",
    "response_id": 4,
    "obj": 3.560031910650184,
    "SLOC": 18.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 313.9937575983544,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = bins_remain_cap[valid_bins] - item\n    exact_fit_bonus = np.where(np.abs(distances) < 1e-6, 10.0, 0.0)\n\n    inverse_distance = 1.0 / (np.abs(distances) + 1e-6)\n    fullness = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n    fullness_score = np.log(1.0 + 1.0 / (1.0 - fullness + 1e-9))\n\n    randomness = np.random.rand(len(valid_bins)) * 0.05  # Reduced randomness\n\n    priorities[valid_bins] = 0.7 * inverse_distance + 0.2 * fullness_score + 0.1 * randomness + exact_fit_bonus\n    return priorities",
    "response_id": 1,
    "obj": 86.58755484643,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 276.1010283783344,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response6.txt_stdout.txt",
    "code_path": "problem_iter12_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_usage_history: np.ndarray = None, future_item_sizes: np.ndarray = None) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, considering fit, usage, and future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_usage_history: Array tracking the number of items placed in each bin (optional).\n        future_item_sizes: Array of sizes of future items (optional).\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    diffs = bins_remain_cap - item\n    valid_bins = diffs >= 0\n\n    if np.any(valid_bins):\n        min_diff = np.min(diffs[valid_bins])\n        \n        # Prioritize tighter fits\n        fit_priority = -diffs[valid_bins] + min_diff\n\n        # Incorporate bin usage history (encourage spreading items across bins)\n        usage_priority = np.zeros_like(bins_remain_cap)\n        if bin_usage_history is not None:\n            usage_priority = 1.0 / (bin_usage_history + 1e-6)  # Bins with fewer items get higher priority\n            usage_priority = usage_priority[valid_bins]\n        \n        # Incorporate future item sizes (attempt to leave space for larger future items)\n        future_priority = np.zeros_like(bins_remain_cap)\n        if future_item_sizes is not None:\n            avg_future_size = np.mean(future_item_sizes) if len(future_item_sizes) > 0 else 0\n            future_priority = (bins_remain_cap - avg_future_size) / (bins_remain_cap + 1e-6)\n            future_priority = future_priority[valid_bins]\n\n        # Combine priorities (weighted sum)\n        priorities[valid_bins] = 0.7 * fit_priority + 0.2 * usage_priority + 0.1 * future_priority\n    \n    return priorities",
    "response_id": 6,
    "obj": 4.108496210610296,
    "SLOC": 18.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 256.46415084724833,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = np.abs(bins_remain_cap[valid_bins] - item)\n    distances = np.where(distances == 0, 1e-9, distances)\n    inverse_distance = 1.0 / distances\n\n    fullness = 1.0 - (bins_remain_cap[valid_bins] / np.max(bins_remain_cap))\n    fullness_score = np.abs(fullness - 0.5)\n    fullness_score = np.where(fullness_score == 0, 1e-9, fullness_score)\n    fullness_priority = 1.0 / fullness_score\n\n    # Encourage filling bins to around 50% to avoid fragmentation, then prioritize almost full bins\n    target_fullness = 0.5\n    fullness_diff = np.abs(fullness - target_fullness)\n    fullness_priority = np.where(fullness > 0.9, 10.0, 1.0 / (fullness_diff + 1e-9))\n\n\n    # Combine with a small exploration factor\n    epsilon = 0.05  # Exploration rate\n    exploration_bonus = np.random.rand(len(valid_bins)) * epsilon\n\n    priorities[valid_bins] = 0.5 * inverse_distance + 0.4 * fullness_priority + 0.1 * exploration_bonus\n\n    return priorities",
    "response_id": 0,
    "obj": 3.8292780215396984,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 307.35774857210805,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin using a sigmoid function.\n    # The sigmoid function maps the ratio of item size to remaining capacity\n    # to a value between 0 and 1, where a higher value indicates a better fit.\n    # Avoid division by zero.\n    valid_bins = bins_remain_cap > 0\n    bins_remain_cap_safe = np.where(bins_remain_cap > 0, bins_remain_cap, 1e-6)\n    fit_scores = 1 / (1 + np.exp(-5 * (item / bins_remain_cap_safe - 0.5)))  # Adjust parameters 5 and 0.5 as needed\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = fit_scores\n    return priorities",
    "response_id": 1,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 95.90827503317318,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = np.abs(bins_remain_cap[valid_bins] - item)\n    distances = np.where(distances == 0, 1e-9, distances)\n    inverse_distance = 1.0 / distances\n\n    fullness = 1.0 - (bins_remain_cap[valid_bins] / np.max(bins_remain_cap))\n    fullness_score = np.abs(fullness - 0.5)\n    fullness_score = np.where(fullness_score == 0, 1e-9, fullness_score)\n    fullness_priority = 1.0 / fullness_score\n\n    # Item density: encourage placing larger items in fuller bins\n    item_density = item / np.max(bins_remain_cap)\n    density_priority = 1.0 - item_density\n\n    # Combine with exploration\n    epsilon = 0.05\n    exploration_bonus = np.random.rand(len(valid_bins)) * epsilon\n\n    priorities[valid_bins] = (0.5 * inverse_distance +\n                              0.3 * fullness_priority +\n                              0.1 * density_priority +\n                              0.1 * exploration_bonus)\n\n    return priorities",
    "response_id": 2,
    "obj": 3.8093338651775075,
    "SLOC": 21.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 305.0255750850964,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.7) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        alpha: Weighting factor for exact fit priority.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Assign highest priority to bins where item exactly fits\n    exact_fit_mask = (bins_remain_cap == item)\n    priorities[exact_fit_mask] = 1.0\n\n    # If no exact fit, assign priority based on remaining capacity.\n    # More remaining capacity is less preferred, so we use the inverse.\n    remaining_capacities = bins_remain_cap[~exact_fit_mask]\n    if remaining_capacities.size > 0:\n        priorities[~exact_fit_mask] = 1.0 / (remaining_capacities + 1e-6)\n\n    # Weighted combination of exact fit and remaining capacity priorities\n    priorities = np.where(exact_fit_mask, alpha, 1-alpha) * priorities\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 93.45440529575887,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = bins_remain_cap[valid_bins] - item\n    exact_fit = (distances == 0).astype(float) * 10  # High priority for exact fits\n\n    # Sigmoid-based scoring\n    sigmoid_input = (bins_remain_cap[valid_bins] - item) / np.max(bins_remain_cap)\n    sigmoid_score = 1.0 / (1.0 + np.exp(-5 * sigmoid_input)) # Scale sigmoid\n\n    # Target fullness of 0.7\n    fullness = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n    fullness_score = np.abs(fullness - 0.7)\n    fullness_priority = np.exp(-5 * fullness_score) # Exponential decay around 0.7\n\n    # Add a decaying random factor for exploration\n    randomness = np.random.rand(len(valid_bins)) * (0.05 / (len(bins_remain_cap) + 1))  # Decay randomness\n\n    priorities[valid_bins] = (0.6 * sigmoid_score + 0.3 * fullness_priority + exact_fit + randomness)\n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 364.5550890997629,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response1.txt_stdout.txt",
    "code_path": "problem_iter15_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = bins_remain_cap[valid_bins] - item\n    \n    # Sigmoid-based scoring for tighter fits\n    sigmoid_strength = 5.0\n    sigmoid_scores = np.exp(-sigmoid_strength * distances)\n\n    # Prioritize exact fits\n    exact_fit = (distances == 0).astype(float) * 10\n\n    # Prioritize near-full bins (around 70%)\n    fullness = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n    fullness_score = np.abs(fullness - 0.7)\n    fullness_priority = np.exp(-sigmoid_strength * fullness_score)\n    \n    # Add a decaying random factor for exploration\n    randomness = np.random.rand(len(valid_bins)) * (0.1 / (len(bins_remain_cap) + 1))\n\n    priorities[valid_bins] = (0.5 * sigmoid_scores + 0.3 * fullness_priority + exact_fit + randomness)\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 287.3841171239176,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response5.txt_stdout.txt",
    "code_path": "problem_iter16_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    distances = bins_remain_cap[valid_bins] - item\n    exact_fit = (distances == 0).astype(float) * 25  # Higher priority for exact fits\n\n    distances = np.abs(distances)\n    distances = np.where(distances == 0, 1e-6, distances)\n    inverse_distance = 1.0 / distances\n\n    fullness = bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n    fullness_score = np.abs(fullness - 0.7)  # Prefer bins around 70% full\n    fullness_score = np.where(fullness_score == 0, 1e-6, fullness_score)\n    fullness_priority = 1.0 / fullness_score\n\n    bin_is_empty = bins_remain_cap == np.max(bins_remain_cap)\n    empty_bin_penalty = np.where(bin_is_empty[valid_bins], -5.0, 0.0)  # Penalize empty bins\n\n    randomness = np.random.rand(len(valid_bins)) * 0.02  # Reduced random factor for exploration\n\n    priorities[valid_bins] = (0.45 * inverse_distance + 0.35 * fullness_priority + exact_fit + empty_bin_penalty + randomness)\n\n    return priorities",
    "response_id": 5,
    "obj": 3.7195851615476623,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 304.37979577972794,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response7.txt_stdout.txt",
    "code_path": "problem_iter16_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the ratio of item size to remaining bin capacity\n    ratios = item / (bins_remain_cap + 1e-6)  # Add a small value to avoid division by zero\n\n    # Prioritize bins where the ratio is high (item fills a large portion of the bin)\n    priorities = ratios\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 15.509775004326936,
    "exec_success": true
  }
]