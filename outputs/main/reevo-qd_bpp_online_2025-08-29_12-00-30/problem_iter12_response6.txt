```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_usage_history: np.ndarray = None, future_item_sizes: np.ndarray = None) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, considering fit, usage, and future items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
        bin_usage_history: Array tracking the number of items placed in each bin (optional).
        future_item_sizes: Array of sizes of future items (optional).

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    diffs = bins_remain_cap - item
    valid_bins = diffs >= 0

    if np.any(valid_bins):
        min_diff = np.min(diffs[valid_bins])
        
        # Prioritize tighter fits
        fit_priority = -diffs[valid_bins] + min_diff

        # Incorporate bin usage history (encourage spreading items across bins)
        usage_priority = np.zeros_like(bins_remain_cap)
        if bin_usage_history is not None:
            usage_priority = 1.0 / (bin_usage_history + 1e-6)  # Bins with fewer items get higher priority
            usage_priority = usage_priority[valid_bins]
        
        # Incorporate future item sizes (attempt to leave space for larger future items)
        future_priority = np.zeros_like(bins_remain_cap)
        if future_item_sizes is not None:
            avg_future_size = np.mean(future_item_sizes) if len(future_item_sizes) > 0 else 0
            future_priority = (bins_remain_cap - avg_future_size) / (bins_remain_cap + 1e-6)
            future_priority = future_priority[valid_bins]

        # Combine priorities (weighted sum)
        priorities[valid_bins] = 0.7 * fit_priority + 0.2 * usage_priority + 0.1 * future_priority
    
    return priorities
```
