```python
import numpy as np

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    return priorities

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin,
    using an Almost Full Fit strategy.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Calculate how much space would be wasted if the item were placed in each bin
    waste = bins_remain_cap - item

    # Assign a higher priority to bins with less waste, but also consider bins that are almost full
    # Give bins which have almost enough capacity to fit the current item a high priority.
    # We also prefer bins with capacity close to item size.
    
    for i in range(len(bins_remain_cap)):
        if bins_remain_cap[i] >= item:
            priorities[i] = waste[i]  # Lower waste is better
        else:
            priorities[i] = -1 # Cannot fit in bin

    # Apply a bonus for bins that are almost full (close to capacity).
    # The almost full fit heuristic prioritizes bins that are near their capacity
    # to maximize space utilization.
    for i in range(len(bins_remain_cap)):
        if bins_remain_cap[i] >= item:
          priorities[i] += (bins_remain_cap[i] / item) - 1 # bonus, higher if close in capacity

    return priorities
```
