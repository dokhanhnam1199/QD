```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates distance, demand, and a bit of "quantum tunneling" (exploration).

    Args:
        distance_matrix: Distance matrix (n x n).
        coordinates: Euclidean coordinates of nodes (n x 2).
        demands: Vector of customer demands (n).
        capacity: Vehicle capacity.

    Returns:
        Heuristic matrix (n x n) indicating the promise of each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Basic distance heuristic (inverse distance)
    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero
    heuristic_matrix += distance_heuristic

    # Demand-based heuristic: Penalize edges connecting nodes with high cumulative demand
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
            else:
                # Estimate if adding edge (i, j) violates capacity on route i->j->0.
                # Simplified estimation: Consider only direct route demand
                demand_penalty = np.clip(demands[i] + demands[j] - capacity, 0, np.inf)  # Penalize if demand exceeds capacity
                heuristic_matrix[i, j] -= 0.1 * demand_penalty / capacity #Reduce value for potentially creating infeasible routes.
                
                # Add another layer of estimation
                # Penalize route including node[i]->node[j]->node[0] based on route distance

                heuristic_matrix[i,j] -= 0.05 * (distance_matrix[i,j] + distance_matrix[j,0])

    # "Quantum Tunneling" - Introduce randomness to explore less obvious routes.
    # Favor connections to nodes far away from their nearest neighbors to avoid clusters

    nearest_neighbor_distances = np.zeros(n)
    for i in range(n):
        distances = distance_matrix[i, :]
        distances_sorted = np.sort(distances)
        nearest_neighbor_distances[i] = distances_sorted[1] if len(distances_sorted) > 1 else 0 #ignore itself

    for i in range(n):
      for j in range(n):
        if i != j:

          tunneling_bonus = 0.01 * (nearest_neighbor_distances[i] + nearest_neighbor_distances[j])
          heuristic_matrix[i, j] += tunneling_bonus # add bonus for tunnel edges.

    # Normalize heuristic values to be between 0 and 1 (optional, but can be helpful)
    max_val = np.max(heuristic_matrix)
    min_val = np.min(heuristic_matrix)

    if max_val > min_val:
        heuristic_matrix = (heuristic_matrix - min_val) / (max_val - min_val)


    return heuristic_matrix
```
