```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for CVRP using a combination of distance, demand,
    and depot proximity considerations.

    Args:
        distance_matrix: (n x n) distance matrix between nodes.
        coordinates: (n x 2) Euclidean coordinates of nodes.
        demands: (n) vector of customer demands.
        capacity: Vehicle capacity.

    Returns:
        (n x n) matrix of edge priorities/indicators. Higher values indicate
        more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Inverse distance heuristic
    inverse_distance = 1 / (distance_matrix + np.eye(n))  # Add eye to avoid division by zero
    np.fill_diagonal(inverse_distance, 0)

    # Demand-based heuristic (penalize edges connecting high-demand nodes)
    demand_factor = np.outer(demands, demands)
    normalized_demand = demand_factor / (capacity**2)
    demand_heuristic = 1 - np.clip(normalized_demand, 0, 1)  # Penalize based on combined demand.  Clip to [0, 1]

    # Depot proximity heuristic (favor edges closer to the depot)
    depot_distances_i = distance_matrix[0, :]
    depot_distances_j = distance_matrix[:, 0]
    depot_proximity = np.outer(1 / (depot_distances_i + 1e-6), 1 / (depot_distances_j.T + 1e-6)) # Avoid divide by zero
    np.fill_diagonal(depot_proximity, 0)

    # Combine the heuristics. Weigh each component differently.
    heuristics = (0.6 * inverse_distance +
                 0.2 * demand_heuristic +
                 0.2 * depot_proximity)

    return heuristics
```
