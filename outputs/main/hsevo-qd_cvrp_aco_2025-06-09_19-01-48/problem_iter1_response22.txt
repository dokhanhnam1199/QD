```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Implements a heuristic for the Capacitated Vehicle Routing Problem (CVRP)
    based on a combination of distance, demand, and angle considerations.

    Args:
        distance_matrix: A numpy array of shape (n, n) representing the distance between each pair of nodes.
        coordinates: A numpy array of shape (n, 2) representing the Euclidean coordinates of each node.
        demands: A numpy array of shape (n,) representing the demand of each node.
        capacity: The capacity of each vehicle.

    Returns:
        A numpy array of shape (n, n) representing the heuristic values for each edge. Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Heuristic 1: Inverse distance, adjusted for demand
    # Favor shorter distances, penalized by the demand of the target node.
    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Add a small value to avoid division by zero.
    demand_penalty = demands / capacity
    demand_penalty[0] = 0  # Depot has no demand penalty

    distance_demand_heuristic = distance_heuristic * (1 - demand_penalty)

    # Heuristic 2: Angle heuristic
    # Penalize sharp turns to promote smoother routes.
    angle_heuristic = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                angles = []
                for k in range(n):
                    if k != i and k != j:
                        # Compute angles between vectors (i -> j) and (i -> k)
                        vector_ij = coordinates[j] - coordinates[i]
                        vector_ik = coordinates[k] - coordinates[i]

                        # Normalize vectors to calculate cosine correctly
                        vector_ij_norm = vector_ij / np.linalg.norm(vector_ij)
                        vector_ik_norm = vector_ik / np.linalg.norm(vector_ik)

                        cos_angle = np.dot(vector_ij_norm, vector_ik_norm)
                        angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Clip for numerical stability

                        angles.append(angle)

                if angles:
                    angle_heuristic[i, j] = 1 - (np.min(angles) / np.pi)  #Favor smaller angles (more straight line). Scale between 0 and 1

    # Heuristic 3: Depot proximity - encourages routes returning to the depot

    depot_proximity_heuristic = np.zeros((n, n))

    for i in range(n):
        for j in range(n):
            if i != j:
                depot_proximity_heuristic[i, j] = (1 - (distance_matrix[j,0] / np.max(distance_matrix))) # Normalize distance to the depot

    # Combine the heuristics

    heuristic_matrix = (0.6 * distance_demand_heuristic + 0.3 * angle_heuristic + 0.1 * depot_proximity_heuristic)
    return heuristic_matrix
```
