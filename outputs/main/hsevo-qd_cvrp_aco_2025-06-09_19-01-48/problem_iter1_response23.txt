```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and node proximity to depot.

    This heuristic combines several factors to estimate the desirability of including
    each edge in a potential CVRP solution.  It prioritizes shorter distances,
    edges connecting nodes with lower combined demand, and edges connecting nodes
    that are relatively close to the depot (encouraging routes to cluster around the depot).

    Args:
        distance_matrix: (n x n) matrix of distances between nodes.
        coordinates: (n x 2) matrix of Euclidean coordinates of nodes.
        demands: (n) vector of customer demands.
        capacity: integer capacity of vehicle.

    Returns:
        (n x n) matrix of heuristic values for each edge. Higher values indicate
        more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Depot distance: Distance of node i from the depot (node 0)
    depot_distances = distance_matrix[0, :]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # Avoid self-loops
                continue

            # Distance factor: inversely proportional to distance.  Add small value to prevent division by zero
            distance_factor = 1 / (distance_matrix[i, j] + 1e-6)

            # Demand factor:  Edges connecting low-demand customers are preferable.
            # The combined demand is normalized to the vehicle capacity. Edges are less desirable if connecting high demand
            demand_factor = 1 - min((demands[i] + demands[j]) / capacity, 1)
            demand_factor = max(demand_factor, 0) # ensures demand_factor doesn't go below zero

            # Depot proximity factor: Nodes close to the depot are favored
            # Normalized by max depot distance so it's scale free

            max_depot_distance = np.max(depot_distances)
            if max_depot_distance > 0: #prevent division by zero
                depot_proximity_i = 1 - (depot_distances[i] / max_depot_distance)
                depot_proximity_j = 1 - (depot_distances[j] / max_depot_distance)

                depot_proximity_factor = (depot_proximity_i + depot_proximity_j) / 2 #Average
            else:
                depot_proximity_factor = 1 #If all distances are zero, depot proximity factor is one

            # Combine factors: Weighted average of distance, demand, and depot proximity
            #  Weights can be tuned based on problem characteristics.
            heuristic_matrix[i, j] = (0.6 * distance_factor +
                                      0.2 * demand_factor +
                                      0.2 * depot_proximity_factor)

    return heuristic_matrix
```
