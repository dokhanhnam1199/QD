```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP) based on a combination of distance,
    demand, and angle considerations. A stochastic component is added.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Demand of each node (n).  demands[0] is the depot's demand (usually 0).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: A matrix (n x n) of heuristic values, indicating the desirability of including each edge in a solution.
                     Higher values suggest a more promising edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Heuristic factors (tunable)
    distance_factor = 1.0
    demand_factor = 0.5
    angle_factor = 0.3
    stochastic_factor = 0.1

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # Avoid self-loops
                continue

            # Distance component: Inverse of the distance (shorter distance is better)
            distance_heuristic = distance_factor / (distance_matrix[i, j] + 1e-6)  # Adding a small value to avoid division by zero

            # Demand component: Encourages edges connecting nodes with demands that fit within capacity.

            # Simplified demand heuristic: just check the destination demand
            # A more complex heuristic could consider if connecting to this node could potentially cause an overload
            demand_heuristic = 1.0 if demands[j] <= capacity else 0.1  #Reduced heuristic score if demand exceed capacity

            # Angle component: Encourages smoother routes by considering angles between nodes
            # Calculate angle between i, j, and the depot (node 0)
            if i != 0 and j != 0:
                vector_io = coordinates[0] - coordinates[i]  # From i to depot
                vector_ij = coordinates[j] - coordinates[i]  # From i to j

                # Normalize vectors (handle zero vector gracefully)
                norm_io = np.linalg.norm(vector_io)
                norm_ij = np.linalg.norm(vector_ij)

                if norm_io > 1e-6 and norm_ij > 1e-6: #avoid zero division
                   vector_io = vector_io / norm_io
                   vector_ij = vector_ij / norm_ij

                   dot_product = np.dot(vector_io, vector_ij)
                   angle = np.arccos(np.clip(dot_product, -1.0, 1.0)) # Clip to avoid domain errors due to floating point inaccuracy.
                   angle_heuristic = angle_factor * (1 - (angle / np.pi))  # Smaller angle (straighter turn) is better.

                else:
                    angle_heuristic = 0.0

            else:
                angle_heuristic = 0.0 # No angle penalty if either i or j is the depot.


            # Stochastic component: Adds randomness to explore different solutions
            stochastic_value = stochastic_factor * np.random.rand()

            # Combine the heuristics
            heuristic_matrix[i, j] = (distance_heuristic +
                                      demand_factor * demand_heuristic +
                                      angle_heuristic +
                                      stochastic_value)

    return heuristic_matrix
```
