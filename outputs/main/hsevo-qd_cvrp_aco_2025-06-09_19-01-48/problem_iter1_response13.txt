```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and angle.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators for each edge (n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Parameters to tune (obtained via radioactive experimentation, naturally!)
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.3
    capacity_penalty_factor = 2.0  # Increase penalty for approaching capacity.

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance component: inverse of distance. Shorter is better.
                distance_component = 1 / distance_matrix[i, j]

                # Demand component: penalize edges leading to high-demand nodes early in route.
                demand_component = 1 / (demands[j] + 1e-6)  # Avoid division by zero

                # Angle component: encourages edges that maintain forward progress (avoid sharp turns)
                #  Calculate the angle between the vectors i->j and depot->j.  Smaller angles are preferred.
                depot_x, depot_y = coordinates[0]
                node_i_x, node_i_y = coordinates[i]
                node_j_x, node_j_y = coordinates[j]

                vector_ij = np.array([node_j_x - node_i_x, node_j_y - node_i_y])
                vector_0j = np.array([node_j_x - depot_x, node_j_y - depot_y])

                # Normalize vectors to unit length (helps with consistency).
                vector_ij = vector_ij / (np.linalg.norm(vector_ij) + 1e-6)  # Avoid division by zero
                vector_0j = vector_0j / (np.linalg.norm(vector_0j) + 1e-6)

                angle = np.arccos(np.clip(np.dot(vector_ij, vector_0j), -1.0, 1.0)) # Clip dot product to avoid domain errors
                angle_component = 1 / (angle + 1e-6)

                # Capacity penalty: penalize if the customer has a large demand relative to capacity
                capacity_penalty = np.exp(-capacity_penalty_factor * demands[j] / capacity)

                # Combine the components
                heuristics[i, j] = (
                    distance_weight * distance_component +
                    demand_weight * demand_component +
                    angle_weight * angle_component
                ) * capacity_penalty # Capacity also impacts the combined component

    return heuristics
```
