```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Implements a heuristic function for CVRP that combines distance, demand,
    and angular considerations to estimate the desirability of including each edge.

    Args:
        distance_matrix: (n x n) matrix of distances between nodes.
        coordinates: (n x 2) array of Euclidean coordinates for each node.
        demands: (n) array of demand for each node.
        capacity: Vehicle capacity.

    Returns:
        (n x n) matrix of heuristic values for each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters for weighting different components of the heuristic
    distance_weight = 0.5
    demand_weight = 0.3
    angle_weight = 0.2

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            distance_heuristic = 1 / (distance_matrix[i, j] + 1e-9)  # Avoid division by zero

            # Demand-based heuristic: prioritize connecting to nodes with moderate demand, avoid tiny demand nodes or too high demand nodes if they're isolated
            demand_heuristic = min(1, demands[j] / (capacity / 2 + 1e-9)) if i != 0 else 0

            # Angle-based heuristic: penalize sharp turns to encourage smoother routes.
            # This part is costly, only use it when it's effective.
            if i == 0:  # Angle calculation meaningful only for intermediate nodes.  Focus it on initial departure from depot.
                angle = np.arctan2(coordinates[j, 1] - coordinates[i, 1], coordinates[j, 0] - coordinates[i, 0])
                angle_heuristic = 1 # always 1 as first stop doesn't have previous node.
            else:
                 angle_heuristic = 0 # Disable otherwise to reduce computational load. It adds limited info.


            heuristic_matrix[i, j] = (
                distance_weight * distance_heuristic +
                demand_weight * demand_heuristic +
                angle_weight * angle_heuristic
            )

    return heuristic_matrix
```
