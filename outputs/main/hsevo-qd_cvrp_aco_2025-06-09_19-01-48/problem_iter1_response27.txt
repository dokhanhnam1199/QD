```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several ideas:
    1. Distance-based desirability: Shorter distances are generally more desirable.
    2. Demand-based penalty:  Edges connecting nodes with high demands are penalized (slightly).
    3. Depot proximity bonus: Edges connecting to the depot (node 0) are encouraged.  This helps in route completion and balancing.
    4. Capacity utilization awareness:  A bonus is given to links where the average demand of connected customers are within a certain tolerance of "ideal" capacity utilization
    5. Location information consideration

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Avoid division by zero and self-loops
    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)
    np.fill_diagonal(distance_matrix, np.inf)

    # Distance-based desirability
    heuristics = 1 / distance_matrix

    # Demand-based penalty
    demand_penalty = np.outer(demands, demands)  # Create an n x n matrix of demand products
    heuristics -= 0.001 * demand_penalty   # Subtract a small penalty based on the demand product

    # Depot proximity bonus
    depot_bonus = np.zeros((n, n))
    depot_bonus[0, :] = 0.1
    depot_bonus[:, 0] = 0.1
    heuristics += depot_bonus


    # Capacity utilization awareness
    ideal_utilization = capacity * 0.75 # Aim for utilization near 75% of capacity
    capacity_utilization_bonus = np.zeros((n,n))

    for i in range(n):
        for j in range(n):
            if i!=j:
                avg_demand = (demands[i] + demands[j])/2

                #Bonus decreases farther away from the target utilization
                capacity_utilization_bonus[i,j] = np.exp(-np.abs(avg_demand - ideal_utilization)/(capacity/2))

    heuristics += 0.1 * capacity_utilization_bonus #Small bonus to promising edge.


    # Location information
    for i in range(n):
        for j in range(n):
            if i != j:
                diff = coordinates[i] - coordinates[j]
                distance = np.sqrt(np.sum(diff * diff))
                heuristics[i, j] /= (1+ 0.01*distance)
                # Penalize based on coordinate distances
    return heuristics
```
