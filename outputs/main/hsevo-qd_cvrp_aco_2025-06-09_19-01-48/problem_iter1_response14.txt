```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Improved heuristics for CVRP, considering distance, demand, and angle.

    Args:
        distance_matrix: Distance between nodes (n x n).
        coordinates: Node coordinates (n x 2).
        demands: Node demands (n).
        capacity: Vehicle capacity.

    Returns:
        Heuristic matrix (n x n) indicating edge desirability.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Heuristic factors (tunable)
    distance_factor = 1.0
    demand_factor = 1.0
    angle_factor = 1.0
    capacity_factor = 1.0


    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0
                continue

            distance_heuristic = distance_factor / distance_matrix[i, j]

            # Prioritize links with low demand (relative to remaining capacity)
            # demand_heuristic = 1 / (demands[j] + 1e-6) # Avoid division by zero and penalize higher demands
            demand_heuristic = demand_factor / (demands[j] + 0.1)

            # Angle heuristic (discourages sharp turns - penalize large angles from depot)
            if i == 0:
                angle_heuristic = 1.0  # No angle to consider for the depot origin.
            else:
                # Calculate angle between (i -> j) and (depot -> i)
                depot_x, depot_y = coordinates[0]
                i_x, i_y = coordinates[i]
                j_x, j_y = coordinates[j]

                v1 = np.array([i_x - depot_x, i_y - depot_y])
                v2 = np.array([j_x - i_x, j_y - i_y])

                v1_norm = np.linalg.norm(v1)
                v2_norm = np.linalg.norm(v2)

                if v1_norm > 0 and v2_norm > 0:
                  dot_product = np.dot(v1, v2)
                  cos_angle = dot_product / (v1_norm * v2_norm)
                  cos_angle = np.clip(cos_angle, -1.0, 1.0)  # Ensure within valid range

                  angle = np.arccos(cos_angle)  # Angle in radians

                  angle_heuristic = angle_factor * (1 - (angle / np.pi)) # Map angle [0, pi] to heuristic [0,1]. Smaller angles give higher scores
                else:
                  angle_heuristic = 0.0 # If one of the vectors has zero length.


            # Capacity heuristic - discourage edges that bring close to vehicle capacity:
            capacity_heuristic = 1 # Initialize to 1 to avoid multiplicative zero.
            # (Optional:  Add a cost depending on demand.)
            heuristic_matrix[i, j] = distance_heuristic * demand_heuristic * angle_heuristic  + capacity_heuristic
            # Cap heuristic matrix. Important for convergence and to deal with outliers.
            heuristic_matrix[i, j] = np.clip(heuristic_matrix[i, j], 0, 10)
    return heuristic_matrix
```
