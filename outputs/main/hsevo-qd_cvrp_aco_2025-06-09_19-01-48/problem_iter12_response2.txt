```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """CVRP heuristic: Combines distance, demand, angle, depot proximity,
    capacity buffer, criticality, adaptive sparsification, and normalization."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # 1. Distance heuristic (inverse square)
    distance_heuristic = 1.0 / (distance_matrix + 1e-6)**2
    heuristic_matrix = distance_heuristic.copy()

    # 2. Demand-based penalty/reward with capacity buffer
    demand_factor = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_factor[i, j] = 0
                continue
            if i == 0 or j == 0:
                continue

            combined_demand = demands[i] + demands[j]
            remaining_capacity = capacity - combined_demand

            if combined_demand > capacity:
                demand_factor[i, j] = 0.01
            elif remaining_capacity > (capacity / 2):
                demand_factor[i, j] = 1.15
            elif remaining_capacity > (capacity / 4):
                demand_factor[i, j] = 1.05
            else:
                demand_factor[i, j] = 0.9
    heuristic_matrix = heuristic_matrix * demand_factor

    # 3. Angle heuristic (encourage straighter paths)
    angle_heuristic = np.zeros((n,n))
    for i in range(n):
        for j in range(n):
            if i == j: continue

            angle_sum = 0
            for k in range(n):
                if k == i or k == j: continue

                v1 = coordinates[i] - coordinates[k]
                v2 = coordinates[j] - coordinates[i]

                dot_product = np.dot(v1, v2)
                magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)

                if magnitudes > 0:
                    cosine_angle = dot_product / magnitudes
                    angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))
                    angle_sum += (np.pi - angle)

            if n > 2:
                angle_heuristic[i,j] = angle_sum / (n - 2)
            else:
                angle_heuristic[i,j] = 0

            heuristic_matrix[i, j] += 0.1 * angle_heuristic[i,j]

    # 4. Depot attraction
    depot_attraction = np.zeros((n, n))
    for i in range(n):
      for j in range(n):
        if i == j: continue
        depot_attraction[i, j] = (1 / (distance_matrix[i, 0] + 1e-6)) + (1 / (distance_matrix[j, 0] + 1e-6))
        heuristic_matrix[i, j] += 0.05 * depot_attraction[i, j]

    for i in range(1, n):
        heuristic_matrix[0, i] *= 0.5  # Discourage direct connections from depot
        heuristic_matrix[i, 0] *= 0.5  # Discourage direct connections to depot

    # 5. Capacity Aware Depot Connection
    capacity_depot_connection = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i == j: continue
            if i == 0 and demands[j] > capacity / 2:
                capacity_depot_connection[i, j] = 0.1  # Heavily Penalize
            if j == 0 and demands[i] > capacity / 2:
                capacity_depot_connection[i, j] = 0.1 # Heavily Penalize
    heuristic_matrix = heuristic_matrix * (1-capacity_depot_connection)

    # 6. Criticality Metric: Encourage connections between "isolated" nodes.
    #    Nodes with high average distance to others are considered isolated.
    avg_distances = np.mean(distance_matrix, axis=1)
    criticality = (avg_distances - np.min(avg_distances)) / (np.max(avg_distances) - np.min(avg_distances) + 1e-6)  # Normalize to [0, 1]
    criticality_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i == j: continue
            criticality_matrix[i, j] = criticality[i] + criticality[j]  # Higher value for connecting two critical nodes
    heuristic_matrix += 0.1 * criticality_matrix

    # 7.  Proximity to Depot if Capacity Almost Full.
    # Encourage returning to the depot if the vehicle is nearly full.
    capacity_proximity = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i == j or i == 0 or j == 0:
                continue
            combined_demand = demands[i] + demands[j]
            remaining_capacity = capacity - combined_demand
            if 0 < remaining_capacity <= capacity * 0.25: # Vehicle nearly full
                capacity_proximity[i,j] =  (1 / (distance_matrix[j,0] + 1e-6)) # Favor connections to depot j
                capacity_proximity[i,j] += (1 / (distance_matrix[i,0] + 1e-6)) # Favor connections to depot i
    heuristic_matrix += 0.075 * capacity_proximity

    # 8. Normalize heuristics for each node (row-wise)
    for i in range(n):
        row_sum = np.sum(heuristic_matrix[i,:])
        if row_sum > 0:
            heuristic_matrix[i,:] /= row_sum

    # 9. Adaptive Sparsification: Dynamically adjust the sparsification threshold.
    #    Start with a more aggressive sparsification and reduce it if the
    #    solutions are poor. (This requires feedback from a higher-level solver)
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.25)
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
