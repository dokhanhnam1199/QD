```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and depot proximity.

    Args:
        distance_matrix (np.ndarray): Distance between nodes (n x n).
        coordinates (np.ndarray): Node coordinates (n x 2).
        demands (np.ndarray): Node demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Edge prior indicators (n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Heuristic 1: Inverse distance
    distance_heuristic = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # Heuristic 2: Demand-weighted distance from depot
    depot_distances = distance_matrix[0, :]
    demand_weighted_depot_distance = demands * depot_distances
    normalized_demand_weighted_depot_distance = demand_weighted_depot_distance / (np.max(demand_weighted_depot_distance) + 1e-9)

    # Heuristic 3: Capacity constraint consideration. Favor closer nodes to the depot
    capacity_proximity = np.zeros((n, n))
    for i in range(1, n): #exclude depot
      for j in range(1, n):
        if i != j:
          capacity_proximity[i,j] = 1/(distance_matrix[0,i]+distance_matrix[0,j]+ 1e-9)
    # Heuristic 4: Angle Penalty from Depot. Penalize large angles from the depot node
    angle_penalty = np.zeros((n,n))

    depot_x, depot_y = coordinates[0, :]
    for i in range(1, n):
        x1, y1 = coordinates[i, :]
        for j in range(1, n):
            if i!=j:
              x2, y2 = coordinates[j,:]

              #compute vector for i and j to the depot
              v1 = np.array([x1 - depot_x, y1 - depot_y])
              v2 = np.array([x2-depot_x, y2 - depot_y])

              #normalize the vector
              v1_norm = v1 / (np.linalg.norm(v1)+1e-9)
              v2_norm = v2 / (np.linalg.norm(v2)+1e-9)

              angle = np.arccos(np.clip(np.dot(v1_norm, v2_norm), -1.0, 1.0)) #angle in radians

              angle_penalty[i,j] = angle

    # Combine heuristics with weights
    heuristics = 0.6 * distance_heuristic + \
                 0.15 * (1 - normalized_demand_weighted_depot_distance[np.newaxis, :]) + \
                 0.15 * capacity_proximity + \
                 0.1* (1-angle_penalty)


    return heuristics
```
