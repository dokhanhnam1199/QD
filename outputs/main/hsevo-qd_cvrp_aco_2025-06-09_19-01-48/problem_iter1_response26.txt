```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Improves upon the basic heuristic by incorporating distance, demand,
    and angular considerations. A low heuristic value indicates a more
    promising edge.

    Args:
        distance_matrix: Distance between all nodes.
        coordinates: Euclidean coordinates of nodes.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        Heuristic matrix indicating the desirability of each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Depot location (node 0)
    depot_x, depot_y = coordinates[0]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = np.inf  # Prevent self-loops
                continue

            distance_factor = distance_matrix[i, j]

            # Demand-based discouragement: higher demand at either node increases the cost
            demand_penalty = (demands[i] + demands[j]) / (2 * capacity)

            # Angle-based encouragement (try to avoid sharp turns). Higher dot product indicates less sharp turn.
            if i == 0: # From depot, then all the same
                angle_factor = 1.0
            else:
                # Compute vector from depot to current node i
                vec_depot_i = coordinates[i] - coordinates[0]
                # Compute vector from current node i to potential next node j
                vec_i_j = coordinates[j] - coordinates[i]
                
                # Normalize the vectors
                vec_depot_i = vec_depot_i / np.linalg.norm(vec_depot_i)
                vec_i_j = vec_i_j / np.linalg.norm(vec_i_j)
                
                # Calculate the dot product
                angle_factor = np.dot(vec_depot_i, vec_i_j)
                # Map dot product to [0, 2]
                angle_factor = 1 - angle_factor # smaller angle preferred. range: [0, 2]

            heuristic_matrix[i, j] = distance_factor + 5 * demand_penalty + 1 * angle_factor

    return heuristic_matrix
```
