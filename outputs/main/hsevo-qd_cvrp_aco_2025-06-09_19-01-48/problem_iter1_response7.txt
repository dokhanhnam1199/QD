```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristics function for CVRP based on a combination of distance, demand,
    and angle considerations.  It assigns higher probabilities to edges that
    are shorter, connect nodes with lower demand, and create a more "balanced"
    tour in terms of angles from the depot.  This encourages exploration of
    diverse routes early on.

    Args:
        distance_matrix: (n x n) matrix of distances between nodes.
        coordinates: (n x 2) matrix of node coordinates.
        demands: (n) vector of customer demands.
        capacity: Vehicle capacity.

    Returns:
        (n x n) matrix of heuristic values for each edge.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Heuristic 1: Distance component (inverse distance)
    distance_heuristic = 1 / (distance_matrix + 1e-9)  # Add small constant to avoid division by zero

    # Heuristic 2: Demand component (prefer edges connecting nodes with lower demand).
    #   We'll use the *product* of demands to favor lower-demand edges. Also include Depot node
    demand_matrix = np.outer(demands, demands)
    demand_heuristic = 1 / (demand_matrix + 1e-9)

    # Heuristic 3: Angle component (encourage "balanced" tours around depot)
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    angle_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            angle_diff = np.abs(angles[i] - angles[j])
            angle_diff = np.minimum(angle_diff, 2 * np.pi - angle_diff)  # Normalize to 0-pi range

            # Encouraging angles that are somewhat far apart (not just going back and forth).
            angle_heuristic_value = np.exp(-angle_diff**2 / (2 * (np.pi / 4)**2)) # Gaussian centered at 0
            angle_matrix[i, j] = 1 - angle_heuristic_value # Inverse because we want bigger differences

    # Heuristic 4: Capacity Considerations near Depot
    capacity_heuristic = np.ones((n,n))
    for i in range(1, n): # Customer Node
      for j in range(1,n): # Customer Node
        if i == j : continue
        # Promote routes near Depot (node 0) based on demand. This creates capacity "reservations".
        # Avoid routes from Depot that immediately saturate capacity
        demand_sum_heuristic = np.clip(1 - (demands[i]+ demands[j]) / capacity, 0.01, 1) # avoid division by zero and negative probs
        capacity_heuristic[0, i] = demand_sum_heuristic # out
        capacity_heuristic[i,0] = demand_sum_heuristic # in

    # Combine heuristics with weights.  Experiment with different weights to tune performance.
    alpha = 0.5  # Weight for distance
    beta = 0.2   # Weight for demand
    gamma = 0.1 # Weight for angle
    delta = 0.2 # Weight for capacity from depot

    heuristics = (alpha * distance_heuristic +
                  beta * demand_heuristic +
                  gamma * angle_matrix +
                  delta * capacity_heuristic )


    # Mask the diagonal (no self-loops)
    np.fill_diagonal(heuristics, 0)

    # Normalize heuristics so they are between 0 and 1 (helps with stochastic sampling).
    heuristics = (heuristics - np.min(heuristics)) / (np.max(heuristics) - np.min(heuristics) + 1e-9)

    return heuristics
```
