```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    CVRP heuristic combining distance, demand, angle, depot proximity, and capacity utilization, 
    with adaptive sparsification and route completion encouragement.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # 1. Distance Heuristic (Inverse Square)
    distance_heuristic = 1.0 / (distance_matrix + 1e-6)**2
    heuristic_matrix = distance_heuristic.copy()

    # 2. Demand-Based Adjustment (Crucial for feasibility)
    demand_factor = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_factor[i, j] = 0
                continue
            
            combined_demand = demands[i] + demands[j]
            if combined_demand > capacity and i != 0 and j != 0:
                demand_factor[i, j] = -0.9  # Significant penalty exceeding capacity
            else:
                demand_factor[i,j] = 0.0 #No penalty
                
            if combined_demand <= (capacity / 5) and i != 0 and j != 0:
                demand_factor[i, j] += 0.1  # Slight reward for very small demands
            elif combined_demand > (capacity * 0.8) and i != 0 and j!=0:
                demand_factor[i, j] -= 0.2 # Moderate penalty for high demands

    heuristic_matrix += demand_factor

    # 3. Angle Heuristic (Encourage straighter paths)
    angle_heuristic = np.zeros((n,n))
    for i in range(n):
        for j in range(n):
            if i == j: continue

            angle_sum = 0
            for k in range(n):
                if k == i or k == j: continue

                v1 = coordinates[i] - coordinates[k]
                v2 = coordinates[j] - coordinates[i]

                dot_product = np.dot(v1, v2)
                magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)

                if magnitudes > 0:
                    cosine_angle = dot_product / magnitudes
                    angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))
                    angle_sum += (np.pi - angle)

            if n > 2:
                angle_heuristic[i,j] = angle_sum / (n - 2)
            else:
                angle_heuristic[i,j] = 0

            heuristic_matrix += 0.05 * angle_heuristic[i,j]


    # 4. Depot Attraction (Nodes closer to depot are encouraged, depot connections discouraged)
    depot_attraction = np.zeros((n, n))
    for i in range(n):
      for j in range(n):
        if i == j: continue
        depot_attraction[i, j] = (1 / (distance_matrix[i, 0] + 1e-6)) + (1 / (distance_matrix[j, 0] + 1e-6))
        heuristic_matrix += 0.025 * depot_attraction[i, j] #Reduced influence
        
        if j == 0 and i != 0:
             heuristic_matrix[i,j] -= 0.1 # Discount connection to depot
        if i == 0 and j != 0:
             heuristic_matrix[i,j] -= 0.1 # Discount connection to depot



    # 5. Route Completion Encouragement:  Prioritize connections that lead back to depot.
    route_completion = np.zeros((n,n))
    for i in range(n):
        for j in range(n):
            if i == j: continue

            # Reward edges (i, j) where j is close to the depot (incentivizes closing routes)
            route_completion[i, j] = 1 / (distance_matrix[j, 0] + 1e-6) #Inverse distance to depot
            heuristic_matrix[i, j] += 0.02 * route_completion[i,j]

    # 6. Capacity Utilization Reward:  Encourage edges that better utilize vehicle capacity (but not exceed).
    capacity_utilization = np.zeros((n,n))
    for i in range(n):
        for j in range(n):
            if i == j or i == 0 or j == 0: continue #Only for customer nodes
            combined_demand = demands[i] + demands[j]
            if combined_demand <= capacity:
                capacity_utilization[i, j] = (combined_demand / capacity)
                heuristic_matrix[i, j] += 0.01 * capacity_utilization[i,j]



    # 7. Normalize heuristics for each node
    for i in range(n):
        row_sum = np.sum(heuristic_matrix[i,:])
        if row_sum > 0:
            heuristic_matrix[i,:] /= row_sum

    # 8. Adaptive Sparsification (Aggressive)
    threshold = np.mean(heuristic_matrix) * 0.4  # Higher threshold for more sparsity
    heuristic_matrix[heuristic_matrix < threshold] = 0

    #Ensure depot connections are not completely eliminated, which might make the problem unsolvable
    for i in range(1,n):
        if heuristic_matrix[0,i] == 0:
            heuristic_matrix[0,i] = np.mean(heuristic_matrix[0,:]) #Fill the matrix with the mean for all non-zeros
        if heuristic_matrix[i,0] == 0:
             heuristic_matrix[i,0] = np.mean(heuristic_matrix[i,:]) #Fill the matrix with the mean for all non-zeros

    return heuristic_matrix
```
