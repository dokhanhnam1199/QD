```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """CVRP heuristic: Enhanced combination of factors with adaptive weighting and refined strategies."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # 1. Distance heuristic (inverse square) with scaling
    distance_heuristic = 1.0 / (distance_matrix + 1e-6)**2
    distance_weight = 0.4  # Adjustable weight for distance
    heuristic_matrix = distance_heuristic * distance_weight

    # 2. Demand-based adjustment with finer granularity and dynamic scaling
    demand_factor = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_factor[i, j] = 0
                continue
            if i == 0 or j == 0:
                continue

            combined_demand = demands[i] + demands[j]
            remaining_capacity = capacity - combined_demand

            if combined_demand > capacity:
                demand_factor[i, j] = 0.01  # Strong penalty
            elif remaining_capacity > (capacity * 0.75):
                demand_factor[i, j] = 1.3  # Higher reward for larger buffer
            elif remaining_capacity > (capacity / 2):
                demand_factor[i, j] = 1.2  # Good reward
            elif remaining_capacity > (capacity / 4):
                demand_factor[i, j] = 1.05  # Moderate
            else:
                demand_factor[i, j] = 0.8  # Penalty
    demand_weight = 0.3  # Adjustable weight for demand
    heuristic_matrix = heuristic_matrix + (demand_factor * demand_weight)


    # 3. Angle heuristic (encourage straighter paths) with adaptive scaling
    angle_heuristic = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i == j: continue

            angle_sum = 0
            for k in range(n):
                if k == i or k == j: continue

                v1 = coordinates[i] - coordinates[k]
                v2 = coordinates[j] - coordinates[i]

                dot_product = np.dot(v1, v2)
                magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)

                if magnitudes > 0:
                    cosine_angle = dot_product / magnitudes
                    angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))
                    angle_sum += (np.pi - angle)

            if n > 2:
                angle_heuristic[i,j] = angle_sum / (n - 2)
            else:
                angle_heuristic[i,j] = 0

    angle_weight = 0.05  # Reduced angle weight
    heuristic_matrix = heuristic_matrix + (angle_weight * angle_heuristic)

    # 4. Depot attraction (refined) with distance normalization
    depot_attraction = np.zeros((n, n))
    max_depot_dist = np.max(distance_matrix[:, 0]) #Find the maximum distance to depot
    for i in range(n):
        for j in range(n):
            if i == j: continue
            #Normalized distance to depot
            depot_dist_i = distance_matrix[i,0] / max_depot_dist if max_depot_dist > 0 else 0
            depot_dist_j = distance_matrix[j,0] / max_depot_dist if max_depot_dist > 0 else 0
            depot_attraction[i, j] = (1 / (depot_dist_i + 1e-6)) + (1 / (depot_dist_j + 1e-6))
    depot_weight = 0.03  # Further reduced depot weight
    heuristic_matrix = heuristic_matrix + (depot_weight * depot_attraction)


    # Discourage direct depot connections adaptively
    depot_connection_penalty = 0.5
    for i in range(1, n):
        heuristic_matrix[0, i] *= (1 - depot_connection_penalty)
        heuristic_matrix[i, 0] *= (1 - depot_connection_penalty)

    # 5. Capacity Aware Depot Connection (refined) with sharper penalty
    capacity_depot_connection = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i == j: continue
            if i == 0 and demands[j] > capacity * 0.6:  # Increased threshold
                capacity_depot_connection[i, j] = 0.5  # Sharper Penalty
            if j == 0 and demands[i] > capacity * 0.6:  # Increased threshold
                capacity_depot_connection[i, j] = 0.5  # Sharper Penalty
    heuristic_matrix = heuristic_matrix * (1 - capacity_depot_connection)

    # 6. Node Criticality (New Feature): Refined Calculation & Integration
    node_criticality = np.zeros(n)
    for i in range(1, n):
        node_criticality[i] = demands[i] * distance_matrix[i, 0]

    max_criticality = np.max(node_criticality)
    if max_criticality > 0:
        node_criticality = node_criticality / max_criticality

    criticality_factor = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                criticality_factor[i, j] = 0
                continue
            criticality_factor[i, j] = 1 + 0.15 * (node_criticality[i] + node_criticality[j]) #Slightly higher impact

    heuristic_matrix = heuristic_matrix * criticality_factor

    # 7. Adaptive Sparsification (aggressively prune weak connections)
    non_zero_values = heuristic_matrix[heuristic_matrix > 0]
    if non_zero_values.size > 0:
        threshold = np.quantile(non_zero_values, 0.50)  # Aggressive Sparsification
        heuristic_matrix[heuristic_matrix < threshold] = 0

    # 8. Normalize heuristics for each node with smoothing to prevent zero sums.
    for i in range(n):
        row_sum = np.sum(heuristic_matrix[i,:])
        if row_sum > 0:
            heuristic_matrix[i,:] /= (row_sum + 1e-9) #Prevent divide by zero and smooth the normalization

    return heuristic_matrix
```
