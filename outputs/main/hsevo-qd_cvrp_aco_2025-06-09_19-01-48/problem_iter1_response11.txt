```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and angular proximity.

    This heuristic prioritizes shorter distances, penalizes edges that connect to nodes
    that would likely exceed vehicle capacity, and favors connections to nodes that are
    angularly closer to each other with respect to the depot.

    Args:
        distance_matrix: (n, n) distance matrix between nodes.
        coordinates: (n, 2) Euclidean coordinates of nodes.
        demands: (n,) customer demands.
        capacity: Vehicle capacity.

    Returns:
        (n, n) matrix of heuristic values for each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to tune the heuristic
    distance_weight = 1.0
    demand_weight = 1.0
    angle_weight = 1.0
    small_value = 1e-6 # Avoid division by zero

    # Calculate angles relative to the depot (node 0)
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance heuristic: Prefer shorter distances
            distance_heuristic = distance_weight / (distance_matrix[i, j] + small_value)

            # Demand heuristic: Penalize edges that would likely overload vehicles.
            # Estimate the remaining capacity if we visit node j after node i.
            # We only consider the demands of the two involved nodes.
            # A more sophisticated model could include consideration of the average or maximum demand,
            # as well as distance-weighted demands of other nodes in proximity.
            demand_heuristic = 1.0 / (demands[i] + demands[j] + small_value)

            # Angle heuristic:  Prioritize nodes closer to each other angularly relative to depot
            angle_diff = np.abs(angles[i] - angles[j])
            angle_heuristic = angle_weight / (angle_diff + small_value)

            # Combine heuristics
            heuristic_matrix[i, j] = (
                distance_heuristic + demand_heuristic + angle_heuristic
            )

    return heuristic_matrix
```
