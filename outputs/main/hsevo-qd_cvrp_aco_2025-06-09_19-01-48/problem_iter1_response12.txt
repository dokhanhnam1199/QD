```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and angle.  Inspired by physics:
    - Inverse square law for distance (gravity).
    - Penalize edges that would overload a vehicle.
    - Encourage connections that "straighten" the route (reduce turning).

    Args:
        distance_matrix: Distance between nodes.
        coordinates:  Node coordinates (x, y).
        demands:  Node demands.
        capacity: Vehicle capacity.

    Returns:
        A matrix of heuristic values for each edge.  Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Add a small constant to distances to avoid division by zero and handle self-loops gracefully
    distance_matrix = distance_matrix + 1e-6

    # Heuristic based on inverse square distance (like gravity's influence):
    heuristic_matrix = 1.0 / (distance_matrix**2)


    # Penalize connections that would likely overload a vehicle *IF* considered early in route construction:
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # Never connect a node to itself.
                continue

            # Rough estimate of the remaining capacity if connecting i and j to the depot:
            #  This is crude since it doesn't know the whole tour!  Helps avoid grossly infeasible early decisions.

            remaining_capacity_i = capacity - demands[i] if i != 0 else capacity # Assume depot has effectively infinite capacity.
            remaining_capacity_j = capacity - demands[j] if j != 0 else capacity

            if (demands[i] + demands[j]) > capacity and i != 0 and j != 0:
               heuristic_matrix[i, j] *= 0.1 # Harsh penalty for immediate overload.

            # Slightly discount connection to the depot for non-depot nodes to encourage intermediate hops first
            if j == 0 and i != 0: #returning to depot
                heuristic_matrix[i,j] *=0.8

    # Angle Heuristic (encourage straighter paths):
    for i in range(n):
        for j in range(n):
            if i == j: continue

            # Consider node k as a potential "previous" node to node i:
            angle_heuristic = 0
            for k in range(n):
                if k == i or k == j: continue

                # Calculate vectors for edges ki and ij:
                vector_ki = coordinates[i] - coordinates[k]
                vector_ij = coordinates[j] - coordinates[i]

                # Calculate the angle between vectors ki and ij:
                dot_product = np.dot(vector_ki, vector_ij)
                magnitudes = np.linalg.norm(vector_ki) * np.linalg.norm(vector_ij)

                if magnitudes > 0: # Avoid division by zero.
                    cosine_angle = dot_product / magnitudes
                    angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))  # Clip to handle potential floating-point errors

                    # Straighter paths have smaller angles (closer to 0).
                    #  Prioritize straighter paths by rewarding small angles.
                    angle_heuristic += (np.pi - angle) # Increase score as the angle decreases
                # Average angle heuristic over all potential "previous" nodes
            if n > 2:
              angle_heuristic /= (n - 2)  # Normalize.  Helps if # of locations dramatically varies
            heuristic_matrix[i, j] += 0.1* angle_heuristic  # Weight the angle heuristic less than distance.

    #Normalize heuristics for each node
    for i in range(n):
        row_sum = np.sum(heuristic_matrix[i,:])
        if row_sum > 0:
            heuristic_matrix[i,:] /= row_sum

    return heuristic_matrix
```
