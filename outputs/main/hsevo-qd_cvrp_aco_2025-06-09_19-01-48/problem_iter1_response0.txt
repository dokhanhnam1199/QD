```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for CVRP based on a combination of factors: distance, demand, and angle.

    Args:
        distance_matrix: Distance matrix (n x n).
        coordinates: Euclidean coordinates of nodes (n x 2).
        demands: Customer demands (n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of the same shape as distance_matrix, indicating the
        prior probability of including each edge in a solution.  Higher values
        indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to tune the heuristic
    alpha = 1.0  # Weight for distance
    beta = 0.5  # Weight for demand compatibility
    gamma = 0.5  # Weight for angle penalty


    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
            else:
                # 1. Distance component: Shorter distances are preferred
                distance_score = alpha / distance_matrix[i, j]

                # 2. Demand compatibility component:
                #   - Penalize edges that would likely lead to exceeding capacity early on
                #   - Encourage connection to the depot when demand gets higher

                demand_score = 0.0
                if i == 0:  # from depot, consider destination demand
                    demand_score = beta * np.exp(-demands[j] / capacity)  # Higher demand, lower score
                elif j == 0: # to depot, better if accumulated demand is high
                    demand_score = beta * (1 - np.exp(-demands[i] / capacity))  # If i has a demand exceeding capacity, the score is 1

                else:
                    demand_score = beta * 1.0 # don't discriminate if not depot connection


                # 3. Angle penalty: Discourage sharp turns
                #    - Calculate the angle between the vectors (i -> j) and (j -> depot)
                angle_penalty = 0.0
                if i != 0 and j != 0:  # avoid depot angles to make it easier to start and end trips
                    vector_ij = coordinates[j] - coordinates[i]
                    vector_j0 = coordinates[0] - coordinates[j]

                    # Compute cosine of the angle
                    norm_ij = np.linalg.norm(vector_ij)
                    norm_j0 = np.linalg.norm(vector_j0)

                    if norm_ij > 0 and norm_j0 > 0:
                        cos_angle = np.dot(vector_ij, vector_j0) / (norm_ij * norm_j0)
                        # Convert cosine to angle in radians
                        angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Clip to handle potential floating-point errors

                        angle_penalty = gamma * (angle / np.pi)  # Normalize to [0, 1] range
                    else:
                         angle_penalty = 0.0

                heuristic_matrix[i, j] = distance_score + demand_score - angle_penalty

    # Normalize the heuristic matrix to be between 0 and 1 (optional)
    min_val = np.min(heuristic_matrix)
    max_val = np.max(heuristic_matrix)

    if max_val > min_val: #Avoid division by zero
        heuristic_matrix = (heuristic_matrix - min_val) / (max_val - min_val)

    return heuristic_matrix
```
