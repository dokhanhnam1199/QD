{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for CVRP based on distance, demand, and angle.  Inspired by physics:\n    - Inverse square law for distance (gravity).\n    - Penalize edges that would overload a vehicle.\n    - Encourage connections that \"straighten\" the route (reduce turning).\n\n    Args:\n        distance_matrix: Distance between nodes.\n        coordinates:  Node coordinates (x, y).\n        demands:  Node demands.\n        capacity: Vehicle capacity.\n\n    Returns:\n        A matrix of heuristic values for each edge.  Higher values indicate more promising edges.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Add a small constant to distances to avoid division by zero and handle self-loops gracefully\n    distance_matrix = distance_matrix + 1e-6\n\n    # Heuristic based on inverse square distance (like gravity's influence):\n    heuristic_matrix = 1.0 / (distance_matrix**2)\n\n\n    # Penalize connections that would likely overload a vehicle *IF* considered early in route construction:\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # Never connect a node to itself.\n                continue\n\n            # Rough estimate of the remaining capacity if connecting i and j to the depot:\n            #  This is crude since it doesn't know the whole tour!  Helps avoid grossly infeasible early decisions.\n\n            remaining_capacity_i = capacity - demands[i] if i != 0 else capacity # Assume depot has effectively infinite capacity.\n            remaining_capacity_j = capacity - demands[j] if j != 0 else capacity\n\n            if (demands[i] + demands[j]) > capacity and i != 0 and j != 0:\n               heuristic_matrix[i, j] *= 0.1 # Harsh penalty for immediate overload.\n\n            # Slightly discount connection to the depot for non-depot nodes to encourage intermediate hops first\n            if j == 0 and i != 0: #returning to depot\n                heuristic_matrix[i,j] *=0.8\n\n    # Angle Heuristic (encourage straighter paths):\n    for i in range(n):\n        for j in range(n):\n            if i == j: continue\n\n            # Consider node k as a potential \"previous\" node to node i:\n            angle_heuristic = 0\n            for k in range(n):\n                if k == i or k == j: continue\n\n                # Calculate vectors for edges ki and ij:\n                vector_ki = coordinates[i] - coordinates[k]\n                vector_ij = coordinates[j] - coordinates[i]\n\n                # Calculate the angle between vectors ki and ij:\n                dot_product = np.dot(vector_ki, vector_ij)\n                magnitudes = np.linalg.norm(vector_ki) * np.linalg.norm(vector_ij)\n\n                if magnitudes > 0: # Avoid division by zero.\n                    cosine_angle = dot_product / magnitudes\n                    angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))  # Clip to handle potential floating-point errors\n\n                    # Straighter paths have smaller angles (closer to 0).\n                    #  Prioritize straighter paths by rewarding small angles.\n                    angle_heuristic += (np.pi - angle) # Increase score as the angle decreases\n                # Average angle heuristic over all potential \"previous\" nodes\n            if n > 2:\n              angle_heuristic /= (n - 2)  # Normalize.  Helps if # of locations dramatically varies\n            heuristic_matrix[i, j] += 0.1* angle_heuristic  # Weight the angle heuristic less than distance.\n\n    #Normalize heuristics for each node\n    for i in range(n):\n        row_sum = np.sum(heuristic_matrix[i,:])\n        if row_sum > 0:\n            heuristic_matrix[i,:] /= row_sum\n\n    return heuristic_matrix\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}