```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    CVRP heuristic combining distance, demand, angle, and depot proximity, with adaptive capacity consideration.
    Emphasizes normalization and sparsification for efficient solution sampling.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))
    
    # Inverse distance heuristic (with small constant to avoid division by zero)
    distance_heuristic = 1.0 / (distance_matrix + 1e-6)

    # Demand-based heuristic
    demand_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_matrix[i, j] = 0
                continue
            demand_matrix[i, j] = 1.0 / (demands[i] + demands[j] + 1e-6)

    # Capacity penalty
    capacity_penalty = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                capacity_penalty[i, j] = 0
                continue
            if (demands[i] + demands[j]) > capacity and i != 0 and j != 0:
                capacity_penalty[i, j] = 0.2  # Increased penalty
            if j == 0 and i != 0:
                capacity_penalty[i, j] = 0.5  # Increased discount for depot connection

    # Angle heuristic (encourage straighter paths)
    angle_heuristic = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                continue

            angle_sum = 0
            for k in range(n):
                if k == i or k == j:
                    continue

                v1 = coordinates[i] - coordinates[k]
                v2 = coordinates[j] - coordinates[i]

                dot_product = np.dot(v1, v2)
                magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)

                if magnitudes > 0:
                    cosine_angle = dot_product / magnitudes
                    angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))
                    angle_sum += (np.pi - angle)

            if n > 2:
                angle_heuristic[i, j] = angle_sum / (n - 2)
            else:
                angle_heuristic[i, j] = 0

    # Depot proximity heuristic
    depot_proximity = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                depot_proximity[i,j] = 0
                continue
            depot_proximity[i, j] = np.exp(-distance_matrix[i, 0] / np.mean(distance_matrix) - distance_matrix[j, 0] / np.mean(distance_matrix)) #Closer to depot -> higher value
            
    # Combine heuristics with weights
    heuristic_matrix = (
        0.5 * distance_heuristic +
        0.1 * demand_matrix +
        0.2 * capacity_penalty +
        0.1 * (1 - angle_heuristic / np.pi) + #smaller angle = better
        0.1 * depot_proximity
    )

    # Normalize heuristics for each node
    for i in range(n):
        row_sum = np.sum(heuristic_matrix[i, :])
        if row_sum > 0:
            heuristic_matrix[i, :] /= row_sum

    # Sparsify: remove edges with low heuristic values (adaptive threshold)
    threshold = np.mean(heuristic_matrix) * 0.3  # Adjusted threshold
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
