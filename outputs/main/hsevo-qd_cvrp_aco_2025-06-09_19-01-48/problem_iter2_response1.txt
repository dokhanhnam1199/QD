```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Combines distance, demand, and angle heuristics with capacity consideration.
    Normalizes the heuristic matrix for better performance.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    distance_matrix = distance_matrix + 1e-6 # Avoid division by zero

    heuristic_matrix = 1.0 / (distance_matrix**2) # Distance heuristic

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0
                continue

            # Capacity penalty
            if (demands[i] + demands[j]) > capacity and i != 0 and j != 0:
                heuristic_matrix[i, j] *= 0.1

            if j == 0 and i != 0:
                heuristic_matrix[i,j] *=0.8

    # Angle Heuristic
    for i in range(n):
        for j in range(n):
            if i == j: continue

            angle_heuristic = 0
            for k in range(n):
                if k == i or k == j: continue

                vector_ki = coordinates[i] - coordinates[k]
                vector_ij = coordinates[j] - coordinates[i]

                dot_product = np.dot(vector_ki, vector_ij)
                magnitudes = np.linalg.norm(vector_ki) * np.linalg.norm(vector_ij)

                if magnitudes > 0:
                    cosine_angle = dot_product / magnitudes
                    angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))

                    angle_heuristic += (np.pi - angle)

            if n > 2:
                angle_heuristic /= (n - 2)
            heuristic_matrix[i, j] += 0.1* angle_heuristic

    # Normalize heuristics
    for i in range(n):
        row_sum = np.sum(heuristic_matrix[i,:])
        if row_sum > 0:
            heuristic_matrix[i,:] /= row_sum

    return heuristic_matrix
```
