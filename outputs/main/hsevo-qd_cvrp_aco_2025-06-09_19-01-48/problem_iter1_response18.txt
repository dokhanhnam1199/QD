```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and angle.

    Combines distance-based desirability with a demand consideration and
    an angle penalty to encourage more clustered routes.

    Args:
        distance_matrix: (n x n) distance matrix.
        coordinates: (n x 2) Euclidean coordinates of nodes.
        demands: (n) vector of customer demands.
        capacity: Vehicle capacity.

    Returns:
        (n x n) matrix of heuristic values.  Higher values indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Avoid division by zero by adding a small constant
    distance_matrix = distance_matrix + 1e-9

    # Distance-based heuristic (inverse distance)
    distance_heuristic = 1 / distance_matrix

    # Demand-based heuristic (penalize edges connecting high-demand nodes)
    # Normalize demands to [0, 1] range
    normalized_demands = demands / np.max(demands)

    # Create demand penalty: high when either node has high demand
    demand_penalty = np.outer(normalized_demands, normalized_demands)
    demand_heuristic = 1 - demand_penalty

    # Angle-based heuristic (encourage turns to closer, less visited nodes)
    angle_heuristic = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                # Calculate angles between vectors depot -> i and depot -> j
                vector_i = coordinates[i] - coordinates[0]
                vector_j = coordinates[j] - coordinates[0]

                # Normalize vectors
                vector_i = vector_i / np.linalg.norm(vector_i)
                vector_j = vector_j / np.linalg.norm(vector_j)

                # Compute cosine of the angle between the vectors
                cos_angle = np.dot(vector_i, vector_j)
                angle = np.arccos(np.clip(cos_angle, -1.0, 1.0)) # arccos output in radians

                angle_heuristic[i, j] = 1 - (angle / np.pi) # Scaling angle to 0-1, so 0 degree = 1, 180 degree = 0

    # Combine the heuristics
    heuristic_matrix = (0.6 * distance_heuristic +
                        0.2 * demand_heuristic +
                        0.2 * angle_heuristic)

    # Make sure to set diagonal elements to 0 (no self-loops)
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
