```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and angle.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Node coordinates (n x 2).
        demands (np.ndarray): Node demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Edge prior indicators (n x n).
    """

    n_nodes = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Scale distance by demand -- penalize edges leading to high demand nodes
    demand_scaled_distance = distance_matrix * (1 + demands / capacity)

    # Angle component: prioritize edges that reduce the total angle swept from depot
    depot_coords = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_coords[1], coordinates[:, 0] - depot_coords[0])

    for i in range(n_nodes):
        for j in range(n_nodes):
            if i == j:
                heuristics[i, j] = 0  # Avoid self-loops
            else:
                # Cost: weighted sum of distance, demand scaling, and angle change
                # small angle change -> good
                angle_diff = np.abs(angles[i] - angles[j])
                angle_diff = np.minimum(angle_diff, 2 * np.pi - angle_diff) # Ensure the smaller angle difference
                heuristics[i, j] = 1 / (demand_scaled_distance[i, j] + 0.1 * angle_diff)

    return heuristics
```
