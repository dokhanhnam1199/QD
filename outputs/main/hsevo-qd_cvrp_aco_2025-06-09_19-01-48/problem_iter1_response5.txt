```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Generates heuristics for CVRP based on distance, demand, and angle.
    Combines distance, demand considerations, and angular proximity to the depot.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate angle to depot
    depot_coords = coordinates[0]
    angles = np.zeros(n)
    for i in range(1, n):
        vector = coordinates[i] - depot_coords
        angles[i] = np.arctan2(vector[1], vector[0])

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance-based heuristic (shorter distances are better)
            distance_heuristic = 1 / distance_matrix[i, j]

            # Demand-based heuristic (penalize high demand when going from depot)
            demand_penalty_i = 1
            demand_penalty_j = 1

            if i == 0:
                 demand_penalty_i = 1 / max(1, demands[j] / capacity) #scale to avoid division by zero
            if j == 0:
                 demand_penalty_j = 1 / max(1, demands[i] / capacity) #scale to avoid division by zero

            # Angle-based heuristic: Prefer routes that minimize sharp turns w.r.t. the depot
            angle_diff = abs(angles[i] - angles[j])
            angle_heuristic = 1 / (1 + min(angle_diff, 2 * np.pi - angle_diff))  # Small angles are better. avoid division by zero.

            # Combine heuristics
            heuristic_matrix[i, j] = distance_heuristic * demand_penalty_i * demand_penalty_j * angle_heuristic


    return heuristic_matrix
```
