```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Generates prior indicators for CVRP edges using a combination of distance,
    demand, and a penalty for exceeding capacity.

    Args:
        distance_matrix: Distance between nodes (n x n).
        coordinates: Node coordinates (n x 2).
        demands: Node demands (n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of heuristic values (n x n). Higher values indicate more
        promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to tune the heuristics.  Experimentation is key.
    alpha = 1.0  # Importance of distance
    beta = 0.5   # Importance of demand proximity (larger = encourages closer demands)
    gamma = 2.0  # Strength of capacity penalty (larger = harsher penalty)
    delta = 0.1  # Small value to prevent division by zero in edge suitability.

    for i in range(n):
        for j in range(n):
            if i != j:  # Avoid self-loops
                distance_factor = alpha / (distance_matrix[i, j] + delta)

                # Encourage edges connecting nodes with complementary demand characteristics.
                #  This is an attempt to build routes which fill vehicles well without overfilling.
                #  If we have demands [10, 20, 30, 40], node 1 (10) would be attracted to node 4 (40) more than node 2.
                demand_proximity = np.exp(-beta * np.abs(demands[i] + demands[j] - capacity))

                # Capacity penalty: Reduces the heuristic value if the sum of demands
                # is high compared to capacity. Makes algorithm prefer edges connecting to
                # nodes whose demand is very small if approaching capacity.
                capacity_penalty = np.exp(-gamma * np.maximum(0, (demands[i] + demands[j]) / capacity - 1))


                heuristic_matrix[i, j] = distance_factor * demand_proximity * capacity_penalty

            else:
                heuristic_matrix[i, j] = 0  # No self-loops

    return heuristic_matrix
```
