```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    CVRP heuristic combining distance, demand, angle, depot proximity, and capacity-aware adjustments with adaptive sparsification.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # 1. Distance Heuristic (Inverse Square)
    distance_heuristic = 1.0 / (distance_matrix + 1e-6)**2
    heuristic_matrix = distance_heuristic.copy()

    # 2. Demand-Based Adjustment
    demand_penalty = np.zeros((n, n))
    for i in range(1, n):  # Exclude depot
        for j in range(1, n):  # Exclude depot
            if i == j:
                continue

            combined_demand = demands[i] + demands[j]

            if combined_demand > capacity:
                demand_penalty[i, j] = -0.9  # Large penalty if exceeding capacity.
            else:
                demand_penalty[i, j] = 0.1 * (1 - (combined_demand / capacity)) #Small reward, scaled relative to capacity. Favor smaller demand pairs.

    heuristic_matrix += demand_penalty


    # 3. Angle Heuristic (Encourage Straighter Paths)
    angle_heuristic = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                continue

            angle_sum = 0
            for k in range(n):
                if k == i or k == j:
                    continue

                v1 = coordinates[i] - coordinates[k]
                v2 = coordinates[j] - coordinates[i]

                dot_product = np.dot(v1, v2)
                magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)

                if magnitudes > 0:
                    cosine_angle = dot_product / magnitudes
                    angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))
                    angle_sum += (np.pi - angle)

            if n > 2:
                angle_heuristic[i, j] = angle_sum / (n - 2)
            else:
                angle_heuristic[i, j] = 0

    heuristic_matrix += 0.1 * angle_heuristic



    # 4. Depot Attraction (Nodes closer to the depot are encouraged)
    depot_attraction = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            depot_attraction[i, j] = (1 / (distance_matrix[i, 0] + 1e-6)) + (1 / (distance_matrix[j, 0] + 1e-6))
    heuristic_matrix += 0.05 * depot_attraction


    # 5. Depot Connection Preference
    depot_connection = np.zeros((n, n))
    for i in range(1, n):  # Iterate through non-depot nodes
        depot_connection[0, i] = 0.2 # Reward connecting depot to other nodes
        depot_connection[i, 0] = 0.2  # Reward connecting other nodes to depot.

    heuristic_matrix += depot_connection

    # 6. Capacity utilization reward for edges connected to the depot
    capacity_utilization_reward = np.zeros((n, n))
    for i in range(1,n):
        capacity_utilization = demands[i] / capacity
        capacity_utilization_reward[0, i] = 0.1 * capacity_utilization # small reward proportional to capacity usage
        capacity_utilization_reward[i, 0] = 0.1 * capacity_utilization

    heuristic_matrix += capacity_utilization_reward


    # 7. Normalize heuristics for each node - Row-wise normalization
    for i in range(n):
        row_sum = np.sum(heuristic_matrix[i, :])
        if row_sum > 0:
            heuristic_matrix[i, :] /= row_sum

    # 8. Adaptive Sparsification
    threshold = np.mean(heuristic_matrix) * 0.5  # More Aggressive Sparsification
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
