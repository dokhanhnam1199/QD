```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics function for the Traveling Salesman Problem (TSP).

    This version combines k-nearest neighbors, penalizes long edges, and ensures connectivity.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix
                                      between cities. distance_matrix[i, j] is the distance
                                      between city i and city j.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix, where each
                    element indicates how promising it is to include that edge in a solution.
                    Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance: Shorter distances are generally more promising.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # 2. Nearest Neighbor Heuristic:
    nearest_neighbors = np.argsort(distance_matrix, axis=1)

    # 3. Combination of Inverse Distance and Nearest Neighbor Information
    k_nearest = min(5, n - 1)  # Consider top k nearest neighbors, ensuring k < n
    for i in range(n):
        for j_index in range(1, k_nearest + 1):  # Start from 1 to exclude the node itself
            j = nearest_neighbors[i, j_index]
            heuristics[i, j] = inverse_distance[i, j]

    # 4. Penalize long edges
    max_distance = np.max(distance_matrix)
    penalty_factor = 0.1  # Adjust the penalty factor as needed
    heuristics = heuristics - (distance_matrix / max_distance) * penalty_factor * np.max(heuristics)
    heuristics[heuristics < 0] = 0

    # 5. Ensure connectivity by adding a small probability to all edges
    # This prevents any node from being completely isolated, ensuring a feasible solution.
    connectivity_bonus = np.mean(inverse_distance) / 1000 # Adjust the bonus factor
    heuristics = heuristics + connectivity_bonus

    # Normalize to make stochastic sampling more stable
    max_heuristic = np.max(heuristics)
    min_heuristic = np.min(heuristics)
    if max_heuristic > min_heuristic:
        heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)
    else:
        heuristics = np.ones_like(heuristics) * 0.5

    return heuristics
```
