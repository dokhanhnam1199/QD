```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using a combination of factors and sparsification.

    Args:
        distance_matrix: A numpy array representing the distance matrix.

    Returns:
        A numpy array of the same shape as distance_matrix, representing the
        prior indicators for each edge.
    """
    n = distance_matrix.shape[0]

    # Initialize the heuristic matrix with inverse distance
    heuristic_matrix = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # Factor 1: Nearest neighbor heuristic
    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:4]  # Find 3 nearest neighbors for each node
    nearest_neighbor_bonus = np.zeros_like(distance_matrix)
    for i in range(n):
        for neighbor in nearest_neighbors[i]:
            nearest_neighbor_bonus[i, neighbor] = 1
    heuristic_matrix = heuristic_matrix + nearest_neighbor_bonus

    # Factor 2: Minimum Spanning Tree (MST) approximation.  Edges in a MST are generally good
    # candidates for TSP solutions.  We don't compute MST directly, but approximate it
    # by emphasizing edges that connect sparsely connected nodes.
    degree = np.sum(distance_matrix > 0, axis=0) # Consider all edges for the purpose of degree.

    degree_bonus = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j and distance_matrix[i,j] > 0:
              degree_bonus[i,j] = 1/(degree[i] + degree[j] + 1e-9) # Edges connecting nodes with small degree should be favored

    heuristic_matrix = heuristic_matrix + degree_bonus

    # Sparsification: Zero out edges that are significantly longer than average
    average_distance = np.mean(distance_matrix[distance_matrix > 0])
    threshold = 3 * average_distance
    heuristic_matrix[distance_matrix > threshold] = 0
    heuristic_matrix[distance_matrix == 0] = 0 # Remove 0 distance
    # Normalize heuristic values (optional but can be helpful)
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        heuristic_matrix = heuristic_matrix / max_heuristic

    return heuristic_matrix
```
