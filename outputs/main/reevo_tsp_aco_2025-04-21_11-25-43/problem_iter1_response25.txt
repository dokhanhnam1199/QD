```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This version combines several factors to determine how promising it is to select an edge,
    including distance, node degree, and global average distance. It also sparsifies the matrix
    by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix
                                        between cities. distance_matrix[i][j] gives the
                                        distance between city i and city j.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix, where each
                    element represents the prior indicator of how promising it is to
                    include the corresponding edge in a solution.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Calculate degree centrality for each node based on inverse distance
    degree_centrality = np.sum(1 / (distance_matrix + 1e-9), axis=1)

    # Calculate the average distance in the matrix
    avg_distance = np.mean(distance_matrix)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Combine distance, degree centrality, and global average distance
                heuristics[i, j] = (
                    1 / (distance_matrix[i, j] + 1e-9)
                    * (degree_centrality[i] + degree_centrality[j])
                    / 2  # Average degree centrality of the two nodes
                    * (avg_distance / (distance_matrix[i, j] + 1e-9)) # Higher if distance is smaller than avg.
                )

    # Sparsify the matrix: Zero out edges that are significantly longer than average.
    threshold = 0.75 * np.mean(heuristics[heuristics > 0]) # dynamic threshold
    heuristics[heuristics < threshold] = 0 # zero out values below the threshold

    # Optional: Enhance diversity by penalizing edges connected to nodes with already many potentially chosen edges
    num_candidate_edges = np.sum(heuristics > 0, axis=1)
    for i in range(n):
        for j in range(n):
            if i != j and heuristics[i, j] > 0:
                 heuristics[i,j] /= (num_candidate_edges[i] + num_candidate_edges[j]) / 2


    return heuristics
```
