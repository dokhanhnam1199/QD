```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for TSP based on distance, degree centrality, sparsification, and adaptive thresholding.
    """
    n = distance_matrix.shape[0]

    # Initialize the heuristic matrix with the inverse square of the distance
    heuristic_matrix = 1 / (distance_matrix**2 + 1e-9)

    # Row-wise normalization
    for i in range(n):
        row_sum = np.sum(heuristic_matrix[i, :])
        if row_sum > 0:
            heuristic_matrix[i, :] /= row_sum

    # Degree centrality heuristic (using inverse distance for degree)
    degree_centrality = np.sum(1 / (distance_matrix + 1e-9), axis=1)

    # Adaptive sparsification based on node degree
    avg_distance = np.mean(distance_matrix)
    for i in range(n):
        # Threshold adapts to how connected the node is (higher degree -> lower threshold)
        sparsification_threshold = avg_distance * (1 + 0.5 * (1 - degree_centrality[i] / np.max(degree_centrality)))
        for j in range(n):
            if distance_matrix[i, j] > sparsification_threshold:
                heuristic_matrix[i, j] = 0

    # Geometric mean centrality penalty
    centrality_matrix = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                centrality_matrix[i, j] = np.sqrt(degree_centrality[i] * degree_centrality[j])

    # Combine with centrality cautiously
    heuristic_matrix *= (1 / (centrality_matrix + 1))
    
    # Another round of row-wise normalization
    for i in range(n):
        row_sum = np.sum(heuristic_matrix[i, :])
        if row_sum > 0:
            heuristic_matrix[i, :] /= row_sum


    # Ensure diagonal is zero for TSP
    for i in range(n):
        heuristic_matrix[i, i] = 0

    # Final normalization to 0-1 range for consistency
    max_val = np.max(heuristic_matrix)
    min_val = np.min(heuristic_matrix)

    if max_val > min_val:
        heuristic_matrix = (heuristic_matrix - min_val) / (max_val - min_val)
    else:
        heuristic_matrix = np.ones_like(heuristic_matrix) * 0.5

    return heuristic_matrix
```
