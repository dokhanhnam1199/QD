```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) that
    combines multiple factors to estimate the suitability of each edge
    in a potential TSP solution.

    The returned matrix indicates how promising each edge is, with higher
    values signifying greater promise. The function incorporates
    distance, node degree (preference for less-connected nodes), and
    a randomness factor to explore diverse solutions. Elements can be
    set to zero to sparsify the search space based on distance thresholds.

    Args:
        distance_matrix (np.ndarray): A square, symmetric matrix representing
                                       the distances between cities.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix,
                    indicating the prior probability/promise of each edge
                    being part of a good TSP tour.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Inverse distance - closer cities are generally better
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # Node degree preference - encourages exploration of less-connected nodes
    # Initially, assume all nodes are equally preferred
    node_preference = np.ones(n)

    # Iterate through all possible edges
    for i in range(n):
        for j in range(i + 1, n):  # Only consider upper triangle since matrix is symmetric
            # Combine factors: inverse distance and node preference
            heuristic_matrix[i, j] = inverse_distance[i, j] * node_preference[i] * node_preference[j]

            # Add some randomness to encourage exploration -  remove to benchmark
            heuristic_matrix[i, j] += np.random.rand() * 0.1
            
            # Sparsify the matrix: set unpromising elements to zero
            # (Example: remove edges longer than a certain percentile)
            distance_threshold = np.percentile(distance_matrix, 75) #consider top 75%
            if distance_matrix[i, j] > distance_threshold:
                heuristic_matrix[i, j] = 0


    # Ensure symmetry
    heuristic_matrix = heuristic_matrix + heuristic_matrix.T

    return heuristic_matrix
```
