{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Worse code]\ndef heuristics_v0(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP).\n\n    This version combines several factors to determine how promising it is to select an edge,\n    including distance, node degree, and global average distance. It also sparsifies the matrix\n    by setting unpromising elements to zero.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix\n                                        between cities. distance_matrix[i][j] gives the\n                                        distance between city i and city j.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix, where each\n                    element represents the prior indicator of how promising it is to\n                    include the corresponding edge in a solution.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix, dtype=float)\n\n    # Calculate degree centrality for each node based on inverse distance\n    degree_centrality = np.sum(1 / (distance_matrix + 1e-9), axis=1)\n\n    # Calculate the average distance in the matrix\n    avg_distance = np.mean(distance_matrix)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Combine distance, degree centrality, and global average distance\n                heuristics[i, j] = (\n                    1 / (distance_matrix[i, j] + 1e-9)\n                    * (degree_centrality[i] + degree_centrality[j])\n                    / 2  # Average degree centrality of the two nodes\n                    * (avg_distance / (distance_matrix[i, j] + 1e-9)) # Higher if distance is smaller than avg.\n                )\n\n    # Sparsify the matrix: Zero out edges that are significantly longer than average.\n    threshold = 0.75 * np.mean(heuristics[heuristics > 0]) # dynamic threshold\n    heuristics[heuristics < threshold] = 0 # zero out values below the threshold\n\n    # Optional: Enhance diversity by penalizing edges connected to nodes with already many potentially chosen edges\n    num_candidate_edges = np.sum(heuristics > 0, axis=1)\n    for i in range(n):\n        for j in range(n):\n            if i != j and heuristics[i, j] > 0:\n                 heuristics[i,j] /= (num_candidate_edges[i] + num_candidate_edges[j]) / 2\n\n\n    return heuristics\n\n[Better code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for TSP using a combination of factors and sparsification.\n\n    Args:\n        distance_matrix (np.ndarray): A distance matrix representing the distances between nodes.\n\n    Returns:\n        np.ndarray: A matrix of the same shape as the distance matrix,\n                    where each element represents the desirability of including\n                    the corresponding edge in a TSP tour.  Higher values\n                    indicate more desirable edges. Zero values indicate\n                    edges that are highly unlikely to be in a good solution.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix, dtype=float)\n\n    # 1. Inverse distance: Shorter distances are more desirable\n    inverse_distance = 1 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero\n\n    # 2. Nearest neighbor heuristic: Prefer edges to nearest neighbors\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)\n    neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(1, min(4,n)): #Consider only the top 3 nearest neighbours\n            neighbor = nearest_neighbors[i,j]\n            neighbor_bonus[i, neighbor] = 1.0 / j  #Give a bonus to nearer neighbours\n\n    # 3. Avoid long edges connected to nodes with already many short edges\n    node_degree_penalty = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        connected_edges = inverse_distance[i, :]\n        num_short_edges = np.sum(connected_edges > np.mean(connected_edges)) #Simple way of checking amount of \"short\" edges connected to node i\n        for j in range(n):\n             node_degree_penalty[i,j] = (num_short_edges / n) if distance_matrix[i,j] > np.mean(distance_matrix[i,:]) else 0 # Penalize if we already have many edges\n\n\n    # Combine the factors: You can adjust the weights as needed\n    heuristics = (0.6 * inverse_distance + 0.3 * neighbor_bonus - 0.1 * node_degree_penalty)\n\n    #Sparsify the matrix. Zero-out less promissing edges\n    threshold = np.percentile(heuristics[np.triu_indices_from(heuristics, k=1)], 40)  # Remove bottom 40% edges. Exclude diagonal elements\n    heuristics[heuristics < threshold] = 0\n\n    # Ensure symmetry in the heuristic matrix (if the distance matrix is symmetric)\n    heuristics = (heuristics + heuristics.T) / 2\n\n    np.fill_diagonal(heuristics, 0)  # Ensure no self-loops\n    return heuristics\n\n[Reflection]\nFocus on nearest neighbors, balance penalties/rewards, sparsify effectively, and ensure symmetry.\n\n\n[Improved code]\nPlease write an improved function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}