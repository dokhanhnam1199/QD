```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using nearest neighbors, balanced penalties/rewards,
    effective sparsification, and symmetry.

    Args:
        distance_matrix (np.ndarray): A distance matrix representing the distances between nodes.

    Returns:
        np.ndarray: A matrix of the same shape as the distance matrix,
                    where each element represents the desirability of including
                    the corresponding edge in a TSP tour. Higher values
                    indicate more desirable edges. Zero values indicate
                    edges that are highly unlikely to be in a good solution.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance: Shorter distances are more desirable
    inverse_distance = 1 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero

    # 2. Nearest neighbor heuristic: Prefer edges to nearest neighbors
    nearest_neighbors = np.argsort(distance_matrix, axis=1)
    neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(1, min(5, n)):  # Consider the top 4 nearest neighbors
            neighbor = nearest_neighbors[i, j]
            neighbor_bonus[i, neighbor] = 1.0 / j  # Give a bonus to nearer neighbors

    # 3. Node degree penalty: Penalize nodes with many potentially chosen edges
    node_degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    potential_edges = inverse_distance > np.mean(inverse_distance) # Consider edges with above-average inverse distance as "potential"
    num_potential_edges = np.sum(potential_edges, axis=1)

    for i in range(n):
        for j in range(n):
            node_degree_penalty[i, j] = num_potential_edges[i] / (n - 1)  # Normalize by max possible degree


    # Combine the factors with adjusted weights
    heuristics = (0.5 * inverse_distance + 0.4 * neighbor_bonus - 0.1 * node_degree_penalty)

    # Sparsify the matrix: Zero-out less promising edges
    threshold = np.percentile(heuristics[np.triu_indices_from(heuristics, k=1)], 50)  # Remove bottom 50% edges. Exclude diagonal elements
    heuristics[heuristics < threshold] = 0

    # Ensure symmetry in the heuristic matrix (if the distance matrix is symmetric)
    heuristics = (heuristics + heuristics.T) / 2

    np.fill_diagonal(heuristics, 0)  # Ensure no self-loops
    return heuristics
```
