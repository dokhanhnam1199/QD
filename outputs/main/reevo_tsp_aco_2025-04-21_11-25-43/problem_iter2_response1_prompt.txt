{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Worse code]\ndef heuristics_v0(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP) using a combination of factors\n    and sparsification.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix.\n                                       distance_matrix[i][j] gives the distance between node i and node j.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n                    representing the heuristic values for each edge. Higher values indicate more promising edges.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Calculate nearest neighbor for each node\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:4]  # Top 3 nearest neighbors (excluding itself)\n\n    # Heuristic: Combine inverse distance with nearest neighbor information.\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                inverse_distance = 1 / distance_matrix[i, j]\n\n                # Give a bonus if the edge connects to a nearest neighbor.  Also penalize long edges more\n                if j in nearest_neighbors[i]:\n                    heuristic_matrix[i, j] = inverse_distance * 2 #increased weighting\n                else:\n                    heuristic_matrix[i, j] = inverse_distance\n\n    # Sparsify the matrix: keep only the most promising edges\n    # Based on global threshold\n    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 75)  # Adjust percentile as needed\n\n    # Or based on local threshold (for each row) - more dynamic\n    for i in range(n):\n      row_threshold = np.percentile(heuristic_matrix[i, :][heuristic_matrix[i, :] > 0], 50)\n      for j in range(n):\n        if heuristic_matrix[i,j] < row_threshold:\n          heuristic_matrix[i,j] = 0\n\n    # Ensure symmetry (TSP is usually undirected)\n    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2\n\n    return heuristic_matrix\n\n[Better code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristics function for the Traveling Salesman Problem (TSP).\n\n    This version combines several factors to determine the \"promisingness\" of each edge\n    and sparsifies the matrix by setting unpromising elements to zero.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix\n                                      between cities.  distance_matrix[i, j] is the distance\n                                      between city i and city j.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix, where each\n                    element indicates how promising it is to include that edge in a solution.\n                    Higher values indicate more promising edges.  Unpromising edges will\n                    have a value of 0.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix, dtype=float)\n\n    # 1. Inverse Distance: Shorter distances are generally more promising.\n    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero\n\n    # 2. Nearest Neighbor Heuristic:\n    #    For each city, find its nearest neighbors. Edges to nearest neighbors are promising.\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)\n\n    # 3. Sparsification and Combination:\n    #    Only consider edges to the k nearest neighbors as potentially promising.\n    #    Combine inverse distance and nearest neighbor information.\n    k_nearest = 5  # Consider top 5 nearest neighbors\n    for i in range(n):\n        for j_index in range(k_nearest):\n            j = nearest_neighbors[i, j_index]\n            heuristics[i, j] = inverse_distance[i, j]  # Assign inverse distance if a nearest neighbor\n    # 4. Penalize edges that are part of very long edges\n    max_distance = np.max(distance_matrix)\n    penalty_factor = 0.1 # Reduce weight of long distances instead of making them 0 to ensure path exists\n    heuristics = heuristics - (distance_matrix/ max_distance)*penalty_factor*np.max(heuristics)\n    heuristics[heuristics < 0] = 0\n    #Ensure each node has at least one outgoing path to any other node by reseting zero rows and columns to small probability\n\n    row_sums = np.sum(heuristics, axis=1)\n    col_sums = np.sum(heuristics, axis=0)\n    for i in range(n):\n        if row_sums[i] == 0:\n            for j in range(n):\n                if i!=j:\n                  heuristics[i,j] = np.mean(inverse_distance[i,:]) /100\n\n        if col_sums[i] == 0:\n            for j in range(n):\n                if i!=j:\n                  heuristics[j,i] =  np.mean(inverse_distance[:,i])/100\n    return heuristics\n\n[Reflection]\nConsider k-nearest neighbors, penalize long edges, and ensure connectivity. Avoid hard thresholds and local percentiles.\n\n\n[Improved code]\nPlease write an improved function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}