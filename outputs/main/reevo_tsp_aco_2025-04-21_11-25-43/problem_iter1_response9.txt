```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using stochastic solution sampling principles.

    Combines several factors to determine the desirability of including each edge in a solution:
    - Inverse distance: Shorter edges are generally more desirable.
    - Node degree:  Edges connecting to nodes with few connections are favored
      to ensure all nodes are visited.
    - Sparsification: Removes very long edges early on to focus on promising regions.
    - Randomness: Introduces a bit of stochasticity to avoid being trapped in local optima.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances
                                         between cities.  distance_matrix[i][j] is the
                                         distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, containing
                    heuristic values indicating the desirability of including each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance (Shorter edges are better)
    inverse_distance = 1.0 / (distance_matrix + 1e-6)  # Add a small constant to avoid division by zero

    # 2. Node Degree Encouragement (Prioritize connecting isolated nodes)
    #    Initially, assume each node has a low degree (all nodes are isolated at first)
    node_degree_penalty = np.ones((n, n))

    # 3. Sparsification (Remove long edges based on a dynamically adjusted threshold)
    threshold = np.mean(distance_matrix[distance_matrix > 0]) * 2  # Adaptive threshold based on mean distance
    sparsified_matrix = np.where(distance_matrix <= threshold, 1, 0)  # Binary matrix indicating allowed edges

    # 4. Randomness (Introduce stochasticity)
    random_factor = np.random.rand(n, n) * 0.1  # Small random values to diversify choices

    # Combine factors to create the heuristic matrix
    heuristic_matrix = inverse_distance * node_degree_penalty * sparsified_matrix + random_factor
    #Ensure diagonals are zero
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
