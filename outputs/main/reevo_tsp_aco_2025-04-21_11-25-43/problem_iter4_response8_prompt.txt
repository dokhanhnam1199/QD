{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Worse code]\ndef heuristics_v0(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP) using a combination of factors.\n\n    This function calculates a heuristic matrix where each element indicates how promising\n    it is to include the corresponding edge in a TSP solution. It combines inverse distance,\n    nearest neighbor information, and a random component.  The heuristic matrix is then\n    sparsified by setting less promising values to zero.\n\n    Args:\n        distance_matrix (np.ndarray): A square matrix representing the distances between cities.\n\n    Returns:\n        np.ndarray: A heuristic matrix of the same shape as the distance matrix,\n                      indicating the desirability of including each edge in a TSP solution.\n                      Higher values indicate more promising edges.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # 1. Inverse distance: shorter distances are generally better\n    heuristic_matrix = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero\n\n    # 2. Nearest neighbor heuristic: prioritize connecting to nearest neighbors\n    for i in range(n):\n        # Find the indices of the k-nearest neighbors for node i, excluding itself\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:4] #Top 3 nearest neighbors\n\n        # Boost the heuristic value for edges connecting to nearest neighbors\n        for neighbor in nearest_neighbors:\n            heuristic_matrix[i, neighbor] *= 2.0 # boost, but only if the neighbor is not itself\n            heuristic_matrix[neighbor, i] *= 2.0\n\n\n    # 3. Random perturbation: Introduce some randomness to avoid getting stuck in local optima\n    random_matrix = np.random.rand(n, n) * 0.1 # small random numbers\n    heuristic_matrix += random_matrix\n\n    # 4. Sparsification: Remove less promising edges to reduce search space\n    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.2)  # Keep top 80% edges\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    # Ensure that diagonal elements are zero, as they represent self-loops\n    np.fill_diagonal(heuristic_matrix, 0)\n\n    return heuristic_matrix\n\n[Better code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristics for TSP based on distance, degree centrality, adaptive sparsification, and randomness.\n    \"\"\"\n    n = distance_matrix.shape[0]\n\n    # Initialize the heuristic matrix with the inverse of the distance\n    heuristic_matrix = 1 / (distance_matrix + 1e-9)\n\n    # Degree centrality heuristic\n    degree_centrality = np.sum(1 / (distance_matrix + 1e-9), axis=1)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristic_matrix[i, j] *= (degree_centrality[i] + degree_centrality[j]) / 2\n\n    # Adaptive Sparsification: dynamically adjust the threshold based on local distances\n    for i in range(n):\n        # Calculate the average distance for each node\n        avg_distance_i = np.mean(distance_matrix[i, :])\n        for j in range(n):\n            if i != j:\n                # Sparsification threshold is based on both global and local average distances\n                sparsification_threshold = 1.5 * (avg_distance_i + np.mean(distance_matrix)) / 2 # Adjusted threshold\n                if distance_matrix[i, j] > sparsification_threshold:\n                    heuristic_matrix[i, j] = 0\n\n    # Distance emphasis\n    heuristic_matrix = heuristic_matrix / (distance_matrix**1.5 + 1e-9)\n\n    # Add some randomness to avoid getting stuck in local optima\n    randomness_factor = 0.05  # Adjust the level of randomness\n    heuristic_matrix += randomness_factor * np.random.rand(n, n)\n\n    # Symmetry: ensure the matrix is symmetric\n    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2\n\n    # Normalize the heuristic matrix\n    max_val = np.max(heuristic_matrix)\n    min_val = np.min(heuristic_matrix)\n\n    if max_val > min_val:\n        heuristic_matrix = (heuristic_matrix - min_val) / (max_val - min_val)\n    else:\n        heuristic_matrix = np.ones_like(heuristic_matrix) * 0.5\n\n    return heuristic_matrix\n\n[Reflection]\nAdaptive sparsification, degree centrality, distance emphasis, and normalization improve heuristic quality.\n\n\n[Improved code]\nPlease write an improved function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}