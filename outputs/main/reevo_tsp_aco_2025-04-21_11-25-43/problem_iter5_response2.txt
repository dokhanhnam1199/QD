```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for TSP based on adaptive sparsification, distance,
    node degree, and geometric mean centrality.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Inverse distance as a base
    heuristic_matrix = 1.0 / (distance_matrix + 1e-9)

    # Node degree centrality (sum of inverse distances)
    degree_centrality = np.sum(1.0 / (distance_matrix + 1e-9), axis=1)

    # Geometric mean centrality (product of inverse distances)
    geometric_centrality = np.prod(1.0 / (distance_matrix + 1e-9), axis=1, where=distance_matrix != 0)  # Avoid multiplying by zero
    geometric_centrality[~np.isfinite(geometric_centrality)] = 0  # Handle potential inf/NaN values

    # Combine degree and geometric centrality
    combined_centrality = (degree_centrality + geometric_centrality) / 2.0

    # Incorporate centrality into the heuristic
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] *= (combined_centrality[i] + combined_centrality[j]) / 2.0

    # Adaptive sparsification based on percentile threshold
    distances = distance_matrix[np.triu_indices_from(distance_matrix, k=1)]  # Upper triangle to avoid duplicates
    threshold_percentile = 75  # Adjust for desired sparsity
    threshold_distance = np.percentile(distances, threshold_percentile)

    # Apply sparsification
    heuristic_matrix[distance_matrix > threshold_distance] = 0

    # Local normalization (row-wise mean) - avoids domination by single large values
    row_means = np.mean(heuristic_matrix, axis=1, keepdims=True)
    heuristic_matrix = heuristic_matrix / (row_means + 1e-9)

    # Controlled randomness for exploration
    randomness_factor = 0.01 # Adjust randomness
    random_matrix = np.random.rand(n, n) * randomness_factor
    heuristic_matrix += random_matrix

    # Normalize the entire matrix to [0, 1]
    max_val = np.max(heuristic_matrix)
    min_val = np.min(heuristic_matrix)

    if max_val > min_val:
        heuristic_matrix = (heuristic_matrix - min_val) / (max_val - min_val)
    else:
        heuristic_matrix = np.ones_like(heuristic_matrix) * 0.5

    return heuristic_matrix
```
