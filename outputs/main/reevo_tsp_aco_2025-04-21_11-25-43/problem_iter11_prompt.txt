{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Prior reflection]\nPrioritize adaptive sparsification using inverse distance and centrality. Employ local normalization and control randomness. Refine thresholds and weighting exponents for balanced exploration-exploitation. Tune parameters iteratively for optimal performance.\n- Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\n\n[Code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristics for TSP based on adaptive sparsification, degree centrality,\n    distance-squared scaling, local normalization, and geometric mean centrality.\n    \"\"\"\n    n = distance_matrix.shape[0]\n\n    # Initialize heuristic matrix with inverse distance, avoid division by zero.\n    heuristic_matrix = 1 / (distance_matrix + 1e-9)\n\n    # Degree centrality heuristic (sum of inverse distances).\n    degree_centrality = np.sum(1 / (distance_matrix + 1e-9), axis=1)\n\n    # Geometric mean centrality\n    geometric_mean_centrality = np.power(np.prod(1 / (distance_matrix + 1e-9), axis=1), 1/ (n - 1))\n\n\n    # Combine degree centrality and geometric mean centrality\n    combined_centrality = (degree_centrality + geometric_mean_centrality) / 2\n\n    # Incorporate centrality into the heuristic.\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristic_matrix[i, j] *= (combined_centrality[i] + combined_centrality[j]) / 2\n\n    # Adaptive sparsification using percentile threshold.\n    threshold_percentile = 75  # Adjust percentile for sparsification.\n    threshold = np.percentile(distance_matrix[distance_matrix > 0], threshold_percentile) # consider only positive distances\n\n    # Sparsify based on the threshold.\n    sparse_mask = distance_matrix > threshold\n    heuristic_matrix[sparse_mask] = 0\n\n    # Distance-squared scaling to penalize longer edges.\n    heuristic_matrix = heuristic_matrix / (distance_matrix**2 + 1e-9)\n\n    # Local normalization: Normalize each row to [0, 1].\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        max_val = np.max(row)\n        min_val = np.min(row)\n        if max_val > min_val:\n            heuristic_matrix[i, :] = (row - min_val) / (max_val - min_val)\n        else:\n            heuristic_matrix[i, :] = np.ones_like(row) * 0.5  # Handle cases with identical values\n\n    return heuristic_matrix\n\n[Improved code]\nPlease write a mutated function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}