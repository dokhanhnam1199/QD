```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using a combination of factors and sparsification.

    Args:
        distance_matrix: A numpy array representing the distance matrix.

    Returns:
        A numpy array of the same shape as the distance matrix, representing
        the heuristic values for each edge. Higher values indicate a more
        promising edge.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance (shorter distances are more promising)
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add small value to avoid division by zero

    # 2. Node degree desirability (penalize edges connecting to nodes with high degree)
    degree_desirability = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Calculate average distance from node i and node j to other nodes
                avg_dist_i = np.mean(distance_matrix[i, :])
                avg_dist_j = np.mean(distance_matrix[j, :])

                # Higher degree means shorter distance from the current node to other nodes,
                # so use 1 / avg_dist to represent the degree penalty factor.
                degree_desirability[i, j] = (1 / (avg_dist_i + 1e-9) + 1 / (avg_dist_j + 1e-9)) / 2.0

    # 3. Combination and Normalization
    heuristics = inverse_distance * degree_desirability

    # Normalize heuristics
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics = heuristics / max_heuristic

    # 4. Sparsification (set unpromising edges to zero)
    threshold = np.quantile(heuristics[heuristics > 0], 0.25)  # Keep top 75% of edges with value > 0

    heuristics[heuristics < threshold] = 0

    return heuristics
```
