```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using a combination of factors and sparsification.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix,
                    representing the prior indicators for each edge.  Higher values
                    indicate a more promising edge.
    """

    n = distance_matrix.shape[0]

    # Initialize heuristic matrix with inverse distance
    heuristic_matrix = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # Incorporate a "shortest link preference"
    min_distances = np.zeros(n)
    for i in range(n):
        min_distances[i] = np.partition(distance_matrix[i, :], 1)[1] # Second smallest as smallest will be self

    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] *= (min_distances[i] * min_distances[j]) / (distance_matrix[i,j] + 1e-9)


    # Sparsify the heuristic matrix: keep only the most promising edges for each node
    threshold = np.zeros(n)
    for i in range(n):
        threshold[i] = np.partition(heuristic_matrix[i, :], max(1,n//4)) [max(1,n//4)] # nth smallest, hence threshold

    for i in range(n):
        for j in range(n):
            if heuristic_matrix[i, j] < threshold[i]:
                heuristic_matrix[i, j] = 0

    # Ensure symmetry (important for some TSP solvers and makes sense heuristically)
    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2

    np.fill_diagonal(heuristic_matrix, 0)  # Remove self-loops
    return heuristic_matrix
```
