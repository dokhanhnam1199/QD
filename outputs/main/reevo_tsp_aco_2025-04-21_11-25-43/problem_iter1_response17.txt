```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling.

    This function combines several factors to estimate the desirability of including each edge in a TSP solution.
    It considers inverse distance, node degree (favors nodes with fewer close neighbors),
    and a penalty for long edges connecting to already connected nodes (discourages long detours).

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i, j] represents the distance
                                          between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element indicates the prior
                      probability or desirability of including the corresponding edge in a TSP solution.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance (shorter edges are generally better)
    inverse_distance = 1.0 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero

    # Node degree component: penalize edges connecting nodes with many nearby neighbors. Encourages exploring further destinations
    degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        # Find indices of sorted distances from city i.
        sorted_indices = np.argsort(distance_matrix[i, :])

        # Number of "neighbors" to consider for each city.  Larger values cause smaller components.
        num_neighbors = min(5, n)  # Limited to avoid making this too strong, also to ensure it works well on small TSP examples
        nearby_cities = sorted_indices[1:num_neighbors + 1]  # Exclude itself.

        # Higher value if the edge isn't a nearby edge.  So degree_penalty[i,j] should be low if j is close to i.
        for j in range(n):
            if j in nearby_cities:
                degree_penalty[i, j] = 0.2 # slightly penalize near cities
            else:
                degree_penalty[i, j] = 1.0 # encourage farther out cities

    # Combine the factors, weighting them
    heuristic_matrix = inverse_distance * degree_penalty

    # Make diagonal zeros
    for i in range(n):
        heuristic_matrix[i, i] = 0.0

    return heuristic_matrix
```
