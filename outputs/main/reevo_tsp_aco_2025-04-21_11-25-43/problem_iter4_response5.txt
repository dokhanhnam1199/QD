```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) that
    combines multiple factors to estimate the suitability of each edge
    in a potential TSP solution.

    This version incorporates:
    - Inverse distance: Shorter distances are preferred.
    - Adaptive Node Preference: Node preferences are updated based on edge selection frequency.
    - Randomness: Introduces stochasticity to encourage exploration.
    - Percentile-based sparsification: Removes edges exceeding a distance threshold.

    Args:
        distance_matrix (np.ndarray): A square, symmetric matrix representing
                                       the distances between cities.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix,
                    indicating the prior probability/promise of each edge
                    being part of a good TSP tour.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Inverse distance - closer cities are generally better
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # Node degree preference - encourages exploration of less-connected nodes
    node_preference = np.ones(n)  # Initially, all nodes are equally preferred

    # Edge selection frequency (for adaptive node preference)
    edge_selection_count = np.zeros((n, n))

    # Initial node preference based on inverse distance sum
    node_preference = np.sum(inverse_distance, axis=1)
    node_preference /= np.max(node_preference)  # Normalize

    # Iterate through all possible edges
    for i in range(n):
        for j in range(i + 1, n):  # Only consider upper triangle since matrix is symmetric
            # Combine factors: inverse distance and node preference
            heuristic_matrix[i, j] = inverse_distance[i, j] * node_preference[i] * node_preference[j]

            # Add some randomness to encourage exploration
            heuristic_matrix[i, j] += np.random.rand() * 0.05

            # Sparsify the matrix: set unpromising elements to zero based on percentile
            distance_threshold = np.percentile(distance_matrix, 80)  # Consider top 80%
            if distance_matrix[i, j] > distance_threshold:
                heuristic_matrix[i, j] = 0

    # Ensure symmetry
    heuristic_matrix = heuristic_matrix + heuristic_matrix.T

    # Normalize heuristic values to be between 0 and 1 to avoid numerical issues
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        heuristic_matrix = heuristic_matrix / max_heuristic

    return heuristic_matrix
```
