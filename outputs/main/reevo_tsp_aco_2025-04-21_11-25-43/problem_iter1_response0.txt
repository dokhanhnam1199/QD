```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics function for the Traveling Salesman Problem (TSP).

    This version combines several factors to determine the "promisingness" of each edge
    and sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix
                                      between cities.  distance_matrix[i, j] is the distance
                                      between city i and city j.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix, where each
                    element indicates how promising it is to include that edge in a solution.
                    Higher values indicate more promising edges.  Unpromising edges will
                    have a value of 0.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance: Shorter distances are generally more promising.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # 2. Nearest Neighbor Heuristic:
    #    For each city, find its nearest neighbors. Edges to nearest neighbors are promising.
    nearest_neighbors = np.argsort(distance_matrix, axis=1)

    # 3. Sparsification and Combination:
    #    Only consider edges to the k nearest neighbors as potentially promising.
    #    Combine inverse distance and nearest neighbor information.
    k_nearest = 5  # Consider top 5 nearest neighbors
    for i in range(n):
        for j_index in range(k_nearest):
            j = nearest_neighbors[i, j_index]
            heuristics[i, j] = inverse_distance[i, j]  # Assign inverse distance if a nearest neighbor
    # 4. Penalize edges that are part of very long edges
    max_distance = np.max(distance_matrix)
    penalty_factor = 0.1 # Reduce weight of long distances instead of making them 0 to ensure path exists
    heuristics = heuristics - (distance_matrix/ max_distance)*penalty_factor*np.max(heuristics)
    heuristics[heuristics < 0] = 0
    #Ensure each node has at least one outgoing path to any other node by reseting zero rows and columns to small probability

    row_sums = np.sum(heuristics, axis=1)
    col_sums = np.sum(heuristics, axis=0)
    for i in range(n):
        if row_sums[i] == 0:
            for j in range(n):
                if i!=j:
                  heuristics[i,j] = np.mean(inverse_distance[i,:]) /100

        if col_sums[i] == 0:
            for j in range(n):
                if i!=j:
                  heuristics[j,i] =  np.mean(inverse_distance[:,i])/100
    return heuristics
```
