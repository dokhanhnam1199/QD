```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using a combination of factors and sparsification.

    Args:
        distance_matrix (np.ndarray): A distance matrix representing the distances between nodes.

    Returns:
        np.ndarray: A matrix of the same shape as the distance matrix,
                    where each element represents the desirability of including
                    the corresponding edge in a TSP tour.  Higher values
                    indicate more desirable edges. Zero values indicate
                    edges that are highly unlikely to be in a good solution.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance: Shorter distances are more desirable
    inverse_distance = 1 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero

    # 2. Nearest neighbor heuristic: Prefer edges to nearest neighbors
    nearest_neighbors = np.argsort(distance_matrix, axis=1)
    neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(1, min(4,n)): #Consider only the top 3 nearest neighbours
            neighbor = nearest_neighbors[i,j]
            neighbor_bonus[i, neighbor] = 1.0 / j  #Give a bonus to nearer neighbours

    # 3. Avoid long edges connected to nodes with already many short edges
    node_degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        connected_edges = inverse_distance[i, :]
        num_short_edges = np.sum(connected_edges > np.mean(connected_edges)) #Simple way of checking amount of "short" edges connected to node i
        for j in range(n):
             node_degree_penalty[i,j] = (num_short_edges / n) if distance_matrix[i,j] > np.mean(distance_matrix[i,:]) else 0 # Penalize if we already have many edges


    # Combine the factors: You can adjust the weights as needed
    heuristics = (0.6 * inverse_distance + 0.3 * neighbor_bonus - 0.1 * node_degree_penalty)

    #Sparsify the matrix. Zero-out less promissing edges
    threshold = np.percentile(heuristics[np.triu_indices_from(heuristics, k=1)], 40)  # Remove bottom 40% edges. Exclude diagonal elements
    heuristics[heuristics < threshold] = 0

    # Ensure symmetry in the heuristic matrix (if the distance matrix is symmetric)
    heuristics = (heuristics + heuristics.T) / 2

    np.fill_diagonal(heuristics, 0)  # Ensure no self-loops
    return heuristics
```
