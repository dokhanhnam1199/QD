```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling.

    Combines multiple factors to determine the prior probability of including each edge in a solution.
    Sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i, j] represents the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element represents the prior probability of including the corresponding edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Factor 1: Inverse distance (shorter edges are more promising)
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # Factor 2: Node degree (encourage edges connected to nodes with few connections)
    node_degree = np.sum(inverse_distance, axis=0)
    node_degree_matrix = np.outer(node_degree, node_degree)
    degree_factor = 1 / (node_degree_matrix + 1e-9) #low node_degree_matrix values gives higher edge probability

    # Factor 3: Encourage connection to the farthest away node to promote exploration of all nodes early
    min_dist = np.min(distance_matrix + np.diag([np.inf]*n))
    max_dist = np.max(distance_matrix + np.diag([np.NINF]*n))

    # Factor 4: Combination of all factors

    heuristic_matrix = inverse_distance * degree_factor


    # Sparsify the matrix (set unpromising edges to zero)
    threshold = np.percentile(heuristic_matrix[np.triu_indices_from(heuristic_matrix, k=1)], 40)  # Consider only top 60% edges
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
