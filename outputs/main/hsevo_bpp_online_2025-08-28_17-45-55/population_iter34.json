[
  {
    "stdout_filepath": "problem_iter32_response0.txt_stdout.txt",
    "code_path": "problem_iter32_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling and exploration based on waste standard deviation.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1 / (1 + np.exp(-waste * 5.0))\n\n    waste_std = np.std(waste)\n    exploration_factor = np.maximum(0.1, waste_std)\n    best_bin_index = np.argmin(waste)\n    priorities[valid_bins[best_bin_index]] += exploration_factor\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 12.883925009972083,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 93.45440529575887,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response1.txt_stdout.txt",
    "code_path": "problem_iter32_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling and a targeted boost to the best bin.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    normalized_waste = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n    std_waste = np.std(normalized_waste)\n    if std_waste > 0:\n        sigmoid_scaled_waste = 1 / (1 + np.exp(-normalized_waste * 2.0))\n        priorities[valid_bins] = sigmoid_scaled_waste\n        best_bin_index = np.argmin(normalized_waste)\n        priorities[np.where(valid_bins)[0][best_bin_index]] += 1.0\n    else:\n        priorities[valid_bins] = 1.0\n        best_bin_index = np.argmin(bins_remain_cap[valid_bins])\n        priorities[np.where(valid_bins)[0][best_bin_index]] += 1.0\n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 142.13383752235586,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response2.txt_stdout.txt",
    "code_path": "problem_iter32_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling and exploration based on waste std.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1 / (1 + np.exp(-waste * 2.0))\n    if len(waste) > 0:\n        std_waste = np.std(waste)\n        exploration_bonus = 0.1 * np.exp(-std_waste / np.mean(waste) if np.mean(waste) > 0 else 0)\n        best_bin_index = np.argmin(waste)\n        priorities[valid_bins[best_bin_index]] += exploration_bonus\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 27.134024730753904,
    "SLOC": 14.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 173.06477719407374,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response3.txt_stdout.txt",
    "code_path": "problem_iter32_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with exploration based on waste standard deviation, modulating the sigmoid.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    normalized_waste = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n    waste_std = np.std(normalized_waste)\n    exploration_factor = np.exp(-waste_std)\n    sigmoid_scale = 5.0\n    priorities = np.zeros_like(bins_remain_cap)\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-normalized_waste * sigmoid_scale))\n    priorities[valid_bins] = sigmoid_scaled_waste * (1 + exploration_factor)\n    best_bin_index = np.argmin(normalized_waste)\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 1.0\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.357798165137619,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 151.30376252379818,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response4.txt_stdout.txt",
    "code_path": "problem_iter32_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling and exploration based on waste std.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    best_bin_index = np.argmin(waste)\n    std_waste = np.std(waste)\n    sigmoid_scale = 5.0\n    exploration_factor = 0.1 * np.exp(-std_waste / (np.mean(waste) + 1e-6))\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n    priorities[valid_bins] = sigmoid_scaled_waste + exploration_factor\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 0.1\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 9.46350219385721,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 171.1759500778849,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response5.txt_stdout.txt",
    "code_path": "problem_iter32_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with dynamic exploration using sigmoid and waste statistics.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    avg_waste = np.mean(waste)\n    std_waste = np.std(waste)\n    if std_waste == 0:\n        std_waste = 1e-6\n    scaled_waste = (waste - avg_waste) / std_waste\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-scaled_waste * 2.0))\n    priorities[valid_bins] = sigmoid_scaled_waste\n    exploration_boost = np.random.rand(n_bins) * 0.1 * (1 + avg_waste/item)\n    priorities[valid_bins] += exploration_boost[valid_bins]\n    best_bin_index = np.argmin(waste)\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 0.5\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 148.51416035101715,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 230.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response6.txt_stdout.txt",
    "code_path": "problem_iter32_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with dynamic exploration based on waste statistics using sigmoid scaling.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    avg_waste = np.mean(waste)\n    waste_std = np.std(waste)\n    if waste_std == 0:\n        waste_std = 1e-6\n    normalized_waste = (waste - avg_waste) / waste_std\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-normalized_waste * 5.0))\n    priorities[valid_bins] = sigmoid_scaled_waste\n    best_bin_index = np.argmin(waste)\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 1.0\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 142.13383752235586,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response7.txt_stdout.txt",
    "code_path": "problem_iter32_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling and dynamic exploration based on waste std.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1 / (1 + np.exp(-waste * 2.0))\n    if len(waste) > 0:\n        std_waste = np.std(waste)\n        exploration_bonus = 0.1 * np.maximum(0.1, std_waste)\n        best_bin_index = np.argmin(waste)\n        priorities[valid_bins[best_bin_index]] += exploration_bonus\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 26.555644196250494,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 128.3789500201924,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response8.txt_stdout.txt",
    "code_path": "problem_iter32_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling and exploration based on waste standard deviation.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[valid_bins] - item\n    normalized_waste = waste / bins_remain_cap[valid_bins]\n    std_waste = np.std(normalized_waste)\n    sigmoid_scale = 1.0\n    sigmoid_input = normalized_waste * sigmoid_scale\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-sigmoid_input))\n    exploration_factor = np.exp(-std_waste)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = sigmoid_scaled_waste * (1 + exploration_factor)\n    best_bin_index = np.argmin(normalized_waste)\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 0.5\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 5.773833266852821,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 153.24725426256592,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response9.txt_stdout.txt",
    "code_path": "problem_iter32_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling and a dynamic exploration boost.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    normalized_waste = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n    waste_std = np.std(normalized_waste)\n    sigmoid_scale = 5.0\n    sigmoid_input = normalized_waste * sigmoid_scale + waste_std\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-sigmoid_input))\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = sigmoid_scaled_waste\n    best_bin_index = np.argmin(bins_remain_cap[valid_bins] - item)\n    priorities[valid_bins][best_bin_index] += 1.0\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 140.2304206377674,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response0.txt_stdout.txt",
    "code_path": "problem_iter33_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    A priority function for online bin packing that combines best-fit with\n    modulated sigmoid scaling based on waste statistics.\n    \"\"\"\n    sigmoid_scale = 5.0\n    best_bin_boost = 2.0\n    waste_std_factor = 2.0\n\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[valid_bins] - item\n    waste_std = np.std(waste)\n    \n    modulated_scale = sigmoid_scale * (1 + waste_std * waste_std_factor)\n\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * modulated_scale))\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = sigmoid_scaled_waste\n\n    best_bin_index = np.argmin(waste)\n    priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 142.13383752235586,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response1.txt_stdout.txt",
    "code_path": "problem_iter33_code1.py",
    "code": "import numpy as np\n\nsigmoid_scale = 1.0\nbest_bin_boost = 1.0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit with a sigmoid-scaled exploration factor based on waste\n    standard deviation.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[valid_bins] - item\n    best_bin_index = np.argmin(waste)\n\n    waste_std = np.std(waste)\n    exploration_factor = 1 / (1 + np.exp(-waste_std * sigmoid_scale))\n\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1 / (1 + np.exp(-waste * sigmoid_scale)) * exploration_factor\n    priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 167.17882283189007,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response2.txt_stdout.txt",
    "code_path": "problem_iter33_code2.py",
    "code": "import numpy as np\n\nsigmoid_scale = 1.0\nbest_bin_boost = 10.0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function for online bin packing, combining best-fit,\n    sigmoid scaling modulated by waste standard deviation, and a best-bin boost.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[valid_bins] - item\n    waste_std = np.std(waste) if len(waste) > 1 else 0.0\n\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n    \n    modulated_sigmoid = sigmoid_scaled_waste * (1 + waste_std)\n    \n    priorities[valid_bins] = modulated_sigmoid\n    \n    best_bin_index = np.argmin(waste)\n    priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 142.13383752235586,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response3.txt_stdout.txt",
    "code_path": "problem_iter33_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins based on a combination of best-fit, waste standard deviation,\n    and a sigmoid scaling for stability.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[valid_bins] - item\n    \n    waste_std = np.std(bins_remain_cap[valid_bins] - item) if len(bins_remain_cap[valid_bins] - item) > 1 else 0.0\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    \n    if waste_std > 0:\n        sigmoid_scale = 0.5 / waste_std\n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n        priorities[valid_bins] = sigmoid_scaled_waste\n    else:\n        priorities[valid_bins] = 1.0\n\n    best_bin_index = np.argmin(waste)\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 0.1 \n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.1284403669724865,
    "SLOC": 16.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 173.91626957122043,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response4.txt_stdout.txt",
    "code_path": "problem_iter33_code4.py",
    "code": "import numpy as np\n\nsigmoid_scale = 1.0\nbest_bin_boost = 1.0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with modulated sigmoid scaling based on waste standard deviation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        best_bin_index = np.argmin(waste)\n        waste_std = np.std(waste)\n        sigmoid_mod = 1.0 + waste_std\n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale * sigmoid_mod))\n        priorities[valid_bins] = sigmoid_scaled_waste\n        priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter34_response0.txt_stdout.txt",
    "code_path": "problem_iter34_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, sigmoid_scale: float = 9.337599777758557, boost: float = 4.705390823708806) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling and a targeted boost to the best bin.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  }
]