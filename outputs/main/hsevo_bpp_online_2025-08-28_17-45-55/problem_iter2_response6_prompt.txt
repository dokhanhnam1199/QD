{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) > 0:\n        priorities[valid_bins] = 1.0 / (bins_remain_cap[valid_bins] - item)\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    \n    priorities[valid_bins] = bins_remain_cap[valid_bins] - item\n    \n    return priorities\n\n### Analyze & experience\n- Comparing `priority_v2` from the best (1st) vs. the worst (20th) heuristics, the key difference lies in how priority is assigned. The best version intelligently prioritizes bins by minimizing waste (`np.argmin(bins_remain_cap[valid_bins] - item)` and assigning a higher priority to the best fit). The worst, and many subsequent versions, simply use `bins_remain_cap[valid_bins] - item` directly, which doesn't account for the overall goal of minimizing wasted space.\n\nComparing the 1st vs. 2nd, they are identical, showcasing an initial lack of variation. From 3rd-4th, there is a shift towards calculating waste, but the 3rd uses `np.where` unnecessarily making it slightly less efficient. Between 4th and 5th, there\u2019s again identical code, suggesting redundancy.  The 6th introduces a `fit_level` representing item size relative to remaining capacity, which is a good concept. 7th attempts an exponential weighting, but normalizes by the sum of fit scores, adding complexity without clear benefit. 8th uses a raw ratio of remaining space to capacity.\n\nThe 9th-10th introduces a sigmoid function (1 / (1 + exp(-x))), attempting a smoother priority distribution, coupled with `np.std` for normalization. This is a solid improvement, but relies on the standard deviation, potentially being sensitive to outliers.  Heuristics 11th-13th use the inverse of remaining space (`1 / (bins_remain_cap - item)`). This amplifies differences but can become unstable when the remaining space is very small (division by a small number). 14th-17th use `bins_remain_cap - item` but assign -1 for invalid bins, which isn\u2019t helpful. Finally, 18th-20th revert to the basic waste calculation.\n\nOverall: The best heuristics focus on *minimizing waste*, either directly or through a smooth function. Using inverse waste creates potential instability. The best solutions avoid unnecessary code or complexity and prioritize bins with the least wasted space. The consistent issue across the lower-ranked heuristics is the lack of nuance in prioritizing bins beyond simple feasibility.\n- \nOkay, let's dissect this and build a robust self-reflection framework for heuristic design, aiming for that $999K! Here's a breakdown focused on improving bin packing heuristics:\n\n* **Keywords:** Prioritization, Normalization, Stability, Conciseness.\n* **Advice:** Focus priority functions *directly* on remaining bin space *after* item placement. Use sigmoid scaling for priorities \u2013 it's robust. Explore item-bin fit ratios *before* complex calculations.\n* **Avoid:** Division (prone to instability), overly complex scoring (redundancy), unnormalized scores (outlier sensitivity).\n* **Explanation:**  Directly addressing the objective, coupled with stable, normalized prioritization, guides the heuristic efficiently. Simplicity aids understanding and prevents unintended consequences.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}