[
  {
    "stdout_filepath": "problem_iter17_response0.txt_stdout.txt",
    "code_path": "problem_iter17_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with a worst-fit penalty using sigmoid scaling for stability.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    sigmoid_scale = 5.0\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n    priorities[possible_bins] = sigmoid_scaled_waste\n\n    best_bin_index = np.argmin(waste)\n    worst_bin_index = np.argmax(waste)\n    \n    priorities[possible_bins][best_bin_index] += 1.0\n    priorities[possible_bins][worst_bin_index] += 0.5\n    \n    priorities[~possible_bins] = 0.0\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 13.40247307538892,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 126.65973476959637,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response1.txt_stdout.txt",
    "code_path": "problem_iter17_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with a worst-fit penalty, using sigmoid scaling for stability.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = 1.0 / (np.exp(waste) + 1e-9)\n    best_bin_index = np.argmin(waste)\n    priorities[possible_bins][best_bin_index] += 0.7\n    worst_bin_index = np.argmax(waste)\n    priorities[possible_bins][worst_bin_index] -= 0.3\n    priorities[~possible_bins] = 0.0\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 99.40434618240934,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response2.txt_stdout.txt",
    "code_path": "problem_iter17_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit waste minimization with a mild worst-fit penalty for diversity.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (waste + 1e-9)\n        worst_bin_index = np.argmax(waste)\n        priorities[valid_bins][worst_bin_index] -= 0.1\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response3.txt_stdout.txt",
    "code_path": "problem_iter17_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (inverse waste) with a mild worst-fit penalty for diversity.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n    worst_bin_index = np.argmax(waste)\n    priorities[np.where(valid_bins)[0][worst_bin_index]] += 0.1\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response4.txt_stdout.txt",
    "code_path": "problem_iter17_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (1/waste) with a stabilized worst-fit penalty (sigmoid).\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n    worst_bin_index = np.argmax(waste)\n    priorities[valid_bins[worst_bin_index]] += 0.5\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 12, in priority_v2\n    worst_bin_index = np.argmax(waste)\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n10\n2\n66.41714012534482\n"
  },
  {
    "stdout_filepath": "problem_iter17_response5.txt_stdout.txt",
    "code_path": "problem_iter17_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (with sigmoid scaling) and a mild worst-fit penalty for bin diversity.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    sigmoid_scale = 5.0\n    priorities[valid_bins] = 1 / (1 + np.exp(-waste * sigmoid_scale))\n    worst_bin_index = np.argmax(waste)\n    priorities[np.where(valid_bins)[0][worst_bin_index]] -= 0.5\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 13.40247307538892,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 93.45440529575887,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response6.txt_stdout.txt",
    "code_path": "problem_iter17_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with a worst-fit penalty, using sigmoid scaling for stability.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[possible_bins] - item\n    sigmoid_scale = 5.0\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = 1.0 / (1 + np.exp(-waste * sigmoid_scale))\n    best_bin_index = np.argmin(waste)\n    worst_bin_index = np.argmax(waste)\n    priorities[possible_bins][best_bin_index] += 1.0\n    priorities[possible_bins][worst_bin_index] -= 0.5\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 13.40247307538892,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 114.20025299224778,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response7.txt_stdout.txt",
    "code_path": "problem_iter17_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a worst-fit penalty using sigmoid scaling for stability.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1.0 / (1 + np.exp(-waste * 5.0))\n\n    best_bin_index = np.argmin(waste)\n    priorities[valid_bins][best_bin_index] += 0.5\n\n    worst_bin_index = np.argmax(waste)\n    priorities[valid_bins][worst_bin_index] -= 0.2\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 13.40247307538892,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 109.80793556946902,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response8.txt_stdout.txt",
    "code_path": "problem_iter17_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a worst-fit penalty, using sigmoid scaling for stability.\"\"\"\n    sigmoid_scale = 5.0\n    best_bin_boost = 1.0\n    worst_fit_penalty = 0.5\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n    priorities[valid_bins] = sigmoid_scaled_waste\n    best_bin_index = np.argmin(waste)\n    worst_bin_index = np.argmax(waste)\n    priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n    priorities[np.where(valid_bins)[0][worst_bin_index]] -= worst_fit_penalty\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.397686477862,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 109.80793556946902,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response9.txt_stdout.txt",
    "code_path": "problem_iter17_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with a worst-fit penalty, using sigmoid scaling for stability.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    sigmoid_scale = 5.0\n\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n    priorities[possible_bins] = sigmoid_scaled_waste\n\n    best_bin_index = np.argmin(waste)\n    priorities[possible_bins][best_bin_index] += 0.5\n\n    worst_bin_index = np.argmax(waste)\n    priorities[possible_bins][worst_bin_index] -= 0.2\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 13.40247307538892,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 115.94522208456974,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response0.txt_stdout.txt",
    "code_path": "problem_iter18_code0.py",
    "code": "import numpy as np\n\nsigmoid_scale = 5.0\nbest_bin_boost = 1.0\nworst_bin_penalty = 0.1\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    A mutated priority function for online bin packing.\n    Balances best-fit exploitation with worst-fit exploration using sigmoid scaling\n    and penalties.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        \n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n        \n        priorities[valid_bins] = sigmoid_scaled_waste\n        \n        worst_bin_index = np.argmax(waste)\n        priorities[valid_bins] -= worst_bin_penalty\n        priorities[np.where(valid_bins)[0][worst_bin_index]] -= 2 * worst_bin_penalty\n\n        best_bin_index = np.argmin(waste)\n        priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 24, in priority_v2\n    priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'subtract' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n13\n2\n129.32351694048162\n"
  },
  {
    "stdout_filepath": "problem_iter18_response1.txt_stdout.txt",
    "code_path": "problem_iter18_code1.py",
    "code": "import numpy as np\n\nsigmoid_scale = 5.0\nbest_bin_boost = 1.0\nworst_bin_penalty = 0.1\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit, worst-fit penalty, and sigmoid scaling for a balanced approach.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        \n        best_bin_index = np.argmin(waste)\n        worst_bin_index = np.argmax(waste)\n\n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n        \n        priorities[valid_bins] = sigmoid_scaled_waste\n\n        priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n        \n        priorities[np.where(valid_bins)[0][worst_bin_index]] -= worst_bin_penalty\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.397686477862,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 97.70233280920246,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response2.txt_stdout.txt",
    "code_path": "problem_iter18_code2.py",
    "code": "import numpy as np\n\nsigmoid_scale = 5.0\nbest_bin_boost = 10.0\nworst_bin_penalty = 2.0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        best_bin_index = np.argmin(waste)\n        worst_bin_index = np.argmax(waste)\n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n        priorities[valid_bins] = sigmoid_scaled_waste\n        priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n        priorities[np.where(valid_bins)[0][worst_bin_index]] -= worst_bin_penalty\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 97.70233280920246,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response3.txt_stdout.txt",
    "code_path": "problem_iter18_code3.py",
    "code": "import numpy as np\n\nsigmoid_scale = 5.0\nbest_bin_boost = 1.0\nworst_bin_penalty = 0.1\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, worst-fit penalty, and sigmoid scaling for enhanced stability.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        \n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n        priorities[valid_bins] = sigmoid_scaled_waste\n\n        best_bin_index = np.argmin(waste)\n        priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n\n        worst_bin_index = np.argmax(waste)\n        priorities[np.where(valid_bins)[0][worst_bin_index]] -= worst_bin_penalty\n        \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.397686477862,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 97.70233280920246,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response4.txt_stdout.txt",
    "code_path": "problem_iter18_code4.py",
    "code": "import numpy as np\n\nsigmoid_scale = 5.0\nbest_bin_boost = 1.0\nworst_bin_penalty = 0.1\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        best_bin_index = np.argmin(waste)\n        worst_bin_index = np.argmax(waste)\n\n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n        priorities[valid_bins] = sigmoid_scaled_waste\n\n        priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n        \n        priorities[np.where(valid_bins)[0][worst_bin_index]] -= worst_bin_penalty\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.397686477862,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 97.70233280920246,
    "exec_success": true
  }
]