[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (minimizing waste) with a sigmoid scaling for stability.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[valid_bins] - item\n    scores = 1 / (1 + np.exp(-waste / (np.std(bins_remain_cap[valid_bins]) + 1e-6)))\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = scores\n    best_bin_index = np.argmin(waste)\n    priorities[valid_bins[best_bin_index]] = 2.0\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 91.73835003173087,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best fit (minimizing waste) with sigmoid scaling for stability.\n    Prioritizes bins that best fit the item and normalizes priority scores.\n    \"\"\"\n    possible_bins = bins_remain_cap[bins_remain_cap >= item]\n    if len(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    waste = possible_bins - item\n    scores = 1 / (1 + np.exp(-(np.argmin(waste) - np.argsort(waste)[0]) / (np.std(waste) + 1e-6)))\n    priorities = np.zeros_like(bins_remain_cap)\n    bin_indices = np.where(bins_remain_cap >= item)[0]\n    \n    best_bin_index = bin_indices[np.argmin(waste)]\n    \n    priorities[best_bin_index] = scores\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 127.37720526058406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and minimizes waste using a sigmoid function.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    fit_levels = item / bins_remain_cap[valid_bins]\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1 / (1 + np.exp(-5 * (1 - fit_levels)))\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 91.73835003173087,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (waste minimization) with sigmoid scaling for stability.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        best_bin_index = np.argmin(waste)\n        \n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste))\n        priorities[valid_bins] = sigmoid_scaled_waste\n        priorities[np.where(valid_bins)[0][best_bin_index]] = 2.0\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 50.18947501009619,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with sigmoid scaling for stable prioritization.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = 1 / (1 + np.exp(-waste))\n    priorities = priorities / np.sum(priorities)\n    result = np.zeros_like(bins_remain_cap)\n    result[possible_bins] = priorities\n    return result",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 76.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (waste minimization) with sigmoid scaling for stability.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1 / (1 + np.exp(waste))\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 50.18947501009619,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best fit (minimizing waste) with sigmoid scaling for stability.\n    Prioritizes bins with the smallest waste after item placement,\n    smoothed by a sigmoid function.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1 / (1 + np.exp(waste))\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 50.18947501009619,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit (minimizing waste) with a sigmoid normalization\n    for stable priority scores.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    if np.any(valid_bins):\n        fit_scores = 1.0 / (waste + 1e-6)\n        max_fit = np.max(fit_scores)\n        \n        sigmoid_input = (fit_scores / max_fit) * 10\n        priorities[valid_bins] = 1.0 / (1.0 + np.exp(-sigmoid_input))\n        \n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 124.86408532184433,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with sigmoid scaling for stable priority.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = 1.0 / (waste + 1e-9)\n    priorities = 1.0 / (1.0 + np.exp(-priorities))\n    priorities[~possible_bins] = 0.0\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 108.04820237218406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with sigmoid scaling for stable prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return priorities\n    waste = bins_remain_cap[possible_bins] - item\n    priorities[possible_bins] = 1.0 / (1 + np.exp(waste))\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    fit_ratios = bins_remain_cap / item\n    valid_bins = fit_ratios >= 1.0\n    if np.any(valid_bins):\n        priorities[valid_bins] = np.exp(-1 / (fit_ratios[valid_bins] - 1))\n        best_bin_index = np.argmax(priorities[valid_bins])\n        priorities[valid_bins] = 0.0\n        priorities[np.where(valid_bins)[0][best_bin_index]] = 1.0\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 48.43204266092217,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    fit_ratios = bins_remain_cap / item\n    valid_bins = fit_ratios >= 1.0\n    if np.any(valid_bins):\n        priorities[valid_bins] = np.exp(-1.0 / (fit_ratios[valid_bins] - 1.0))\n        best_bin_index = np.argmax(priorities[valid_bins])\n        priorities[valid_bins] = 0.0\n        priorities[np.where(valid_bins)[0][best_bin_index]] = 1.0\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 48.43204266092217,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    fit_ratios = item / bins_remain_cap\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        fit_ratios[~valid_bins] = np.inf\n        bin_index = np.argmin(fit_ratios)\n        priorities[valid_bins] = np.exp(-(fit_ratios[valid_bins] - 1))\n        priorities[bin_index] = np.max(priorities[valid_bins])\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 12.016354208216994,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 44.97261104228487,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    fit_ratios = item / bins_remain_cap\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        fit_ratios[~valid_bins] = np.inf\n        priorities[valid_bins] = np.exp(-(fit_ratios[valid_bins] - 0.5)**2)\n        best_bin_index = np.argmax(priorities[valid_bins])\n        priorities[valid_bins] = 0.0\n        priorities[valid_bins[best_bin_index]] = 1.0\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 60.91767875292166,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    fit_ratios = bins_remain_cap / item\n    valid_bins = fit_ratios >= 1.0\n    if np.any(valid_bins):\n        priorities[valid_bins] = np.exp(-1.0 / (fit_ratios[valid_bins] - 1.0))\n        priorities[valid_bins] = priorities[valid_bins] / np.max(priorities[valid_bins])\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 62.907475208398566,
    "exec_success": true
  }
]