[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit with sigmoid scaling and a decaying best bin boost.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1 / (1 + np.exp(waste))\n    best_bin_index = np.argmin(waste)\n    priorities[valid_bins] = np.exp(-(waste - 1))\n    priorities[best_bin_index] = np.max(priorities[valid_bins])\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 74.23092131656186,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling and a decaying best-bin boost.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        fit_ratios = item / bins_remain_cap[valid_bins]\n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * 2.0))\n        priorities[valid_bins] = sigmoid_scaled_waste * np.exp(-(fit_ratios - 1))\n        best_bin_index = np.argmin(waste)\n        priorities[np.where(valid_bins)[0][best_bin_index]] += 1.0\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 11.82688472277624,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 136.16184010614157,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with sigmoid scaling and a decaying best-bin boost.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = 1.0 / (waste + 1e-9)\n    priorities = 1.0 / (1.0 + np.exp(-priorities))\n    priorities[~possible_bins] = 0.0\n\n    if np.any(possible_bins):\n        best_bin_index = np.argmin(waste)\n        priorities[possible_bins][best_bin_index] += 1.0\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 122.9848878378053,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling and std normalization for stability.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[valid_bins] - item\n    mean_waste = np.mean(waste)\n    std_waste = np.std(waste)\n    if std_waste == 0:\n        normalized_waste = np.zeros_like(waste)\n    else:\n        normalized_waste = (waste - mean_waste) / std_waste\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1 / (1 + np.exp(-normalized_waste))\n    best_bin_index = np.argmin(waste)\n    priorities[np.where(valid_bins)[0][best_bin_index]] = 2.0\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 108.04820237218406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with sigmoid scaling and a decaying best-bin boost.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = 1.0 / (waste + 1e-9)\n    priorities = 1.0 / (1.0 + np.exp(-priorities))\n    priorities[~possible_bins] = 0.0\n\n    best_bin_index = np.argmin(waste)\n    \n    boost_factor = 2.0\n    priorities[possible_bins[best_bin_index]] += boost_factor\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 124.86408532184433,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit waste with sigmoid scaling and a decaying best-bin boost.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1 / (1 + np.exp(-5 * (1 - (item / bins_remain_cap[valid_bins]))))\n    \n    best_bin_index = np.argmin(waste)\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 2.0\n    \n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 122.9848878378053,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling and a decaying best bin boost.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = 1.0 / (waste + 1e-9)\n    sigmoid_scaled_waste = 1.0 / (1.0 + np.exp(-priorities))\n    priorities[~possible_bins] = 0.0\n    best_bin_index = np.argmin(waste)\n    best_bin_boost = 2.0\n    priorities[possible_bins][best_bin_index] += best_bin_boost\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 124.86408532184433,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling and a best-bin boost.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[valid_bins] - item\n    scores = 1 / (1 + np.exp(-waste / (np.std(bins_remain_cap[valid_bins]) + 1e-6)))\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = scores\n    best_bin_index = np.argmin(waste)\n    priorities[valid_bins[best_bin_index]] = 2.0\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 91.73835003173087,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling and standard deviation for stable priorities.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[valid_bins] - item\n    fit_scores = 1.0 / (waste + 1e-6)\n    mean_waste = np.mean(waste)\n    std_waste = np.std(waste)\n    if std_waste == 0:\n        std_waste = 1e-6\n    normalized_waste = (waste - mean_waste) / std_waste\n    sigmoid_input = normalized_waste * 2.5\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1.0 / (1.0 + np.exp(-sigmoid_input))\n    best_bin_index = np.argmin(waste)\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 2.0\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 175.93083758004835,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling & standardized waste, plus a decaying best bin boost.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[valid_bins] - item\n    std_waste = np.std(waste)\n    if std_waste == 0:\n        normalized_waste = np.zeros_like(waste)\n    else:\n        normalized_waste = waste / std_waste\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-normalized_waste * 2.5369418572825637))\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = sigmoid_scaled_waste\n    best_bin_index = np.argmin(waste)\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 2.0\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 126.65973476959637,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\nsigmoid_scale = 5.0\nbest_bin_boost = 2.0\ndecay_rate = 0.995\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, iteration: int = 0) -> np.ndarray:\n    \"\"\"\n    Combines best-fit with sigmoid scaling, a decaying best-bin boost,\n    and handles edge cases for robustness.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-sigmoid_scale * waste))\n\n    priorities[valid_bins] = sigmoid_scaled_waste\n\n    best_bin_index = np.argmin(waste)\n    boosted_priority = priorities[valid_bins][best_bin_index] + best_bin_boost * np.exp(-decay_rate * iteration)\n    priorities[np.where(valid_bins)[0][best_bin_index]] = boosted_priority\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 137.5488750216347,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\nsigmoid_scale = 5.0\nbest_bin_boost = 2.0\ndecay_rate = 0.995\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, iteration: int = 0) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        relative_waste = waste / np.max(waste) if np.max(waste) > 0 else waste\n        sigmoid_scaled_waste = 1 / (1 + np.exp(-sigmoid_scale * relative_waste))\n        priorities[valid_bins] = sigmoid_scaled_waste\n        \n        best_bin_index = np.argmin(waste)\n        boost = best_bin_boost * np.exp(-decay_rate * iteration)\n        priorities[np.where(valid_bins)[0][best_bin_index]] += boost\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 161.66617507355795,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, iteration: int, max_iterations: int) -> np.ndarray:\n    \"\"\"\n    An enhanced priority function for online bin packing, combining best-fit,\n    sigmoid scaling, and a decaying best-bin boost.\n    \"\"\"\n    sigmoid_scale = 5.0\n    best_bin_boost = 1.0\n    decay_rate = 0.99\n\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        best_bin_index = np.argmin(waste)\n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n        priorities[valid_bins] = sigmoid_scaled_waste\n        \n        boost_factor = best_bin_boost * (1 - (iteration / max_iterations))\n        priorities[np.where(valid_bins)[0][best_bin_index]] += boost_factor\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 2 required positional arguments: 'iteration' and 'max_iterations'\n14\n2\n129.32351694048162\n"
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\nsigmoid_scale = 5.0\nbest_bin_boost = 2.0\ndecay_rate = 0.995\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, iteration: int) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        \n        sigmoid_scaled_waste = 1 / (1 + np.exp(-sigmoid_scale * waste))\n        \n        priorities[valid_bins] = sigmoid_scaled_waste\n        \n        best_bin_index = np.argmin(waste)\n        boosted_priority = best_bin_boost * (decay_rate ** iteration)\n        priorities[np.where(valid_bins)[0][best_bin_index]] += boosted_priority\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'iteration'\n11\n2\n115.94522208456974\n"
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\nsigmoid_scale = 5.0\nbest_bin_boost = 2.0\ndecay_rate = 0.995\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, iteration: int) -> np.ndarray:\n    \"\"\"\n    A refined priority function for online bin packing.\n    Combines best-fit with sigmoid scaling, a decaying best-bin boost,\n    and relative prioritization.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        \n        sigmoid_scaled_waste = 1 / (1 + np.exp(-sigmoid_scale * waste))\n        priorities[valid_bins] = sigmoid_scaled_waste\n        \n        best_bin_index = np.argmin(waste)\n        boosted_priority = best_bin_boost * (decay_rate ** iteration)\n        priorities[np.where(valid_bins)[0][best_bin_index]] += boosted_priority\n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'iteration'\n11\n2\n115.94522208456974\n"
  }
]