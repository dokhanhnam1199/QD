[
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit waste minimization with a mild worst-fit penalty, and handles empty bin cases.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n    worst_bin_index = np.argmax(waste)\n    priorities[valid_bins][worst_bin_index] -= 0.1\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a mild worst-fit penalty and handles no valid bins.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    sigmoid_scale = 5.0\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n    priorities[possible_bins] = sigmoid_scaled_waste\n\n    best_bin_index = np.argmin(waste)\n    worst_bin_index = np.argmax(waste)\n\n    priorities[possible_bins][best_bin_index] += 0.5\n    priorities[possible_bins][worst_bin_index] -= 0.1\n\n    priorities[~possible_bins] = 0.0\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 13.40247307538892,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 128.3789500201924,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling and a worst-fit penalty.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    sigmoid_scale = 5.0\n    priorities[valid_bins] = 1 / (1 + np.exp(-waste * sigmoid_scale))\n    worst_bin_index = np.argmax(waste)\n    priorities[np.where(valid_bins)[0][worst_bin_index]] -= 0.1\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 13.40247307538892,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 93.45440529575887,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response3.txt_stdout.txt",
    "code_path": "problem_iter20_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit waste minimization with a worst-fit penalty and explicit handling of no valid bins.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (waste + 1e-9)\n        worst_bin_index = np.argmax(waste)\n        priorities[valid_bins][worst_bin_index] -= 0.1\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (inverse waste) with a mild worst-fit penalty, handling edge cases.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n    worst_bin_index = np.argmax(waste)\n    priorities[np.where(valid_bins)[0][worst_bin_index]] += 0.1\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a mild worst-fit penalty and sigmoid scaling for robustness.\"\"\"\n    sigmoid_scale = 5.0\n    best_bin_boost = 2.0\n    worst_bin_penalty = 0.5\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n        priorities[valid_bins] = sigmoid_scaled_waste\n        best_bin_index = np.argmin(waste)\n        worst_bin_index = np.argmax(waste)\n        priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n        priorities[np.where(valid_bins)[0][worst_bin_index]] -= worst_bin_penalty\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 97.70233280920246,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization with a worst-fit penalty, handling empty bins.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[possible_bins] - item\n    sigmoid_scale = 5.0\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = 1.0 / (1 + np.exp(-waste * sigmoid_scale))\n    best_bin_index = np.argmin(waste)\n    worst_bin_index = np.argmax(waste)\n    priorities[possible_bins][best_bin_index] += 1.0\n    priorities[possible_bins][worst_bin_index] -= 0.5\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 13.40247307538892,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 114.20025299224778,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response7.txt_stdout.txt",
    "code_path": "problem_iter20_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (inverse waste) with a mild worst-fit penalty and handles edge cases.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n\n    worst_bin_index = np.argmax(waste)\n    priorities[np.where(valid_bins)[0][worst_bin_index]] += 0.1\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit waste minimization with a mild worst-fit penalty.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (waste + 1e-9)\n        worst_bin_index = np.argmax(waste)\n        priorities[valid_bins][worst_bin_index] -= 0.1\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a worst-fit penalty, using sigmoid scaling and explicit handling of no valid bins.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    sigmoid_scale = 5.0\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n    priorities[possible_bins] = sigmoid_scaled_waste\n    best_bin_index = np.argmin(waste)\n    worst_bin_index = np.argmax(waste)\n    priorities[possible_bins][best_bin_index] += 1.0\n    priorities[possible_bins][worst_bin_index] -= 0.1\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 13.40247307538892,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 114.20025299224778,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response0.txt_stdout.txt",
    "code_path": "problem_iter21_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, exploration_rate: float = 0.1, best_fit_weight: float = 0.7, diversity_weight: float = 0.3) -> np.ndarray:\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[valid_bins] - item\n    best_fit_score = -waste\n    \n    bin_counts = np.zeros_like(bins_remain_cap)\n    \n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] > 0:\n            bin_counts[i] = 1\n    \n    diversity_score = bin_counts[valid_bins]\n    \n    priorities = (best_fit_weight * best_fit_score + diversity_weight * diversity_score)\n    \n    if np.any(valid_bins):\n        \n        best_bin_index = np.argmin(waste)\n        \n        priorities[valid_bins] += exploration_rate * (np.random.rand(np.sum(valid_bins)))\n        priorities[np.where(valid_bins)[0][best_bin_index]] += exploration_rate * 2\n        \n        \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 161.66617507355795,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response1.txt_stdout.txt",
    "code_path": "problem_iter21_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive prioritization combining best-fit, worst-fit, and a diversity component.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[valid_bins] - item\n    best_bin_index = np.argmin(waste)\n    worst_bin_index = np.argmax(waste)\n\n    priorities = np.zeros_like(bins_remain_cap)\n\n    best_fit_score = 1.0 / (1.0 + waste)\n    worst_fit_score = waste\n    diversity_score = 1.0 / (np.sum(valid_bins) + 1e-6)\n\n    weight_best_fit = 0.6\n    weight_worst_fit = 0.2\n    weight_diversity = 0.2\n\n    priorities[valid_bins] = (weight_best_fit * best_fit_score +\n                              weight_worst_fit * worst_fit_score +\n                              weight_diversity * diversity_score)\n\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 0.1\n    priorities[np.where(valid_bins)[0][worst_bin_index]] -= 0.05\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 149.10251296370166,
    "SLOC": 20.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 201.18251441994926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response2.txt_stdout.txt",
    "code_path": "problem_iter21_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive prioritization combining best-fit, first-fit, and diversity.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    best_bin_index = np.argmin(waste)\n\n    first_fit_scores = np.where(valid_bins)[0]\n    first_fit_ranks = np.argsort(first_fit_scores)\n    first_fit_priority = np.zeros_like(bins_remain_cap)\n    first_fit_priority[valid_bins] = 1.0 / (first_fit_ranks + 1)\n\n    diversity_scores = np.zeros_like(bins_remain_cap)\n    bin_occupancy = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    diversity_scores[valid_bins] = 1 - bin_occupancy[valid_bins]\n    \n    adaptive_weight_best_fit = 0.6\n    adaptive_weight_first_fit = 0.3\n    adaptive_weight_diversity = 0.1\n    \n    priorities[valid_bins] = (adaptive_weight_best_fit * (1 / (1 + np.exp(-waste * 2)))) + \\\n                             (adaptive_weight_first_fit * first_fit_priority[valid_bins]) + \\\n                             (adaptive_weight_diversity * diversity_scores[valid_bins])\n\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 0.1\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 23.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 264.5480677450177,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response3.txt_stdout.txt",
    "code_path": "problem_iter21_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, exploration_rate: float = 0.1, diversity_factor: float = 1.0) -> np.ndarray:\n    \"\"\"\n    Adaptive priority function for online bin packing. Combines best-fit,\n    exploration, and diversity to enhance packing performance.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[valid_bins] - item\n    best_bin_index = np.argmin(waste)\n    best_fit_priority = 1.0 / (1.0 + np.exp(-waste * 2.0))\n\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = best_fit_priority\n\n    exploration_bonus = np.random.rand(len(bins_remain_cap)) * exploration_rate\n    priorities[valid_bins] += exploration_bonus\n\n    bin_occupancy = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n    bin_occupancy = np.clip(bin_occupancy, 0.0, 1.0)\n    diversity_bonus = diversity_factor * (1.0 - bin_occupancy)\n    priorities[valid_bins] += diversity_bonus\n\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 0.5\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 20, in priority_v2\n    \nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n17\n2\n210.99629561116632\n"
  },
  {
    "stdout_filepath": "problem_iter21_response4.txt_stdout.txt",
    "code_path": "problem_iter21_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha=0.7, beta=0.3, exploration_rate=0.1) -> np.ndarray:\n    \"\"\"\n    Adaptive prioritization for bin packing, balancing best-fit and diversity.\n\n    Args:\n        item (float): The size of the item to be packed.\n        bins_remain_cap (np.ndarray): The remaining capacity of each bin.\n        alpha (float): Weight for best-fit component.\n        beta (float): Weight for diversity component.\n        exploration_rate (float): Probability of choosing a random bin for exploration.\n\n    Returns:\n        np.ndarray: Priority scores for each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    best_bin_index = np.argmin(waste)\n\n    best_fit_component = np.zeros_like(bins_remain_cap)\n    best_fit_component[valid_bins] = 1 / (1 + np.exp(-waste * 5))\n\n    diversity_component = np.zeros_like(bins_remain_cap)\n    bin_usage = 1 - bins_remain_cap / np.max(bins_remain_cap)\n    diversity_component[valid_bins] = bin_usage[valid_bins]\n\n    priorities = alpha * best_fit_component + beta * diversity_component\n\n    if np.random.rand() < exploration_rate:\n        random_bin_index = np.random.choice(n_bins)\n        priorities[random_bin_index] = np.max(priorities) + 1\n\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 0.5\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 22.237734343837257,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 213.03044134663566,
    "exec_success": true
  }
]