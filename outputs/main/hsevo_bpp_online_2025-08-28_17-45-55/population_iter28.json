[
  {
    "stdout_filepath": "problem_iter26_response0.txt_stdout.txt",
    "code_path": "problem_iter26_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with dynamic exploration based on remaining capacity.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    priorities = np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[valid_bins] - item\n    best_bin_index = np.argmin(waste)\n\n    priorities[valid_bins] = 0.5 * (1 / (1 + np.exp(-waste))) + 0.5 * (waste / np.max(waste))\n    exploration_factor = np.mean(bins_remain_cap[valid_bins]) / item if np.mean(bins_remain_cap[valid_bins]) > 0 else 1.0\n    exploration_factor = np.clip(exploration_factor, 0.1, 5.0)\n\n    priorities[valid_bins] += exploration_factor * (1 / (np.arange(1, len(valid_bins) + 1)))\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 0.1\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 17, in priority_v2\n    std_waste = 1e-6\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n13\n3\n247.1753118485642\n"
  },
  {
    "stdout_filepath": "problem_iter26_response1.txt_stdout.txt",
    "code_path": "problem_iter26_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with dynamic exploration based on average waste.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    avg_waste = np.mean(waste)\n    std_waste = np.std(waste)\n\n    if std_waste == 0:\n        std_waste = 1e-6\n\n    scaled_waste = (waste - avg_waste) / std_waste\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-scaled_waste * 5.0))\n    priorities[valid_bins] = sigmoid_scaled_waste\n\n    exploration_boost = np.random.rand(n_bins) * 0.1 * (1 + avg_waste/item)\n    priorities[valid_bins] += exploration_boost[valid_bins]\n\n    best_bin_index = np.argmin(waste)\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 1.0\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.98603909054647,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 227.8930302777963,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response2.txt_stdout.txt",
    "code_path": "problem_iter26_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a diversity component based on bin usage.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    best_fit_component = 1 / (1 + np.exp(-waste * 5))\n    bin_usage = 1 - bins_remain_cap / np.max(bins_remain_cap)\n    diversity_component = bin_usage\n\n    alpha = 0.7\n    beta = 0.3\n    priorities[valid_bins] = alpha * best_fit_component + beta * diversity_component\n    best_bin_index = np.argmin(waste)\n    priorities[valid_bins[best_bin_index]] += 0.5\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 5.574391703230963,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 175.93083758004835,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response3.txt_stdout.txt",
    "code_path": "problem_iter26_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a dynamic exploration factor based on average remaining capacity.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    best_bin_index = np.argmin(waste)\n    exploration_factor = np.mean(bins_remain_cap[valid_bins]) / (item + 1e-6)\n    exploration_factor = np.clip(exploration_factor, 0.1, 5.0)\n    priorities[valid_bins] = (1 / (waste + 1e-6)) * (1 + exploration_factor * np.random.rand())\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 1.0\n    return priorities",
    "response_id": 3,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 142.7018117963935,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response4.txt_stdout.txt",
    "code_path": "problem_iter26_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a mild worst-fit penalty and exploration.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n\n    worst_bin_index = np.argmax(waste)\n    priorities[np.where(valid_bins)[0][worst_bin_index]] += 0.1\n\n    exploration_rate = 0.1\n    if np.random.rand() < exploration_rate:\n        random_bin_index = np.random.choice(n_bins)\n        priorities[random_bin_index] = np.max(priorities) + 1\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 62.953729557239726,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 97.70233280920246,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response5.txt_stdout.txt",
    "code_path": "problem_iter26_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a time-dependent exploration bonus for improved bin packing.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1 / (1 + np.exp(-waste * 2.0))\n    best_bin_index = np.argmin(waste)\n    priorities[valid_bins][best_bin_index] += 0.5\n    exploration_boost = 0.1 * np.sum(valid_bins)\n    priorities[valid_bins] += exploration_boost / n_bins\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 27.173913043478258,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 143.95954188301644,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response6.txt_stdout.txt",
    "code_path": "problem_iter26_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a time-dependent exploration bonus for better performance.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    best_bin_index = np.argmin(waste)\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * 0.5))\n    priorities[valid_bins] = sigmoid_scaled_waste\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 1.0\n\n    exploration_boost = 0.1 * (n_bins - np.sum(valid_bins))\n    priorities[valid_bins] += exploration_boost\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 142.13383752235586,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response7.txt_stdout.txt",
    "code_path": "problem_iter26_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with sigmoid scaling and a mild worst-fit penalty.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = 1 / (1 + np.exp(-waste * 2.0))\n    \n    best_bin_index = np.argmin(waste)\n    worst_bin_index = np.argmax(waste)\n    \n    priorities[possible_bins][best_bin_index] += 1.0\n    priorities[possible_bins][worst_bin_index] -= 0.2\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 27.173913043478258,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 114.20025299224778,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response8.txt_stdout.txt",
    "code_path": "problem_iter26_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a mild worst-fit penalty and explicit invalid bin handling.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n    worst_bin_index = np.argmax(waste)\n    priorities[np.where(valid_bins)[0][worst_bin_index]] += 0.1\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response9.txt_stdout.txt",
    "code_path": "problem_iter26_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with time-dependent exploration bonus for improved bin packing.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    best_bin_index = np.argmin(waste)\n    time_step = np.sum(bins_remain_cap > 0)\n    exploration_bonus_factor = 0.1\n    exploration_bonus = exploration_bonus_factor * np.exp(-time_step / n_bins)\n\n    priorities[valid_bins] = -waste\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 1.0 + exploration_bonus\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 122.13617281353935,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response0.txt_stdout.txt",
    "code_path": "problem_iter27_code0.py",
    "code": "import numpy as np\n\nsigmoid_scale = 1.0\nbest_bin_boost = 1.0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        best_bin_index = np.argmin(waste)\n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n        priorities[valid_bins] = sigmoid_scaled_waste\n        priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n        \n        penalty = 0.1\n        \n        for i in range(len(bins_remain_cap)):\n            if valid_bins[i]:\n                if i != np.where(valid_bins)[0][best_bin_index]:\n                    priorities[i] -= penalty * waste[best_bin_index] / (waste[i] + 1e-6)\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997369999983 seconds"
  },
  {
    "stdout_filepath": "problem_iter27_response1.txt_stdout.txt",
    "code_path": "problem_iter27_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Enhanced priority function for online bin packing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        best_bin_index = np.argmin(waste)\n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * 2))\n        priorities[valid_bins] = sigmoid_scaled_waste\n        \n        penalty = 0.1\n        for i in range(len(valid_bins)):\n            if i != best_bin_index:\n                priorities[valid_bins][i] -= penalty * waste[i]\n\n        priorities[np.where(valid_bins)[0][best_bin_index]] += 1.0\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997092000012 seconds"
  },
  {
    "stdout_filepath": "problem_iter27_response2.txt_stdout.txt",
    "code_path": "problem_iter27_code2.py",
    "code": "import numpy as np\n\nsigmoid_scale = 1.0\nbest_bin_boost = 1.0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        best_bin_index = np.argmin(waste)\n        \n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n        priorities[valid_bins] = sigmoid_scaled_waste\n        \n        priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n        \n        for i in range(len(bins_remain_cap)):\n            if valid_bins[i]:\n                if i != np.where(valid_bins)[0][best_bin_index]:\n                    \n                    priority_reduction = 0.1 * (waste[best_bin_index] - waste[np.where(valid_bins)[0][i]])\n                    \n                    if priority_reduction > 0:\n                        priorities[i] -= priority_reduction\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999971709999954 seconds"
  },
  {
    "stdout_filepath": "problem_iter27_response3.txt_stdout.txt",
    "code_path": "problem_iter27_code3.py",
    "code": "import numpy as np\n\nsigmoid_scale = 5.0\nbest_bin_boost = 1.0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        best_bin_index = np.argmin(waste)\n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n        priorities[valid_bins] = sigmoid_scaled_waste\n        priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n        \n        penalty = 0.1\n        for i in range(len(bins_remain_cap)):\n            if valid_bins[i] and i != np.where(valid_bins)[0][best_bin_index]:\n                priorities[i] -= penalty * (bins_remain_cap[i] - item)\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997259099996 seconds"
  },
  {
    "stdout_filepath": "problem_iter27_response4.txt_stdout.txt",
    "code_path": "problem_iter27_code4.py",
    "code": "import numpy as np\n\nsigmoid_scale = 5.0\nbest_bin_boost = 1.0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Enhanced priority function for Online Bin Packing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        best_bin_index = np.argmin(waste)\n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n        priorities[valid_bins] = sigmoid_scaled_waste\n        priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n        \n        remaining_bins_indices = np.where(valid_bins)[0]\n        \n        for i in remaining_bins_indices:\n            if i != np.where(valid_bins)[0][best_bin_index]:\n                priorities[i] += 0.1 * (bins_remain_cap[i] / np.max(bins_remain_cap))\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999973379999574 seconds"
  },
  {
    "stdout_filepath": "problem_iter28_response0.txt_stdout.txt",
    "code_path": "problem_iter28_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, exploration_factor_min: float = 0.5562127205763006, exploration_factor_max: float = 1.5637184622296219, small_value: float = 0.0002827948637643275) -> np.ndarray:\n    \"\"\"Combines best-fit with a dynamic exploration factor based on average remaining capacity.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  }
]