[
  {
    "stdout_filepath": "problem_iter23_response0.txt_stdout.txt",
    "code_path": "problem_iter23_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with diversity and mild worst-fit penalty.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    best_bin_index = np.argmin(waste)\n    worst_bin_index = np.argmax(waste)\n    best_fit_component = np.zeros_like(bins_remain_cap)\n    best_fit_component[valid_bins] = 1 / (1 + np.exp(-waste * 5))\n    diversity_component = np.zeros_like(bins_remain_cap)\n    bin_usage = 1 - bins_remain_cap / np.max(bins_remain_cap)\n    diversity_component[valid_bins] = bin_usage[valid_bins]\n    priorities = 0.6 * best_fit_component + 0.4 * diversity_component\n    priorities[possible_bins][best_bin_index] += 0.2\n    priorities[possible_bins][worst_bin_index] -= 0.05\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 19, in priority_v2\n    priorities[valid_bins] += 0.1 * np.random.rand(np.sum(valid_bins))\nNameError: name 'possible_bins' is not defined\n18\n2\n194.3192398051029\n"
  },
  {
    "stdout_filepath": "problem_iter23_response1.txt_stdout.txt",
    "code_path": "problem_iter23_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit waste minimization with diversity and exploration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    best_fit_score = -waste\n    bin_counts = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] > 0:\n            bin_counts[i] = 1\n    diversity_score = bin_counts[valid_bins]\n    priorities[valid_bins] = (0.7 * best_fit_score + 0.3 * diversity_score)\n    best_bin_index = np.argmin(waste)\n    priorities[valid_bins][best_bin_index] += 1.0\n    priorities[valid_bins] += 0.1 * np.random.rand(np.sum(valid_bins))\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 19, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n17\n4\n145.71363126237387\n"
  },
  {
    "stdout_filepath": "problem_iter23_response2.txt_stdout.txt",
    "code_path": "problem_iter23_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a mild worst-fit penalty and explicit invalid bin handling.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n    worst_bin_index = np.argmax(waste)\n    priorities[np.where(valid_bins)[0][worst_bin_index]] += 0.1\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response3.txt_stdout.txt",
    "code_path": "problem_iter23_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with worst-fit penalty and diversity.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n    worst_bin_index = np.argmax(waste)\n    priorities[np.where(valid_bins)[0][worst_bin_index]] += 0.1\n    diversity_score = 1.0 / (np.sum(valid_bins) + 1e-6)\n    priorities[valid_bins] += 0.05 * diversity_score\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 14, in priority_v2\n    priorities[valid_bins][best_bin_index] += 0.5\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n12\n2\n131.18329672565338\n"
  },
  {
    "stdout_filepath": "problem_iter23_response4.txt_stdout.txt",
    "code_path": "problem_iter23_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (v0) with handling no valid bins (v1) for robustness.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        sigmoid_scale = 5.0\n        sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n        priorities[valid_bins] = sigmoid_scaled_waste\n        best_bin_index = np.argmin(waste)\n        worst_bin_index = np.argmax(waste)\n        priorities[valid_bins][best_bin_index] += 0.5\n        priorities[valid_bins][worst_bin_index] -= 0.1\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 13.40247307538892,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 97.70233280920246,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response5.txt_stdout.txt",
    "code_path": "problem_iter23_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit waste minimization with a mild worst-fit penalty and diversity.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n    worst_bin_index = np.argmax(waste)\n    priorities[valid_bins][worst_bin_index] -= 0.1\n    diversity_score = 1.0 / (np.sum(valid_bins) + 1e-6)\n    priorities[valid_bins] += 0.05 * diversity_score\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 14, in priority_v2\n    priorities[possible_bins][worst_bin_index] -= 0.2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n12\n2\n131.18329672565338\n"
  },
  {
    "stdout_filepath": "problem_iter23_response6.txt_stdout.txt",
    "code_path": "problem_iter23_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a mild worst-fit penalty and handles invalid bins.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = 1 / (1 + np.exp(-waste * 2.0))\n    best_bin_index = np.argmin(waste)\n    worst_bin_index = np.argmax(waste)\n    priorities[possible_bins][best_bin_index] += 1.0\n    priorities[possible_bins][worst_bin_index] -= 0.2\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 27.173913043478258,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 114.20025299224778,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response7.txt_stdout.txt",
    "code_path": "problem_iter23_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a worst-fit penalty and a diversity component for adaptable bin selection.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n\n    worst_bin_index = np.argmax(waste)\n    priorities[np.where(valid_bins)[0][worst_bin_index]] += 0.1\n\n    diversity_score = 1.0 / (np.sum(valid_bins) + 1e-6)\n    priorities[valid_bins] += 0.05 * diversity_score\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 17, in priority_v2\n    \nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n12\n2\n131.18329672565338\n"
  },
  {
    "stdout_filepath": "problem_iter23_response8.txt_stdout.txt",
    "code_path": "problem_iter23_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with diversity and exploration for robust bin packing.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    best_bin_index = np.argmin(waste)\n    bin_usage = 1 - bins_remain_cap / np.max(bins_remain_cap)\n\n    best_fit_component = 1 / (1 + np.exp(-waste * 5))\n    diversity_component = bin_usage\n\n    alpha = 0.7\n    beta = 0.3\n    priorities[valid_bins] = alpha * best_fit_component + beta * diversity_component\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 0.5\n\n    exploration_rate = 0.1\n    if np.random.rand() < exploration_rate:\n        random_bin_index = np.random.choice(n_bins)\n        priorities[random_bin_index] = np.max(priorities) + 1\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.208216992421225,
    "SLOC": 20.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 213.03044134663566,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response9.txt_stdout.txt",
    "code_path": "problem_iter23_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a mild worst-fit penalty and exploration.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (waste + 1e-9)\n\n    worst_bin_index = np.argmax(waste)\n    priorities[valid_bins][worst_bin_index] -= 0.1\n\n    exploration_rate = 0.1\n    priorities[valid_bins] += exploration_rate * np.random.rand(np.sum(valid_bins))\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 17, in priority_v2\n    diversity_component[valid_bins] = bin_usage[valid_bins]\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n12\n2\n99.40434618240934\n"
  },
  {
    "stdout_filepath": "problem_iter24_response0.txt_stdout.txt",
    "code_path": "problem_iter24_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    A priority function for online bin packing that dynamically adjusts exploration vs. exploitation.\n    It combines best-fit, worst-fit, and a dynamic exploration boost.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    waste = bins_remain_cap[valid_bins] - item\n    best_bin_index = np.argmin(waste)\n    worst_bin_index = np.argmax(waste)\n\n    priorities[valid_bins] = 0.5 * (1 / (1 + np.exp(-waste))) + 0.5 * (waste / np.max(waste))\n    \n    exploration_boost = 0.1\n    \n    \n    \n    if np.random.rand() < exploration_boost:\n        \n        priorities[valid_bins] = 0.8 * priorities[valid_bins] + 0.2 * (1 / (np.arange(1, len(valid_bins) + 1)))\n        \n\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 0.1\n    priorities[np.where(valid_bins)[0][worst_bin_index]] -= 0.05\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 111.1687275628241,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 268.8361000750002,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response1.txt_stdout.txt",
    "code_path": "problem_iter24_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    A priority function for online bin packing that dynamically adjusts\n    exploration vs. exploitation. It combines best-fit with a time-dependent\n    exploration bonus.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    \n    best_bin_index = np.argmin(waste)\n    \n    exploration_bonus_factor = 0.1 \n    \n    time_step = np.sum(bins_remain_cap > 0)\n    \n    exploration_bonus = exploration_bonus_factor * np.exp(-time_step / n_bins)\n    \n    \n    priorities[valid_bins] = -waste \n    priorities[np.where(valid_bins)[0][best_bin_index]] += 1.0 + exploration_bonus\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 122.13617281353935,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response2.txt_stdout.txt",
    "code_path": "problem_iter24_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    A priority function for online bin packing that combines best-fit,\n    worst-fit, and a dynamic exploration factor.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_capacities = bins_remain_cap[valid_bins]\n    n_valid_bins = len(remaining_capacities)\n\n    best_fit_score = 1.0 / (remaining_capacities - item + 1e-6)\n    worst_fit_score = remaining_capacities\n    \n    exploration_factor = np.random.uniform(0.0, 0.2)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    \n    \n    combined_score = (0.6 * best_fit_score + 0.4 * worst_fit_score) * (1 + exploration_factor)\n    \n    priorities[valid_bins] = combined_score\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 86.55763861188672,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 131.18329672565338,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response3.txt_stdout.txt",
    "code_path": "problem_iter24_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, worst-fit, and a dynamic exploration factor.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    best_bin_index = np.argmin(waste)\n    worst_bin_index = np.argmax(waste)\n\n    exploration_factor = np.mean(bins_remain_cap[valid_bins]) / item if np.mean(bins_remain_cap[valid_bins]) > 0 else 1.0\n    exploration_factor = np.clip(exploration_factor, 0.1, 5.0)\n\n    priorities[valid_bins] = (1 / (waste + 1e-6)) * (1 + exploration_factor * (np.random.rand() - 0.5))\n    priorities[np.where(valid_bins)[0][best_bin_index]] += 2.0\n    priorities[np.where(valid_bins)[0][worst_bin_index]] -= 0.5\n    priorities[priorities < 0] = 0\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.13841244515357,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 201.18251441994926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response4.txt_stdout.txt",
    "code_path": "problem_iter24_code4.py",
    "code": "import numpy as np\n\nsigmoid_scale = 5.0\nbest_bin_boost = 1.0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive priority function combining best-fit, exploration, and dynamic scaling.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    \n    if not np.any(valid_bins):\n        return priorities\n\n    waste = bins_remain_cap[valid_bins] - item\n    \n    avg_waste = np.mean(waste)\n    std_waste = np.std(waste)\n\n    if std_waste == 0:\n      std_waste = 1e-6\n    \n    scaled_waste = (waste - avg_waste) / std_waste\n    \n    sigmoid_scaled_waste = 1 / (1 + np.exp(-scaled_waste * sigmoid_scale))\n    \n    priorities[valid_bins] = sigmoid_scaled_waste\n\n    \n    best_bin_index = np.argmin(waste)\n    \n    \n    exploration_boost = np.random.rand(n_bins) * 0.1\n    priorities[valid_bins] += exploration_boost[valid_bins]\n    \n    priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 179.74529681972018,
    "exec_success": true
  }
]