{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit with a worst-fit penalty to promote diversity.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (waste + 1e-9)\n        \n        worst_bin_index = np.argmax(waste)\n        priorities[valid_bins][worst_bin_index] += 0.5\n        \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit and worst-fit strategies with sigmoid scaling for robust bin selection.\"\"\"\n    sigmoid_scale = 5.0\n    best_bin_boost = 1.0\n    worst_fit_penalty = 0.5\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    best_bin_index = np.argmin(waste)\n    worst_bin_index = np.argmax(waste)\n    sigmoid_scaled_waste = 1 / (1 + np.exp(-waste * sigmoid_scale))\n    priorities[valid_bins] = sigmoid_scaled_waste\n    priorities[np.where(valid_bins)[0][best_bin_index]] += best_bin_boost\n    priorities[np.where(valid_bins)[0][worst_bin_index]] -= worst_fit_penalty\n    return priorities\n\n### Analyze & experience\n- Comparing Heuristics 1st vs 2nd, the 1st utilizes a sigmoid scaling on waste *and* a boost for the best bin, introducing parameters tuned for stability. The 2nd relies solely on inverse waste and a simple boost/penalty, lacking the smoothing effect of the sigmoid.  Comparing Heuristics 2nd vs 3rd, 4th, 5th, they are identical.\n\nComparing 1st vs 6th, the 1st's sigmoid is a key difference, stabilizing priority scores and preventing extreme values. 6th uses a simple inverse waste, which can be sensitive. Comparing 6th vs 7th, 8th, 9th, they are identical.\n\nComparing 6th vs 10th, 10th adds a penalty to the *worst* bin, intended to promote diversity. But subtracting a constant value may not be as effective as the sigmoid scaling, and can cause negative priorities.  11th through 13th are very similar, focusing on best-fit with a mild worst-fit penalty. 14th & 15th introduce sigmoid scaling to both best and worst bins, and a penalty for worst bin. 16th & 17th use a smaller worst fit penalty. 18th, 19th and 20th combine best fit and a worst fit penalty.\n\nOverall: The best heuristics (1st) intelligently combines best-fit with techniques to stabilize the priority scores and to prevent extreme values by scaling and boosting. The worst heuristics (20th) rely on simple inverse waste and lack the stabilizing features seen in the best, as well as lack of a smoothing effect.  The repeated heuristics contribute nothing to comparative insight.\n- \nOkay, let's redefine \"Current Self-Reflection\" for superior heuristic design, aiming for that $999K! Here's a breakdown, learning *from* the \"Ineffective\" notes to avoid past pitfalls:\n\n* **Keywords:** Meta-optimization, Balance, Stability, Exploration/Exploitation.\n* **Advice:** Focus on *balancing* exploitation (best-fit boosts) with exploration (worst-fit penalties). Prioritize robust, parameter-driven control (like sigmoid scaling) over problem-specific 'cleverness'.\n* **Avoid:** Directly optimizing for the *objective* within the heuristic itself. Don't chase immediate waste reduction; prioritize stable, diverse search. Resist dynamic adjustments *without* thorough testing.\n* **Explanation:** The \"Ineffective\" reflections overly focused on bin-packing specifics & direct optimization, causing instability. True improvement comes from controlling the *search process*, not micro-managing bin choices.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}