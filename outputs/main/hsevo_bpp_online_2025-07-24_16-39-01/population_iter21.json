[
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Heuristics combining utilization factor, relative remaining capacity, and effective tie-breaker.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Calculate new utilization factor and relative remaining capacity\n    new_utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    relative_remain_cap = (bins_remain_cap - item) / (bins_remain_cap + epsilon)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, -np.abs(new_utilization_factor) + relative_remain_cap, -np.inf)\n    \n    # Effective tie-breaker based on bin index and small random noise\n    num_bins = len(bins_remain_cap)\n    bin_index_factor = np.log(num_bins / (1 + np.arange(num_bins)))\n    random_noise = np.random.uniform(0, 1, size=num_bins) * tie_breaker_coef\n    priority += (bins_remain_cap >= item) * (bin_index_factor + random_noise)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Heuristic combining refined utilization factor and bin index tie-breaker.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Refined utilization factor\n    utilization_factor = np.exp(-((bins_remain_cap - item) / (item + epsilon)) ** 2)\n    utilization_score = bins_remain_cap / (item + epsilon)  # Additional utilization score\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, utilization_factor * utilization_score, -np.inf)\n    \n    # Incorporate a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef\n    \n    # Normalize priority scores\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  \n        priority = np.where(priority != -np.inf, priority - max_priority, -np.inf)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 7.678500199441564,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization, remaining capacity, and bin index for effective bin selection.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate remaining capacity and utilization after adding the item\n    remaining_after_addition = bins_remain_cap[valid_bins] - item\n    utilization_after_addition = 1.0 - remaining_after_addition / bins_remain_cap[valid_bins]\n    \n    # Priority score combines negative remaining capacity and utilization\n    priority_scores_valid = -np.abs(remaining_after_addition / bins_remain_cap[valid_bins] - 0.5) + utilization_after_addition\n    \n    # Create array to store priority scores for all bins\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priority_scores[valid_bins] = priority_scores_valid\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker_coef = 1e-3\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef, \n                               -np.inf)\n    \n    # Introduce a small adjustment based on remaining capacity\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + bins_remain_cap / np.max(bins_remain_cap) * tie_breaker_coef * 0.1, \n                               -np.inf)\n    \n    return priority_scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.447546868767465,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response3.txt_stdout.txt",
    "code_path": "problem_iter20_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, remaining capacity, and bin index for prioritization.\n    \"\"\"\n    # Calculate utilization factor after adding the item\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, 1e-8)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, -(np.abs(utilization_factor - 0.5) + 0.1 * (1 - bins_remain_cap / np.max(bins_remain_cap))), -np.inf)\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * np.log(num_bins / (1 + np.arange(num_bins))) * 1e-6\n    \n    # Introduce a small random noise for further tie-breaking\n    np.random.seed(int(item * 1e6))  \n    priority += (bins_remain_cap >= item) * np.random.uniform(-1e-8, 1e-8, size=num_bins)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 47.975668129238144,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines refined utilization factor and remaining capacity with a simple tie-breaker for online Bin Packing Problem.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate remaining capacity and utilization after adding the item\n    remaining_after_addition = bins_remain_cap[valid_bins] - item\n    utilization_factor = np.exp(-((bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]) ** 2)\n    \n    # Priority score combines utilization factor and negative remaining capacity\n    priority_scores_valid = -remaining_after_addition + utilization_factor\n    \n    # Create array to store priority scores for all bins\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priority_scores[valid_bins] = priority_scores_valid\n    \n    # Add a simple tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker_coef = 1e-3\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef, \n                               -np.inf)\n    \n    return priority_scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for the tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and fit score for prioritization with an enhanced tie-breaker.\n    \"\"\"\n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    fit_score = 1 - (item / np.maximum(bins_remain_cap, epsilon))\n    \n    # Priority score for bins that can fit the item, using a combination of utilization and fit score\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) - fit_score * 0.1, -np.inf)\n    \n    # Enhanced tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and fit score with a tie-breaker for effective prioritization.\n    \"\"\"\n    # Constants\n    epsilon = 1e-6  # Avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Calculate utilization factor and fit score\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, \n                        # Combine utilization factor and fit score\n                        0.5 * utilization_factor + 0.5 * fit_score, \n                        -np.inf)\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 149.10251296370166,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response7.txt_stdout.txt",
    "code_path": "problem_iter20_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit score and a tie-breaker based on bin index for online Bin Packing Problem.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Fit score: prioritize bins where the item fits well\n    fit_score = np.where(bins_remain_cap >= item, -(np.abs(remaining_cap_after_addition)), -np.inf)\n    \n    # Tie-breaker based on bin index with a small coefficient\n    tie_breaker = np.log(len(bins_remain_cap) / (1 + np.arange(len(bins_remain_cap)))) * 1e-3\n    \n    # Add a small random noise for further tie-breaking\n    random_noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    # Combine fit score, tie-breaker, and random noise\n    priority_scores = fit_score + tie_breaker + random_noise\n    \n    return priority_scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines remaining capacity and utilization with a logarithmic bin index tie-breaker.\n    Prioritizes bins that fit the item, have high utilization, and lower index.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap[valid_bins] - item\n    \n    # Calculate utilization after adding the item\n    bin_utilization_after_addition = 1 - (remaining_after_addition / (bins_remain_cap[valid_bins] + 1e-6))  # Avoid division by zero\n    \n    # Priority score combines negative remaining capacity and utilization\n    priority_scores_valid = -remaining_after_addition + bin_utilization_after_addition\n    \n    # Create array to store priority scores for all bins\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priority_scores[valid_bins] = priority_scores_valid\n    \n    # Add a tie-breaker based on bin index with a small coefficient\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + 0.01 * np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    return priority_scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit score, remaining capacity, and a tie-breaker for online Bin Packing Problem.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Fit score: prioritize bins where the item fits well\n    fit_score = np.where(bins_remain_cap >= item, -(np.abs(remaining_cap_after_addition)), -np.inf)\n    \n    # Secondary prioritization based on remaining capacity\n    secondary_priority = np.where(bins_remain_cap >= item, -bins_remain_cap / np.max(bins_remain_cap), 0)\n    \n    # Tie-breaker based on bin index\n    tie_breaker = np.log(len(bins_remain_cap) / (1 + np.arange(len(bins_remain_cap)))) * 1e-3\n    \n    # Combine fit score, secondary priority, and tie-breaker\n    priority_scores = fit_score + secondary_priority + tie_breaker\n    \n    return priority_scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response0.txt_stdout.txt",
    "code_path": "problem_iter21_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    An advanced priority function that combines the remaining capacity, utilization factor, \n    and a sophisticated tie-breaker for online Bin Packing Problem.\n    \n    Parameters:\n    - item: The size of the item to be packed.\n    - bins_remain_cap: An array of the remaining capacities of the bins.\n    \n    Returns:\n    - priority: An array of priority scores for each bin.\n    \"\"\"\n    epsilon = 1e-6  # Small value to avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for the tie-breaker\n    \n    # Calculate the utilization factor after packing the item, avoiding division by zero\n    new_utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap - item + epsilon, epsilon)\n    \n    # Priority score for bins that can fit the item, based on the new utilization factor after packing\n    priority = np.where(bins_remain_cap >= item, new_utilization_factor, -np.inf)\n    \n    # Introduce a sophisticated tie-breaker that considers both bin fullness and index\n    num_bins = len(bins_remain_cap)\n    bin_fullness = 1 - (bins_remain_cap / (np.max(bins_remain_cap) + epsilon))  # Normalize bin fullness\n    tie_breaker = (bins_remain_cap >= item) * ((bin_fullness * 0.7) + (np.log(num_bins / (1 + np.arange(num_bins))) / np.log(num_bins) * 0.3))\n    \n    # Combine the priority score with the tie-breaker\n    priority += tie_breaker * tie_breaker_coef\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 5.394894295971294,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 211.52361657053456,
    "mi": 89.5256429006552,
    "token_count": 137.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response1.txt_stdout.txt",
    "code_path": "problem_iter21_code1.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function combining multiple factors for effective bin selection in online Bin Packing Problem.\n    \"\"\"\n    # Mask for bins that can fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate the 'First-Fit Decreasing Height' inspired score, normalized by bin capacity\n    ff_score = (bins_remain_cap - item) / (bins_remain_cap.max() + epsilon)\n    \n    # Utilization factor, avoiding division by zero\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Combine utilization factor and a 'best-fit' criterion for prioritization\n    priority = np.where(valid_bins, -np.abs(utilization_factor) + ff_score, -np.inf)\n    \n    # Introduce a randomness component with a decaying factor based on bin index for tie-breaking\n    num_bins = len(bins_remain_cap)\n    randomness_component = valid_bins * (np.random.rand(num_bins) * np.exp(-np.arange(num_bins) / num_bins))\n    \n    # Add tie-breaker components\n    priority += tie_breaker_coef * (valid_bins * (np.log(num_bins / (1 + np.arange(num_bins)))) + randomness_component)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 86.75708017550858,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 211.52361657053456,
    "mi": 89.5256429006552,
    "token_count": 137.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response2.txt_stdout.txt",
    "code_path": "problem_iter21_code2.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # A small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for the tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    An advanced priority function that combines multiple factors for effective bin selection in online Bin Packing Problem.\n    \n    It considers the remaining capacity, utilization factor, and a dynamic tie-breaker based on bin index and randomness.\n    \"\"\"\n    # Calculate utilization factor, focusing on how much the bin will be utilized if the item is placed in it\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # First component of priority: Bins that can fit the item get a score based on their utilization factor\n    priority = np.where(bins_remain_cap >= item, -utilization_factor, -np.inf)\n    \n    # Second component: Add a tie-breaker that combines bin index (to avoid always filling the first bins) and randomness (for exploration)\n    num_bins = len(bins_remain_cap)\n    tie_breaker = np.log(num_bins / (1 + np.arange(num_bins))) + np.random.uniform(0, tie_breaker_coef, size=num_bins)\n    priority += (bins_remain_cap >= item) * tie_breaker\n    \n    # Normalize the priority scores to ensure they are on the same scale and to enhance numerical stability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  # Check if there are bins that can fit the item\n        priority = np.where(priority != -np.inf, priority - max_priority, -np.inf)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 211.52361657053456,
    "mi": 89.5256429006552,
    "token_count": 137.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response3.txt_stdout.txt",
    "code_path": "problem_iter21_code3.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Improved priority function that combines multiple factors for effective bin selection.\n    \"\"\"\n    # Calculate the fraction of remaining capacity after placing the item\n    post_utilization = (bins_remain_cap - item) / (bins_remain_cap + epsilon)\n    \n    # Priority score is a combination of the post-utilization factor and the remaining capacity\n    # for bins that can fit the item, with a penalty for bins that are too full or too empty\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(post_utilization - 0.5) + 0.5 - (bins_remain_cap - item) / (1 + bins_remain_cap.max()), \n                        -np.inf)\n    \n    # Introduce a randomness component with a decaying coefficient based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.random.rand(num_bins) * tie_breaker_coef / (1 + np.arange(num_bins)))\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 11.049062624650974,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 211.52361657053456,
    "mi": 89.5256429006552,
    "token_count": 137.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response4.txt_stdout.txt",
    "code_path": "problem_iter21_code4.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for the tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that combines remaining capacity, utilization factor, \n    and a sophisticated tie-breaker for online Bin Packing Problem.\n    \"\"\"\n    # Calculate utilization factor, ensuring no division by zero\n    utilization_factor = 1 - (item / np.maximum(bins_remain_cap, epsilon))\n    \n    # Priority score for bins that can fit the item, using a combination of utilization and remaining capacity\n    priority = np.where(bins_remain_cap >= item, utilization_factor, -np.inf)\n    \n    # Enhanced tie-breaker: combines bin index and remaining capacity for more nuanced decision-making\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + \n                                               (bins_remain_cap / (1 + np.arange(num_bins)) * tie_breaker_coef * 1e-2))\n    \n    # Final priority score with the enhanced tie-breaker\n    priority += tie_breaker\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 149.10251296370166,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 211.52361657053456,
    "mi": 89.5256429006552,
    "token_count": 137.0,
    "exec_success": true
  }
]