[
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Heuristics combining utilization factor, relative remaining capacity, and effective tie-breaker.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Calculate new utilization factor and relative remaining capacity\n    new_utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    relative_remain_cap = (bins_remain_cap - item) / (bins_remain_cap + epsilon)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, -np.abs(new_utilization_factor) + relative_remain_cap, -np.inf)\n    \n    # Effective tie-breaker based on bin index and small random noise\n    num_bins = len(bins_remain_cap)\n    bin_index_factor = np.log(num_bins / (1 + np.arange(num_bins)))\n    random_noise = np.random.uniform(0, 1, size=num_bins) * tie_breaker_coef\n    priority += (bins_remain_cap >= item) * (bin_index_factor + random_noise)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Heuristic combining refined utilization factor and bin index tie-breaker.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Refined utilization factor\n    utilization_factor = np.exp(-((bins_remain_cap - item) / (item + epsilon)) ** 2)\n    utilization_score = bins_remain_cap / (item + epsilon)  # Additional utilization score\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, utilization_factor * utilization_score, -np.inf)\n    \n    # Incorporate a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef\n    \n    # Normalize priority scores\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  \n        priority = np.where(priority != -np.inf, priority - max_priority, -np.inf)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 7.678500199441564,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization, remaining capacity, and bin index for effective bin selection.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate remaining capacity and utilization after adding the item\n    remaining_after_addition = bins_remain_cap[valid_bins] - item\n    utilization_after_addition = 1.0 - remaining_after_addition / bins_remain_cap[valid_bins]\n    \n    # Priority score combines negative remaining capacity and utilization\n    priority_scores_valid = -np.abs(remaining_after_addition / bins_remain_cap[valid_bins] - 0.5) + utilization_after_addition\n    \n    # Create array to store priority scores for all bins\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priority_scores[valid_bins] = priority_scores_valid\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker_coef = 1e-3\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef, \n                               -np.inf)\n    \n    # Introduce a small adjustment based on remaining capacity\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + bins_remain_cap / np.max(bins_remain_cap) * tie_breaker_coef * 0.1, \n                               -np.inf)\n    \n    return priority_scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.447546868767465,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response3.txt_stdout.txt",
    "code_path": "problem_iter20_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, remaining capacity, and bin index for prioritization.\n    \"\"\"\n    # Calculate utilization factor after adding the item\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, 1e-8)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, -(np.abs(utilization_factor - 0.5) + 0.1 * (1 - bins_remain_cap / np.max(bins_remain_cap))), -np.inf)\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * np.log(num_bins / (1 + np.arange(num_bins))) * 1e-6\n    \n    # Introduce a small random noise for further tie-breaking\n    np.random.seed(int(item * 1e6))  \n    priority += (bins_remain_cap >= item) * np.random.uniform(-1e-8, 1e-8, size=num_bins)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 47.975668129238144,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines refined utilization factor and remaining capacity with a simple tie-breaker for online Bin Packing Problem.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate remaining capacity and utilization after adding the item\n    remaining_after_addition = bins_remain_cap[valid_bins] - item\n    utilization_factor = np.exp(-((bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]) ** 2)\n    \n    # Priority score combines utilization factor and negative remaining capacity\n    priority_scores_valid = -remaining_after_addition + utilization_factor\n    \n    # Create array to store priority scores for all bins\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priority_scores[valid_bins] = priority_scores_valid\n    \n    # Add a simple tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker_coef = 1e-3\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef, \n                               -np.inf)\n    \n    return priority_scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for the tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and fit score for prioritization with an enhanced tie-breaker.\n    \"\"\"\n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    fit_score = 1 - (item / np.maximum(bins_remain_cap, epsilon))\n    \n    # Priority score for bins that can fit the item, using a combination of utilization and fit score\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) - fit_score * 0.1, -np.inf)\n    \n    # Enhanced tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and fit score with a tie-breaker for effective prioritization.\n    \"\"\"\n    # Constants\n    epsilon = 1e-6  # Avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Calculate utilization factor and fit score\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, \n                        # Combine utilization factor and fit score\n                        0.5 * utilization_factor + 0.5 * fit_score, \n                        -np.inf)\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 149.10251296370166,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response7.txt_stdout.txt",
    "code_path": "problem_iter20_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit score and a tie-breaker based on bin index for online Bin Packing Problem.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Fit score: prioritize bins where the item fits well\n    fit_score = np.where(bins_remain_cap >= item, -(np.abs(remaining_cap_after_addition)), -np.inf)\n    \n    # Tie-breaker based on bin index with a small coefficient\n    tie_breaker = np.log(len(bins_remain_cap) / (1 + np.arange(len(bins_remain_cap)))) * 1e-3\n    \n    # Add a small random noise for further tie-breaking\n    random_noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    # Combine fit score, tie-breaker, and random noise\n    priority_scores = fit_score + tie_breaker + random_noise\n    \n    return priority_scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines remaining capacity and utilization with a logarithmic bin index tie-breaker.\n    Prioritizes bins that fit the item, have high utilization, and lower index.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap[valid_bins] - item\n    \n    # Calculate utilization after adding the item\n    bin_utilization_after_addition = 1 - (remaining_after_addition / (bins_remain_cap[valid_bins] + 1e-6))  # Avoid division by zero\n    \n    # Priority score combines negative remaining capacity and utilization\n    priority_scores_valid = -remaining_after_addition + bin_utilization_after_addition\n    \n    # Create array to store priority scores for all bins\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priority_scores[valid_bins] = priority_scores_valid\n    \n    # Add a tie-breaker based on bin index with a small coefficient\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + 0.01 * np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    return priority_scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit score, remaining capacity, and a tie-breaker for online Bin Packing Problem.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Fit score: prioritize bins where the item fits well\n    fit_score = np.where(bins_remain_cap >= item, -(np.abs(remaining_cap_after_addition)), -np.inf)\n    \n    # Secondary prioritization based on remaining capacity\n    secondary_priority = np.where(bins_remain_cap >= item, -bins_remain_cap / np.max(bins_remain_cap), 0)\n    \n    # Tie-breaker based on bin index\n    tie_breaker = np.log(len(bins_remain_cap) / (1 + np.arange(len(bins_remain_cap)))) * 1e-3\n    \n    # Combine fit score, secondary priority, and tie-breaker\n    priority_scores = fit_score + secondary_priority + tie_breaker\n    \n    return priority_scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 147.1612434150308,
    "mi": 88.36353668247742,
    "token_count": 133.0,
    "exec_success": true
  }
]