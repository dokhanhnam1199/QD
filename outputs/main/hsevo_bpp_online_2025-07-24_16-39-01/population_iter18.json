[
  {
    "stdout_filepath": "problem_iter17_response0.txt_stdout.txt",
    "code_path": "problem_iter17_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines remaining capacity and utilization with a simple tie-breaker.\n    Prioritizes bins that fit the item, have high utilization, and lower index.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap[valid_bins] - item\n    \n    # Calculate utilization after adding the item\n    bin_utilization_after_addition = 1 - (remaining_after_addition / bins_remain_cap[valid_bins])\n    \n    # Priority score combines negative remaining capacity and utilization\n    priority_scores_valid = -remaining_after_addition + bin_utilization_after_addition\n    \n    # Create array to store priority scores for all bins\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priority_scores[valid_bins] = priority_scores_valid\n    \n    # Add a simple tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + 0.01 * np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 176.46653521143952,
    "mi": 89.78918830054849,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response1.txt_stdout.txt",
    "code_path": "problem_iter17_code1.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for the tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit score and remaining capacity score for prioritization with an enhanced tie-breaker.\n    \"\"\"\n    # Calculate fit score and remaining capacity score\n    fit_score = 1 - (item / np.maximum(bins_remain_cap, epsilon))\n    remain_cap_score = bins_remain_cap / (item + epsilon)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, -fit_score + remain_cap_score * 0.1, -np.inf)\n    \n    # Enhanced tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.287993617869964,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 176.46653521143952,
    "mi": 89.78918830054849,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response2.txt_stdout.txt",
    "code_path": "problem_iter17_code2.py",
    "code": "import numpy as np\n\neps = 1e-6  # small value to avoid division by zero\ntie_breaker_coef = 0.1  # coefficient for tie-breaker\nrandom_noise_max = 1e-3  # maximum random noise\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and remaining capacity with a simple tie-breaker and logarithmic bin index.\n    Uses a more straightforward utilization factor calculation and adds random noise for tie-breaking.\n    \"\"\"\n    # Calculate utilization factor\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, eps)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor), -np.inf)\n    \n    # Add a tie-breaker based on bin index with a small coefficient and random noise\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef + \n                                              np.random.uniform(0, random_noise_max, size=num_bins))\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.168328679696844,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 176.46653521143952,
    "mi": 89.78918830054849,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response3.txt_stdout.txt",
    "code_path": "problem_iter17_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Heuristic combining fit score, utilization, and bin index tie-breaker.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Fit score and utilization score\n    fit_score = np.abs(bins_remain_cap - item)\n    utilization_score = bins_remain_cap\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, -(fit_score / np.maximum(bins_remain_cap, epsilon)) + utilization_score / np.maximum(bins_remain_cap, epsilon), -np.inf)\n    \n    # Incorporate a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    # Normalize priority scores\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  \n        priority = np.where(priority != -np.inf, priority - max_priority, -np.inf)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 176.46653521143952,
    "mi": 89.78918830054849,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response4.txt_stdout.txt",
    "code_path": "problem_iter17_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit score and a simple tie-breaker for online Bin Packing Problem.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Fit score: prioritize bins where the item fits well\n    fit_score = np.where(bins_remain_cap >= item, -(np.abs(remaining_cap_after_addition)), -np.inf)\n    \n    # Simple tie-breaker based on bin index\n    tie_breaker = np.log(len(bins_remain_cap) / (1 + np.arange(len(bins_remain_cap)))) * 1e-3\n    \n    # Combine fit score and tie-breaker\n    priority_scores = fit_score + tie_breaker\n    \n    return priority_scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 176.46653521143952,
    "mi": 89.78918830054849,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response5.txt_stdout.txt",
    "code_path": "problem_iter17_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and a simple tie-breaker for prioritization.\n    \"\"\"\n    # Calculate utilization factor after adding the item, avoiding division by zero\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, 1e-8)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor), -np.inf)\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * 1e-6)\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 176.46653521143952,
    "mi": 89.78918830054849,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response6.txt_stdout.txt",
    "code_path": "problem_iter17_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and a simple tie-breaker for effective prioritization.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    # Calculate a utilization factor that rewards bins with just enough capacity\n    utilization_factor = np.exp(-((bins_remain_cap - item) / (item + epsilon)) ** 2)\n    \n    # Assign a high priority score to bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, utilization_factor, -np.inf)\n    \n    # Introduce a simple tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3\n    \n    # Combine the priority score with the tie-breaker\n    priority += tie_breaker\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 176.46653521143952,
    "mi": 89.78918830054849,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response7.txt_stdout.txt",
    "code_path": "problem_iter17_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit score, remaining capacity, and bin index for effective prioritization.\n    \"\"\"\n    # Calculate relative size and fit score\n    epsilon = 1e-6  # Avoid division by zero\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n\n    # Calculate priority score\n    max_capacity = np.max(bins_remain_cap) + item  # Assuming all bins have the same max capacity\n    priority = np.where(bins_remain_cap >= item, \n                        fit_score + 0.1 * (max_capacity - bins_remain_cap), \n                        -np.inf)\n\n    # Add a simple tie-breaker based on bin index with a small coefficient\n    num_bins = len(bins_remain_cap)\n    priority = np.where(priority != -np.inf, priority + np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3, -np.inf)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 176.46653521143952,
    "mi": 89.78918830054849,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response8.txt_stdout.txt",
    "code_path": "problem_iter17_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines prioritizing bins with just enough capacity and a robust tie-breaking strategy.\n    \"\"\"\n    # Prioritize bins with just enough capacity and consider utilization factor\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item) + 0.1 * (item / bins_remain_cap), -np.inf)\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority_scores += np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3\n    \n    # Add a small random noise for further tie-breaking\n    priority_scores += np.random.rand(*priority_scores.shape) * 1e-6\n    \n    return priority_scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 176.46653521143952,
    "mi": 89.78918830054849,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response9.txt_stdout.txt",
    "code_path": "problem_iter17_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization and remaining capacity with a simple tie-breaker for online Bin Packing Problem.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate remaining capacity and utilization after adding the item\n    remaining_after_addition = bins_remain_cap[valid_bins] - item\n    utilization_after_addition = 1.0 - remaining_after_addition / bins_remain_cap[valid_bins]\n    \n    # Priority score combines negative remaining capacity and utilization\n    priority_scores_valid = -remaining_after_addition + utilization_after_addition\n    \n    # Create array to store priority scores for all bins\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priority_scores[valid_bins] = priority_scores_valid\n    \n    # Add a simple tie-breaker based on bin index with a smaller coefficient\n    num_bins = len(bins_remain_cap)\n    tie_breaker_coef = 1e-3\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef, \n                               -np.inf)\n    \n    return priority_scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 176.46653521143952,
    "mi": 89.78918830054849,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response0.txt_stdout.txt",
    "code_path": "problem_iter18_code0.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for the tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced prioritization function that combines multiple factors and uses an effective tie-breaker.\n    \"\"\"\n    # Calculate the utilization factor after placing the item, avoiding division by zero\n    new_utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Calculate the relative remaining capacity after placing the item\n    relative_remain_cap = (bins_remain_cap - item) / (bins_remain_cap + epsilon)\n    \n    # Priority score for bins that can fit the item, combining utilization factor and relative remaining capacity\n    priority = np.where(bins_remain_cap >= item, -np.abs(new_utilization_factor) + relative_remain_cap, -np.inf)\n    \n    # Introduce a tie-breaker based on a combination of bin index and a random noise for bins that can fit the item\n    num_bins = len(bins_remain_cap)\n    bin_index_factor = np.log(num_bins / (1 + np.arange(num_bins)))\n    random_noise = np.random.uniform(0, 1, size=num_bins) * tie_breaker_coef\n    priority += (bins_remain_cap >= item) * (bin_index_factor + random_noise)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 341.2150500951926,
    "mi": 89.991727230818,
    "token_count": 178.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response1.txt_stdout.txt",
    "code_path": "problem_iter18_code1.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced prioritization function that combines multiple factors for online Bin Packing Problem.\n    \"\"\"\n    # Calculate the fraction of remaining capacity after placing the item\n    remaining_fraction = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Assign high priority to bins that can fit the item and have a remaining fraction close to zero\n    priority = np.where(bins_remain_cap >= item, -np.abs(remaining_fraction - 0.5), -np.inf)\n    \n    # Introduce a secondary prioritization based on the remaining capacity\n    priority += (bins_remain_cap >= item) * (-bins_remain_cap / np.max(bins_remain_cap))\n    \n    # Add a tie-breaker based on bin index with a small coefficient\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    # Add a small random noise to the priority for further tie-breaking\n    np.random.seed(0)  # For reproducibility\n    priority += (bins_remain_cap >= item) * (np.random.rand(num_bins) * tie_breaker_coef * 0.1)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 10.779816513761482,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 341.2150500951926,
    "mi": 89.991727230818,
    "token_count": 178.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response2.txt_stdout.txt",
    "code_path": "problem_iter18_code2.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that combines multiple factors for bin prioritization.\n    \"\"\"\n    # Calculate the fraction of remaining capacity after placing the item\n    remaining_fraction = (bins_remain_cap - item) / bins_remain_cap.max()\n    \n    # Calculate a score based on how well the item fits into the bin\n    fit_score = np.where(bins_remain_cap >= item, 1 - np.abs((bins_remain_cap - item) / bins_remain_cap), -np.inf)\n    \n    # Calculate a utilization factor, avoiding division by zero\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Priority score is a weighted sum of fit score and utilization factor\n    priority = np.where(bins_remain_cap >= item, 0.7 * fit_score + 0.3 * utilization_factor, -np.inf)\n    \n    # Add a tie-breaker based on bin index with a small coefficient\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    # Introduce a small random noise for further tie-breaking\n    np.random.seed(0)  # For reproducibility\n    priority += (bins_remain_cap >= item) * np.random.uniform(0, tie_breaker_coef, size=num_bins)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 341.2150500951926,
    "mi": 89.991727230818,
    "token_count": 178.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response3.txt_stdout.txt",
    "code_path": "problem_iter18_code3.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced prioritization function combining multiple factors for online Bin Packing Problem.\n    \"\"\"\n    # Calculate the utilization factor after placing the item, handling potential division by zero\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Calculate a 'fit score' that rewards bins where the item fits well (leaving minimal remaining capacity)\n    fit_score = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    # Priority is a weighted sum of utilization factor and fit score\n    priority = 0.5 * utilization_factor + 0.5 * fit_score\n    \n    # Introduce a tie-breaker based on bin index to favor bins that were created earlier\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    # Add a small random noise to the priority for bins that can fit the item, to avoid deterministic tie-breaks\n    np.random.seed(0)  # For reproducibility\n    random_noise = (bins_remain_cap >= item) * np.random.uniform(-tie_breaker_coef, tie_breaker_coef, size=num_bins)\n    priority += random_noise\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 341.2150500951926,
    "mi": 89.991727230818,
    "token_count": 178.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response4.txt_stdout.txt",
    "code_path": "problem_iter18_code4.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Improved priority function that combines multiple factors for effective bin selection.\n    \"\"\"\n    # Calculate the fraction of remaining capacity after placing the item\n    remaining_fraction = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Priority score for bins that can fit the item, using a combination of remaining fraction and remaining capacity\n    priority = np.where(bins_remain_cap >= item, -np.abs(remaining_fraction - 0.5), -np.inf)\n    \n    # Add a tie-breaker based on the bin's remaining capacity and index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (\n        np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef + \n        bins_remain_cap / np.max(bins_remain_cap) * tie_breaker_coef * 0.1\n    )\n    \n    # Introduce a small random noise for further tie-breaking\n    np.random.seed(int(item * 1e6))  # Seed based on item size for reproducibility\n    priority += (bins_remain_cap >= item) * np.random.uniform(-tie_breaker_coef * 1e-2, tie_breaker_coef * 1e-2, size=num_bins)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 42.780215396888714,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 341.2150500951926,
    "mi": 89.991727230818,
    "token_count": 178.0,
    "exec_success": true
  }
]