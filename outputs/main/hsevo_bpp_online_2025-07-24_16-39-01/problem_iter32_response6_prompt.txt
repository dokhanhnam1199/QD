{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\nepsilon = 1e-6  # small value to avoid division by zero\ntie_breaker_coef = 1e-3  # coefficient for tie-breaker\n\n    \"\"\"\n    Enhanced priority function that balances utilization factor, remaining capacity, \n    and a novel tie-breaker based on the bin's relative remaining capacity.\n    \"\"\"\n    # Calculate the utilization factor after placing the item in each bin\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Calculate a weighted score combining utilization factor and remaining capacity\n    score = np.where(bins_remain_cap >= item, -0.5 * np.abs(utilization_factor) + 0.5 * (bins_remain_cap - item) / bins_remain_cap.max(), -np.inf)\n    \n    # Introduce a novel tie-breaker that favors bins with remaining capacity closer to the item size\n    tie_breaker = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), 0)\n    \n    # Combine the score and tie-breaker\n    priority = score + tie_breaker_coef * tie_breaker\n    \n    # Add a secondary tie-breaker based on bin index to ensure a deterministic order\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef ** 2)\n    \n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\n    \"\"\"\n    Enhanced priority function that balances utilization factor, remaining capacity, and a novel tie-breaker.\n    \"\"\"\n    # Calculate a normalized utilization factor, considering both the item size and bin remaining capacity\n    utilization_factor = 1 - (item / np.maximum(bins_remain_cap, epsilon))\n    \n    # Priority score for bins that can fit the item, based on a combination of utilization factor and a non-linear remaining capacity term\n    priority = np.where(bins_remain_cap >= item, utilization_factor * (1 - np.exp(-(bins_remain_cap - item))), -np.inf)\n    \n    # Introduce a more nuanced tie-breaker that considers both bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + (bins_remain_cap / (1 + np.sum(bins_remain_cap))) * tie_breaker_coef)\n    \n    # Combine the priority score with the tie-breaker, ensuring that the tie-breaker does not dominate the priority score\n    priority += tie_breaker\n    \n    return priority\n\n### Analyze & experience\n- Comparing the best heuristic (1st) with the worst (20th), we see that the top heuristic utilizes a more nuanced and weighted approach to calculating priority, incorporating multiple factors such as utilization factor, remaining capacity, and a sophisticated tie-breaker with carefully tuned coefficients. In contrast, the lower-ranked heuristics, while similar in structure, either lack the fine-tuning of coefficients or simplify certain aspects of the calculation. For instance, comparing (1st) vs (2nd), the top heuristic has optimized coefficients for its tie-breaker and weighted factors, suggesting the importance of these optimizations. (3rd) vs (4th) and other subsequent pairs show a gradual simplification or less optimal tuning of these elements. Notably, the worst heuristics (19th and 20th) are nearly identical and lack the nuanced weighting seen in the top heuristics. Overall, the key differentiators among the top heuristics are the sophistication of their tie-breakers and the weighting of their scoring factors.\n- \nTo redesign 'Current self-reflection', let's analyze the given information and identify key aspects.\n\n* Keywords: nuanced scoring, weighted factors, robust optimization, tie-breakers, utilization, fit score, remaining capacity.\n* Advice: Combine multiple relevant factors (utilization, fit score, remaining capacity) and use effective tie-breakers (bin index, randomness) with robust optimization methods to fine-tune coefficients.\n* Avoid: Unnecessary complexity, excessive randomness, redundant components, and ineffective prioritization strategies.\n* Explanation: By incorporating multiple factors and using effective tie-breakers with robust optimization, we can create a more balanced and efficient heuristic that avoids common pitfalls like complexity and inefficiency.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}