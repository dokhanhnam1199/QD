{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0004090798450965327, tie_breaker_coef: float = 0.007235820299396483, \n                utilization_weight: float = 0.7972918990003264, remaining_capacity_weight: float = 0.40715313092312244, \n                tie_breaker_log_weight: float = 0.5149245278161441, tie_breaker_norm_weight: float = 0.6260375790742155) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function combining utilization factor, remaining capacity, and a sophisticated tie-breaker.\n    \"\"\"\n    # Normalize remaining capacity to enhance comparison\n    norm_remain_cap = bins_remain_cap / np.max(bins_remain_cap)\n    \n    # Calculate a weighted utilization factor that considers both the item size and bin capacity\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    weighted_utilization = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) * utilization_weight + norm_remain_cap * remaining_capacity_weight, -np.inf)\n    \n    # Priority score for bins that can fit the item, emphasizing both utilization and remaining capacity\n    priority = weighted_utilization\n    \n    # Introduce a more nuanced tie-breaker based on bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_log_weight + norm_remain_cap * tie_breaker_norm_weight) * tie_breaker_coef)\n    priority += tie_breaker\n    \n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\nepsilon = 1e-6  # Avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function combining utilization factor, remaining capacity, and a sophisticated tie-breaker.\n    \"\"\"\n    # Normalize remaining capacity to enhance comparison\n    norm_remain_cap = bins_remain_cap / np.max(bins_remain_cap)\n    \n    # Calculate a weighted utilization factor that considers both the item size and bin capacity\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    weighted_utilization = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) * 0.7 + norm_remain_cap * 0.3, -np.inf)\n    \n    # Priority score for bins that can fit the item, emphasizing both utilization and remaining capacity\n    priority = weighted_utilization\n    \n    # Introduce a more nuanced tie-breaker based on bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * 0.5 + norm_remain_cap * 0.5) * tie_breaker_coef)\n    priority += tie_breaker\n    \n    return priority\n\n[Heuristics 3rd]\nimport numpy as np\n\nepsilon = 1e-6  # Avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function combining utilization factor, remaining capacity, and a sophisticated tie-breaker.\n    \"\"\"\n    # Normalize remaining capacity to enhance comparison\n    norm_remain_cap = bins_remain_cap / np.max(bins_remain_cap)\n    \n    # Calculate a weighted utilization factor that considers both the item size and bin capacity\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    weighted_utilization = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) * 0.7 + norm_remain_cap * 0.3, -np.inf)\n    \n    # Priority score for bins that can fit the item, emphasizing both utilization and remaining capacity\n    priority = weighted_utilization\n    \n    # Introduce a more nuanced tie-breaker based on bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * 0.5 + norm_remain_cap * 0.5) * tie_breaker_coef)\n    priority += tie_breaker\n    \n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that balances utilization, remaining capacity, and bin index for online Bin Packing Problem.\n    \"\"\"\n    # Calculate the 'fitting score' based on how well the item fits into the bin\n    fitting_score = np.where(bins_remain_cap >= item, \n                             1 - np.abs((bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)), \n                             0)  # Score is 0 if the item cannot fit\n    \n    # Priority score is a combination of fitting score and a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority = fitting_score + tie_breaker_coef * (np.log(num_bins / (1 + np.arange(num_bins))))\n    \n    # Ensure bins that cannot fit the item have the lowest priority\n    priority = np.where(bins_remain_cap >= item, priority, -np.inf)\n    \n    return priority\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a simple tie-breaker for effective prioritization.\n    Balances multiple factors and avoids redundant complexity.\n    \"\"\"\n    # Constants to avoid division by zero and for tie-breaker\n    epsilon = 1e-6  \n    tie_breaker_coef = 1e-3  \n    utilization_factor_weight = 0.8  # Weight for utilization factor\n    fit_score_weight = 0.2  # Weight for fit score\n    \n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(utilization_factor) * utilization_factor_weight + fit_score * fit_score_weight, \n                        -np.inf)\n    \n    # Enhanced tie-breaker: combines bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + \n                                              (- (bins_remain_cap - item) / (1 + bins_remain_cap.max()) * 0.01))\n    \n    return priority\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a simple tie-breaker for effective prioritization.\n    Balances multiple factors and avoids redundant complexity.\n    \"\"\"\n    # Constants to avoid division by zero and for tie-breaker\n    epsilon = 1e-6  \n    tie_breaker_coef = 1e-3  \n    utilization_factor_weight = 0.8  # Weight for utilization factor\n    fit_score_weight = 0.2  # Weight for fit score\n    \n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(utilization_factor) * utilization_factor_weight + fit_score * fit_score_weight, \n                        -np.inf)\n    \n    # Enhanced tie-breaker: combines bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + \n                                              (- (bins_remain_cap - item) / (1 + bins_remain_cap.max()) * 0.01))\n    \n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a simple tie-breaker for effective prioritization.\n    Balances multiple factors and avoids redundant complexity.\n    \"\"\"\n    # Constants to avoid division by zero and for tie-breaker\n    epsilon = 1e-6  \n    tie_breaker_coef = 1e-3  \n    utilization_factor_weight = 0.8  # Weight for utilization factor\n    fit_score_weight = 0.2  # Weight for fit score\n    \n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(utilization_factor) * utilization_factor_weight + fit_score * fit_score_weight, \n                        -np.inf)\n    \n    # Enhanced tie-breaker: combines bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + \n                                              (- (bins_remain_cap - item) / (1 + bins_remain_cap.max()) * 0.01))\n    \n    return priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a simple tie-breaker for effective bin selection.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    # Calculate priority score for bins that can fit the item\n    valid_bins = bins_remain_cap >= item\n    remaining_fraction = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    priority = np.where(valid_bins, -remaining_fraction + np.exp(-np.abs(bins_remain_cap - item) / item), -np.inf)\n    \n    # Introduce a tie-breaker based on the bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker_coef = 1e-3\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    # Favor bins that are almost full\n    almost_full_bins = np.logical_and(valid_bins, bins_remain_cap - item < item * 0.1)\n    priority += almost_full_bins * (1 - remaining_fraction) * 0.1\n    \n    # Enhance with remaining capacity factor for valid bins\n    remaining_capacity_factor = bins_remain_cap / (item + epsilon)\n    priority += valid_bins * remaining_capacity_factor * 0.05  # Weighted addition\n    \n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a simple tie-breaker for effective prioritization.\n    \"\"\"\n    epsilon = 1e-6  # Small value to avoid division by zero\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item, balancing utilization factor and fit score\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(utilization_factor) * 0.95 + fit_score * 0.5, \n                        -np.inf)\n    \n    # Simple tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * 0.007)\n    \n    # Favor bins that are almost full to minimize waste\n    almost_full_bins = np.logical_and(bins_remain_cap >= item, bins_remain_cap - item < item * 0.1)\n    priority += almost_full_bins * (1 - np.abs(utilization_factor)) * 0.1\n    \n    # Introduce an additional subtle tie-breaker based on remaining capacity\n    priority += (bins_remain_cap >= item) * (bins_remain_cap / (1 + item) * 0.001)\n    \n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a simple tie-breaker for effective prioritization.\n    Favors bins that are almost full to minimize waste.\n    \"\"\"\n    epsilon = 1e-6  # Small value to avoid division by zero\n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, \n                        # Combine utilization factor and fit score with a bias towards utilization factor\n                        -np.abs(utilization_factor) * 0.95 + fit_score * 0.5, \n                        -np.inf)\n    \n    # Add a simple tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * 0.008)\n    \n    # Slightly favor bins that are almost full to minimize waste\n    almost_full_bins = np.logical_and(bins_remain_cap >= item, bins_remain_cap - item < item * 0.1)\n    priority += almost_full_bins * (1 - np.abs(utilization_factor)) * 0.12\n    \n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a simple tie-breaker for effective bin selection.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    # Calculate priority score for bins that can fit the item\n    valid_bins = bins_remain_cap >= item\n    remaining_fraction = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    priority = np.where(valid_bins, -remaining_fraction + np.exp(-np.abs(bins_remain_cap - item) / item), -np.inf)\n    \n    # Introduce a tie-breaker based on the bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker_coef = 1e-3\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    # Favor bins that are almost full\n    almost_full_bins = np.logical_and(valid_bins, bins_remain_cap - item < item * 0.1)\n    priority += almost_full_bins * (1 - remaining_fraction) * 0.1\n    \n    # Enhance with remaining capacity factor for valid bins\n    remaining_capacity_factor = bins_remain_cap / (item + epsilon)\n    priority += valid_bins * remaining_capacity_factor * 0.05  # Weighted addition\n    \n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a simple tie-breaker for effective bin selection.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    # Calculate priority score for bins that can fit the item\n    valid_bins = bins_remain_cap >= item\n    remaining_fraction = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    priority = np.where(valid_bins, -remaining_fraction + np.exp(-np.abs(bins_remain_cap - item) / item), -np.inf)\n    \n    # Introduce a tie-breaker based on the bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker_coef = 1e-3\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    # Favor bins that are almost full\n    almost_full_bins = np.logical_and(valid_bins, bins_remain_cap - item < item * 0.1)\n    priority += almost_full_bins * (1 - remaining_fraction) * 0.1\n    \n    # Enhance with remaining capacity factor for valid bins\n    remaining_capacity_factor = bins_remain_cap / (item + epsilon)\n    priority += valid_bins * remaining_capacity_factor * 0.05  # Weighted addition\n    \n    return priority\n\n[Heuristics 13th]\nimport numpy as np\n\nepsilon = 1e-6  # small value to avoid division by zero\ntie_breaker_coef = 1e-3  # coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that balances utilization factor, remaining capacity, \n    and a novel tie-breaker based on the bin's relative remaining capacity.\n    \"\"\"\n    # Calculate the utilization factor after placing the item in each bin\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Calculate a weighted score combining utilization factor and remaining capacity\n    score = np.where(bins_remain_cap >= item, -0.5 * np.abs(utilization_factor) + 0.5 * (bins_remain_cap - item) / bins_remain_cap.max(), -np.inf)\n    \n    # Introduce a novel tie-breaker that favors bins with remaining capacity closer to the item size\n    tie_breaker = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), 0)\n    \n    # Combine the score and tie-breaker\n    priority = score + tie_breaker_coef * tie_breaker\n    \n    # Add a secondary tie-breaker based on bin index to ensure a deterministic order\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef ** 2)\n    \n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a sophisticated tie-breaker for online Bin Packing Problem.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Fit score and utilization factor\n    fit_score = np.where(bins_remain_cap >= item, -(np.abs(remaining_cap_after_addition) / bins_remain_cap), -np.inf)\n    utilization_after_addition = 1.0 - remaining_cap_after_addition / bins_remain_cap\n    utilization_score = np.where(bins_remain_cap >= item, utilization_after_addition, 0)\n    \n    # Combine fit score and utilization score with a focus on bins that are almost full\n    priority_scores = fit_score + utilization_score\n    \n    # Sophisticated tie-breaker based on a combination of bin remaining capacity and index\n    epsilon = 1e-6  # Small value to avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((bins_remain_cap / (item + epsilon)) + np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    # Combine priority score with tie-breaker and a small random noise for further tie-breaking\n    priority_scores = np.where(priority_scores != -np.inf, priority_scores + tie_breaker + np.random.uniform(0, 1e-6, size=len(bins_remain_cap)), -np.inf)\n    \n    return priority_scores\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a sophisticated tie-breaker for online Bin Packing Problem.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Fit score and utilization factor\n    fit_score = np.where(bins_remain_cap >= item, -(np.abs(remaining_cap_after_addition) / bins_remain_cap), -np.inf)\n    utilization_after_addition = 1.0 - remaining_cap_after_addition / bins_remain_cap\n    utilization_score = np.where(bins_remain_cap >= item, utilization_after_addition, 0)\n    \n    # Combine fit score and utilization score with a focus on bins that are almost full\n    priority_scores = fit_score + utilization_score\n    \n    # Sophisticated tie-breaker based on a combination of bin remaining capacity and index\n    epsilon = 1e-6  # Small value to avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((bins_remain_cap / (item + epsilon)) + np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    # Combine priority score with tie-breaker and a small random noise for further tie-breaking\n    priority_scores = np.where(priority_scores != -np.inf, priority_scores + tie_breaker + np.random.uniform(0, 1e-6, size=len(bins_remain_cap)), -np.inf)\n    \n    return priority_scores\n\n[Heuristics 16th]\nimport numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that balances utilization factor, remaining capacity, and a novel tie-breaker.\n    \"\"\"\n    # Calculate a normalized utilization factor, considering both the item size and bin remaining capacity\n    utilization_factor = 1 - (item / np.maximum(bins_remain_cap, epsilon))\n    \n    # Priority score for bins that can fit the item, based on a combination of utilization factor and a non-linear remaining capacity term\n    priority = np.where(bins_remain_cap >= item, utilization_factor * (1 - np.exp(-(bins_remain_cap - item))), -np.inf)\n    \n    # Introduce a more nuanced tie-breaker that considers both bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + (bins_remain_cap / (1 + np.sum(bins_remain_cap))) * tie_breaker_coef)\n    \n    # Combine the priority score with the tie-breaker, ensuring that the tie-breaker does not dominate the priority score\n    priority += tie_breaker\n    \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that balances utilization factor, remaining capacity, and a novel tie-breaker.\n    \"\"\"\n    # Calculate a normalized utilization factor, considering both the item size and bin remaining capacity\n    utilization_factor = 1 - (item / np.maximum(bins_remain_cap, epsilon))\n    \n    # Priority score for bins that can fit the item, based on a combination of utilization factor and a non-linear remaining capacity term\n    priority = np.where(bins_remain_cap >= item, utilization_factor * (1 - np.exp(-(bins_remain_cap - item))), -np.inf)\n    \n    # Introduce a more nuanced tie-breaker that considers both bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + (bins_remain_cap / (1 + np.sum(bins_remain_cap))) * tie_breaker_coef)\n    \n    # Combine the priority score with the tie-breaker, ensuring that the tie-breaker does not dominate the priority score\n    priority += tie_breaker\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that balances utilization factor, remaining capacity, and a novel tie-breaker.\n    \"\"\"\n    # Calculate a normalized utilization factor, considering both the item size and bin remaining capacity\n    utilization_factor = 1 - (item / np.maximum(bins_remain_cap, epsilon))\n    \n    # Priority score for bins that can fit the item, based on a combination of utilization factor and a non-linear remaining capacity term\n    priority = np.where(bins_remain_cap >= item, utilization_factor * (1 - np.exp(-(bins_remain_cap - item))), -np.inf)\n    \n    # Introduce a more nuanced tie-breaker that considers both bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + (bins_remain_cap / (1 + np.sum(bins_remain_cap))) * tie_breaker_coef)\n    \n    # Combine the priority score with the tie-breaker, ensuring that the tie-breaker does not dominate the priority score\n    priority += tie_breaker\n    \n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a sophisticated tie-breaker for effective prioritization.\n    \"\"\"\n    # Constants\n    epsilon = 1e-6  # Small value to avoid division by zero\n    utilization_factor_weight = 0.98  # Weight for utilization factor\n    fit_score_weight = 0.45  # Weight for fit score\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(utilization_factor) * utilization_factor_weight + fit_score * fit_score_weight, \n                        -np.inf)\n    \n    # Sophisticated tie-breaker based on remaining capacity and bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * (\n        (bins_remain_cap / (item + epsilon)) +  # Favor bins with remaining capacity close to the item size\n        np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef  # Tie-breaker based on bin index\n    )\n    \n    # Combine the priority score with the tie-breaker\n    priority += tie_breaker\n    \n    return priority\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a sophisticated tie-breaker for effective prioritization.\n    \"\"\"\n    # Constants\n    epsilon = 1e-6  # Small value to avoid division by zero\n    utilization_factor_weight = 0.98  # Weight for utilization factor\n    fit_score_weight = 0.45  # Weight for fit score\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(utilization_factor) * utilization_factor_weight + fit_score * fit_score_weight, \n                        -np.inf)\n    \n    # Sophisticated tie-breaker based on remaining capacity and bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * (\n        (bins_remain_cap / (item + epsilon)) +  # Favor bins with remaining capacity close to the item size\n        np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef  # Tie-breaker based on bin index\n    )\n    \n    # Combine the priority score with the tie-breaker\n    priority += tie_breaker\n    \n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}