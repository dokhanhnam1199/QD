```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines effective prioritization of bins with just enough capacity and robust tie-breaking.
    Uses a utilization factor and a small random noise for tie-breaking.
    """
    # Filter out bins that cannot fit the item
    valid_bins = bins_remain_cap >= item
    
    # Calculate the priority score for valid bins
    # Use a combination of negative remaining capacity and a utilization factor
    num_bins = len(bins_remain_cap)
    priority_scores = np.where(valid_bins, 
                                -(bins_remain_cap - item) +  # Prioritize bins with just enough capacity
                                np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3 +  # Tie-breaker based on bin index
                                np.random.uniform(0, 1e-6, size=num_bins),  # Random noise for tie-breaking
                                -np.inf)  # Negative infinity for bins that cannot fit the item
    
    return priority_scores
```
