{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin.\n    Combines effective prioritization with robust tie-breaking.\n    \"\"\"\n    # Prioritize bins with just enough capacity\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, 1e-9)  # Avoid division by zero\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) - (bins_remain_cap - item) / np.max(bins_remain_cap), -np.inf)\n    \n    # Add a small factor considering the bin index to break ties\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3)  # Use a smaller coefficient\n    \n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a heuristic that prioritizes bins based on their remaining capacity,\n    the item size, and a tie-breaking strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # So, we use a combination of the negative of the remaining capacity after adding the item and the bin utilization ratio\n\n    # First, calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n\n    # For bins that can fit the item, calculate the priority score\n    # We use a combination of the negative remaining capacity and the bin utilization ratio\n    priority_scores = np.where(\n        bins_remain_cap >= item, \n        -(remaining_cap_after_addition) + (1 / (bins_remain_cap + 1e-9)), \n        -np.inf\n    )\n\n    return priority_scores\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a more sophisticated heuristic that combines \n    the benefits of prioritizing bins with just enough capacity and \n    handling edge cases effectively.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # So, we use a combination of the negative of the remaining capacity after adding the item and a tie-breaker\n    # If the item doesn't fit, the priority score is negative infinity\n    \n    # First, filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # For valid bins, calculate the priority score\n    # We use a combination of the negative remaining capacity and a small random noise for tie-breaking\n    priority_scores = np.where(valid_bins, -(bins_remain_cap - item) + np.random.uniform(0, 1e-6, size=len(bins_remain_cap)), -np.inf)\n    \n    return priority_scores\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a more sophisticated heuristic that considers both \n    the remaining capacity after adding the item and the proportion of the bin's \n    remaining capacity that the item occupies.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # and where the item occupies a significant proportion of the remaining capacity\n    \n    # First, calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # For bins that can fit the item, calculate the priority score as a combination\n    # of the negative remaining capacity after addition (to prioritize bins that are \n    # just enough for the item) and the proportion of the remaining capacity that \n    # the item occupies (to prioritize bins where the item is a significant portion)\n    priority_scores = np.where(\n        bins_remain_cap >= item, \n        -(remaining_cap_after_addition) + (item / bins_remain_cap), \n        -np.inf\n    )\n    \n    return priority_scores\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Combines prioritizing bins with just enough capacity and a robust tie-breaking strategy.\n    \"\"\"\n    # Prioritize bins that have just enough capacity for the item\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a small factor considering the initial remaining capacity and random noise to break ties\n    initial_capacities = np.full_like(bins_remain_cap, 1.0)  \n    priority_scores += 0.1 * np.where(bins_remain_cap >= item, (initial_capacities - bins_remain_cap), 0) + np.random.rand(*priority_scores.shape) * 1e-6\n    \n    return priority_scores\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Combines prioritizing bins with just enough capacity and a robust tie-breaking strategy.\n    \"\"\"\n    # Prioritize bins that have just enough capacity for the item\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a small factor considering the initial remaining capacity and random noise to break ties\n    initial_capacities = np.full_like(bins_remain_cap, 1.0)  \n    priority_scores += 0.1 * np.where(bins_remain_cap >= item, (initial_capacities - bins_remain_cap), 0) + np.random.rand(*priority_scores.shape) * 1e-6\n    \n    return priority_scores\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin.\n    Combines effective prioritization with robust tie-breaking.\n    \"\"\"\n    # Prioritize bins with just enough capacity\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, 1e-9)  # Avoid division by zero\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) - (bins_remain_cap - item) / np.max(bins_remain_cap), -np.inf)\n    \n    # Add a small factor considering the bin index to break ties\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3)  # Use a smaller coefficient\n    \n    return priority\n\n[Heuristics 8th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, capacity_tolerance_weight: float = 0.27631331772271417, tie_breaker_weight: float = 0.00016327641965518957) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins with just enough capacity and breaks ties using remaining capacity and bin index.\n    \"\"\"\n    # Calculate priority score for bins that can fit the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    # Prioritize bins that are just enough for the item and have less remaining capacity\n    priority = valid_bins * (-(bins_remain_cap - item) + capacity_tolerance_weight * bins_remain_cap.max() - capacity_tolerance_weight * bins_remain_cap)\n    \n    # Add a small factor considering the bin index to break ties\n    num_bins = len(bins_remain_cap)\n    priority += valid_bins * np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_weight\n    \n    # Set priority to negative infinity for bins that cannot fit the item\n    priority = np.where(bins_remain_cap >= item, priority, -np.inf)\n    \n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Combines prioritizing bins with just enough capacity and a robust tie-breaking strategy.\n    \"\"\"\n    # Prioritize bins that have just enough capacity for the item\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a small factor considering the initial remaining capacity and random noise to break ties\n    initial_capacities = np.full_like(bins_remain_cap, 1.0)  \n    priority_scores += 0.1 * np.where(bins_remain_cap >= item, (initial_capacities - bins_remain_cap), 0) + np.random.rand(*priority_scores.shape) * 1e-6\n    \n    return priority_scores\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines remaining capacity and 'fullness' with a tie-breaker based on bin index.\n    \"\"\"\n    # Calculate max capacity assuming all bins have the same max capacity\n    max_capacity = np.max(bins_remain_cap) + item\n    \n    # Priority score for bins that can fit the item\n    mask = bins_remain_cap >= item\n    priority = np.where(mask, \n                        -(bins_remain_cap - item) + (max_capacity - bins_remain_cap - item) / max_capacity, \n                        -np.inf)\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority = np.where(priority != -np.inf, \n                        priority + np.log(num_bins / (1 + np.arange(num_bins))) + np.random.uniform(0, 1e-6, size=num_bins), \n                        -np.inf)\n    \n    # Normalize scores to avoid extreme values\n    finite_scores = priority[np.isfinite(priority)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            priority[np.isfinite(priority)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines remaining capacity and 'fullness' with a tie-breaker based on bin index.\n    \"\"\"\n    # Calculate max capacity assuming all bins have the same max capacity\n    max_capacity = np.max(bins_remain_cap) + item\n    \n    # Priority score for bins that can fit the item\n    mask = bins_remain_cap >= item\n    priority = np.where(mask, \n                        -(bins_remain_cap - item) + (max_capacity - bins_remain_cap - item) / max_capacity, \n                        -np.inf)\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority = np.where(priority != -np.inf, \n                        priority + np.log(num_bins / (1 + np.arange(num_bins))) + np.random.uniform(0, 1e-6, size=num_bins), \n                        -np.inf)\n    \n    # Normalize scores to avoid extreme values\n    finite_scores = priority[np.isfinite(priority)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            priority[np.isfinite(priority)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines effective prioritization of bins with just enough capacity and robust tie-breaking.\n    \"\"\"\n    # Check if the item can fit into the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Prioritize bins that are just enough for the item, with a simpler formula\n    priority = valid_bins * (-(bins_remain_cap - item))\n    \n    # Add a small random noise and consider bin index for tie-breaking\n    num_bins = len(bins_remain_cap)\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) + np.random.rand(*priority.shape) * 1e-6)\n    \n    return priority\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines effective prioritization of bins with just enough capacity and robust tie-breaking.\n    \"\"\"\n    # Check if the item can fit into the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Prioritize bins that are just enough for the item, with a simpler formula\n    priority = valid_bins * (-(bins_remain_cap - item))\n    \n    # Add a small random noise and consider bin index for tie-breaking\n    num_bins = len(bins_remain_cap)\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) + np.random.rand(*priority.shape) * 1e-6)\n    \n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to bins, combining \n    remaining capacity and 'fullness' with a tie-breaker based on bin index.\n    \"\"\"\n    # Calculate max capacity assuming all bins have the same max capacity\n    max_capacity = np.max(bins_remain_cap) + item\n    \n    # Priority score: negative remaining capacity after addition, \n    # plus a 'fullness' factor\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + (max_capacity - bins_remain_cap - item) / max_capacity, \n                               -np.inf)\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))) + np.random.uniform(0, 1e-6, size=num_bins), \n                               -np.inf)\n    \n    # Normalize scores to avoid extreme values\n    finite_scores = priority_scores[np.isfinite(priority_scores)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            priority_scores[np.isfinite(priority_scores)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority_scores\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to bins, combining \n    remaining capacity and 'fullness' with a tie-breaker based on bin index.\n    \"\"\"\n    # Calculate max capacity assuming all bins have the same max capacity\n    max_capacity = np.max(bins_remain_cap) + item\n    \n    # Priority score: negative remaining capacity after addition, \n    # plus a 'fullness' factor\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + (max_capacity - bins_remain_cap - item) / max_capacity, \n                               -np.inf)\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))) + np.random.uniform(0, 1e-6, size=num_bins), \n                               -np.inf)\n    \n    # Normalize scores to avoid extreme values\n    finite_scores = priority_scores[np.isfinite(priority_scores)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            priority_scores[np.isfinite(priority_scores)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority_scores\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines remaining capacity and 'fullness' with a tie-breaker based on bin index.\n    \"\"\"\n    # Calculate max capacity assuming all bins have the same max capacity\n    max_capacity = np.max(bins_remain_cap) + item\n    \n    # Priority score for bins that can fit the item\n    mask = bins_remain_cap >= item\n    priority = np.where(mask, \n                        -(bins_remain_cap - item) + (max_capacity - bins_remain_cap - item) / max_capacity, \n                        -np.inf)\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority = np.where(priority != -np.inf, \n                        priority + np.log(num_bins / (1 + np.arange(num_bins))) + np.random.uniform(0, 1e-6, size=num_bins), \n                        -np.inf)\n    \n    # Normalize scores to avoid extreme values\n    finite_scores = priority[np.isfinite(priority)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            priority[np.isfinite(priority)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines effective prioritization of bins with just enough capacity and robust tie-breaking.\n    \"\"\"\n    # Check if the item can fit into the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Prioritize bins that are just enough for the item, with a simpler formula\n    priority = valid_bins * (-(bins_remain_cap - item))\n    \n    # Add a small random noise and consider bin index for tie-breaking\n    num_bins = len(bins_remain_cap)\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) + np.random.rand(*priority.shape) * 1e-6)\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines remaining capacity and 'fullness' with tie-breaking using bin index and random noise.\n    \"\"\"\n    # Calculate max capacity assuming all bins have the same max capacity\n    max_capacity = np.max(bins_remain_cap) + item\n    \n    # Number of available bins\n    num_bins = len(bins_remain_cap)\n    \n    # Priority score for bins that can fit the item\n    mask = bins_remain_cap >= item\n    priority = np.where(mask, \n                        -(bins_remain_cap - item) +  # Prioritize bins with just enough capacity\n                        (max_capacity - bins_remain_cap - item) / max_capacity +  # Consider 'fullness'\n                        np.log(num_bins / (1 + np.arange(num_bins))) +  # Tie-break using bin index\n                        np.random.uniform(0, 1e-6, size=num_bins),  # Add random noise for further tie-breaking\n                        -np.inf)  # Invalid bins have -inf priority\n    \n    # Normalize scores to avoid extreme values\n    finite_scores = priority[np.isfinite(priority)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            priority[np.isfinite(priority)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines effective prioritization of bins with just enough capacity and robust tie-breaking.\n    \"\"\"\n    # Check if the item can fit into the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Prioritize bins that are just enough for the item, with a simpler formula\n    priority = valid_bins * (-(bins_remain_cap - item))\n    \n    # Add a small random noise and consider bin index for tie-breaking\n    num_bins = len(bins_remain_cap)\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) + np.random.rand(*priority.shape) * 1e-6)\n    \n    return priority\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    Combines effective prioritization with a robust tie-breaking strategy.\n    \"\"\"\n    # Prioritize bins with just enough capacity\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Tie-break using a combination of remaining capacity and bin index\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + 0.1 * bins_remain_cap.max() - 0.1 * bins_remain_cap + np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    return priority_scores\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}