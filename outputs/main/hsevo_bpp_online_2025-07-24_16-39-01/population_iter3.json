[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    \n    Combines elements of First-Fit decreasing heuristic and score normalization.\n    Prioritizes bins with just enough capacity, adding noise to break ties.\n    \"\"\"\n    # Calculate priority scores for bins with enough capacity\n    mask = bins_remain_cap >= item\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n    priority_scores[mask] = -(bins_remain_cap[mask] - item) + np.random.uniform(0, 1e-6, size=np.sum(mask))  # Add small noise\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.11846828879138,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 94.75393362454983,
    "token_count": 122.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by prioritizing bins with just enough capacity for the item and breaking ties randomly.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Prioritize bins with less remaining capacity after addition and break ties randomly\n    priority = np.where(remaining_capacity_after_addition >= 0, \n                        -remaining_capacity_after_addition + np.random.uniform(0, 1e-6, size=len(bins_remain_cap)), \n                        -np.inf)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 94.75393362454983,
    "token_count": 122.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins with just enough capacity for the item and breaks ties with random noise.\n    \"\"\"\n    # Check if the item can fit into the bin and prioritize bins with less remaining capacity after addition\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    priority = valid_bins * (-(bins_remain_cap - item))  # Prioritize bins that are just enough for the item\n    \n    # Add a small random noise to break ties\n    priority += np.random.rand(*priority.shape) * 1e-6\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 94.75393362454983,
    "token_count": 122.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins with capacity closest to the item size, with a tie-breaker.\n    \"\"\"\n    # Calculate the priority score as the negative of the remaining capacity after adding the item\n    priority = -np.abs(bins_remain_cap - item)  # prioritize bins with just enough capacity\n    \n    # Add a small random noise to break ties\n    np.random.seed(0)  # for reproducibility\n    priority += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    # Set the priority to negative infinity for bins that cannot accommodate the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 94.75393362454983,
    "token_count": 122.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to bins.\n    Prioritizes bins with just enough capacity, using negative remaining capacity and adding noise to break ties.\n    \"\"\"\n    # Calculate priority scores for bins that can fit the item\n    mask = bins_remain_cap >= item\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n    # Use negative remaining capacity after addition and add a small random noise\n    priority_scores[mask] = -(bins_remain_cap[mask] - item) + np.random.uniform(0, 1e-6, size=np.sum(mask))\n    \n    return priority_scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.11846828879138,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 94.75393362454983,
    "token_count": 122.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    \n    Prioritizes bins with just enough capacity, using negative remaining capacity after addition,\n    and adds a small noise to break ties.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    mask = bins_remain_cap >= item\n    \n    # Initialize priority scores with negative infinity for bins that are too small\n    priority = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For valid bins, calculate priority as negative remaining capacity after addition with a small noise\n    priority[mask] = -(bins_remain_cap[mask] - item) + np.random.uniform(0, 1e-6, np.sum(mask))\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.11846828879138,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 94.75393362454983,
    "token_count": 122.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining the benefits of \n    prioritizing bins with just enough capacity and breaking ties.\n    \"\"\"\n    # Prioritize bins with less remaining capacity after addition, with a small noise to break ties\n    priority = np.where(bins_remain_cap >= item, \n                        -(bins_remain_cap - item) + 1e-6 * np.random.rand(len(bins_remain_cap)), \n                        -np.inf)\n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 94.75393362454983,
    "token_count": 122.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to bins based on remaining capacity.\n\n    Prioritizes bins that fit the item tightly, with a small random noise to break ties.\n    \"\"\"\n    # Calculate priority scores: negative remaining capacity after adding the item\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a small random noise to break ties\n    noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    priority_scores = np.where(np.isfinite(priority_scores), priority_scores + noise, priority_scores)\n    \n    return priority_scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 94.75393362454983,
    "token_count": 122.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and a small random noise to break ties.\n    \"\"\"\n    # Calculate priority based on remaining capacity after adding the item\n    priority = np.where(bins_remain_cap >= item, -(bins_remain_cap - item) + np.random.uniform(0, 1e-6, size=len(bins_remain_cap)), -np.inf)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 94.75393362454983,
    "token_count": 122.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority score for each bin based on remaining capacity and item size.\n    Bins with just enough capacity get highest priority, with tie-breaks by randomness.\n    \"\"\"\n    # Calculate priority scores: bins with remaining capacity closest to item size get highest priority\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a small random noise to break ties\n    finite_scores = priority_scores[np.isfinite(priority_scores)]\n    if len(finite_scores) > 0:\n        noise = np.random.uniform(0, 1e-6, size=len(priority_scores))\n        priority_scores = np.where(np.isfinite(priority_scores), priority_scores + noise, -np.inf)\n    \n    return priority_scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 94.75393362454983,
    "token_count": 122.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a dynamic prioritization strategy that considers both the remaining capacity and the 'fullness' of the bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item and are relatively full\n    # So, we use a combination of the negative of the remaining capacity after adding the item and the current fullness of the bin\n    # If the item doesn't fit, the priority score is negative infinity\n    max_capacity = np.max(bins_remain_cap) + item  # assuming all bins have the same max capacity\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + (max_capacity - bins_remain_cap - item) / max_capacity, \n                               -np.inf)\n    \n    # Normalize the scores to avoid extreme values\n    finite_scores = priority_scores[np.isfinite(priority_scores)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            priority_scores[np.isfinite(priority_scores)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 97.67226489021297,
    "mi": 51.079893042501666,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a dynamic prioritization strategy that considers both \n    the remaining capacity of the bin and the number of bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # and also consider the number of bins\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) / (bins_remain_cap + 1e-6), \n                               -np.inf)\n    \n    # Add a small bonus to the priority score for bins with smaller remaining capacity\n    # to encourage packing items tightly\n    priority_scores = np.where(bins_remain_cap >= item, \n                               priority_scores + 1 / (bins_remain_cap + 1e-6), \n                               priority_scores)\n    \n    return priority_scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 97.67226489021297,
    "mi": 51.079893042501666,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a dynamic prioritization strategy that considers both \n    the remaining capacity of the bin and the number of bins available.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the number of available bins\n    num_bins = len(bins_remain_cap)\n    \n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # and also consider the number of available bins\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    # Normalize the priority scores to ensure they are within a comparable range\n    max_score = np.max(priority_scores)\n    if max_score != -np.inf:\n        priority_scores = np.where(priority_scores != -np.inf, priority_scores - max_score, -np.inf)\n    \n    return priority_scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 97.67226489021297,
    "mi": 51.079893042501666,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a dynamic prioritization strategy that considers both the remaining capacity and the \"fullness\" of each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have enough capacity for the item and are relatively fuller\n    # So, we use a combination of the negative of the remaining capacity after adding the item and the current fullness of the bin\n    # If the item doesn't fit, the priority score is negative infinity\n    max_capacity = np.max(bins_remain_cap) + item  # assuming all bins have the same max capacity\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + (max_capacity - bins_remain_cap - item) / max_capacity, \n                               -np.inf)\n    \n    # Normalize the priority scores to ensure they are on the same scale\n    # This helps in cases where the remaining capacities are very large or very small\n    finite_scores = priority_scores[np.isfinite(priority_scores)]\n    if len(finite_scores) > 0:\n        min_score = np.min(finite_scores)\n        max_score = np.max(finite_scores)\n        if max_score != min_score:\n            priority_scores[np.isfinite(priority_scores)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority_scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 97.67226489021297,
    "mi": 51.079893042501666,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a dynamic prioritization strategy that considers both the remaining capacity and the \"fullness\" of the bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item and are relatively full\n    # So, we use a combination of the negative of the remaining capacity after adding the item and the current fullness of the bin\n    # If the item doesn't fit, the priority score is negative infinity\n    max_cap = np.max(bins_remain_cap) + item  # assuming all bins have the same capacity\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item) + (max_cap - bins_remain_cap - item) / max_cap, -np.inf)\n    \n    return priority_scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 97.67226489021297,
    "mi": 51.079893042501666,
    "token_count": 81.0,
    "exec_success": true
  }
]