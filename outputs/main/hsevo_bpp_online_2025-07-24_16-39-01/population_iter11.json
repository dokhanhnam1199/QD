[
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and remaining capacity for prioritization with a simple tie-breaker.\n    \"\"\"\n    # Calculate utilization factor, avoiding division by zero\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, 1e-9)\n    \n    # Priority score for bins that can fit the item, using a combination of utilization and remaining capacity\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor), -np.inf)\n    \n    # Add a tie-breaker based on bin index with a small coefficient\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines remaining capacity and 'fullness' with a tie-breaker based on bin index and random noise.\n    \"\"\"\n    # Calculate max capacity assuming all bins have the same max capacity\n    max_capacity = np.max(bins_remain_cap) + item\n    \n    # Priority score for bins that can fit the item\n    mask = bins_remain_cap >= item\n    priority = np.where(mask, \n                        -(bins_remain_cap - item) + 0.1 * (max_capacity - bins_remain_cap - item) / max_capacity, \n                        -np.inf)\n    \n    # Add a tie-breaker based on bin index and random noise\n    num_bins = len(bins_remain_cap)\n    priority = np.where(priority != -np.inf, \n                        priority + np.log(num_bins / (1 + np.arange(num_bins))) + np.random.uniform(0, 1e-6, size=num_bins), \n                        -np.inf)\n    \n    # Normalize scores to avoid extreme values\n    finite_scores = priority[np.isfinite(priority)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            priority[np.isfinite(priority)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines effective prioritization of bins with just enough capacity and robust tie-breaking.\n    Uses a combination of negative remaining capacity and bin utilization ratio for prioritization.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the item can fit into the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Prioritize bins that are just enough for the item\n    priority = valid_bins * (-(remaining_cap_after_addition) + (1 / (bins_remain_cap + 1e-9)))\n    \n    # Add a small random noise for tie-breaking\n    num_bins = len(bins_remain_cap)\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) + np.random.rand(*priority.shape) * 1e-6)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response3.txt_stdout.txt",
    "code_path": "problem_iter11_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines effective prioritization of bins with just enough capacity and robust tie-breaking.\n    Uses a utilization factor and a small random noise for tie-breaking.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate the priority score for valid bins\n    # Use a combination of negative remaining capacity and a utilization factor\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(valid_bins, \n                                -(bins_remain_cap - item) +  # Prioritize bins with just enough capacity\n                                np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3 +  # Tie-breaker based on bin index\n                                np.random.uniform(0, 1e-6, size=num_bins),  # Random noise for tie-breaking\n                                -np.inf)  # Negative infinity for bins that cannot fit the item\n    \n    return priority_scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to bins, combining remaining capacity, \n    utilization factor, and a simple tie-breaker based on bin index.\n    \"\"\"\n    # Calculate priority score as a combination of negative remaining capacity \n    # after addition and the proportion of the remaining capacity that the item occupies\n    remaining_cap_after_addition = bins_remain_cap - item\n    priority_scores = np.where(\n        bins_remain_cap >= item, \n        -(remaining_cap_after_addition) + (item / bins_remain_cap), \n        -np.inf\n    )\n    \n    # Add a simple tie-breaker based on bin index to favor earlier bins\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    return priority_scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response5.txt_stdout.txt",
    "code_path": "problem_iter11_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Combines prioritizing bins with just enough capacity and a robust tie-breaking strategy.\n    \"\"\"\n    # Prioritize bins that have just enough capacity for the item\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a utilization factor considering the proportion of remaining capacity\n    max_capacity = np.max(bins_remain_cap) + item\n    utilization_factor = (max_capacity - bins_remain_cap - item) / max_capacity\n    priority_scores += 0.1 * np.where(bins_remain_cap >= item, utilization_factor, 0)\n    \n    # Add a small random noise for tie-breaking\n    priority_scores += np.random.rand(*priority_scores.shape) * 1e-6\n    \n    return priority_scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response6.txt_stdout.txt",
    "code_path": "problem_iter11_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines prioritizing bins with just enough capacity and a robust tie-breaking strategy.\n    Utilizes a simple utilization factor and random noise for tie-breaking.\n    \"\"\"\n    # Prioritize bins that have just enough capacity for the item\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Calculate a utilization factor based on the remaining capacity\n    max_capacity = np.max(bins_remain_cap) + item  # Assuming all bins have the same max capacity\n    utilization_factor = (max_capacity - bins_remain_cap - item) / max_capacity\n    \n    # Combine the priority score with the utilization factor\n    priority_scores += 0.1 * np.where(bins_remain_cap >= item, utilization_factor, 0)\n    \n    # Add random noise for tie-breaking\n    priority_scores += np.random.rand(*priority_scores.shape) * 1e-6\n    \n    return priority_scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response7.txt_stdout.txt",
    "code_path": "problem_iter11_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines effective prioritization with robust tie-breaking.\n    Prioritizes bins with just enough capacity and uses a balanced tie-breaking strategy.\n    \"\"\"\n    # Prioritize bins with just enough capacity using a utilization factor\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, 1e-9)  \n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor), -np.inf)\n    \n    # Add a small factor considering the bin index for tie-breaking\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3 + np.random.rand(*priority.shape) * 1e-6)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response8.txt_stdout.txt",
    "code_path": "problem_iter11_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and remaining capacity with tie-breaking using bin index.\n    \"\"\"\n    # Calculate priority score for bins that can fit the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    # Prioritize bins that are just enough for the item\n    priority = valid_bins * (-(bins_remain_cap - item) + 0.1 * bins_remain_cap.max() - 0.1 * bins_remain_cap)\n    \n    # Add a small factor considering the bin index to break ties\n    num_bins = len(bins_remain_cap)\n    priority += valid_bins * np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3\n    \n    # Set priority to negative infinity for bins that cannot fit the item\n    priority = np.where(bins_remain_cap >= item, priority, -np.inf)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response9.txt_stdout.txt",
    "code_path": "problem_iter11_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines prioritizing bins with just enough capacity and a robust tie-breaking strategy.\n    Utilizes a mix of remaining capacity and random noise for effective tie-breaking.\n    \"\"\"\n    # Prioritize bins that have just enough capacity for the item\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a factor considering the proportion of remaining capacity and a small random noise for tie-breaking\n    num_bins = len(bins_remain_cap)\n    priority_scores += 0.1 * np.where(bins_remain_cap >= item, (1 - bins_remain_cap), 0) + np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3 + np.random.rand(*priority_scores.shape) * 1e-6\n    \n    return priority_scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  }
]