{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a simple tie-breaker for effective bin selection.\n    \"\"\"\n    # Calculate the fraction of remaining capacity after packing the item\n    epsilon = 1e-6  # Avoid division by zero\n    remaining_fraction = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Priority score for bins that can fit the item\n    valid_bins = bins_remain_cap >= item\n    priority = np.where(valid_bins, -remaining_fraction + np.exp(-np.abs(bins_remain_cap - item) / item), -np.inf)\n    \n    # Introduce a tie-breaker based on the bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker_coef = 1e-3\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    # Favor bins that are almost full\n    almost_full_bins = np.logical_and(valid_bins, bins_remain_cap - item < item * 0.1)\n    priority += almost_full_bins * (1 - remaining_fraction) * 0.1\n    \n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for the tie-breaker\n\n    \"\"\"\n    Enhanced prioritization function that combines multiple factors for effective bin selection.\n    \"\"\"\n    # Calculate the utilization factor after placing the item in each bin\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Calculate the remaining capacity factor, normalized to be between 0 and 1\n    remaining_capacity_factor = bins_remain_cap / (item + epsilon)\n    \n    # Priority score for bins that can fit the item, combining utilization factor and remaining capacity factor\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) + remaining_capacity_factor, -np.inf)\n    \n    # Introduce a tie-breaker that favors bins with lower indices (older bins), using a logarithmic scale\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    # Further differentiate bins with very similar priorities by considering their original capacity (assuming all bins have the same capacity)\n    # This step is skipped as it requires knowing the original capacity, but it's a potential enhancement\n    \n    return priority\n\n### Analyze & experience\n- Comparing the best heuristics (1st) vs the worst (20th), we see that top heuristics tend to have a more nuanced combination of utilization factor and fit score, with subtle differences in weighting and tie-breaking mechanisms. The top heuristics also tend to favor bins that are almost full to minimize waste. Comparing (1st) vs (2nd), we see that the main difference is in the choice of weights and epsilon value. (2nd) has more precise weights, suggesting that fine-tuning these parameters can lead to improved performance. (3rd) vs (4th) shows that introducing additional parameters can be beneficial, but (4th) has a more complex function signature. Comparing (19th) vs (20th), we see that they are identical, suggesting that there may be some redundancy in the list. Overall, the top heuristics tend to have a balance between utilization factor, fit score, and tie-breaking mechanisms.\n- \nTo redefine 'Current self-reflection' and avoid all things in 'Ineffective self-reflection', let's analyze the given information.\n\n* Keywords: Utilization, Remaining Capacity, Tie-breaking, Simplicity\n* Advice: \n  \u2022 Balance multiple factors like utilization and remaining capacity.\n  \u2022 Use simple yet effective tie-breakers based on bin index or other relevant characteristics.\n  \u2022 Experiment with different weightings and combinations of these factors.\n  \u2022 Focus on combining key factors with effective tie-breakers.\n* Avoid: Redundant complexity, excessive randomness, unnecessary complexity, ineffective prioritization strategies.\n* Explanation: The redefined 'Current self-reflection' should focus on balancing multiple relevant factors and using effective tie-breakers while maintaining simplicity. It should avoid redundant complexity and ineffective prioritization strategies, ultimately leading to designing better heuristics.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}