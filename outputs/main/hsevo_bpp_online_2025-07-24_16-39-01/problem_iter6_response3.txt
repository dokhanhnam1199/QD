```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.

    This function implements a more nuanced heuristic that considers both the 
    remaining capacity after adding the item and the number of items already 
    packed in the bin (not directly available but can be inferred from the remaining capacity).
    It prioritizes bins that have just enough capacity for the item and are relatively fuller.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the priority score for each bin
    # We want to prioritize bins that have just enough capacity for the item
    # and are relatively fuller (i.e., have less remaining capacity)
    # So, we use a combination of the negative of the remaining capacity after 
    # adding the item and the current remaining capacity as a tie-breaker
    # If the item doesn't fit, the priority score is negative infinity
    priority_scores = np.where(bins_remain_cap >= item, 
                               -(bins_remain_cap - item) + 0.1 * bins_remain_cap.max() - 0.1 * bins_remain_cap, 
                               -np.inf)
    
    return priority_scores
```
