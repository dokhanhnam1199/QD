{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n                utilization_weight: float = 0.7972918990003264, remaining_capacity_weight: float = 0.40715313092312244, \n                tie_breaker_log_weight: float = 0.5149245278161441, tie_breaker_norm_weight: float = 0.6260375790742155) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function combining utilization factor, remaining capacity, and a sophisticated tie-breaker.\n    \"\"\"\n    # Normalize remaining capacity to enhance comparison\n    norm_remain_cap = bins_remain_cap / np.max(bins_remain_cap)\n    \n    # Calculate a weighted utilization factor that considers both the item size and bin capacity\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    weighted_utilization = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) * utilization_weight + norm_remain_cap * remaining_capacity_weight, -np.inf)\n    \n    # Priority score for bins that can fit the item, emphasizing both utilization and remaining capacity\n    priority = weighted_utilization\n    \n    # Introduce a more nuanced tie-breaker based on bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_log_weight + norm_remain_cap * tie_breaker_norm_weight) * tie_breaker_coef)\n    priority += tie_breaker\n    \n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines utilization factor, fit score, and a simple tie-breaker for effective bin selection.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    # Calculate priority score for bins that can fit the item\n    valid_bins = bins_remain_cap >= item\n    remaining_fraction = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    priority = np.where(valid_bins, -remaining_fraction + np.exp(-np.abs(bins_remain_cap - item) / item), -np.inf)\n    \n    # Introduce a tie-breaker based on the bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker_coef = 1e-3\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    # Favor bins that are almost full\n    almost_full_bins = np.logical_and(valid_bins, bins_remain_cap - item < item * 0.1)\n    priority += almost_full_bins * (1 - remaining_fraction) * 0.1\n    \n    # Enhance with remaining capacity factor for valid bins\n    remaining_capacity_factor = bins_remain_cap / (item + epsilon)\n    priority += valid_bins * remaining_capacity_factor * 0.05  # Weighted addition\n    \n    return priority\n\n### Analyze & experience\n- Comparing the best heuristic (1st) with the worst (20th), we see that the top heuristic utilizes a more nuanced and weighted approach to calculating priority, incorporating multiple factors such as utilization factor, remaining capacity, and a sophisticated tie-breaker with carefully tuned coefficients. In contrast, the lower-ranked heuristics, while similar in structure, either lack the fine-tuning of coefficients or simplify certain aspects of the calculation. For instance, comparing (1st) vs (2nd), the top heuristic has optimized coefficients for its tie-breaker and weighted factors, suggesting the importance of these optimizations. (3rd) vs (4th) and other subsequent pairs show a gradual simplification or less optimal tuning of these elements. Notably, the worst heuristics (19th and 20th) are nearly identical and lack the nuanced weighting seen in the top heuristics. Overall, the key differentiators among the top heuristics are the sophistication of their tie-breakers and the weighting of their scoring factors.\n- \nTo redesign 'Current self-reflection', let's analyze the given information and identify key aspects.\n\n* Keywords: nuanced scoring, weighted factors, robust optimization, tie-breakers, utilization, fit score, remaining capacity.\n* Advice: Combine multiple relevant factors (utilization, fit score, remaining capacity) and use effective tie-breakers (bin index, randomness) with robust optimization methods to fine-tune coefficients.\n* Avoid: Unnecessary complexity, excessive randomness, redundant components, and ineffective prioritization strategies.\n* Explanation: By incorporating multiple factors and using effective tie-breakers with robust optimization, we can create a more balanced and efficient heuristic that avoids common pitfalls like complexity and inefficiency.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}