{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority scores for adding an item to bins.\n    Combines remaining capacity and 'fullness' of bins, with tie-breaking noise.\n    \"\"\"\n    # Calculate max capacity assuming all bins have the same max capacity\n    max_capacity = np.max(bins_remain_cap) + item\n    \n    # Priority score: negative remaining capacity after addition, \n    # plus a 'fullness' factor, and a small random noise to break ties\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + (max_capacity - bins_remain_cap - item) / max_capacity + np.random.uniform(0, 1e-6, size=len(bins_remain_cap)), \n                               -np.inf)\n    \n    # Normalize scores to avoid extreme values\n    finite_scores = priority_scores[np.isfinite(priority_scores)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            priority_scores[np.isfinite(priority_scores)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    \n    Combines the First-Fit decreasing heuristic with a tie-breaker based on bin index.\n    \"\"\"\n    # Calculate priority scores based on remaining capacity\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a small random noise to break ties\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    return priority_scores\n\n### Analyze & experience\n- Comparing the best heuristic (1st) with the worst (20th), we see that the top heuristic prioritizes bins with just enough capacity and considers the remaining capacity, while the worst one also prioritizes bins with just enough capacity but with a less effective tie-breaking strategy. \nComparing (1st) vs (2nd), we see that both consider remaining capacity after adding the item, but the 1st heuristic uses a simpler and more effective formula. \n(3rd) vs (4th) shows that similar heuristics can have slight variations in their formulas, but (3rd) adds a small random noise which is beneficial. \n(19th) vs (20th) shows that using a combination of random noise and bin index for tie-breaking is common among lower-ranked heuristics, but (19th) uses a more sophisticated approach with tuned parameters.\nOverall, effective prioritization and tie-breaking strategies are crucial, and top heuristics tend to use simpler, more effective formulas.\n- \nTo redesign 'Current self-reflection,' let's analyze the given information and reframe it to avoid the pitfalls mentioned in 'Ineffective self-reflection.' Here's a step-by-step breakdown:\n\n### Analysis\n- The 'Current self-reflection' focuses on simple prioritization formulas and tie-breaking using multiple factors.\n- The 'Ineffective self-reflection' suggests looking into more effective prioritization strategies and handling edge cases.\n\n### Redefined 'Current self-reflection'\nTo design better heuristics, consider the following:\n* **Keywords**: Effective prioritization, multiple factors, edge cases.\n* **Advice**: Focus on strategies like negative or inverse remaining capacity and implement robust tie-breaking.\n* **Avoid**: Simple, non-effective prioritization and lack of edge case handling.\n* **Explanation**: Combining effective prioritization strategies with robust handling of edge cases like division by zero and ties will lead to better heuristics.\n\nLet's refine our approach with these insights. I'm ready to help design better heuristics.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}