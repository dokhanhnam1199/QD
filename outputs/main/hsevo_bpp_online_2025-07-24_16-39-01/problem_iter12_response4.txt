```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.

    This function implements a heuristic that prioritizes bins based on their remaining capacity and utilization.
    It combines the factors of having just enough capacity for the item and the overall utilization of the bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the priority score for each bin
    # We want to prioritize bins that have just enough capacity for the item
    # and also have a high overall utilization
    
    # First, filter out bins that cannot fit the item
    valid_bins = bins_remain_cap >= item
    
    # For valid bins, calculate the remaining capacity after adding the item
    remaining_after_addition = bins_remain_cap[valid_bins] - item
    
    # Calculate the utilization of the bin after adding the item
    # Assuming the bin capacity is 1.0 (or normalize it to 1.0)
    bin_utilization_after_addition = (1.0 - remaining_after_addition) / 1.0
    
    # Priority score is a combination of the negative remaining capacity (to prioritize bins with just enough capacity)
    # and the bin utilization after adding the item (to prioritize bins that are more full)
    priority_scores_valid = -remaining_after_addition + bin_utilization_after_addition
    
    # Create an array to store the priority scores for all bins
    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    # Assign the calculated priority scores to the valid bins
    priority_scores[valid_bins] = priority_scores_valid
    
    return priority_scores
```
