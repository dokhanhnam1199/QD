[
  {
    "stdout_filepath": "problem_iter32_response0.txt_stdout.txt",
    "code_path": "problem_iter32_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, remaining capacity, and sophisticated tie-breaker for effective bin selection.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    # Normalize remaining capacity\n    norm_remain_cap = bins_remain_cap / np.max(bins_remain_cap)\n    \n    # Calculate weighted utilization factor\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    weighted_utilization = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) + norm_remain_cap * 0.05, -np.inf)\n    \n    # Priority score for bins that can fit the item\n    priority = weighted_utilization\n    \n    # Introduce a nuanced tie-breaker based on bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    tie_breaker_coef = 1e-3\n    tie_breaker = valid_bins * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef + norm_remain_cap * 0.01))\n    priority += tie_breaker\n    \n    # Favor bins that are almost full\n    almost_full_bins = np.logical_and(valid_bins, bins_remain_cap - item < item * 0.1)\n    priority += almost_full_bins * (1 - utilization_factor) * 0.1\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 361.8911104523407,
    "mi": 87.13706735577362,
    "token_count": 199.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response1.txt_stdout.txt",
    "code_path": "problem_iter32_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and sophisticated tie-breakers for effective prioritization.\n    \"\"\"\n    epsilon = 1e-6  \n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item, balancing utilization factor and fit score\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(utilization_factor) * 0.95 + fit_score * 0.5, \n                        -np.inf)\n    \n    # Sophisticated tie-breaker based on remaining capacity and bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * (\n        np.log(num_bins / (1 + np.arange(num_bins))) * 0.007 +  # Tie-breaker based on bin index\n        (bins_remain_cap / (item + epsilon)) * 0.001  # Favor bins with remaining capacity close to the item size\n    )\n    # Favor bins that are almost full to minimize waste\n    almost_full_bins = np.logical_and(bins_remain_cap >= item, bins_remain_cap - item < item * 0.1)\n    priority += almost_full_bins * (1 - np.abs(utilization_factor)) * 0.1 + tie_breaker\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 361.8911104523407,
    "mi": 87.13706735577362,
    "token_count": 199.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response2.txt_stdout.txt",
    "code_path": "problem_iter32_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a nuanced tie-breaker for effective prioritization.\n    Favors bins that are almost full and balances multiple factors.\n    \"\"\"\n    epsilon = 1e-6  # Small value to avoid division by zero\n    tie_breaker_coef = 0.008  # Coefficient for tie-breaker\n    \n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(utilization_factor) * 0.7 + fit_score * 0.3, \n                        -np.inf)\n    \n    # Introduce a nuanced tie-breaker that considers both bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + \n                                               (bins_remain_cap / (1 + np.sum(bins_remain_cap))) * tie_breaker_coef)\n    \n    # Combine the priority score with the tie-breaker and slightly favor bins that are almost full\n    priority += tie_breaker\n    almost_full_bins = np.logical_and(bins_remain_cap >= item, bins_remain_cap - item < item * 0.1)\n    priority += almost_full_bins * (1 - np.abs(utilization_factor)) * 0.1\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 361.8911104523407,
    "mi": 87.13706735577362,
    "token_count": 199.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response3.txt_stdout.txt",
    "code_path": "problem_iter32_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fitting score, utilization factor, and a sophisticated tie-breaker for effective prioritization.\n    \"\"\"\n    epsilon = 1e-6  # Small value to avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Calculate the 'fitting score' based on how well the item fits into the bin\n    fitting_score = np.where(bins_remain_cap >= item, \n                             1 - np.abs((bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)), \n                             0)  # Score is 0 if the item cannot fit\n    \n    # Calculate utilization factor\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Priority score for bins that can fit the item, combining fitting score and utilization factor\n    priority = np.where(bins_remain_cap >= item, \n                        fitting_score - np.abs(utilization_factor) * 0.5,  # Balance between fitting score and utilization\n                        -np.inf)\n    \n    # Sophisticated tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker = np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef\n    \n    # Combine the priority score with the tie-breaker\n    priority += tie_breaker\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 361.8911104523407,
    "mi": 87.13706735577362,
    "token_count": 199.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response4.txt_stdout.txt",
    "code_path": "problem_iter32_code4.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines weighted utilization factor, fit score, and a sophisticated tie-breaker for effective bin selection.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    utilization_factor_weight = 0.7  # Weight for utilization factor\n    fit_score_weight = 0.3  # Weight for fit score\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(utilization_factor) * utilization_factor_weight + fit_score * fit_score_weight, \n                        -np.inf)\n    \n    # Enhanced tie-breaker: combines bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    priority += valid_bins * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + \n                               (- (bins_remain_cap - item) / (1 + bins_remain_cap.max()) * 0.01))\n    \n    # Favor bins that are almost full\n    almost_full_bins = np.logical_and(valid_bins, bins_remain_cap - item < item * 0.1)\n    priority += almost_full_bins * (1 - utilization_factor) * 0.05  # Weighted addition\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 361.8911104523407,
    "mi": 87.13706735577362,
    "token_count": 199.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response5.txt_stdout.txt",
    "code_path": "problem_iter32_code5.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a sophisticated tie-breaker for effective prioritization.\n    Balances multiple factors and avoids redundant complexity with robust optimization.\n    \"\"\"\n    # Constants to avoid division by zero and for tie-breaker\n    epsilon = 1e-6  \n    tie_breaker_coef = 1e-3  \n    utilization_factor_weight = 0.8  # Weight for utilization factor\n    fit_score_weight = 0.2  # Weight for fit score\n    \n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(utilization_factor) * utilization_factor_weight + fit_score * fit_score_weight, \n                        -np.inf)\n    \n    # Sophisticated tie-breaker: combines bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + \n                                               (- (bins_remain_cap - item) / (1 + bins_remain_cap.max()) * 0.01))\n    \n    # Combine priority score with tie-breaker and a small random noise for further tie-breaking\n    priority += tie_breaker + np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 361.8911104523407,
    "mi": 87.13706735577362,
    "token_count": 199.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response6.txt_stdout.txt",
    "code_path": "problem_iter32_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines nuanced scoring and tie-breakers for efficient bin packing.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Calculate utilization factor and weighted score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    score = np.where(bins_remain_cap >= item, -0.5 * np.abs(utilization_factor) + 0.5 * (bins_remain_cap - item) / bins_remain_cap.max(), -np.inf)\n    \n    # Novel tie-breaker favoring bins with remaining capacity close to item size\n    tie_breaker = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), 0)\n    priority = score + tie_breaker_coef * tie_breaker\n    \n    # Secondary tie-breaker based on bin index for deterministic order\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef ** 2)\n    \n    # Additional nuance from v1: considering remaining capacity proportion\n    remaining_capacity_proportion = (bins_remain_cap / (1 + np.sum(bins_remain_cap))) * tie_breaker_coef\n    priority += (bins_remain_cap >= item) * remaining_capacity_proportion\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 61.53769445552455,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 361.8911104523407,
    "mi": 87.13706735577362,
    "token_count": 199.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response7.txt_stdout.txt",
    "code_path": "problem_iter32_code7.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a sophisticated tie-breaker for effective bin selection.\n    \"\"\"\n    epsilon = 1e-6  \n    utilization_factor_weight = 0.8  \n    fit_score_weight = 0.2  \n    tie_breaker_coef = 1e-3  \n    \n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(utilization_factor) * utilization_factor_weight + fit_score * fit_score_weight, \n                        -np.inf)\n    \n    # Enhanced tie-breaker: combines bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    priority += valid_bins * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + \n                               (- (bins_remain_cap - item) / (1 + bins_remain_cap.max()) * 0.01))\n    \n    # Favor bins that are almost full (additional factor from priority_v1)\n    almost_full_bins = np.logical_and(valid_bins, bins_remain_cap - item < item * 0.1)\n    remaining_fraction = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    priority += almost_full_bins * (1 - remaining_fraction) * 0.1\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 361.8911104523407,
    "mi": 87.13706735577362,
    "token_count": 199.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response8.txt_stdout.txt",
    "code_path": "problem_iter32_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Heuristic combining weighted utilization, remaining capacity, and a nuanced tie-breaker.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Weighted utilization factor\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    norm_remain_cap = bins_remain_cap / np.max(bins_remain_cap)\n    weighted_utilization = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) * 0.7 + norm_remain_cap * 0.3, -np.inf)\n    \n    # Nuanced tie-breaker based on bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * 0.5 + \n                                                bins_remain_cap / (1 + np.sum(bins_remain_cap)) * 0.5) * tie_breaker_coef)\n    \n    # Combine weighted utilization and tie-breaker for priority score\n    priority = weighted_utilization + tie_breaker\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.01874750698045,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 361.8911104523407,
    "mi": 87.13706735577362,
    "token_count": 199.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response9.txt_stdout.txt",
    "code_path": "problem_iter32_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines weighted utilization factor, remaining capacity, and a sophisticated tie-breaker for online Bin Packing Problem.\n    \"\"\"\n    # Normalize remaining capacity\n    norm_remain_cap = bins_remain_cap / np.max(bins_remain_cap)\n    epsilon = 1e-6  # Avoid division by zero\n    \n    # Weighted utilization factor considering item size and bin capacity\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    weighted_utilization = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) * 0.7 + norm_remain_cap * 0.3, -np.inf)\n    \n    # Sophisticated tie-breaker based on bin remaining capacity and index\n    num_bins = len(bins_remain_cap)\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * 0.5 + \n                                                (bins_remain_cap / (item + epsilon)) * 0.5) * tie_breaker_coef)\n    \n    # Combine weighted utilization with tie-breaker and a small random noise for further tie-breaking\n    priority = np.where(weighted_utilization != -np.inf, weighted_utilization + tie_breaker + np.random.uniform(0, 1e-6, size=num_bins), -np.inf)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 3.9289988033506273,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 361.8911104523407,
    "mi": 87.13706735577362,
    "token_count": 199.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response0.txt_stdout.txt",
    "code_path": "problem_iter33_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                utilization_weight: float = 0.43, fit_score_weight: float = 0.27, \n                remaining_capacity_weight: float = 0.30, tie_breaker_log_weight: float = 0.65, \n                epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Advanced priority function incorporating utilization, fit score, remaining capacity, and a sophisticated tie-breaker.\n    \"\"\"\n    # Normalize remaining capacity for better comparison\n    norm_remain_cap = bins_remain_cap / np.max(bins_remain_cap)\n    \n    # Calculate a fit score that rewards bins with just enough capacity for the item\n    fit_score = -np.abs(bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Calculate weighted factors for bins that can fit the item\n    weighted_utilization = np.where(bins_remain_cap >= item, \n                                     (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon) * utilization_weight, \n                                     -np.inf)\n    weighted_fit_score = np.where(bins_remain_cap >= item, fit_score * fit_score_weight, -np.inf)\n    weighted_remaining_capacity = np.where(bins_remain_cap >= item, norm_remain_cap * remaining_capacity_weight, -np.inf)\n    \n    # Priority score combining multiple weighted factors\n    priority = weighted_utilization + weighted_fit_score + weighted_remaining_capacity\n    \n    # Introduce a nuanced tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_log_weight)\n    priority += tie_breaker\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 299.8556500836541,
    "mi": 88.99655719795149,
    "token_count": 208.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response1.txt_stdout.txt",
    "code_path": "problem_iter33_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                fit_score_weight: float = 0.4321, utilization_weight: float = 0.5679, \n                remaining_capacity_weight: float = 0.1234, tie_breaker_log_weight: float = 0.9012, \n                epsilon: float = 1e-6, tie_breaker_coef: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Advanced priority function combining fit score, utilization factor, and remaining capacity with a nuanced tie-breaker.\n    \"\"\"\n    # Calculate fit score: how well the item fits into the bin\n    fit_score = 1 - np.abs((bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon))\n    fit_score = np.where(bins_remain_cap >= item, fit_score, -np.inf)\n    \n    # Calculate utilization factor after placing the item\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Normalize remaining capacity to enhance comparison\n    norm_remain_cap = bins_remain_cap / np.max(bins_remain_cap)\n    \n    # Combine fit score, utilization factor, and remaining capacity into a priority score\n    priority = (fit_score * fit_score_weight + \n                -np.abs(utilization_factor) * utilization_weight + \n                norm_remain_cap * remaining_capacity_weight)\n    \n    # Introduce a nuanced tie-breaker based on bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_log_weight) * tie_breaker_coef)\n    priority += tie_breaker\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.11846828879138,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 299.8556500836541,
    "mi": 88.99655719795149,
    "token_count": 208.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response2.txt_stdout.txt",
    "code_path": "problem_iter33_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                fit_score_weight: float = 0.3, utilization_weight: float = 0.4, \n                remaining_capacity_weight: float = 0.2, tie_breaker_index_weight: float = 0.05, \n                tie_breaker_random_weight: float = 0.05, epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Advanced priority function that combines fit score, utilization factor, remaining capacity, \n    and sophisticated tie-breakers for enhanced online bin packing.\n    \"\"\"\n    # Calculate fit score: how well the item fits into the bin\n    fit_score = 1 - np.abs(bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, fit_score, -np.inf)\n    \n    # Utilization factor considering the item size and bin capacity\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Normalize remaining capacity for comparison\n    norm_remain_cap = bins_remain_cap / np.max(bins_remain_cap)\n    \n    # Weighted score combining fit, utilization, and remaining capacity\n    weighted_score = (fit_score * fit_score_weight + \n                      -np.abs(utilization_factor) * utilization_weight + \n                      norm_remain_cap * remaining_capacity_weight)\n    \n    # Introduce tie-breakers based on bin index and randomness\n    num_bins = len(bins_remain_cap)\n    tie_breaker_index = (1 - np.arange(num_bins) / num_bins) * tie_breaker_index_weight\n    tie_breaker_random = np.random.rand(num_bins) * tie_breaker_random_weight\n    \n    # Priority score is the sum of weighted score and tie-breakers\n    priority = weighted_score + tie_breaker_index + tie_breaker_random\n    \n    # Ensure bins that cannot fit the item have the lowest priority\n    priority = np.where(bins_remain_cap >= item, priority, -np.inf)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.01874750698045,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 299.8556500836541,
    "mi": 88.99655719795149,
    "token_count": 208.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response3.txt_stdout.txt",
    "code_path": "problem_iter33_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                utilization_weight: float = 0.5, fit_score_weight: float = 0.3, \n                remaining_capacity_weight: float = 0.2, tie_breaker_index_weight: float = 0.1, \n                epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function combining utilization factor, fit score, remaining capacity, and a tie-breaker based on bin index.\n    \"\"\"\n    # Calculate a fit score that rewards bins where the item fits well\n    fit_score = np.where(bins_remain_cap >= item, 1 - (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon), 0)\n    \n    # Calculate utilization factor\n    utilization_factor = np.where(bins_remain_cap >= item, (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon), -np.inf)\n    \n    # Normalize remaining capacity to enhance comparison\n    norm_remain_cap = bins_remain_cap / np.max(bins_remain_cap)\n    \n    # Calculate the priority score as a weighted sum of the factors\n    priority = (utilization_factor * utilization_weight + \n                fit_score * fit_score_weight + \n                norm_remain_cap * remaining_capacity_weight)\n    \n    # Introduce a tie-breaker based on bin index to favor earlier bins\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (1 / (1 + np.arange(num_bins))) * tie_breaker_index_weight\n    \n    # Add the tie-breaker to the priority score\n    priority += tie_breaker\n    \n    # Ensure that bins that cannot fit the item have a very low priority\n    priority = np.where(bins_remain_cap >= item, priority, -np.inf)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 147.06820901475868,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 299.8556500836541,
    "mi": 88.99655719795149,
    "token_count": 208.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response4.txt_stdout.txt",
    "code_path": "problem_iter33_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                fit_score_weight: float = 0.3, utilization_weight: float = 0.4, \n                remaining_capacity_weight: float = 0.3, tie_breaker_log_weight: float = 0.2, \n                epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function combining fit score, utilization factor, and remaining capacity with a sophisticated tie-breaker.\n    \"\"\"\n    # Fit score: how well the item fits into the bin\n    fit_score = 1 - np.abs(bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, fit_score, -np.inf)\n    \n    # Utilization factor: how much of the bin will be used after placing the item\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Normalize remaining capacity to enhance comparison\n    norm_remain_cap = bins_remain_cap / np.max(bins_remain_cap)\n    \n    # Calculate priority score as a weighted sum of fit score, utilization factor, and remaining capacity\n    priority = (fit_score * fit_score_weight + \n                -np.abs(utilization_factor) * utilization_weight + \n                norm_remain_cap * remaining_capacity_weight)\n    \n    # Introduce a nuanced tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_log_weight)\n    priority += tie_breaker\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.407658556043084,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 299.8556500836541,
    "mi": 88.99655719795149,
    "token_count": 208.0,
    "exec_success": true
  }
]