```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines fit score, secondary priority based on remaining capacity, and a simple tie-breaker.
    """
    # Calculate remaining capacity after adding the item
    remaining_cap_after_addition = bins_remain_cap - item
    
    # Fit score: prioritize bins where the item fits well
    fit_score = np.where(bins_remain_cap >= item, -(np.abs(remaining_cap_after_addition)), -np.inf)
    
    # Secondary prioritization based on remaining capacity
    secondary_priority = np.where(bins_remain_cap >= item, -bins_remain_cap / np.max(bins_remain_cap), 0)
    
    # Simple tie-breaker based on bin index
    tie_breaker = np.log(len(bins_remain_cap) / (1 + np.arange(len(bins_remain_cap)))) * 1e-3
    
    # Combine fit score, secondary priority, and tie-breaker
    priority_scores = fit_score + secondary_priority + tie_breaker
    
    # Add a small random noise for further tie-breaking (inspired by priority_v1)
    np.random.seed(int(item * 1e6))  
    priority_scores += (bins_remain_cap >= item) * np.random.uniform(-1e-8, 1e-8, size=len(bins_remain_cap))
    
    return priority_scores
```
