[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements the First-Fit decreasing heuristic with a twist.\n    It prioritizes bins that have just enough capacity for the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # So, we use the negative of the remaining capacity after adding the item\n    # If the item doesn't fit, the priority score is negative infinity\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # To avoid division by zero and make the score more meaningful, we can add a small value to the denominator\n    # However, in this case, it's not necessary because we're not using the remaining capacity as a denominator\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score as the negative of the difference (lower difference means higher priority)\n    # Add a small value to the denominator to avoid division by zero\n    priority = -diff / (bins_remain_cap + 1e-6)\n    \n    # Set the priority score to negative infinity for bins that cannot accommodate the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item and lower remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # If the bin has enough capacity for the item, the priority score is the negative of the remaining capacity\n    # Otherwise, the priority score is negative infinity\n    priority_scores = np.where(bins_remain_cap >= item, -bins_remain_cap, -np.inf)\n    \n    return priority_scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    Bins with remaining capacity closest to the item size are given higher priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Bins that can fit the item should have higher priority\n    mask = bins_remain_cap >= item\n    \n    # Assign high priority to bins that can fit the item and have remaining capacity closest to the item size\n    priority = np.where(mask, 1 / (1 + diff), 0)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still hold the item gets the highest priority.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # If the bin cannot hold the item, its priority score is -inf\n    # Otherwise, the priority score is the negative of the remaining capacity\n    # This is because we want to prioritize bins with less remaining capacity\n    priority_scores = np.where(bins_remain_cap >= item, -bins_remain_cap, -np.inf)\n    \n    return priority_scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # If the item can fit in the bin, the priority score is the negative of the remaining capacity\n    # If the item cannot fit in the bin, the priority score is negative infinity\n    priority_scores = np.where(bins_remain_cap >= item, -bins_remain_cap, -np.inf)\n    \n    return priority_scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with remaining capacity closest to the item size gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    diff[bins_remain_cap < item] = np.inf\n    \n    # Calculate the priority score as the negative of the difference (lower difference means higher priority)\n    priority = -diff\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_diff = np.max(-priority[priority != -np.inf])\n    if max_diff > 0:\n        priority = priority / max_diff\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit into the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Give higher priority to bins with less remaining capacity that can still fit the item\n    priority = valid_bins * (1 - bins_remain_cap / np.max(bins_remain_cap))\n    \n    # Add a small random noise to break ties\n    priority += np.random.rand(*priority.shape) * 1e-6\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements the First-Fit Decreasing Height (FFDH) priority \n    heuristic, a variation of which is suitable for online bin packing. \n    The priority is higher for bins that have just enough remaining capacity \n    to hold the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin. \n    # A bin with remaining capacity closer to the item size gets higher priority.\n    # Bins that cannot fit the item get a priority score of negative infinity.\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -np.abs(bins_remain_cap - item), \n                               -np.inf)\n    return priority_scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # If the item cannot fit in a bin, set the priority to negative infinity\n    priority = np.where(remaining_capacity_after_addition >= 0, \n                        # Prioritize bins with less remaining capacity after addition\n                        -remaining_capacity_after_addition, \n                        # Use negative infinity for bins that are too small\n                        -np.inf)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # If the item cannot fit in the bin, the priority score is -inf\n    # Otherwise, the priority score is the negative of the remaining capacity after adding the item\n    # This way, the bin with the least remaining capacity that can still fit the item gets the highest priority\n    priority_scores = np.where(bins_remain_cap >= item, - (bins_remain_cap - item), -np.inf)\n    \n    return priority_scores",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n    If a bin cannot hold the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin with remaining capacity closest to the item size gets the highest priority\n    priority = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    return priority",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on First-Fit heuristic with a twist to encourage fuller bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # For bins that can fit the item, the priority score is inversely proportional to the remaining capacity after adding the item\n    # This encourages packing items into bins that will be fuller after adding the item\n    scores = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1e-9), -1.0)\n    # The '+ 1e-9' is to avoid division by zero\n    \n    return scores",
    "response_id": 12,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on the remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Create a mask to identify bins that have enough capacity for the item\n    valid_bins = remaining_capacity_after_addition >= 0\n    \n    # Assign a high priority to valid bins and a low priority to invalid bins\n    priority = np.where(valid_bins, bins_remain_cap - item, -np.inf)\n    \n    return priority",
    "response_id": 13,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements the First-Fit-Decreasing heuristic.\n    It prioritizes bins that have just enough capacity for the item.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high if the bin has just enough capacity for the item\n    # and low if the bin is too small or too large for the item\n    priority_scores = np.where(bins_remain_cap >= item, \n                               bins_remain_cap - item, \n                               np.inf)\n    # Invert the scores so that smaller values (i.e., bins that are a good fit) have higher priority\n    priority_scores = 1 / (1 + priority_scores)\n    \n    return priority_scores",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements the First-Fit decreasing heuristic with a twist.\n    It prioritizes bins that have just enough capacity for the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high when the bin has just enough capacity for the item\n    priority_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, np.inf)\n    # Use the negative of the scores to get the bin with the highest priority (i.e., the one with the least remaining capacity)\n    priority_scores = -priority_scores\n    \n    return priority_scores",
    "response_id": 15,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high if the bin has enough capacity and is almost full\n    scores = np.where(bins_remain_cap >= item, 1 - (bins_remain_cap - item) / bins_remain_cap, -1)\n    # Normalize the scores to be between 0 and 1\n    scores = np.maximum(scores, 0)\n    return scores",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    We prefer bins that have just enough capacity to hold the item.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high if the bin has just enough capacity to hold the item\n    priority = np.where(bins_remain_cap >= item, \n                        1 - np.abs(bins_remain_cap - item) / item, \n                        0)\n    return priority",
    "response_id": 17,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Create a mask to identify bins that have enough capacity for the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # For bins with enough capacity, the priority is inversely proportional to the remaining capacity after addition\n    # This encourages packing items tightly into bins\n    priority_valid_bins = 1 / (remaining_cap_after_addition + 1e-6)  # Add a small value to avoid division by zero\n    \n    # For bins without enough capacity, the priority is negative infinity (or a very low number in practice)\n    # This effectively prevents the item from being assigned to these bins\n    priority_invalid_bins = -np.inf * np.ones_like(priority_valid_bins)\n    \n    # Combine the priorities for valid and invalid bins based on the mask\n    priority = np.where(valid_bins_mask, priority_valid_bins, priority_invalid_bins)\n    \n    return priority",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with remaining capacity closest to the item size will have the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score as the negative of the difference (lower difference means higher priority)\n    # Add a small value to avoid division by zero when bins_remain_cap equals item\n    priority = -diff + 1e-6\n    \n    # Set the priority to negative infinity for bins that cannot accommodate the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements the First-Fit decreasing heuristic with a twist. \n    It gives higher priority to bins that have enough capacity for the item \n    and are most full. If a bin does not have enough capacity, its priority is \n    set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # Priority is high when the bin has just enough capacity for the item\n    # and is most full, i.e., has the least remaining capacity\n    priority = np.where(bins_remain_cap >= item, \n                        # The more full the bin is, the higher the priority\n                        1 / (bins_remain_cap + 1e-6), \n                        # If the bin does not have enough capacity, set priority to negative infinity\n                        -np.inf)\n    \n    return priority",
    "response_id": 20,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin based on \n    the remaining capacity of the bins and the size of the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # and the size of the item. A bin with a remaining capacity closest to the \n    # item size will have the highest priority score.\n    priority_scores = np.where(bins_remain_cap >= item, \n                               bins_remain_cap - item, \n                               -np.inf)\n    \n    # Normalize the priority scores to ensure they are in a comparable range.\n    # Here, we use a simple normalization by subtracting the minimum score and \n    # then dividing by the range of scores. However, since we're using -inf for \n    # bins that can't fit the item, this step is somewhat redundant but remains \n    # for potential future adjustments to the scoring system.\n    finite_scores = priority_scores[np.isfinite(priority_scores)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            normalized_scores = (priority_scores - min_score) / (max_score - min_score)\n        else:\n            normalized_scores = np.where(priority_scores == max_score, 1.0, 0.0)\n    else:\n        normalized_scores = np.zeros_like(priority_scores)\n    \n    # Softmax normalization to ensure the scores are positive and sum to 1.\n    # However, for simplicity and to maintain the relative order, we'll directly \n    # return the priority scores. To introduce softmax, uncomment the following.\n    # e_scores = np.exp(normalized_scores)\n    # return e_scores / np.sum(e_scores)\n    return normalized_scores",
    "response_id": 21,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size will have the highest priority.\n    If a bin does not have enough capacity to hold the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is the negative of the difference between the remaining capacity and the item size\n    # This way, a bin with a remaining capacity closest to the item size will have the highest score\n    priority_scores = -np.abs(bins_remain_cap - item)\n    \n    # Set the priority score to negative infinity if the bin does not have enough capacity\n    priority_scores[bins_remain_cap < item] = -np.inf\n    \n    return priority_scores",
    "response_id": 22,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n    If a bin cannot hold the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin with remaining capacity closest to the item size gets the highest priority\n    priorities = np.where(bins_remain_cap >= item, \n                          -np.abs(bins_remain_cap - item),  # Closer to item size is better\n                          -np.inf)  # Cannot hold the item, so priority is -inf\n    \n    return priorities",
    "response_id": 23,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score as the negative of the difference (lower difference means higher priority)\n    # Add a small value to the difference to avoid division by zero when taking the reciprocal\n    priority = - (diff + 1e-6)\n    \n    # Set the priority score to negative infinity for bins that cannot accommodate the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 24,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign a high priority score to bins that have enough capacity for the item\n    # and a low priority score to bins that don't have enough capacity\n    priority_scores = np.where(remaining_cap_after_addition >= 0, \n                               -remaining_cap_after_addition,  # Lower remaining capacity is preferred\n                               -np.inf)  # Bins that can't fit the item get the lowest priority\n    \n    # To avoid division by zero and to make the scores more distinguishable, \n    # we can add a small value to the denominator or use a different scoring function\n    # Here, we simply use the negative remaining capacity as the score\n    \n    return priority_scores",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with remaining capacity closest to the item size gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(bins_remain_cap >= item, -diff, -np.inf)\n    \n    return priority",
    "response_id": 26,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priority = np.where(remaining_cap_after_add >= 0, \n                        # For bins that can hold the item, prioritize the ones with the least remaining capacity\n                        -remaining_cap_after_add, \n                        # For bins that cannot hold the item, assign a very low priority\n                        -np.inf)\n    \n    return priority",
    "response_id": 27,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough \n    remaining capacity to fit the item. It discourages bins that would be left \n    with a lot of remaining capacity after the item is added, as well as bins \n    that are too small to fit the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Create a mask to avoid division by zero and to ignore bins that are too small\n    mask = bins_remain_cap >= item\n    \n    # Initialize priority scores with negative infinity for bins that are too small\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For bins that can fit the item, calculate the priority score\n    # The score is higher when the remaining capacity after adding the item is smaller\n    priority_scores[mask] = 1 - (bins_remain_cap[mask] - item) / bins_remain_cap[mask]\n    \n    return priority_scores",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with remaining capacity closest to the item size gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(bins_remain_cap >= item, -diff, -np.inf)\n    \n    return priority",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "mi": 61.82864391142225,
    "token_count": 63.0,
    "exec_success": true
  }
]