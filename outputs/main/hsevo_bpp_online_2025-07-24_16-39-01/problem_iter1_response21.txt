```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin based on 
    the remaining capacity of the bins and the size of the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the priority score for each bin based on the remaining capacity
    # and the size of the item. A bin with a remaining capacity closest to the 
    # item size will have the highest priority score.
    priority_scores = np.where(bins_remain_cap >= item, 
                               bins_remain_cap - item, 
                               -np.inf)
    
    # Normalize the priority scores to ensure they are in a comparable range.
    # Here, we use a simple normalization by subtracting the minimum score and 
    # then dividing by the range of scores. However, since we're using -inf for 
    # bins that can't fit the item, this step is somewhat redundant but remains 
    # for potential future adjustments to the scoring system.
    finite_scores = priority_scores[np.isfinite(priority_scores)]
    if len(finite_scores) > 0:
        min_score, max_score = np.min(finite_scores), np.max(finite_scores)
        if max_score != min_score:
            normalized_scores = (priority_scores - min_score) / (max_score - min_score)
        else:
            normalized_scores = np.where(priority_scores == max_score, 1.0, 0.0)
    else:
        normalized_scores = np.zeros_like(priority_scores)
    
    # Softmax normalization to ensure the scores are positive and sum to 1.
    # However, for simplicity and to maintain the relative order, we'll directly 
    # return the priority scores. To introduce softmax, uncomment the following.
    # e_scores = np.exp(normalized_scores)
    # return e_scores / np.sum(e_scores)
    return normalized_scores
```
