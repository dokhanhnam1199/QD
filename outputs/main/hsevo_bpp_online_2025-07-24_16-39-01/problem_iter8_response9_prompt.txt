{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a hybrid heuristic that considers both the remaining capacity \n    after adding the item and the number of items already packed in the bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # and have fewer items already packed (i.e., larger remaining capacity initially)\n    initial_capacities = np.full_like(bins_remain_cap, 1.0)  # assuming initial capacity is 1.0\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + 0.1 * (initial_capacities - bins_remain_cap), \n                               -np.inf)\n    \n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins with just enough capacity and breaks ties with a combination of random noise and bin index.\n    \"\"\"\n    # Check if the item can fit into the bin and prioritize bins with less remaining capacity after addition\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    priority = valid_bins * (-(bins_remain_cap - item))  # Prioritize bins that are just enough for the item\n    \n    # Add a small factor considering the bin index (older bins are prioritized) and random noise to break ties\n    num_bins = len(bins_remain_cap)\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) + np.random.rand(*priority.shape) * 1e-6)\n    \n    return priority\n\n### Analyze & experience\n- Comparing the best heuristic (1st) with the worst (20th), we see that the top heuristic prioritizes bins with just enough capacity and considers the remaining capacity, while the worst one also prioritizes bins with just enough capacity but with a less effective tie-breaking strategy. \nComparing (1st) vs (2nd), we see that both consider remaining capacity after adding the item, but the 1st heuristic uses a simpler and more effective formula. \n(3rd) vs (4th) shows that similar heuristics can have slight variations in their formulas, but (3rd) adds a small random noise which is beneficial. \n(19th) vs (20th) shows that using a combination of random noise and bin index for tie-breaking is common among lower-ranked heuristics, but (19th) uses a more sophisticated approach with tuned parameters.\nOverall, effective prioritization and tie-breaking strategies are crucial, and top heuristics tend to use simpler, more effective formulas.\n- \nTo redesign 'Current self-reflection,' let's analyze the given information and reframe it to avoid the pitfalls mentioned in 'Ineffective self-reflection.' Here's a step-by-step breakdown:\n\n### Analysis\n- The 'Current self-reflection' focuses on simple prioritization formulas and tie-breaking using multiple factors.\n- The 'Ineffective self-reflection' suggests looking into more effective prioritization strategies and handling edge cases.\n\n### Redefined 'Current self-reflection'\nTo design better heuristics, consider the following:\n* **Keywords**: Effective prioritization, multiple factors, edge cases.\n* **Advice**: Focus on strategies like negative or inverse remaining capacity and implement robust tie-breaking.\n* **Avoid**: Simple, non-effective prioritization and lack of edge case handling.\n* **Explanation**: Combining effective prioritization strategies with robust handling of edge cases like division by zero and ties will lead to better heuristics.\n\nLet's refine our approach with these insights. I'm ready to help design better heuristics.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}