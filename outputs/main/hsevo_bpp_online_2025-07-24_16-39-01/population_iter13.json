[
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and remaining capacity for prioritization with a simple tie-breaker.\n    \"\"\"\n    # Calculate utilization factor, avoiding division by zero\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, 1e-9)\n    \n    # Priority score for bins that can fit the item, using a combination of utilization and remaining capacity\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor), -np.inf)\n    \n    # Add a tie-breaker based on bin index with a small coefficient\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3)\n    \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines remaining capacity and 'fullness' with a tie-breaker based on bin index and random noise.\n    \"\"\"\n    # Calculate max capacity assuming all bins have the same max capacity\n    max_capacity = np.max(bins_remain_cap) + item\n    \n    # Priority score for bins that can fit the item\n    mask = bins_remain_cap >= item\n    priority = np.where(mask, \n                        -(bins_remain_cap - item) + 0.1 * (max_capacity - bins_remain_cap - item) / max_capacity, \n                        -np.inf)\n    \n    # Add a tie-breaker based on bin index and random noise\n    num_bins = len(bins_remain_cap)\n    priority = np.where(priority != -np.inf, \n                        priority + np.log(num_bins / (1 + np.arange(num_bins))) + np.random.uniform(0, 1e-6, size=num_bins), \n                        -np.inf)\n    \n    # Normalize scores to avoid extreme values\n    finite_scores = priority[np.isfinite(priority)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            priority[np.isfinite(priority)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines effective prioritization of bins with just enough capacity and robust tie-breaking.\n    Uses a combination of negative remaining capacity and bin utilization ratio for prioritization.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the item can fit into the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Prioritize bins that are just enough for the item\n    priority = valid_bins * (-(remaining_cap_after_addition) + (1 / (bins_remain_cap + 1e-9)))\n    \n    # Add a small random noise for tie-breaking\n    num_bins = len(bins_remain_cap)\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) + np.random.rand(*priority.shape) * 1e-6)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response3.txt_stdout.txt",
    "code_path": "problem_iter11_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines effective prioritization of bins with just enough capacity and robust tie-breaking.\n    Uses a utilization factor and a small random noise for tie-breaking.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate the priority score for valid bins\n    # Use a combination of negative remaining capacity and a utilization factor\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(valid_bins, \n                                -(bins_remain_cap - item) +  # Prioritize bins with just enough capacity\n                                np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3 +  # Tie-breaker based on bin index\n                                np.random.uniform(0, 1e-6, size=num_bins),  # Random noise for tie-breaking\n                                -np.inf)  # Negative infinity for bins that cannot fit the item\n    \n    return priority_scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to bins, combining remaining capacity, \n    utilization factor, and a simple tie-breaker based on bin index.\n    \"\"\"\n    # Calculate priority score as a combination of negative remaining capacity \n    # after addition and the proportion of the remaining capacity that the item occupies\n    remaining_cap_after_addition = bins_remain_cap - item\n    priority_scores = np.where(\n        bins_remain_cap >= item, \n        -(remaining_cap_after_addition) + (item / bins_remain_cap), \n        -np.inf\n    )\n    \n    # Add a simple tie-breaker based on bin index to favor earlier bins\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    return priority_scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response5.txt_stdout.txt",
    "code_path": "problem_iter11_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Combines prioritizing bins with just enough capacity and a robust tie-breaking strategy.\n    \"\"\"\n    # Prioritize bins that have just enough capacity for the item\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a utilization factor considering the proportion of remaining capacity\n    max_capacity = np.max(bins_remain_cap) + item\n    utilization_factor = (max_capacity - bins_remain_cap - item) / max_capacity\n    priority_scores += 0.1 * np.where(bins_remain_cap >= item, utilization_factor, 0)\n    \n    # Add a small random noise for tie-breaking\n    priority_scores += np.random.rand(*priority_scores.shape) * 1e-6\n    \n    return priority_scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response6.txt_stdout.txt",
    "code_path": "problem_iter11_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines prioritizing bins with just enough capacity and a robust tie-breaking strategy.\n    Utilizes a simple utilization factor and random noise for tie-breaking.\n    \"\"\"\n    # Prioritize bins that have just enough capacity for the item\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Calculate a utilization factor based on the remaining capacity\n    max_capacity = np.max(bins_remain_cap) + item  # Assuming all bins have the same max capacity\n    utilization_factor = (max_capacity - bins_remain_cap - item) / max_capacity\n    \n    # Combine the priority score with the utilization factor\n    priority_scores += 0.1 * np.where(bins_remain_cap >= item, utilization_factor, 0)\n    \n    # Add random noise for tie-breaking\n    priority_scores += np.random.rand(*priority_scores.shape) * 1e-6\n    \n    return priority_scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response7.txt_stdout.txt",
    "code_path": "problem_iter11_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines effective prioritization with robust tie-breaking.\n    Prioritizes bins with just enough capacity and uses a balanced tie-breaking strategy.\n    \"\"\"\n    # Prioritize bins with just enough capacity using a utilization factor\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, 1e-9)  \n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor), -np.inf)\n    \n    # Add a small factor considering the bin index for tie-breaking\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3 + np.random.rand(*priority.shape) * 1e-6)\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response8.txt_stdout.txt",
    "code_path": "problem_iter11_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and remaining capacity with tie-breaking using bin index.\n    \"\"\"\n    # Calculate priority score for bins that can fit the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    # Prioritize bins that are just enough for the item\n    priority = valid_bins * (-(bins_remain_cap - item) + 0.1 * bins_remain_cap.max() - 0.1 * bins_remain_cap)\n    \n    # Add a small factor considering the bin index to break ties\n    num_bins = len(bins_remain_cap)\n    priority += valid_bins * np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3\n    \n    # Set priority to negative infinity for bins that cannot fit the item\n    priority = np.where(bins_remain_cap >= item, priority, -np.inf)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response9.txt_stdout.txt",
    "code_path": "problem_iter11_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines prioritizing bins with just enough capacity and a robust tie-breaking strategy.\n    Utilizes a mix of remaining capacity and random noise for effective tie-breaking.\n    \"\"\"\n    # Prioritize bins that have just enough capacity for the item\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a factor considering the proportion of remaining capacity and a small random noise for tie-breaking\n    num_bins = len(bins_remain_cap)\n    priority_scores += 0.1 * np.where(bins_remain_cap >= item, (1 - bins_remain_cap), 0) + np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3 + np.random.rand(*priority_scores.shape) * 1e-6\n    \n    return priority_scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 188.0175887256437,
    "mi": 89.34861771298247,
    "token_count": 118.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a more sophisticated heuristic that combines multiple factors for effective prioritization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # For bins that have enough capacity, calculate the priority score\n    # We want to prioritize bins that have just enough capacity for the item (to maximize utilization)\n    # and also consider the absolute remaining capacity (to avoid leaving too much empty space)\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(np.abs(remaining_cap_after_addition)) +  # prioritize bins with just enough capacity\n                               0.01 * bins_remain_cap,  # slightly prioritize bins with more remaining capacity\n                               -np.inf)  # bins that can't fit the item get -inf priority\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 59.77612193827004,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a mutated heuristic that combines multiple factors for effective prioritization.\n    It prioritizes bins that have just enough capacity for the item and are relatively more empty.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # So, we use a combination of the negative of the remaining capacity after adding the item and the current remaining capacity\n    # If the item doesn't fit, the priority score is negative infinity\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item) + 0.1 * bins_remain_cap, -np.inf)\n    \n    return priority_scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 59.77612193827004,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a heuristic that combines multiple factors for effective prioritization.\n    It prioritizes bins that have just enough capacity for the item and are most filled.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Create a mask for bins that can fit the item\n    can_fit_item = bins_remain_cap >= item\n    \n    # For bins that can fit the item, calculate the priority score as a combination of \n    # the negative remaining capacity after addition (to prioritize bins that are most filled) \n    # and the remaining capacity (to prioritize bins that have just enough capacity)\n    priority_scores = np.where(can_fit_item, \n                               -remaining_cap_after_addition + 0.1 * (1 - (remaining_cap_after_addition / bins_remain_cap)), \n                               -np.inf)\n    \n    return priority_scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 59.77612193827004,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a heuristic that combines the remaining capacity \n    and the utilization of the bin to determine the priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the initial capacity of the bins (assuming it's the same for all bins)\n    # Here, we assume the initial capacity is the maximum remaining capacity seen so far\n    max_remain_cap = np.max(bins_remain_cap)\n    \n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # and also have a high utilization (i.e., low remaining capacity)\n    priority_scores = np.where(\n        bins_remain_cap >= item, \n        # Combine the negative of the remaining capacity after adding the item \n        # and the utilization of the bin (1 - remaining capacity / initial capacity)\n        -(bins_remain_cap - item) + (1 - bins_remain_cap / max_remain_cap), \n        -np.inf  # If the item doesn't fit, the priority score is negative infinity\n    )\n    \n    return priority_scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 59.77612193827004,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a heuristic that prioritizes bins based on their remaining capacity and utilization.\n    It combines the factors of having just enough capacity for the item and the overall utilization of the bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # and also have a high overall utilization\n    \n    # First, filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # For valid bins, calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap[valid_bins] - item\n    \n    # Calculate the utilization of the bin after adding the item\n    # Assuming the bin capacity is 1.0 (or normalize it to 1.0)\n    bin_utilization_after_addition = (1.0 - remaining_after_addition) / 1.0\n    \n    # Priority score is a combination of the negative remaining capacity (to prioritize bins with just enough capacity)\n    # and the bin utilization after adding the item (to prioritize bins that are more full)\n    priority_scores_valid = -remaining_after_addition + bin_utilization_after_addition\n    \n    # Create an array to store the priority scores for all bins\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    \n    # Assign the calculated priority scores to the valid bins\n    priority_scores[valid_bins] = priority_scores_valid\n    \n    return priority_scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 59.77612193827004,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response1.txt_stdout.txt",
    "code_path": "problem_iter13_code1.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 6.092855021862127e-07, tie_breaker_coef: float = 0.054746423211797395) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and remaining capacity for prioritization with a simple tie-breaker.\n    \"\"\"\n    # Calculate utilization factor, avoiding division by zero\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Priority score for bins that can fit the item, using a combination of utilization and remaining capacity\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor), -np.inf)\n    \n    # Add a tie-breaker based on bin index with a small coefficient\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    return priority",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.01874750698045,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 138.24238017775622,
    "mi": 92.08407263537839,
    "token_count": 126.0,
    "exec_success": true
  }
]