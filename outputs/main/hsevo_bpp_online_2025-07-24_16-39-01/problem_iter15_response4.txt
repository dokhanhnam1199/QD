```python
import numpy as np

epsilon = 1e-6  # Small value to avoid division by zero
tie_breaker_coef = 1e-3  # Coefficient for tie-breaker

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Enhanced prioritization function combining multiple factors for online Bin Packing Problem.
    
    This function calculates a priority score for each bin based on how well it can accommodate the item,
    considering both the bin's remaining capacity and its relative utilization. It also incorporates a 
    tie-breaker based on bin index to favor newer bins.
    """
    # Calculate the absolute difference between the item size and the remaining capacity
    # Lower difference indicates a better fit
    fit_score = np.abs(bins_remain_cap - item)
    
    # Calculate a utilization score; bins with lower remaining capacity (higher utilization) are preferred
    utilization_score = bins_remain_cap
    
    # Priority score for bins that can fit the item, using a combination of fit score and utilization score
    priority = np.where(bins_remain_cap >= item, -(fit_score / np.maximum(bins_remain_cap, epsilon)) + utilization_score / np.maximum(bins_remain_cap, epsilon), -np.inf)
    
    # Incorporate a tie-breaker based on bin index to favor bins with lower indices (older bins)
    num_bins = len(bins_remain_cap)
    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)
    
    # Normalize the priority scores to ensure they are on a comparable scale
    max_priority = np.max(priority)
    if max_priority != -np.inf:  # Check if there are any bins that can fit the item
        priority = np.where(priority != -np.inf, priority - max_priority, -np.inf)
    
    return priority
```
