{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n                epsilon: float = 0.00045513611548818594, \n                tie_breaker_coef: float = 0.006961741864045284, \n                utilization_factor_weight: float = 0.8093456021579895, \n                fit_score_weight: float = 0.24322675658121395) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a simple tie-breaker for effective prioritization.\n    Weights are chosen based on the analysis of top-ranked heuristics.\n    \"\"\"\n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, \n                        # Combine utilization factor and fit score with a bias towards utilization factor\n                        -np.abs(utilization_factor) * utilization_factor_weight + fit_score * fit_score_weight, \n                        -np.inf)\n    \n    # Add a simple tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines utilization factor and fit score with a balanced tie-breaker.\n    \"\"\"\n    # Constants to avoid division by zero and for tie-breaker\n    epsilon = 1e-6  \n    tie_breaker_coef = 1e-3  \n    \n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    fit_score = 1 - (item / np.maximum(bins_remain_cap, epsilon))\n    \n    # Priority score for bins that can fit the item, balancing utilization and fit\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) - fit_score * 0.1, -np.inf)\n    \n    # Enhanced tie-breaker: combines bin index and a small randomness component\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + \n                                              (np.random.rand(num_bins) * tie_breaker_coef / (10 * (1 + np.arange(num_bins)))))\n    \n    # Additional consideration for remaining capacity to differentiate bins with similar utilization\n    priority += (bins_remain_cap >= item) * (- (bins_remain_cap - item) / (1 + bins_remain_cap.max()) * 0.01)\n    \n    return priority\n\n### Analyze & experience\n- Comparing the best heuristics (1st) vs the worst (20th), we see that top heuristics tend to have a more nuanced combination of utilization factor and fit score, with subtle differences in weighting and tie-breaking mechanisms. The top heuristics also tend to favor bins that are almost full to minimize waste. Comparing (1st) vs (2nd), we see that the main difference is in the choice of weights and epsilon value. (2nd) has more precise weights, suggesting that fine-tuning these parameters can lead to improved performance. (3rd) vs (4th) shows that introducing additional parameters can be beneficial, but (4th) has a more complex function signature. Comparing (19th) vs (20th), we see that they are identical, suggesting that there may be some redundancy in the list. Overall, the top heuristics tend to have a balance between utilization factor, fit score, and tie-breaking mechanisms.\n- \nTo redefine 'Current self-reflection' and avoid all things in 'Ineffective self-reflection', let's analyze the given information.\n\n* Keywords: Utilization, Remaining Capacity, Tie-breaking, Simplicity\n* Advice: \n  \u2022 Balance multiple factors like utilization and remaining capacity.\n  \u2022 Use simple yet effective tie-breakers based on bin index or other relevant characteristics.\n  \u2022 Experiment with different weightings and combinations of these factors.\n  \u2022 Focus on combining key factors with effective tie-breakers.\n* Avoid: Redundant complexity, excessive randomness, unnecessary complexity, ineffective prioritization strategies.\n* Explanation: The redefined 'Current self-reflection' should focus on balancing multiple relevant factors and using effective tie-breakers while maintaining simplicity. It should avoid redundant complexity and ineffective prioritization strategies, ultimately leading to designing better heuristics.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}