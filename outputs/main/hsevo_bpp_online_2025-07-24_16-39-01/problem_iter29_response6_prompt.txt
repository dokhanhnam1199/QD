{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, fit score, and a simple tie-breaker for effective bin selection.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Calculate the fraction of remaining capacity after packing the item\n    remaining_fraction = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Calculate the fit factor: how well the item fits into the bin\n    fit_factor = 1 - np.abs(bins_remain_cap - item) / (bins_remain_cap + epsilon)\n    fit_factor = np.where(bins_remain_cap >= item, fit_factor, -np.inf)  # Penalize bins that can't fit the item\n    \n    # Combine remaining fraction and fit factor into a priority score\n    priority = -remaining_fraction + fit_factor\n    \n    # Introduce a tie-breaker based on the bin index to favor bins with lower indices\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    # Slightly favor bins that are almost full to minimize waste\n    almost_full_bins = np.logical_and(bins_remain_cap >= item, bins_remain_cap - item < item * 0.1)\n    priority += almost_full_bins * (1 - remaining_fraction) * 0.1\n    \n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\n    \"\"\"\n    Enhanced prioritization function combining multiple factors for effective bin selection.\n    \"\"\"\n    # Calculate the utilization factor after placing the item in each bin\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Calculate a score based on the remaining capacity after placing the item\n    remaining_capacity_score = bins_remain_cap - item\n    \n    # Priority score for bins that can fit the item, using a combination of utilization factor and remaining capacity score\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) + remaining_capacity_score / (1 + item), -np.inf)\n    \n    # Introduce a tie-breaker that considers both bin index and remaining capacity\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef + remaining_capacity_score * 1e-6)\n    \n    # Combine the priority score with the tie-breaker\n    priority += tie_breaker\n    \n    return priority\n\n### Analyze & experience\n- Comparing the best heuristics (1st) vs the worst (20th), we see that top heuristics tend to have a more nuanced combination of utilization factor and fit score, with subtle differences in weighting and tie-breaking mechanisms. The top heuristics also tend to favor bins that are almost full to minimize waste. Comparing (1st) vs (2nd), we see that the main difference is in the choice of weights and epsilon value. (2nd) has more precise weights, suggesting that fine-tuning these parameters can lead to improved performance. (3rd) vs (4th) shows that introducing additional parameters can be beneficial, but (4th) has a more complex function signature. Comparing (19th) vs (20th), we see that they are identical, suggesting that there may be some redundancy in the list. Overall, the top heuristics tend to have a balance between utilization factor, fit score, and tie-breaking mechanisms.\n- \nTo redefine 'Current self-reflection' and avoid all things in 'Ineffective self-reflection', let's analyze the given information.\n\n* Keywords: Utilization, Remaining Capacity, Tie-breaking, Simplicity\n* Advice: \n  \u2022 Balance multiple factors like utilization and remaining capacity.\n  \u2022 Use simple yet effective tie-breakers based on bin index or other relevant characteristics.\n  \u2022 Experiment with different weightings and combinations of these factors.\n  \u2022 Focus on combining key factors with effective tie-breakers.\n* Avoid: Redundant complexity, excessive randomness, unnecessary complexity, ineffective prioritization strategies.\n* Explanation: The redefined 'Current self-reflection' should focus on balancing multiple relevant factors and using effective tie-breakers while maintaining simplicity. It should avoid redundant complexity and ineffective prioritization strategies, ultimately leading to designing better heuristics.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}