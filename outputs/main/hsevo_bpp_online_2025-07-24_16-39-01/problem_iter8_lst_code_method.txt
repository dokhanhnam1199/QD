{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a more nuanced heuristic that considers both the \n    remaining capacity after adding the item and the number of items already \n    packed in the bin (not directly available but can be inferred from the remaining capacity).\n    It prioritizes bins that have just enough capacity for the item and are relatively fuller.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # and are relatively fuller (i.e., have less remaining capacity)\n    # So, we use a combination of the negative of the remaining capacity after \n    # adding the item and the current remaining capacity as a tie-breaker\n    # If the item doesn't fit, the priority score is negative infinity\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + 0.1 * bins_remain_cap.max() - 0.1 * bins_remain_cap, \n                               -np.inf)\n    \n    return priority_scores\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a more sophisticated heuristic that takes into account \n    both the remaining capacity after adding the item and the number of bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # So, we use a combination of the negative of the remaining capacity after adding the item and a bin utilization factor\n    # If the item doesn't fit, the priority score is negative infinity\n    \n    # Calculate the utilization factor for each bin if the item is added\n    utilization_factor = (bins_remain_cap - item) / bins_remain_cap\n    \n    # For bins that can fit the item, assign a priority score based on the utilization factor and remaining capacity\n    priority_scores = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) - (bins_remain_cap - item) / np.max(bins_remain_cap), -np.inf)\n    \n    # To break ties, we can add a small random noise to the priority scores\n    # However, for simplicity and reproducibility, we will not add noise here\n    \n    return priority_scores\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    Prioritizes bins with just enough capacity, considering remaining capacity and 'fullness'.\n    \"\"\"\n    # Calculate priority score for bins that can accommodate the item\n    mask = bins_remain_cap >= item\n    priority = np.where(mask, \n                        -(bins_remain_cap - item) / (bins_remain_cap + 1e-6) + 1 / (bins_remain_cap + 1e-6), \n                        -np.inf)\n    # Add a small random noise to break ties\n    priority[mask] += np.random.uniform(0, 1e-6, np.sum(mask))\n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a more nuanced heuristic that considers both the \n    remaining capacity after adding the item and the number of items already \n    packed in the bin (not directly available but can be inferred from the remaining capacity).\n    It prioritizes bins that have just enough capacity for the item and are relatively fuller.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # and are relatively fuller (i.e., have less remaining capacity)\n    # So, we use a combination of the negative of the remaining capacity after \n    # adding the item and the current remaining capacity as a tie-breaker\n    # If the item doesn't fit, the priority score is negative infinity\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + 0.1 * bins_remain_cap.max() - 0.1 * bins_remain_cap, \n                               -np.inf)\n    \n    return priority_scores\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins with just enough capacity and breaks ties with random noise.\n    \"\"\"\n    # Check if the item can fit into the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Prioritize bins that are just enough for the item\n    priority = valid_bins * (-(bins_remain_cap - item))\n    \n    # Add a small random noise to break ties, only for valid bins\n    priority += valid_bins * np.random.rand(*priority.shape) * 1e-6\n    \n    return priority\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to bins.\n    Combines remaining capacity and 'fullness' of bins, with tie-breaking noise.\n    \"\"\"\n    # Calculate max capacity assuming all bins have the same max capacity\n    max_capacity = np.max(bins_remain_cap) + item\n    \n    # Priority score: negative remaining capacity after addition, \n    # plus a 'fullness' factor, and a small random noise to break ties\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + (max_capacity - bins_remain_cap - item) / max_capacity + np.random.uniform(0, 1e-6, size=len(bins_remain_cap)), \n                               -np.inf)\n    \n    # Normalize scores to avoid extreme values\n    finite_scores = priority_scores[np.isfinite(priority_scores)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            priority_scores[np.isfinite(priority_scores)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority_scores\n\n[Heuristics 7th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                noise_weight: float = 4.9723798067088914e-05) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins with just enough capacity and breaks ties with random noise.\n    \"\"\"\n    # Check if the item can fit into the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Prioritize bins that are just enough for the item\n    priority = valid_bins * (-(bins_remain_cap - item))\n    \n    # Add a small random noise to break ties, only for valid bins\n    priority += valid_bins * np.random.rand(*priority.shape) * noise_weight\n    \n    return priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    Combines remaining capacity and 'fullness' with tie-breaking noise.\n    \"\"\"\n    # Calculate max capacity assuming all bins have the same max capacity\n    max_capacity = np.max(bins_remain_cap) + item\n    \n    # Priority score for bins that can fit the item\n    mask = bins_remain_cap >= item\n    priority = np.where(mask, \n                        -(bins_remain_cap - item) + (max_capacity - bins_remain_cap - item) / max_capacity + np.random.uniform(0, 1e-6, size=len(bins_remain_cap)), \n                        -np.inf)\n    \n    # Normalize scores to avoid extreme values\n    finite_scores = priority[np.isfinite(priority)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            priority[np.isfinite(priority)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    Combines remaining capacity and 'fullness' with tie-breaking noise.\n    \"\"\"\n    # Calculate max capacity assuming all bins have the same max capacity\n    max_capacity = np.max(bins_remain_cap) + item\n    \n    # Priority score for bins that can fit the item\n    mask = bins_remain_cap >= item\n    priority = np.where(mask, \n                        -(bins_remain_cap - item) + (max_capacity - bins_remain_cap - item) / max_capacity + np.random.uniform(0, 1e-6, size=len(bins_remain_cap)), \n                        -np.inf)\n    \n    # Normalize scores to avoid extreme values\n    finite_scores = priority[np.isfinite(priority)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            priority[np.isfinite(priority)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a hybrid heuristic that considers both the remaining capacity \n    after adding the item and the number of items already packed in the bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # and have fewer items already packed (i.e., larger remaining capacity initially)\n    initial_capacities = np.full_like(bins_remain_cap, 1.0)  # assuming initial capacity is 1.0\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + 0.1 * (initial_capacities - bins_remain_cap), \n                               -np.inf)\n    \n    return priority_scores\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins with just enough capacity and breaks ties with a combination of random noise and bin index.\n    \"\"\"\n    # Check if the item can fit into the bin and prioritize bins with less remaining capacity after addition\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    priority = valid_bins * (-(bins_remain_cap - item))  # Prioritize bins that are just enough for the item\n    \n    # Add a small factor considering the bin index (older bins are prioritized) and random noise to break ties\n    num_bins = len(bins_remain_cap)\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) + np.random.rand(*priority.shape) * 1e-6)\n    \n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins with just enough capacity and breaks ties with a combination of random noise and bin index.\n    \"\"\"\n    # Check if the item can fit into the bin and prioritize bins with less remaining capacity after addition\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    priority = valid_bins * (-(bins_remain_cap - item))  # Prioritize bins that are just enough for the item\n    \n    # Add a small factor considering the bin index (older bins are prioritized) and random noise to break ties\n    num_bins = len(bins_remain_cap)\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) + np.random.rand(*priority.shape) * 1e-6)\n    \n    return priority\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins with just enough capacity and breaks ties with a combination of random noise and bin index.\n    \"\"\"\n    # Check if the item can fit into the bin and prioritize bins with less remaining capacity after addition\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    priority = valid_bins * (-(bins_remain_cap - item))  # Prioritize bins that are just enough for the item\n    \n    # Add a small factor considering the bin index (older bins are prioritized) and random noise to break ties\n    num_bins = len(bins_remain_cap)\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) + np.random.rand(*priority.shape) * 1e-6)\n    \n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    \n    Combines the First-Fit decreasing heuristic with a tie-breaker based on bin index.\n    \"\"\"\n    # Calculate priority scores based on remaining capacity\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a small random noise to break ties\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    return priority_scores\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                random_noise_upper_bound: float = 0.000512910372337147, \n                invalid_bin_priority: float = -3582939133.573016) -> np.ndarray:\n    \"\"\"\n    Priority score for each bin by considering remaining capacity and bin index, with random tie-breaking.\n    \"\"\"\n    # Calculate the number of available bins\n    num_bins = len(bins_remain_cap)\n    \n    # Prioritize bins with enough capacity, considering remaining capacity and bin index\n    priority = np.where(bins_remain_cap >= item, \n                        -(bins_remain_cap - item) + np.log(num_bins / (1 + np.arange(num_bins))) + np.random.uniform(0, random_noise_upper_bound, size=num_bins), \n                        invalid_bin_priority)\n    \n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    \n    Combines the First-Fit decreasing heuristic with a tie-breaker based on bin index.\n    \"\"\"\n    # Calculate priority scores based on remaining capacity\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a small random noise to break ties\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    return priority_scores\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                random_noise_upper_bound: float = 0.000512910372337147, \n                invalid_bin_priority: float = -3582939133.573016) -> np.ndarray:\n    \"\"\"\n    Priority score for each bin by considering remaining capacity and bin index, with random tie-breaking.\n    \"\"\"\n    # Calculate the number of available bins\n    num_bins = len(bins_remain_cap)\n    \n    # Prioritize bins with enough capacity, considering remaining capacity and bin index\n    priority = np.where(bins_remain_cap >= item, \n                        -(bins_remain_cap - item) + np.log(num_bins / (1 + np.arange(num_bins))) + np.random.uniform(0, random_noise_upper_bound, size=num_bins), \n                        invalid_bin_priority)\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    \n    Combines the First-Fit decreasing heuristic with a tie-breaker based on bin index.\n    \"\"\"\n    # Calculate priority scores based on remaining capacity\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a small random noise to break ties\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    return priority_scores\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                random_noise_upper_bound: float = 0.000512910372337147, \n                invalid_bin_priority: float = -3582939133.573016) -> np.ndarray:\n    \"\"\"\n    Priority score for each bin by considering remaining capacity and bin index, with random tie-breaking.\n    \"\"\"\n    # Calculate the number of available bins\n    num_bins = len(bins_remain_cap)\n    \n    # Prioritize bins with enough capacity, considering remaining capacity and bin index\n    priority = np.where(bins_remain_cap >= item, \n                        -(bins_remain_cap - item) + np.log(num_bins / (1 + np.arange(num_bins))) + np.random.uniform(0, random_noise_upper_bound, size=num_bins), \n                        invalid_bin_priority)\n    \n    return priority\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins with just enough capacity and breaks ties with a combination of random noise and bin index.\n    \"\"\"\n    # Check if the item can fit into the bin and prioritize bins with less remaining capacity after addition\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    priority = valid_bins * (-(bins_remain_cap - item))  # Prioritize bins that are just enough for the item\n    \n    # Add a small factor considering the bin index (older bins are prioritized) and random noise to break ties\n    num_bins = len(bins_remain_cap)\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) + np.random.rand(*priority.shape) * 1e-6)\n    \n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}