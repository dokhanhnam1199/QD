{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 6.092855021862127e-07, tie_breaker_coef: float = 0.054746423211797395) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and remaining capacity for prioritization with a simple tie-breaker.\n    \"\"\"\n    # Calculate utilization factor, avoiding division by zero\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Priority score for bins that can fit the item, using a combination of utilization and remaining capacity\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor), -np.inf)\n    \n    # Add a tie-breaker based on bin index with a small coefficient\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 6.092855021862127e-07, tie_breaker_coef: float = 0.054746423211797395) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and remaining capacity for prioritization with a simple tie-breaker.\n    \"\"\"\n    # Calculate utilization factor, avoiding division by zero\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Priority score for bins that can fit the item, using a combination of utilization and remaining capacity\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor), -np.inf)\n    \n    # Add a tie-breaker based on bin index with a small coefficient\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    return priority\n\n[Heuristics 3rd]\nimport numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for the tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and fit score for prioritization with an enhanced tie-breaker.\n    \"\"\"\n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    fit_score = 1 - (item / np.maximum(bins_remain_cap, epsilon))\n    \n    # Priority score for bins that can fit the item, using a combination of utilization and fit score\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) - fit_score * 0.1, -np.inf)\n    \n    # Enhanced tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for the tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and fit score for prioritization with an enhanced tie-breaker.\n    \"\"\"\n    # Calculate utilization factor and fit score\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    fit_score = 1 - (item / np.maximum(bins_remain_cap, epsilon))\n    \n    # Priority score for bins that can fit the item, using a combination of utilization and fit score\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor) - fit_score * 0.1, -np.inf)\n    \n    # Enhanced tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    return priority\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit score, remaining capacity, and a tie-breaker for online Bin Packing Problem.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Fit score: prioritize bins where the item fits well\n    fit_score = np.where(bins_remain_cap >= item, -(np.abs(remaining_cap_after_addition)), -np.inf)\n    \n    # Secondary prioritization based on remaining capacity\n    secondary_priority = np.where(bins_remain_cap >= item, -bins_remain_cap / np.max(bins_remain_cap), 0)\n    \n    # Tie-breaker based on bin index\n    tie_breaker = np.log(len(bins_remain_cap) / (1 + np.arange(len(bins_remain_cap)))) * 1e-3\n    \n    # Combine fit score, secondary priority, and tie-breaker\n    priority_scores = fit_score + secondary_priority + tie_breaker\n    \n    return priority_scores\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit score and a tie-breaker based on bin index for online Bin Packing Problem.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Fit score: prioritize bins where the item fits well\n    fit_score = np.where(bins_remain_cap >= item, -(np.abs(remaining_cap_after_addition)), -np.inf)\n    \n    # Tie-breaker based on bin index with a small coefficient\n    tie_breaker = np.log(len(bins_remain_cap) / (1 + np.arange(len(bins_remain_cap)))) * 1e-3\n    \n    # Add a small random noise for further tie-breaking\n    random_noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    # Combine fit score, tie-breaker, and random noise\n    priority_scores = fit_score + tie_breaker + random_noise\n    \n    return priority_scores\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit score, remaining capacity, and a tie-breaker for online Bin Packing Problem.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Fit score: prioritize bins where the item fits well\n    fit_score = np.where(bins_remain_cap >= item, -(np.abs(remaining_cap_after_addition)), -np.inf)\n    \n    # Secondary prioritization based on remaining capacity\n    secondary_priority = np.where(bins_remain_cap >= item, -bins_remain_cap / np.max(bins_remain_cap), 0)\n    \n    # Tie-breaker based on bin index\n    tie_breaker = np.log(len(bins_remain_cap) / (1 + np.arange(len(bins_remain_cap)))) * 1e-3\n    \n    # Combine fit score, secondary priority, and tie-breaker\n    priority_scores = fit_score + secondary_priority + tie_breaker\n    \n    return priority_scores\n\n[Heuristics 8th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                tie_breaker_coef: float = 0.07531178921019346) -> np.ndarray:\n    \"\"\"\n    Combines refined utilization factor and remaining capacity with a simple tie-breaker for online Bin Packing Problem.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate remaining capacity and utilization after adding the item\n    remaining_after_addition = bins_remain_cap[valid_bins] - item\n    utilization_factor = np.exp(-((bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]) ** 2)\n    \n    # Priority score combines utilization factor and negative remaining capacity\n    priority_scores_valid = -remaining_after_addition + utilization_factor\n    \n    # Create array to store priority scores for all bins\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priority_scores[valid_bins] = priority_scores_valid\n    \n    # Add a simple tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef, \n                               -np.inf)\n    \n    return priority_scores\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit score and a tie-breaker based on bin index for online Bin Packing Problem.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Fit score: prioritize bins where the item fits well\n    fit_score = np.where(bins_remain_cap >= item, -(np.abs(remaining_cap_after_addition)), -np.inf)\n    \n    # Tie-breaker based on bin index with a small coefficient\n    tie_breaker = np.log(len(bins_remain_cap) / (1 + np.arange(len(bins_remain_cap)))) * 1e-3\n    \n    # Add a small random noise for further tie-breaking\n    random_noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    # Combine fit score, tie-breaker, and random noise\n    priority_scores = fit_score + tie_breaker + random_noise\n    \n    return priority_scores\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization, remaining capacity, and bin index for effective bin selection.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate remaining capacity and utilization after adding the item\n    remaining_after_addition = bins_remain_cap[valid_bins] - item\n    utilization_after_addition = 1.0 - remaining_after_addition / bins_remain_cap[valid_bins]\n    \n    # Priority score combines negative remaining capacity and utilization\n    priority_scores_valid = -np.abs(remaining_after_addition / bins_remain_cap[valid_bins] - 0.5) + utilization_after_addition\n    \n    # Create array to store priority scores for all bins\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priority_scores[valid_bins] = priority_scores_valid\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker_coef = 1e-3\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef, \n                               -np.inf)\n    \n    # Introduce a small adjustment based on remaining capacity\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + bins_remain_cap / np.max(bins_remain_cap) * tie_breaker_coef * 0.1, \n                               -np.inf)\n    \n    return priority_scores\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization, remaining capacity, and bin index for effective bin selection.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate remaining capacity and utilization after adding the item\n    remaining_after_addition = bins_remain_cap[valid_bins] - item\n    utilization_after_addition = 1.0 - remaining_after_addition / bins_remain_cap[valid_bins]\n    \n    # Priority score combines negative remaining capacity and utilization\n    priority_scores_valid = -np.abs(remaining_after_addition / bins_remain_cap[valid_bins] - 0.5) + utilization_after_addition\n    \n    # Create array to store priority scores for all bins\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priority_scores[valid_bins] = priority_scores_valid\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    tie_breaker_coef = 1e-3\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef, \n                               -np.inf)\n    \n    # Introduce a small adjustment based on remaining capacity\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + bins_remain_cap / np.max(bins_remain_cap) * tie_breaker_coef * 0.1, \n                               -np.inf)\n    \n    return priority_scores\n\n[Heuristics 12th]\nimport numpy as np\n\nepsilon = 1e-6  # A small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for the tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    An advanced priority function that combines multiple factors for effective bin selection in online Bin Packing Problem.\n    \n    It considers the remaining capacity, utilization factor, and a dynamic tie-breaker based on bin index and randomness.\n    \"\"\"\n    # Calculate utilization factor, focusing on how much the bin will be utilized if the item is placed in it\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # First component of priority: Bins that can fit the item get a score based on their utilization factor\n    priority = np.where(bins_remain_cap >= item, -utilization_factor, -np.inf)\n    \n    # Second component: Add a tie-breaker that combines bin index (to avoid always filling the first bins) and randomness (for exploration)\n    num_bins = len(bins_remain_cap)\n    tie_breaker = np.log(num_bins / (1 + np.arange(num_bins))) + np.random.uniform(0, tie_breaker_coef, size=num_bins)\n    priority += (bins_remain_cap >= item) * tie_breaker\n    \n    # Normalize the priority scores to ensure they are on the same scale and to enhance numerical stability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  # Check if there are bins that can fit the item\n        priority = np.where(priority != -np.inf, priority - max_priority, -np.inf)\n    \n    return priority\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Heuristic combining refined utilization factor and bin index tie-breaker.\n    \"\"\"\n    epsilon = 1e-6  # Avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Refined utilization factor\n    utilization_factor = np.exp(-((bins_remain_cap - item) / (item + epsilon)) ** 2)\n    utilization_score = bins_remain_cap / (item + epsilon)  # Additional utilization score\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, utilization_factor * utilization_score, -np.inf)\n    \n    # Incorporate a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef\n    \n    # Normalize priority scores\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  \n        priority = np.where(priority != -np.inf, priority - max_priority, -np.inf)\n    \n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Improved priority function that combines multiple factors for effective bin selection.\n    \"\"\"\n    # Calculate the fraction of remaining capacity after placing the item\n    post_utilization = (bins_remain_cap - item) / (bins_remain_cap + epsilon)\n    \n    # Priority score is a combination of the post-utilization factor and the remaining capacity\n    # for bins that can fit the item, with a penalty for bins that are too full or too empty\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(post_utilization - 0.5) + 0.5 - (bins_remain_cap - item) / (1 + bins_remain_cap.max()), \n                        -np.inf)\n    \n    # Introduce a randomness component with a decaying coefficient based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.random.rand(num_bins) * tie_breaker_coef / (1 + np.arange(num_bins)))\n    \n    return priority\n\n[Heuristics 15th]\nimport numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Improved priority function that combines multiple factors for effective bin selection.\n    \"\"\"\n    # Calculate the fraction of remaining capacity after placing the item\n    post_utilization = (bins_remain_cap - item) / (bins_remain_cap + epsilon)\n    \n    # Priority score is a combination of the post-utilization factor and the remaining capacity\n    # for bins that can fit the item, with a penalty for bins that are too full or too empty\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(post_utilization - 0.5) + 0.5 - (bins_remain_cap - item) / (1 + bins_remain_cap.max()), \n                        -np.inf)\n    \n    # Introduce a randomness component with a decaying coefficient based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.random.rand(num_bins) * tie_breaker_coef / (1 + np.arange(num_bins)))\n    \n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Improved priority function that combines multiple factors for effective bin selection.\n    \"\"\"\n    # Calculate the fraction of remaining capacity after placing the item\n    post_utilization = (bins_remain_cap - item) / (bins_remain_cap + epsilon)\n    \n    # Priority score is a combination of the post-utilization factor and the remaining capacity\n    # for bins that can fit the item, with a penalty for bins that are too full or too empty\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(post_utilization - 0.5) + 0.5 - (bins_remain_cap - item) / (1 + bins_remain_cap.max()), \n                        -np.inf)\n    \n    # Introduce a randomness component with a decaying coefficient based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.random.rand(num_bins) * tie_breaker_coef / (1 + np.arange(num_bins)))\n    \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, remaining capacity, and bin index for prioritization.\n    \"\"\"\n    # Calculate utilization factor after adding the item\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, 1e-8)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, -(np.abs(utilization_factor - 0.5) + 0.1 * (1 - bins_remain_cap / np.max(bins_remain_cap))), -np.inf)\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * np.log(num_bins / (1 + np.arange(num_bins))) * 1e-6\n    \n    # Introduce a small random noise for further tie-breaking\n    np.random.seed(int(item * 1e6))  \n    priority += (bins_remain_cap >= item) * np.random.uniform(-1e-8, 1e-8, size=num_bins)\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function combining multiple factors for effective bin selection in online Bin Packing Problem.\n    \"\"\"\n    # Mask for bins that can fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate the 'First-Fit Decreasing Height' inspired score, normalized by bin capacity\n    ff_score = (bins_remain_cap - item) / (bins_remain_cap.max() + epsilon)\n    \n    # Utilization factor, avoiding division by zero\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Combine utilization factor and a 'best-fit' criterion for prioritization\n    priority = np.where(valid_bins, -np.abs(utilization_factor) + ff_score, -np.inf)\n    \n    # Introduce a randomness component with a decaying factor based on bin index for tie-breaking\n    num_bins = len(bins_remain_cap)\n    randomness_component = valid_bins * (np.random.rand(num_bins) * np.exp(-np.arange(num_bins) / num_bins))\n    \n    # Add tie-breaker components\n    priority += tie_breaker_coef * (valid_bins * (np.log(num_bins / (1 + np.arange(num_bins)))) + randomness_component)\n    \n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and fit score with a tie-breaker for effective prioritization.\n    \"\"\"\n    # Constants\n    epsilon = 1e-6  # Avoid division by zero\n    tie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n    \n    # Calculate utilization factor and fit score\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, \n                        # Combine utilization factor and fit score\n                        0.5 * utilization_factor + 0.5 * fit_score, \n                        -np.inf)\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    return priority\n\n[Heuristics 20th]\nimport numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for the tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function that combines remaining capacity, utilization factor, \n    and a sophisticated tie-breaker for online Bin Packing Problem.\n    \"\"\"\n    # Calculate utilization factor, ensuring no division by zero\n    utilization_factor = 1 - (item / np.maximum(bins_remain_cap, epsilon))\n    \n    # Priority score for bins that can fit the item, using a combination of utilization and remaining capacity\n    priority = np.where(bins_remain_cap >= item, utilization_factor, -np.inf)\n    \n    # Enhanced tie-breaker: combines bin index and remaining capacity for more nuanced decision-making\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + \n                                               (bins_remain_cap / (1 + np.arange(num_bins)) * tie_breaker_coef * 1e-2))\n    \n    # Final priority score with the enhanced tie-breaker\n    priority += tie_breaker\n    \n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}