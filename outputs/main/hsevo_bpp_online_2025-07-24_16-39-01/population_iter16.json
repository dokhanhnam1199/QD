[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and remaining capacity with a simple tie-breaker and logarithmic bin index.\n    \"\"\"\n    # Calculate utilization factor\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, 1e-9)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor), -np.inf)\n    \n    # Add a tie-breaker based on bin index with a small coefficient\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3 + np.random.uniform(0, 1e-6, size=num_bins))\n    \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 169.6436125266828,
    "mi": 92.04553747407395,
    "token_count": 115.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines prioritizing bins with just enough capacity, utilization factor, and a robust tie-breaking strategy.\n    \"\"\"\n    # Prioritize bins that have just enough capacity for the item and consider utilization factor\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item) + 0.1 * (item / bins_remain_cap), -np.inf)\n    \n    # Add a robust tie-breaker based on bin index and a small random noise\n    num_bins = len(bins_remain_cap)\n    priority_scores += np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3 + np.random.rand(*priority_scores.shape) * 1e-6\n    \n    return priority_scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 169.6436125266828,
    "mi": 92.04553747407395,
    "token_count": 115.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, remaining capacity, and a simple tie-breaker for prioritization.\n    \"\"\"\n    # Calculate utilization factor after adding the item, avoiding division by zero\n    utilization_factor = (1 - (bins_remain_cap - item))  # Assuming bin capacity is 1.0\n    \n    # Priority score for bins that can fit the item\n    valid_bins = bins_remain_cap >= item\n    priority = np.where(valid_bins, -np.abs(bins_remain_cap - item) + utilization_factor, -np.inf)\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += valid_bins * (np.log(num_bins / (1 + np.arange(num_bins))) * 0.01)  # Using a small coefficient for tie-breaker\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 169.6436125266828,
    "mi": 92.04553747407395,
    "token_count": 115.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, remaining capacity, and a tie-breaker for effective bin prioritization.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate the priority score for valid bins\n    num_bins = len(bins_remain_cap)\n    # Combine negative remaining capacity after addition, utilization factor, and a tie-breaker\n    priority_scores = np.where(valid_bins, \n                                -(bins_remain_cap - item) +  # Prioritize bins with just enough capacity\n                                (item / bins_remain_cap) +  # Utilization factor\n                                np.log(num_bins / (1 + np.arange(num_bins))) * 1e-3 +  # Tie-breaker based on bin index\n                                np.random.uniform(0, 1e-6, size=num_bins),  # Random noise for tie-breaking\n                                -np.inf)  # Negative infinity for bins that cannot fit the item\n    \n    return priority_scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 169.6436125266828,
    "mi": 92.04553747407395,
    "token_count": 115.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines remaining capacity, utilization, and a simple tie-breaker based on bin index.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap[valid_bins] - item\n    \n    # Calculate utilization after adding the item\n    bin_utilization_after_addition = 1.0 - remaining_after_addition\n    \n    # Priority score combines negative remaining capacity and utilization\n    priority_scores_valid = -remaining_after_addition + bin_utilization_after_addition\n    \n    # Create array to store priority scores for all bins\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priority_scores[valid_bins] = priority_scores_valid\n    \n    # Add a simple tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    return priority_scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 169.6436125266828,
    "mi": 92.04553747407395,
    "token_count": 115.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor, remaining capacity, and a tie-breaker for effective prioritization.\n    \"\"\"\n    # Calculate utilization factor, avoiding division by zero\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, 1e-6)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, \n                        -np.abs(utilization_factor) +  # prioritize bins with just enough capacity\n                        0.01 * bins_remain_cap,  # slightly prioritize bins with more remaining capacity\n                        -np.inf)\n    \n    # Add a tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * 0.001)\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 86.5775827682489,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 169.6436125266828,
    "mi": 92.04553747407395,
    "token_count": 115.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to bins, combining remaining capacity and a tie-breaker.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Priority score: bins with just enough capacity are prioritized\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(np.abs(remaining_cap_after_addition)) +  # prioritize bins with just enough capacity\n                               np.log(len(bins_remain_cap) / (1 + np.arange(len(bins_remain_cap)))),  # tie-breaker\n                               -np.inf)  # bins that can't fit the item get -inf priority\n    \n    return priority_scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 169.6436125266828,
    "mi": 92.04553747407395,
    "token_count": 115.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to bins, combining remaining capacity, \n    utilization factor, and a simple tie-breaker based on bin index.\n    \"\"\"\n    # Filter out bins that cannot fit the item and calculate remaining capacity after addition\n    valid_bins = bins_remain_cap >= item\n    remaining_after_addition = bins_remain_cap[valid_bins] - item\n    \n    # Calculate utilization after adding the item\n    bin_utilization_after_addition = 1.0 - remaining_after_addition\n    \n    # Priority score combines negative remaining capacity and bin utilization after addition\n    priority_scores_valid = -remaining_after_addition + bin_utilization_after_addition\n    \n    # Create an array to store the priority scores for all bins\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priority_scores[valid_bins] = priority_scores_valid\n    \n    # Add a simple tie-breaker based on bin index to favor earlier bins\n    num_bins = len(bins_remain_cap)\n    priority_scores = np.where(priority_scores != -np.inf, \n                               priority_scores + np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    return priority_scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 169.6436125266828,
    "mi": 92.04553747407395,
    "token_count": 115.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines remaining capacity and 'fullness' with a simple yet effective tie-breaker.\n\n    Prioritizes bins that fit the item, are relatively empty, and have a lower index.\n    \"\"\"\n    # Calculate priority score for bins that can fit the item\n    max_capacity = np.max(bins_remain_cap) + item  # assuming all bins have the same max capacity\n    priority = np.where(bins_remain_cap >= item, \n                        -(bins_remain_cap - item) + 0.1 * (max_capacity - bins_remain_cap), \n                        -np.inf)  # prioritize bins that are relatively empty\n    \n    # Add a simple tie-breaker based on bin index\n    num_bins = len(bins_remain_cap)\n    priority = np.where(priority != -np.inf, priority + np.log(num_bins / (1 + np.arange(num_bins))), -np.inf)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.078579976067022,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 169.6436125266828,
    "mi": 92.04553747407395,
    "token_count": 115.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and remaining capacity with a tie-breaker for prioritization.\n    \"\"\"\n    # Calculate utilization factor with a regularization to avoid division by zero\n    max_remain_cap = np.max(bins_remain_cap)\n    utilization_factor = 1 - bins_remain_cap / max_remain_cap\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, -(bins_remain_cap - item) + utilization_factor, -np.inf)\n    \n    # Add a tie-breaker based on bin index to resolve ties\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * 1e-6)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 169.6436125266828,
    "mi": 92.04553747407395,
    "token_count": 115.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced prioritization function combining multiple factors for online Bin Packing Problem.\n    \"\"\"\n    # Calculate the utilization factor after placing the item, ensuring no division by zero\n    post_utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, epsilon)\n    \n    # Calculate the relative remaining capacity after placing the item\n    relative_remain_cap = bins_remain_cap - item\n    \n    # Priority score for bins that can fit the item, combining post-utilization factor and relative remaining capacity\n    priority = np.where(bins_remain_cap >= item, -np.abs(post_utilization_factor) + relative_remain_cap / (item + epsilon), -np.inf)\n    \n    # Introduce a tie-breaker based on bin index to favor bins that are filled more evenly and are earlier in the list\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins)))) * tie_breaker_coef + (1 - (bins_remain_cap / (item + epsilon))) * tie_breaker_coef)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 149.2919824491424,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 255.15831097164298,
    "mi": 80.70574456277627,
    "token_count": 181.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response1.txt_stdout.txt",
    "code_path": "problem_iter15_code1.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced prioritization function that combines multiple factors for online Bin Packing Problem.\n    \n    This function calculates a priority score for each bin based on how well it can accommodate the item,\n    considering both the utilization factor and the remaining capacity. It also incorporates a tie-breaker\n    to differentiate between bins with similar characteristics.\n    \"\"\"\n    # Normalize the remaining capacity to emphasize bins that are closer to being full or empty\n    normalized_remain_cap = bins_remain_cap / (item + epsilon)\n    \n    # Calculate a utilization factor that rewards bins that are not too empty or too full\n    utilization_factor = np.exp(-((normalized_remain_cap - 1) ** 2) / 2)\n    \n    # Assign a high priority score to bins that can fit the item, weighted by their utilization factor\n    priority = np.where(bins_remain_cap >= item, utilization_factor, -np.inf)\n    \n    # Introduce a tie-breaker based on the bin's remaining capacity and its index\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (bins_remain_cap >= item) * ((np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + (bins_remain_cap / (item + epsilon)) * 1e-2)\n    \n    # Combine the priority score with the tie-breaker\n    priority += tie_breaker\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.068607897885915,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 255.15831097164298,
    "mi": 80.70574456277627,
    "token_count": 181.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response2.txt_stdout.txt",
    "code_path": "problem_iter15_code2.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # A small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for the tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    An advanced prioritization function that combines multiple factors for online Bin Packing Problem.\n    \n    It considers not just the utilization factor and remaining capacity but also the relative size of the item to the bin capacity.\n    \"\"\"\n    # Calculate the relative size of the item to the bin's remaining capacity\n    relative_size = item / np.maximum(bins_remain_cap, epsilon)\n    \n    # Calculate a 'fit score' that rewards bins where the item fits well (i.e., fills a significant portion of the bin)\n    fit_score = np.where(bins_remain_cap >= item, 1 - relative_size, 0)\n    \n    # Priority score is a combination of the fit score and a penalty for bins that are too full or too empty\n    priority = np.where(bins_remain_cap >= item, fit_score + np.log(bins_remain_cap + epsilon) * 0.1, -np.inf)\n    \n    # Add a tie-breaker based on the bin index to ensure a consistent ordering when priorities are equal\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 149.2919824491424,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 255.15831097164298,
    "mi": 80.70574456277627,
    "token_count": 181.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response3.txt_stdout.txt",
    "code_path": "problem_iter15_code3.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for the tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced prioritization function that considers both the fit of the item to the bin and the bin's remaining capacity,\n    with a sophisticated tie-breaking mechanism based on both bin index and remaining capacity.\n    \"\"\"\n    # Calculate a score that reflects how well the item fits into the bin, avoiding division by zero\n    fit_score = 1 - (item / np.maximum(bins_remain_cap, epsilon))\n    \n    # Calculate a normalized remaining capacity score to encourage packing items tightly\n    remain_cap_score = bins_remain_cap / (item + epsilon)\n    \n    # Priority score for bins that can fit the item, combining fit score and remaining capacity score\n    priority = np.where(bins_remain_cap >= item, -fit_score + remain_cap_score * 0.1, -np.inf)\n    \n    # Enhanced tie-breaking based on both bin index and remaining capacity to diversify bin selection\n    num_bins = len(bins_remain_cap)\n    tie_breaker = (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef) + (bins_remain_cap / np.max(bins_remain_cap) * tie_breaker_coef * 0.1)\n    priority += (bins_remain_cap >= item) * tie_breaker\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.287993617869964,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 255.15831097164298,
    "mi": 80.70574456277627,
    "token_count": 181.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response4.txt_stdout.txt",
    "code_path": "problem_iter15_code4.py",
    "code": "import numpy as np\n\nepsilon = 1e-6  # Small value to avoid division by zero\ntie_breaker_coef = 1e-3  # Coefficient for tie-breaker\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced prioritization function combining multiple factors for online Bin Packing Problem.\n    \n    This function calculates a priority score for each bin based on how well it can accommodate the item,\n    considering both the bin's remaining capacity and its relative utilization. It also incorporates a \n    tie-breaker based on bin index to favor newer bins.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity\n    # Lower difference indicates a better fit\n    fit_score = np.abs(bins_remain_cap - item)\n    \n    # Calculate a utilization score; bins with lower remaining capacity (higher utilization) are preferred\n    utilization_score = bins_remain_cap\n    \n    # Priority score for bins that can fit the item, using a combination of fit score and utilization score\n    priority = np.where(bins_remain_cap >= item, -(fit_score / np.maximum(bins_remain_cap, epsilon)) + utilization_score / np.maximum(bins_remain_cap, epsilon), -np.inf)\n    \n    # Incorporate a tie-breaker based on bin index to favor bins with lower indices (older bins)\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef)\n    \n    # Normalize the priority scores to ensure they are on a comparable scale\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  # Check if there are any bins that can fit the item\n        priority = np.where(priority != -np.inf, priority - max_priority, -np.inf)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 255.15831097164298,
    "mi": 80.70574456277627,
    "token_count": 181.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response0.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, eps: float = 8.556427755033233e-07, tie_breaker_coef: float = 0.005674043456174885, random_noise_max: float = 0.000515987924623494) -> np.ndarray:\n    \"\"\"\n    Combines utilization factor and remaining capacity with a simple tie-breaker and logarithmic bin index.\n    \"\"\"\n    # Calculate utilization factor\n    utilization_factor = (bins_remain_cap - item) / np.maximum(bins_remain_cap, eps)\n    \n    # Priority score for bins that can fit the item\n    priority = np.where(bins_remain_cap >= item, -np.abs(utilization_factor), -np.inf)\n    \n    # Add a tie-breaker based on bin index with a small coefficient\n    num_bins = len(bins_remain_cap)\n    priority += (bins_remain_cap >= item) * (np.log(num_bins / (1 + np.arange(num_bins))) * tie_breaker_coef + np.random.uniform(0, random_noise_max, size=num_bins))\n    \n    return priority",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 155.88872502451935,
    "mi": 91.71875308527649,
    "token_count": 147.0,
    "exec_success": true
  }
]