{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins with just enough capacity for the item and breaks ties with random noise.\n    \"\"\"\n    # Check if the item can fit into the bin and prioritize bins with less remaining capacity after addition\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    priority = valid_bins * (-(bins_remain_cap - item))  # Prioritize bins that are just enough for the item\n    \n    # Add a small random noise to break ties\n    priority += np.random.rand(*priority.shape) * 1e-6\n    \n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a dynamic prioritization strategy that considers both the remaining capacity and the 'fullness' of the bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item and are relatively full\n    # So, we use a combination of the negative of the remaining capacity after adding the item and the current fullness of the bin\n    # If the item doesn't fit, the priority score is negative infinity\n    max_capacity = np.max(bins_remain_cap) + item  # assuming all bins have the same max capacity\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + (max_capacity - bins_remain_cap - item) / max_capacity, \n                               -np.inf)\n    \n    # Normalize the scores to avoid extreme values\n    finite_scores = priority_scores[np.isfinite(priority_scores)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            priority_scores[np.isfinite(priority_scores)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority_scores\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a dynamic prioritization strategy that considers both \n    the remaining capacity of the bin and the number of bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # and also consider the number of bins\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) / (bins_remain_cap + 1e-6), \n                               -np.inf)\n    \n    # Add a small bonus to the priority score for bins with smaller remaining capacity\n    # to encourage packing items tightly\n    priority_scores = np.where(bins_remain_cap >= item, \n                               priority_scores + 1 / (bins_remain_cap + 1e-6), \n                               priority_scores)\n    \n    return priority_scores\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements the First-Fit decreasing heuristic with a twist.\n    It prioritizes bins that have just enough capacity for the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # So, we use the negative of the remaining capacity after adding the item\n    # If the item doesn't fit, the priority score is negative infinity\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # To avoid division by zero and make the score more meaningful, we can add a small value to the denominator\n    # However, in this case, it's not necessary because we're not using the remaining capacity as a denominator\n    \n    return priority_scores\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins with just enough capacity for the item and breaks ties with random noise.\n    \"\"\"\n    # Check if the item can fit into the bin and prioritize bins with less remaining capacity after addition\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    priority = valid_bins * (-(bins_remain_cap - item))  # Prioritize bins that are just enough for the item\n    \n    # Add a small random noise to break ties\n    priority += np.random.rand(*priority.shape) * 1e-6\n    \n    return priority\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a dynamic prioritization strategy that considers both \n    the remaining capacity of the bin and the number of bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # and also consider the number of bins\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) / (bins_remain_cap + 1e-6), \n                               -np.inf)\n    \n    # Add a small bonus to the priority score for bins with smaller remaining capacity\n    # to encourage packing items tightly\n    priority_scores = np.where(bins_remain_cap >= item, \n                               priority_scores + 1 / (bins_remain_cap + 1e-6), \n                               priority_scores)\n    \n    return priority_scores\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to bins based on remaining capacity.\n\n    Prioritizes bins that fit the item tightly, with a small random noise to break ties.\n    \"\"\"\n    # Calculate priority scores: negative remaining capacity after adding the item\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a small random noise to break ties\n    noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    priority_scores = np.where(np.isfinite(priority_scores), priority_scores + noise, priority_scores)\n    \n    return priority_scores\n\n[Heuristics 8th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                random_noise_upper_bound: float = 0.000512910372337147, \n                invalid_bin_priority: float = -3582939133.573016) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by prioritizing bins with just enough capacity for the item and breaking ties randomly.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        random_noise_upper_bound: Upper bound for random noise added to break ties.\n        invalid_bin_priority: Priority for bins that are too small for the item.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Prioritize bins with less remaining capacity after addition and break ties randomly\n    priority = np.where(remaining_capacity_after_addition >= 0, \n                        -remaining_capacity_after_addition + np.random.uniform(0, random_noise_upper_bound, size=len(bins_remain_cap)), \n                        invalid_bin_priority)\n    \n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a dynamic prioritization strategy that considers both the remaining capacity and the 'fullness' of the bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item and are relatively full\n    # So, we use a combination of the negative of the remaining capacity after adding the item and the current fullness of the bin\n    # If the item doesn't fit, the priority score is negative infinity\n    max_capacity = np.max(bins_remain_cap) + item  # assuming all bins have the same max capacity\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + (max_capacity - bins_remain_cap - item) / max_capacity, \n                               -np.inf)\n    \n    # Normalize the scores to avoid extreme values\n    finite_scores = priority_scores[np.isfinite(priority_scores)]\n    if len(finite_scores) > 0:\n        min_score, max_score = np.min(finite_scores), np.max(finite_scores)\n        if max_score != min_score:\n            priority_scores[np.isfinite(priority_scores)] = (finite_scores - min_score) / (max_score - min_score)\n    \n    return priority_scores\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a dynamic prioritization strategy that considers both \n    the remaining capacity of the bin and the number of bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # and also consider the number of bins\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) / (bins_remain_cap + 1e-6), \n                               -np.inf)\n    \n    # Add a small bonus to the priority score for bins with smaller remaining capacity\n    # to encourage packing items tightly\n    priority_scores = np.where(bins_remain_cap >= item, \n                               priority_scores + 1 / (bins_remain_cap + 1e-6), \n                               priority_scores)\n    \n    return priority_scores\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a dynamic prioritization strategy that considers both \n    the remaining capacity of the bin and the number of bins available.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the number of available bins\n    num_bins = len(bins_remain_cap)\n    \n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # and also consider the number of available bins\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    # Normalize the priority scores to ensure they are within a comparable range\n    max_score = np.max(priority_scores)\n    if max_score != -np.inf:\n        priority_scores = np.where(priority_scores != -np.inf, priority_scores - max_score, -np.inf)\n    \n    return priority_scores\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a dynamic prioritization strategy that considers both \n    the remaining capacity of the bin and the number of bins available.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the number of available bins\n    num_bins = len(bins_remain_cap)\n    \n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # and also consider the number of available bins\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    # Normalize the priority scores to ensure they are within a comparable range\n    max_score = np.max(priority_scores)\n    if max_score != -np.inf:\n        priority_scores = np.where(priority_scores != -np.inf, priority_scores - max_score, -np.inf)\n    \n    return priority_scores\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a dynamic prioritization strategy that considers both \n    the remaining capacity of the bin and the number of bins available.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the number of available bins\n    num_bins = len(bins_remain_cap)\n    \n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # and also consider the number of available bins\n    priority_scores = np.where(bins_remain_cap >= item, \n                               -(bins_remain_cap - item) + np.log(num_bins / (1 + np.arange(num_bins))), \n                               -np.inf)\n    \n    # Normalize the priority scores to ensure they are within a comparable range\n    max_score = np.max(priority_scores)\n    if max_score != -np.inf:\n        priority_scores = np.where(priority_scores != -np.inf, priority_scores - max_score, -np.inf)\n    \n    return priority_scores\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    \n    Combines elements of First-Fit decreasing heuristic and score normalization.\n    Prioritizes bins with just enough capacity, adding noise to break ties.\n    \"\"\"\n    # Calculate priority scores for bins with enough capacity\n    mask = bins_remain_cap >= item\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n    priority_scores[mask] = -(bins_remain_cap[mask] - item) + np.random.uniform(0, 1e-6, size=np.sum(mask))  # Add small noise\n    \n    return priority_scores\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to bins.\n    Prioritizes bins with just enough capacity, using negative remaining capacity and adding noise to break ties.\n    \"\"\"\n    # Calculate priority scores for bins that can fit the item\n    mask = bins_remain_cap >= item\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n    # Use negative remaining capacity after addition and add a small random noise\n    priority_scores[mask] = -(bins_remain_cap[mask] - item) + np.random.uniform(0, 1e-6, size=np.sum(mask))\n    \n    return priority_scores\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    \n    Combines elements of First-Fit decreasing heuristic and score normalization.\n    Prioritizes bins with just enough capacity, adding noise to break ties.\n    \"\"\"\n    # Calculate priority scores for bins with enough capacity\n    mask = bins_remain_cap >= item\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n    priority_scores[mask] = -(bins_remain_cap[mask] - item) + np.random.uniform(0, 1e-6, size=np.sum(mask))  # Add small noise\n    \n    return priority_scores\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    \n    Prioritizes bins with just enough capacity, using negative remaining capacity after addition,\n    and adds a small noise to break ties.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    mask = bins_remain_cap >= item\n    \n    # Initialize priority scores with negative infinity for bins that are too small\n    priority = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For valid bins, calculate priority as negative remaining capacity after addition with a small noise\n    priority[mask] = -(bins_remain_cap[mask] - item) + np.random.uniform(0, 1e-6, np.sum(mask))\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    \n    Prioritizes bins with just enough capacity, using negative remaining capacity after addition,\n    and adds a small noise to break ties.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    mask = bins_remain_cap >= item\n    \n    # Initialize priority scores with negative infinity for bins that are too small\n    priority = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For valid bins, calculate priority as negative remaining capacity after addition with a small noise\n    priority[mask] = -(bins_remain_cap[mask] - item) + np.random.uniform(0, 1e-6, np.sum(mask))\n    \n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    \n    Prioritizes bins with just enough capacity, using negative remaining capacity after addition,\n    and adds a small noise to break ties.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    mask = bins_remain_cap >= item\n    \n    # Initialize priority scores with negative infinity for bins that are too small\n    priority = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For valid bins, calculate priority as negative remaining capacity after addition with a small noise\n    priority[mask] = -(bins_remain_cap[mask] - item) + np.random.uniform(0, 1e-6, np.sum(mask))\n    \n    return priority\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    \n    Prioritizes bins with just enough capacity, using negative remaining capacity after addition,\n    and adds a small noise to break ties.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    mask = bins_remain_cap >= item\n    \n    # Initialize priority scores with negative infinity for bins that are too small\n    priority = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For valid bins, calculate priority as negative remaining capacity after addition with a small noise\n    priority[mask] = -(bins_remain_cap[mask] - item) + np.random.uniform(0, 1e-6, np.sum(mask))\n    \n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}