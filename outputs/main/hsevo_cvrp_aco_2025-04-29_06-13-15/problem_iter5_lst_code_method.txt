{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1. Distance: Edges with shorter distances are preferred.\n    2. Demand Feasibility: Penalizes edges that would immediately violate capacity constraints if used early in a route.\n    3. Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4. Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will \"attract\" closer nodes to form clusters.\n    5. Savings Heuristic Integration: Incorporates the savings heuristic to encourage merging routes.\n    6. Sparsification: Sets unpromising edges to zero to focus the search.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # 4. Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0\n    for i in range(1, n):\n        for j in range(1, n):\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n\n    # 5. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n\n    # Combine the heuristics with adaptive weights.  Weights could be tuned by a metaheuristic\n    alpha = 0.4\n    beta = 0.2\n    gamma = 0.15\n    delta = 0.15\n    eta = 0.1\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * gravitational_heuristic + delta * savings_heuristic\n\n    # 6. Sparsification\n    # Only keep edges with a heuristic value above a certain threshold or that are among the k-nearest neighbors.\n\n    k_nearest = 10 #consider only k-nearest neighbors.\n    threshold = np.percentile(heuristics[heuristics > 0], 30)  # Dynamic threshold (e.g., 30th percentile)\n\n    for i in range(n):\n        # Find k-nearest neighbors\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] #excluding self loop and depot\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1. Distance: Edges with shorter distances are preferred.\n    2. Demand Feasibility: Penalizes edges that would immediately violate capacity constraints if used early in a route.\n    3. Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4. Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will \"attract\" closer nodes to form clusters.\n    5. Savings Heuristic Integration: Incorporates the savings heuristic to encourage merging routes.\n    6. Sparsification: Sets unpromising edges to zero to focus the search.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # 4. Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0\n    for i in range(1, n):\n        for j in range(1, n):\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n\n    # 5. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n\n    # Combine the heuristics with adaptive weights.  Weights could be tuned by a metaheuristic\n    alpha = 0.4\n    beta = 0.2\n    gamma = 0.15\n    delta = 0.15\n    eta = 0.1\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * gravitational_heuristic + delta * savings_heuristic\n\n    # 6. Sparsification\n    # Only keep edges with a heuristic value above a certain threshold or that are among the k-nearest neighbors.\n\n    k_nearest = 10 #consider only k-nearest neighbors.\n    threshold = np.percentile(heuristics[heuristics > 0], 30)  # Dynamic threshold (e.g., 30th percentile)\n\n    for i in range(n):\n        # Find k-nearest neighbors\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] #excluding self loop and depot\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1. Distance: Edges with shorter distances are preferred.\n    2. Demand Feasibility: Penalizes edges that would immediately violate capacity constraints.\n    3. Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4. Gravitational Attraction: Mimics the gravitational attraction of black holes.\n    5. Angle Prioritization:  Prioritizes edges that create smaller angles at intersections, promoting smoother routes.\n    6. Sparsification: Sets unpromising edges to zero to reduce search space.\n    7. Adaptive Scaling: Adaptively scales the influence of different heuristic components based on problem characteristics.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # Add a small value to avoid division by zero\n    epsilon = 1e-6\n\n    # 1. Distance component (inverse relationship)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # 2. Demand Feasibility component\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0  # No self-loops\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                 demand_heuristic[i,j] = 0.05\n\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # 4. Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0\n    for i in range(1, n):\n        for j in range(1, n):\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n\n\n    # 5. Angle Prioritization: Smaller angles are preferred (smoother routes).  Only calculate for non-depot nodes.\n    angle_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                #Find a k such that k is close to both i and j.\n                best_k = -1\n                min_dist = float('inf')\n                for k in range(1, n):\n                    if k != i and k != j:\n                        dist = distance_matrix[i, k] + distance_matrix[j, k]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_k = k\n                if best_k != -1:\n                    # cosine rule\n                    a = distance_matrix[i,j]\n                    b = distance_matrix[i, best_k]\n                    c = distance_matrix[j, best_k]\n                    angle = np.arccos((b**2 + c**2 - a**2) / (2 * b * c + epsilon))\n                    angle_heuristic[i,j] = 1 - (angle / np.pi) #Smaller angle, bigger value\n\n    # 6. Sparsification: Remove edges that are too long relative to average distance. Adaptively determined.\n    avg_distance = np.sum(distance_matrix) / (n * (n - 1))\n    sparsification_threshold = 2.5 * avg_distance  # Tune this parameter.\n    sparsification_mask = distance_matrix <= sparsification_threshold\n\n    # Combine the heuristics with adaptive scaling.  Weights can be tuned.\n    alpha = 0.4  # Distance weight\n    beta = 0.2  # Demand weight\n    gamma = 0.15 # Depot weight\n    delta = 0.15 # Gravitational weight\n    theta = 0.1 # Angle weight\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * demand_heuristic + gamma * depot_heuristic + delta * gravitational_heuristic + theta * angle_heuristic\n\n    # Apply sparsification\n    heuristics = heuristics * sparsification_mask\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1. Distance: Edges with shorter distances are preferred.\n    2. Demand Feasibility: Penalizes edges that would immediately violate capacity constraints.\n    3. Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4. Gravitational Attraction: Mimics the gravitational attraction of black holes.\n    5. Angle Prioritization:  Prioritizes edges that create smaller angles at intersections, promoting smoother routes.\n    6. Sparsification: Sets unpromising edges to zero to reduce search space.\n    7. Adaptive Scaling: Adaptively scales the influence of different heuristic components based on problem characteristics.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # Add a small value to avoid division by zero\n    epsilon = 1e-6\n\n    # 1. Distance component (inverse relationship)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # 2. Demand Feasibility component\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0  # No self-loops\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                 demand_heuristic[i,j] = 0.05\n\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # 4. Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0\n    for i in range(1, n):\n        for j in range(1, n):\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n\n\n    # 5. Angle Prioritization: Smaller angles are preferred (smoother routes).  Only calculate for non-depot nodes.\n    angle_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                #Find a k such that k is close to both i and j.\n                best_k = -1\n                min_dist = float('inf')\n                for k in range(1, n):\n                    if k != i and k != j:\n                        dist = distance_matrix[i, k] + distance_matrix[j, k]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_k = k\n                if best_k != -1:\n                    # cosine rule\n                    a = distance_matrix[i,j]\n                    b = distance_matrix[i, best_k]\n                    c = distance_matrix[j, best_k]\n                    angle = np.arccos((b**2 + c**2 - a**2) / (2 * b * c + epsilon))\n                    angle_heuristic[i,j] = 1 - (angle / np.pi) #Smaller angle, bigger value\n\n    # 6. Sparsification: Remove edges that are too long relative to average distance. Adaptively determined.\n    avg_distance = np.sum(distance_matrix) / (n * (n - 1))\n    sparsification_threshold = 2.5 * avg_distance  # Tune this parameter.\n    sparsification_mask = distance_matrix <= sparsification_threshold\n\n    # Combine the heuristics with adaptive scaling.  Weights can be tuned.\n    alpha = 0.4  # Distance weight\n    beta = 0.2  # Demand weight\n    gamma = 0.15 # Depot weight\n    delta = 0.15 # Gravitational weight\n    theta = 0.1 # Angle weight\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * demand_heuristic + gamma * depot_heuristic + delta * gravitational_heuristic + theta * angle_heuristic\n\n    # Apply sparsification\n    heuristics = heuristics * sparsification_mask\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle to depot, and angle between nodes to create a heuristic.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    distance_weight = 1.0\n    demand_weight = 0.5\n    angle_weight = 0.3\n    capacity_penalty = 2.0\n\n    depot_x, depot_y = coordinates[0]\n    angles = np.zeros(n)\n\n    for i in range(1, n):\n        x, y = coordinates[i]\n        dx = x - depot_x\n        dy = y - depot_y\n        angles[i] = np.arctan2(dy, dx)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0\n                continue\n\n            distance_term = distance_weight / distance_matrix[i, j] if distance_matrix[i,j] > 0 else 0\n            demand_term = (1 - demand_weight * demands[j] / capacity)\n\n            if i == 0:\n              angle_term = 0\n            else:\n              vector_ij = coordinates[j] - coordinates[i]\n              vector_j0 = coordinates[0] - coordinates[j]\n              norm_ij = np.linalg.norm(vector_ij)\n              norm_j0 = np.linalg.norm(vector_j0)\n              if norm_ij > 0 and norm_j0 > 0:\n                dot_product = np.dot(vector_ij, vector_j0)\n                cosine_angle = dot_product / (norm_ij * norm_j0)\n                angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))\n                angle_term = (1 - angle_weight * angle / np.pi)\n              else:\n                angle_term = 0\n\n            if demands[j] > (capacity/2):\n               demand_term = demand_term / capacity_penalty\n\n            angle_diff = abs(angles[i]-angles[j])\n            angle_depot_term =  angle_diff/np.pi\n\n            heuristic_matrix[i, j] = distance_term * demand_term * angle_term + 0.1 * angle_depot_term # Combine factors, depot angle has lower weight\n\n    return heuristic_matrix\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle to depot, and angle between nodes to create a heuristic.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    distance_weight = 1.0\n    demand_weight = 0.5\n    angle_weight = 0.3\n    capacity_penalty = 2.0\n\n    depot_x, depot_y = coordinates[0]\n    angles = np.zeros(n)\n\n    for i in range(1, n):\n        x, y = coordinates[i]\n        dx = x - depot_x\n        dy = y - depot_y\n        angles[i] = np.arctan2(dy, dx)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0\n                continue\n\n            distance_term = distance_weight / distance_matrix[i, j] if distance_matrix[i,j] > 0 else 0\n            demand_term = (1 - demand_weight * demands[j] / capacity)\n\n            if i == 0:\n              angle_term = 0\n            else:\n              vector_ij = coordinates[j] - coordinates[i]\n              vector_j0 = coordinates[0] - coordinates[j]\n              norm_ij = np.linalg.norm(vector_ij)\n              norm_j0 = np.linalg.norm(vector_j0)\n              if norm_ij > 0 and norm_j0 > 0:\n                dot_product = np.dot(vector_ij, vector_j0)\n                cosine_angle = dot_product / (norm_ij * norm_j0)\n                angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))\n                angle_term = (1 - angle_weight * angle / np.pi)\n              else:\n                angle_term = 0\n\n            if demands[j] > (capacity/2):\n               demand_term = demand_term / capacity_penalty\n\n            angle_diff = abs(angles[i]-angles[j])\n            angle_depot_term =  angle_diff/np.pi\n\n            heuristic_matrix[i, j] = distance_term * demand_term * angle_term + 0.1 * angle_depot_term # Combine factors, depot angle has lower weight\n\n    return heuristic_matrix\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle to depot, and angle between nodes to create a heuristic.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    distance_weight = 1.0\n    demand_weight = 0.5\n    angle_weight = 0.3\n    capacity_penalty = 2.0\n\n    depot_x, depot_y = coordinates[0]\n    angles = np.zeros(n)\n\n    for i in range(1, n):\n        x, y = coordinates[i]\n        dx = x - depot_x\n        dy = y - depot_y\n        angles[i] = np.arctan2(dy, dx)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0\n                continue\n\n            distance_term = distance_weight / distance_matrix[i, j] if distance_matrix[i,j] > 0 else 0\n            demand_term = (1 - demand_weight * demands[j] / capacity)\n\n            if i == 0:\n              angle_term = 0\n            else:\n              vector_ij = coordinates[j] - coordinates[i]\n              vector_j0 = coordinates[0] - coordinates[j]\n              norm_ij = np.linalg.norm(vector_ij)\n              norm_j0 = np.linalg.norm(vector_j0)\n              if norm_ij > 0 and norm_j0 > 0:\n                dot_product = np.dot(vector_ij, vector_j0)\n                cosine_angle = dot_product / (norm_ij * norm_j0)\n                angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))\n                angle_term = (1 - angle_weight * angle / np.pi)\n              else:\n                angle_term = 0\n\n            if demands[j] > (capacity/2):\n               demand_term = demand_term / capacity_penalty\n\n            angle_diff = abs(angles[i]-angles[j])\n            angle_depot_term =  angle_diff/np.pi\n\n            heuristic_matrix[i, j] = distance_term * demand_term * angle_term + 0.1 * angle_depot_term # Combine factors, depot angle has lower weight\n\n    return heuristic_matrix\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1.  Distance: Edges with shorter distances are preferred.\n    2.  Demand Feasibility:  Penalizes edges that would immediately violate capacity constraints if used early in a route.\n    3.  Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4.  Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will \"attract\" closer nodes to form clusters.\n    5.  Savings Heuristic Component:  Estimates cost savings by merging routes.\n    6.  Sparsification: Setting unpromising edges to zero to reduce the search space and computational cost.\n    7.  Adaptive Weighting: Dynamically adjusts the weights of different heuristic components based on problem characteristics.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # Add a small value to avoid division by zero\n    epsilon = 1e-6\n\n    # 1. Distance component (inverse relationship)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # 2. Demand Feasibility component\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0  # No self-loops\n\n            # If using this edge would exceed vehicle capacity (assuming starting from depot), penalize\n            if demands[i] + demands[j] > capacity and i == 0: # starting node\n                demand_heuristic[i, j] = 0.1  # A small value but not zero so it is not totally ignored\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                 demand_heuristic[i,j] = 0.05\n\n\n    # 3. Depot Proximity (encourage returning to depot if far and demand is high)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):  # Exclude depot itself\n        # Calculate average distance from node i to all other nodes (excluding the depot)\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0] # If only one other point exist use the distance to depot.\n\n        # Encourage going back to the depot from this node IF it is far and demands are relatively high.\n        # Depot preference is weighted based on avg_distance and demand compared to capacity\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference #symmetry\n\n    # 4. Gravitational Attraction: Node `i` attracts closeby node `j`\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0  # Adjust to control attraction strength.\n    for i in range(1, n):  # Start from 1 to exclude the depot itself as a gravity center. Depot is served by the previous depot_heuristic.\n        for j in range(1, n): # Start from 1 to exclude the depot itself being attracted by the gravitational heuristic.\n\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon) # F = G*m1*m2/r^2\n\n    # 5. Savings Heuristic Component\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_heuristic[i, j] = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[j, i] = savings_heuristic[i, j]  # Symmetry\n\n    # Adaptive Weighting (Example: Adjust based on average demand relative to capacity)\n    avg_demand = np.mean(demands[1:])\n    demand_ratio = avg_demand / capacity\n\n    # Adjust weights based on demand ratio (example)\n    weight_distance = 0.4  # Base weight\n    weight_demand = 0.3\n    weight_depot = 0.1 + demand_ratio * 0.2  # Increase depot weight if demand is high\n    weight_gravitational = 0.1\n    weight_savings = 0.1 - demand_ratio * 0.05 #Decrease saving if demand is high\n\n    # Combine the heuristics with adaptive weights\n    heuristics = (weight_distance * distance_heuristic * demand_heuristic +\n                  weight_depot * depot_heuristic +\n                  weight_gravitational * gravitational_heuristic +\n                  weight_savings * savings_heuristic)\n\n    # 6. Sparsification (set unpromising edges to zero)\n    threshold = np.mean(heuristics) * 0.2  # Dynamic threshold based on mean\n    heuristics[heuristics < threshold] = 0\n\n    # Normalize to be between 0 and 1, can help stability of stochastic sampling methods\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for CVRP combining distance, demand, and angle; adds depot proximity.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n    normalized_demands = demands / np.max(demands)  # Scale to 0-1\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                distance_factor = 1 / distance_matrix[i, j]\n                demand_factor = 1 - normalized_demands[j]\n                if i == 0:\n                    demand_factor = 1.0\n\n                # Angle heuristic relative to the depot\n                depot_x, depot_y = coordinates[0]\n                i_x, i_y = coordinates[i]\n                j_x, j_y = coordinates[j]\n\n                vector_ij = np.array([j_x - i_x, j_y - i_y])\n                vector_di = np.array([i_x - depot_x, i_y - depot_y])\n\n                vector_ij = vector_ij / (np.linalg.norm(vector_ij) + 1e-9)\n                vector_di = vector_di / (np.linalg.norm(vector_di) + 1e-9)\n\n                dot_product = np.clip(np.dot(vector_ij, vector_di), -1.0, 1.0)\n                angle = np.arccos(dot_product)\n                angle_factor = 1 - (angle / np.pi)\n\n                # Depot proximity: encourage nodes close to depot\n                depot_distance_i = distance_matrix[0, i]\n                depot_distance_j = distance_matrix[0, j]\n                depot_proximity_factor = 1 / (depot_distance_i + depot_distance_j + 1e-9)\n\n                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor * depot_proximity_factor\n            else:\n                heuristic_matrix[i, j] = 0\n\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix /= max_heuristic\n    else:\n        heuristic_matrix = np.ones_like(heuristic_matrix) / n\n\n    return heuristic_matrix\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for CVRP combining distance, demand, and angle; adds depot proximity.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n    normalized_demands = demands / np.max(demands)  # Scale to 0-1\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                distance_factor = 1 / distance_matrix[i, j]\n                demand_factor = 1 - normalized_demands[j]\n                if i == 0:\n                    demand_factor = 1.0\n\n                # Angle heuristic relative to the depot\n                depot_x, depot_y = coordinates[0]\n                i_x, i_y = coordinates[i]\n                j_x, j_y = coordinates[j]\n\n                vector_ij = np.array([j_x - i_x, j_y - i_y])\n                vector_di = np.array([i_x - depot_x, i_y - depot_y])\n\n                vector_ij = vector_ij / (np.linalg.norm(vector_ij) + 1e-9)\n                vector_di = vector_di / (np.linalg.norm(vector_di) + 1e-9)\n\n                dot_product = np.clip(np.dot(vector_ij, vector_di), -1.0, 1.0)\n                angle = np.arccos(dot_product)\n                angle_factor = 1 - (angle / np.pi)\n\n                # Depot proximity: encourage nodes close to depot\n                depot_distance_i = distance_matrix[0, i]\n                depot_distance_j = distance_matrix[0, j]\n                depot_proximity_factor = 1 / (depot_distance_i + depot_distance_j + 1e-9)\n\n                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor * depot_proximity_factor\n            else:\n                heuristic_matrix[i, j] = 0\n\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix /= max_heuristic\n    else:\n        heuristic_matrix = np.ones_like(heuristic_matrix) / n\n\n    return heuristic_matrix\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for CVRP combining distance, demand, and angle; adds depot proximity.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n    normalized_demands = demands / np.max(demands)  # Scale to 0-1\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                distance_factor = 1 / distance_matrix[i, j]\n                demand_factor = 1 - normalized_demands[j]\n                if i == 0:\n                    demand_factor = 1.0\n\n                # Angle heuristic relative to the depot\n                depot_x, depot_y = coordinates[0]\n                i_x, i_y = coordinates[i]\n                j_x, j_y = coordinates[j]\n\n                vector_ij = np.array([j_x - i_x, j_y - i_y])\n                vector_di = np.array([i_x - depot_x, i_y - depot_y])\n\n                vector_ij = vector_ij / (np.linalg.norm(vector_ij) + 1e-9)\n                vector_di = vector_di / (np.linalg.norm(vector_di) + 1e-9)\n\n                dot_product = np.clip(np.dot(vector_ij, vector_di), -1.0, 1.0)\n                angle = np.arccos(dot_product)\n                angle_factor = 1 - (angle / np.pi)\n\n                # Depot proximity: encourage nodes close to depot\n                depot_distance_i = distance_matrix[0, i]\n                depot_distance_j = distance_matrix[0, j]\n                depot_proximity_factor = 1 / (depot_distance_i + depot_distance_j + 1e-9)\n\n                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor * depot_proximity_factor\n            else:\n                heuristic_matrix[i, j] = 0\n\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix /= max_heuristic\n    else:\n        heuristic_matrix = np.ones_like(heuristic_matrix) / n\n\n    return heuristic_matrix\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Combines distance, demand, and spatial clustering with adaptive scaling.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Avoid division by zero.\n    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)\n\n    # Define weights for combining heuristics\n    alpha = 0.4  # Importance of distance\n    beta = 0.35   # Importance of demand feasibility\n    gamma = 0.25  # Importance of cluster affinity\n\n    # Heuristic based on inverse distance\n    distance_heuristic = 1 / distance_matrix\n\n    # Heuristic based on demand feasibility\n    demand_heuristic = np.ones_like(distance_matrix, dtype=float)\n    for i in range(1, n):  # Skip depot\n        for j in range(1, n): # Skip depot\n            if i != j:\n                if demands[i] + demands[j] > capacity:\n                    demand_heuristic[i, j] = 0.1 # severely penalize\n                else:\n                     demand_heuristic[i, j] = 1 - (demands[i] + demands[j]) / (2*capacity)\n\n    # Heuristic based on spatial clustering\n    cluster_heuristic = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                 # Density based on inverse distance to other nodes\n                 density_i = np.sum(1 / distance_matrix[i, 1:]) - (1/ distance_matrix[i,i]) if np.sum(1 / distance_matrix[i, 1:]) < np.inf else 0 # Avoid division by zero\n                 density_j = np.sum(1 / distance_matrix[j, 1:]) - (1/ distance_matrix[j,j]) if np.sum(1 / distance_matrix[j, 1:]) < np.inf else 0 # Avoid division by zero\n                 # penalize connections to nodes with much lower density\n                 cluster_heuristic[i,j] = min(density_i, density_j) / max(density_i, density_j) if max(density_i, density_j) > 0 else 0 #Between 0 and 1\n                 \n    #Gravitational attraction to the depot\n    depot_attraction = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(1, n):\n        depot_attraction[0, i] = 1/(distance_matrix[0, i])\n        depot_attraction[i, 0] = 1/(distance_matrix[i, 0]) # Symmetric\n\n    # Combine heuristics with weights\n    heuristic_matrix = (alpha * distance_heuristic +\n                        beta * demand_heuristic +\n                        gamma * cluster_heuristic +\n                        0.1 * depot_attraction)\n\n    # Depot edges should be generally favored to return to depot\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 1.2  # Favor leaving the depot\n        heuristic_matrix[i, 0] *= 1.2  # Favor returning to the depot\n\n    # Normalize the heuristic matrix to [0, 1]\n    max_heuristic = np.max(heuristic_matrix)\n    min_heuristic = np.min(heuristic_matrix)\n    heuristic_matrix = (heuristic_matrix - min_heuristic) / (max_heuristic - min_heuristic) if max_heuristic > min_heuristic else np.zeros_like(heuristic_matrix)\n\n    return heuristic_matrix\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Combines distance, demand, and spatial clustering with adaptive scaling.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Avoid division by zero.\n    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)\n\n    # Define weights for combining heuristics\n    alpha = 0.4  # Importance of distance\n    beta = 0.35   # Importance of demand feasibility\n    gamma = 0.25  # Importance of cluster affinity\n\n    # Heuristic based on inverse distance\n    distance_heuristic = 1 / distance_matrix\n\n    # Heuristic based on demand feasibility\n    demand_heuristic = np.ones_like(distance_matrix, dtype=float)\n    for i in range(1, n):  # Skip depot\n        for j in range(1, n): # Skip depot\n            if i != j:\n                if demands[i] + demands[j] > capacity:\n                    demand_heuristic[i, j] = 0.1 # severely penalize\n                else:\n                     demand_heuristic[i, j] = 1 - (demands[i] + demands[j]) / (2*capacity)\n\n    # Heuristic based on spatial clustering\n    cluster_heuristic = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                 # Density based on inverse distance to other nodes\n                 density_i = np.sum(1 / distance_matrix[i, 1:]) - (1/ distance_matrix[i,i]) if np.sum(1 / distance_matrix[i, 1:]) < np.inf else 0 # Avoid division by zero\n                 density_j = np.sum(1 / distance_matrix[j, 1:]) - (1/ distance_matrix[j,j]) if np.sum(1 / distance_matrix[j, 1:]) < np.inf else 0 # Avoid division by zero\n                 # penalize connections to nodes with much lower density\n                 cluster_heuristic[i,j] = min(density_i, density_j) / max(density_i, density_j) if max(density_i, density_j) > 0 else 0 #Between 0 and 1\n                 \n    #Gravitational attraction to the depot\n    depot_attraction = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(1, n):\n        depot_attraction[0, i] = 1/(distance_matrix[0, i])\n        depot_attraction[i, 0] = 1/(distance_matrix[i, 0]) # Symmetric\n\n    # Combine heuristics with weights\n    heuristic_matrix = (alpha * distance_heuristic +\n                        beta * demand_heuristic +\n                        gamma * cluster_heuristic +\n                        0.1 * depot_attraction)\n\n    # Depot edges should be generally favored to return to depot\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 1.2  # Favor leaving the depot\n        heuristic_matrix[i, 0] *= 1.2  # Favor returning to the depot\n\n    # Normalize the heuristic matrix to [0, 1]\n    max_heuristic = np.max(heuristic_matrix)\n    min_heuristic = np.min(heuristic_matrix)\n    heuristic_matrix = (heuristic_matrix - min_heuristic) / (max_heuristic - min_heuristic) if max_heuristic > min_heuristic else np.zeros_like(heuristic_matrix)\n\n    return heuristic_matrix\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Combines distance, demand, and spatial clustering with adaptive scaling.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Avoid division by zero.\n    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)\n\n    # Define weights for combining heuristics\n    alpha = 0.4  # Importance of distance\n    beta = 0.35   # Importance of demand feasibility\n    gamma = 0.25  # Importance of cluster affinity\n\n    # Heuristic based on inverse distance\n    distance_heuristic = 1 / distance_matrix\n\n    # Heuristic based on demand feasibility\n    demand_heuristic = np.ones_like(distance_matrix, dtype=float)\n    for i in range(1, n):  # Skip depot\n        for j in range(1, n): # Skip depot\n            if i != j:\n                if demands[i] + demands[j] > capacity:\n                    demand_heuristic[i, j] = 0.1 # severely penalize\n                else:\n                     demand_heuristic[i, j] = 1 - (demands[i] + demands[j]) / (2*capacity)\n\n    # Heuristic based on spatial clustering\n    cluster_heuristic = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                 # Density based on inverse distance to other nodes\n                 density_i = np.sum(1 / distance_matrix[i, 1:]) - (1/ distance_matrix[i,i]) if np.sum(1 / distance_matrix[i, 1:]) < np.inf else 0 # Avoid division by zero\n                 density_j = np.sum(1 / distance_matrix[j, 1:]) - (1/ distance_matrix[j,j]) if np.sum(1 / distance_matrix[j, 1:]) < np.inf else 0 # Avoid division by zero\n                 # penalize connections to nodes with much lower density\n                 cluster_heuristic[i,j] = min(density_i, density_j) / max(density_i, density_j) if max(density_i, density_j) > 0 else 0 #Between 0 and 1\n                 \n    #Gravitational attraction to the depot\n    depot_attraction = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(1, n):\n        depot_attraction[0, i] = 1/(distance_matrix[0, i])\n        depot_attraction[i, 0] = 1/(distance_matrix[i, 0]) # Symmetric\n\n    # Combine heuristics with weights\n    heuristic_matrix = (alpha * distance_heuristic +\n                        beta * demand_heuristic +\n                        gamma * cluster_heuristic +\n                        0.1 * depot_attraction)\n\n    # Depot edges should be generally favored to return to depot\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 1.2  # Favor leaving the depot\n        heuristic_matrix[i, 0] *= 1.2  # Favor returning to the depot\n\n    # Normalize the heuristic matrix to [0, 1]\n    max_heuristic = np.max(heuristic_matrix)\n    min_heuristic = np.min(heuristic_matrix)\n    heuristic_matrix = (heuristic_matrix - min_heuristic) / (max_heuristic - min_heuristic) if max_heuristic > min_heuristic else np.zeros_like(heuristic_matrix)\n\n    return heuristic_matrix\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, angle, and depot proximity.\n    Sparsifies the matrix by setting unpromising elements to zero.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            dist_h = 1 / (distance_matrix[i, j] + epsilon)\n            demand_h = 1 - np.clip((demands[i] + demands[j]) / (2 * capacity + epsilon), 0, 1)\n            if i == 0 or j == 0:\n                demand_h = 1.0\n\n            angle_h = 1.0\n            if i != 0 and j != 0:\n                angle_h = 0.0\n                nn_idx = -1; dist = np.inf\n                for k in range(n):\n                    if k != i and k != j:\n                        if distance_matrix[i, k] < dist:\n                            dist = distance_matrix[i, k]\n                            nn_idx = k\n\n                if nn_idx != -1:\n                    a = distance_matrix[i, j]\n                    b = distance_matrix[i, nn_idx]\n                    c = distance_matrix[j, nn_idx]\n                    try:\n                        angle_h = (a**2 + b**2 - c**2) / (2 * a * b + epsilon)\n                        angle_h = np.clip(angle_h, -1.0, 1.0)\n                        angle_h = (angle_h + 1.0) / 2.0\n                    except:\n                        angle_h = 0.5\n\n            depot_prox_h = 1 - np.clip((distance_matrix[0, i] + distance_matrix[0, j]) / (2 * np.max(distance_matrix) + epsilon), 0, 1)\n\n            heuristics[i, j] = (\n                0.5 * dist_h +\n                0.15 * demand_h +\n                0.25 * angle_h +\n                0.1 * depot_prox_h\n            )\n\n    # Sparsify the matrix (optional, but can be beneficial)\n    threshold = np.mean(heuristics) * 0.2  # Dynamic threshold based on the mean\n    heuristics[heuristics < threshold] = 0\n\n    return heuristics\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, angle, and depot proximity.\n    Sparsifies the matrix by setting unpromising elements to zero.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            dist_h = 1 / (distance_matrix[i, j] + epsilon)\n            demand_h = 1 - np.clip((demands[i] + demands[j]) / (2 * capacity + epsilon), 0, 1)\n            if i == 0 or j == 0:\n                demand_h = 1.0\n\n            angle_h = 1.0\n            if i != 0 and j != 0:\n                angle_h = 0.0\n                nn_idx = -1; dist = np.inf\n                for k in range(n):\n                    if k != i and k != j:\n                        if distance_matrix[i, k] < dist:\n                            dist = distance_matrix[i, k]\n                            nn_idx = k\n\n                if nn_idx != -1:\n                    a = distance_matrix[i, j]\n                    b = distance_matrix[i, nn_idx]\n                    c = distance_matrix[j, nn_idx]\n                    try:\n                        angle_h = (a**2 + b**2 - c**2) / (2 * a * b + epsilon)\n                        angle_h = np.clip(angle_h, -1.0, 1.0)\n                        angle_h = (angle_h + 1.0) / 2.0\n                    except:\n                        angle_h = 0.5\n\n            depot_prox_h = 1 - np.clip((distance_matrix[0, i] + distance_matrix[0, j]) / (2 * np.max(distance_matrix) + epsilon), 0, 1)\n\n            heuristics[i, j] = (\n                0.5 * dist_h +\n                0.15 * demand_h +\n                0.25 * angle_h +\n                0.1 * depot_prox_h\n            )\n\n    # Sparsify the matrix (optional, but can be beneficial)\n    threshold = np.mean(heuristics) * 0.2  # Dynamic threshold based on the mean\n    heuristics[heuristics < threshold] = 0\n\n    return heuristics\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristic combining distance, demand, angle, and depot proximity.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Distance and demand scaling\n    demand_scaled_distance = distance_matrix * (demands[np.newaxis, :] + demands[:, np.newaxis]) / (2 * capacity)\n    demand_scaled_distance = np.where(demand_scaled_distance == 0, np.inf, demand_scaled_distance)\n\n    # Depot proximity\n    depot_x, depot_y = coordinates[0]\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                continue\n            node_i_x, node_i_y = coordinates[i]\n            node_j_x, node_j_y = coordinates[j]\n\n            angle_i = np.arctan2(node_i_y - depot_y, node_i_x - depot_x)\n            angle_j = np.arctan2(node_j_y - depot_y, node_j_x - depot_x)\n            angle_diff = np.abs(angle_i - angle_j)\n            angle_diff = np.minimum(angle_diff, 2 * np.pi - angle_diff)\n            angular_penalty = (angle_diff / np.pi)\n\n            depot_proximity = 1 - 0.9 * max(distance_matrix[0,i], distance_matrix[0,j]) / np.mean(distance_matrix)\n\n            heuristics[i, j] = 1 / (demand_scaled_distance[i, j] + 0.1 * angular_penalty) + 0.5 * depot_proximity # combine, add proximity\n            heuristics[j, i] = heuristics[i, j]\n\n    # Depot edges prioritization\n    for i in range(1, n):\n        heuristics[0, i] = 1.0 / (distance_matrix[0, i] * demands[i] / capacity + 1e-6)\n        heuristics[i, 0] = heuristics[0, i]\n\n    # No self-loops\n    for i in range(n):\n        heuristics[i, i] = 0\n\n    return heuristics\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, depot proximity, and spatial influence for CVRP heuristic.\"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Parameters\n    distance_weight = 1.0\n    demand_weight = 1.0\n    spatial_weight = 0.5\n    depot_proximity_weight = 0.5\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            # Distance\n            distance_heuristic = distance_weight / (distance_matrix[i, j] + 1e-9)\n\n            # Demand\n            demand_i = demands[i]\n            demand_j = demands[j]\n            combined_demand = (2 * demand_i * demand_j) / (demand_i + demand_j + 1e-9)\n            demand_heuristic = (1 - min(1.0, combined_demand / capacity)) * demand_weight\n\n            # Spatial\n            spatial_heuristic = 0.0\n            neighbor_radius = np.mean(distance_matrix) / 2\n            neighbor_count = 0\n            for k in range(n):\n                if k != i and k != j and distance_matrix[i, k] < neighbor_radius:\n                    spatial_heuristic += demands[k]\n                    neighbor_count += 1\n                if k != i and k != j and distance_matrix[j, k] < neighbor_radius:\n                    spatial_heuristic += demands[k]\n                    neighbor_count += 1\n            if neighbor_count > 0:\n                spatial_heuristic = (1 - min(1, spatial_heuristic / (neighbor_count * capacity + 1e-9))) * spatial_weight\n            else:\n                spatial_heuristic = spatial_weight\n\n            # Depot Proximity\n            depot_proximity = 1 - 0.9 * max(distance_matrix[0, i], distance_matrix[0, j]) / np.mean(distance_matrix)\n            depot_heuristic = depot_proximity * depot_proximity_weight\n\n            heuristic_matrix[i, j] = distance_heuristic + demand_heuristic + spatial_heuristic + depot_heuristic\n\n    # Depot connections favored\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 1.2  # Boost depot connections\n        heuristic_matrix[i, 0] *= 1.2\n\n\n    return heuristic_matrix\n\n[Heuristics 19th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Combines distance, demand, and angle considerations, with adaptive weighting, and depot proximity.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n    scaled_distance = distance_matrix / np.max(distance_matrix)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            heuristic_matrix[i, j] = 1 / (scaled_distance[i, j] + 0.0001)\n\n            demand_penalty = (demands[i] + demands[j]) / (2 * capacity)\n            heuristic_matrix[i, j] /= (demand_penalty + 0.5)\n\n            if demands[i] > 0.7 * capacity or demands[j] > 0.7 * capacity:\n                heuristic_matrix[i, j] /= 5\n\n            if i == 0 or j == 0:\n                heuristic_matrix[i, j] *= 1.5\n            \n            if 0.15*capacity < demands[i] < 0.45*capacity or 0.15*capacity < demands[j] < 0.45*capacity:\n                heuristic_matrix[i, j] *= 1.1\n    \n            if i != 0 and j != 0:\n                vector_ij = coordinates[j] - coordinates[i]\n                vector_0j = coordinates[j] - coordinates[0]\n                dot_product = np.dot(vector_ij, vector_0j)\n                magnitude_ij = np.linalg.norm(vector_ij)\n                magnitude_0j = np.linalg.norm(vector_0j)\n\n                if magnitude_ij > 0 and magnitude_0j > 0:\n                    cos_angle = dot_product / (magnitude_ij * magnitude_0j)\n                    cos_angle = np.clip(cos_angle, -1.0, 1.0)\n                    angle = np.arccos(cos_angle)\n                    angle_factor = 1 - (angle / np.pi)\n                    heuristic_matrix[i, j] *= (0.5 + angle_factor)/1.5 #angle factor 0.5 to 1.5\n                \n\n    return heuristic_matrix\n\n[Heuristics 20th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Combines distance, demand, and angle considerations, with adaptive weighting, and depot proximity.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n    scaled_distance = distance_matrix / np.max(distance_matrix)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            heuristic_matrix[i, j] = 1 / (scaled_distance[i, j] + 0.0001)\n\n            demand_penalty = (demands[i] + demands[j]) / (2 * capacity)\n            heuristic_matrix[i, j] /= (demand_penalty + 0.5)\n\n            if demands[i] > 0.7 * capacity or demands[j] > 0.7 * capacity:\n                heuristic_matrix[i, j] /= 5\n\n            if i == 0 or j == 0:\n                heuristic_matrix[i, j] *= 1.5\n            \n            if 0.15*capacity < demands[i] < 0.45*capacity or 0.15*capacity < demands[j] < 0.45*capacity:\n                heuristic_matrix[i, j] *= 1.1\n    \n            if i != 0 and j != 0:\n                vector_ij = coordinates[j] - coordinates[i]\n                vector_0j = coordinates[j] - coordinates[0]\n                dot_product = np.dot(vector_ij, vector_0j)\n                magnitude_ij = np.linalg.norm(vector_ij)\n                magnitude_0j = np.linalg.norm(vector_0j)\n\n                if magnitude_ij > 0 and magnitude_0j > 0:\n                    cos_angle = dot_product / (magnitude_ij * magnitude_0j)\n                    cos_angle = np.clip(cos_angle, -1.0, 1.0)\n                    angle = np.arccos(cos_angle)\n                    angle_factor = 1 - (angle / np.pi)\n                    heuristic_matrix[i, j] *= (0.5 + angle_factor)/1.5 #angle factor 0.5 to 1.5\n                \n\n    return heuristic_matrix\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}