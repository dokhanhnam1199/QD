```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Combines distance, demand, and angle considerations, with adaptive weighting, and depot proximity.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))
    scaled_distance = distance_matrix / np.max(distance_matrix)

    for i in range(n):
        for j in range(n):
            if i == j:
                continue

            heuristic_matrix[i, j] = 1 / (scaled_distance[i, j] + 0.0001)

            demand_penalty = (demands[i] + demands[j]) / (2 * capacity)
            heuristic_matrix[i, j] /= (demand_penalty + 0.5)

            if demands[i] > 0.7 * capacity or demands[j] > 0.7 * capacity:
                heuristic_matrix[i, j] /= 5

            if i == 0 or j == 0:
                heuristic_matrix[i, j] *= 1.5
            
            if 0.15*capacity < demands[i] < 0.45*capacity or 0.15*capacity < demands[j] < 0.45*capacity:
                heuristic_matrix[i, j] *= 1.1
    
            if i != 0 and j != 0:
                vector_ij = coordinates[j] - coordinates[i]
                vector_0j = coordinates[j] - coordinates[0]
                dot_product = np.dot(vector_ij, vector_0j)
                magnitude_ij = np.linalg.norm(vector_ij)
                magnitude_0j = np.linalg.norm(vector_0j)

                if magnitude_ij > 0 and magnitude_0j > 0:
                    cos_angle = dot_product / (magnitude_ij * magnitude_0j)
                    cos_angle = np.clip(cos_angle, -1.0, 1.0)
                    angle = np.arccos(cos_angle)
                    angle_factor = 1 - (angle / np.pi)
                    heuristic_matrix[i, j] *= (0.5 + angle_factor)/1.5 #angle factor 0.5 to 1.5
                

    return heuristic_matrix
```
