```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates distance, demand, and angular considerations.

    Args:
        distance_matrix: Distance matrix (shape: n by n).
        coordinates: Euclidean coordinates of nodes (shape: n by 2).
        demands: Vector of customer demands (shape: n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of the same shape as the distance_matrix representing prior indicators
        of how promising it is to include each edge in a solution.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to control the influence of each component
    distance_weight = 0.5  # Weight for the distance component
    demand_weight = 0.3    # Weight for the demand component
    angle_weight = 0.2     # Weight for the angle component

    # Depot coordinates
    depot_x, depot_y = coordinates[0]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # Avoid self-loops
                continue

            # Distance component: Inverse of distance (shorter distances are preferred)
            distance_heuristic = 1 / (distance_matrix[i, j] + 1e-6)  # Add small epsilon to avoid division by zero

            # Demand component: Prioritize edges that connect to nodes with demands that
            # are neither too small (potentially insignificant) nor too large (likely needing a return trip).
            # Normalize demands by capacity
            normalized_demand_i = demands[i] / capacity
            normalized_demand_j = demands[j] / capacity

            # Heuristic value based on how well the demands 'fit' with the capacity
            demand_heuristic = np.exp(-np.abs(normalized_demand_i + normalized_demand_j - 0.5))  # Prefer nodes whose sum is around half the capacity

            # Angle component: Calculate the angle between the vectors depot -> i and depot -> j.
            # Edges that are "in the same direction" from the depot are penalized slightly, encouraging a broader search.
            if i != 0 and j != 0:
                vector_i = coordinates[i] - coordinates[0]
                vector_j = coordinates[j] - coordinates[0]

                # Calculate the cosine of the angle between the vectors
                cosine_angle = np.dot(vector_i, vector_j) / (np.linalg.norm(vector_i) * np.linalg.norm(vector_j) + 1e-6)
                # Angle is good if negative or small positive
                angle_heuristic = max(0, 1 - cosine_angle)
            else:
                angle_heuristic = 1  # If one of the nodes is the depot, the angle heuristic does not penalize.


            # Combine the heuristics, ensure all components are non-negative and normalized
            heuristic_matrix[i, j] = (
                distance_weight * distance_heuristic +
                demand_weight * demand_heuristic +
                angle_weight * angle_heuristic
            )

    # Normalize the heuristic matrix to be between 0 and 1 (optional)
    heuristic_matrix = heuristic_matrix / np.max(heuristic_matrix)

    return heuristic_matrix
```
