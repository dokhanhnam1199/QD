```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A more sophisticated heuristics for CVRP, considering distance, angle, demand, and capacity.

    Args:
        distance_matrix: (n, n) distance matrix.
        coordinates: (n, 2) coordinates of nodes.
        demands: (n,) demand of each node.
        capacity: Vehicle capacity.

    Returns:
        (n, n) matrix of edge weights, indicating the desirability of including each edge in the solution.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Heuristic 1: Inverse distance (like v1, but modified)
    distance_heuristic = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero

    # Heuristic 2: Angle Penalty (discourage sharp turns)
    angle_heuristic = np.ones((n, n))
    for i in range(1, n):  # Exclude depot
        for j in range(1, n):  # Exclude depot
            if i != j:
                # Calculate angle between depot-i and i-j vectors
                vector_di = coordinates[i] - coordinates[0]  #Depot to i
                vector_ij = coordinates[j] - coordinates[i] # i to j

                dot_product = np.dot(vector_di, vector_ij)
                magnitudes = np.linalg.norm(vector_di) * np.linalg.norm(vector_ij)
                if magnitudes == 0:
                    angle = 0 #If i == depot
                else:
                    angle = np.arccos(np.clip(dot_product / magnitudes, -1.0, 1.0))  # Clip to handle numerical issues

                angle_penalty = (angle / np.pi)  # Normalize to [0, 1] - higher angles are penalized.

                angle_heuristic[i, j] = 1 - angle_penalty #Small angles preferred so high value
                angle_heuristic[j, i] = 1 - angle_penalty #symmetric
    # Heuristic 3: Demand-Awareness
    demand_heuristic = np.ones((n, n))

    for i in range(1,n):
         for j in range(1, n):
            if i!= j:
                # Penalize edges connecting to nodes with high demand if they are close to depot.
                # Reward connections between nodes with smaller demands
                demand_impact = (demands[i] + demands[j]) / (2 * capacity)
                demand_impact = np.clip(demand_impact, 0.0, 1.0) #Clamp so values are between 0 and 1

                if (distance_matrix[0,i] < np.mean(distance_matrix) or distance_matrix[0,j] < np.mean(distance_matrix)):
                    demand_heuristic[i,j] = 1 - demand_impact #Penalize edges to high-demand if nearby depot
                else:
                    demand_heuristic[i, j] = 1 #Do nothing
                demand_heuristic[j, i] = demand_heuristic[i, j] #make symmetric


    # Heuristic 4: Depot Affinity

    depot_affinity_heuristic = np.ones((n,n))
    for i in range(1,n):
        depot_proximity = distance_matrix[0,i] / np.mean(distance_matrix)
        depot_proximity = np.clip(depot_proximity, 0, 1)
        for j in range(1,n):

            depot_affinity_heuristic[i,j] = 1- depot_proximity
            depot_affinity_heuristic[j,i] = 1 - depot_proximity


    # Combine the heuristics (weighted sum)
    heuristic_matrix = (
        0.5 * distance_heuristic +
        0.15 * angle_heuristic +
        0.25 * demand_heuristic +
        0.10 * depot_affinity_heuristic
    )


    # Ensure depot affinity is always considered by having edges connected to it rated higher

    for i in range(1,n):
        heuristic_matrix[0,i] = 1 #High priority to return to the depot
        heuristic_matrix[i,0] = 1

    return heuristic_matrix
```
