```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version considers distance, demand, angle relative to the depot, and route feasibility in assigning edge priorities.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    depot_x, depot_y = coordinates[0]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
                continue

            # Distance component: Favor shorter distances
            distance_factor = 1 / distance_matrix[i, j] if distance_matrix[i, j] > 0 else 0  # Avoid division by zero

            # Demand component: Penalize edges that connect to nodes with high demand if the starting node already carries high demand.
            demand_factor = 1.0  #Neutral by default
            #Heavier penalty for node close to depot.
            demand_i = demands[i]
            demand_j = demands[j]
            distance_to_depot_i = distance_matrix[i,0]
            distance_to_depot_j = distance_matrix[j,0]

            demand_factor_i = 1/ (demand_i + 1e-6) #Avoid division by 0
            demand_factor_j = 1/ (demand_j + 1e-6) #Avoid division by 0

            # Angle component: Prioritize edges that keep the route moving generally away from the depot and progressing around
            angle_factor = 1.0
            if i != 0 and j != 0:
                angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)
                angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)
                angle_diff = np.abs(angle_i - angle_j)
                angle_diff = min(angle_diff, 2 * np.pi - angle_diff) # angle between 0 and pi

                angle_factor = 1 - (angle_diff / np.pi) # Higher if angles are similar

            #Combine: Favor nearby, lower-demand nodes generally moving away from the depot
            heuristics[i, j] = distance_factor  * demand_factor_j * angle_factor

    return heuristics
```
