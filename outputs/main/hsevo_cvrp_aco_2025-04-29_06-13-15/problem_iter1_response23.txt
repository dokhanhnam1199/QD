```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Generates a heuristic matrix for the Capacitated Vehicle Routing Problem (CVRP).
    This version considers distance, demand, and proximity to the depot.

    Args:
        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes.
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): A vector of customer demands.
        capacity (int): The vehicle capacity.

    Returns:
        np.ndarray: A heuristic matrix where each element indicates the desirability
                     of including the corresponding edge in a route.
    """
    n_nodes = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Avoid division by zero.
    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)

    # Proximity to depot. Measure the angle each node creates to the depot.
    depot_x, depot_y = coordinates[0]
    angles = np.zeros(n_nodes)

    for i in range(1, n_nodes):
        x, y = coordinates[i]
        dx = x - depot_x
        dy = y - depot_y
        angles[i] = np.arctan2(dy, dx)

    for i in range(n_nodes):
        for j in range(n_nodes):
            if i == j:
                heuristic_matrix[i, j] = 0  # Do not allow self loops.
            else:
                # Prioritize shorter distances.
                distance_factor = 1 / distance_matrix[i, j]

                # Penalize edges connecting to nodes with high demand (except the depot).
                demand_penalty_i = 1 if i == 0 else demands[i] / capacity
                demand_penalty_j = 1 if j == 0 else demands[j] / capacity

                # Add term to include node with larger angle
                angle_diff = abs(angles[i]-angles[j])

                #Combine angle and demand penalty
                heuristic_matrix[i, j] = distance_factor / (demand_penalty_i * demand_penalty_j) + angle_diff/np.pi # Normalize

    return heuristic_matrix
```
