[2025-04-29 06:13:15,431][root][INFO] - Workspace: C:\Users\Nam\Documents\GitHub\HSEvo\outputs\main\hsevo_cvrp_aco_2025-04-29_06-13-15
[2025-04-29 06:13:15,431][root][INFO] - Project Root: C:\Users\Nam\Documents\GitHub\HSEvo
[2025-04-29 06:13:15,431][root][INFO] - Using LLM: gemini/gemini-2.0-flash
[2025-04-29 06:13:15,431][root][INFO] - Using Algorithm: hsevo
[2025-04-29 06:13:17,848][httpx][INFO] - HTTP Request: GET https://raw.githubusercontent.com/BerriAI/litellm/main/model_prices_and_context_window.json "HTTP/1.1 200 OK"
[2025-04-29 06:13:19,641][root][INFO] - Problem: cvrp_aco
[2025-04-29 06:13:19,642][root][INFO] - Problem description: Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
[2025-04-29 06:13:19,647][root][INFO] - Function name: heuristics
[2025-04-29 06:13:19,649][root][INFO] - Evaluating seed function...
[2025-04-29 06:13:19,649][root][INFO] - Seed function code: 
import numpy as np
import random
import math
import scipy
import torch
def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix
[2025-04-29 06:13:19,649][root][INFO] - Iteration 0: Running Code 0
[2025-04-29 06:13:25,404][root][INFO] - Iteration 0: Code Run 0 successful!
[2025-04-29 06:13:55,895][root][INFO] - Iteration 0, response_id 0: Objective value: 18.60114687535548
[2025-04-29 06:13:55,896][root][INFO] - Iteration 0: Elitist: 18.60114687535548
[2025-04-29 06:13:55,896][root][INFO] - Iteration 0 finished...
[2025-04-29 06:13:55,896][root][INFO] - Best obj: 18.60114687535548, Best Code Path: problem_iter0_code0.py
[2025-04-29 06:13:55,896][root][INFO] - LLM usage: prompt_tokens = 0, completion_tokens = 0
[2025-04-29 06:13:55,896][root][INFO] - Function Evals: 1
[2025-04-29 06:13:55,897][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,898][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,899][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Isaac Newton, the father of physics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Isaac Newton, the father of physics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,901][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,902][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Nikola Tesla, master of electricity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Nikola Tesla, master of electricity. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,904][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,905][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,907][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,910][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,911][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,913][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,914][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,915][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Isaac Newton, the father of physics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Isaac Newton, the father of physics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,916][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,918][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Nikola Tesla, master of electricity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Nikola Tesla, master of electricity. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,924][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,926][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,927][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,929][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,931][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,933][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,934][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,936][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Isaac Newton, the father of physics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Isaac Newton, the father of physics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,937][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,938][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Nikola Tesla, master of electricity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Nikola Tesla, master of electricity. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,939][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,941][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,943][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,944][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:55,946][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.

def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    return 1 / distance_matrix


Refer to the format of a trivial design above. Be very creative and give `heuristics_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-29 06:13:56,001][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:13:56,003][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:01,883][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:01,887][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:01,889][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:01,889][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:01,891][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:01,894][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:03,478][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:03,480][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:03,480][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:03,481][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:03,482][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:03,482][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:07,474][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:07,477][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:07,479][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:07,479][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:07,481][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:07,484][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:08,784][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:08,787][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:08,788][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:08,788][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:08,790][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:08,792][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:12,266][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:12,270][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:12,271][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:12,272][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:12,274][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:12,275][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:14,739][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:14,740][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:14,741][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:14,741][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:14,742][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:14,743][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:19,368][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:19,380][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:19,382][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:19,382][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:19,383][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:19,383][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:20,832][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:20,835][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:20,836][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:20,837][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:20,839][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:20,840][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:25,939][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:25,943][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:25,944][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:25,944][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:25,946][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:25,948][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:26,826][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:26,827][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:26,828][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:26,828][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:26,829][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:26,830][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:31,007][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:31,010][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:31,011][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:31,011][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:31,014][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:31,015][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:33,312][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:33,313][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:33,314][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:33,314][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:33,315][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:33,316][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:37,414][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:37,416][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:37,417][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:37,417][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:37,418][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:37,418][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:38,039][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:38,043][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:38,044][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:38,044][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:38,047][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:38,048][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:44,808][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:44,811][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:44,812][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:44,813][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:44,815][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:44,816][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:46,221][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:14:46,224][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:14:46,226][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:46,226][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:46,228][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:14:46,231][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:46,476][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-29 06:14:46,492][root][INFO] - Attempt 1 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "model": "gemini-2.0-flash",
              "location": "global"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "8s"
      }
    ]
  }
}

[2025-04-29 06:14:47,927][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-29 06:14:47,945][root][INFO] - Attempt 1 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "location": "global",
              "model": "gemini-2.0-flash"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "7s"
      }
    ]
  }
}

[2025-04-29 06:14:49,494][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:50,947][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:51,176][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-29 06:14:51,191][root][INFO] - Attempt 2 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "location": "global",
              "model": "gemini-2.0-flash"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "3s"
      }
    ]
  }
}

[2025-04-29 06:14:52,622][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-29 06:14:52,641][root][INFO] - Attempt 2 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "location": "global",
              "model": "gemini-2.0-flash"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "2s"
      }
    ]
  }
}

[2025-04-29 06:14:54,193][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:55,642][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:14:55,881][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-29 06:14:55,890][root][INFO] - Attempt 3 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "location": "global",
              "model": "gemini-2.0-flash"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "59s"
      }
    ]
  }
}

[2025-04-29 06:14:58,891][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:15:02,671][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:15:02,674][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:15:02,675][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:02,676][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:02,678][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:15:02,679][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:07,260][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:15:07,263][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:15:07,264][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:07,265][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:07,267][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:15:07,268][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:07,840][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:15:07,842][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:15:07,843][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:07,843][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:07,844][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:15:07,845][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:11,919][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:15:11,923][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:15:11,924][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:11,924][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:11,926][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:15:11,928][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:14,531][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:15:14,534][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:15:14,535][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:14,535][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:14,537][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:15:14,539][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:19,491][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:15:19,494][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:15:19,496][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:19,496][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:19,498][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:15:19,500][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:20,354][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:15:20,356][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:15:20,357][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:20,358][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:20,360][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:15:20,362][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:24,381][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:15:24,384][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:15:24,386][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:24,386][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:24,388][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:15:24,390][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:26,759][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:15:26,762][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:15:26,763][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:26,763][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:26,765][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:15:26,766][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:29,896][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:15:29,899][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:15:29,900][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:29,901][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:29,902][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:15:29,905][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:34,725][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:15:34,728][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:15:34,730][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:34,730][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:34,732][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:15:34,734][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:37,190][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:15:37,192][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:15:37,194][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:37,194][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:37,196][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:15:37,198][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:40,577][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:15:40,590][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:15:40,592][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:40,592][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:40,593][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:43,739][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:15:43,741][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:15:43,742][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:43,742][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:43,744][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:15:43,801][root][INFO] - Iteration 1: Running Code 0
[2025-04-29 06:15:49,600][root][INFO] - Iteration 1: Code Run 0 successful!
[2025-04-29 06:15:49,601][root][INFO] - Iteration 1: Running Code 1
[2025-04-29 06:15:56,625][root][INFO] - Iteration 1: Code Run 1 successful!
[2025-04-29 06:15:56,625][root][INFO] - Iteration 1: Running Code 2
[2025-04-29 06:16:04,495][root][INFO] - Iteration 1: Code Run 2 successful!
[2025-04-29 06:16:04,495][root][INFO] - Iteration 1: Running Code 3
[2025-04-29 06:16:12,918][root][INFO] - Iteration 1: Code Run 3 successful!
[2025-04-29 06:16:12,918][root][INFO] - Iteration 1: Running Code 4
[2025-04-29 06:16:22,247][root][INFO] - Iteration 1: Code Run 4 successful!
[2025-04-29 06:16:22,247][root][INFO] - Iteration 1: Running Code 5
[2025-04-29 06:16:32,108][root][INFO] - Iteration 1: Code Run 5 successful!
[2025-04-29 06:16:32,108][root][INFO] - Iteration 1: Running Code 6
[2025-04-29 06:16:42,168][root][INFO] - Iteration 1: Code Run 6 successful!
[2025-04-29 06:16:42,168][root][INFO] - Iteration 1: Running Code 7
[2025-04-29 06:16:52,819][root][INFO] - Iteration 1: Code Run 7 successful!
[2025-04-29 06:16:52,819][root][INFO] - Iteration 1: Running Code 8
[2025-04-29 06:17:04,692][root][INFO] - Iteration 1: Code Run 8 successful!
[2025-04-29 06:17:04,693][root][INFO] - Iteration 1: Running Code 9
[2025-04-29 06:17:16,804][root][INFO] - Iteration 1: Code Run 9 successful!
[2025-04-29 06:17:16,804][root][INFO] - Iteration 1: Running Code 10
[2025-04-29 06:17:29,741][root][INFO] - Iteration 1: Code Run 10 successful!
[2025-04-29 06:17:29,741][root][INFO] - Iteration 1: Running Code 11
[2025-04-29 06:17:42,854][root][INFO] - Iteration 1: Code Run 11 successful!
[2025-04-29 06:17:42,854][root][INFO] - Iteration 1: Running Code 12
[2025-04-29 06:17:56,168][root][INFO] - Iteration 1: Code Run 12 successful!
[2025-04-29 06:17:56,168][root][INFO] - Iteration 1: Running Code 13
[2025-04-29 06:18:11,645][root][INFO] - Iteration 1: Code Run 13 successful!
[2025-04-29 06:18:11,645][root][INFO] - Iteration 1: Running Code 14
[2025-04-29 06:18:28,161][root][INFO] - Iteration 1: Code Run 14 successful!
[2025-04-29 06:18:28,161][root][INFO] - Iteration 1: Running Code 15
[2025-04-29 06:18:44,074][root][INFO] - Iteration 1: Code Run 15 successful!
[2025-04-29 06:18:44,074][root][INFO] - Iteration 1: Running Code 16
[2025-04-29 06:18:58,872][root][INFO] - Iteration 1: Code Run 16 successful!
[2025-04-29 06:18:58,872][root][INFO] - Iteration 1: Running Code 17
[2025-04-29 06:19:12,613][root][INFO] - Iteration 1: Code Run 17 successful!
[2025-04-29 06:19:12,614][root][INFO] - Iteration 1: Running Code 18
[2025-04-29 06:19:28,575][root][INFO] - Iteration 1: Code Run 18 successful!
[2025-04-29 06:19:28,575][root][INFO] - Iteration 1: Running Code 19
[2025-04-29 06:19:44,568][root][INFO] - Iteration 1: Code Run 19 successful!
[2025-04-29 06:19:44,569][root][INFO] - Iteration 1: Running Code 20
[2025-04-29 06:20:00,721][root][INFO] - Iteration 1: Code Run 20 successful!
[2025-04-29 06:20:00,721][root][INFO] - Iteration 1: Running Code 21
[2025-04-29 06:20:16,768][root][INFO] - Iteration 1: Code Run 21 successful!
[2025-04-29 06:20:16,769][root][INFO] - Iteration 1: Running Code 22
[2025-04-29 06:20:34,512][root][INFO] - Iteration 1: Code Run 22 successful!
[2025-04-29 06:20:34,512][root][INFO] - Iteration 1: Running Code 23
[2025-04-29 06:20:50,376][root][INFO] - Iteration 1: Code Run 23 successful!
[2025-04-29 06:20:50,377][root][INFO] - Iteration 1: Running Code 24
[2025-04-29 06:21:05,644][root][INFO] - Iteration 1: Code Run 24 successful!
[2025-04-29 06:21:05,645][root][INFO] - Iteration 1: Running Code 25
[2025-04-29 06:21:24,621][root][INFO] - Iteration 1: Code Run 25 successful!
[2025-04-29 06:21:24,621][root][INFO] - Iteration 1: Running Code 26
[2025-04-29 06:21:43,446][root][INFO] - Iteration 1: Code Run 26 successful!
[2025-04-29 06:21:43,446][root][INFO] - Iteration 1: Running Code 27
[2025-04-29 06:22:01,566][root][INFO] - Iteration 1: Code Run 27 successful!
[2025-04-29 06:22:01,567][root][INFO] - Iteration 1: Running Code 28
[2025-04-29 06:22:19,132][root][INFO] - Iteration 1: Code Run 28 successful!
[2025-04-29 06:22:19,132][root][INFO] - Iteration 1: Running Code 29
[2025-04-29 06:22:35,650][root][INFO] - Iteration 1: Code Run 29 successful!
[2025-04-29 06:22:35,652][root][INFO] - Iteration 1, response_id 0: Objective value: 38.330385194409914
[2025-04-29 06:22:35,672][root][INFO] - Iteration 1, response_id 1: Objective value: 21.041743313292805
[2025-04-29 06:22:35,686][root][INFO] - Iteration 1, response_id 2: Objective value: 10.789751173104534
[2025-04-29 06:22:35,729][root][INFO] - Iteration 1, response_id 3: Objective value: 20.89857454661189
[2025-04-29 06:22:35,744][root][INFO] - Iteration 1, response_id 4: Objective value: 18.089982470824545
[2025-04-29 06:22:35,756][root][INFO] - Iteration 1, response_id 5: Objective value: 14.418876134359905
[2025-04-29 06:22:35,768][root][INFO] - Iteration 1, response_id 6: Objective value: 21.372511174586815
[2025-04-29 06:22:35,781][root][INFO] - Iteration 1, response_id 7: Objective value: 20.086050012912633
[2025-04-29 06:22:35,782][root][INFO] - Iteration 1, response_id 8: Objective value: 38.330385194409914
[2025-04-29 06:22:35,794][root][INFO] - Iteration 1, response_id 9: Objective value: 20.019918304158388
[2025-04-29 06:22:35,808][root][INFO] - Iteration 1, response_id 10: Objective value: 10.511579784046017
[2025-04-29 06:22:35,821][root][INFO] - Iteration 1, response_id 11: Objective value: 18.93445040580805
[2025-04-29 06:23:00,249][root][INFO] - Iteration 1, response_id 12: Objective value: 23.49542230512759
[2025-04-29 06:23:00,259][root][INFO] - Iteration 1, response_id 13: Objective value: 14.7206601047567
[2025-04-29 06:23:00,272][root][INFO] - Iteration 1, response_id 14: Objective value: 19.33641940173863
[2025-04-29 06:23:00,284][root][INFO] - Iteration 1, response_id 15: Objective value: 17.398542925223822
[2025-04-29 06:23:00,297][root][INFO] - Iteration 1, response_id 16: Objective value: 10.282342568133634
[2025-04-29 06:23:00,309][root][INFO] - Iteration 1, response_id 17: Objective value: 12.464162169017662
[2025-04-29 06:23:42,859][root][INFO] - Iteration 1, response_id 18: Objective value: 20.247788629119135
[2025-04-29 06:23:44,804][root][INFO] - Iteration 1, response_id 19: Objective value: 20.993595485428667
[2025-04-29 06:24:04,287][root][INFO] - Iteration 1, response_id 20: Objective value: 21.153052500971874
[2025-04-29 06:24:04,308][root][INFO] - Iteration 1, response_id 21: Objective value: 15.391208121215337
[2025-04-29 06:24:04,329][root][INFO] - Iteration 1, response_id 22: Objective value: 19.526970113147947
[2025-04-29 06:24:04,349][root][INFO] - Iteration 1, response_id 23: Objective value: 12.245207014826144
[2025-04-29 06:24:29,482][root][INFO] - Iteration 1, response_id 24: Objective value: 38.330385194409914
[2025-04-29 06:24:29,494][root][INFO] - Iteration 1, response_id 25: Objective value: 16.61957153778082
[2025-04-29 06:24:29,506][root][INFO] - Iteration 1, response_id 26: Objective value: 20.56610285493344
[2025-04-29 06:24:29,525][root][INFO] - Iteration 1, response_id 27: Objective value: 20.75647260787293
[2025-04-29 06:24:29,537][root][INFO] - Iteration 1, response_id 28: Objective value: 16.36044320552272
[2025-04-29 06:24:31,571][root][INFO] - Iteration 1, response_id 29: Objective value: 20.54385993750274
[2025-04-29 06:24:31,573][root][INFO] - Iteration 1: Elitist: 10.282342568133634
[2025-04-29 06:24:31,574][root][INFO] - Iteration 1 finished...
[2025-04-29 06:24:31,574][root][INFO] - Best obj: 10.282342568133634, Best Code Path: problem_iter1_code16.py
[2025-04-29 06:24:31,574][root][INFO] - LLM usage: prompt_tokens = 9708, completion_tokens = 20145
[2025-04-29 06:24:31,574][root][INFO] - Function Evals: 31
[2025-04-29 06:24:31,575][root][INFO] - Flash reflection Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.

User Prompt: 
### List heuristics
Below is a list of design heuristics ranked from best to worst.
[Heuristics 1st]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates:
    1.  Distance: Edges with shorter distances are preferred.
    2.  Demand Feasibility:  Penalizes edges that would immediately violate capacity constraints if used early in a route.
    3.  Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.
    4.  Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will "attract" closer nodes to form clusters.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Add a small value to avoid division by zero
    epsilon = 1e-6

    # 1. Distance component (inverse relationship)
    distance_heuristic = 1 / (distance_matrix + epsilon)

    # 2. Demand Feasibility component
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0  # No self-loops

            # If using this edge would exceed vehicle capacity (assuming starting from depot), penalize
            if demands[i] + demands[j] > capacity and i == 0: # starting node
                demand_heuristic[i, j] = 0.1  # A small value but not zero so it is not totally ignored
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = 0.1
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                 demand_heuristic[i,j] = 0.05


    # 3. Depot Proximity (encourage returning to depot if far and demand is high)
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):  # Exclude depot itself
        # Calculate average distance from node i to all other nodes (excluding the depot)
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0] # If only one other point exist use the distance to depot.

        # Encourage going back to the depot from this node IF it is far and demands are relatively high.
        # Depot preference is weighted based on avg_distance and demand compared to capacity
        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)
        depot_heuristic[i, 0] = depot_preference
        depot_heuristic[0, i] = depot_preference #symmetry

    # 4. Gravitational Attraction: Node `i` attracts closeby node `j`
    gravitational_heuristic = np.zeros((n, n))
    gravitational_constant = 1.0  # Adjust to control attraction strength.
    for i in range(1, n):  # Start from 1 to exclude the depot itself as a gravity center. Depot is served by the previous depot_heuristic.
        for j in range(1, n): # Start from 1 to exclude the depot itself being attracted by the gravitational heuristic.

            mass_i = demands[i]
            mass_j = demands[j]
            if i == j:
                gravitational_heuristic[i,j] = 0
                continue
            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon) # F = G*m1*m2/r^2

    # Combine the heuristics
    heuristics = distance_heuristic * demand_heuristic + depot_heuristic + gravitational_heuristic


    # Normalize to be between 0 and 1, can help stability of stochastic sampling methods
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics

[Heuristics 2nd]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates:
    1.  Distance: Edges with shorter distances are preferred.
    2.  Demand Feasibility:  Penalizes edges that would immediately violate capacity constraints if used early in a route.
    3.  Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.
    4.  Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will "attract" closer nodes to form clusters.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Add a small value to avoid division by zero
    epsilon = 1e-6

    # 1. Distance component (inverse relationship)
    distance_heuristic = 1 / (distance_matrix + epsilon)

    # 2. Demand Feasibility component
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0  # No self-loops

            # If using this edge would exceed vehicle capacity (assuming starting from depot), penalize
            if demands[i] + demands[j] > capacity and i == 0: # starting node
                demand_heuristic[i, j] = 0.1  # A small value but not zero so it is not totally ignored
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = 0.1
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                 demand_heuristic[i,j] = 0.05


    # 3. Depot Proximity (encourage returning to depot if far and demand is high)
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):  # Exclude depot itself
        # Calculate average distance from node i to all other nodes (excluding the depot)
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0] # If only one other point exist use the distance to depot.

        # Encourage going back to the depot from this node IF it is far and demands are relatively high.
        # Depot preference is weighted based on avg_distance and demand compared to capacity
        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)
        depot_heuristic[i, 0] = depot_preference
        depot_heuristic[0, i] = depot_preference #symmetry

    # 4. Gravitational Attraction: Node `i` attracts closeby node `j`
    gravitational_heuristic = np.zeros((n, n))
    gravitational_constant = 1.0  # Adjust to control attraction strength.
    for i in range(1, n):  # Start from 1 to exclude the depot itself as a gravity center. Depot is served by the previous depot_heuristic.
        for j in range(1, n): # Start from 1 to exclude the depot itself being attracted by the gravitational heuristic.

            mass_i = demands[i]
            mass_j = demands[j]
            if i == j:
                gravitational_heuristic[i,j] = 0
                continue
            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon) # F = G*m1*m2/r^2

    # Combine the heuristics
    heuristics = distance_heuristic * demand_heuristic + depot_heuristic + gravitational_heuristic


    # Normalize to be between 0 and 1, can help stability of stochastic sampling methods
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics

[Heuristics 3rd]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Implements a heuristic for the CVRP based on a combination of distance, demand,
    and angle considerations.  This function attempts to create more informed prior
    probabilities for edges in the solution.

    Args:
        distance_matrix: A numpy array representing the distances between nodes.
        coordinates: A numpy array representing the (x, y) coordinates of the nodes.
        demands: A numpy array representing the demand of each node.
        capacity: The capacity of each vehicle.

    Returns:
        A numpy array representing the heuristic values for each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Constants to tune the heuristic
    distance_weight = 1.0
    demand_weight = 0.5  # Penalize high-demand edges
    angle_weight = 0.3  # Encourages smoother routes
    capacity_penalty = 2.0 #Additional penalty of going to high demand customer

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            distance_term = distance_weight / distance_matrix[i, j] if distance_matrix[i,j] > 0 else 0 # Favor shorter distances
            demand_term = (1 - demand_weight * demands[j] / capacity)  # Penalize edges leading to high-demand nodes

            # Calculate angle between edges (i->j) and (j-> depot) as proxy for smooth route.
            # Lower values indicate direct route to depot
            if i == 0: #depot to customer
              angle_term = 0 #don't take into consideration
            else:
              vector_ij = coordinates[j] - coordinates[i]
              vector_j0 = coordinates[0] - coordinates[j]
              norm_ij = np.linalg.norm(vector_ij)
              norm_j0 = np.linalg.norm(vector_j0)
              if norm_ij > 0 and norm_j0 > 0:
                dot_product = np.dot(vector_ij, vector_j0)
                cosine_angle = dot_product / (norm_ij * norm_j0)
                angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))
                angle_term = (1 - angle_weight * angle / np.pi)
              else:
                angle_term = 0

            #Additional penalty for high demand customers.
            if demands[j] > (capacity/2):
               demand_term = demand_term / capacity_penalty
            
            heuristic_matrix[i, j] = distance_term * demand_term * angle_term #Combine factors


    return heuristic_matrix

[Heuristics 4th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Generates a heuristic matrix for the Capacitated Vehicle Routing Problem (CVRP).
    This version considers distance, demand, and proximity to the depot.

    Args:
        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes.
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): A vector of customer demands.
        capacity (int): The vehicle capacity.

    Returns:
        np.ndarray: A heuristic matrix where each element indicates the desirability
                     of including the corresponding edge in a route.
    """
    n_nodes = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Avoid division by zero.
    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)

    # Proximity to depot. Measure the angle each node creates to the depot.
    depot_x, depot_y = coordinates[0]
    angles = np.zeros(n_nodes)

    for i in range(1, n_nodes):
        x, y = coordinates[i]
        dx = x - depot_x
        dy = y - depot_y
        angles[i] = np.arctan2(dy, dx)

    for i in range(n_nodes):
        for j in range(n_nodes):
            if i == j:
                heuristic_matrix[i, j] = 0  # Do not allow self loops.
            else:
                # Prioritize shorter distances.
                distance_factor = 1 / distance_matrix[i, j]

                # Penalize edges connecting to nodes with high demand (except the depot).
                demand_penalty_i = 1 if i == 0 else demands[i] / capacity
                demand_penalty_j = 1 if j == 0 else demands[j] / capacity

                # Add term to include node with larger angle
                angle_diff = abs(angles[i]-angles[j])

                #Combine angle and demand penalty
                heuristic_matrix[i, j] = distance_factor / (demand_penalty_i * demand_penalty_j) + angle_diff/np.pi # Normalize

    return heuristic_matrix

[Heuristics 5th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Generates a heuristic matrix for the Capacitated Vehicle Routing Problem (CVRP).
    This version considers distance, demand, and proximity to the depot.

    Args:
        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes.
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): A vector of customer demands.
        capacity (int): The vehicle capacity.

    Returns:
        np.ndarray: A heuristic matrix where each element indicates the desirability
                     of including the corresponding edge in a route.
    """
    n_nodes = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Avoid division by zero.
    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)

    # Proximity to depot. Measure the angle each node creates to the depot.
    depot_x, depot_y = coordinates[0]
    angles = np.zeros(n_nodes)

    for i in range(1, n_nodes):
        x, y = coordinates[i]
        dx = x - depot_x
        dy = y - depot_y
        angles[i] = np.arctan2(dy, dx)

    for i in range(n_nodes):
        for j in range(n_nodes):
            if i == j:
                heuristic_matrix[i, j] = 0  # Do not allow self loops.
            else:
                # Prioritize shorter distances.
                distance_factor = 1 / distance_matrix[i, j]

                # Penalize edges connecting to nodes with high demand (except the depot).
                demand_penalty_i = 1 if i == 0 else demands[i] / capacity
                demand_penalty_j = 1 if j == 0 else demands[j] / capacity

                # Add term to include node with larger angle
                angle_diff = abs(angles[i]-angles[j])

                #Combine angle and demand penalty
                heuristic_matrix[i, j] = distance_factor / (demand_penalty_i * demand_penalty_j) + angle_diff/np.pi # Normalize

    return heuristic_matrix

[Heuristics 6th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Generates a heuristic matrix for the Capacitated Vehicle Routing Problem (CVRP).
    This version considers distance, demand, and proximity to the depot.

    Args:
        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes.
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): A vector of customer demands.
        capacity (int): The vehicle capacity.

    Returns:
        np.ndarray: A heuristic matrix where each element indicates the desirability
                     of including the corresponding edge in a route.
    """
    n_nodes = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Avoid division by zero.
    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)

    # Proximity to depot. Measure the angle each node creates to the depot.
    depot_x, depot_y = coordinates[0]
    angles = np.zeros(n_nodes)

    for i in range(1, n_nodes):
        x, y = coordinates[i]
        dx = x - depot_x
        dy = y - depot_y
        angles[i] = np.arctan2(dy, dx)

    for i in range(n_nodes):
        for j in range(n_nodes):
            if i == j:
                heuristic_matrix[i, j] = 0  # Do not allow self loops.
            else:
                # Prioritize shorter distances.
                distance_factor = 1 / distance_matrix[i, j]

                # Penalize edges connecting to nodes with high demand (except the depot).
                demand_penalty_i = 1 if i == 0 else demands[i] / capacity
                demand_penalty_j = 1 if j == 0 else demands[j] / capacity

                # Add term to include node with larger angle
                angle_diff = abs(angles[i]-angles[j])

                #Combine angle and demand penalty
                heuristic_matrix[i, j] = distance_factor / (demand_penalty_i * demand_penalty_j) + angle_diff/np.pi # Normalize

    return heuristic_matrix

[Heuristics 7th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and angle.

    Args:
        distance_matrix: Distance between nodes.
        coordinates: Coordinates of each node.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        Heuristic matrix indicating edge desirability.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Idea:  Combine distance (shorter is better), demand (lower is better given cap),
    #        and angular considerations (avoid sharp turns). Also, bias away from high-demand nodes
    #        except for the first hop (encourage initial diverse routes).

    # Normalize demands
    normalized_demands = demands / np.max(demands)  # Scale to 0-1

    for i in range(n):
        for j in range(n):
            if i != j:  # No self-loops

                distance_factor = 1 / distance_matrix[i, j]
                demand_factor = 1 - normalized_demands[j]  # Higher demand -> lower desirability
                if i == 0: # depot. always visit all nodes
                  demand_factor = 1.0 # remove demand as factor for initial route leaving the depot

                # Angle heuristic: Penalize sharp turns.
                # Calculate angle between vector i->j and depot->i

                depot_x, depot_y = coordinates[0]
                i_x, i_y = coordinates[i]
                j_x, j_y = coordinates[j]
                
                # Calculate vectors
                vector_ij = np.array([j_x - i_x, j_y - i_y])
                vector_di = np.array([i_x - depot_x, i_y - depot_y])

                # Normalize vectors to prevent magnitude affecting the result. Important!
                vector_ij = vector_ij / (np.linalg.norm(vector_ij) + 1e-9)
                vector_di = vector_di / (np.linalg.norm(vector_di) + 1e-9)


                # Calculate dot product and clip to ensure acos works even with floating-point errors
                dot_product = np.clip(np.dot(vector_ij, vector_di), -1.0, 1.0) #Ensure valid range

                # Calculate angle (in radians). Larger angle -> worse desirability (penalize)
                angle = np.arccos(dot_product)
                angle_factor = 1 - (angle / np.pi) # Scale to 0 - 1, larger angle-> small factor.

                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor
            else:
                heuristic_matrix[i, j] = 0  # No self-loops

    # Normalize to 0-1 for consistent behavior
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        heuristic_matrix /= max_heuristic
    else:
        heuristic_matrix = np.ones_like(heuristic_matrix) / n # if every edge has a heuristic of 0

    return heuristic_matrix

[Heuristics 8th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP) based on distance, demand, and node proximity.

    Args:
        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes.
        coordinates (np.ndarray): Euclidean coordinates of the nodes.
        demands (np.ndarray): A vector of customer demands.
        capacity (int): The vehicle capacity.

    Returns:
        np.ndarray: A matrix of heuristics values for each edge, indicating how promising it is to include the edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Heuristic 1: Inverse distance - shorter distances are preferred
    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero

    # Heuristic 2: Demand-based penalty - penalize edges that connect nodes with high combined demand, exceeding capacity. Edges to the depot are always favored
    demand_penalty = np.ones_like(distance_matrix)
    for i in range(1, n):  # Skip depot (index 0) for the inner loop
        for j in range(1, n):
            if i != j:
                if demands[i] + demands[j] > capacity:
                    demand_penalty[i, j] = 0.1  # Severely penalize if sum exceeds capacity
                else:
                    demand_penalty[i,j] = 1

    #Heuristic 3: Closeness to Depot Penalty.  Nodes farther away from depot penalize each other more strongly. This tries to pull edges closer to the depot earlier.
    depot_penalty = np.ones_like(distance_matrix)
    for i in range(1, n):
        for j in range(1,n):
            if i != j:
                depot_distance_i = distance_matrix[0, i]
                depot_distance_j = distance_matrix[0, j]
                depot_penalty[i, j] = max(0.1, 1.0 / (0.1 + (depot_distance_i + depot_distance_j)/2 )) # Ensure a non-zero penalty. Larger distanes penalize more

    #Favor connections to/from the depot
    for i in range(1, n):
      demand_penalty[0,i] = 1
      demand_penalty[i,0] = 1
      depot_penalty[0,i] = 1
      depot_penalty[i,0] = 1




    # Combine the heuristics - balance distance and demand considerations
    heuristics_matrix = distance_heuristic * demand_penalty * depot_penalty

    return heuristics_matrix

[Heuristics 9th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several factors to estimate edge desirability:
    1. Inverse Distance: Shorter distances are generally more desirable.
    2. Depot Proximity: Edges connected to the depot (node 0) are often crucial for route construction.
    3. Demand Consideration: Penalizes edges connecting high-demand nodes to avoid overloading vehicles early in a route.
    4. Closeness to Depot: If customer j is near to the depot than customer i then give higher priorities.
    5. Angle between nodes i and j. Prefer shorter angle for faster visiting.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Vector of customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    depot_x, depot_y = coordinates[0]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
                continue

            # 1. Inverse Distance
            distance_factor = 1 / (distance_matrix[i, j] + 1e-9)  # Add a small value to avoid division by zero.

            # 2. Depot Proximity
            depot_proximity_factor = 0.0
            if i == 0 or j == 0:
                depot_proximity_factor = 1.0

            # 3. Demand Consideration
            demand_penalty = 1.0
            demand_penalty = np.exp(-(demands[i] + demands[j]) / (2 * capacity) )  # Exponential decay for high demands

            # 4. Closeness to depot:
            distance_i_to_depot = np.sqrt((coordinates[i, 0] - depot_x)**2 + (coordinates[i, 1] - depot_y)**2)
            distance_j_to_depot = np.sqrt((coordinates[j, 0] - depot_x)**2 + (coordinates[j, 1] - depot_y)**2)

            closeness_factor = 0.0
            if distance_j_to_depot < distance_i_to_depot:
                closeness_factor = 0.5 # Adding a weight.

            # 5. Angle

            dx1 = coordinates[i, 0] - depot_x
            dy1 = coordinates[i, 1] - depot_y
            dx2 = coordinates[j, 0] - depot_x
            dy2 = coordinates[j, 1] - depot_y
            angle1 = np.arctan2(dy1, dx1)
            angle2 = np.arctan2(dy2, dx2)
            angle_diff = np.abs(angle1 - angle2)
            angle_factor = 1/(angle_diff + 1e-9)
            heuristics[i, j] = distance_factor * (1 + depot_proximity_factor) * demand_penalty + closeness_factor + angle_factor
            # Combination of factors
            #heuristics[i, j] = distance_factor + depot_proximity_factor - demand_factor
    return heuristics

[Heuristics 10th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on a combination of distance, demand, and spatial considerations.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes.
        coordinates (np.ndarray): Euclidean coordinates of nodes.
        demands (np.ndarray): Demand of each node.
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators for each edge (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Inverse distance (gravitational analogy - closer is better)
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add small constant to avoid division by zero

    # Demand-aware penalty (penalize edges connecting nodes with high demand - capacity constraints)
    demand_penalty = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            demand_penalty[i, j] = (demands[i] + demands[j]) / (2 * capacity)  # Scale penalty based on demand relative to capacity
    
    # Depot proximity bias (favor edges near the depot - central planning authority).
    depot_proximity = np.zeros_like(distance_matrix)
    for i in range(n):
      for j in range(n):
        depot_proximity[i,j] = 1 / (distance_matrix[0, i] + distance_matrix[0,j] + 1e-9)
    # Angle-based heuristic (Encourage routes that don't have sharp turns - minimize jerky movements).

    angle_factor = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                vector_i = coordinates[i] - coordinates[0]  # Vector from depot to node i
                vector_j = coordinates[j] - coordinates[0]  # Vector from depot to node j

                # Compute cosine of the angle between the vectors
                dot_product = np.dot(vector_i, vector_j)
                magnitude_i = np.linalg.norm(vector_i)
                magnitude_j = np.linalg.norm(vector_j)

                if magnitude_i > 0 and magnitude_j > 0:
                    cos_angle = dot_product / (magnitude_i * magnitude_j)
                    angle_factor[i, j] = (1 + cos_angle)/2  #Scale to [0,1]. Higher is better (straighter paths)
                else:
                    angle_factor[i, j] = 0 # Handle edge cases.

    # Combine the heuristics (assign weights based on relative importance)
    heuristics = (0.5 * inverse_distance +
                  0.15 * (1 - demand_penalty) +  # Invert the penalty so higher is better
                  0.15 * depot_proximity +
                  0.2 * angle_factor
                  )

    return heuristics

[Heuristics 11th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP using a combination of distance, demand, and angular considerations.

    Args:
        distance_matrix: Distance matrix (n x n).
        coordinates: Node coordinates (n x 2).
        demands: Node demands (n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of heuristic values (n x n). Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Depot location (assuming it's the first node).
    depot_x, depot_y = coordinates[0]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops

            else:
                # Combination of factors:

                # 1. Distance factor (inverse distance)
                distance_factor = 1 / distance_matrix[i, j]

                # 2. Demand factor: Prioritize edges connecting nodes with combined demand
                # that is not excessive relative to vehicle capacity.
                demand_factor = 1.0 / (1 + min(demands[i] + demands[j], capacity))

                # 3. Angular factor:  Nodes closer to the 'angle' from depot are preferred.
                # It encourages routing away from the depot in a broad sweep.

                # Calculate angles from the depot to each node. Avoid division by zero.
                angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)
                angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)
                angular_difference = abs(angle_i - angle_j)
                # Penalize large angular differences.
                angular_factor = 1.0 / (1 + angular_difference)

                # Incorporate depot proximity. It is desirable to return to depot at certain point.
                depot_distance_factor_i = 1.0 / (1 + distance_matrix[0, i])
                depot_distance_factor_j = 1.0 / (1 + distance_matrix[0, j])
                depot_proximity_factor = depot_distance_factor_i + depot_distance_factor_j

                # Combine all factors with weights. Tune weights to fit the problem at hand.
                heuristic_matrix[i, j] = (
                    0.5 * distance_factor +
                    0.15 * demand_factor +
                    0.15 * angular_factor +
                    0.2 * depot_proximity_factor
                )


    return heuristic_matrix

[Heuristics 12th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP using a combination of distance, demand, and angular considerations.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Scale distance by demand
    demand_scaled_distance = distance_matrix * (demands[np.newaxis, :] + demands[:, np.newaxis]) / (2 * capacity)  # Normalize by 2*capacity for relative cost
    demand_scaled_distance = np.where(demand_scaled_distance == 0, np.inf, demand_scaled_distance) # Avoid division by zero and zero distances (self-loops)

    # Angular penalty (discourage sharp turns at depot)
    depot_x, depot_y = coordinates[0]
    for i in range(1, n):
        for j in range(1, n):
            if i == j:
                continue
            node_i_x, node_i_y = coordinates[i]
            node_j_x, node_j_y = coordinates[j]

            # Angles relative to the depot
            angle_i = np.arctan2(node_i_y - depot_y, node_i_x - depot_x)
            angle_j = np.arctan2(node_j_y - depot_y, node_j_x - depot_x)

            angle_diff = np.abs(angle_i - angle_j)
            angle_diff = np.minimum(angle_diff, 2 * np.pi - angle_diff)  # Ensure angle_diff is the shorter angle

            angular_penalty = (angle_diff / np.pi)  # Scale to [0, 1]

            # Adjust heuristic value based on distance, demand and angular penalty.
            heuristics[i, j] = 1 / (demand_scaled_distance[i, j] + 0.1* angular_penalty) # add a small amount to ensure strictly positive
            heuristics[j, i] = heuristics[i, j] # enforce symmetric heuristics

    # Special treatment for depot edges. Prioritize edges to the depot.
    for i in range(1, n):
        heuristics[0, i] = 1.0 / (distance_matrix[0, i]* demands[i] / capacity+1e-6)  # Scale by demand relative to capacity
        heuristics[i, 0] = heuristics[0, i]

    #Make self-loops zero to prohibit them
    for i in range(n):
      heuristics[i, i] = 0

    return heuristics

[Heuristics 13th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP using a combination of distance, demand, and angular considerations.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Scale distance by demand
    demand_scaled_distance = distance_matrix * (demands[np.newaxis, :] + demands[:, np.newaxis]) / (2 * capacity)  # Normalize by 2*capacity for relative cost
    demand_scaled_distance = np.where(demand_scaled_distance == 0, np.inf, demand_scaled_distance) # Avoid division by zero and zero distances (self-loops)

    # Angular penalty (discourage sharp turns at depot)
    depot_x, depot_y = coordinates[0]
    for i in range(1, n):
        for j in range(1, n):
            if i == j:
                continue
            node_i_x, node_i_y = coordinates[i]
            node_j_x, node_j_y = coordinates[j]

            # Angles relative to the depot
            angle_i = np.arctan2(node_i_y - depot_y, node_i_x - depot_x)
            angle_j = np.arctan2(node_j_y - depot_y, node_j_x - depot_x)

            angle_diff = np.abs(angle_i - angle_j)
            angle_diff = np.minimum(angle_diff, 2 * np.pi - angle_diff)  # Ensure angle_diff is the shorter angle

            angular_penalty = (angle_diff / np.pi)  # Scale to [0, 1]

            # Adjust heuristic value based on distance, demand and angular penalty.
            heuristics[i, j] = 1 / (demand_scaled_distance[i, j] + 0.1* angular_penalty) # add a small amount to ensure strictly positive
            heuristics[j, i] = heuristics[i, j] # enforce symmetric heuristics

    # Special treatment for depot edges. Prioritize edges to the depot.
    for i in range(1, n):
        heuristics[0, i] = 1.0 / (distance_matrix[0, i]* demands[i] / capacity+1e-6)  # Scale by demand relative to capacity
        heuristics[i, 0] = heuristics[0, i]

    #Make self-loops zero to prohibit them
    for i in range(n):
      heuristics[i, i] = 0

    return heuristics

[Heuristics 14th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Generates heuristics for CVRP based on distance, demand, and vehicle capacity,
    prioritizing edges that connect nodes with moderate demand that, when combined,
    do not exceed vehicle capacity, and penalizing edges that are too long or
    connect to very high-demand nodes. It also gives slight preference to shorter
    edges overall, and connections to depot are given higher consideration

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Demand of each node (n). Depot demand is demands[0].
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Heuristic values for each edge (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Scale distance for better handling
    scaled_distance = distance_matrix / np.max(distance_matrix)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Base heuristic: Inverse of distance (shorter edges are better)
            heuristic_matrix[i, j] = 1 / (scaled_distance[i, j] + 0.0001) #prevent division by zero

            # Demand consideration: Nodes with moderate demand are more desirable
            demand_penalty = (demands[i] + demands[j]) / (2 * capacity)
            heuristic_matrix[i, j] /= (demand_penalty + 0.5)  # Penalty increases as combined demand approaches capacity. Avoid division by zero

            # Heavily Penalize edges connecting nodes with extreme demands if demand will overflow
            if demands[i] > 0.7 * capacity or demands[j] > 0.7 * capacity:
                heuristic_matrix[i, j] /= 5  # Much stronger penalty

            # Add slight preference for edges close to depot
            if i == 0 or j == 0:
                heuristic_matrix[i, j] *= 1.5
            
            # Small boost for mid-range demand nodes as they have higher chance of being combined
            if 0.15*capacity < demands[i] < 0.45*capacity or 0.15*capacity < demands[j] < 0.45*capacity:
                heuristic_matrix[i, j] *= 1.1

    return heuristic_matrix

[Heuristics 15th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates distance, demand, angle, and depot proximity considerations.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Avoid division by zero by adding a small epsilon
    epsilon = 1e-6

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
                continue

            # Base heuristic: inverse distance (more attractive for shorter distances)
            distance_heuristic = 1 / (distance_matrix[i, j] + epsilon)

            # Demand heuristic: penalize edges connecting high-demand nodes directly if capacity is limited.
            # Encourage returning to the depot (node 0) if the demand is high.
            demand_penalty = (demands[i] + demands[j]) / (2 * capacity + epsilon)
            demand_heuristic = 1 - np.clip(demand_penalty, 0, 1)  # Clip to ensure it's not negative
            if i == 0 or j == 0:  # Favor returns to the depot when close to full capacity.
                demand_heuristic = 1.0

            # Angle heuristic: Encourage smoother turns by penalizing sharp angles.
            # Approximated using the cosine rule. If the angle is small, the penalty will be small
            # leading to higher overall heuristic. The smaller the angle, the closer cosine to 1.
            angle_heuristic = 1.0  # Assume perfect smoothing if insufficient nodes to form angle

            if i != 0 and j != 0:
                angle_heuristic = 0.0
                # Find nearest node that is not equal to node i and j.
                nn_idx = -1; dist = np.inf
                for k in range(n):
                  if k != i and k!= j:
                    if distance_matrix[i, k] < dist:
                      dist = distance_matrix[i,k]
                      nn_idx = k

                if nn_idx != -1:
                    a = distance_matrix[i, j]
                    b = distance_matrix[i, nn_idx]
                    c = distance_matrix[j, nn_idx]
                    # Catch exception arising from floating errors.
                    try:
                      angle_heuristic = (a**2 + b**2 - c**2) / (2 * a * b + epsilon)
                      angle_heuristic = np.clip(angle_heuristic, -1.0, 1.0)  # Clip cosine value within valid range
                      angle_heuristic = (angle_heuristic + 1.0) / 2.0 # maps the angle to be between 0 and 1
                    except Exception as e:
                        angle_heuristic = 0.5 # sets angle heuristic to indifference
            # Depot proximity: if both i and j are far from the depot (node 0), penalize the edge.
            depot_proximity_penalty = (distance_matrix[0, i] + distance_matrix[0, j]) / (2 * np.max(distance_matrix) + epsilon) # normalized.
            depot_proximity_heuristic = 1 - np.clip(depot_proximity_penalty, 0, 1)  # If very far, value -> 0. Otherwise, value closer to 1.

            # Combine heuristics with weights (can be tuned)
            heuristics[i, j] = (
                0.5 * distance_heuristic +
                0.15 * demand_heuristic +
                0.25 * angle_heuristic +
                0.1 * depot_proximity_heuristic
            )

    return heuristics

[Heuristics 16th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Improves upon v1 by considering demand, distance, and spatial clustering.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Avoid division by zero.
    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)

    # Combination of factors. Weights can be tuned.
    alpha = 0.5  # Importance of distance
    beta = 0.3   # Importance of demand feasibility (higher demand, lower heuristic)
    gamma = 0.2  # Importance of cluster affinity

    # Heuristic based on inverse distance
    distance_heuristic = 1 / distance_matrix

    # Heuristic based on demand feasibility.  Encourage edges to nodes
    # that are unlikely to exceed capacity *early* in a route. Penalize if connecting would
    # likely immediately exceed capacity
    demand_heuristic = np.ones_like(distance_matrix, dtype=float)
    for i in range(1, n):  # Skip depot
        for j in range(1, n): #Skip depot
            if i != j:
                if demands[i] + demands[j] > capacity:
                    demand_heuristic[i, j] = 0.1 # severely penalize the connection
                else:
                     demand_heuristic[i, j] = 1 - (demands[i] + demands[j]) / (2*capacity) # Linearly decreasing, but not lower than zero.

    # Heuristic based on spatial clustering using a simple density estimate
    # penalize for edges going outside local region to maintain more "local" routes
    cluster_heuristic = np.zeros_like(distance_matrix, dtype=float)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                 # Simple heuristic: Density based on inverse distance to other nodes
                 density_i = np.sum(1 / distance_matrix[i, 1:]) - (1/ distance_matrix[i,i]) if np.sum(1 / distance_matrix[i, 1:]) < np.inf else 0 # Avoid division by zero, substract term 1/d_ii as distance_matrix[i,i] = inf
                 density_j = np.sum(1 / distance_matrix[j, 1:]) - (1/ distance_matrix[j,j]) if np.sum(1 / distance_matrix[j, 1:]) < np.inf else 0 # Avoid division by zero
                 # penalize connections to nodes with much lower density
                 cluster_heuristic[i,j] = min(density_i, density_j) / max(density_i, density_j) if max(density_i, density_j) > 0 else 0 #Between 0 and 1

    # Combine heuristics
    heuristic_matrix = (alpha * distance_heuristic +
                        beta * demand_heuristic +
                        gamma * cluster_heuristic)

    # Depot edges should be generally favored to return to depot
    for i in range(1, n):
        heuristic_matrix[0, i] *= 1.2  # Slightly favor leaving the depot
        heuristic_matrix[i, 0] *= 1.2  # Slightly favor returning to the depot

    return heuristic_matrix

[Heuristics 17th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling principles.

    This version incorporates distance, demand, and spatial distribution to guide the search towards promising edges.

    Args:
        distance_matrix: n x n distance matrix between nodes.
        coordinates: n x 2 array of node coordinates (Euclidean).
        demands: n-dimensional array of customer demands.
        capacity: Vehicle capacity.

    Returns:
        n x n matrix of heuristic values, indicating the promise of including each edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (feel free to experiment with these)
    distance_weight = 1.0
    demand_weight = 1.0
    spatial_weight = 0.5  # weight assigned to influence of neighboring demand
    depot_proximity_weight = 0.5  # reward proximity to depot

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # 1. Distance component: Inverse of distance (shorter is better)
            distance_heuristic = distance_weight / (distance_matrix[i, j] + 1e-9) # avoid division by zero

            # 2. Demand component: Penalize edges connecting nodes with high combined demand relative to capacity.
            #    We are using harmonic mean because high demands from either customer should deter the connection
            demand_i = demands[i]
            demand_j = demands[j]
            combined_demand = (2 * demand_i * demand_j) / (demand_i + demand_j + 1e-9)

            demand_heuristic = (1- min(1.0, combined_demand / capacity)) * demand_weight

            # 3. Spatial Distribution component: Consider nearby nodes with high demand
            spatial_heuristic = 0.0
            neighbor_radius = np.mean(distance_matrix) / 2  # Dynamically adjusted radius
            neighbor_count = 0
            for k in range(n):
                if k != i and k != j and distance_matrix[i, k] < neighbor_radius: # find neighbor
                    spatial_heuristic += demands[k]
                    neighbor_count += 1
                if k != i and k != j and distance_matrix[j, k] < neighbor_radius:
                    spatial_heuristic += demands[k]
                    neighbor_count += 1
            if neighbor_count > 0:
                 spatial_heuristic = (1 - min(1, spatial_heuristic / (neighbor_count * capacity + 1e-9))) * spatial_weight
            else:
                spatial_heuristic = spatial_weight

            #4. Proximity to Depot
            depot_proximity = 1 - 0.9 * max(distance_matrix[0,i], distance_matrix[0,j]) / np.mean(distance_matrix)
            depot_heuristic = depot_proximity * depot_proximity_weight

            # Combine components - adjust weights to fine-tune the heuristic
            heuristic_matrix[i, j] = distance_heuristic + demand_heuristic + spatial_heuristic + depot_heuristic

    return heuristic_matrix

[Heuristics 18th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling principles.

    This version incorporates distance, demand, and spatial distribution to guide the search towards promising edges.

    Args:
        distance_matrix: n x n distance matrix between nodes.
        coordinates: n x 2 array of node coordinates (Euclidean).
        demands: n-dimensional array of customer demands.
        capacity: Vehicle capacity.

    Returns:
        n x n matrix of heuristic values, indicating the promise of including each edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (feel free to experiment with these)
    distance_weight = 1.0
    demand_weight = 1.0
    spatial_weight = 0.5  # weight assigned to influence of neighboring demand
    depot_proximity_weight = 0.5  # reward proximity to depot

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # 1. Distance component: Inverse of distance (shorter is better)
            distance_heuristic = distance_weight / (distance_matrix[i, j] + 1e-9) # avoid division by zero

            # 2. Demand component: Penalize edges connecting nodes with high combined demand relative to capacity.
            #    We are using harmonic mean because high demands from either customer should deter the connection
            demand_i = demands[i]
            demand_j = demands[j]
            combined_demand = (2 * demand_i * demand_j) / (demand_i + demand_j + 1e-9)

            demand_heuristic = (1- min(1.0, combined_demand / capacity)) * demand_weight

            # 3. Spatial Distribution component: Consider nearby nodes with high demand
            spatial_heuristic = 0.0
            neighbor_radius = np.mean(distance_matrix) / 2  # Dynamically adjusted radius
            neighbor_count = 0
            for k in range(n):
                if k != i and k != j and distance_matrix[i, k] < neighbor_radius: # find neighbor
                    spatial_heuristic += demands[k]
                    neighbor_count += 1
                if k != i and k != j and distance_matrix[j, k] < neighbor_radius:
                    spatial_heuristic += demands[k]
                    neighbor_count += 1
            if neighbor_count > 0:
                 spatial_heuristic = (1 - min(1, spatial_heuristic / (neighbor_count * capacity + 1e-9))) * spatial_weight
            else:
                spatial_heuristic = spatial_weight

            #4. Proximity to Depot
            depot_proximity = 1 - 0.9 * max(distance_matrix[0,i], distance_matrix[0,j]) / np.mean(distance_matrix)
            depot_heuristic = depot_proximity * depot_proximity_weight

            # Combine components - adjust weights to fine-tune the heuristic
            heuristic_matrix[i, j] = distance_heuristic + demand_heuristic + spatial_heuristic + depot_heuristic

    return heuristic_matrix

[Heuristics 19th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic for CVRP based on distance, demand, and angle.

    Args:
        distance_matrix: Distance matrix between nodes.
        coordinates: Coordinates of each node.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        A matrix indicating the desirability of each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate angle between nodes relative to depot
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0
                continue

            distance_factor = 1 / distance_matrix[i, j]

            # Penalize edges connecting nodes with high demands if either i or j is not the depot
            demand_penalty = 1.0
            if i != 0 and j != 0:
                demand_penalty = 1 / (demands[i] + demands[j])

            # Encourage edges connecting nodes with similar angles (close to the depot)
            angle_diff = abs(angles[i] - angles[j])
            angle_factor = np.exp(-angle_diff)  # Exponential decay based on angle difference

            heuristic_matrix[i, j] = distance_factor * demand_penalty * angle_factor

    return heuristic_matrix

[Heuristics 20th]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for CVRP using a combination of distance, demand, and angle considerations.

    Args:
        distance_matrix: Distance matrix between nodes (n x n).
        coordinates: Euclidean coordinates of nodes (n x 2).
        demands: Customer demands (n).
        capacity: Vehicle capacity.

    Returns:
        Heuristic matrix (n x n) indicating the desirability of including each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to control the influence of different factors
    distance_weight = 0.5
    demand_weight = 0.3
    angle_weight = 0.2

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
            else:
                # Distance factor: Inverse of distance
                distance_factor = 1 / distance_matrix[i, j]

                # Demand factor:  Encourage connecting to nodes with demands that fit vehicle capacity.
                # Penalize exceeding capacity more heavily.

                demand_factor = 1 / (demands[j] + 1e-6) # Avoid division by zero
                if demands[i] + demands[j] > capacity:
                    demand_factor /=2

                # Angle factor:  Prefer edges that don't make sharp turns
                # Calculate the angle between the vectors from node i to node j and from node 0 (depot) to node j
                if i != 0 and j != 0:
                    vector_ij = coordinates[j] - coordinates[i]
                    vector_0j = coordinates[j] - coordinates[0]

                    # Calculate the dot product and magnitudes
                    dot_product = np.dot(vector_ij, vector_0j)
                    magnitude_ij = np.linalg.norm(vector_ij)
                    magnitude_0j = np.linalg.norm(vector_0j)

                    # Calculate the cosine of the angle
                    if magnitude_ij > 0 and magnitude_0j > 0:
                        cos_angle = dot_product / (magnitude_ij * magnitude_0j)
                        # Ensure cos_angle is within [-1, 1] to avoid errors
                        cos_angle = np.clip(cos_angle, -1.0, 1.0)
                        angle = np.arccos(cos_angle)  # Angle in radians
                        angle_factor = 1 - (angle / np.pi) # Normalize between 0 and 1

                    else:
                        angle_factor = 0.5 # Neutral value if vectors are zero
                else:
                    angle_factor = 0.5 #Neutral if one node is the depot.


                # Combine the factors
                heuristic_matrix[i, j] = (
                    distance_weight * distance_factor +
                    demand_weight * demand_factor +
                    angle_weight * angle_factor
                )

    return heuristic_matrix


### Guide
- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.
- The response in Markdown style and nothing else has the following structure:
"**Analysis:**
**Experience:**"
In there:
+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.
Example: "Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:"

+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).

I'm going to tip $999K for a better heuristics! Let's think step by step.
[2025-04-29 06:24:31,585][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:24:36,468][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:24:36,469][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:24:36,470][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:36,470][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:36,472][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:36,496][root][INFO] - Comprehensive reflection Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.

User Prompt: 
Your task is to redefine 'Current self-reflection' paying attention to avoid all things in 'Ineffective self-reflection' in order to come up with ideas to design better heuristics.

### Current self-reflection
When designing heuristics, consider incorporating diverse factors beyond basic distance and demand. Spatial relationships, such as clustering and gravitational attraction, can significantly improve performance. Normalizing the heuristic output and carefully tuning the weights of different factors are also critical for stability and adaptability.
None

### Ineffective self-reflection
None

Response (<100 words) should have 4 bullet points: Keywords, Advice, Avoid, Explanation.
I'm going to tip $999K for a better heuristics! Let's think step by step.
[2025-04-29 06:24:36,498][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:24:39,466][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:24:39,468][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:24:39,470][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:39,470][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:39,473][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:39,486][root][INFO] - Crossover Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.


### Better code
def heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    Generates heuristics for CVRP based on distance, demand, and vehicle capacity,
    prioritizing edges that connect nodes with moderate demand that, when combined,
    do not exceed vehicle capacity, and penalizing edges that are too long or
    connect to very high-demand nodes. It also gives slight preference to shorter
    edges overall, and connections to depot are given higher consideration

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Demand of each node (n). Depot demand is demands[0].
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Heuristic values for each edge (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Scale distance for better handling
    scaled_distance = distance_matrix / np.max(distance_matrix)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Base heuristic: Inverse of distance (shorter edges are better)
            heuristic_matrix[i, j] = 1 / (scaled_distance[i, j] + 0.0001) #prevent division by zero

            # Demand consideration: Nodes with moderate demand are more desirable
            demand_penalty = (demands[i] + demands[j]) / (2 * capacity)
            heuristic_matrix[i, j] /= (demand_penalty + 0.5)  # Penalty increases as combined demand approaches capacity. Avoid division by zero

            # Heavily Penalize edges connecting nodes with extreme demands if demand will overflow
            if demands[i] > 0.7 * capacity or demands[j] > 0.7 * capacity:
                heuristic_matrix[i, j] /= 5  # Much stronger penalty

            # Add slight preference for edges close to depot
            if i == 0 or j == 0:
                heuristic_matrix[i, j] *= 1.5
            
            # Small boost for mid-range demand nodes as they have higher chance of being combined
            if 0.15*capacity < demands[i] < 0.45*capacity or 0.15*capacity < demands[j] < 0.45*capacity:
                heuristic_matrix[i, j] *= 1.1

    return heuristic_matrix

### Worse code
def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    Heuristic function for CVRP using a combination of distance, demand, and angle considerations.

    Args:
        distance_matrix: Distance matrix between nodes (n x n).
        coordinates: Euclidean coordinates of nodes (n x 2).
        demands: Customer demands (n).
        capacity: Vehicle capacity.

    Returns:
        Heuristic matrix (n x n) indicating the desirability of including each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to control the influence of different factors
    distance_weight = 0.5
    demand_weight = 0.3
    angle_weight = 0.2

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
            else:
                # Distance factor: Inverse of distance
                distance_factor = 1 / distance_matrix[i, j]

                # Demand factor:  Encourage connecting to nodes with demands that fit vehicle capacity.
                # Penalize exceeding capacity more heavily.

                demand_factor = 1 / (demands[j] + 1e-6) # Avoid division by zero
                if demands[i] + demands[j] > capacity:
                    demand_factor /=2

                # Angle factor:  Prefer edges that don't make sharp turns
                # Calculate the angle between the vectors from node i to node j and from node 0 (depot) to node j
                if i != 0 and j != 0:
                    vector_ij = coordinates[j] - coordinates[i]
                    vector_0j = coordinates[j] - coordinates[0]

                    # Calculate the dot product and magnitudes
                    dot_product = np.dot(vector_ij, vector_0j)
                    magnitude_ij = np.linalg.norm(vector_ij)
                    magnitude_0j = np.linalg.norm(vector_0j)

                    # Calculate the cosine of the angle
                    if magnitude_ij > 0 and magnitude_0j > 0:
                        cos_angle = dot_product / (magnitude_ij * magnitude_0j)
                        # Ensure cos_angle is within [-1, 1] to avoid errors
                        cos_angle = np.clip(cos_angle, -1.0, 1.0)
                        angle = np.arccos(cos_angle)  # Angle in radians
                        angle_factor = 1 - (angle / np.pi) # Normalize between 0 and 1

                    else:
                        angle_factor = 0.5 # Neutral value if vectors are zero
                else:
                    angle_factor = 0.5 #Neutral if one node is the depot.


                # Combine the factors
                heuristic_matrix[i, j] = (
                    distance_weight * distance_factor +
                    demand_weight * demand_factor +
                    angle_weight * angle_factor
                )

    return heuristic_matrix

### Analyze & experience
- Comparing (1st) vs (20th), we see the best heuristic incorporates a gravitational attraction component, while the worst uses a simpler angle factor. Also, the best normalizes the combined heuristics to between 0 and 1, potentially improving stability. The worst uses fixed weights, potentially limiting adaptability.

Comparing (2nd best) vs (2nd worst), we see that "Heuristics 2nd" and "Heuristics 19th" exhibit noticeable distinctions. "Heuristics 2nd" employs gravitational attraction, demand feasibility, and depot proximity while "Heuristics 19th" focuses on angle relative to the depot.

Comparing (1st) vs (2nd), there are no difference so both are the same.

Comparing (3rd) vs (4th), we see that "Heuristics 3rd" calculates an angle between edges (i->j) and (j-> depot) as a proxy for a smooth route, also including additional penalty for high demand customers. "Heuristics 4th" measures the angle each node creates to the depot and combine angle and demand penalty.

Comparing (second worst) vs (worst), "Heuristics 19th" calculates angle between nodes relative to the depot, encouraging edges connecting nodes with similar angles. "Heuristics 20th" calculates angle between the vectors from node i to node j and from node 0 (depot) to node j, preferring edges that don't make sharp turns.

Overall: The better heuristics incorporate more sophisticated factors like gravitational attraction and spatial distribution, while also normalizing the output. Simpler approaches relying solely on distance, demand, and basic angle calculations tend to perform worse. The weighting of different factors and handling of edge cases (e.g., division by zero) also seem to play a crucial role. Depot proximity is a frequently used concept that appears in many of the better heuristics.
- - Try combining various factors to determine how promising it is to select an edge.
- Try sparsifying the matrix by setting unpromising elements to zero.
Okay, let's redefine effective self-reflection for heuristic design.

*   **Keywords:** Multi-faceted Evaluation, Adaptive Tuning, Contextual Awareness, Performance Analysis.
*   **Advice:** Actively analyze *why* a heuristic succeeds/fails in specific instances. Consider environmental factors (e.g., problem structure, data distribution). Prioritize adaptive weight tuning during execution.
*   **Avoid:** Focusing solely on overall averages. Ignoring the influence of problem-specific characteristics. Fixed or arbitrary parameter settings.
*   **Explanation:** Shift from broad considerations to a deep understanding of performance drivers. This enables targeted improvements and robust heuristic design.


Your task is to write an improved function `heuristics_v2` by COMBINING elements of two above heuristics base Analyze & experience.
Output the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.

I'm going to tip $999K for a better heuristics! Let's think step by step.
[2025-04-29 06:24:39,513][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:24:39,515][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:24:43,483][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:24:43,484][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:24:43,485][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:43,485][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:43,486][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:24:43,487][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:43,547][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:24:43,548][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:24:43,549][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:43,549][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:43,550][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:24:43,550][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:47,723][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:24:47,726][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:24:47,728][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:47,728][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:47,730][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:24:47,732][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:49,605][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:24:49,609][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:24:49,610][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:49,610][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:49,612][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:24:49,613][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:52,228][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:24:52,231][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:24:52,233][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:52,233][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:52,236][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:24:52,237][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:54,507][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:24:54,511][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:24:54,512][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:54,512][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:54,515][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:24:54,517][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:56,135][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:24:56,138][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:24:56,140][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:56,140][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:56,142][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:24:56,143][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:59,424][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:24:59,427][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:24:59,428][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:59,429][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:24:59,431][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:24:59,432][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:25:00,835][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:25:00,837][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:25:00,838][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:25:00,838][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:25:00,840][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:25:04,127][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:25:04,130][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:25:04,131][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:25:04,131][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:25:04,132][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:25:04,160][root][INFO] - Iteration 2: Running Code 0
[2025-04-29 06:25:10,079][root][INFO] - Iteration 2: Code Run 0 successful!
[2025-04-29 06:25:10,080][root][INFO] - Iteration 2: Running Code 1
[2025-04-29 06:25:17,001][root][INFO] - Iteration 2: Code Run 1 successful!
[2025-04-29 06:25:17,001][root][INFO] - Iteration 2: Running Code 2
[2025-04-29 06:25:24,924][root][INFO] - Iteration 2: Code Run 2 successful!
[2025-04-29 06:25:24,924][root][INFO] - Iteration 2: Running Code 3
[2025-04-29 06:25:33,112][root][INFO] - Iteration 2: Code Run 3 successful!
[2025-04-29 06:25:33,112][root][INFO] - Iteration 2: Running Code 4
[2025-04-29 06:25:41,602][root][INFO] - Iteration 2: Code Run 4 successful!
[2025-04-29 06:25:41,603][root][INFO] - Iteration 2: Running Code 5
[2025-04-29 06:25:50,923][root][INFO] - Iteration 2: Code Run 5 successful!
[2025-04-29 06:25:50,923][root][INFO] - Iteration 2: Running Code 6
[2025-04-29 06:26:01,028][root][INFO] - Iteration 2: Code Run 6 successful!
[2025-04-29 06:26:01,028][root][INFO] - Iteration 2: Running Code 7
[2025-04-29 06:26:12,090][root][INFO] - Iteration 2: Code Run 7 successful!
[2025-04-29 06:26:12,090][root][INFO] - Iteration 2: Running Code 8
[2025-04-29 06:26:24,604][root][INFO] - Iteration 2: Code Run 8 successful!
[2025-04-29 06:26:24,604][root][INFO] - Iteration 2: Running Code 9
[2025-04-29 06:26:36,057][root][INFO] - Iteration 2: Code Run 9 successful!
[2025-04-29 06:26:36,068][root][INFO] - Iteration 2, response_id 0: Objective value: 21.731926105631082
[2025-04-29 06:26:39,337][root][INFO] - Iteration 2, response_id 1: Objective value: 21.120337032718915
[2025-04-29 06:26:39,354][root][INFO] - Iteration 2, response_id 2: Objective value: 10.313319677036498
[2025-04-29 06:27:11,095][root][INFO] - Iteration 2, response_id 3: Objective value: 18.698241227290584
[2025-04-29 06:27:23,420][root][INFO] - Iteration 2, response_id 4: Objective value: 20.389559771858693
[2025-04-29 06:27:23,431][root][INFO] - Iteration 2, response_id 5: Objective value: 10.289470385124009
[2025-04-29 06:27:23,444][root][INFO] - Iteration 2, response_id 6: Objective value: 11.53264689507572
[2025-04-29 06:27:36,280][root][INFO] - Iteration 2, response_id 7: Objective value: 20.102892395991827
[2025-04-29 06:27:40,164][root][INFO] - Iteration 2, response_id 8: Objective value: 21.277719054253556
[2025-04-29 06:27:40,176][root][INFO] - Iteration 2, response_id 9: Objective value: 12.501357424723057
[2025-04-29 06:27:40,178][root][INFO] - Iteration 2 finished...
[2025-04-29 06:27:40,178][root][INFO] - Best obj: 10.282342568133634, Best Code Path: problem_iter1_code16.py
[2025-04-29 06:27:40,178][root][INFO] - LLM usage: prompt_tokens = 45281, completion_tokens = 25433
[2025-04-29 06:27:40,179][root][INFO] - Function Evals: 41
[2025-04-29 06:27:40,182][root][INFO] - Mutation Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.
The `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.


Current heuristics:
def heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates:
    1.  Distance: Edges with shorter distances are preferred.
    2.  Demand Feasibility:  Penalizes edges that would immediately violate capacity constraints if used early in a route.
    3.  Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.
    4.  Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will "attract" closer nodes to form clusters.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Add a small value to avoid division by zero
    epsilon = 1e-6

    # 1. Distance component (inverse relationship)
    distance_heuristic = 1 / (distance_matrix + epsilon)

    # 2. Demand Feasibility component
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0  # No self-loops

            # If using this edge would exceed vehicle capacity (assuming starting from depot), penalize
            if demands[i] + demands[j] > capacity and i == 0: # starting node
                demand_heuristic[i, j] = 0.1  # A small value but not zero so it is not totally ignored
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = 0.1
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                 demand_heuristic[i,j] = 0.05


    # 3. Depot Proximity (encourage returning to depot if far and demand is high)
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):  # Exclude depot itself
        # Calculate average distance from node i to all other nodes (excluding the depot)
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0] # If only one other point exist use the distance to depot.

        # Encourage going back to the depot from this node IF it is far and demands are relatively high.
        # Depot preference is weighted based on avg_distance and demand compared to capacity
        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)
        depot_heuristic[i, 0] = depot_preference
        depot_heuristic[0, i] = depot_preference #symmetry

    # 4. Gravitational Attraction: Node `i` attracts closeby node `j`
    gravitational_heuristic = np.zeros((n, n))
    gravitational_constant = 1.0  # Adjust to control attraction strength.
    for i in range(1, n):  # Start from 1 to exclude the depot itself as a gravity center. Depot is served by the previous depot_heuristic.
        for j in range(1, n): # Start from 1 to exclude the depot itself being attracted by the gravitational heuristic.

            mass_i = demands[i]
            mass_j = demands[j]
            if i == j:
                gravitational_heuristic[i,j] = 0
                continue
            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon) # F = G*m1*m2/r^2

    # Combine the heuristics
    heuristics = distance_heuristic * demand_heuristic + depot_heuristic + gravitational_heuristic


    # Normalize to be between 0 and 1, can help stability of stochastic sampling methods
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics

Now, think outside the box write a mutated function `heuristics_v2` better than current version.
You can use some hints below:
- - Try combining various factors to determine how promising it is to select an edge.
- Try sparsifying the matrix by setting unpromising elements to zero.
Okay, let's redefine effective self-reflection for heuristic design.

*   **Keywords:** Multi-faceted Evaluation, Adaptive Tuning, Contextual Awareness, Performance Analysis.
*   **Advice:** Actively analyze *why* a heuristic succeeds/fails in specific instances. Consider environmental factors (e.g., problem structure, data distribution). Prioritize adaptive weight tuning during execution.
*   **Avoid:** Focusing solely on overall averages. Ignoring the influence of problem-specific characteristics. Fixed or arbitrary parameter settings.
*   **Explanation:** Shift from broad considerations to a deep understanding of performance drivers. This enables targeted improvements and robust heuristic design.


Output code only and enclose your code with Python code block: ```python ... ```.
I'm going to tip $999K for a better solution!
[2025-04-29 06:27:40,184][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:27:40,185][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:27:48,655][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:27:48,673][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:27:48,673][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:27:48,674][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:27:48,674][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:27:48,675][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:27:50,428][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:27:50,430][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:27:50,431][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:27:50,431][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:27:50,432][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:27:50,432][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:27:58,938][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:27:58,941][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:27:58,943][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:27:58,943][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:27:58,946][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:27:58,947][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:27:59,689][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:27:59,692][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:27:59,693][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:27:59,694][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:27:59,696][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:28:07,143][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:28:07,146][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:28:07,148][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:28:07,148][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:28:07,151][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:28:07,171][root][INFO] - Iteration 3: Running Code 0
[2025-04-29 06:28:12,830][root][INFO] - Iteration 3: Code Run 0 successful!
[2025-04-29 06:28:12,830][root][INFO] - Iteration 3: Running Code 1
[2025-04-29 06:28:19,411][root][INFO] - Iteration 3: Code Run 1 successful!
[2025-04-29 06:28:19,412][root][INFO] - Iteration 3: Running Code 2
[2025-04-29 06:28:27,334][root][INFO] - Iteration 3: Code Run 2 successful!
[2025-04-29 06:28:27,334][root][INFO] - Iteration 3: Running Code 3
[2025-04-29 06:28:35,558][root][INFO] - Iteration 3: Code Run 3 successful!
[2025-04-29 06:28:35,559][root][INFO] - Iteration 3: Running Code 4
[2025-04-29 06:28:43,828][root][INFO] - Iteration 3: Code Run 4 successful!
[2025-04-29 06:28:50,365][root][INFO] - Iteration 3, response_id 0: Objective value: 10.337038682926385
[2025-04-29 06:28:59,278][root][INFO] - Iteration 3, response_id 1: Objective value: 11.044227313497643
[2025-04-29 06:29:08,014][root][INFO] - Iteration 3, response_id 2: Objective value: 11.62739944952315
[2025-04-29 06:29:14,022][root][INFO] - Iteration 3, response_id 3: Objective value: 10.757687488118044
[2025-04-29 06:29:17,954][root][INFO] - Iteration 3, response_id 4: Objective value: 10.09120235996582
[2025-04-29 06:29:17,955][root][INFO] - Iteration 3: Elitist: 10.09120235996582
[2025-04-29 06:29:17,955][root][INFO] - Iteration 3 finished...
[2025-04-29 06:29:17,955][root][INFO] - Best obj: 10.09120235996582, Best Code Path: problem_iter3_code4.py
[2025-04-29 06:29:17,956][root][INFO] - LLM usage: prompt_tokens = 46768, completion_tokens = 26488
[2025-04-29 06:29:17,956][root][INFO] - Function Evals: 46
[2025-04-29 06:29:17,957][root][INFO] - Harmony Search Prompt: 
System Prompt: 
You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.
User Prompt: 
[code]
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates:
    1. Distance: Edges with shorter distances are preferred.
    2. Demand Feasibility: Penalizes edges that would immediately violate capacity constraints if used early in a route.
    3. Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.
    4. Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will "attract" closer nodes to form clusters.
    5. Savings Heuristic Integration: Incorporates the savings heuristic to encourage merging routes.
    6. Sparsification: Sets unpromising edges to zero to focus the search.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))
    epsilon = 1e-6

    # 1. Distance component
    distance_heuristic = 1 / (distance_matrix + epsilon)

    # 2. Demand Feasibility
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            if demands[i] + demands[j] > capacity and i == 0:
                demand_heuristic[i, j] = 0.1
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = 0.1
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                demand_heuristic[i,j] = 0.05

    # 3. Depot Proximity
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]
        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)
        depot_heuristic[i, 0] = depot_preference
        depot_heuristic[0, i] = depot_preference

    # 4. Gravitational Attraction
    gravitational_heuristic = np.zeros((n, n))
    gravitational_constant = 1.0
    for i in range(1, n):
        for j in range(1, n):
            mass_i = demands[i]
            mass_j = demands[j]
            if i == j:
                gravitational_heuristic[i,j] = 0
                continue
            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)

    # 5. Savings Heuristic
    savings_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_heuristic[i, j] = savings
            savings_heuristic[j, i] = savings  # Savings are symmetric

    # Combine the heuristics with adaptive weights.  Weights could be tuned by a metaheuristic
    alpha = 0.4
    beta = 0.2
    gamma = 0.15
    delta = 0.15
    eta = 0.1

    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * gravitational_heuristic + delta * savings_heuristic

    # 6. Sparsification
    # Only keep edges with a heuristic value above a certain threshold or that are among the k-nearest neighbors.

    k_nearest = 10 #consider only k-nearest neighbors.
    threshold = np.percentile(heuristics[heuristics > 0], 30)  # Dynamic threshold (e.g., 30th percentile)

    for i in range(n):
        # Find k-nearest neighbors
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] #excluding self loop and depot

        for j in range(n):
            if heuristics[i, j] < threshold and j not in nearest_neighbors:
                heuristics[i, j] = 0

    # Normalize to be between 0 and 1
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics

Now extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.

- Output code only and enclose your code with Python code block: ```python ... ```.
- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```.
[2025-04-29 06:29:17,960][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:29:29,978][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:29:29,981][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:29:29,982][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:29:29,983][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:29:29,986][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:29:29,992][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                   demand_violation_penalty: float = 0.1,
                   high_demand_violation_penalty: float = 0.05,
                   gravitational_constant: float = 1.0,
                   alpha: float = 0.4,
                   beta: float = 0.2,
                   gamma: float = 0.15,
                   delta: float = 0.1,
                   eta: float = 0.1,
                   k_nearest: int = 10,
                   threshold_percentile: float = 30.0) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates:
    1. Distance: Edges with shorter distances are preferred.
    2. Demand Feasibility: Penalizes edges that would immediately violate capacity constraints if used early in a route.
    3. Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.
    4. Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will "attract" closer nodes to form clusters.
    5. Savings Heuristic Integration: Incorporates the savings heuristic to encourage merging routes.
    6. Sparsification: Sets unpromising edges to zero to focus the search.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].
        capacity (int): Vehicle capacity.
        demand_violation_penalty (float): Penalty for edges violating capacity when connecting to depot. Default is 0.1.
        high_demand_violation_penalty (float): Penalty for edges violating capacity when connecting high demand nodes. Default is 0.05
        gravitational_constant (float): Gravitational constant for the gravitational attraction heuristic. Default is 1.0.
        alpha (float): Weight for the distance heuristic. Default is 0.4.
        beta (float): Weight for the depot proximity heuristic. Default is 0.2.
        gamma (float): Weight for the gravitational attraction heuristic. Default is 0.15.
        delta (float): Weight for the savings heuristic. Default is 0.1.
        eta (float): Unused weight. Default is 0.1.
        k_nearest (int): Number of nearest neighbors to consider. Default is 10.
        threshold_percentile (float): Percentile for the sparsification threshold. Default is 30.0.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))
    epsilon = 1e-6

    # 1. Distance component
    distance_heuristic = 1 / (distance_matrix + epsilon)

    # 2. Demand Feasibility
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            if demands[i] + demands[j] > capacity and i == 0:
                demand_heuristic[i, j] = demand_violation_penalty
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = demand_violation_penalty
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                demand_heuristic[i,j] = high_demand_violation_penalty

    # 3. Depot Proximity
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]
        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)
        depot_heuristic[i, 0] = depot_preference
        depot_heuristic[0, i] = depot_preference

    # 4. Gravitational Attraction
    gravitational_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            mass_i = demands[i]
            mass_j = demands[j]
            if i == j:
                gravitational_heuristic[i,j] = 0
                continue
            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)

    # 5. Savings Heuristic
    savings_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_heuristic[i, j] = savings
            savings_heuristic[j, i] = savings  # Savings are symmetric


    # Combine the heuristics with adaptive weights.  Weights could be tuned by a metaheuristic

    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * gravitational_heuristic + delta * savings_heuristic

    # 6. Sparsification
    # Only keep edges with a heuristic value above a certain threshold or that are among the k-nearest neighbors.

    threshold = np.percentile(heuristics[heuristics > 0], threshold_percentile)  # Dynamic threshold (e.g., 30th percentile)

    for i in range(n):
        # Find k-nearest neighbors
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] #excluding self loop and depot

        for j in range(n):
            if heuristics[i, j] < threshold and j not in nearest_neighbors:
                heuristics[i, j] = 0

    # Normalize to be between 0 and 1
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics
```

```python
parameter_ranges = {
    'demand_violation_penalty': (0.0, 1.0),
    'high_demand_violation_penalty': (0.0, 1.0),
    'gravitational_constant': (0.0, 5.0),
    'alpha': (0.0, 1.0),
    'beta': (0.0, 1.0),
    'gamma': (0.0, 1.0),
    'delta': (0.0, 1.0),
    'eta': (0.0, 1.0),
    'k_nearest': (1, 50),
    'threshold_percentile': (0.0, 100.0)
}
```
[2025-04-29 06:29:30,011][root][INFO] - Iteration 4: Running Code 0
[2025-04-29 06:29:32,173][root][INFO] - Iteration 4: Code Run 0 execution error!
[2025-04-29 06:29:32,173][root][INFO] - Iteration 4: Running Code 1
[2025-04-29 06:29:34,239][root][INFO] - Iteration 4: Code Run 1 execution error!
[2025-04-29 06:29:34,239][root][INFO] - Iteration 4: Running Code 2
[2025-04-29 06:29:36,297][root][INFO] - Iteration 4: Code Run 2 execution error!
[2025-04-29 06:29:36,297][root][INFO] - Iteration 4: Running Code 3
[2025-04-29 06:29:38,475][root][INFO] - Iteration 4: Code Run 3 execution error!
[2025-04-29 06:29:38,476][root][INFO] - Iteration 4: Running Code 4
[2025-04-29 06:29:40,605][root][INFO] - Iteration 4: Code Run 4 execution error!
[2025-04-29 06:29:40,620][root][INFO] - Iteration 4, response_id 0: Objective value: inf
[2025-04-29 06:29:40,622][root][INFO] - Iteration 4, response_id 1: Objective value: inf
[2025-04-29 06:29:40,623][root][INFO] - Iteration 4, response_id 2: Objective value: inf
[2025-04-29 06:29:40,625][root][INFO] - Iteration 4, response_id 3: Objective value: inf
[2025-04-29 06:29:40,879][root][INFO] - Iteration 4, response_id 4: Objective value: inf
[2025-04-29 06:29:40,882][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:29:46,552][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:29:46,557][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:29:46,559][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:29:46,559][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:29:46,562][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:29:46,565][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                   demand_penalty: float = 0.1, large_demand_penalty: float = 0.05, gravitational_constant: float = 1.0,
                   distance_weight: float = 1.0, depot_weight: float = 1.0, gravity_weight: float = 1.0,
                   epsilon: float = 1e-6) -> np.ndarray:
    """
    Combines distance, demand feasibility, depot proximity, 
    and gravitational attraction for CVRP edge prioritization.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # 1. Distance (inverse)
    distance_heuristic = 1 / (distance_matrix + epsilon)

    # 2. Demand Feasibility
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            if demands[i] + demands[j] > capacity and i == 0:
                demand_heuristic[i, j] = demand_penalty
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = demand_penalty
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                 demand_heuristic[i,j] = large_demand_penalty

    # 3. Depot Proximity
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]
        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)
        depot_heuristic[i, 0] = depot_preference
        depot_heuristic[0, i] = depot_preference

    # 4. Gravitational Attraction
    gravitational_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            mass_i = demands[i]
            mass_j = demands[j]
            if i == j:
                gravitational_heuristic[i,j] = 0
                continue
            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)

    # Combine and Normalize
    heuristics = distance_weight * distance_heuristic * demand_heuristic + depot_weight * depot_heuristic + gravity_weight * gravitational_heuristic
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics
```

```python
parameter_ranges = {
    'demand_penalty': (0.0, 1.0),
    'large_demand_penalty': (0.0, 1.0),
    'gravitational_constant': (0.0, 10.0),
    'distance_weight': (0.0, 10.0),
    'depot_weight': (0.0, 10.0),
    'gravity_weight': (0.0, 10.0),
    'epsilon': (1e-7, 1e-5)
}
```
[2025-04-29 06:29:46,574][root][INFO] - Iteration 4: Running Code 0
[2025-04-29 06:29:52,278][root][INFO] - Iteration 4: Code Run 0 successful!
[2025-04-29 06:29:52,278][root][INFO] - Iteration 4: Running Code 1
[2025-04-29 06:29:58,033][root][INFO] - Iteration 4: Code Run 1 execution error!
[2025-04-29 06:29:58,033][root][INFO] - Iteration 4: Running Code 2
[2025-04-29 06:30:03,734][root][INFO] - Iteration 4: Code Run 2 successful!
[2025-04-29 06:30:03,734][root][INFO] - Iteration 4: Running Code 3
[2025-04-29 06:30:09,448][root][INFO] - Iteration 4: Code Run 3 successful!
[2025-04-29 06:30:09,449][root][INFO] - Iteration 4: Running Code 4
[2025-04-29 06:30:15,142][root][INFO] - Iteration 4: Code Run 4 execution error!
[2025-04-29 06:30:15,143][root][INFO] - Iteration 4, response_id 0: Objective value: inf
[2025-04-29 06:30:15,145][root][INFO] - Iteration 4, response_id 1: Objective value: inf
[2025-04-29 06:30:15,146][root][INFO] - Iteration 4, response_id 2: Objective value: inf
[2025-04-29 06:30:15,147][root][INFO] - Iteration 4, response_id 3: Objective value: inf
[2025-04-29 06:30:15,639][root][INFO] - Iteration 4, response_id 4: Objective value: inf
[2025-04-29 06:30:15,643][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:30:21,079][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:30:21,082][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:30:21,083][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:30:21,083][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:30:21,086][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:30:21,087][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  demand_penalty_depot: float = 0.1, demand_penalty_other: float = 0.05,
                  gravitational_constant: float = 1.0, epsilon: float = 1e-6) -> np.ndarray:
    """
    Combines distance, demand feasibility, depot proximity, and gravitational attraction.
    Normalizes the heuristic matrix for stability.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # 1. Distance component (inverse relationship)
    distance_heuristic = 1 / (distance_matrix + epsilon)

    # 2. Demand Feasibility component
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            if demands[i] + demands[j] > capacity and i == 0:
                demand_heuristic[i, j] = demand_penalty_depot
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = demand_penalty_depot
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                 demand_heuristic[i,j] = demand_penalty_other

    # 3. Depot Proximity
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]
        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)
        depot_heuristic[i, 0] = depot_preference
        depot_heuristic[0, i] = depot_preference

    # 4. Gravitational Attraction
    gravitational_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            mass_i = demands[i]
            mass_j = demands[j]
            if i == j:
                gravitational_heuristic[i,j] = 0
                continue
            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)

    # Combine the heuristics
    heuristics = distance_heuristic * demand_heuristic + depot_heuristic + gravitational_heuristic

    # Normalize
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics
```

```python
parameter_ranges = {
    'demand_penalty_depot': (0.0, 0.2),
    'demand_penalty_other': (0.0, 0.1),
    'gravitational_constant': (0.5, 1.5),
    'epsilon': (1e-7, 1e-5)
}
```
[2025-04-29 06:30:21,096][root][INFO] - Iteration 4: Running Code 0
[2025-04-29 06:30:26,788][root][INFO] - Iteration 4: Code Run 0 successful!
[2025-04-29 06:30:26,788][root][INFO] - Iteration 4: Running Code 1
[2025-04-29 06:30:32,437][root][INFO] - Iteration 4: Code Run 1 execution error!
[2025-04-29 06:30:32,437][root][INFO] - Iteration 4: Running Code 2
[2025-04-29 06:30:38,048][root][INFO] - Iteration 4: Code Run 2 execution error!
[2025-04-29 06:30:38,048][root][INFO] - Iteration 4: Running Code 3
[2025-04-29 06:30:43,701][root][INFO] - Iteration 4: Code Run 3 execution error!
[2025-04-29 06:30:43,701][root][INFO] - Iteration 4: Running Code 4
[2025-04-29 06:30:49,353][root][INFO] - Iteration 4: Code Run 4 execution error!
[2025-04-29 06:30:49,355][root][INFO] - Iteration 4, response_id 0: Objective value: inf
[2025-04-29 06:30:49,356][root][INFO] - Iteration 4, response_id 1: Objective value: inf
[2025-04-29 06:30:49,358][root][INFO] - Iteration 4, response_id 2: Objective value: inf
[2025-04-29 06:30:49,359][root][INFO] - Iteration 4, response_id 3: Objective value: inf
[2025-04-29 06:30:49,851][root][INFO] - Iteration 4, response_id 4: Objective value: inf
[2025-04-29 06:30:49,852][root][INFO] - Iteration 4 finished...
[2025-04-29 06:30:49,852][root][INFO] - Best obj: 10.09120235996582, Best Code Path: problem_iter3_code4.py
[2025-04-29 06:30:49,852][root][INFO] - LLM usage: prompt_tokens = 49466, completion_tokens = 29474
[2025-04-29 06:30:49,853][root][INFO] - Function Evals: 46
[2025-04-29 06:30:49,854][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:30:55,798][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:30:55,801][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:30:55,803][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:30:55,803][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:30:55,806][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:30:55,839][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:30:58,882][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:30:58,885][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:30:58,887][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:30:58,887][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:30:58,890][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:30:58,931][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:30:58,932][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:31:04,494][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:31:04,497][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:31:04,498][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:04,498][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:04,500][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:31:04,502][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:05,180][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:31:05,184][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:31:05,185][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:05,185][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:05,188][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:31:05,189][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:09,966][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:31:09,969][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:31:09,970][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:09,971][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:09,972][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:09,975][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:31:12,367][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:31:12,370][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:31:12,371][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:12,372][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:12,374][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:31:12,374][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:14,821][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:31:14,822][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:31:14,823][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:14,823][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:14,823][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:31:14,824][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:17,035][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:31:17,055][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:31:17,056][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:17,056][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:17,057][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:31:17,058][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:20,703][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:31:20,706][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:31:20,707][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:20,708][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:20,710][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:31:20,711][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:22,689][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:31:22,691][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:31:22,692][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:22,693][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:22,694][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:31:22,695][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:24,818][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:31:24,821][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:31:24,822][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:24,823][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:24,824][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:26,356][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:31:26,359][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:31:26,361][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:26,361][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:26,364][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:31:26,401][root][INFO] - Iteration 5: Running Code 0
[2025-04-29 06:31:31,930][root][INFO] - Iteration 5: Code Run 0 successful!
[2025-04-29 06:31:31,930][root][INFO] - Iteration 5: Running Code 1
[2025-04-29 06:31:38,611][root][INFO] - Iteration 5: Code Run 1 successful!
[2025-04-29 06:31:38,612][root][INFO] - Iteration 5: Running Code 2
[2025-04-29 06:31:46,386][root][INFO] - Iteration 5: Code Run 2 successful!
[2025-04-29 06:31:46,386][root][INFO] - Iteration 5: Running Code 3
[2025-04-29 06:31:54,560][root][INFO] - Iteration 5: Code Run 3 successful!
[2025-04-29 06:31:54,561][root][INFO] - Iteration 5: Running Code 4
[2025-04-29 06:32:03,722][root][INFO] - Iteration 5: Code Run 4 successful!
[2025-04-29 06:32:03,722][root][INFO] - Iteration 5: Running Code 5
[2025-04-29 06:32:13,514][root][INFO] - Iteration 5: Code Run 5 successful!
[2025-04-29 06:32:13,514][root][INFO] - Iteration 5: Running Code 6
[2025-04-29 06:32:24,159][root][INFO] - Iteration 5: Code Run 6 successful!
[2025-04-29 06:32:24,159][root][INFO] - Iteration 5: Running Code 7
[2025-04-29 06:32:35,228][root][INFO] - Iteration 5: Code Run 7 successful!
[2025-04-29 06:32:35,228][root][INFO] - Iteration 5: Running Code 8
[2025-04-29 06:32:47,140][root][INFO] - Iteration 5: Code Run 8 successful!
[2025-04-29 06:32:47,140][root][INFO] - Iteration 5: Running Code 9
[2025-04-29 06:32:58,890][root][INFO] - Iteration 5: Code Run 9 successful!
[2025-04-29 06:32:58,904][root][INFO] - Iteration 5, response_id 0: Objective value: 19.597798493271714
[2025-04-29 06:33:02,635][root][INFO] - Iteration 5, response_id 1: Objective value: 16.731438784074136
[2025-04-29 06:33:37,095][root][INFO] - Iteration 5, response_id 2: Objective value: 21.906298505158222
[2025-04-29 06:33:43,870][root][INFO] - Iteration 5, response_id 3: Objective value: 18.675835363021122
[2025-04-29 06:33:49,835][root][INFO] - Iteration 5, response_id 4: Objective value: 19.650057007556647
[2025-04-29 06:33:49,849][root][INFO] - Iteration 5, response_id 5: Objective value: 13.40416685210088
[2025-04-29 06:33:50,344][root][INFO] - Iteration 5, response_id 6: Objective value: 11.704520278004587
[2025-04-29 06:34:05,108][root][INFO] - Iteration 5, response_id 7: Objective value: 19.727320651061213
[2025-04-29 06:34:08,351][root][INFO] - Iteration 5, response_id 8: Objective value: 17.778437899629022
[2025-04-29 06:34:12,165][root][INFO] - Iteration 5, response_id 9: Objective value: 20.41205460693447
[2025-04-29 06:34:12,167][root][INFO] - Iteration 5 finished...
[2025-04-29 06:34:12,167][root][INFO] - Best obj: 10.09120235996582, Best Code Path: problem_iter3_code4.py
[2025-04-29 06:34:12,167][root][INFO] - LLM usage: prompt_tokens = 90046, completion_tokens = 36501
[2025-04-29 06:34:12,168][root][INFO] - Function Evals: 56
[2025-04-29 06:34:12,170][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:34:12,172][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:34:21,480][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:34:21,484][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:34:21,485][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:34:21,486][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:34:21,488][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:34:21,490][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:34:25,967][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:34:25,968][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:34:25,969][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:34:25,969][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:34:25,970][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:34:25,971][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:34:31,551][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:34:31,553][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:34:31,553][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:34:31,553][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:34:31,554][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:34:31,555][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:34:37,923][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:34:37,926][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:34:37,928][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:34:37,928][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:34:37,931][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:34:42,601][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:34:42,602][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:34:42,603][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:34:42,603][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:34:42,605][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:34:42,623][root][INFO] - Iteration 6: Running Code 0
[2025-04-29 06:34:48,371][root][INFO] - Iteration 6: Code Run 0 successful!
[2025-04-29 06:34:48,371][root][INFO] - Iteration 6: Running Code 1
[2025-04-29 06:34:55,172][root][INFO] - Iteration 6: Code Run 1 successful!
[2025-04-29 06:34:55,172][root][INFO] - Iteration 6: Running Code 2
[2025-04-29 06:35:02,831][root][INFO] - Iteration 6: Code Run 2 successful!
[2025-04-29 06:35:02,831][root][INFO] - Iteration 6: Running Code 3
[2025-04-29 06:35:05,694][root][INFO] - Iteration 6: Code Run 3 execution error!
[2025-04-29 06:35:05,694][root][INFO] - Iteration 6: Running Code 4
[2025-04-29 06:35:13,696][root][INFO] - Iteration 6: Code Run 4 successful!
[2025-04-29 06:35:27,178][root][INFO] - Iteration 6, response_id 0: Objective value: 13.502287618875494
[2025-04-29 06:35:33,036][root][INFO] - Iteration 6, response_id 1: Objective value: 12.928376379741675
[2025-04-29 06:35:40,546][root][INFO] - Iteration 6, response_id 2: Objective value: 13.129100927189464
[2025-04-29 06:35:40,557][root][INFO] - Iteration 6, response_id 3: Objective value: inf
[2025-04-29 06:35:46,801][root][INFO] - Iteration 6, response_id 4: Objective value: 9.981977741345494
[2025-04-29 06:35:46,802][root][INFO] - Iteration 6: Elitist: 9.981977741345494
[2025-04-29 06:35:46,803][root][INFO] - Iteration 6 finished...
[2025-04-29 06:35:46,803][root][INFO] - Best obj: 9.981977741345494, Best Code Path: problem_iter6_code4.py
[2025-04-29 06:35:46,803][root][INFO] - LLM usage: prompt_tokens = 91668, completion_tokens = 38353
[2025-04-29 06:35:46,804][root][INFO] - Function Evals: 61
[2025-04-29 06:35:46,814][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:35:59,271][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:35:59,276][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:35:59,277][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:35:59,277][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:35:59,279][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:35:59,284][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                   epsilon: float = 1e-6,
                   demand_feasibility_penalty: float = 0.1,
                   demand_feasibility_large_demand_penalty: float = 0.05,
                   gravitational_constant: float = 1.0,
                   clustering_k_nearest: int = 6,
                   alpha: float = 0.3,
                   beta: float = 0.15,
                   gamma: float = 0.1,
                   delta: float = 0.15,
                   eta: float = 0.1,
                   mu: float = 0.2,
                   sparsification_k_nearest: int = 10,
                   sparsification_threshold_percentile: float = 30.0,
                   capacity_ratio_adjust_alpha: float = 0.1,
                   capacity_ratio_adjust_beta: float = -0.05) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates:
    1.  Distance: Edges with shorter distances are preferred.
    2.  Demand Feasibility: Penalizes edges that would immediately violate capacity constraints if used early in a route.
    3.  Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.
    4.  Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will "attract" closer nodes to form clusters.
    5.  Savings Heuristic Integration: Incorporates the savings heuristic to encourage merging routes.
    6.  Sparsification: Sets unpromising edges to zero to focus the search.
    7.  Clustering Coefficient: Encourages connections between nodes within local clusters
    8.  Adaptive Weighting: Adjusts weights based on problem characteristics (e.g., tightness of capacity)

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].
        capacity (int): Vehicle capacity.
        epsilon (float): Small value to avoid division by zero.
        demand_feasibility_penalty (float): Penalty for demand infeasibility when connecting to the depot.
        demand_feasibility_large_demand_penalty (float): Penalty for demand infeasibility with large customer demands.
        gravitational_constant (float): Gravitational constant for the gravitational attraction heuristic.
        clustering_k_nearest (int): Number of nearest neighbors to consider for clustering coefficient.
        alpha (float): Weight for the distance heuristic.
        beta (float): Weight for the depot proximity heuristic.
        gamma (float): Weight for the gravitational attraction heuristic.
        delta (float): Weight for the savings heuristic.
        eta (float): Unused weight.
        mu (float): Weight for the clustering heuristic.
        sparsification_k_nearest (int): Number of nearest neighbors to keep during sparsification.
        sparsification_threshold_percentile (float): Percentile threshold for sparsification.
        capacity_ratio_adjust_alpha (float): Adjustment to alpha based on capacity ratio.
        capacity_ratio_adjust_beta (float): Adjustment to beta based on capacity ratio.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # 1. Distance component
    distance_heuristic = 1 / (distance_matrix + epsilon)

    # 2. Demand Feasibility
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            if demands[i] + demands[j] > capacity and i == 0:
                demand_heuristic[i, j] = demand_feasibility_penalty
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = demand_feasibility_penalty
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                demand_heuristic[i,j] = demand_feasibility_large_demand_penalty

    # 3. Depot Proximity
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]
        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)
        depot_heuristic[i, 0] = depot_preference
        depot_heuristic[0, i] = depot_preference

    # 4. Gravitational Attraction
    gravitational_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            mass_i = demands[i]
            mass_j = demands[j]
            if i == j:
                gravitational_heuristic[i,j] = 0
                continue
            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)

    # 5. Savings Heuristic
    savings_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_heuristic[i, j] = savings
            savings_heuristic[j, i] = savings  # Savings are symmetric

    # 7. Clustering Coefficient approximation (Local Density)
    clustering_heuristic = np.zeros((n, n))
    for i in range(1, n):
        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:clustering_k_nearest] + 1  # k-nearest neighbors excluding depot, adjusting index
        for j in range(1, n):
            if i != j:
                common_neighbors = 0
                for neighbor_i in nearest_neighbors:
                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:clustering_k_nearest] + 1):
                        common_neighbors += 1
                clustering_heuristic[i, j] = common_neighbors / clustering_k_nearest

    # 8. Adaptive Weighting
    # Adjust weights based on problem characteristics (e.g., capacity tightness)
    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness

    # Adjust alpha (distance) and beta (depot) based on capacity ratio
    alpha += capacity_ratio_adjust_alpha * capacity_ratio  # Increase importance of distance if capacity is tight
    beta -= capacity_ratio_adjust_beta * capacity_ratio  # Decrease importance of going to depot if capacity is tight (more local clusters)

    # Combine the heuristics with adaptive weights. Weights could be tuned by a metaheuristic
    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * gravitational_heuristic + delta * savings_heuristic + mu * clustering_heuristic

    # 6. Sparsification
    # Only keep edges with a heuristic value above a certain threshold or that are among the k-nearest neighbors.
    threshold = np.percentile(heuristics[heuristics > 0], sparsification_threshold_percentile)  # Dynamic threshold (e.g., 30th percentile)

    for i in range(n):
        # Find k-nearest neighbors
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:sparsification_k_nearest+1] #excluding self loop and depot

        for j in range(n):
            if heuristics[i, j] < threshold and j not in nearest_neighbors:
                heuristics[i, j] = 0

    # Normalize to be between 0 and 1
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics
```

```python
parameter_ranges = {
    'epsilon': (1e-7, 1e-5),
    'demand_feasibility_penalty': (0.05, 0.2),
    'demand_feasibility_large_demand_penalty': (0.01, 0.1),
    'gravitational_constant': (0.5, 2.0),
    'clustering_k_nearest': (3.0, 10.0),
    'alpha': (0.1, 0.5),
    'beta': (0.05, 0.3),
    'gamma': (0.05, 0.2),
    'delta': (0.05, 0.3),
    'eta': (0.05, 0.2),
    'mu': (0.1, 0.3),
    'sparsification_k_nearest': (5.0, 15.0),
    'sparsification_threshold_percentile': (10.0, 50.0),
    'capacity_ratio_adjust_alpha': (0.05, 0.2),
    'capacity_ratio_adjust_beta': (-0.2, -0.01)
}
```
[2025-04-29 06:35:59,300][root][INFO] - Iteration 7: Running Code 0
[2025-04-29 06:36:01,531][root][INFO] - Iteration 7: Code Run 0 execution error!
[2025-04-29 06:36:01,531][root][INFO] - Iteration 7: Running Code 1
[2025-04-29 06:36:03,675][root][INFO] - Iteration 7: Code Run 1 execution error!
[2025-04-29 06:36:03,676][root][INFO] - Iteration 7: Running Code 2
[2025-04-29 06:36:05,806][root][INFO] - Iteration 7: Code Run 2 execution error!
[2025-04-29 06:36:05,806][root][INFO] - Iteration 7: Running Code 3
[2025-04-29 06:36:07,846][root][INFO] - Iteration 7: Code Run 3 execution error!
[2025-04-29 06:36:07,846][root][INFO] - Iteration 7: Running Code 4
[2025-04-29 06:36:09,947][root][INFO] - Iteration 7: Code Run 4 execution error!
[2025-04-29 06:36:09,963][root][INFO] - Iteration 7, response_id 0: Objective value: inf
[2025-04-29 06:36:09,966][root][INFO] - Iteration 7, response_id 1: Objective value: inf
[2025-04-29 06:36:09,968][root][INFO] - Iteration 7, response_id 2: Objective value: inf
[2025-04-29 06:36:09,969][root][INFO] - Iteration 7, response_id 3: Objective value: inf
[2025-04-29 06:36:10,236][root][INFO] - Iteration 7, response_id 4: Objective value: inf
[2025-04-29 06:36:10,239][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:36:18,607][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:36:18,609][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:36:18,610][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:36:18,610][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:36:18,611][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:36:18,613][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  epsilon: float = 1e-6, gravitational_constant: float = 1.0,
                  weight_distance: float = 0.4, weight_demand: float = 0.3,
                  weight_depot_base: float = 0.1, weight_depot_multiplier: float = 0.2,
                  weight_gravitational: float = 0.1, weight_savings_base: float = 0.1,
                  weight_savings_multiplier: float = -0.05, threshold_multiplier: float = 0.2,
                  demand_threshold: float = 0.1, capacity_threshold: float = 0.05) -> np.ndarray:
    """Heuristics for CVRP combining distance, demand, depot proximity, savings, and gravitational attraction with sparsification."""

    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # 1. Distance component
    distance_heuristic = 1 / (distance_matrix + epsilon)

    # 2. Demand Feasibility
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            if demands[i] + demands[j] > capacity and i == 0:
                demand_heuristic[i, j] = demand_threshold
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = demand_threshold
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                 demand_heuristic[i,j] = capacity_threshold


    # 3. Depot Proximity
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]

        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)
        depot_heuristic[i, 0] = depot_preference
        depot_heuristic[0, i] = depot_preference

    # 4. Gravitational Attraction
    gravitational_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            mass_i = demands[i]
            mass_j = demands[j]
            if i == j:
                gravitational_heuristic[i,j] = 0
                continue
            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)

    # 5. Savings Heuristic
    savings_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_heuristic[i, j] = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_heuristic[j, i] = savings_heuristic[i, j]

    # Adaptive Weighting
    avg_demand = np.mean(demands[1:])
    demand_ratio = avg_demand / capacity

    weight_depot = weight_depot_base + demand_ratio * weight_depot_multiplier
    weight_savings = weight_savings_base + demand_ratio * weight_savings_multiplier

    heuristics = (weight_distance * distance_heuristic * demand_heuristic +
                  weight_depot * depot_heuristic +
                  weight_gravitational * gravitational_heuristic +
                  weight_savings * savings_heuristic)

    # Sparsification
    threshold = np.mean(heuristics) * threshold_multiplier
    heuristics[heuristics < threshold] = 0

    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics
```

```python
parameter_ranges = {
    'epsilon': (1e-7, 1e-5),
    'gravitational_constant': (0.5, 1.5),
    'weight_distance': (0.2, 0.6),
    'weight_demand': (0.1, 0.5),
    'weight_depot_base': (0.05, 0.15),
    'weight_depot_multiplier': (0.1, 0.3),
    'weight_gravitational': (0.05, 0.15),
    'weight_savings_base': (0.05, 0.15),
    'weight_savings_multiplier': (-0.1, -0.01),
    'threshold_multiplier': (0.1, 0.3),
    'demand_threshold': (0.05, 0.2),
    'capacity_threshold': (0.01, 0.1)
}
```
[2025-04-29 06:36:18,625][root][INFO] - Iteration 7: Running Code 0
[2025-04-29 06:36:24,178][root][INFO] - Iteration 7: Code Run 0 execution error!
[2025-04-29 06:36:24,179][root][INFO] - Iteration 7: Running Code 1
[2025-04-29 06:36:29,861][root][INFO] - Iteration 7: Code Run 1 execution error!
[2025-04-29 06:36:29,862][root][INFO] - Iteration 7: Running Code 2
[2025-04-29 06:36:35,400][root][INFO] - Iteration 7: Code Run 2 execution error!
[2025-04-29 06:36:35,400][root][INFO] - Iteration 7: Running Code 3
[2025-04-29 06:36:41,019][root][INFO] - Iteration 7: Code Run 3 successful!
[2025-04-29 06:36:41,020][root][INFO] - Iteration 7: Running Code 4
[2025-04-29 06:36:46,519][root][INFO] - Iteration 7: Code Run 4 successful!
[2025-04-29 06:36:46,521][root][INFO] - Iteration 7, response_id 0: Objective value: inf
[2025-04-29 06:36:46,523][root][INFO] - Iteration 7, response_id 1: Objective value: inf
[2025-04-29 06:36:46,524][root][INFO] - Iteration 7, response_id 2: Objective value: inf
[2025-04-29 06:36:46,526][root][INFO] - Iteration 7, response_id 3: Objective value: inf
[2025-04-29 06:36:47,010][root][INFO] - Iteration 7, response_id 4: Objective value: inf
[2025-04-29 06:36:47,014][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:37:02,471][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:37:02,475][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:37:02,476][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:02,477][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:02,479][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:02,485][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  demand_violation_penalty: float = 0.1,
                  high_demand_violation_penalty: float = 0.05,
                  neighborhood_size: int = 5,
                  alpha: float = 0.3,
                  beta: float = 0.15,
                  gamma: float = 0.20,
                  delta: float = 0.15,
                  eta: float = 0.1,
                  phi: float = 0.1,
                  sparsity_percentile: float = 40.0,
                  k_nearest: int = 12) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates:
    1. Distance: Edges with shorter distances are preferred.
    2. Demand Feasibility: Penalizes edges that would immediately violate capacity constraints.
    3. Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.
    4. Savings Heuristic Integration: Incorporates the savings heuristic to encourage merging routes.
    5. Clustering Encouragement: Encourages connections within spatial clusters.
    6. Sparsification: Sets unpromising edges to zero to focus the search, adaptively.
    7. Adaptive Weighting: Dynamically adjusts weights based on problem characteristics.
    8. Demand Density: Considers demand density around each node.
    9. Angle to Depot: Prioritizes connections that reduce the angle formed by (node i - depot - node j) to encourage direct routes

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].
        capacity (int): Vehicle capacity.
        demand_violation_penalty (float): Penalty for edges violating capacity when one node is the depot. Default is 0.1.
        high_demand_violation_penalty (float): Penalty for edges violating capacity for other nodes. Default is 0.05.
        neighborhood_size (int): Number of neighbors to consider for demand density. Default is 5.
        alpha (float): Weight for distance heuristic. Default is 0.3.
        beta (float): Weight for depot proximity heuristic. Default is 0.15.
        gamma (float): Weight for savings heuristic. Default is 0.20.
        delta (float): Weight for clustering heuristic. Default is 0.15.
        eta (float): Weight for demand density heuristic. Default is 0.1.
        phi (float): Weight for angle heuristic. Default is 0.1.
        sparsity_percentile (float): Percentile for sparsification threshold. Default is 40.0.
        k_nearest (int): Number of nearest neighbors to consider regardless of sparsification threshold. Default is 12.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))
    epsilon = 1e-6

    # 1. Distance component (normalized)
    distance_heuristic = 1 / (distance_matrix + epsilon)
    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)

    # 2. Demand Feasibility
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            if demands[i] + demands[j] > capacity and i == 0:
                demand_heuristic[i, j] = demand_violation_penalty
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = demand_violation_penalty
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                demand_heuristic[i,j] = high_demand_violation_penalty

    # 3. Depot Proximity (normalized and enhanced)
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]
        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)
        depot_heuristic[i, 0] = depot_preference
        depot_heuristic[0, i] = depot_preference
    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)


    # 4. Savings Heuristic (normalized)
    savings_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_heuristic[i, j] = savings
            savings_heuristic[j, i] = savings  # Savings are symmetric
    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)

    # 5. Clustering Encouragement (based on spatial proximity)
    clustering_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            dist_ij = distance_matrix[i, j]
            # Encourage connections between nodes that are close relative to their distance to the depot
            clustering_heuristic[i, j] = clustering_heuristic[j, i] = np.exp(-dist_ij / (distance_matrix[i, 0] + distance_matrix[j, 0] + epsilon))

    # 6. Demand Density
    demand_density_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i == j:
                continue
            # Measure demand density around each node
            i_neighbors = np.argsort(distance_matrix[i, 1:])[:neighborhood_size] + 1
            j_neighbors = np.argsort(distance_matrix[j, 1:])[:neighborhood_size] + 1

            i_density = np.sum(demands[i_neighbors]) / np.sum(distance_matrix[i, i_neighbors]) if np.sum(distance_matrix[i, i_neighbors]) > 0 else 0
            j_density = np.sum(demands[j_neighbors]) / np.sum(distance_matrix[j, j_neighbors]) if np.sum(distance_matrix[j, j_neighbors]) > 0 else 0
            demand_density_heuristic[i,j] = demand_density_heuristic[j, i] = i_density + j_density

    demand_density_heuristic = (demand_density_heuristic - np.min(demand_density_heuristic)) / (np.max(demand_density_heuristic) - np.min(demand_density_heuristic) + epsilon)

    #7. Angle to Depot
    angle_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i == j:
                continue
            vector_i = coordinates[i] - coordinates[0]
            vector_j = coordinates[j] - coordinates[0]

            # Calculate the cosine of the angle
            cosine_angle = np.dot(vector_i, vector_j) / (np.linalg.norm(vector_i) * np.linalg.norm(vector_j) + epsilon)

            # Convert cosine to angle in radians
            angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))

            angle_heuristic[i, j] = angle_heuristic[j, i] =  1- (angle / np.pi) # Normalize to [0, 1] (higher is better, smaller angle)

    # Adaptive Weighting (adjust based on problem size/characteristics)
    n_customers = n - 1

    # Combine the heuristics
    heuristics = (alpha * distance_heuristic * demand_heuristic +
                  beta * depot_heuristic +
                  gamma * savings_heuristic +
                  delta * clustering_heuristic +
                  eta * demand_density_heuristic +
                  phi * angle_heuristic)

    # 8. Sparsification (adaptive threshold based on heuristic values)
    threshold = np.percentile(heuristics[heuristics > 0], sparsity_percentile)

    for i in range(n):
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]
        for j in range(n):
            if heuristics[i, j] < threshold and j not in nearest_neighbors:
                heuristics[i, j] = 0

    # Normalize to be between 0 and 1
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics
```

```python
parameter_ranges = {
    'demand_violation_penalty': (0.0, 0.5),
    'high_demand_violation_penalty': (0.0, 0.5),
    'neighborhood_size': (1.0, 10.0),
    'alpha': (0.0, 1.0),
    'beta': (0.0, 1.0),
    'gamma': (0.0, 1.0),
    'delta': (0.0, 1.0),
    'eta': (0.0, 1.0),
    'phi': (0.0, 1.0),
    'sparsity_percentile': (0.0, 100.0),
    'k_nearest': (1.0, 20.0)
}
```
[2025-04-29 06:37:02,500][root][INFO] - Iteration 7: Running Code 0
[2025-04-29 06:37:04,576][root][INFO] - Iteration 7: Code Run 0 execution error!
[2025-04-29 06:37:04,576][root][INFO] - Iteration 7: Running Code 1
[2025-04-29 06:37:06,614][root][INFO] - Iteration 7: Code Run 1 execution error!
[2025-04-29 06:37:06,614][root][INFO] - Iteration 7: Running Code 2
[2025-04-29 06:37:08,648][root][INFO] - Iteration 7: Code Run 2 execution error!
[2025-04-29 06:37:08,649][root][INFO] - Iteration 7: Running Code 3
[2025-04-29 06:37:10,818][root][INFO] - Iteration 7: Code Run 3 execution error!
[2025-04-29 06:37:10,818][root][INFO] - Iteration 7: Running Code 4
[2025-04-29 06:37:12,938][root][INFO] - Iteration 7: Code Run 4 execution error!
[2025-04-29 06:37:12,950][root][INFO] - Iteration 7, response_id 0: Objective value: inf
[2025-04-29 06:37:12,952][root][INFO] - Iteration 7, response_id 1: Objective value: inf
[2025-04-29 06:37:12,954][root][INFO] - Iteration 7, response_id 2: Objective value: inf
[2025-04-29 06:37:12,957][root][INFO] - Iteration 7, response_id 3: Objective value: inf
[2025-04-29 06:37:13,221][root][INFO] - Iteration 7, response_id 4: Objective value: inf
[2025-04-29 06:37:13,222][root][INFO] - Iteration 7 finished...
[2025-04-29 06:37:13,222][root][INFO] - Best obj: 9.981977741345494, Best Code Path: problem_iter6_code4.py
[2025-04-29 06:37:13,223][root][INFO] - LLM usage: prompt_tokens = 96230, completion_tokens = 43713
[2025-04-29 06:37:13,223][root][INFO] - Function Evals: 61
[2025-04-29 06:37:13,224][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:37:17,700][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:37:17,703][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:37:17,705][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:17,705][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:17,708][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:17,744][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:37:20,713][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:37:20,716][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:37:20,717][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:20,718][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:20,721][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:20,760][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:37:20,761][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:37:26,695][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:37:26,697][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:37:26,698][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:26,698][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:26,699][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:37:26,711][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:27,505][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:37:27,508][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:37:27,509][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:27,509][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:27,511][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:37:27,512][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:33,609][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:37:33,612][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:37:33,613][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:33,614][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:33,616][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:37:33,617][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:34,534][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:37:34,535][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:37:34,536][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:34,536][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:34,537][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:37:34,538][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:39,072][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:37:39,074][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:37:39,075][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:39,075][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:39,076][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:37:39,076][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:40,331][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:37:40,334][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:37:40,335][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:40,336][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:40,338][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:37:40,340][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:45,486][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:37:45,489][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:37:45,490][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:45,491][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:45,494][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:37:45,495][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:46,245][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:37:46,247][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:37:46,248][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:46,248][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:46,250][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:37:46,251][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:52,373][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:37:52,376][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:37:52,378][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:52,378][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:52,380][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:52,732][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:37:52,737][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:37:52,738][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:52,739][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:52,741][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:37:52,780][root][INFO] - Iteration 8: Running Code 0
[2025-04-29 06:37:58,464][root][INFO] - Iteration 8: Code Run 0 successful!
[2025-04-29 06:37:58,464][root][INFO] - Iteration 8: Running Code 1
[2025-04-29 06:38:05,273][root][INFO] - Iteration 8: Code Run 1 successful!
[2025-04-29 06:38:05,273][root][INFO] - Iteration 8: Running Code 2
[2025-04-29 06:38:13,215][root][INFO] - Iteration 8: Code Run 2 successful!
[2025-04-29 06:38:13,215][root][INFO] - Iteration 8: Running Code 3
[2025-04-29 06:38:21,346][root][INFO] - Iteration 8: Code Run 3 successful!
[2025-04-29 06:38:21,346][root][INFO] - Iteration 8: Running Code 4
[2025-04-29 06:38:30,546][root][INFO] - Iteration 8: Code Run 4 successful!
[2025-04-29 06:38:30,546][root][INFO] - Iteration 8: Running Code 5
[2025-04-29 06:38:40,227][root][INFO] - Iteration 8: Code Run 5 successful!
[2025-04-29 06:38:40,227][root][INFO] - Iteration 8: Running Code 6
[2025-04-29 06:38:50,351][root][INFO] - Iteration 8: Code Run 6 successful!
[2025-04-29 06:38:50,351][root][INFO] - Iteration 8: Running Code 7
[2025-04-29 06:39:01,672][root][INFO] - Iteration 8: Code Run 7 successful!
[2025-04-29 06:39:01,673][root][INFO] - Iteration 8: Running Code 8
[2025-04-29 06:39:11,990][root][INFO] - Iteration 8: Code Run 8 successful!
[2025-04-29 06:39:11,991][root][INFO] - Iteration 8: Running Code 9
[2025-04-29 06:39:23,550][root][INFO] - Iteration 8: Code Run 9 successful!
[2025-04-29 06:39:23,565][root][INFO] - Iteration 8, response_id 0: Objective value: 19.773221246454852
[2025-04-29 06:39:23,579][root][INFO] - Iteration 8, response_id 1: Objective value: 9.98576610998956
[2025-04-29 06:39:27,823][root][INFO] - Iteration 8, response_id 2: Objective value: 13.469909769062951
[2025-04-29 06:39:59,751][root][INFO] - Iteration 8, response_id 3: Objective value: 18.672463394974532
[2025-04-29 06:40:02,051][root][INFO] - Iteration 8, response_id 4: Objective value: 17.300154257032027
[2025-04-29 06:40:13,555][root][INFO] - Iteration 8, response_id 5: Objective value: 17.282885786022263
[2025-04-29 06:40:13,566][root][INFO] - Iteration 8, response_id 6: Objective value: 13.479884051888437
[2025-04-29 06:40:17,676][root][INFO] - Iteration 8, response_id 7: Objective value: 13.714407773435918
[2025-04-29 06:40:24,204][root][INFO] - Iteration 8, response_id 8: Objective value: 18.246382131152767
[2025-04-29 06:40:24,226][root][INFO] - Iteration 8, response_id 9: Objective value: 9.994638196571596
[2025-04-29 06:40:24,227][root][INFO] - Iteration 8 finished...
[2025-04-29 06:40:24,227][root][INFO] - Best obj: 9.981977741345494, Best Code Path: problem_iter6_code4.py
[2025-04-29 06:40:24,227][root][INFO] - LLM usage: prompt_tokens = 139480, completion_tokens = 52189
[2025-04-29 06:40:24,228][root][INFO] - Function Evals: 71
[2025-04-29 06:40:24,232][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:40:24,233][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:40:38,566][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:40:38,569][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:40:38,571][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:40:38,571][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:40:38,573][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:40:38,575][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:40:38,644][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:40:38,646][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:40:38,647][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:40:38,647][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:40:38,648][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:40:38,648][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:40:53,446][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:40:53,449][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:40:53,451][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:40:53,451][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:40:53,453][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:40:53,455][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:40:54,069][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:40:54,072][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:40:54,072][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:40:54,073][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:40:54,074][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:41:10,984][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:41:10,987][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:41:10,989][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:41:10,989][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:41:10,991][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:41:11,011][root][INFO] - Iteration 9: Running Code 0
[2025-04-29 06:41:16,705][root][INFO] - Iteration 9: Code Run 0 successful!
[2025-04-29 06:41:16,705][root][INFO] - Iteration 9: Running Code 1
[2025-04-29 06:41:23,426][root][INFO] - Iteration 9: Code Run 1 successful!
[2025-04-29 06:41:23,427][root][INFO] - Iteration 9: Running Code 2
[2025-04-29 06:41:31,082][root][INFO] - Iteration 9: Code Run 2 successful!
[2025-04-29 06:41:31,082][root][INFO] - Iteration 9: Running Code 3
[2025-04-29 06:41:39,160][root][INFO] - Iteration 9: Code Run 3 successful!
[2025-04-29 06:41:39,161][root][INFO] - Iteration 9: Running Code 4
[2025-04-29 06:41:47,508][root][INFO] - Iteration 9: Code Run 4 successful!
[2025-04-29 06:42:03,617][root][INFO] - Iteration 9, response_id 0: Objective value: 18.5540961837897
[2025-04-29 06:42:05,497][root][INFO] - Iteration 9, response_id 1: Objective value: 13.162313156594848
[2025-04-29 06:42:18,342][root][INFO] - Iteration 9, response_id 2: Objective value: 17.57317139585216
[2025-04-29 06:42:20,921][root][INFO] - Iteration 9, response_id 3: Objective value: 13.246724105128317
[2025-04-29 06:42:37,805][root][INFO] - Iteration 9, response_id 4: Objective value: 28.676291055248715
[2025-04-29 06:42:37,806][root][INFO] - Iteration 9 finished...
[2025-04-29 06:42:37,806][root][INFO] - Best obj: 9.981977741345494, Best Code Path: problem_iter6_code4.py
[2025-04-29 06:42:37,806][root][INFO] - LLM usage: prompt_tokens = 141461, completion_tokens = 54207
[2025-04-29 06:42:37,806][root][INFO] - Function Evals: 76
[2025-04-29 06:42:37,810][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:42:46,201][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:42:46,204][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:42:46,206][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:42:46,206][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:42:46,208][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:42:46,210][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  epsilon: float = 1e-6, demand_heuristic_depot_penalty: float = 0.1, demand_heuristic_other_penalty: float = 0.05,
                  gravitational_constant: float = 1.0, weight_distance: float = 0.4, weight_demand: float = 0.3,
                  weight_depot_base: float = 0.1, weight_depot_demand_factor: float = 0.2, weight_gravitational: float = 0.1,
                  weight_savings_base: float = 0.1, weight_savings_demand_factor: float = -0.05, k_nearest: int = 10,
                  threshold_percentile: float = 30.0) -> np.ndarray:
    """Heuristic combining distance, demand, depot proximity, savings, gravitational attraction, and adaptive weights with sparsification."""
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # 1. Distance component
    distance_heuristic = 1 / (distance_matrix + epsilon)

    # 2. Demand Feasibility
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            if demands[i] + demands[j] > capacity and i == 0:
                demand_heuristic[i, j] = demand_heuristic_depot_penalty
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = demand_heuristic_depot_penalty
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                 demand_heuristic[i,j] = demand_heuristic_other_penalty


    # 3. Depot Proximity
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]
        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)
        depot_heuristic[i, 0] = depot_preference
        depot_heuristic[0, i] = depot_preference

    # 4. Gravitational Attraction
    gravitational_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            mass_i = demands[i]
            mass_j = demands[j]
            if i == j:
                gravitational_heuristic[i,j] = 0
                continue
            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)

    # 5. Savings Heuristic
    savings_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_heuristic[i, j] = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_heuristic[j, i] = savings_heuristic[i, j]

    # Adaptive Weighting
    avg_demand = np.mean(demands[1:])
    demand_ratio = avg_demand / capacity

    weight_depot = weight_depot_base + demand_ratio * weight_depot_demand_factor
    weight_savings = weight_savings_base + demand_ratio * weight_savings_demand_factor

    heuristics = (weight_distance * distance_heuristic * demand_heuristic +
                  weight_depot * depot_heuristic +
                  weight_gravitational * gravitational_heuristic +
                  weight_savings * savings_heuristic)

    # Sparsification: k-NN
    threshold = np.percentile(heuristics[heuristics > 0], threshold_percentile)  # Adaptive threshold
    for i in range(n):
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]
        for j in range(n):
            if heuristics[i, j] < threshold and j not in nearest_neighbors:
                heuristics[i, j] = 0

    # Normalize
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics
```

```python
parameter_ranges = {
    'epsilon': (1e-07, 1e-05),
    'demand_heuristic_depot_penalty': (0.01, 0.2),
    'demand_heuristic_other_penalty': (0.01, 0.1),
    'gravitational_constant': (0.5, 1.5),
    'weight_distance': (0.2, 0.6),
    'weight_demand': (0.1, 0.5),
    'weight_depot_base': (0.05, 0.15),
    'weight_depot_demand_factor': (0.1, 0.3),
    'weight_gravitational': (0.05, 0.15),
    'weight_savings_base': (0.05, 0.15),
    'weight_savings_demand_factor': (-0.1, 0.0),
    'k_nearest': (5.0, 15.0),
    'threshold_percentile': (10.0, 50.0)
}
```
[2025-04-29 06:42:46,230][root][INFO] - Iteration 10: Running Code 0
[2025-04-29 06:42:52,033][root][INFO] - Iteration 10: Code Run 0 execution error!
[2025-04-29 06:42:52,033][root][INFO] - Iteration 10: Running Code 1
[2025-04-29 06:42:57,565][root][INFO] - Iteration 10: Code Run 1 successful!
[2025-04-29 06:42:57,566][root][INFO] - Iteration 10: Running Code 2
[2025-04-29 06:43:03,182][root][INFO] - Iteration 10: Code Run 2 successful!
[2025-04-29 06:43:03,183][root][INFO] - Iteration 10: Running Code 3
[2025-04-29 06:43:08,684][root][INFO] - Iteration 10: Code Run 3 successful!
[2025-04-29 06:43:08,684][root][INFO] - Iteration 10: Running Code 4
[2025-04-29 06:43:14,292][root][INFO] - Iteration 10: Code Run 4 successful!
[2025-04-29 06:43:14,295][root][INFO] - Iteration 10, response_id 0: Objective value: inf
[2025-04-29 06:43:14,296][root][INFO] - Iteration 10, response_id 1: Objective value: inf
[2025-04-29 06:43:14,297][root][INFO] - Iteration 10, response_id 2: Objective value: inf
[2025-04-29 06:43:14,299][root][INFO] - Iteration 10, response_id 3: Objective value: inf
[2025-04-29 06:43:14,799][root][INFO] - Iteration 10, response_id 4: Objective value: inf
[2025-04-29 06:43:14,802][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:43:24,780][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:43:24,782][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:43:24,783][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:43:24,783][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:43:24,785][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:43:24,787][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  demand_threshold_i0: float = 0.1,
                  demand_threshold_other: float = 0.05,
                  angle_normalization_epsilon: float = 1e-9,
                  dot_product_clip_min: float = -1.0,
                  dot_product_clip_max: float = 1.0,
                  weight_distance: float = 0.3,
                  weight_demand: float = 0.2,
                  weight_savings_base: float = 0.2,
                  weight_savings_demand_factor: float = 0.1,
                  weight_angle: float = 0.15,
                  weight_depot_base: float = 0.15,
                  weight_depot_demand_factor: float = 0.05,
                  sparsification_threshold_factor: float = 0.3) -> np.ndarray:
    """Heuristic combining distance, demand, savings, angle, and depot proximity with adaptive weights."""

    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))
    epsilon = 1e-6

    # 1. Distance component
    distance_heuristic = 1 / (distance_matrix + epsilon)

    # 2. Demand Feasibility
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            if demands[i] + demands[j] > capacity and i == 0:
                demand_heuristic[i, j] = demand_threshold_i0
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = demand_threshold_i0
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                 demand_heuristic[i,j] = demand_threshold_other


    # 3. Savings Heuristic
    savings_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_heuristic[i, j] = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_heuristic[j, i] = savings_heuristic[i, j]

    # 4. Angle heuristic relative to the depot
    angle_heuristic = np.zeros((n,n))
    for i in range(n):
        for j in range(n):
            if i != j:
                depot_x, depot_y = coordinates[0]
                i_x, i_y = coordinates[i]
                j_x, j_y = coordinates[j]

                vector_ij = np.array([j_x - i_x, j_y - i_y])
                vector_di = np.array([i_x - depot_x, i_y - depot_y])

                vector_ij = vector_ij / (np.linalg.norm(vector_ij) + angle_normalization_epsilon)
                vector_di = vector_di / (np.linalg.norm(vector_di) + angle_normalization_epsilon)

                dot_product = np.clip(np.dot(vector_ij, vector_di), dot_product_clip_min, dot_product_clip_max)
                angle = np.arccos(dot_product)
                angle_factor = 1 - (angle / np.pi)
                angle_heuristic[i,j] = angle_factor
            else:
                angle_heuristic[i,j] = 0


    # 5. Depot Proximity
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]

        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)
        depot_heuristic[i, 0] = depot_preference
        depot_heuristic[0, i] = depot_preference

    # Adaptive Weighting
    avg_demand = np.mean(demands[1:])
    demand_ratio = avg_demand / capacity

    weight_savings = weight_savings_base + demand_ratio * weight_savings_demand_factor
    weight_depot = weight_depot_base - demand_ratio * weight_depot_demand_factor

    heuristics = (weight_distance * distance_heuristic * demand_heuristic +
                  weight_savings * savings_heuristic +
                  weight_angle * angle_heuristic +
                  weight_depot * depot_heuristic)

    # Sparsification
    threshold = np.mean(heuristics) * sparsification_threshold_factor
    heuristics[heuristics < threshold] = 0

    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics
```

```python
parameter_ranges = {
    "demand_threshold_i0": (0.0, 0.2),
    "demand_threshold_other": (0.0, 0.2),
    "angle_normalization_epsilon": (1e-10, 1e-8),
    "dot_product_clip_min": (-1.0, -0.9),
    "dot_product_clip_max": (0.9, 1.0),
    "weight_distance": (0.1, 0.5),
    "weight_demand": (0.0, 0.4),
    "weight_savings_base": (0.0, 0.4),
    "weight_savings_demand_factor": (0.0, 0.2),
    "weight_angle": (0.0, 0.3),
    "weight_depot_base": (0.0, 0.3),
    "weight_depot_demand_factor": (0.0, 0.2),
    "sparsification_threshold_factor": (0.0, 1.0)
}
```
[2025-04-29 06:43:24,798][root][INFO] - Iteration 10: Running Code 0
[2025-04-29 06:43:30,511][root][INFO] - Iteration 10: Code Run 0 successful!
[2025-04-29 06:43:30,512][root][INFO] - Iteration 10: Running Code 1
[2025-04-29 06:43:36,212][root][INFO] - Iteration 10: Code Run 1 execution error!
[2025-04-29 06:43:36,212][root][INFO] - Iteration 10: Running Code 2
[2025-04-29 06:43:41,794][root][INFO] - Iteration 10: Code Run 2 successful!
[2025-04-29 06:43:41,794][root][INFO] - Iteration 10: Running Code 3
[2025-04-29 06:43:47,562][root][INFO] - Iteration 10: Code Run 3 execution error!
[2025-04-29 06:43:47,563][root][INFO] - Iteration 10: Running Code 4
[2025-04-29 06:43:53,241][root][INFO] - Iteration 10: Code Run 4 execution error!
[2025-04-29 06:43:53,243][root][INFO] - Iteration 10, response_id 0: Objective value: inf
[2025-04-29 06:43:53,244][root][INFO] - Iteration 10, response_id 1: Objective value: inf
[2025-04-29 06:43:53,245][root][INFO] - Iteration 10, response_id 2: Objective value: inf
[2025-04-29 06:43:53,247][root][INFO] - Iteration 10, response_id 3: Objective value: inf
[2025-04-29 06:43:53,741][root][INFO] - Iteration 10, response_id 4: Objective value: inf
[2025-04-29 06:43:53,744][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:44:00,301][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:44:00,304][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:44:00,306][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:00,306][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:00,309][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:00,311][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  epsilon: float = 1e-6,
                  demand_depot_penalty: float = 0.1,
                  demand_excess_penalty: float = 0.05,
                  alpha_tight_capacity: float = 0.6,
                  alpha_loose_capacity: float = 0.4,
                  capacity_threshold: float = 0.7,
                  k_nearest: int = 10,
                  vehicle_estimation_factor: int = 5) -> np.ndarray:
    """Combines distance, demand feasibility, depot proximity, and adaptive weights with sparsification."""
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))


    # 1. Distance component
    distance_heuristic = 1 / (distance_matrix + epsilon)

    # 2. Demand Feasibility
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            if demands[i] + demands[j] > capacity and i == 0:
                demand_heuristic[i, j] = demand_depot_penalty
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = demand_depot_penalty
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                demand_heuristic[i,j] = demand_excess_penalty


    # 3. Depot Proximity
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]
        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)
        depot_heuristic[i, 0] = depot_preference
        depot_heuristic[0, i] = depot_preference

    # Combine the heuristics with adaptive weights based on capacity tightness.
    capacity_ratio = np.sum(demands) / (capacity * (n // vehicle_estimation_factor)) # Estimate number of vehicles.

    alpha = alpha_tight_capacity if capacity_ratio < capacity_threshold else alpha_loose_capacity  # Adjust weight based on capacity tightness
    beta = 1 - alpha

    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic

    # Sparsification (k-NN)

    for i in range(n):
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]
        for j in range(n):
            if j not in nearest_neighbors:
                heuristics[i, j] = 0

    # Normalize to be between 0 and 1
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val
    return heuristics
```

```python
parameter_ranges = {
    'epsilon': (1e-7, 1e-5),
    'demand_depot_penalty': (0.01, 0.2),
    'demand_excess_penalty': (0.01, 0.1),
    'alpha_tight_capacity': (0.4, 0.8),
    'alpha_loose_capacity': (0.2, 0.6),
    'capacity_threshold': (0.5, 0.9),
    'k_nearest': (5.0, 20.0),
    'vehicle_estimation_factor': (3.0, 8.0),
}
```
[2025-04-29 06:44:00,320][root][INFO] - Iteration 10: Running Code 0
[2025-04-29 06:44:05,876][root][INFO] - Iteration 10: Code Run 0 execution error!
[2025-04-29 06:44:05,877][root][INFO] - Iteration 10: Running Code 1
[2025-04-29 06:44:11,365][root][INFO] - Iteration 10: Code Run 1 execution error!
[2025-04-29 06:44:11,366][root][INFO] - Iteration 10: Running Code 2
[2025-04-29 06:44:17,148][root][INFO] - Iteration 10: Code Run 2 successful!
[2025-04-29 06:44:17,148][root][INFO] - Iteration 10: Running Code 3
[2025-04-29 06:44:22,800][root][INFO] - Iteration 10: Code Run 3 successful!
[2025-04-29 06:44:22,800][root][INFO] - Iteration 10: Running Code 4
[2025-04-29 06:44:28,413][root][INFO] - Iteration 10: Code Run 4 execution error!
[2025-04-29 06:44:28,414][root][INFO] - Iteration 10, response_id 0: Objective value: inf
[2025-04-29 06:44:28,416][root][INFO] - Iteration 10, response_id 1: Objective value: inf
[2025-04-29 06:44:28,417][root][INFO] - Iteration 10, response_id 2: Objective value: inf
[2025-04-29 06:44:28,418][root][INFO] - Iteration 10, response_id 3: Objective value: inf
[2025-04-29 06:44:28,952][root][INFO] - Iteration 10, response_id 4: Objective value: inf
[2025-04-29 06:44:28,953][root][INFO] - Iteration 10 finished...
[2025-04-29 06:44:28,953][root][INFO] - Best obj: 9.981977741345494, Best Code Path: problem_iter6_code4.py
[2025-04-29 06:44:28,953][root][INFO] - LLM usage: prompt_tokens = 144241, completion_tokens = 57496
[2025-04-29 06:44:28,954][root][INFO] - Function Evals: 76
[2025-04-29 06:44:28,956][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:44:34,439][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:44:34,442][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:44:34,443][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:34,444][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:34,446][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:34,490][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:44:37,670][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:44:37,673][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:44:37,674][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:37,675][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:37,677][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:37,728][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:44:37,729][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:44:44,261][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:44:44,263][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:44:44,264][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:44,264][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:44,265][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:44:44,266][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:44,780][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:44:44,783][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:44:44,784][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:44,785][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:44,787][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:44,789][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:44:50,231][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:44:50,234][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:44:50,235][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:50,235][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:50,238][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:44:50,240][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:52,340][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:44:52,342][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:44:52,343][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:52,343][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:52,344][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:44:52,345][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:57,286][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:44:57,289][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:44:57,291][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:57,291][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:44:57,293][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:44:57,294][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:01,205][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:45:01,208][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:45:01,209][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:01,209][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:01,210][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:45:01,211][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:07,145][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:45:07,148][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:45:07,149][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:07,149][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:07,151][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:45:07,153][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:08,966][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:45:08,969][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:45:08,970][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:08,971][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:08,973][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:45:08,975][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:14,062][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:45:14,065][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:45:14,066][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:14,066][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:14,069][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:16,011][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:45:16,015][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:45:16,016][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:16,016][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:16,019][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:45:16,074][root][INFO] - Iteration 11: Running Code 0
[2025-04-29 06:45:21,774][root][INFO] - Iteration 11: Code Run 0 successful!
[2025-04-29 06:45:21,774][root][INFO] - Iteration 11: Running Code 1
[2025-04-29 06:45:28,557][root][INFO] - Iteration 11: Code Run 1 successful!
[2025-04-29 06:45:28,557][root][INFO] - Iteration 11: Running Code 2
[2025-04-29 06:45:36,307][root][INFO] - Iteration 11: Code Run 2 successful!
[2025-04-29 06:45:36,307][root][INFO] - Iteration 11: Running Code 3
[2025-04-29 06:45:44,401][root][INFO] - Iteration 11: Code Run 3 successful!
[2025-04-29 06:45:44,401][root][INFO] - Iteration 11: Running Code 4
[2025-04-29 06:45:52,755][root][INFO] - Iteration 11: Code Run 4 successful!
[2025-04-29 06:45:52,755][root][INFO] - Iteration 11: Running Code 5
[2025-04-29 06:46:02,003][root][INFO] - Iteration 11: Code Run 5 successful!
[2025-04-29 06:46:02,004][root][INFO] - Iteration 11: Running Code 6
[2025-04-29 06:46:11,896][root][INFO] - Iteration 11: Code Run 6 successful!
[2025-04-29 06:46:11,897][root][INFO] - Iteration 11: Running Code 7
[2025-04-29 06:46:22,427][root][INFO] - Iteration 11: Code Run 7 successful!
[2025-04-29 06:46:22,427][root][INFO] - Iteration 11: Running Code 8
[2025-04-29 06:46:32,855][root][INFO] - Iteration 11: Code Run 8 successful!
[2025-04-29 06:46:32,856][root][INFO] - Iteration 11: Running Code 9
[2025-04-29 06:46:43,208][root][INFO] - Iteration 11: Code Run 9 successful!
[2025-04-29 06:46:43,228][root][INFO] - Iteration 11, response_id 0: Objective value: 17.229428533767674
[2025-04-29 06:46:43,239][root][INFO] - Iteration 11, response_id 1: Objective value: 18.75199833617679
[2025-04-29 06:46:43,252][root][INFO] - Iteration 11, response_id 2: Objective value: 11.807624151941251
[2025-04-29 06:47:10,252][root][INFO] - Iteration 11, response_id 3: Objective value: 17.62476867437767
[2025-04-29 06:47:19,720][root][INFO] - Iteration 11, response_id 4: Objective value: 19.46957197404294
[2025-04-29 06:47:34,784][root][INFO] - Iteration 11, response_id 5: Objective value: 19.856509016676824
[2025-04-29 06:47:34,794][root][INFO] - Iteration 11, response_id 6: Objective value: 13.898930731789983
[2025-04-29 06:47:34,807][root][INFO] - Iteration 11, response_id 7: Objective value: 13.47256793983558
[2025-04-29 06:47:39,010][root][INFO] - Iteration 11, response_id 8: Objective value: 15.589110787232633
[2025-04-29 06:47:46,139][root][INFO] - Iteration 11, response_id 9: Objective value: 17.453609868871474
[2025-04-29 06:47:46,140][root][INFO] - Iteration 11 finished...
[2025-04-29 06:47:46,140][root][INFO] - Best obj: 9.981977741345494, Best Code Path: problem_iter6_code4.py
[2025-04-29 06:47:46,140][root][INFO] - LLM usage: prompt_tokens = 207669, completion_tokens = 68648
[2025-04-29 06:47:46,141][root][INFO] - Function Evals: 86
[2025-04-29 06:47:46,144][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:47:46,146][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:47:54,937][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:47:54,939][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:47:54,939][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:47:54,940][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:47:54,940][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:47:54,941][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:47:55,619][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:47:55,622][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:47:55,623][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:47:55,623][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:47:55,625][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:47:55,626][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:48:04,269][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:48:04,283][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:48:04,284][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:48:04,284][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:48:04,285][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:48:04,286][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:48:07,897][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:48:07,899][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:48:07,899][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:48:07,900][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:48:07,902][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:48:14,266][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:48:14,269][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:48:14,271][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:48:14,271][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:48:14,274][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:48:14,298][root][INFO] - Iteration 12: Running Code 0
[2025-04-29 06:48:20,026][root][INFO] - Iteration 12: Code Run 0 successful!
[2025-04-29 06:48:20,026][root][INFO] - Iteration 12: Running Code 1
[2025-04-29 06:48:26,946][root][INFO] - Iteration 12: Code Run 1 successful!
[2025-04-29 06:48:26,947][root][INFO] - Iteration 12: Running Code 2
[2025-04-29 06:48:34,864][root][INFO] - Iteration 12: Code Run 2 successful!
[2025-04-29 06:48:34,864][root][INFO] - Iteration 12: Running Code 3
[2025-04-29 06:48:43,224][root][INFO] - Iteration 12: Code Run 3 successful!
[2025-04-29 06:48:43,224][root][INFO] - Iteration 12: Running Code 4
[2025-04-29 06:48:52,362][root][INFO] - Iteration 12: Code Run 4 successful!
[2025-04-29 06:49:08,647][root][INFO] - Iteration 12, response_id 0: Objective value: 11.697514421738497
[2025-04-29 06:49:14,541][root][INFO] - Iteration 12, response_id 1: Objective value: 10.108804360758949
[2025-04-29 06:49:21,790][root][INFO] - Iteration 12, response_id 2: Objective value: 9.948078455545994
[2025-04-29 06:49:32,912][root][INFO] - Iteration 12, response_id 3: Objective value: 15.436588658809791
[2025-04-29 06:49:40,275][root][INFO] - Iteration 12, response_id 4: Objective value: 17.895110276634806
[2025-04-29 06:49:40,276][root][INFO] - Iteration 12: Elitist: 9.948078455545994
[2025-04-29 06:49:40,276][root][INFO] - Iteration 12 finished...
[2025-04-29 06:49:40,277][root][INFO] - Best obj: 9.948078455545994, Best Code Path: problem_iter12_code2.py
[2025-04-29 06:49:40,277][root][INFO] - LLM usage: prompt_tokens = 209679, completion_tokens = 70070
[2025-04-29 06:49:40,277][root][INFO] - Function Evals: 91
[2025-04-29 06:49:40,281][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:49:53,342][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:49:53,345][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:49:53,346][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:49:53,347][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:49:53,349][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:49:53,355][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  distance_scale_factor: float = 0.5,
                  demand_heuristic_value: float = 0.1,
                  demand_heuristic_value_2: float = 0.05,
                  urgency_factor: float = 5.0,
                  adaptive_gravitational_constant_factor: float = 0.2,
                  lookahead_neighbors: int = 5,
                  future_savings_weight: float = 0.1,
                  k_nearest_neighbors_clustering: int = 6,
                  k_nearest_neighbors_sparsification: int = 10,
                  sparsification_threshold: float = 25,
                  depot_heuristic_weight: float = 0.3,
                  gravitational_heuristic_weight: float = 0.2,
                  savings_heuristic_weight: float = 0.15,
                  clustering_heuristic_weight: float = 0.1,
                  alpha_slack_adjust: float = 0.1,
                  beta_slack_adjust: float = -0.1,
                  gamma_slack_adjust: float = 0.05,
                  delta_slack_adjust: float = 0.05,
                  alpha: float = 0.4,
                  beta: float = 0.2,
                  gamma: float = 0.1,
                  delta: float = 0.15,
                  eta: float = 0.15) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several improvements over v1, including:

    1.  Adaptive Distance Scaling: Dynamically adjusts the importance of distance based on problem tightness.
    2.  Refined Demand Feasibility: Considers remaining vehicle capacity for more accurate feasibility assessments.
    3.  Enhanced Depot Attraction: Uses a softmax function to prioritize returns to the depot based on urgency.
    4.  Adaptive Gravitational Constant: Adjusts the gravitational constant based on the average demand.
    5.  Edge Clustering Coefficient: Focuses on connections within high-demand clusters.
    6.  Lookahead Savings: Estimates savings based on potential future connections.
    7.  Reinforced Sparsification: Adaptively sets thresholds based on edge characteristics.
    8.  Capacity Slack Aware weight adjustments: adjusts weights based on how close total demand is to vehicle capacity.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))
    epsilon = 1e-6

    # 1. Adaptive Distance Scaling
    total_demand = np.sum(demands[1:])
    capacity_ratio = total_demand / (capacity * (n - 1))
    distance_scale = 1.0 + distance_scale_factor * capacity_ratio  # Increase distance importance if capacity is tight
    distance_heuristic = 1 / (distance_matrix * distance_scale + epsilon)

    # 2. Refined Demand Feasibility
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            #Consider the edge between depot and the node.
            if demands[i] + demands[j] > capacity and i == 0:
                demand_heuristic[i, j] = demand_heuristic_value
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = demand_heuristic_value
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                demand_heuristic[i,j] = demand_heuristic_value_2

    # 3. Enhanced Depot Attraction
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]
        urgency = np.exp(urgency_factor * (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity))
        depot_heuristic[i, 0] = urgency
        depot_heuristic[0, i] = urgency

    # 4. Adaptive Gravitational Attraction
    gravitational_heuristic = np.zeros((n, n))
    avg_demand = np.mean(demands[1:])
    adaptive_gravitational_constant = 1.0 + adaptive_gravitational_constant_factor * (avg_demand / capacity)
    for i in range(1, n):
        for j in range(1, n):
            if i == j:
                gravitational_heuristic[i,j] = 0
                continue
            mass_i = demands[i]
            mass_j = demands[j]
            gravitational_heuristic[i, j] = adaptive_gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)

    # 5. Savings Heuristic with Lookahead
    savings_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
            #Lookahead
            neighbor_i = np.argsort(distance_matrix[i, 1:])[:lookahead_neighbors] + 1
            neighbor_j = np.argsort(distance_matrix[j, 1:])[:lookahead_neighbors] + 1
            future_savings = 0
            for ni in neighbor_i:
                for nj in neighbor_j:
                    future_savings += distance_matrix[ni, 0] + distance_matrix[0, nj] - distance_matrix[ni, nj]
            savings += future_savings_weight * future_savings / (lookahead_neighbors**2 + epsilon)
            savings_heuristic[i, j] = savings
            savings_heuristic[j, i] = savings

    # 6. Edge Clustering Coefficient (focus on high-demand clusters)
    clustering_heuristic = np.zeros((n, n))
    for i in range(1, n):
        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest_neighbors_clustering] + 1
        for j in range(1, n):
            if i != j:
                common_neighbors = 0
                for neighbor_i in nearest_neighbors:
                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest_neighbors_clustering] + 1):
                        common_neighbors += 1
                clustering_heuristic[i, j] = (common_neighbors / k_nearest_neighbors_clustering) * (demands[i] + demands[j]) / (2*capacity) # Scale by demand

    # 7. Sparsification
    heuristics = (distance_heuristic * demand_heuristic)**0.5 + depot_heuristic_weight * depot_heuristic + gravitational_heuristic_weight * gravitational_heuristic + savings_heuristic_weight * savings_heuristic + clustering_heuristic_weight * clustering_heuristic
    threshold = np.percentile(heuristics[heuristics > 0], sparsification_threshold)
    for i in range(n):
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest_neighbors_sparsification+1]
        for j in range(n):
            if heuristics[i, j] < threshold and j not in nearest_neighbors:
                heuristics[i, j] = 0

    # 8. Capacity Slack Aware Weight Adjustments

    # Measure capacity slack as the percentage of unused capacity across all vehicles, assuming one vehicle per customer.
    capacity_slack = 1 - (total_demand / (capacity * (n - 1)))

    # If we have a lot of spare capacity, reduce the importance of the depot trips.
    alpha = alpha + alpha_slack_adjust*capacity_slack # Give more weight to distance
    beta = beta + beta_slack_adjust*capacity_slack  # Give less weight to depot
    gamma = gamma + gamma_slack_adjust*capacity_slack
    delta = delta + delta_slack_adjust*capacity_slack
    # Recombine heuristics with adjusted weights.
    heuristics = (distance_heuristic * demand_heuristic)**0.5 + beta * depot_heuristic + gamma * gravitational_heuristic + delta * savings_heuristic + eta * clustering_heuristic
    # Normalize
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics
```

```python
parameter_ranges = {
    'distance_scale_factor': (0.0, 1.0),
    'demand_heuristic_value': (0.0, 0.5),
    'demand_heuristic_value_2': (0.0, 0.5),
    'urgency_factor': (1.0, 10.0),
    'adaptive_gravitational_constant_factor': (0.0, 0.5),
    'lookahead_neighbors': (2.0, 10.0),
    'future_savings_weight': (0.0, 0.5),
    'k_nearest_neighbors_clustering': (3.0, 12.0),
    'k_nearest_neighbors_sparsification': (5.0, 20.0),
    'sparsification_threshold': (10.0, 50.0),
    'depot_heuristic_weight': (0.1, 0.5),
    'gravitational_heuristic_weight': (0.05, 0.4),
    'savings_heuristic_weight': (0.0, 0.3),
    'clustering_heuristic_weight': (0.0, 0.3),
    'alpha_slack_adjust': (-0.2, 0.2),
    'beta_slack_adjust': (-0.2, 0.2),
    'gamma_slack_adjust': (-0.1, 0.1),
    'delta_slack_adjust': (-0.1, 0.1),
    'alpha': (0.1, 0.7),
    'beta': (0.0, 0.5),
    'gamma': (0.0, 0.4),
    'delta': (0.0, 0.3),
    'eta': (0.0, 0.3)
}
```
[2025-04-29 06:49:53,373][root][INFO] - Iteration 13: Running Code 0
[2025-04-29 06:49:55,554][root][INFO] - Iteration 13: Code Run 0 execution error!
[2025-04-29 06:49:55,554][root][INFO] - Iteration 13: Running Code 1
[2025-04-29 06:49:57,665][root][INFO] - Iteration 13: Code Run 1 execution error!
[2025-04-29 06:49:57,665][root][INFO] - Iteration 13: Running Code 2
[2025-04-29 06:49:59,785][root][INFO] - Iteration 13: Code Run 2 execution error!
[2025-04-29 06:49:59,786][root][INFO] - Iteration 13: Running Code 3
[2025-04-29 06:50:01,888][root][INFO] - Iteration 13: Code Run 3 execution error!
[2025-04-29 06:50:01,888][root][INFO] - Iteration 13: Running Code 4
[2025-04-29 06:50:03,952][root][INFO] - Iteration 13: Code Run 4 execution error!
[2025-04-29 06:50:03,969][root][INFO] - Iteration 13, response_id 0: Objective value: inf
[2025-04-29 06:50:03,971][root][INFO] - Iteration 13, response_id 1: Objective value: inf
[2025-04-29 06:50:03,973][root][INFO] - Iteration 13, response_id 2: Objective value: inf
[2025-04-29 06:50:03,976][root][INFO] - Iteration 13, response_id 3: Objective value: inf
[2025-04-29 06:50:04,232][root][INFO] - Iteration 13, response_id 4: Objective value: inf
[2025-04-29 06:50:04,238][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:50:17,397][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:50:17,401][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:50:17,402][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:50:17,403][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:50:17,406][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:50:17,413][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                   epsilon: float = 1e-6,
                   demand_feasibility_penalty_depot: float = 0.2,
                   demand_feasibility_penalty_other: float = 0.1,
                   gravitational_constant_factor: float = 2.0,
                   k_nearest_neighbors_adaptive_clustering_min: int = 3,
                   k_nearest_neighbors_adaptive_clustering_max: int = 8,
                   distance_weight: float = 0.4,
                   depot_weight: float = 0.15,
                   gravitational_weight: float = 0.1,
                   savings_weight: float = 0.15,
                   demand_weight: float = 0.1,
                   clustering_weight: float = 0.1,
                   k_nearest_neighbors_sparsification: int = 12,
                   sparsification_threshold_percentile: float = 40.0) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several improvements over v1:

    1.  Adaptive Distance: Distance heuristic adapts based on the average demand.
    2.  Refined Demand Feasibility: Considers remaining capacity and multiple node demands.
    3.  Enhanced Depot Prioritization: Favors depot returns based on route length and demand.
    4.  Dynamic Gravitational Attraction: Adjusts gravitational constant based on capacity utilization.
    5.  Improved Savings Calculation: Takes into account demand feasibility for route merging.
    6.  Contextual Sparsification: Sparsifies based on local density and demand.
    7.  Adaptive Clustering: Adjusts k-nearest neighbors based on graph density.
    8.  Reinforcement Learning inspired weighting: Weights updated based on the hypothetical impact of edge inclusion.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].
        capacity (int): Vehicle capacity.
        epsilon (float): A small constant to avoid division by zero. Default is 1e-6.
        demand_feasibility_penalty_depot (float): Penalty if demands of i and j exceed capacity when i or j is depot. Default is 0.2
        demand_feasibility_penalty_other (float): Penalty if demands of i or j exceeds capacity when i or j is not depot. Default is 0.1
        gravitational_constant_factor (float): Factor to increase gravitational constant based on capacity utilization. Default is 2.0.
        k_nearest_neighbors_adaptive_clustering_min (int): Minimum number of neighbors for adaptive clustering. Default is 3.
        k_nearest_neighbors_adaptive_clustering_max (int): Maximum number of neighbors for adaptive clustering. Default is 8.
        distance_weight (float): Weight for the distance heuristic. Default is 0.4.
        depot_weight (float): Weight for the depot heuristic. Default is 0.15.
        gravitational_weight (float): Weight for the gravitational heuristic. Default is 0.1.
        savings_weight (float): Weight for the savings heuristic. Default is 0.15.
        demand_weight (float): Weight for the demand heuristic. Default is 0.1.
        clustering_weight (float): Weight for the clustering heuristic. Default is 0.1.
        k_nearest_neighbors_sparsification (int): Number of nearest neighbors to consider during sparsification. Default is 12.
        sparsification_threshold_percentile (float): Percentile threshold for sparsification. Default is 40.0.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # 1. Adaptive Distance Component
    avg_demand = np.mean(demands[1:])
    distance_scale = 1 + (avg_demand / capacity)  # Scale distance based on average demand
    distance_heuristic = 1 / (distance_matrix * distance_scale + epsilon)

    # 2. Refined Demand Feasibility
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
                continue
            # Account for depot trips, but don't exclude outright
            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):
                 demand_heuristic[i, j] = demand_feasibility_penalty_depot
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                demand_heuristic[i,j] = demand_feasibility_penalty_other
    # 3. Enhanced Depot Prioritization
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]
        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)
        depot_heuristic[i, 0] = depot_preference
        depot_heuristic[0, i] = depot_preference

    # 4. Dynamic Gravitational Attraction
    gravitational_heuristic = np.zeros((n, n))
    capacity_utilization = np.sum(demands[1:]) / ((n - 1) * capacity) # Estimate capacity pressure
    gravitational_constant = 1.0 + gravitational_constant_factor * capacity_utilization  # Increase gravity if capacity is tight.
    for i in range(1, n):
        for j in range(1, n):
            if i == j:
                gravitational_heuristic[i, j] = 0
                continue
            mass_i = demands[i]
            mass_j = demands[j]
            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)

    # 5. Improved Savings Heuristic
    savings_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
             # Adjust savings based on the demand of the combined route
            if demands[i] + demands[j] <= capacity:
                savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
                savings_heuristic[i, j] = savings
                savings_heuristic[j, i] = savings  # Savings are symmetric

    # 7. Adaptive Clustering Coefficient (Local Density)
    clustering_heuristic = np.zeros((n, n))
    graph_density = 2 / (n * (n - 1)) * np.sum(distance_matrix > 0) #approximation
    k_nearest = max(k_nearest_neighbors_adaptive_clustering_min, min(int(n * graph_density), k_nearest_neighbors_adaptive_clustering_max)) #dynamic k based on graph density
    for i in range(1, n):
        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1
        for j in range(1, n):
            if i != j:
                common_neighbors = 0
                for neighbor_i in nearest_neighbors:
                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):
                        common_neighbors += 1
                clustering_heuristic[i, j] = common_neighbors / k_nearest

    # 8. Reinforcement Learning inspired Weighting
    alpha = distance_weight  #Distance
    beta = depot_weight #Depot
    gamma = gravitational_weight #Gravitational
    delta = savings_weight #Savings
    eta = demand_weight #Demand
    mu = clustering_weight #Clustering
    # Heuristic combination

    heuristics = (alpha * distance_heuristic +
                  beta * depot_heuristic +
                  gamma * gravitational_heuristic +
                  delta * savings_heuristic +
                  eta * demand_heuristic +
                  mu * clustering_heuristic)

    # 6. Contextual Sparsification
    k_nearest = k_nearest_neighbors_sparsification
    threshold = np.percentile(heuristics[heuristics > 0], sparsification_threshold_percentile)
    for i in range(n):
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] # Exclude self and depot.
        for j in range(n):
            if heuristics[i, j] < threshold and j not in nearest_neighbors:
                heuristics[i, j] = 0

    # Normalize
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics
```

```python
parameter_ranges = {
    'epsilon': (1e-7, 1e-5),
    'demand_feasibility_penalty_depot': (0.0, 0.5),
    'demand_feasibility_penalty_other': (0.0, 0.5),
    'gravitational_constant_factor': (1.0, 5.0),
    'k_nearest_neighbors_adaptive_clustering_min': (1.0, 5.0),
    'k_nearest_neighbors_adaptive_clustering_max': (5.0, 15.0),
    'distance_weight': (0.0, 1.0),
    'depot_weight': (0.0, 1.0),
    'gravitational_weight': (0.0, 1.0),
    'savings_weight': (0.0, 1.0),
    'demand_weight': (0.0, 1.0),
    'clustering_weight': (0.0, 1.0),
    'k_nearest_neighbors_sparsification': (5.0, 20.0),
    'sparsification_threshold_percentile': (10.0, 50.0)
}
```
[2025-04-29 06:50:17,429][root][INFO] - Iteration 13: Running Code 0
[2025-04-29 06:50:19,553][root][INFO] - Iteration 13: Code Run 0 execution error!
[2025-04-29 06:50:19,553][root][INFO] - Iteration 13: Running Code 1
[2025-04-29 06:50:21,588][root][INFO] - Iteration 13: Code Run 1 execution error!
[2025-04-29 06:50:21,589][root][INFO] - Iteration 13: Running Code 2
[2025-04-29 06:50:23,636][root][INFO] - Iteration 13: Code Run 2 execution error!
[2025-04-29 06:50:23,636][root][INFO] - Iteration 13: Running Code 3
[2025-04-29 06:50:25,755][root][INFO] - Iteration 13: Code Run 3 execution error!
[2025-04-29 06:50:25,756][root][INFO] - Iteration 13: Running Code 4
[2025-04-29 06:50:27,819][root][INFO] - Iteration 13: Code Run 4 execution error!
[2025-04-29 06:50:27,839][root][INFO] - Iteration 13, response_id 0: Objective value: inf
[2025-04-29 06:50:27,841][root][INFO] - Iteration 13, response_id 1: Objective value: inf
[2025-04-29 06:50:27,842][root][INFO] - Iteration 13, response_id 2: Objective value: inf
[2025-04-29 06:50:27,844][root][INFO] - Iteration 13, response_id 3: Objective value: inf
[2025-04-29 06:50:28,112][root][INFO] - Iteration 13, response_id 4: Objective value: inf
[2025-04-29 06:50:28,116][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:50:39,629][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:50:39,633][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:50:39,634][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:50:39,634][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:50:39,637][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:50:39,642][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  violation_penalty_depot: float = 0.01, violation_penalty_other: float = 0.005, violation_penalty_strong: float = 0.001,
                  isolation_threshold_multiplier: float = 1.0, depot_preference_exponent: float = 0.5,
                  alpha_connectivity_factor: float = 0.4, beta_connectivity_factor: float = 0.1, gamma_connectivity_factor: float = 0.4, eta_connectivity_factor: float = 0.1,
                  k_nearest: int = 8, percentile_threshold: float = 50.0, epsilon: float = 1e-6) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version focuses on a refined combination of factors, dynamic parameter adaptation,
    and more aggressive sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.
        violation_penalty_depot (float): Penalty for immediate capacity violations at the depot. Default is 0.01.
        violation_penalty_other (float): Penalty for capacity violations at other nodes. Default is 0.005
        violation_penalty_strong (float): Very strong penalty for exceeding remaining capacity
        isolation_threshold_multiplier (float): Multiplier for the isolation threshold. Default is 1.0.
        depot_preference_exponent (float): Exponent for the depot preference calculation. Default is 0.5.
        alpha_connectivity_factor (float): Factor for distance importance. Default is 0.4.
        beta_connectivity_factor (float): Factor for depot proximity importance. Default is 0.1.
        gamma_connectivity_factor (float): Factor for savings importance. Default is 0.4.
        eta_connectivity_factor (float): Factor for similarity importance. Default is 0.1
        k_nearest (int): Number of nearest neighbors to keep. Default is 8.
        percentile_threshold (float): Percentile threshold for sparsification. Default is 50.0.
        epsilon (float): small value added to distance to avoid divide by zero. Default is 1e-6

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # 1. Distance Component (Enhanced)
    #   - Inverse square distance emphasizes shorter edges more strongly.
    distance_heuristic = 1 / (distance_matrix**2 + epsilon)

    # 2. Demand Feasibility (Refined)
    #   - Stricter penalty for immediate capacity violations.
    #   - Considers the remaining capacity of the current route (simulated).
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            if demands[i] + demands[j] > capacity and i == 0:
                demand_heuristic[i, j] = violation_penalty_depot  # Stronger penalty for depot-initiated violation
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = violation_penalty_depot  # Stronger penalty for depot-initiated violation
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                demand_heuristic[i,j] = violation_penalty_other

            # Simulate a simple route: depot -> i -> j
            remaining_capacity = capacity - demands[i] if i != 0 else capacity
            if i != 0 and j!= 0 and remaining_capacity < demands[j]:
                 demand_heuristic[i,j] = violation_penalty_strong #Very strong penalty


    # 3. Depot Proximity (Contextualized)
    #   - Only apply depot preference to nodes that are "isolated" (far from most others).
    #   - Adjust preference strength based on demand.
    depot_heuristic = np.zeros((n, n))
    isolation_threshold = np.mean(distance_matrix) * isolation_threshold_multiplier  # Node is "isolated" if its avg dist is above this
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]
        if avg_distance > isolation_threshold:
            depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)**depot_preference_exponent # sqrt makes demands less impact
            depot_heuristic[i, 0] = depot_preference
            depot_heuristic[0, i] = depot_preference


    # 4. Savings Heuristic (Aggressive)
    #   - Prioritize high-saving merges very aggressively.
    savings_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_heuristic[i, j] = savings**2  # Emphasize high savings
            savings_heuristic[j, i] = savings**2

    # 5. Node Similarity (Demand-Distance Tradeoff)
    # Encourage edges between nodes with similar demand/distance profiles
    similarity_heuristic = np.zeros((n, n))
    demand_normalized = demands / np.max(demands)
    distance_to_depot_normalized = distance_matrix[:, 0] / np.max(distance_matrix[:, 0])

    for i in range(1, n):
        for j in range(i + 1, n):
            demand_diff = abs(demand_normalized[i] - demand_normalized[j])
            distance_diff = abs(distance_to_depot_normalized[i] - distance_to_depot_normalized[j])
            similarity_heuristic[i, j] = 1 - (demand_diff + distance_diff) / 2 #High score when demand diff and distance_to_depot_diff are small
            similarity_heuristic[j, i] = similarity_heuristic[i, j]

    # 6. Adaptive Weighting (Mechanism-Driven)
    #   - Dynamically adjust weights based on network connectivity.
    #   - High connectivity -> emphasize savings. Low connectivity -> emphasize distance.
    connectivity = np.sum(distance_matrix < np.mean(distance_matrix)) / (n * n)  # Ratio of "close" edges
    alpha = alpha_connectivity_factor * (1 - connectivity)  # Distance importance (inversely proportional to connectivity)
    beta = beta_connectivity_factor * (1-connectivity) # Depot proximity
    gamma = gamma_connectivity_factor * connectivity  # Savings importance (proportional to connectivity)
    eta = eta_connectivity_factor * connectivity #Similarity heuristic

    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * savings_heuristic + eta * similarity_heuristic

    # 7. Sparsification (Aggressive and Dynamic)
    #   - Remove edges below a percentile threshold AND those that violate "triangle inequality".
    #   - Only keep k-nearest neighbors.

    threshold = np.percentile(heuristics[heuristics > 0], percentile_threshold)  # Aggressive sparsification

    for i in range(n):
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]

        for j in range(n):
            if heuristics[i, j] < threshold and j not in nearest_neighbors:
                heuristics[i, j] = 0
            #Triangle inequality check
            for k in range(n):
              if distance_matrix[i,j] > distance_matrix[i,k] + distance_matrix[k,j]:
                heuristics[i,j] = 0
                break



    # Normalize
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics
```

```python
parameter_ranges = {
    "violation_penalty_depot": (0.001, 0.1),
    "violation_penalty_other": (0.0001, 0.01),
    "violation_penalty_strong": (0.0001, 0.001),
    "isolation_threshold_multiplier": (0.5, 1.5),
    "depot_preference_exponent": (0.1, 1.0),
    "alpha_connectivity_factor": (0.1, 0.7),
    "beta_connectivity_factor": (0.01, 0.3),
    "gamma_connectivity_factor": (0.1, 0.7),
    "eta_connectivity_factor": (0.01, 0.3),
    "k_nearest": (2.0, 20.0),
    "percentile_threshold": (10.0, 90.0),
    "epsilon": (1e-7, 1e-5)
}
```
[2025-04-29 06:50:39,658][root][INFO] - Iteration 13: Running Code 0
[2025-04-29 06:50:41,774][root][INFO] - Iteration 13: Code Run 0 execution error!
[2025-04-29 06:50:41,774][root][INFO] - Iteration 13: Running Code 1
[2025-04-29 06:50:43,808][root][INFO] - Iteration 13: Code Run 1 execution error!
[2025-04-29 06:50:43,808][root][INFO] - Iteration 13: Running Code 2
[2025-04-29 06:50:45,885][root][INFO] - Iteration 13: Code Run 2 execution error!
[2025-04-29 06:50:45,886][root][INFO] - Iteration 13: Running Code 3
[2025-04-29 06:50:48,033][root][INFO] - Iteration 13: Code Run 3 execution error!
[2025-04-29 06:50:48,034][root][INFO] - Iteration 13: Running Code 4
[2025-04-29 06:50:50,148][root][INFO] - Iteration 13: Code Run 4 execution error!
[2025-04-29 06:50:50,164][root][INFO] - Iteration 13, response_id 0: Objective value: inf
[2025-04-29 06:50:50,165][root][INFO] - Iteration 13, response_id 1: Objective value: inf
[2025-04-29 06:50:50,167][root][INFO] - Iteration 13, response_id 2: Objective value: inf
[2025-04-29 06:50:50,169][root][INFO] - Iteration 13, response_id 3: Objective value: inf
[2025-04-29 06:50:50,433][root][INFO] - Iteration 13, response_id 4: Objective value: inf
[2025-04-29 06:50:50,434][root][INFO] - Iteration 13 finished...
[2025-04-29 06:50:50,434][root][INFO] - Best obj: 9.948078455545994, Best Code Path: problem_iter12_code2.py
[2025-04-29 06:50:50,435][root][INFO] - LLM usage: prompt_tokens = 214732, completion_tokens = 76649
[2025-04-29 06:50:50,435][root][INFO] - Function Evals: 91
[2025-04-29 06:50:50,437][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:50:56,618][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:50:56,621][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:50:56,622][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:50:56,623][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:50:56,625][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:50:56,669][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:50:58,933][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:50:58,938][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:50:58,939][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:50:58,940][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:50:58,942][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:50:58,996][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:50:58,997][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:51:04,881][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:51:04,887][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:51:04,889][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:04,889][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:04,890][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:51:04,891][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:08,284][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:51:08,287][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:51:08,288][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:08,288][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:08,290][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:51:08,292][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:10,710][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:51:10,719][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:51:10,720][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:10,721][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:10,722][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:51:10,723][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:13,896][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:51:13,901][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:51:13,902][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:13,903][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:13,905][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:51:13,907][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:20,404][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:51:20,407][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:51:20,409][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:20,409][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:20,411][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:51:20,413][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:21,500][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:51:21,503][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:51:21,504][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:21,504][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:21,507][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:51:21,508][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:27,283][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:51:27,286][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:51:27,287][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:27,288][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:27,290][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:51:27,291][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:28,738][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:51:28,751][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:51:28,752][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:28,752][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:28,753][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:51:28,754][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:35,274][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:51:35,277][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:51:35,278][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:35,279][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:35,281][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:36,341][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:51:36,345][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:51:36,346][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:36,347][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:36,350][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:51:36,395][root][INFO] - Iteration 14: Running Code 0
[2025-04-29 06:51:42,047][root][INFO] - Iteration 14: Code Run 0 successful!
[2025-04-29 06:51:42,047][root][INFO] - Iteration 14: Running Code 1
[2025-04-29 06:51:49,038][root][INFO] - Iteration 14: Code Run 1 successful!
[2025-04-29 06:51:49,039][root][INFO] - Iteration 14: Running Code 2
[2025-04-29 06:51:56,968][root][INFO] - Iteration 14: Code Run 2 successful!
[2025-04-29 06:51:56,968][root][INFO] - Iteration 14: Running Code 3
[2025-04-29 06:52:05,069][root][INFO] - Iteration 14: Code Run 3 successful!
[2025-04-29 06:52:05,069][root][INFO] - Iteration 14: Running Code 4
[2025-04-29 06:52:13,509][root][INFO] - Iteration 14: Code Run 4 successful!
[2025-04-29 06:52:13,509][root][INFO] - Iteration 14: Running Code 5
[2025-04-29 06:52:23,011][root][INFO] - Iteration 14: Code Run 5 successful!
[2025-04-29 06:52:23,011][root][INFO] - Iteration 14: Running Code 6
[2025-04-29 06:52:32,904][root][INFO] - Iteration 14: Code Run 6 successful!
[2025-04-29 06:52:32,904][root][INFO] - Iteration 14: Running Code 7
[2025-04-29 06:52:43,543][root][INFO] - Iteration 14: Code Run 7 successful!
[2025-04-29 06:52:43,543][root][INFO] - Iteration 14: Running Code 8
[2025-04-29 06:52:54,185][root][INFO] - Iteration 14: Code Run 8 successful!
[2025-04-29 06:52:54,185][root][INFO] - Iteration 14: Running Code 9
[2025-04-29 06:53:04,949][root][INFO] - Iteration 14: Code Run 9 successful!
[2025-04-29 06:53:04,960][root][INFO] - Iteration 14, response_id 0: Objective value: 10.057616909052339
[2025-04-29 06:53:19,632][root][INFO] - Iteration 14, response_id 1: Objective value: 20.74392525736209
[2025-04-29 06:53:19,643][root][INFO] - Iteration 14, response_id 2: Objective value: 11.831148571056133
[2025-04-29 06:53:19,656][root][INFO] - Iteration 14, response_id 3: Objective value: 11.43461627034817
[2025-04-29 06:53:36,389][root][INFO] - Iteration 14, response_id 4: Objective value: 15.90036445069918
[2025-04-29 06:54:02,897][root][INFO] - Iteration 14, response_id 5: Objective value: 22.79880646146317
[2025-04-29 06:54:02,907][root][INFO] - Iteration 14, response_id 6: Objective value: 11.878731218091817
[2025-04-29 06:54:08,346][root][INFO] - Iteration 14, response_id 7: Objective value: 21.158697144389386
[2025-04-29 06:54:08,354][root][INFO] - Iteration 14, response_id 8: Objective value: 16.159808852695335
[2025-04-29 06:54:08,367][root][INFO] - Iteration 14, response_id 9: Objective value: 11.77507527573892
[2025-04-29 06:54:08,368][root][INFO] - Iteration 14 finished...
[2025-04-29 06:54:08,368][root][INFO] - Best obj: 9.948078455545994, Best Code Path: problem_iter12_code2.py
[2025-04-29 06:54:08,368][root][INFO] - LLM usage: prompt_tokens = 279142, completion_tokens = 87710
[2025-04-29 06:54:08,369][root][INFO] - Function Evals: 101
[2025-04-29 06:54:08,373][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:54:08,375][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:54:21,164][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:54:21,167][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:54:21,169][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:54:21,169][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:54:21,171][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:54:21,173][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:54:24,367][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:54:24,377][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:54:24,377][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:54:24,378][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:54:24,378][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:54:24,379][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:54:32,615][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:54:32,617][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:54:32,617][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:54:32,617][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:54:32,618][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:54:32,619][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:54:37,500][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:54:37,502][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:54:37,502][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:54:37,502][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:54:37,503][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:54:46,714][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:54:46,717][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:54:46,718][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:54:46,719][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:54:46,722][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:54:46,741][root][INFO] - Iteration 15: Running Code 0
[2025-04-29 06:54:52,676][root][INFO] - Iteration 15: Code Run 0 successful!
[2025-04-29 06:54:52,676][root][INFO] - Iteration 15: Running Code 1
[2025-04-29 06:54:59,500][root][INFO] - Iteration 15: Code Run 1 successful!
[2025-04-29 06:54:59,501][root][INFO] - Iteration 15: Running Code 2
[2025-04-29 06:55:07,374][root][INFO] - Iteration 15: Code Run 2 successful!
[2025-04-29 06:55:07,374][root][INFO] - Iteration 15: Running Code 3
[2025-04-29 06:55:15,508][root][INFO] - Iteration 15: Code Run 3 successful!
[2025-04-29 06:55:15,508][root][INFO] - Iteration 15: Running Code 4
[2025-04-29 06:55:24,781][root][INFO] - Iteration 15: Code Run 4 successful!
[2025-04-29 06:55:34,033][root][INFO] - Iteration 15, response_id 0: Objective value: 9.978406210020221
[2025-04-29 06:55:42,639][root][INFO] - Iteration 15, response_id 1: Objective value: 14.620414877276758
[2025-04-29 06:55:58,882][root][INFO] - Iteration 15, response_id 2: Objective value: 21.39050058638373
[2025-04-29 06:55:58,893][root][INFO] - Iteration 15, response_id 3: Objective value: 13.528749957169575
[2025-04-29 06:55:58,914][root][INFO] - Iteration 15, response_id 4: Objective value: inf
[2025-04-29 06:55:58,915][root][INFO] - Iteration 15 finished...
[2025-04-29 06:55:58,915][root][INFO] - Best obj: 9.948078455545994, Best Code Path: problem_iter12_code2.py
[2025-04-29 06:55:58,915][root][INFO] - LLM usage: prompt_tokens = 281444, completion_tokens = 89210
[2025-04-29 06:55:58,916][root][INFO] - Function Evals: 106
[2025-04-29 06:55:58,919][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:56:21,800][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:56:21,803][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:56:21,805][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:56:21,805][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:56:21,808][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:56:21,813][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                   distance_scale_factor: float = 0.5,
                   demand_heuristic_value: float = 0.2,
                   urgency_factor: float = 5.0,
                   adaptive_gravitational_constant_factor: float = 0.2,
                   future_savings_weight: float = 0.1,
                   edge_clustering_k_nearest: int = 6,
                   combined_heuristic_depot_weight: float = 0.3,
                   combined_heuristic_gravitational_weight: float = 0.15,
                   combined_heuristic_savings_weight: float = 0.1,
                   combined_heuristic_clustering_weight: float = 0.1,
                   combined_heuristic_load_balance_weight: float = 0.05,
                   sparsification_percentile: float = 30.0,
                   k_nearest_neighbors: int = 10) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version combines adaptive elements, spatial awareness, and sparsification for enhanced performance.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))
    epsilon = 1e-6

    # 1. Adaptive Distance Scaling
    total_demand = np.sum(demands[1:])
    capacity_ratio = total_demand / (capacity * (n - 1 + epsilon))
    distance_scale = 1.0 + distance_scale_factor * capacity_ratio
    distance_heuristic = 1 / (distance_matrix * distance_scale + epsilon)

    # 2. Demand Feasibility with Remaining Capacity Consideration
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            if i == 0 and j != 0 and demands[j] > capacity:
                demand_heuristic[i,j] = 0
            if j == 0 and i != 0 and demands[i] > capacity:
                demand_heuristic[i,j] = 0

            if i != 0 and j != 0:
                if demands[i] + demands[j] > capacity:
                   demand_heuristic[i, j] = demand_heuristic_value

    # 3. Enhanced Depot Attraction (Softmax with Capacity-Based Urgency)
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2 + epsilon) if n > 2 else distance_matrix[i, 0]
        urgency = np.exp(urgency_factor * (avg_distance / np.max(distance_matrix)) * (demands[i] / (capacity + epsilon)))
        depot_heuristic[i, 0] = urgency
        depot_heuristic[0, i] = urgency

    # 4. Adaptive Gravitational Attraction with Distance-Demand Interaction
    gravitational_heuristic = np.zeros((n, n))
    avg_demand = np.mean(demands[1:])
    adaptive_gravitational_constant = 1.0 + adaptive_gravitational_constant_factor * (avg_demand / capacity)
    for i in range(1, n):
        for j in range(1, n):
            if i == j:
                gravitational_heuristic[i, j] = 0
                continue
            mass_i = demands[i]
            mass_j = demands[j]
            gravitational_heuristic[i, j] = adaptive_gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)

    # 5. Savings Heuristic with Lookahead and Demand Considerations
    savings_heuristic = np.zeros((n, n))
    lookahead_neighbors = 5
    for i in range(1, n):
        for j in range(i + 1, n):
            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
            neighbor_i = np.argsort(distance_matrix[i, 1:])[:lookahead_neighbors] + 1
            neighbor_j = np.argsort(distance_matrix[j, 1:])[:lookahead_neighbors] + 1
            future_savings = 0
            for ni in neighbor_i:
                for nj in neighbor_j:
                    future_savings += distance_matrix[ni, 0] + distance_matrix[0, nj] - distance_matrix[ni, nj]

            #Modulate future savings based on demand
            future_savings_modulation = (demands[i] + demands[j]) / (2 * capacity + epsilon)
            savings += future_savings_weight * future_savings * future_savings_modulation / (lookahead_neighbors**2 + epsilon)
            savings_heuristic[i, j] = savings
            savings_heuristic[j, i] = savings

    # 6. Edge Clustering Coefficient (Focus on High-Demand Clusters and Distance)
    clustering_heuristic = np.zeros((n, n))
    k_nearest = edge_clustering_k_nearest
    for i in range(1, n):
        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1
        for j in range(1, n):
            if i != j:
                common_neighbors = 0
                for neighbor_i in nearest_neighbors:
                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):
                        common_neighbors += 1
                clustering_coefficient = common_neighbors / (k_nearest + epsilon)
                demand_factor = (demands[i] + demands[j]) / (2 * capacity + epsilon)
                distance_factor = 1 / (distance_matrix[i, j] + epsilon)  # Closer clusters are more important
                clustering_heuristic[i, j] = clustering_coefficient * demand_factor * distance_factor

    # 7. Vehicle Load Balancing Heuristic
    load_balance_heuristic = np.zeros((n, n))
    avg_demand_per_customer = np.mean(demands[1:])
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
              demand_difference = abs(demands[i] - demands[j])
              load_balance_score = 1 - (demand_difference / (2 * avg_demand_per_customer + epsilon))
              load_balance_heuristic[i, j] = load_balance_score if load_balance_score > 0 else 0 #Ensure positive value

    # 8. Combination and Sparsification with Adaptive Threshold
    combined_heuristic = (distance_heuristic * demand_heuristic)**0.5 + combined_heuristic_depot_weight * depot_heuristic + combined_heuristic_gravitational_weight * gravitational_heuristic + combined_heuristic_savings_weight * savings_heuristic + combined_heuristic_clustering_weight * clustering_heuristic + combined_heuristic_load_balance_weight * load_balance_heuristic

    #Adaptive Sparsification based on heuristic values
    threshold = np.percentile(combined_heuristic[combined_heuristic > 0], sparsification_percentile)
    k_nearest = k_nearest_neighbors # Number of nearest neighbors to always keep
    for i in range(n):
      nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]
      for j in range(n):
        if combined_heuristic[i,j] < threshold and j not in nearest_neighbors:
          combined_heuristic[i,j] = 0

    # Normalize final heuristic
    max_val = np.max(combined_heuristic)
    if max_val > 0:
        heuristics = combined_heuristic / max_val
    else:
        heuristics = combined_heuristic

    return heuristics
```

```python
parameter_ranges = {
    'distance_scale_factor': (0.0, 1.0),
    'demand_heuristic_value': (0.0, 1.0),
    'urgency_factor': (1.0, 10.0),
    'adaptive_gravitational_constant_factor': (0.0, 1.0),
    'future_savings_weight': (0.0, 0.5),
    'edge_clustering_k_nearest': (3.0, 10.0),
    'combined_heuristic_depot_weight': (0.0, 0.5),
    'combined_heuristic_gravitational_weight': (0.0, 0.5),
    'combined_heuristic_savings_weight': (0.0, 0.5),
    'combined_heuristic_clustering_weight': (0.0, 0.5),
    'combined_heuristic_load_balance_weight': (0.0, 0.5),
    'sparsification_percentile': (10.0, 50.0),
    'k_nearest_neighbors': (5.0, 20.0)
}
```
[2025-04-29 06:56:21,835][root][INFO] - Iteration 16: Running Code 0
[2025-04-29 06:56:24,059][root][INFO] - Iteration 16: Code Run 0 execution error!
[2025-04-29 06:56:24,059][root][INFO] - Iteration 16: Running Code 1
[2025-04-29 06:56:26,115][root][INFO] - Iteration 16: Code Run 1 execution error!
[2025-04-29 06:56:26,115][root][INFO] - Iteration 16: Running Code 2
[2025-04-29 06:56:28,164][root][INFO] - Iteration 16: Code Run 2 execution error!
[2025-04-29 06:56:28,164][root][INFO] - Iteration 16: Running Code 3
[2025-04-29 06:56:30,290][root][INFO] - Iteration 16: Code Run 3 execution error!
[2025-04-29 06:56:30,291][root][INFO] - Iteration 16: Running Code 4
[2025-04-29 06:56:32,279][root][INFO] - Iteration 16: Code Run 4 execution error!
[2025-04-29 06:56:32,281][root][INFO] - Iteration 16, response_id 0: Objective value: inf
[2025-04-29 06:56:32,282][root][INFO] - Iteration 16, response_id 1: Objective value: inf
[2025-04-29 06:56:32,284][root][INFO] - Iteration 16, response_id 2: Objective value: inf
[2025-04-29 06:56:32,285][root][INFO] - Iteration 16, response_id 3: Objective value: inf
[2025-04-29 06:56:32,556][root][INFO] - Iteration 16, response_id 4: Objective value: inf
[2025-04-29 06:56:32,559][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:56:52,253][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:56:52,254][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:56:52,255][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:56:52,255][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:56:52,257][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:56:52,261][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                   distance_scale_increase: float = 0.5, urgency_factor: float = 5.0,
                   adaptive_gravitational_constant_increase: float = 0.2, lookahead_neighbors: int = 5,
                   future_savings_weight: float = 0.1, k_nearest_clustering: int = 6,
                   alpha: float = 0.2, beta: float = 0.15, gamma: float = 0.1, delta: float = 0.15,
                   eta: float = 0.2, k_nearest_sparsification: int = 12, threshold_percentile: float = 40.0,
                   demand_depot_penalty: float = 0.1, demand_capacity_penalty: float = 0.05) -> np.ndarray:
    """Heuristics for CVRP. Combines distance, demand, depot proximity, savings, gravitational attraction, clustering, adaptively weighted and sparsified."""
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))
    epsilon = 1e-6

    # 1. Adaptive Distance Scaling
    total_demand = np.sum(demands[1:])
    capacity_ratio = total_demand / (capacity * (n - 1))
    distance_scale = 1.0 + distance_scale_increase * capacity_ratio  # Increase distance importance if capacity is tight
    distance_heuristic = 1 / (distance_matrix * distance_scale + epsilon)
    #distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)

    # 2. Demand Feasibility
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            if demands[i] + demands[j] > capacity and i == 0:
                demand_heuristic[i, j] = demand_depot_penalty
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = demand_depot_penalty
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                demand_heuristic[i,j] = demand_capacity_penalty

    # 3. Enhanced Depot Attraction
    depot_heuristic = np.zeros((n, n))
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]
        urgency = np.exp(urgency_factor * (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity))
        depot_heuristic[i, 0] = urgency
        depot_heuristic[0, i] = urgency
    #depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)

    # 4. Adaptive Gravitational Attraction
    gravitational_heuristic = np.zeros((n, n))
    avg_demand = np.mean(demands[1:])
    adaptive_gravitational_constant = 1.0 + adaptive_gravitational_constant_increase * (avg_demand / capacity)
    for i in range(1, n):
        for j in range(1, n):
            if i == j:
                gravitational_heuristic[i,j] = 0
                continue
            mass_i = demands[i]
            mass_j = demands[j]
            gravitational_heuristic[i, j] = adaptive_gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)

    # 5. Savings Heuristic with Lookahead
    savings_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
            #Lookahead
            neighbor_i = np.argsort(distance_matrix[i, 1:])[:lookahead_neighbors] + 1
            neighbor_j = np.argsort(distance_matrix[j, 1:])[:lookahead_neighbors] + 1
            future_savings = 0
            for ni in neighbor_i:
                for nj in neighbor_j:
                    future_savings += distance_matrix[ni, 0] + distance_matrix[0, nj] - distance_matrix[ni, nj]
            savings += future_savings_weight * future_savings / (lookahead_neighbors**2 + epsilon)
            savings_heuristic[i, j] = savings
            savings_heuristic[j, i] = savings
    #savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)

    # 6. Edge Clustering Coefficient (focus on high-demand clusters)
    clustering_heuristic = np.zeros((n, n))
    k_nearest = k_nearest_clustering
    for i in range(1, n):
        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1
        for j in range(1, n):
            if i != j:
                common_neighbors = 0
                for neighbor_i in nearest_neighbors:
                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):
                        common_neighbors += 1
                clustering_heuristic[i, j] = (common_neighbors / k_nearest) * (demands[i] + demands[j]) / (2*capacity) # Scale by demand
    #clustering_heuristic = clustering_heuristic / np.max(clustering_heuristic)

    # Adaptive Weighting
    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))
    num_nodes_factor = n / 100.0

    alpha_dynamic = alpha
    beta_dynamic = beta
    gamma_dynamic = gamma
    delta_dynamic = delta
    eta_dynamic = eta

    alpha_dynamic += 0.05 * capacity_ratio + 0.02 * num_nodes_factor
    beta_dynamic -= 0.03 * capacity_ratio - 0.01 * num_nodes_factor
    gamma_dynamic += 0.02 * capacity_ratio + 0.03 * num_nodes_factor
    delta_dynamic += 0.01 * capacity_ratio + 0.02 * num_nodes_factor
    eta_dynamic -= 0.01 * capacity_ratio - 0.02 * num_nodes_factor

    # Combine heuristics

    heuristics = (alpha_dynamic * distance_heuristic * demand_heuristic +
                  beta_dynamic * depot_heuristic +
                  gamma_dynamic * gravitational_heuristic +
                  delta_dynamic * savings_heuristic +
                  eta_dynamic * clustering_heuristic)

    # Sparsification (adaptive threshold)
    k_nearest = min(k_nearest_sparsification, n - 1)
    threshold = np.percentile(heuristics[heuristics > 0], threshold_percentile)

    for i in range(n):
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]
        for j in range(n):
            if heuristics[i, j] < threshold and j not in nearest_neighbors:
                heuristics[i, j] = 0

    # Normalize
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics
```

```python
parameter_ranges = {
    'distance_scale_increase': (0.0, 1.0),
    'urgency_factor': (1.0, 10.0),
    'adaptive_gravitational_constant_increase': (0.0, 0.5),
    'lookahead_neighbors': (1.0, 10.0),
    'future_savings_weight': (0.0, 0.5),
    'k_nearest_clustering': (2.0, 15.0),
    'alpha': (0.0, 1.0),
    'beta': (0.0, 1.0),
    'gamma': (0.0, 1.0),
    'delta': (0.0, 1.0),
    'eta': (0.0, 1.0),
    'k_nearest_sparsification': (5.0, 20.0),
    'threshold_percentile': (10.0, 90.0),
    'demand_depot_penalty': (0.0, 0.5),
    'demand_capacity_penalty': (0.0, 0.5)
}
```
[2025-04-29 06:56:52,278][root][INFO] - Iteration 16: Running Code 0
[2025-04-29 06:56:54,373][root][INFO] - Iteration 16: Code Run 0 execution error!
[2025-04-29 06:56:54,374][root][INFO] - Iteration 16: Running Code 1
[2025-04-29 06:56:56,418][root][INFO] - Iteration 16: Code Run 1 execution error!
[2025-04-29 06:56:56,418][root][INFO] - Iteration 16: Running Code 2
[2025-04-29 06:56:58,424][root][INFO] - Iteration 16: Code Run 2 execution error!
[2025-04-29 06:56:58,424][root][INFO] - Iteration 16: Running Code 3
[2025-04-29 06:57:00,560][root][INFO] - Iteration 16: Code Run 3 execution error!
[2025-04-29 06:57:00,561][root][INFO] - Iteration 16: Running Code 4
[2025-04-29 06:57:02,578][root][INFO] - Iteration 16: Code Run 4 execution error!
[2025-04-29 06:57:02,580][root][INFO] - Iteration 16, response_id 0: Objective value: inf
[2025-04-29 06:57:02,582][root][INFO] - Iteration 16, response_id 1: Objective value: inf
[2025-04-29 06:57:02,583][root][INFO] - Iteration 16, response_id 2: Objective value: inf
[2025-04-29 06:57:02,585][root][INFO] - Iteration 16, response_id 3: Objective value: inf
[2025-04-29 06:57:02,860][root][INFO] - Iteration 16, response_id 4: Objective value: inf
[2025-04-29 06:57:02,863][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-29 06:57:11,089][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-29 06:57:11,090][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-29 06:57:11,091][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:57:11,091][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:57:11,092][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-29 06:57:11,094][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  demand_heuristic_depot_val: float = 0.1,
                  demand_heuristic_other_val: float = 0.05,
                  alpha_base: float = 0.3,
                  alpha_capacity_effect: float = 0.2,
                  gamma_base: float = 0.3,
                  gamma_capacity_effect: float = 0.1,
                  delta_base: float = 0.2,
                  delta_capacity_effect: float = -0.1,
                  k_nearest: int = 10,
                  threshold_percentile: float = 40.0) -> np.ndarray:
    """CVRP heuristic: Combines distance, demand, savings, and angle heuristics with adaptive weighting and sparsification."""
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))
    epsilon = 1e-6

    # Distance component
    distance_heuristic = 1 / (distance_matrix + epsilon)
    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)

    # Demand Feasibility
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):
                demand_heuristic[i, j] = demand_heuristic_depot_val
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                demand_heuristic[i,j] = demand_heuristic_other_val

    # Savings Heuristic
    savings_heuristic = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_heuristic[i, j] = savings
            savings_heuristic[j, i] = savings
    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)

    # Angle-based Clustering
    angle_heuristic = np.zeros((n, n))
    depot_x, depot_y = coordinates[0]
    for i in range(1, n):
        angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)
        for j in range(i + 1, n):
            angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)
            angle_diff = min(abs(angle_i - angle_j), 2 * np.pi - abs(angle_i - angle_j))
            angle_preference = np.exp(-angle_diff)
            angle_heuristic[i, j] = angle_preference
            angle_heuristic[j, i] = angle_preference

    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)


    # Adaptive Weighting - adjusted based on capacity ratio.
    capacity_ratio = np.sum(demands[1:]) / (capacity * (n-1))
    alpha = alpha_base + alpha_capacity_effect * capacity_ratio # Distance weight
    beta = 0.0 # depot proximity is removed here
    gamma = gamma_base + gamma_capacity_effect * capacity_ratio # Savings weight
    delta = delta_base + delta_capacity_effect * capacity_ratio # angle heuristic

    heuristics = alpha * distance_heuristic * demand_heuristic + gamma * savings_heuristic * demand_heuristic + delta * angle_heuristic * demand_heuristic

    # Adaptive Sparsification based on percentile and k-NN
    threshold = np.percentile(heuristics[heuristics > 0], threshold_percentile) # Adaptive threshold based on percentile

    for i in range(n):
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]
        for j in range(n):
            if heuristics[i, j] < threshold and j not in nearest_neighbors:
                heuristics[i, j] = 0


    # Normalize to be between 0 and 1
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics
```

```python
parameter_ranges = {
    "demand_heuristic_depot_val": (0.0, 0.2),
    "demand_heuristic_other_val": (0.0, 0.1),
    "alpha_base": (0.0, 1.0),
    "alpha_capacity_effect": (-0.5, 0.5),
    "gamma_base": (0.0, 1.0),
    "gamma_capacity_effect": (-0.5, 0.5),
    "delta_base": (0.0, 1.0),
    "delta_capacity_effect": (-0.5, 0.5),
    "k_nearest": (1, 20),
    "threshold_percentile": (0.0, 100.0)
}
```
[2025-04-29 06:57:11,106][root][INFO] - Iteration 16: Running Code 0
[2025-04-29 06:57:16,695][root][INFO] - Iteration 16: Code Run 0 successful!
[2025-04-29 06:57:16,695][root][INFO] - Iteration 16: Running Code 1
[2025-04-29 06:57:22,394][root][INFO] - Iteration 16: Code Run 1 successful!
[2025-04-29 06:57:22,395][root][INFO] - Iteration 16: Running Code 2
[2025-04-29 06:57:28,192][root][INFO] - Iteration 16: Code Run 2 successful!
[2025-04-29 06:57:28,192][root][INFO] - Iteration 16: Running Code 3
[2025-04-29 06:57:33,972][root][INFO] - Iteration 16: Code Run 3 execution error!
[2025-04-29 06:57:33,972][root][INFO] - Iteration 16: Running Code 4
[2025-04-29 06:57:39,737][root][INFO] - Iteration 16: Code Run 4 execution error!
[2025-04-29 06:57:39,738][root][INFO] - Iteration 16, response_id 0: Objective value: inf
[2025-04-29 06:57:39,740][root][INFO] - Iteration 16, response_id 1: Objective value: inf
[2025-04-29 06:57:39,742][root][INFO] - Iteration 16, response_id 2: Objective value: inf
[2025-04-29 06:57:39,744][root][INFO] - Iteration 16, response_id 3: Objective value: inf
[2025-04-29 06:57:40,273][root][INFO] - Iteration 16, response_id 4: Objective value: inf
[2025-04-29 06:57:40,274][root][INFO] - Iteration 16 finished...
[2025-04-29 06:57:40,274][root][INFO] - Best obj: 9.948078455545994, Best Code Path: problem_iter12_code2.py
[2025-04-29 06:57:40,274][root][INFO] - LLM usage: prompt_tokens = 285780, completion_tokens = 94219
[2025-04-29 06:57:40,275][root][INFO] - Function Evals: 106
[2025-04-29 06:57:40,275][root][INFO] - Best Code Overall: import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several improvements over v1, including:

    1.  Adaptive Distance Scaling: Dynamically adjusts the importance of distance based on problem tightness.
    2.  Refined Demand Feasibility: Considers remaining vehicle capacity for more accurate feasibility assessments.
    3.  Enhanced Depot Attraction: Uses a softmax function to prioritize returns to the depot based on urgency.
    4.  Adaptive Gravitational Constant: Adjusts the gravitational constant based on the average demand.
    5.  Edge Clustering Coefficient: Focuses on connections within high-demand clusters.
    6.  Lookahead Savings: Estimates savings based on potential future connections.
    7.  Reinforced Sparsification: Adaptively sets thresholds based on edge characteristics.
    8.  Capacity Slack Aware weight adjustments: adjusts weights based on how close total demand is to vehicle capacity.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))
    epsilon = 1e-6

    # 1. Adaptive Distance Scaling
    total_demand = np.sum(demands[1:])
    capacity_ratio = total_demand / (capacity * (n - 1))
    distance_scale = 1.0 + 0.5 * capacity_ratio  # Increase distance importance if capacity is tight
    distance_heuristic = 1 / (distance_matrix * distance_scale + epsilon)

    # 2. Refined Demand Feasibility
    demand_heuristic = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                demand_heuristic[i, j] = 0
            #Consider the edge between depot and the node.
            if demands[i] + demands[j] > capacity and i == 0:
                demand_heuristic[i, j] = 0.1
            elif demands[i] + demands[j] > capacity and j == 0:
                demand_heuristic[i, j] = 0.1
            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:
                demand_heuristic[i,j] = 0.05

    # 3. Enhanced Depot Attraction
    depot_heuristic = np.zeros((n, n))
    urgency_factor = 5.0
    for i in range(1, n):
        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]
        urgency = np.exp(urgency_factor * (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity))
        depot_heuristic[i, 0] = urgency
        depot_heuristic[0, i] = urgency

    # 4. Adaptive Gravitational Attraction
    gravitational_heuristic = np.zeros((n, n))
    avg_demand = np.mean(demands[1:])
    adaptive_gravitational_constant = 1.0 + 0.2 * (avg_demand / capacity)
    for i in range(1, n):
        for j in range(1, n):
            if i == j:
                gravitational_heuristic[i,j] = 0
                continue
            mass_i = demands[i]
            mass_j = demands[j]
            gravitational_heuristic[i, j] = adaptive_gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)

    # 5. Savings Heuristic with Lookahead
    savings_heuristic = np.zeros((n, n))
    lookahead_neighbors = 5 #number of neighbors to consider for lookahead
    for i in range(1, n):
        for j in range(i + 1, n):
            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
            #Lookahead
            neighbor_i = np.argsort(distance_matrix[i, 1:])[:lookahead_neighbors] + 1
            neighbor_j = np.argsort(distance_matrix[j, 1:])[:lookahead_neighbors] + 1
            future_savings = 0
            for ni in neighbor_i:
                for nj in neighbor_j:
                    future_savings += distance_matrix[ni, 0] + distance_matrix[0, nj] - distance_matrix[ni, nj]
            savings += 0.1 * future_savings / (lookahead_neighbors**2 + epsilon)
            savings_heuristic[i, j] = savings
            savings_heuristic[j, i] = savings

    # 6. Edge Clustering Coefficient (focus on high-demand clusters)
    clustering_heuristic = np.zeros((n, n))
    k_nearest = 6
    for i in range(1, n):
        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1
        for j in range(1, n):
            if i != j:
                common_neighbors = 0
                for neighbor_i in nearest_neighbors:
                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):
                        common_neighbors += 1
                clustering_heuristic[i, j] = (common_neighbors / k_nearest) * (demands[i] + demands[j]) / (2*capacity) # Scale by demand

    # 7. Sparsification
    k_nearest = 10
    sparsification_threshold = 25 #more aggressive sparsification
    heuristics = (distance_heuristic * demand_heuristic)**0.5 + 0.3 * depot_heuristic + 0.2 * gravitational_heuristic + 0.15 * savings_heuristic + 0.1 * clustering_heuristic
    threshold = np.percentile(heuristics[heuristics > 0], sparsification_threshold)
    for i in range(n):
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]
        for j in range(n):
            if heuristics[i, j] < threshold and j not in nearest_neighbors:
                heuristics[i, j] = 0

    # 8. Capacity Slack Aware Weight Adjustments

    # Measure capacity slack as the percentage of unused capacity across all vehicles, assuming one vehicle per customer.
    capacity_slack = 1 - (total_demand / (capacity * (n - 1)))
    alpha = 0.4 # Distance heuristic
    beta = 0.2 # Depot heuristic
    gamma = 0.1 # Gravitational heuristic
    delta = 0.15 # Savings heuristic
    eta = 0.15 # Clustering heuristic

    # If we have a lot of spare capacity, reduce the importance of the depot trips.
    alpha = alpha + 0.1*capacity_slack # Give more weight to distance
    beta = beta - 0.1*capacity_slack  # Give less weight to depot
    gamma = gamma + 0.05*capacity_slack
    delta = delta + 0.05*capacity_slack
    # Recombine heuristics with adjusted weights.
    # heuristics = (distance_heuristic * demand_heuristic)**0.5 + 0.3 * depot_heuristic + 0.2 * gravitational_heuristic + 0.15 * savings_heuristic + 0.1 * clustering_heuristic
    # Normalize
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics
[2025-04-29 06:57:40,276][root][INFO] - Best Code Path Overall: problem_iter12_code2.py
[2025-04-29 06:57:40,278][root][INFO] - Running validation script...: C:\Users\Nam\Documents\GitHub\HSEvo/problems/cvrp_aco/eval.py
[2025-04-29 07:06:48,217][root][INFO] - Validation script finished. Results are saved in best_code_overall_val_stdout.txt.
[2025-04-29 07:06:48,233][root][INFO] - [*] Running ...
[2025-04-29 07:06:48,233][root][INFO] - [*] Average for 20: 5.560903990269182
[2025-04-29 07:06:48,234][root][INFO] - [*] Average for 50: 10.014544392870501
[2025-04-29 07:06:48,234][root][INFO] - [*] Average for 100: 16.91855880578948
