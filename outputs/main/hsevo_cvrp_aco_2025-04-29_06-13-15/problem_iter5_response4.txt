```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Combines distance, demand, angle, and depot proximity with adaptive weighting."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))
    normalized_demands = demands / np.max(demands)
    depot_x, depot_y = coordinates[0]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0
                continue

            distance_factor = 1 / distance_matrix[i, j] if distance_matrix[i,j] > 0 else 0
            demand_factor = 1 - normalized_demands[j]
            if i == 0:
                demand_factor = 1.0

            i_x, i_y = coordinates[i]
            j_x, j_y = coordinates[j]

            vector_ij = np.array([j_x - i_x, j_y - i_y])
            vector_di = np.array([i_x - depot_x, i_y - depot_y])

            vector_ij = vector_ij / (np.linalg.norm(vector_ij) + 1e-9)
            vector_di = vector_di / (np.linalg.norm(vector_di) + 1e-9)

            dot_product = np.clip(np.dot(vector_ij, vector_di), -1.0, 1.0)
            angle = np.arccos(dot_product)
            angle_factor = 1 - (angle / np.pi)

            depot_distance_i = distance_matrix[0, i]
            depot_distance_j = distance_matrix[0, j]
            depot_proximity_factor = 1 / (depot_distance_i + depot_distance_j + 1e-9)

            #Adaptive weighting based on demand
            demand_weight = 0.5 + 0.5 * normalized_demands[j] #increase weight for high demand nodes
            heuristic_matrix[i, j] = distance_factor * (demand_weight * demand_factor + (1-demand_weight) * (angle_factor * depot_proximity_factor))

    #Sparsification: zero out less promising edges
    mean_heuristic = np.mean(heuristic_matrix)
    heuristic_matrix[heuristic_matrix < 0.5 * mean_heuristic] = 0

    return heuristic_matrix
```
