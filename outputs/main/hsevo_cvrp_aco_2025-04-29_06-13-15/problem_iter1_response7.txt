```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP using a combination of distance, demand, and angular considerations.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Scale distance by demand
    demand_scaled_distance = distance_matrix * (demands[np.newaxis, :] + demands[:, np.newaxis]) / (2 * capacity)  # Normalize by 2*capacity for relative cost
    demand_scaled_distance = np.where(demand_scaled_distance == 0, np.inf, demand_scaled_distance) # Avoid division by zero and zero distances (self-loops)

    # Angular penalty (discourage sharp turns at depot)
    depot_x, depot_y = coordinates[0]
    for i in range(1, n):
        for j in range(1, n):
            if i == j:
                continue
            node_i_x, node_i_y = coordinates[i]
            node_j_x, node_j_y = coordinates[j]

            # Angles relative to the depot
            angle_i = np.arctan2(node_i_y - depot_y, node_i_x - depot_x)
            angle_j = np.arctan2(node_j_y - depot_y, node_j_x - depot_x)

            angle_diff = np.abs(angle_i - angle_j)
            angle_diff = np.minimum(angle_diff, 2 * np.pi - angle_diff)  # Ensure angle_diff is the shorter angle

            angular_penalty = (angle_diff / np.pi)  # Scale to [0, 1]

            # Adjust heuristic value based on distance, demand and angular penalty.
            heuristics[i, j] = 1 / (demand_scaled_distance[i, j] + 0.1* angular_penalty) # add a small amount to ensure strictly positive
            heuristics[j, i] = heuristics[i, j] # enforce symmetric heuristics

    # Special treatment for depot edges. Prioritize edges to the depot.
    for i in range(1, n):
        heuristics[0, i] = 1.0 / (distance_matrix[0, i]* demands[i] / capacity+1e-6)  # Scale by demand relative to capacity
        heuristics[i, 0] = heuristics[0, i]

    #Make self-loops zero to prohibit them
    for i in range(n):
      heuristics[i, i] = 0

    return heuristics
```
