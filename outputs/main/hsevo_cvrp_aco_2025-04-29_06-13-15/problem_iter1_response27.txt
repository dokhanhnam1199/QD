```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Improves upon v1 by considering demand, distance, and spatial clustering.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Avoid division by zero.
    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)

    # Combination of factors. Weights can be tuned.
    alpha = 0.5  # Importance of distance
    beta = 0.3   # Importance of demand feasibility (higher demand, lower heuristic)
    gamma = 0.2  # Importance of cluster affinity

    # Heuristic based on inverse distance
    distance_heuristic = 1 / distance_matrix

    # Heuristic based on demand feasibility.  Encourage edges to nodes
    # that are unlikely to exceed capacity *early* in a route. Penalize if connecting would
    # likely immediately exceed capacity
    demand_heuristic = np.ones_like(distance_matrix, dtype=float)
    for i in range(1, n):  # Skip depot
        for j in range(1, n): #Skip depot
            if i != j:
                if demands[i] + demands[j] > capacity:
                    demand_heuristic[i, j] = 0.1 # severely penalize the connection
                else:
                     demand_heuristic[i, j] = 1 - (demands[i] + demands[j]) / (2*capacity) # Linearly decreasing, but not lower than zero.

    # Heuristic based on spatial clustering using a simple density estimate
    # penalize for edges going outside local region to maintain more "local" routes
    cluster_heuristic = np.zeros_like(distance_matrix, dtype=float)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                 # Simple heuristic: Density based on inverse distance to other nodes
                 density_i = np.sum(1 / distance_matrix[i, 1:]) - (1/ distance_matrix[i,i]) if np.sum(1 / distance_matrix[i, 1:]) < np.inf else 0 # Avoid division by zero, substract term 1/d_ii as distance_matrix[i,i] = inf
                 density_j = np.sum(1 / distance_matrix[j, 1:]) - (1/ distance_matrix[j,j]) if np.sum(1 / distance_matrix[j, 1:]) < np.inf else 0 # Avoid division by zero
                 # penalize connections to nodes with much lower density
                 cluster_heuristic[i,j] = min(density_i, density_j) / max(density_i, density_j) if max(density_i, density_j) > 0 else 0 #Between 0 and 1

    # Combine heuristics
    heuristic_matrix = (alpha * distance_heuristic +
                        beta * demand_heuristic +
                        gamma * cluster_heuristic)

    # Depot edges should be generally favored to return to depot
    for i in range(1, n):
        heuristic_matrix[0, i] *= 1.2  # Slightly favor leaving the depot
        heuristic_matrix[i, 0] *= 1.2  # Slightly favor returning to the depot

    return heuristic_matrix
```
