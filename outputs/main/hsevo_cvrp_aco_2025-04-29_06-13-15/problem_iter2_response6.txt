```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Combines distance, demand, angle to depot, and angle between nodes to create a heuristic."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.3
    capacity_penalty = 2.0

    depot_x, depot_y = coordinates[0]
    angles = np.zeros(n)

    for i in range(1, n):
        x, y = coordinates[i]
        dx = x - depot_x
        dy = y - depot_y
        angles[i] = np.arctan2(dy, dx)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0
                continue

            distance_term = distance_weight / distance_matrix[i, j] if distance_matrix[i,j] > 0 else 0
            demand_term = (1 - demand_weight * demands[j] / capacity)

            if i == 0:
              angle_term = 0
            else:
              vector_ij = coordinates[j] - coordinates[i]
              vector_j0 = coordinates[0] - coordinates[j]
              norm_ij = np.linalg.norm(vector_ij)
              norm_j0 = np.linalg.norm(vector_j0)
              if norm_ij > 0 and norm_j0 > 0:
                dot_product = np.dot(vector_ij, vector_j0)
                cosine_angle = dot_product / (norm_ij * norm_j0)
                angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))
                angle_term = (1 - angle_weight * angle / np.pi)
              else:
                angle_term = 0

            if demands[j] > (capacity/2):
               demand_term = demand_term / capacity_penalty

            angle_diff = abs(angles[i]-angles[j])
            angle_depot_term =  angle_diff/np.pi

            heuristic_matrix[i, j] = distance_term * demand_term * angle_term + 0.1 * angle_depot_term # Combine factors, depot angle has lower weight

    return heuristic_matrix
```
