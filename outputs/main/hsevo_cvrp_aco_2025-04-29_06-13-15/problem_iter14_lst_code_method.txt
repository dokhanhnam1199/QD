{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates several improvements over v1, including:\n\n    1.  Adaptive Distance Scaling: Dynamically adjusts the importance of distance based on problem tightness.\n    2.  Refined Demand Feasibility: Considers remaining vehicle capacity for more accurate feasibility assessments.\n    3.  Enhanced Depot Attraction: Uses a softmax function to prioritize returns to the depot based on urgency.\n    4.  Adaptive Gravitational Constant: Adjusts the gravitational constant based on the average demand.\n    5.  Edge Clustering Coefficient: Focuses on connections within high-demand clusters.\n    6.  Lookahead Savings: Estimates savings based on potential future connections.\n    7.  Reinforced Sparsification: Adaptively sets thresholds based on edge characteristics.\n    8.  Capacity Slack Aware weight adjustments: adjusts weights based on how close total demand is to vehicle capacity.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Adaptive Distance Scaling\n    total_demand = np.sum(demands[1:])\n    capacity_ratio = total_demand / (capacity * (n - 1))\n    distance_scale = 1.0 + 0.5 * capacity_ratio  # Increase distance importance if capacity is tight\n    distance_heuristic = 1 / (distance_matrix * distance_scale + epsilon)\n\n    # 2. Refined Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            #Consider the edge between depot and the node.\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Enhanced Depot Attraction\n    depot_heuristic = np.zeros((n, n))\n    urgency_factor = 5.0\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        urgency = np.exp(urgency_factor * (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity))\n        depot_heuristic[i, 0] = urgency\n        depot_heuristic[0, i] = urgency\n\n    # 4. Adaptive Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    avg_demand = np.mean(demands[1:])\n    adaptive_gravitational_constant = 1.0 + 0.2 * (avg_demand / capacity)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            mass_i = demands[i]\n            mass_j = demands[j]\n            gravitational_heuristic[i, j] = adaptive_gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n\n    # 5. Savings Heuristic with Lookahead\n    savings_heuristic = np.zeros((n, n))\n    lookahead_neighbors = 5 #number of neighbors to consider for lookahead\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            #Lookahead\n            neighbor_i = np.argsort(distance_matrix[i, 1:])[:lookahead_neighbors] + 1\n            neighbor_j = np.argsort(distance_matrix[j, 1:])[:lookahead_neighbors] + 1\n            future_savings = 0\n            for ni in neighbor_i:\n                for nj in neighbor_j:\n                    future_savings += distance_matrix[ni, 0] + distance_matrix[0, nj] - distance_matrix[ni, nj]\n            savings += 0.1 * future_savings / (lookahead_neighbors**2 + epsilon)\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n\n    # 6. Edge Clustering Coefficient (focus on high-demand clusters)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = 6\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = (common_neighbors / k_nearest) * (demands[i] + demands[j]) / (2*capacity) # Scale by demand\n\n    # 7. Sparsification\n    k_nearest = 10\n    sparsification_threshold = 25 #more aggressive sparsification\n    heuristics = (distance_heuristic * demand_heuristic)**0.5 + 0.3 * depot_heuristic + 0.2 * gravitational_heuristic + 0.15 * savings_heuristic + 0.1 * clustering_heuristic\n    threshold = np.percentile(heuristics[heuristics > 0], sparsification_threshold)\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # 8. Capacity Slack Aware Weight Adjustments\n\n    # Measure capacity slack as the percentage of unused capacity across all vehicles, assuming one vehicle per customer.\n    capacity_slack = 1 - (total_demand / (capacity * (n - 1)))\n    alpha = 0.4 # Distance heuristic\n    beta = 0.2 # Depot heuristic\n    gamma = 0.1 # Gravitational heuristic\n    delta = 0.15 # Savings heuristic\n    eta = 0.15 # Clustering heuristic\n\n    # If we have a lot of spare capacity, reduce the importance of the depot trips.\n    alpha = alpha + 0.1*capacity_slack # Give more weight to distance\n    beta = beta - 0.1*capacity_slack  # Give less weight to depot\n    gamma = gamma + 0.05*capacity_slack\n    delta = delta + 0.05*capacity_slack\n    # Recombine heuristics with adjusted weights.\n    # heuristics = (distance_heuristic * demand_heuristic)**0.5 + 0.3 * depot_heuristic + 0.2 * gravitational_heuristic + 0.15 * savings_heuristic + 0.1 * clustering_heuristic\n    # Normalize\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates several improvements over v1, including:\n\n    1.  Adaptive Distance Scaling: Dynamically adjusts the importance of distance based on problem tightness.\n    2.  Refined Demand Feasibility: Considers remaining vehicle capacity for more accurate feasibility assessments.\n    3.  Enhanced Depot Attraction: Uses a softmax function to prioritize returns to the depot based on urgency.\n    4.  Adaptive Gravitational Constant: Adjusts the gravitational constant based on the average demand.\n    5.  Edge Clustering Coefficient: Focuses on connections within high-demand clusters.\n    6.  Lookahead Savings: Estimates savings based on potential future connections.\n    7.  Reinforced Sparsification: Adaptively sets thresholds based on edge characteristics.\n    8.  Capacity Slack Aware weight adjustments: adjusts weights based on how close total demand is to vehicle capacity.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Adaptive Distance Scaling\n    total_demand = np.sum(demands[1:])\n    capacity_ratio = total_demand / (capacity * (n - 1))\n    distance_scale = 1.0 + 0.5 * capacity_ratio  # Increase distance importance if capacity is tight\n    distance_heuristic = 1 / (distance_matrix * distance_scale + epsilon)\n\n    # 2. Refined Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            #Consider the edge between depot and the node.\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Enhanced Depot Attraction\n    depot_heuristic = np.zeros((n, n))\n    urgency_factor = 5.0\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        urgency = np.exp(urgency_factor * (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity))\n        depot_heuristic[i, 0] = urgency\n        depot_heuristic[0, i] = urgency\n\n    # 4. Adaptive Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    avg_demand = np.mean(demands[1:])\n    adaptive_gravitational_constant = 1.0 + 0.2 * (avg_demand / capacity)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            mass_i = demands[i]\n            mass_j = demands[j]\n            gravitational_heuristic[i, j] = adaptive_gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n\n    # 5. Savings Heuristic with Lookahead\n    savings_heuristic = np.zeros((n, n))\n    lookahead_neighbors = 5 #number of neighbors to consider for lookahead\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            #Lookahead\n            neighbor_i = np.argsort(distance_matrix[i, 1:])[:lookahead_neighbors] + 1\n            neighbor_j = np.argsort(distance_matrix[j, 1:])[:lookahead_neighbors] + 1\n            future_savings = 0\n            for ni in neighbor_i:\n                for nj in neighbor_j:\n                    future_savings += distance_matrix[ni, 0] + distance_matrix[0, nj] - distance_matrix[ni, nj]\n            savings += 0.1 * future_savings / (lookahead_neighbors**2 + epsilon)\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n\n    # 6. Edge Clustering Coefficient (focus on high-demand clusters)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = 6\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = (common_neighbors / k_nearest) * (demands[i] + demands[j]) / (2*capacity) # Scale by demand\n\n    # 7. Sparsification\n    k_nearest = 10\n    sparsification_threshold = 25 #more aggressive sparsification\n    heuristics = (distance_heuristic * demand_heuristic)**0.5 + 0.3 * depot_heuristic + 0.2 * gravitational_heuristic + 0.15 * savings_heuristic + 0.1 * clustering_heuristic\n    threshold = np.percentile(heuristics[heuristics > 0], sparsification_threshold)\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # 8. Capacity Slack Aware Weight Adjustments\n\n    # Measure capacity slack as the percentage of unused capacity across all vehicles, assuming one vehicle per customer.\n    capacity_slack = 1 - (total_demand / (capacity * (n - 1)))\n    alpha = 0.4 # Distance heuristic\n    beta = 0.2 # Depot heuristic\n    gamma = 0.1 # Gravitational heuristic\n    delta = 0.15 # Savings heuristic\n    eta = 0.15 # Clustering heuristic\n\n    # If we have a lot of spare capacity, reduce the importance of the depot trips.\n    alpha = alpha + 0.1*capacity_slack # Give more weight to distance\n    beta = beta - 0.1*capacity_slack  # Give less weight to depot\n    gamma = gamma + 0.05*capacity_slack\n    delta = delta + 0.05*capacity_slack\n    # Recombine heuristics with adjusted weights.\n    # heuristics = (distance_heuristic * demand_heuristic)**0.5 + 0.3 * depot_heuristic + 0.2 * gravitational_heuristic + 0.15 * savings_heuristic + 0.1 * clustering_heuristic\n    # Normalize\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates several improvements over v1, including:\n\n    1.  Adaptive Distance Scaling: Dynamically adjusts the importance of distance based on problem tightness.\n    2.  Refined Demand Feasibility: Considers remaining vehicle capacity for more accurate feasibility assessments.\n    3.  Enhanced Depot Attraction: Uses a softmax function to prioritize returns to the depot based on urgency.\n    4.  Adaptive Gravitational Constant: Adjusts the gravitational constant based on the average demand.\n    5.  Edge Clustering Coefficient: Focuses on connections within high-demand clusters.\n    6.  Lookahead Savings: Estimates savings based on potential future connections.\n    7.  Reinforced Sparsification: Adaptively sets thresholds based on edge characteristics.\n    8.  Capacity Slack Aware weight adjustments: adjusts weights based on how close total demand is to vehicle capacity.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Adaptive Distance Scaling\n    total_demand = np.sum(demands[1:])\n    capacity_ratio = total_demand / (capacity * (n - 1))\n    distance_scale = 1.0 + 0.5 * capacity_ratio  # Increase distance importance if capacity is tight\n    distance_heuristic = 1 / (distance_matrix * distance_scale + epsilon)\n\n    # 2. Refined Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            #Consider the edge between depot and the node.\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Enhanced Depot Attraction\n    depot_heuristic = np.zeros((n, n))\n    urgency_factor = 5.0\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        urgency = np.exp(urgency_factor * (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity))\n        depot_heuristic[i, 0] = urgency\n        depot_heuristic[0, i] = urgency\n\n    # 4. Adaptive Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    avg_demand = np.mean(demands[1:])\n    adaptive_gravitational_constant = 1.0 + 0.2 * (avg_demand / capacity)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            mass_i = demands[i]\n            mass_j = demands[j]\n            gravitational_heuristic[i, j] = adaptive_gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n\n    # 5. Savings Heuristic with Lookahead\n    savings_heuristic = np.zeros((n, n))\n    lookahead_neighbors = 5 #number of neighbors to consider for lookahead\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            #Lookahead\n            neighbor_i = np.argsort(distance_matrix[i, 1:])[:lookahead_neighbors] + 1\n            neighbor_j = np.argsort(distance_matrix[j, 1:])[:lookahead_neighbors] + 1\n            future_savings = 0\n            for ni in neighbor_i:\n                for nj in neighbor_j:\n                    future_savings += distance_matrix[ni, 0] + distance_matrix[0, nj] - distance_matrix[ni, nj]\n            savings += 0.1 * future_savings / (lookahead_neighbors**2 + epsilon)\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n\n    # 6. Edge Clustering Coefficient (focus on high-demand clusters)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = 6\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = (common_neighbors / k_nearest) * (demands[i] + demands[j]) / (2*capacity) # Scale by demand\n\n    # 7. Sparsification\n    k_nearest = 10\n    sparsification_threshold = 25 #more aggressive sparsification\n    heuristics = (distance_heuristic * demand_heuristic)**0.5 + 0.3 * depot_heuristic + 0.2 * gravitational_heuristic + 0.15 * savings_heuristic + 0.1 * clustering_heuristic\n    threshold = np.percentile(heuristics[heuristics > 0], sparsification_threshold)\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # 8. Capacity Slack Aware Weight Adjustments\n\n    # Measure capacity slack as the percentage of unused capacity across all vehicles, assuming one vehicle per customer.\n    capacity_slack = 1 - (total_demand / (capacity * (n - 1)))\n    alpha = 0.4 # Distance heuristic\n    beta = 0.2 # Depot heuristic\n    gamma = 0.1 # Gravitational heuristic\n    delta = 0.15 # Savings heuristic\n    eta = 0.15 # Clustering heuristic\n\n    # If we have a lot of spare capacity, reduce the importance of the depot trips.\n    alpha = alpha + 0.1*capacity_slack # Give more weight to distance\n    beta = beta - 0.1*capacity_slack  # Give less weight to depot\n    gamma = gamma + 0.05*capacity_slack\n    delta = delta + 0.05*capacity_slack\n    # Recombine heuristics with adjusted weights.\n    # heuristics = (distance_heuristic * demand_heuristic)**0.5 + 0.3 * depot_heuristic + 0.2 * gravitational_heuristic + 0.15 * savings_heuristic + 0.1 * clustering_heuristic\n    # Normalize\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version focuses on a refined combination of factors, dynamic parameter adaptation,\n    and more aggressive sparsification.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance Component (Enhanced)\n    #   - Inverse square distance emphasizes shorter edges more strongly.\n    distance_heuristic = 1 / (distance_matrix**2 + epsilon)\n\n    # 2. Demand Feasibility (Refined)\n    #   - Stricter penalty for immediate capacity violations.\n    #   - Considers the remaining capacity of the current route (simulated).\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.01  # Stronger penalty for depot-initiated violation\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.01  # Stronger penalty for depot-initiated violation\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.005\n\n            # Simulate a simple route: depot -> i -> j\n            remaining_capacity = capacity - demands[i] if i != 0 else capacity\n            if i != 0 and j!= 0 and remaining_capacity < demands[j]:\n                 demand_heuristic[i,j] = 0.001 #Very strong penalty\n\n\n    # 3. Depot Proximity (Contextualized)\n    #   - Only apply depot preference to nodes that are \"isolated\" (far from most others).\n    #   - Adjust preference strength based on demand.\n    depot_heuristic = np.zeros((n, n))\n    isolation_threshold = np.mean(distance_matrix)  # Node is \"isolated\" if its avg dist is above this\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        if avg_distance > isolation_threshold:\n            depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)**0.5 # sqrt makes demands less impact\n            depot_heuristic[i, 0] = depot_preference\n            depot_heuristic[0, i] = depot_preference\n\n\n    # 4. Savings Heuristic (Aggressive)\n    #   - Prioritize high-saving merges very aggressively.\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings**2  # Emphasize high savings\n            savings_heuristic[j, i] = savings**2\n\n    # 5. Node Similarity (Demand-Distance Tradeoff)\n    # Encourage edges between nodes with similar demand/distance profiles\n    similarity_heuristic = np.zeros((n, n))\n    demand_normalized = demands / np.max(demands)\n    distance_to_depot_normalized = distance_matrix[:, 0] / np.max(distance_matrix[:, 0])\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            demand_diff = abs(demand_normalized[i] - demand_normalized[j])\n            distance_diff = abs(distance_to_depot_normalized[i] - distance_to_depot_normalized[j])\n            similarity_heuristic[i, j] = 1 - (demand_diff + distance_diff) / 2 #High score when demand diff and distance_to_depot_diff are small\n            similarity_heuristic[j, i] = similarity_heuristic[i, j]\n\n    # 6. Adaptive Weighting (Mechanism-Driven)\n    #   - Dynamically adjust weights based on network connectivity.\n    #   - High connectivity -> emphasize savings. Low connectivity -> emphasize distance.\n    connectivity = np.sum(distance_matrix < np.mean(distance_matrix)) / (n * n)  # Ratio of \"close\" edges\n    alpha = 0.4 * (1 - connectivity)  # Distance importance (inversely proportional to connectivity)\n    beta = 0.1 * (1-connectivity) # Depot proximity\n    gamma = 0.4 * connectivity  # Savings importance (proportional to connectivity)\n    eta = 0.1 * connectivity #Similarity heuristic\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * savings_heuristic + eta * similarity_heuristic\n\n    # 7. Sparsification (Aggressive and Dynamic)\n    #   - Remove edges below a percentile threshold AND those that violate \"triangle inequality\".\n    #   - Only keep k-nearest neighbors.\n    k_nearest = 8\n    threshold = np.percentile(heuristics[heuristics > 0], 50)  # Aggressive sparsification\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n            #Triangle inequality check\n            for k in range(n):\n              if distance_matrix[i,j] > distance_matrix[i,k] + distance_matrix[k,j]:\n                heuristics[i,j] = 0\n                break\n\n\n\n    # Normalize\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, savings, and angle heuristics with adaptive weighting and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                 demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # Angle-based Clustering\n    angle_heuristic = np.zeros((n, n))\n    depot_x, depot_y = coordinates[0]\n    for i in range(1, n):\n        angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)\n        for j in range(i + 1, n):\n            angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)\n            angle_diff = min(abs(angle_i - angle_j), 2 * np.pi - abs(angle_i - angle_j))\n            angle_preference = np.exp(-angle_diff)\n            angle_heuristic[i, j] = angle_preference\n            angle_heuristic[j, i] = angle_preference\n\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)\n\n\n    # Adaptive Weighting - adjusted based on capacity ratio.\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n-1))\n    alpha = 0.3 + 0.2 * capacity_ratio # Distance weight\n    beta = 0.2 - 0.1 * capacity_ratio # depot proximity is removed here\n    gamma = 0.3 + 0.1 * capacity_ratio # Savings weight\n    delta = 0.2 - 0.1 * capacity_ratio # angle heuristic\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + gamma * savings_heuristic * demand_heuristic + delta * angle_heuristic * demand_heuristic\n\n    # Adaptive Sparsification based on percentile and k-NN\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 40) # Adaptive threshold based on percentile\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, savings, and angle heuristics with adaptive weighting and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                 demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # Angle-based Clustering\n    angle_heuristic = np.zeros((n, n))\n    depot_x, depot_y = coordinates[0]\n    for i in range(1, n):\n        angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)\n        for j in range(i + 1, n):\n            angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)\n            angle_diff = min(abs(angle_i - angle_j), 2 * np.pi - abs(angle_i - angle_j))\n            angle_preference = np.exp(-angle_diff)\n            angle_heuristic[i, j] = angle_preference\n            angle_heuristic[j, i] = angle_preference\n\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)\n\n\n    # Adaptive Weighting - adjusted based on capacity ratio.\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n-1))\n    alpha = 0.3 + 0.2 * capacity_ratio # Distance weight\n    beta = 0.2 - 0.1 * capacity_ratio # depot proximity is removed here\n    gamma = 0.3 + 0.1 * capacity_ratio # Savings weight\n    delta = 0.2 - 0.1 * capacity_ratio # angle heuristic\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + gamma * savings_heuristic * demand_heuristic + delta * angle_heuristic * demand_heuristic\n\n    # Adaptive Sparsification based on percentile and k-NN\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 40) # Adaptive threshold based on percentile\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced CVRP heuristic: Combines adaptive weighting, clustering, angles, and demand density.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n    demand_heuristic = (demand_heuristic - np.min(demand_heuristic)) / (np.max(demand_heuristic) - np.min(demand_heuristic) + epsilon)\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n    # 4. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 5. Clustering Coefficient\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = min(10, n - 1)\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = common_neighbors / k_nearest\n    clustering_heuristic = (clustering_heuristic - np.min(clustering_heuristic)) / (np.max(clustering_heuristic) - np.min(clustering_heuristic) + epsilon)\n\n    # 6. Angle Cost Heuristic\n    angle_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_oi = coordinates[i] - coordinates[0]\n                vector_ij = coordinates[j] - coordinates[i]\n                dot_product = np.dot(vector_oi, vector_ij)\n                magnitude_oi = np.linalg.norm(vector_oi)\n                magnitude_ij = np.linalg.norm(vector_ij)\n\n                if magnitude_oi > 0 and magnitude_ij > 0:\n                    cosine_angle = dot_product / (magnitude_oi * magnitude_ij)\n                    cosine_angle = np.clip(cosine_angle, -1.0, 1.0)\n                    angle = np.arccos(cosine_angle)\n                    angle_cost = angle / np.pi\n                    angle_heuristic[i, j] = 1 - angle_cost\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)\n\n    # 7. Demand Density Heuristic\n    demand_density_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                near_nodes_i = np.argsort(distance_matrix[i, 1:])[:5] + 1\n                near_nodes_j = np.argsort(distance_matrix[j, 1:])[:5] + 1\n                total_demand_i = np.sum(demands[near_nodes_i])\n                total_demand_j = np.sum(demands[near_nodes_j])\n                demand_density_heuristic[i,j] = (total_demand_i + total_demand_j)\n\n    demand_density_heuristic = (demand_density_heuristic - np.min(demand_density_heuristic)) / (np.max(demand_density_heuristic) - np.min(demand_density_heuristic) + epsilon)\n\n    # 8. Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))\n    num_nodes_factor = n / 100.0\n\n    alpha = 0.2\n    beta = 0.15\n    gamma = 0.1\n    delta = 0.15\n    eta = 0.2\n    mu = 0.1\n    zeta = 0 # no route balance here\n\n    alpha += 0.05 * capacity_ratio + 0.02 * num_nodes_factor\n    beta -= 0.03 * capacity_ratio - 0.01 * num_nodes_factor\n    gamma += 0.02 * capacity_ratio + 0.03 * num_nodes_factor\n    delta += 0.01 * capacity_ratio + 0.02 * num_nodes_factor\n    eta -= 0.01 * capacity_ratio - 0.02 * num_nodes_factor\n    mu += 0.03 * capacity_ratio + 0.01 * num_nodes_factor\n\n    heuristics = (alpha * distance_heuristic * demand_heuristic +\n                  beta * depot_heuristic +\n                  gamma * savings_heuristic +\n                  delta * clustering_heuristic +\n                  eta * angle_heuristic +\n                  mu * demand_density_heuristic )\n\n    # 9. Sparsification (Adaptive Threshold)\n    k_nearest = min(12, n -1)\n    threshold = np.percentile(heuristics[heuristics > 0], 40)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines distance, demand, depot proximity, savings, clustering, and adaptive weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component (normalized)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Depot Proximity (normalized and enhanced)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # 4. Savings Heuristic (normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 5. Clustering Encouragement (based on spatial proximity)\n    clustering_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            dist_ij = distance_matrix[i, j]\n            # Encourage connections between nodes that are close relative to their distance to the depot\n            clustering_heuristic[i, j] = clustering_heuristic[j, i] = np.exp(-dist_ij / (distance_matrix[i, 0] + distance_matrix[j, 0] + epsilon))\n\n    # Adaptive Weighting (adjust based on problem size/characteristics)\n    n_customers = n - 1\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n    alpha = 0.3 #distance\n    beta = 0.15 #depot proximity\n    gamma = 0.20 #savings\n    delta = 0.15 #clustering\n    phi = 0.05 # angle cost\n\n    # Adjust weights (example: emphasize depot proximity more for larger problems)\n    if n_customers > 50:\n        beta += 0.05\n        alpha -= 0.05 #reduce alpha a bit\n    if capacity < np.mean(demands) * 5: # Tighter capacity constraints, increase savings\n        gamma += 0.05\n    if capacity_ratio > 0.75:\n        alpha -= 0.05\n        delta += 0.05\n\n    # 9. Angle Cost\n    angle_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Calculate angle between vectors depot->i and depot->j\n                vector_i = coordinates[i] - coordinates[0]\n                vector_j = coordinates[j] - coordinates[0]\n                dot_product = np.dot(vector_i, vector_j)\n                magn_i = np.linalg.norm(vector_i)\n                magn_j = np.linalg.norm(vector_j)\n                if magn_i * magn_j == 0:\n                    angle = 0\n                else:\n                    angle = np.arccos(dot_product / (magn_i * magn_j + epsilon))\n                angle_cost = angle / np.pi  # Normalize angle to [0, 1]\n                angle_heuristic[i, j] = 1 - angle_cost  # Prefer smaller angles\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon) # Normalize\n\n\n\n    # Combine the heuristics\n    heuristics = (alpha * distance_heuristic * demand_heuristic +\n                  beta * depot_heuristic +\n                  gamma * savings_heuristic +\n                  delta * clustering_heuristic +\n                  phi * angle_heuristic)\n\n    # 6. Sparsification (adaptive threshold based on heuristic values)\n    threshold = np.percentile(heuristics[heuristics > 0], 40) # Increased sparsity\n\n    k_nearest = 12 #consider k-nearest neighbors, increase it a bit\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines distance, demand, savings, depot proximity, and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n\n    # Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n    alpha = 0.3\n    beta = 0.15\n    delta = 0.1\n\n    alpha += 0.1 * capacity_ratio  # Increase importance of distance if capacity is tight\n    beta -= 0.05 * capacity_ratio  # Decrease importance of going to depot if capacity is tight\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + delta * savings_heuristic\n\n    # Adaptive Sparsification: Adjust threshold based on capacity ratio\n    k_nearest = 10  # consider only k-nearest neighbors.\n    threshold_percentile = 30 + 10 * capacity_ratio  # Adjust percentile based on tightness\n    threshold = np.percentile(heuristics[heuristics > 0], threshold_percentile)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines distance, demand, savings, depot proximity, and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n\n    # Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n    alpha = 0.3\n    beta = 0.15\n    delta = 0.1\n\n    alpha += 0.1 * capacity_ratio  # Increase importance of distance if capacity is tight\n    beta -= 0.05 * capacity_ratio  # Decrease importance of going to depot if capacity is tight\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + delta * savings_heuristic\n\n    # Adaptive Sparsification: Adjust threshold based on capacity ratio\n    k_nearest = 10  # consider only k-nearest neighbors.\n    threshold_percentile = 30 + 10 * capacity_ratio  # Adjust percentile based on tightness\n    threshold = np.percentile(heuristics[heuristics > 0], threshold_percentile)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines distance, demand, savings, depot proximity, clustering, sparsification, adaptive.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n    demand_heuristic = (demand_heuristic - np.min(demand_heuristic)) / (np.max(demand_heuristic) - np.min(demand_heuristic) + epsilon)\n\n\n    # Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n    # Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # Clustering Coefficient approximation (Local Density)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = 6  # Consider only k-nearest neighbors for clustering\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1  # k-nearest neighbors excluding depot, adjusting index\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = common_neighbors / k_nearest\n    clustering_heuristic = (clustering_heuristic - np.min(clustering_heuristic)) / (np.max(clustering_heuristic) - np.min(clustering_heuristic) + epsilon)\n\n    # Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n\n    # Dynamically adjust weights based on capacity_ratio and node proximity\n    alpha = 0.4 #Distance\n    beta = 0.2 #Depot\n    gamma = 0.1 #savings\n    delta = 0.3  #clustering\n\n    #Adjust weights\n    alpha += 0.05 * capacity_ratio #Tighter -> prioritize distance\n    beta -= 0.05 * capacity_ratio #Tighter -> less depot\n\n    #Combine\n    heuristics = alpha * distance_heuristic + beta * depot_heuristic + gamma * savings_heuristic + delta * clustering_heuristic\n\n    # Sparsification\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 30)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] #excluding self loop and depot\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines distance, demand, savings, depot proximity, clustering, sparsification, adaptive.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n    demand_heuristic = (demand_heuristic - np.min(demand_heuristic)) / (np.max(demand_heuristic) - np.min(demand_heuristic) + epsilon)\n\n\n    # Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n    # Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # Clustering Coefficient approximation (Local Density)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = 6  # Consider only k-nearest neighbors for clustering\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1  # k-nearest neighbors excluding depot, adjusting index\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = common_neighbors / k_nearest\n    clustering_heuristic = (clustering_heuristic - np.min(clustering_heuristic)) / (np.max(clustering_heuristic) - np.min(clustering_heuristic) + epsilon)\n\n    # Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n\n    # Dynamically adjust weights based on capacity_ratio and node proximity\n    alpha = 0.4 #Distance\n    beta = 0.2 #Depot\n    gamma = 0.1 #savings\n    delta = 0.3  #clustering\n\n    #Adjust weights\n    alpha += 0.05 * capacity_ratio #Tighter -> prioritize distance\n    beta -= 0.05 * capacity_ratio #Tighter -> less depot\n\n    #Combine\n    heuristics = alpha * distance_heuristic + beta * depot_heuristic + gamma * savings_heuristic + delta * clustering_heuristic\n\n    # Sparsification\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 30)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] #excluding self loop and depot\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1.  Distance: Edges with shorter distances are preferred.\n    2.  Demand Feasibility: Penalizes edges that would immediately violate capacity constraints if used early in a route.\n    3.  Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4.  Savings Heuristic Integration: Incorporates the savings heuristic to encourage merging routes.\n    5.  Sparsification: Sets unpromising edges to zero to focus the search.\n    6.  Clustering Coefficient: Encourages connections between nodes within local clusters\n    7.  Adaptive Weighting: Adjusts weights based on problem characteristics (e.g., tightness of capacity) and node characteristics.\n    8.  Orientation: Nodes in similar direction from the depot are more likely to be on the same route\n    9.  Demand-Distance interaction: Penalize long edges between high-demand nodes.\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):  # Only check at the depot\n                demand_heuristic[i, j] = 0.1 # Lower, as the depot is important.\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05 # Much Lower, avoid overload\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # 4. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n\n    # 5. Clustering Coefficient approximation (Local Density)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = 6  # Consider only k-nearest neighbors for clustering\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1  # k-nearest neighbors excluding depot, adjusting index\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = common_neighbors / k_nearest\n\n    # 6. Orientation Heuristic\n    orientation_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Calculate angles from depot\n                angle_i = np.arctan2(coordinates[i, 1] - coordinates[0, 1], coordinates[i, 0] - coordinates[0, 0])\n                angle_j = np.arctan2(coordinates[j, 1] - coordinates[0, 1], coordinates[j, 0] - coordinates[0, 0])\n\n                # Angle difference\n                angle_diff = np.abs(angle_i - angle_j)\n                angle_diff = np.min([angle_diff, 2 * np.pi - angle_diff])  # Ensure smaller angle\n\n                # Prioritize similar orientations (smaller angle difference)\n                orientation_heuristic[i, j] = np.exp(-angle_diff) # Exponential decay\n\n    # 7. Demand-Distance Interaction\n    demand_distance_heuristic = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n             demand_distance_heuristic[i, j] = np.exp(- (demands[i] + demands[j]) * distance_matrix[i, j] / capacity) # Penalize long edges between high-demand nodes.\n\n    # 8. Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n    alpha = 0.3\n    beta = 0.15\n    gamma = 0.05\n    delta = 0.15\n    eta = 0.1\n    mu = 0.1\n    zeta = 0.15\n    theta = 0.1\n\n    # Adjust alpha (distance) and beta (depot) based on capacity ratio\n    alpha += 0.1 * capacity_ratio  # Increase importance of distance if capacity is tight\n    beta -= 0.05 * capacity_ratio  # Decrease importance of going to depot if capacity is tight (more local clusters)\n\n    # Node Diversity Weighting\n    demand_std = np.std(demands[1:])\n    distance_to_depot_std = np.std(distance_matrix[0, 1:])\n\n    if demand_std > 0 and distance_to_depot_std > 0:\n        alpha += 0.05 * (demand_std / np.mean(demands[1:]))\n        beta += 0.05 * (distance_to_depot_std / np.mean(distance_matrix[0,1:]))\n\n\n    # Combine the heuristics with adaptive weights. Weights could be tuned by a metaheuristic\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * savings_heuristic + delta * clustering_heuristic + eta * orientation_heuristic + mu * demand_distance_heuristic\n\n    # 9. Sparsification\n    # Only keep edges with a heuristic value above a certain threshold or that are among the k-nearest neighbors.\n    k_nearest = min(10, n - 1)  # consider only k-nearest neighbors.\n    threshold = np.percentile(heuristics[heuristics > 0], 30)  # Dynamic threshold (e.g., 30th percentile)\n\n    for i in range(n):\n        # Find k-nearest neighbors\n        nearest_neighbors = np.argsort(heuristics[i, :])[::-1][1:k_nearest+1] # excluding self loop\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines normalized distance, demand, savings,\n       depot proximity, and clustering. Adaptive weights and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Normalized Distance\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Savings Heuristic (normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 4. Depot Proximity (normalized)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / (np.max(distance_matrix) + epsilon)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n    # 5. Clustering Encouragement\n    clustering_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            dist_ij = distance_matrix[i, j]\n            clustering_heuristic[i, j] = clustering_heuristic[j, i] = np.exp(-dist_ij / (distance_matrix[i, 0] + distance_matrix[j, 0] + epsilon))\n\n    # Adaptive Weighting (based on capacity utilization)\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))\n    alpha = 0.3  # Distance\n    beta = 0.2 # Depot\n    gamma = 0.25  # Savings\n    delta = 0.25  # Clustering\n\n    if capacity_ratio > 0.7:  # High capacity utilization\n        alpha -= 0.05\n        gamma += 0.05\n    elif capacity_ratio < 0.3:  # Low capacity utilization\n        beta += 0.05\n        delta -= 0.05\n\n    heuristics = (alpha * distance_heuristic * demand_heuristic +\n                  beta * depot_heuristic +\n                  gamma * savings_heuristic * demand_heuristic +\n                  delta * clustering_heuristic)\n\n    # Sparsification (k-NN and percentile threshold)\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 40)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, savings, angle cost, depot proximity, with adaptive weights and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component (normalized)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n\n\n    # 3. Savings Heuristic (normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 4. Depot Proximity Heuristic (normalized)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / (np.max(distance_matrix) + epsilon)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # 5. Angle Cost (prioritize nodes with smaller angles from the depot)\n    angle_heuristic = np.zeros((n, n))\n    depot_coords = coordinates[0]\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                angle_heuristic[i, j] = 0\n                continue\n\n            vector_i = coordinates[i] - depot_coords\n            vector_j = coordinates[j] - depot_coords\n\n            # Calculate the angle between the two vectors\n            dot_product = np.dot(vector_i, vector_j)\n            magnitudes = np.linalg.norm(vector_i) * np.linalg.norm(vector_j)\n            if magnitudes == 0:\n                angle = 0\n            else:\n                angle = np.arccos(np.clip(dot_product / magnitudes, -1.0, 1.0))\n\n            angle_heuristic[i, j] = 1 - (angle / np.pi)  # Smaller angles are preferred\n\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)\n\n    # 6. Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))\n    alpha = 0.3  # Distance\n    beta = 0.2   # Depot Proximity\n    gamma = 0.2   # Savings\n    delta = 0.2   # Angle Cost\n    eta = 0.1 # Demand Feasibility\n\n\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * savings_heuristic * demand_heuristic + delta * angle_heuristic + eta * demand_heuristic\n\n\n    # 7. Sparsification (k-NN + Threshold)\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 40) # Adjust percentile as needed\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] # Find k-nearest neighbors\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # 8. Normalization\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, savings, angle cost, depot proximity, with adaptive weights and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component (normalized)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n\n\n    # 3. Savings Heuristic (normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 4. Depot Proximity Heuristic (normalized)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / (np.max(distance_matrix) + epsilon)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # 5. Angle Cost (prioritize nodes with smaller angles from the depot)\n    angle_heuristic = np.zeros((n, n))\n    depot_coords = coordinates[0]\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                angle_heuristic[i, j] = 0\n                continue\n\n            vector_i = coordinates[i] - depot_coords\n            vector_j = coordinates[j] - depot_coords\n\n            # Calculate the angle between the two vectors\n            dot_product = np.dot(vector_i, vector_j)\n            magnitudes = np.linalg.norm(vector_i) * np.linalg.norm(vector_j)\n            if magnitudes == 0:\n                angle = 0\n            else:\n                angle = np.arccos(np.clip(dot_product / magnitudes, -1.0, 1.0))\n\n            angle_heuristic[i, j] = 1 - (angle / np.pi)  # Smaller angles are preferred\n\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)\n\n    # 6. Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))\n    alpha = 0.3  # Distance\n    beta = 0.2   # Depot Proximity\n    gamma = 0.2   # Savings\n    delta = 0.2   # Angle Cost\n    eta = 0.1 # Demand Feasibility\n\n\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * savings_heuristic * demand_heuristic + delta * angle_heuristic + eta * demand_heuristic\n\n\n    # 7. Sparsification (k-NN + Threshold)\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 40) # Adjust percentile as needed\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] # Find k-nearest neighbors\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # 8. Normalization\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, savings, angle cost, depot proximity, with adaptive weights and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component (normalized)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n\n\n    # 3. Savings Heuristic (normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 4. Depot Proximity Heuristic (normalized)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / (np.max(distance_matrix) + epsilon)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # 5. Angle Cost (prioritize nodes with smaller angles from the depot)\n    angle_heuristic = np.zeros((n, n))\n    depot_coords = coordinates[0]\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                angle_heuristic[i, j] = 0\n                continue\n\n            vector_i = coordinates[i] - depot_coords\n            vector_j = coordinates[j] - depot_coords\n\n            # Calculate the angle between the two vectors\n            dot_product = np.dot(vector_i, vector_j)\n            magnitudes = np.linalg.norm(vector_i) * np.linalg.norm(vector_j)\n            if magnitudes == 0:\n                angle = 0\n            else:\n                angle = np.arccos(np.clip(dot_product / magnitudes, -1.0, 1.0))\n\n            angle_heuristic[i, j] = 1 - (angle / np.pi)  # Smaller angles are preferred\n\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)\n\n    # 6. Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))\n    alpha = 0.3  # Distance\n    beta = 0.2   # Depot Proximity\n    gamma = 0.2   # Savings\n    delta = 0.2   # Angle Cost\n    eta = 0.1 # Demand Feasibility\n\n\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * savings_heuristic * demand_heuristic + delta * angle_heuristic + eta * demand_heuristic\n\n\n    # 7. Sparsification (k-NN + Threshold)\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 40) # Adjust percentile as needed\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] # Find k-nearest neighbors\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # 8. Normalization\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines distance, demand, depot proximity, savings, clustering, centrality, adaptive weighting, sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance (normalized)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Depot Proximity (normalized)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n    # 4. Savings (normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 5. Clustering (adaptive k)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = min(10, n - 1)\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = common_neighbors / k_nearest\n    clustering_heuristic = clustering_heuristic / np.max(clustering_heuristic)\n\n    # 6. Node Centrality (normalized)\n    centrality = np.zeros(n)\n    for i in range(1, n):\n        centrality[i] = np.sum(distance_matrix[i, 1:])\n    centrality = np.max(centrality) / (centrality + epsilon)\n    centrality[0] = 1\n    centrality_heuristic = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            centrality_heuristic[i, j] = (centrality[i] + centrality[j]) / 2.0\n    centrality_heuristic = centrality_heuristic / np.max(centrality_heuristic)\n\n    # Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))\n    num_nodes_factor = n / 100.0\n\n    alpha = 0.2\n    beta = 0.15\n    gamma = 0.1\n    delta = 0.15\n    eta = 0.2\n\n    alpha += 0.05 * capacity_ratio + 0.02 * num_nodes_factor\n    beta -= 0.03 * capacity_ratio - 0.01 * num_nodes_factor\n    gamma += 0.02 * capacity_ratio + 0.03 * num_nodes_factor\n    delta += 0.01 * capacity_ratio + 0.02 * num_nodes_factor\n    eta -= 0.01 * capacity_ratio - 0.02 * num_nodes_factor\n\n    # Combine heuristics\n    heuristics = (alpha * distance_heuristic * demand_heuristic +\n                  beta * depot_heuristic +\n                  gamma * savings_heuristic +\n                  delta * clustering_heuristic +\n                  eta * centrality_heuristic)\n\n    # Sparsification (adaptive threshold)\n    k_nearest = min(12, n - 1)\n    threshold = np.percentile(heuristics[heuristics > 0], 40)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 19th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines distance, demand, depot proximity, savings, clustering, centrality, adaptive weighting, sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance (normalized)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Depot Proximity (normalized)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n    # 4. Savings (normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 5. Clustering (adaptive k)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = min(10, n - 1)\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = common_neighbors / k_nearest\n    clustering_heuristic = clustering_heuristic / np.max(clustering_heuristic)\n\n    # 6. Node Centrality (normalized)\n    centrality = np.zeros(n)\n    for i in range(1, n):\n        centrality[i] = np.sum(distance_matrix[i, 1:])\n    centrality = np.max(centrality) / (centrality + epsilon)\n    centrality[0] = 1\n    centrality_heuristic = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            centrality_heuristic[i, j] = (centrality[i] + centrality[j]) / 2.0\n    centrality_heuristic = centrality_heuristic / np.max(centrality_heuristic)\n\n    # Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))\n    num_nodes_factor = n / 100.0\n\n    alpha = 0.2\n    beta = 0.15\n    gamma = 0.1\n    delta = 0.15\n    eta = 0.2\n\n    alpha += 0.05 * capacity_ratio + 0.02 * num_nodes_factor\n    beta -= 0.03 * capacity_ratio - 0.01 * num_nodes_factor\n    gamma += 0.02 * capacity_ratio + 0.03 * num_nodes_factor\n    delta += 0.01 * capacity_ratio + 0.02 * num_nodes_factor\n    eta -= 0.01 * capacity_ratio - 0.02 * num_nodes_factor\n\n    # Combine heuristics\n    heuristics = (alpha * distance_heuristic * demand_heuristic +\n                  beta * depot_heuristic +\n                  gamma * savings_heuristic +\n                  delta * clustering_heuristic +\n                  eta * centrality_heuristic)\n\n    # Sparsification (adaptive threshold)\n    k_nearest = min(12, n - 1)\n    threshold = np.percentile(heuristics[heuristics > 0], 40)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 20th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines distance, demand, depot proximity, savings, clustering, centrality, adaptive weighting, sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance (normalized)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Depot Proximity (normalized)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n    # 4. Savings (normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 5. Clustering (adaptive k)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = min(10, n - 1)\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = common_neighbors / k_nearest\n    clustering_heuristic = clustering_heuristic / np.max(clustering_heuristic)\n\n    # 6. Node Centrality (normalized)\n    centrality = np.zeros(n)\n    for i in range(1, n):\n        centrality[i] = np.sum(distance_matrix[i, 1:])\n    centrality = np.max(centrality) / (centrality + epsilon)\n    centrality[0] = 1\n    centrality_heuristic = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            centrality_heuristic[i, j] = (centrality[i] + centrality[j]) / 2.0\n    centrality_heuristic = centrality_heuristic / np.max(centrality_heuristic)\n\n    # Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))\n    num_nodes_factor = n / 100.0\n\n    alpha = 0.2\n    beta = 0.15\n    gamma = 0.1\n    delta = 0.15\n    eta = 0.2\n\n    alpha += 0.05 * capacity_ratio + 0.02 * num_nodes_factor\n    beta -= 0.03 * capacity_ratio - 0.01 * num_nodes_factor\n    gamma += 0.02 * capacity_ratio + 0.03 * num_nodes_factor\n    delta += 0.01 * capacity_ratio + 0.02 * num_nodes_factor\n    eta -= 0.01 * capacity_ratio - 0.02 * num_nodes_factor\n\n    # Combine heuristics\n    heuristics = (alpha * distance_heuristic * demand_heuristic +\n                  beta * depot_heuristic +\n                  gamma * savings_heuristic +\n                  delta * clustering_heuristic +\n                  eta * centrality_heuristic)\n\n    # Sparsification (adaptive threshold)\n    k_nearest = min(12, n - 1)\n    threshold = np.percentile(heuristics[heuristics > 0], 40)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}