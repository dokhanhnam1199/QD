{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\nCurrent heuristics:\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates several improvements over v1, including:\n\n    1.  Adaptive Distance Scaling: Dynamically adjusts the importance of distance based on problem tightness.\n    2.  Refined Demand Feasibility: Considers remaining vehicle capacity for more accurate feasibility assessments.\n    3.  Enhanced Depot Attraction: Uses a softmax function to prioritize returns to the depot based on urgency.\n    4.  Adaptive Gravitational Constant: Adjusts the gravitational constant based on the average demand.\n    5.  Edge Clustering Coefficient: Focuses on connections within high-demand clusters.\n    6.  Lookahead Savings: Estimates savings based on potential future connections.\n    7.  Reinforced Sparsification: Adaptively sets thresholds based on edge characteristics.\n    8.  Capacity Slack Aware weight adjustments: adjusts weights based on how close total demand is to vehicle capacity.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Adaptive Distance Scaling\n    total_demand = np.sum(demands[1:])\n    capacity_ratio = total_demand / (capacity * (n - 1))\n    distance_scale = 1.0 + 0.5 * capacity_ratio  # Increase distance importance if capacity is tight\n    distance_heuristic = 1 / (distance_matrix * distance_scale + epsilon)\n\n    # 2. Refined Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            #Consider the edge between depot and the node.\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Enhanced Depot Attraction\n    depot_heuristic = np.zeros((n, n))\n    urgency_factor = 5.0\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        urgency = np.exp(urgency_factor * (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity))\n        depot_heuristic[i, 0] = urgency\n        depot_heuristic[0, i] = urgency\n\n    # 4. Adaptive Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    avg_demand = np.mean(demands[1:])\n    adaptive_gravitational_constant = 1.0 + 0.2 * (avg_demand / capacity)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            mass_i = demands[i]\n            mass_j = demands[j]\n            gravitational_heuristic[i, j] = adaptive_gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n\n    # 5. Savings Heuristic with Lookahead\n    savings_heuristic = np.zeros((n, n))\n    lookahead_neighbors = 5 #number of neighbors to consider for lookahead\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            #Lookahead\n            neighbor_i = np.argsort(distance_matrix[i, 1:])[:lookahead_neighbors] + 1\n            neighbor_j = np.argsort(distance_matrix[j, 1:])[:lookahead_neighbors] + 1\n            future_savings = 0\n            for ni in neighbor_i:\n                for nj in neighbor_j:\n                    future_savings += distance_matrix[ni, 0] + distance_matrix[0, nj] - distance_matrix[ni, nj]\n            savings += 0.1 * future_savings / (lookahead_neighbors**2 + epsilon)\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n\n    # 6. Edge Clustering Coefficient (focus on high-demand clusters)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = 6\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = (common_neighbors / k_nearest) * (demands[i] + demands[j]) / (2*capacity) # Scale by demand\n\n    # 7. Sparsification\n    k_nearest = 10\n    sparsification_threshold = 25 #more aggressive sparsification\n    heuristics = (distance_heuristic * demand_heuristic)**0.5 + 0.3 * depot_heuristic + 0.2 * gravitational_heuristic + 0.15 * savings_heuristic + 0.1 * clustering_heuristic\n    threshold = np.percentile(heuristics[heuristics > 0], sparsification_threshold)\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # 8. Capacity Slack Aware Weight Adjustments\n\n    # Measure capacity slack as the percentage of unused capacity across all vehicles, assuming one vehicle per customer.\n    capacity_slack = 1 - (total_demand / (capacity * (n - 1)))\n    alpha = 0.4 # Distance heuristic\n    beta = 0.2 # Depot heuristic\n    gamma = 0.1 # Gravitational heuristic\n    delta = 0.15 # Savings heuristic\n    eta = 0.15 # Clustering heuristic\n\n    # If we have a lot of spare capacity, reduce the importance of the depot trips.\n    alpha = alpha + 0.1*capacity_slack # Give more weight to distance\n    beta = beta - 0.1*capacity_slack  # Give less weight to depot\n    gamma = gamma + 0.05*capacity_slack\n    delta = delta + 0.05*capacity_slack\n    # Recombine heuristics with adjusted weights.\n    # heuristics = (distance_heuristic * demand_heuristic)**0.5 + 0.3 * depot_heuristic + 0.2 * gravitational_heuristic + 0.15 * savings_heuristic + 0.1 * clustering_heuristic\n    # Normalize\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\nNow, think outside the box write a mutated function `heuristics_v2` better than current version.\nYou can use some hints below:\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, here's a redefinition of \"Current Self-Reflection\" optimized for designing better heuristics, while avoiding the pitfalls of the \"Ineffective Self-Reflection\":\n\n*   **Keywords:** Problem-specific, Adaptive, Normalization, Sparsification, Diverse Factors, Robustness, Solution Quality Influence, Spatial relationships, Clustering, Gravitational attraction.\n\n*   **Advice:** Actively seek and incorporate problem-specific knowledge, especially spatial relationships, clustering, and gravitational attraction; meticulously normalize individual heuristic components; and implement adaptive weighting schemes based on *multiple* problem characteristics and consider sparsification.\n\n*   **Avoid:** Generic \"consider diverse factors.\" Don't just mention adaptive weighting; focus on making it responsive to multiple problem features.\n\n*   **Explanation:** The goal is to move beyond vague recommendations to actionable strategies by emphasizing the importance of normalization and adaptive weighting schemes to multiple problem characteristics, leading to enhanced robustness and adaptability.\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}