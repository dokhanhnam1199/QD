```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP combining distance, demand, and angle; adds depot proximity.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))
    normalized_demands = demands / np.max(demands)  # Scale to 0-1

    for i in range(n):
        for j in range(n):
            if i != j:
                distance_factor = 1 / distance_matrix[i, j]
                demand_factor = 1 - normalized_demands[j]
                if i == 0:
                    demand_factor = 1.0

                # Angle heuristic relative to the depot
                depot_x, depot_y = coordinates[0]
                i_x, i_y = coordinates[i]
                j_x, j_y = coordinates[j]

                vector_ij = np.array([j_x - i_x, j_y - i_y])
                vector_di = np.array([i_x - depot_x, i_y - depot_y])

                vector_ij = vector_ij / (np.linalg.norm(vector_ij) + 1e-9)
                vector_di = vector_di / (np.linalg.norm(vector_di) + 1e-9)

                dot_product = np.clip(np.dot(vector_ij, vector_di), -1.0, 1.0)
                angle = np.arccos(dot_product)
                angle_factor = 1 - (angle / np.pi)

                # Depot proximity: encourage nodes close to depot
                depot_distance_i = distance_matrix[0, i]
                depot_distance_j = distance_matrix[0, j]
                depot_proximity_factor = 1 / (depot_distance_i + depot_distance_j + 1e-9)

                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor * depot_proximity_factor
            else:
                heuristic_matrix[i, j] = 0

    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        heuristic_matrix /= max_heuristic
    else:
        heuristic_matrix = np.ones_like(heuristic_matrix) / n

    return heuristic_matrix
```
