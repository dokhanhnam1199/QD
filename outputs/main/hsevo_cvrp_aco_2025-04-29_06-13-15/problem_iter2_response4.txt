```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Enhanced heuristic combining distance, demand, angle, and depot proximity."""
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Distance and demand scaling
    demand_scaled_distance = distance_matrix * (demands[np.newaxis, :] + demands[:, np.newaxis]) / (2 * capacity)
    demand_scaled_distance = np.where(demand_scaled_distance == 0, np.inf, demand_scaled_distance)

    # Depot proximity
    depot_x, depot_y = coordinates[0]
    for i in range(1, n):
        for j in range(1, n):
            if i == j:
                continue
            node_i_x, node_i_y = coordinates[i]
            node_j_x, node_j_y = coordinates[j]

            angle_i = np.arctan2(node_i_y - depot_y, node_i_x - depot_x)
            angle_j = np.arctan2(node_j_y - depot_y, node_j_x - depot_x)
            angle_diff = np.abs(angle_i - angle_j)
            angle_diff = np.minimum(angle_diff, 2 * np.pi - angle_diff)
            angular_penalty = (angle_diff / np.pi)

            depot_proximity = 1 - 0.9 * max(distance_matrix[0,i], distance_matrix[0,j]) / np.mean(distance_matrix)

            heuristics[i, j] = 1 / (demand_scaled_distance[i, j] + 0.1 * angular_penalty) + 0.5 * depot_proximity # combine, add proximity
            heuristics[j, i] = heuristics[i, j]

    # Depot edges prioritization
    for i in range(1, n):
        heuristics[0, i] = 1.0 / (distance_matrix[0, i] * demands[i] / capacity + 1e-6)
        heuristics[i, 0] = heuristics[0, i]

    # No self-loops
    for i in range(n):
        heuristics[i, i] = 0

    return heuristics
```
