{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Heuristic combining distance, demand, depot proximity, savings, gravitational attraction, and adaptive weights with sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                 demand_heuristic[i,j] = 0.05\n\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # 4. Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0\n    for i in range(1, n):\n        for j in range(1, n):\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n\n    # 5. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_heuristic[i, j] = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[j, i] = savings_heuristic[i, j]\n\n    # Adaptive Weighting\n    avg_demand = np.mean(demands[1:])\n    demand_ratio = avg_demand / capacity\n\n    weight_distance = 0.4\n    weight_demand = 0.3\n    weight_depot = 0.1 + demand_ratio * 0.2\n    weight_gravitational = 0.1\n    weight_savings = 0.1 - demand_ratio * 0.05\n\n    heuristics = (weight_distance * distance_heuristic * demand_heuristic +\n                  weight_depot * depot_heuristic +\n                  weight_gravitational * gravitational_heuristic +\n                  weight_savings * savings_heuristic)\n\n    # Sparsification: k-NN\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 30)  # Adaptive threshold\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines distance, demand, depot proximity,savings and gravitation with sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0\n    for i in range(1, n):\n        for j in range(1, n):\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n\n    # Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n\n    # Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n    alpha = 0.3\n    beta = 0.15\n    gamma = 0.1\n    delta = 0.1\n\n    alpha += 0.1 * capacity_ratio  # Increase importance of distance if capacity is tight\n    beta -= 0.05 * capacity_ratio  # Decrease importance of going to depot if capacity is tight\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * gravitational_heuristic + delta * savings_heuristic\n\n    # Sparsification\n    k_nearest = 10  # consider only k-nearest neighbors.\n    threshold = np.percentile(heuristics[heuristics > 0], 30)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines distance, demand, depot proximity,savings and gravitation with sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0\n    for i in range(1, n):\n        for j in range(1, n):\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n\n    # Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n\n    # Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n    alpha = 0.3\n    beta = 0.15\n    gamma = 0.1\n    delta = 0.1\n\n    alpha += 0.1 * capacity_ratio  # Increase importance of distance if capacity is tight\n    beta -= 0.05 * capacity_ratio  # Decrease importance of going to depot if capacity is tight\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * gravitational_heuristic + delta * savings_heuristic\n\n    # Sparsification\n    k_nearest = 10  # consider only k-nearest neighbors.\n    threshold = np.percentile(heuristics[heuristics > 0], 30)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1. Distance: Edges with shorter distances are preferred.\n    2. Demand Feasibility: Penalizes edges that would immediately violate capacity constraints.\n    3. Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4. Savings Heuristic Integration: Encourages merging routes.\n    5. Sparsification: Sets unpromising edges to zero to focus the search.\n    6. Clustering Coefficient: Encourages connections between nodes within local clusters\n    7. Adaptive Weighting: Adjusts weights based on problem characteristics (e.g., tightness of capacity) and node proximity.\n    8. Angle Cost: Penalizes sharp turns (high angle cost) to promote smoother routes.\n    9. Demand Density: Encourages connections in dense demand regions.\n    10. Randomized Perturbation: Adds a small random value to each edge's heuristic value for diversity.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n    demand_heuristic = (demand_heuristic - np.min(demand_heuristic)) / (np.max(demand_heuristic) - np.min(demand_heuristic) + epsilon)\n\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n    # 4. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 5. Clustering Coefficient approximation (Local Density)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = 6  # Consider only k-nearest neighbors for clustering\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1  # k-nearest neighbors excluding depot, adjusting index\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = common_neighbors / k_nearest\n    clustering_heuristic = (clustering_heuristic - np.min(clustering_heuristic)) / (np.max(clustering_heuristic) - np.min(clustering_heuristic) + epsilon)\n\n    # 8. Angle Cost Heuristic\n    angle_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Calculate angle between vectors (0 -> i) and (i -> j)\n                vector_oi = coordinates[i] - coordinates[0]\n                vector_ij = coordinates[j] - coordinates[i]\n                dot_product = np.dot(vector_oi, vector_ij)\n                magnitude_oi = np.linalg.norm(vector_oi)\n                magnitude_ij = np.linalg.norm(vector_ij)\n\n                if magnitude_oi > 0 and magnitude_ij > 0:\n                    cosine_angle = dot_product / (magnitude_oi * magnitude_ij)\n                    cosine_angle = np.clip(cosine_angle, -1.0, 1.0)  # Clip to valid range\n                    angle = np.arccos(cosine_angle)\n                    angle_cost = angle / np.pi  # Normalize to [0, 1]\n                    angle_heuristic[i, j] = 1 - angle_cost  # Prefer smaller angles\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)\n\n\n    # 9. Demand Density Heuristic\n    demand_density_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                #Consider nodes near to node i, and j\n                near_nodes_i = np.argsort(distance_matrix[i, 1:])[:5] + 1 #5 nearest\n                near_nodes_j = np.argsort(distance_matrix[j, 1:])[:5] + 1 #5 nearest\n\n                total_demand_i = np.sum(demands[near_nodes_i])\n                total_demand_j = np.sum(demands[near_nodes_j])\n\n                demand_density_heuristic[i,j] = (total_demand_i + total_demand_j)\n\n    demand_density_heuristic = (demand_density_heuristic - np.min(demand_density_heuristic)) / (np.max(demand_density_heuristic) - np.min(demand_density_heuristic) + epsilon)\n\n    # Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n\n    # Dynamically adjust weights based on capacity_ratio and node proximity\n    alpha = 0.2 #Distance\n    beta = 0.1 #Depot\n    gamma = 0.05 #savings\n    delta = 0.15  #clustering\n    eta = 0.3 #angle\n    phi = 0.2 #demand density\n\n    #Adjust weights\n    alpha += 0.05 * capacity_ratio #Tighter -> prioritize distance\n    beta -= 0.05 * capacity_ratio #Tighter -> less depot\n    eta += 0.05 * capacity_ratio #Tighter -> prioritize smoother turns\n\n    #Combine\n    heuristics = alpha * distance_heuristic + beta * depot_heuristic + gamma * savings_heuristic + delta * clustering_heuristic + eta * angle_heuristic + phi * demand_density_heuristic\n\n    # 10. Randomized Perturbation for diversity\n    random_perturbation = np.random.normal(0, 0.01, size=(n, n))\n    heuristics += random_perturbation\n\n    # Sparsification\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 30)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] #excluding self loop and depot\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1. Distance: Edges with shorter distances are preferred.\n    2. Demand Feasibility: Penalizes edges that would immediately violate capacity constraints.\n    3. Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4. Savings Heuristic Integration: Encourages merging routes.\n    5. Sparsification: Sets unpromising edges to zero to focus the search.\n    6. Clustering Coefficient: Encourages connections between nodes within local clusters\n    7. Adaptive Weighting: Adjusts weights based on problem characteristics (e.g., tightness of capacity) and node proximity.\n    8. Angle Cost: Penalizes sharp turns (high angle cost) to promote smoother routes.\n    9. Demand Density: Encourages connections in dense demand regions.\n    10. Randomized Perturbation: Adds a small random value to each edge's heuristic value for diversity.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n    demand_heuristic = (demand_heuristic - np.min(demand_heuristic)) / (np.max(demand_heuristic) - np.min(demand_heuristic) + epsilon)\n\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n    # 4. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 5. Clustering Coefficient approximation (Local Density)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = 6  # Consider only k-nearest neighbors for clustering\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1  # k-nearest neighbors excluding depot, adjusting index\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = common_neighbors / k_nearest\n    clustering_heuristic = (clustering_heuristic - np.min(clustering_heuristic)) / (np.max(clustering_heuristic) - np.min(clustering_heuristic) + epsilon)\n\n    # 8. Angle Cost Heuristic\n    angle_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Calculate angle between vectors (0 -> i) and (i -> j)\n                vector_oi = coordinates[i] - coordinates[0]\n                vector_ij = coordinates[j] - coordinates[i]\n                dot_product = np.dot(vector_oi, vector_ij)\n                magnitude_oi = np.linalg.norm(vector_oi)\n                magnitude_ij = np.linalg.norm(vector_ij)\n\n                if magnitude_oi > 0 and magnitude_ij > 0:\n                    cosine_angle = dot_product / (magnitude_oi * magnitude_ij)\n                    cosine_angle = np.clip(cosine_angle, -1.0, 1.0)  # Clip to valid range\n                    angle = np.arccos(cosine_angle)\n                    angle_cost = angle / np.pi  # Normalize to [0, 1]\n                    angle_heuristic[i, j] = 1 - angle_cost  # Prefer smaller angles\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)\n\n\n    # 9. Demand Density Heuristic\n    demand_density_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                #Consider nodes near to node i, and j\n                near_nodes_i = np.argsort(distance_matrix[i, 1:])[:5] + 1 #5 nearest\n                near_nodes_j = np.argsort(distance_matrix[j, 1:])[:5] + 1 #5 nearest\n\n                total_demand_i = np.sum(demands[near_nodes_i])\n                total_demand_j = np.sum(demands[near_nodes_j])\n\n                demand_density_heuristic[i,j] = (total_demand_i + total_demand_j)\n\n    demand_density_heuristic = (demand_density_heuristic - np.min(demand_density_heuristic)) / (np.max(demand_density_heuristic) - np.min(demand_density_heuristic) + epsilon)\n\n    # Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n\n    # Dynamically adjust weights based on capacity_ratio and node proximity\n    alpha = 0.2 #Distance\n    beta = 0.1 #Depot\n    gamma = 0.05 #savings\n    delta = 0.15  #clustering\n    eta = 0.3 #angle\n    phi = 0.2 #demand density\n\n    #Adjust weights\n    alpha += 0.05 * capacity_ratio #Tighter -> prioritize distance\n    beta -= 0.05 * capacity_ratio #Tighter -> less depot\n    eta += 0.05 * capacity_ratio #Tighter -> prioritize smoother turns\n\n    #Combine\n    heuristics = alpha * distance_heuristic + beta * depot_heuristic + gamma * savings_heuristic + delta * clustering_heuristic + eta * angle_heuristic + phi * demand_density_heuristic\n\n    # 10. Randomized Perturbation for diversity\n    random_perturbation = np.random.normal(0, 0.01, size=(n, n))\n    heuristics += random_perturbation\n\n    # Sparsification\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 30)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] #excluding self loop and depot\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics combining distance, demand, savings, angles, and adaptive weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component (normalized)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                demand_heuristic[i, j] = 0.1  # Reduced penalty\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05 #reduced penalty\n\n    # 3. Depot Proximity (normalized)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]\n        depot_preference = (avg_distance / (np.max(distance_matrix) + epsilon)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n    # 4. Savings Heuristic (normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 5. Angle-based Clustering\n    angle_heuristic = np.zeros((n, n))\n    depot_x, depot_y = coordinates[0]\n    for i in range(1, n):\n        angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)\n        for j in range(i + 1, n):\n            angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)\n            angle_diff = min(abs(angle_i - angle_j), 2 * np.pi - abs(angle_i - angle_j))\n            angle_preference = np.exp(-angle_diff)  # Higher value for smaller angle differences\n            angle_heuristic[i, j] = angle_preference\n            angle_heuristic[j, i] = angle_preference\n\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)\n\n    # 6. Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n-1))\n    alpha = 0.35 #distance\n    beta = 0.1 #depot\n    gamma = 0.25 #savings\n    delta = 0.3 # Angle\n    if capacity < np.mean(demands) * 5: # Tighter capacity constraints, increase savings\n        gamma += 0.05\n        alpha -= 0.05\n\n    # Combine the heuristics with adaptive weights\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * savings_heuristic * demand_heuristic + delta * angle_heuristic * demand_heuristic\n\n    # 7. Sparsification\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 40)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, savings, depot proximity, and angle heuristics with adaptive weighting and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                 demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / (np.max(distance_matrix) + epsilon)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # 4. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n\n    # 5. Angle-based Clustering\n    angle_heuristic = np.zeros((n, n))\n    depot_x, depot_y = coordinates[0]\n    for i in range(1, n):\n        angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)\n        for j in range(i + 1, n):\n            angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)\n            angle_diff = min(abs(angle_i - angle_j), 2 * np.pi - abs(angle_i - angle_j))\n            angle_preference = np.exp(-angle_diff)\n            angle_heuristic[i, j] = angle_preference\n            angle_heuristic[j, i] = angle_preference\n\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)\n\n\n    # 6. Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n-1))\n    alpha = 0.35\n    beta = 0.1\n    gamma = 0.25\n    delta = 0.3\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * savings_heuristic * demand_heuristic + delta * angle_heuristic * demand_heuristic\n\n    # 7. Sparsification (Adaptive Threshold)\n    mean_heuristic = np.mean(heuristics[heuristics > 0])\n    threshold = 0.5 * mean_heuristic\n\n    heuristics[heuristics < threshold] = 0\n\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines distance, demand, savings, depot proximity, and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n\n    # Combine heuristics\n    alpha = 0.4\n    beta = 0.2\n    delta = 0.4\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + delta * savings_heuristic\n\n    # Sparsify the matrix using k-NN and thresholding\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 30)\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines distance, demand, depot proximity, savings, clustering, and adaptive weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component (normalized)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Depot Proximity (normalized and enhanced)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # 4. Savings Heuristic (normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 5. Clustering Encouragement (based on spatial proximity)\n    clustering_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            dist_ij = distance_matrix[i, j]\n            # Encourage connections between nodes that are close relative to their distance to the depot\n            clustering_heuristic[i, j] = clustering_heuristic[j, i] = np.exp(-dist_ij / (distance_matrix[i, 0] + distance_matrix[j, 0] + epsilon))\n\n    # Adaptive Weighting (adjust based on problem size/characteristics)\n    n_customers = n - 1\n    alpha = 0.3 #distance\n    beta = 0.15 #depot proximity\n    gamma = 0.20 #savings\n    delta = 0.15 #clustering\n\n    # Adjust weights (example: emphasize depot proximity more for larger problems)\n    if n_customers > 50:\n        beta += 0.05\n        alpha -= 0.05 #reduce alpha a bit\n    if capacity < np.mean(demands) * 5: # Tighter capacity constraints, increase savings\n        gamma += 0.05\n\n    # Combine the heuristics\n    heuristics = (alpha * distance_heuristic * demand_heuristic +\n                  beta * depot_heuristic +\n                  gamma * savings_heuristic +\n                  delta * clustering_heuristic)\n\n    # 6. Sparsification (adaptive threshold based on heuristic values)\n    threshold = np.percentile(heuristics[heuristics > 0], 40) # Increased sparsity\n\n    k_nearest = 12 #consider k-nearest neighbors, increase it a bit\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines distance, demand, depot proximity, savings, clustering, and adaptive weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component (normalized)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Depot Proximity (normalized and enhanced)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # 4. Savings Heuristic (normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 5. Clustering Encouragement (based on spatial proximity)\n    clustering_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            dist_ij = distance_matrix[i, j]\n            # Encourage connections between nodes that are close relative to their distance to the depot\n            clustering_heuristic[i, j] = clustering_heuristic[j, i] = np.exp(-dist_ij / (distance_matrix[i, 0] + distance_matrix[j, 0] + epsilon))\n\n    # Adaptive Weighting (adjust based on problem size/characteristics)\n    n_customers = n - 1\n    alpha = 0.3 #distance\n    beta = 0.15 #depot proximity\n    gamma = 0.20 #savings\n    delta = 0.15 #clustering\n\n    # Adjust weights (example: emphasize depot proximity more for larger problems)\n    if n_customers > 50:\n        beta += 0.05\n        alpha -= 0.05 #reduce alpha a bit\n    if capacity < np.mean(demands) * 5: # Tighter capacity constraints, increase savings\n        gamma += 0.05\n\n    # Combine the heuristics\n    heuristics = (alpha * distance_heuristic * demand_heuristic +\n                  beta * depot_heuristic +\n                  gamma * savings_heuristic +\n                  delta * clustering_heuristic)\n\n    # 6. Sparsification (adaptive threshold based on heuristic values)\n    threshold = np.percentile(heuristics[heuristics > 0], 40) # Increased sparsity\n\n    k_nearest = 12 #consider k-nearest neighbors, increase it a bit\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines distance, demand, depot proximity, savings, clustering, and adaptive weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component (normalized)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Depot Proximity (normalized and enhanced)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # 4. Savings Heuristic (normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 5. Clustering Encouragement (based on spatial proximity)\n    clustering_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            dist_ij = distance_matrix[i, j]\n            # Encourage connections between nodes that are close relative to their distance to the depot\n            clustering_heuristic[i, j] = clustering_heuristic[j, i] = np.exp(-dist_ij / (distance_matrix[i, 0] + distance_matrix[j, 0] + epsilon))\n\n    # Adaptive Weighting (adjust based on problem size/characteristics)\n    n_customers = n - 1\n    alpha = 0.3 #distance\n    beta = 0.15 #depot proximity\n    gamma = 0.20 #savings\n    delta = 0.15 #clustering\n\n    # Adjust weights (example: emphasize depot proximity more for larger problems)\n    if n_customers > 50:\n        beta += 0.05\n        alpha -= 0.05 #reduce alpha a bit\n    if capacity < np.mean(demands) * 5: # Tighter capacity constraints, increase savings\n        gamma += 0.05\n\n    # Combine the heuristics\n    heuristics = (alpha * distance_heuristic * demand_heuristic +\n                  beta * depot_heuristic +\n                  gamma * savings_heuristic +\n                  delta * clustering_heuristic)\n\n    # 6. Sparsification (adaptive threshold based on heuristic values)\n    threshold = np.percentile(heuristics[heuristics > 0], 40) # Increased sparsity\n\n    k_nearest = 12 #consider k-nearest neighbors, increase it a bit\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1.  Distance: Edges with shorter distances are preferred.\n    2.  Demand Feasibility: Penalizes edges that would immediately violate capacity constraints if used early in a route.\n    3.  Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4.  Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will \"attract\" closer nodes to form clusters.\n    5.  Savings Heuristic Integration: Incorporates the savings heuristic to encourage merging routes.\n    6.  Sparsification: Sets unpromising edges to zero to focus the search.\n    7.  Clustering Coefficient: Encourages connections between nodes within local clusters\n    8.  Adaptive Weighting: Adjusts weights based on problem characteristics (e.g., tightness of capacity)\n    9.  Angle Cost: Penalizes sharp turns in routes, encouraging smoother paths.\n    10. Route Elongation Penalty: Penalizes edges that significantly elongate existing routes beyond a certain threshold.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon) # Normalize\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n    demand_heuristic = (demand_heuristic - np.min(demand_heuristic)) / (np.max(demand_heuristic) - np.min(demand_heuristic) + epsilon) # Normalize\n\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon) # Normalize\n\n\n    # 4. Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0\n    for i in range(1, n):\n        for j in range(1, n):\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n    gravitational_heuristic = (gravitational_heuristic - np.min(gravitational_heuristic)) / (np.max(gravitational_heuristic) - np.min(gravitational_heuristic) + epsilon) # Normalize\n\n\n    # 5. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon) # Normalize\n\n    # 7. Clustering Coefficient approximation (Local Density)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = 6  # Consider only k-nearest neighbors for clustering\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1  # k-nearest neighbors excluding depot, adjusting index\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = common_neighbors / k_nearest\n    clustering_heuristic = (clustering_heuristic - np.min(clustering_heuristic)) / (np.max(clustering_heuristic) - np.min(clustering_heuristic) + epsilon) # Normalize\n\n    # 9. Angle Cost\n    angle_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Calculate angle between vectors depot->i and depot->j\n                vector_i = coordinates[i] - coordinates[0]\n                vector_j = coordinates[j] - coordinates[0]\n                dot_product = np.dot(vector_i, vector_j)\n                magn_i = np.linalg.norm(vector_i)\n                magn_j = np.linalg.norm(vector_j)\n                if magn_i * magn_j == 0:\n                    angle = 0\n                else:\n                    angle = np.arccos(dot_product / (magn_i * magn_j + epsilon))\n                angle_cost = angle / np.pi  # Normalize angle to [0, 1]\n                angle_heuristic[i, j] = 1 - angle_cost  # Prefer smaller angles\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon) # Normalize\n\n    # 10. Route Elongation Penalty (considering current distance from depot)\n    elongation_heuristic = np.ones((n, n))\n    avg_cust_distance = np.mean(distance_matrix[0, 1:])\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                if distance_matrix[i,j] > 2 * avg_cust_distance: # dynamically adjust threshold\n                     elongation_heuristic[i, j] = 0.2 # drastically reduce probability of selection\n    elongation_heuristic = (elongation_heuristic - np.min(elongation_heuristic)) / (np.max(elongation_heuristic) - np.min(elongation_heuristic) + epsilon) # Normalize\n\n\n    # 8. Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n    alpha = 0.25\n    beta = 0.1\n    gamma = 0.05\n    delta = 0.1\n    eta = 0.05\n    mu = 0.15\n    phi = 0.15\n    kappa = 0.15 # route elongation\n\n    alpha += 0.1 * capacity_ratio\n    beta -= 0.05 * capacity_ratio\n\n\n    # Combine the heuristics with adaptive weights.\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + \\\n                 gamma * gravitational_heuristic + delta * savings_heuristic + mu * clustering_heuristic + \\\n                 phi * angle_heuristic + kappa * elongation_heuristic\n\n    # 6. Sparsification\n    k_nearest = 10  # consider only k-nearest neighbors.\n    threshold = np.percentile(heuristics[heuristics > 0], 40)  # Dynamic threshold\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] #excluding self loop and depot\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1.  Distance: Edges with shorter distances are preferred.\n    2.  Demand Feasibility: Penalizes edges that would immediately violate capacity constraints if used early in a route.\n    3.  Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4.  Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will \"attract\" closer nodes to form clusters.\n    5.  Savings Heuristic Integration: Incorporates the savings heuristic to encourage merging routes.\n    6.  Sparsification: Sets unpromising edges to zero to focus the search.\n    7.  Clustering Coefficient: Encourages connections between nodes within local clusters\n    8.  Adaptive Weighting: Adjusts weights based on problem characteristics (e.g., tightness of capacity)\n    9.  Angle Cost: Penalizes sharp turns in routes, encouraging smoother paths.\n    10. Route Elongation Penalty: Penalizes edges that significantly elongate existing routes beyond a certain threshold.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon) # Normalize\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n    demand_heuristic = (demand_heuristic - np.min(demand_heuristic)) / (np.max(demand_heuristic) - np.min(demand_heuristic) + epsilon) # Normalize\n\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon) # Normalize\n\n\n    # 4. Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0\n    for i in range(1, n):\n        for j in range(1, n):\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n    gravitational_heuristic = (gravitational_heuristic - np.min(gravitational_heuristic)) / (np.max(gravitational_heuristic) - np.min(gravitational_heuristic) + epsilon) # Normalize\n\n\n    # 5. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon) # Normalize\n\n    # 7. Clustering Coefficient approximation (Local Density)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = 6  # Consider only k-nearest neighbors for clustering\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1  # k-nearest neighbors excluding depot, adjusting index\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = common_neighbors / k_nearest\n    clustering_heuristic = (clustering_heuristic - np.min(clustering_heuristic)) / (np.max(clustering_heuristic) - np.min(clustering_heuristic) + epsilon) # Normalize\n\n    # 9. Angle Cost\n    angle_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Calculate angle between vectors depot->i and depot->j\n                vector_i = coordinates[i] - coordinates[0]\n                vector_j = coordinates[j] - coordinates[0]\n                dot_product = np.dot(vector_i, vector_j)\n                magn_i = np.linalg.norm(vector_i)\n                magn_j = np.linalg.norm(vector_j)\n                if magn_i * magn_j == 0:\n                    angle = 0\n                else:\n                    angle = np.arccos(dot_product / (magn_i * magn_j + epsilon))\n                angle_cost = angle / np.pi  # Normalize angle to [0, 1]\n                angle_heuristic[i, j] = 1 - angle_cost  # Prefer smaller angles\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon) # Normalize\n\n    # 10. Route Elongation Penalty (considering current distance from depot)\n    elongation_heuristic = np.ones((n, n))\n    avg_cust_distance = np.mean(distance_matrix[0, 1:])\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                if distance_matrix[i,j] > 2 * avg_cust_distance: # dynamically adjust threshold\n                     elongation_heuristic[i, j] = 0.2 # drastically reduce probability of selection\n    elongation_heuristic = (elongation_heuristic - np.min(elongation_heuristic)) / (np.max(elongation_heuristic) - np.min(elongation_heuristic) + epsilon) # Normalize\n\n\n    # 8. Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n    alpha = 0.25\n    beta = 0.1\n    gamma = 0.05\n    delta = 0.1\n    eta = 0.05\n    mu = 0.15\n    phi = 0.15\n    kappa = 0.15 # route elongation\n\n    alpha += 0.1 * capacity_ratio\n    beta -= 0.05 * capacity_ratio\n\n\n    # Combine the heuristics with adaptive weights.\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + \\\n                 gamma * gravitational_heuristic + delta * savings_heuristic + mu * clustering_heuristic + \\\n                 phi * angle_heuristic + kappa * elongation_heuristic\n\n    # 6. Sparsification\n    k_nearest = 10  # consider only k-nearest neighbors.\n    threshold = np.percentile(heuristics[heuristics > 0], 40)  # Dynamic threshold\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] #excluding self loop and depot\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1.  Distance: Edges with shorter distances are preferred.\n    2.  Demand Feasibility: Penalizes edges that would immediately violate capacity constraints.\n    3.  Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4.  Savings Heuristic Integration: Incorporates the savings heuristic to encourage merging routes.\n    5.  Sparsification: Sets unpromising edges to zero to focus the search.\n    6.  Clustering Coefficient: Encourages connections between nodes within local clusters. Uses adaptive k-nearest neighbor count.\n    7.  Adaptive Weighting: Adjusts weights based on problem characteristics (e.g., tightness of capacity, number of nodes).\n    8.  Node Centrality: Prioritizes connections from more \"central\" nodes to distribute routes evenly.\n    9.  Demand Density: Encourages links between nodes with similar demand profiles within spatial proximity\n    10. Route balancing: Add heuristics to encourage routes of a similar length\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component (Normalized)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = distance_heuristic / np.max(distance_heuristic)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n    demand_heuristic = demand_heuristic / np.max(demand_heuristic)\n\n    # 3. Depot Proximity (Normalized)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = depot_heuristic / np.max(depot_heuristic)\n\n    # 4. Savings Heuristic (Normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = savings_heuristic / np.max(savings_heuristic)\n\n    # 6. Clustering Coefficient approximation (Local Density) - Adaptive k\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = min(10, n - 1)  # Adaptive k: Limit to n-1\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = common_neighbors / k_nearest\n    clustering_heuristic = clustering_heuristic / np.max(clustering_heuristic)\n\n\n    # 8. Node Centrality (Closeness Centrality Approximation) (Normalized)\n    centrality = np.zeros(n)\n    for i in range(1, n):\n        centrality[i] = np.sum(distance_matrix[i, 1:])\n    centrality = np.max(centrality) / (centrality + epsilon)  # Higher is more central\n    centrality[0] = 1 #depot as most central\n    centrality_heuristic = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            centrality_heuristic[i, j] = (centrality[i] + centrality[j]) / 2.0\n    centrality_heuristic = centrality_heuristic / np.max(centrality_heuristic)\n\n    # 9. Demand Density (Normalized)\n    demand_density_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            demand_diff = abs(demands[i] - demands[j]) / capacity\n            distance_normalized = distance_matrix[i, j] / np.max(distance_matrix)\n            demand_density_heuristic[i, j] = 1- (demand_diff + distance_normalized) / 2\n    demand_density_heuristic = demand_density_heuristic / np.max(demand_density_heuristic)\n\n    #10. Route Balance (penalize connections that contribute to large imbalances)\n    route_balance_heuristic = np.ones((n,n))\n    avg_route_length = np.sum(distance_matrix) / (n * n)\n\n    for i in range(1,n):\n        for j in range(1,n):\n            if i == j:\n                route_balance_heuristic[i,j] = 0\n            edge_length_deviation = abs(distance_matrix[i,j] - avg_route_length)\n            route_balance_heuristic[i,j] = max(0, 1 - (edge_length_deviation / avg_route_length))\n\n    route_balance_heuristic = route_balance_heuristic / np.max(route_balance_heuristic)\n\n\n\n    # 7. Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n    num_nodes_factor = n / 100.0  # Scale based on the number of nodes\n\n    alpha = 0.2  # Distance\n    beta = 0.15  # Depot Proximity\n    gamma = 0.1   # Savings\n    delta = 0.15  # Clustering\n    eta = 0.2  # Centrality\n    mu = 0.1   # Demand Density\n    zeta = 0.1 #route balance\n\n    # Adapt weights\n    alpha += 0.05 * capacity_ratio + 0.02 * num_nodes_factor\n    beta -= 0.03 * capacity_ratio - 0.01 * num_nodes_factor\n    gamma += 0.02 * capacity_ratio + 0.03 * num_nodes_factor\n    delta += 0.01 * capacity_ratio + 0.02 * num_nodes_factor\n    eta -= 0.01 * capacity_ratio - 0.02 * num_nodes_factor\n    mu += 0.03 * capacity_ratio + 0.01 * num_nodes_factor\n    zeta +=  0.02 * capacity_ratio - 0.01 * num_nodes_factor\n\n    # Combine the heuristics with adaptive weights.\n    heuristics = (alpha * distance_heuristic * demand_heuristic +\n                  beta * depot_heuristic +\n                  gamma * savings_heuristic +\n                  delta * clustering_heuristic +\n                  eta * centrality_heuristic +\n                  mu * demand_density_heuristic +\n                  zeta * route_balance_heuristic)\n\n\n    # 5. Sparsification (Adaptive Threshold)\n    k_nearest = min(12, n -1)\n    threshold = np.percentile(heuristics[heuristics > 0], 40) # Adaptive Percentile\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1.  Distance: Edges with shorter distances are preferred.\n    2.  Demand Feasibility: Penalizes edges that would immediately violate capacity constraints.\n    3.  Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4.  Savings Heuristic Integration: Incorporates the savings heuristic to encourage merging routes.\n    5.  Sparsification: Sets unpromising edges to zero to focus the search.\n    6.  Clustering Coefficient: Encourages connections between nodes within local clusters. Uses adaptive k-nearest neighbor count.\n    7.  Adaptive Weighting: Adjusts weights based on problem characteristics (e.g., tightness of capacity, number of nodes).\n    8.  Node Centrality: Prioritizes connections from more \"central\" nodes to distribute routes evenly.\n    9.  Demand Density: Encourages links between nodes with similar demand profiles within spatial proximity\n    10. Route balancing: Add heuristics to encourage routes of a similar length\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component (Normalized)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = distance_heuristic / np.max(distance_heuristic)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n    demand_heuristic = demand_heuristic / np.max(demand_heuristic)\n\n    # 3. Depot Proximity (Normalized)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = depot_heuristic / np.max(depot_heuristic)\n\n    # 4. Savings Heuristic (Normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = savings_heuristic / np.max(savings_heuristic)\n\n    # 6. Clustering Coefficient approximation (Local Density) - Adaptive k\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = min(10, n - 1)  # Adaptive k: Limit to n-1\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = common_neighbors / k_nearest\n    clustering_heuristic = clustering_heuristic / np.max(clustering_heuristic)\n\n\n    # 8. Node Centrality (Closeness Centrality Approximation) (Normalized)\n    centrality = np.zeros(n)\n    for i in range(1, n):\n        centrality[i] = np.sum(distance_matrix[i, 1:])\n    centrality = np.max(centrality) / (centrality + epsilon)  # Higher is more central\n    centrality[0] = 1 #depot as most central\n    centrality_heuristic = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            centrality_heuristic[i, j] = (centrality[i] + centrality[j]) / 2.0\n    centrality_heuristic = centrality_heuristic / np.max(centrality_heuristic)\n\n    # 9. Demand Density (Normalized)\n    demand_density_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            demand_diff = abs(demands[i] - demands[j]) / capacity\n            distance_normalized = distance_matrix[i, j] / np.max(distance_matrix)\n            demand_density_heuristic[i, j] = 1- (demand_diff + distance_normalized) / 2\n    demand_density_heuristic = demand_density_heuristic / np.max(demand_density_heuristic)\n\n    #10. Route Balance (penalize connections that contribute to large imbalances)\n    route_balance_heuristic = np.ones((n,n))\n    avg_route_length = np.sum(distance_matrix) / (n * n)\n\n    for i in range(1,n):\n        for j in range(1,n):\n            if i == j:\n                route_balance_heuristic[i,j] = 0\n            edge_length_deviation = abs(distance_matrix[i,j] - avg_route_length)\n            route_balance_heuristic[i,j] = max(0, 1 - (edge_length_deviation / avg_route_length))\n\n    route_balance_heuristic = route_balance_heuristic / np.max(route_balance_heuristic)\n\n\n\n    # 7. Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n    num_nodes_factor = n / 100.0  # Scale based on the number of nodes\n\n    alpha = 0.2  # Distance\n    beta = 0.15  # Depot Proximity\n    gamma = 0.1   # Savings\n    delta = 0.15  # Clustering\n    eta = 0.2  # Centrality\n    mu = 0.1   # Demand Density\n    zeta = 0.1 #route balance\n\n    # Adapt weights\n    alpha += 0.05 * capacity_ratio + 0.02 * num_nodes_factor\n    beta -= 0.03 * capacity_ratio - 0.01 * num_nodes_factor\n    gamma += 0.02 * capacity_ratio + 0.03 * num_nodes_factor\n    delta += 0.01 * capacity_ratio + 0.02 * num_nodes_factor\n    eta -= 0.01 * capacity_ratio - 0.02 * num_nodes_factor\n    mu += 0.03 * capacity_ratio + 0.01 * num_nodes_factor\n    zeta +=  0.02 * capacity_ratio - 0.01 * num_nodes_factor\n\n    # Combine the heuristics with adaptive weights.\n    heuristics = (alpha * distance_heuristic * demand_heuristic +\n                  beta * depot_heuristic +\n                  gamma * savings_heuristic +\n                  delta * clustering_heuristic +\n                  eta * centrality_heuristic +\n                  mu * demand_density_heuristic +\n                  zeta * route_balance_heuristic)\n\n\n    # 5. Sparsification (Adaptive Threshold)\n    k_nearest = min(12, n -1)\n    threshold = np.percentile(heuristics[heuristics > 0], 40) # Adaptive Percentile\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, savings and depot proximity with adaptive weights and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance heuristic\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # Demand feasibility heuristic\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # Savings heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # Depot proximity heuristic\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / (np.max(distance_matrix) + epsilon)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # Adaptive weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))\n    alpha = 0.4\n    beta = 0.2\n    gamma = 0.3\n    delta = 0.1\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * savings_heuristic * demand_heuristic + delta * savings_heuristic\n\n    # Sparsification\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 40)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, savings and depot proximity with adaptive weights and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance heuristic\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # Demand feasibility heuristic\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # Savings heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # Depot proximity heuristic\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / (np.max(distance_matrix) + epsilon)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # Adaptive weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))\n    alpha = 0.4\n    beta = 0.2\n    gamma = 0.3\n    delta = 0.1\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * savings_heuristic * demand_heuristic + delta * savings_heuristic\n\n    # Sparsification\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 40)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, savings and depot proximity with adaptive weights and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance heuristic\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # Demand feasibility heuristic\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # Savings heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # Depot proximity heuristic\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / (np.max(distance_matrix) + epsilon)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # Adaptive weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))\n    alpha = 0.4\n    beta = 0.2\n    gamma = 0.3\n    delta = 0.1\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * savings_heuristic * demand_heuristic + delta * savings_heuristic\n\n    # Sparsification\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 40)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 19th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Heuristic: Combines distance, demand, angle, depot proximity with adaptive weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Calculate tightness of capacity constraint\n    capacity_ratio = np.sum(demands) / (capacity * (n - 1)) #excluding depot\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            dist_h = 1 / (distance_matrix[i, j] + epsilon)\n            demand_h = 1 - np.clip((demands[i] + demands[j]) / (2 * capacity + epsilon), 0, 1)\n            if i == 0 or j == 0:\n                demand_h = 1.0\n\n            angle_h = 1.0\n            if i != 0 and j != 0:\n                angle_h = 0.0\n\n                # Calculate angle to depot\n                depot_x, depot_y = coordinates[0]\n                i_x, i_y = coordinates[i]\n                j_x, j_y = coordinates[j]\n\n                vector_ij = np.array([j_x - i_x, j_y - i_y])\n                vector_di = np.array([i_x - depot_x, i_y - depot_y])\n\n                vector_ij = vector_ij / (np.linalg.norm(vector_ij) + epsilon)\n                vector_di = vector_di / (np.linalg.norm(vector_di) + epsilon)\n\n                dot_product = np.clip(np.dot(vector_ij, vector_di), -1.0, 1.0)\n                angle = np.arccos(dot_product)\n                angle_h = 1 - (angle / np.pi)\n\n\n            depot_prox_h = 1 - np.clip((distance_matrix[0, i] + distance_matrix[0, j]) / (2 * np.max(distance_matrix) + epsilon), 0, 1)\n\n            # Adaptive weights based on capacity tightness\n            weight_dist = 0.5\n            weight_demand = 0.15 + 0.2 * capacity_ratio  # Increase weight if capacity is tight\n            weight_angle = 0.25 - 0.1 * capacity_ratio   # Decrease weight if capacity is tight\n            weight_depot = 0.1\n\n            heuristic_matrix[i, j] = (\n                weight_dist * dist_h +\n                weight_demand * demand_h +\n                weight_angle * angle_h +\n                weight_depot * depot_prox_h\n            )\n\n    # Normalize heuristic values\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix /= max_heuristic\n    else:\n        heuristic_matrix = np.ones_like(heuristic_matrix) / n\n\n\n    # Sparsify the matrix based on mean heuristic value\n    threshold = np.mean(heuristic_matrix) * 0.5\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Heuristics 20th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1. Distance: Edges with shorter distances are preferred.\n    2. Demand Feasibility: Penalizes edges that would immediately violate capacity constraints if used early in a route.\n    3. Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4. Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will \"attract\" closer nodes to form clusters.\n    5. Savings Heuristic Integration: Incorporates the savings heuristic to encourage merging routes.\n    6. Sparsification: Sets unpromising edges to zero to focus the search.\n    7. Clustering Coefficient: Encourages connections between nodes within local clusters\n    8. Adaptive Weighting: Adjusts weights based on problem characteristics (e.g., tightness of capacity)\n    9. Angle Cost: Edges forming sharp turns are penalized.\n    10. Route balance: A factor promoting more equally sized routes.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon) # Normalize\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n    demand_heuristic = (demand_heuristic - np.min(demand_heuristic)) / (np.max(demand_heuristic) - np.min(demand_heuristic) + epsilon) # Normalize\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon) # Normalize\n\n    # 4. Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0\n    for i in range(1, n):\n        for j in range(1, n):\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n    gravitational_heuristic = (gravitational_heuristic - np.min(gravitational_heuristic)) / (np.max(gravitational_heuristic) - np.min(gravitational_heuristic) + epsilon) # Normalize\n\n    # 5. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon) # Normalize\n\n    # 7. Clustering Coefficient approximation (Local Density)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = 6  # Consider only k-nearest neighbors for clustering\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1  # k-nearest neighbors excluding depot, adjusting index\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = common_neighbors / k_nearest\n    clustering_heuristic = (clustering_heuristic - np.min(clustering_heuristic)) / (np.max(clustering_heuristic) - np.min(clustering_heuristic) + epsilon) # Normalize\n\n    # 9. Angle Cost\n    angle_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Vectors from depot to i and depot to j\n                vector_i = coordinates[i] - coordinates[0]\n                vector_j = coordinates[j] - coordinates[0]\n\n                # Calculate the cosine of the angle between the vectors\n                dot_product = np.dot(vector_i, vector_j)\n                magnitude_i = np.linalg.norm(vector_i)\n                magnitude_j = np.linalg.norm(vector_j)\n                cos_angle = dot_product / (magnitude_i * magnitude_j + epsilon)\n\n                # Convert cosine to angle in radians\n                angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))\n\n                # Penalize sharp turns (small angles)\n                angle_cost = angle / np.pi  # Normalize angle to [0, 1]\n                angle_heuristic[i, j] = angle_cost\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)  # Normalize\n\n\n    # 10. Route balance\n    route_balance_heuristic = np.zeros((n, n))\n    total_demand = np.sum(demands[1:])\n    ideal_route_demand = total_demand / 3 if total_demand / capacity > 3 else total_demand / (int(total_demand / capacity) +1) #Assuming 3 vehicles.\n    for i in range(1, n):\n        demand_diff_penalty = np.abs(demands[i] - ideal_route_demand) / total_demand\n        route_balance_heuristic[0, i] = 1 - demand_diff_penalty\n        route_balance_heuristic[i, 0] = 1 - demand_diff_penalty\n\n    route_balance_heuristic = (route_balance_heuristic - np.min(route_balance_heuristic)) / (np.max(route_balance_heuristic) - np.min(route_balance_heuristic) + epsilon)  # Normalize\n\n\n    # 8. Adaptive Weighting\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n    alpha = 0.25\n    beta = 0.10\n    gamma = 0.05\n    delta = 0.10\n    eta = 0.05\n    mu = 0.05\n    phi = 0.20\n    lamda = 0.2\n\n\n    # Adjust weights based on capacity ratio\n    alpha += 0.1 * capacity_ratio  # Increase importance of distance if capacity is tight\n    beta -= 0.05 * capacity_ratio  # Decrease importance of going to depot if capacity is tight (more local clusters)\n    phi -= 0.05 * capacity_ratio\n\n    # Combine the heuristics with adaptive weights. Weights could be tuned by a metaheuristic\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * gravitational_heuristic + delta * savings_heuristic + mu * clustering_heuristic + phi * angle_heuristic + lamda * route_balance_heuristic\n\n    # 6. Sparsification\n    # Only keep edges with a heuristic value above a certain threshold or that are among the k-nearest neighbors.\n    k_nearest = 10  # consider only k-nearest neighbors.\n    threshold = np.percentile(heuristics[heuristics > 0], 30)  # Dynamic threshold (e.g., 30th percentile)\n\n    for i in range(n):\n        # Find k-nearest neighbors\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] #excluding self loop and depot\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}