```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several factors to estimate edge desirability:
    1. Inverse Distance: Shorter distances are generally more desirable.
    2. Depot Proximity: Edges connected to the depot (node 0) are often crucial for route construction.
    3. Demand Consideration: Penalizes edges connecting high-demand nodes to avoid overloading vehicles early in a route.
    4. Closeness to Depot: If customer j is near to the depot than customer i then give higher priorities.
    5. Angle between nodes i and j. Prefer shorter angle for faster visiting.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Vector of customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    depot_x, depot_y = coordinates[0]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
                continue

            # 1. Inverse Distance
            distance_factor = 1 / (distance_matrix[i, j] + 1e-9)  # Add a small value to avoid division by zero.

            # 2. Depot Proximity
            depot_proximity_factor = 0.0
            if i == 0 or j == 0:
                depot_proximity_factor = 1.0

            # 3. Demand Consideration
            demand_penalty = 1.0
            demand_penalty = np.exp(-(demands[i] + demands[j]) / (2 * capacity) )  # Exponential decay for high demands

            # 4. Closeness to depot:
            distance_i_to_depot = np.sqrt((coordinates[i, 0] - depot_x)**2 + (coordinates[i, 1] - depot_y)**2)
            distance_j_to_depot = np.sqrt((coordinates[j, 0] - depot_x)**2 + (coordinates[j, 1] - depot_y)**2)

            closeness_factor = 0.0
            if distance_j_to_depot < distance_i_to_depot:
                closeness_factor = 0.5 # Adding a weight.

            # 5. Angle

            dx1 = coordinates[i, 0] - depot_x
            dy1 = coordinates[i, 1] - depot_y
            dx2 = coordinates[j, 0] - depot_x
            dy2 = coordinates[j, 1] - depot_y
            angle1 = np.arctan2(dy1, dx1)
            angle2 = np.arctan2(dy2, dx2)
            angle_diff = np.abs(angle1 - angle2)
            angle_factor = 1/(angle_diff + 1e-9)
            heuristics[i, j] = distance_factor * (1 + depot_proximity_factor) * demand_penalty + closeness_factor + angle_factor
            # Combination of factors
            #heuristics[i, j] = distance_factor + depot_proximity_factor - demand_factor
    return heuristics
```
