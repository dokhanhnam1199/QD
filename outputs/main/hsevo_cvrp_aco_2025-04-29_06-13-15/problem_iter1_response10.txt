```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates distance, demand, and depot proximity considerations.

    Args:
        distance_matrix: Distance matrix between nodes.
        coordinates: Euclidean coordinates of nodes.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        A matrix of heuristic scores for each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Heuristic 1: Inverse distance
    heuristic_matrix = 1 / (distance_matrix + 1e-6)  # Add small value to avoid division by zero

    # Heuristic 2: Demand factor - discourage connecting to nodes that quickly fill a vehicle
    demand_factor = np.outer(demands, demands)
    heuristic_matrix = heuristic_matrix / (demand_factor + 1e-6)

    # Heuristic 3: Depot proximity - encourage edges connecting nodes near the depot (node 0) to depot
    depot_distances = distance_matrix[0, :]
    depot_proximity_factor = np.outer(depot_distances, depot_distances)
    heuristic_matrix = heuristic_matrix / (depot_proximity_factor + 1e-6)


    # Heuristic 4: Capacity remaining at each node if going to a particular node from depot.
    initial_remaining_capacity = capacity
    remaining_capacity_at_node = np.zeros(n)
    for i in range(1, n):  # exclude the depot at index 0
        remaining_capacity_at_node[i] = initial_remaining_capacity - demands[i]
        if remaining_capacity_at_node[i] < 0:
            remaining_capacity_at_node[i] = 0

    remaining_capacity_factor = np.outer(remaining_capacity_at_node, remaining_capacity_at_node)
    heuristic_matrix = heuristic_matrix * (remaining_capacity_factor + 1e-6)

    # Heuristic 5: Encourage nodes with relatively higher demand to be visited earlier
    demand_incentive = demands / np.sum(demands)
    demand_incentive_matrix = np.outer(demand_incentive, demand_incentive)
    heuristic_matrix = heuristic_matrix * (demand_incentive_matrix + 1e-6)

    # Normalize the heuristic matrix
    heuristic_matrix = heuristic_matrix / np.max(heuristic_matrix)

    return heuristic_matrix
```
