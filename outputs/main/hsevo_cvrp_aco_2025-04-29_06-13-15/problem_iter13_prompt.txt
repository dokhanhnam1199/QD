{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version focuses on a refined combination of factors, dynamic parameter adaptation,\n    and more aggressive sparsification.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance Component (Enhanced)\n    #   - Inverse square distance emphasizes shorter edges more strongly.\n    distance_heuristic = 1 / (distance_matrix**2 + epsilon)\n\n    # 2. Demand Feasibility (Refined)\n    #   - Stricter penalty for immediate capacity violations.\n    #   - Considers the remaining capacity of the current route (simulated).\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.01  # Stronger penalty for depot-initiated violation\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.01  # Stronger penalty for depot-initiated violation\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.005\n\n            # Simulate a simple route: depot -> i -> j\n            remaining_capacity = capacity - demands[i] if i != 0 else capacity\n            if i != 0 and j!= 0 and remaining_capacity < demands[j]:\n                 demand_heuristic[i,j] = 0.001 #Very strong penalty\n\n\n    # 3. Depot Proximity (Contextualized)\n    #   - Only apply depot preference to nodes that are \"isolated\" (far from most others).\n    #   - Adjust preference strength based on demand.\n    depot_heuristic = np.zeros((n, n))\n    isolation_threshold = np.mean(distance_matrix)  # Node is \"isolated\" if its avg dist is above this\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        if avg_distance > isolation_threshold:\n            depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)**0.5 # sqrt makes demands less impact\n            depot_heuristic[i, 0] = depot_preference\n            depot_heuristic[0, i] = depot_preference\n\n\n    # 4. Savings Heuristic (Aggressive)\n    #   - Prioritize high-saving merges very aggressively.\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings**2  # Emphasize high savings\n            savings_heuristic[j, i] = savings**2\n\n    # 5. Node Similarity (Demand-Distance Tradeoff)\n    # Encourage edges between nodes with similar demand/distance profiles\n    similarity_heuristic = np.zeros((n, n))\n    demand_normalized = demands / np.max(demands)\n    distance_to_depot_normalized = distance_matrix[:, 0] / np.max(distance_matrix[:, 0])\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            demand_diff = abs(demand_normalized[i] - demand_normalized[j])\n            distance_diff = abs(distance_to_depot_normalized[i] - distance_to_depot_normalized[j])\n            similarity_heuristic[i, j] = 1 - (demand_diff + distance_diff) / 2 #High score when demand diff and distance_to_depot_diff are small\n            similarity_heuristic[j, i] = similarity_heuristic[i, j]\n\n    # 6. Adaptive Weighting (Mechanism-Driven)\n    #   - Dynamically adjust weights based on network connectivity.\n    #   - High connectivity -> emphasize savings. Low connectivity -> emphasize distance.\n    connectivity = np.sum(distance_matrix < np.mean(distance_matrix)) / (n * n)  # Ratio of \"close\" edges\n    alpha = 0.4 * (1 - connectivity)  # Distance importance (inversely proportional to connectivity)\n    beta = 0.1 * (1-connectivity) # Depot proximity\n    gamma = 0.4 * connectivity  # Savings importance (proportional to connectivity)\n    eta = 0.1 * connectivity #Similarity heuristic\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * savings_heuristic + eta * similarity_heuristic\n\n    # 7. Sparsification (Aggressive and Dynamic)\n    #   - Remove edges below a percentile threshold AND those that violate \"triangle inequality\".\n    #   - Only keep k-nearest neighbors.\n    k_nearest = 8\n    threshold = np.percentile(heuristics[heuristics > 0], 50)  # Aggressive sparsification\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n            #Triangle inequality check\n            for k in range(n):\n              if distance_matrix[i,j] > distance_matrix[i,k] + distance_matrix[k,j]:\n                heuristics[i,j] = 0\n                break\n\n\n\n    # Normalize\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}