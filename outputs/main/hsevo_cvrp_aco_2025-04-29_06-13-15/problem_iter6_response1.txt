```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates:
    1.  Distance and Demand Ratio: Edges with shorter distances and better demand fit are preferred.
    2.  Capacity Utilization: Encourages routes to utilize vehicle capacity effectively.
    3.  Node Centrality: Favors connecting to more central nodes to promote balanced routes.
    4.  Clustering Tendency: Identifies and encourages connections within potential clusters of nodes.
    5.  Adaptive Sparsification: Dynamically adjusts sparsification based on problem characteristics.
    6.  Combined Score: Combines individual heuristic scores with adaptive weights.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).
        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))
    epsilon = 1e-6

    # 1. Distance and Demand Ratio
    distance_demand_ratio = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i == j:
                distance_demand_ratio[i, j] = 0
            else:
                distance_demand_ratio[i, j] = (1 / (distance_matrix[i, j] + epsilon)) * (1 - abs(demands[i] + demands[j] - capacity) / (capacity + epsilon))

    # 2. Capacity Utilization
    capacity_utilization = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                capacity_utilization[i, j] = max(0, 1 - abs(demands[i] + demands[j] - capacity) / (capacity + epsilon))
            else:
                capacity_utilization[i,j] = 0

    # 3. Node Centrality
    node_centrality = np.zeros((n, n))
    degree_centrality = np.sum(1 / (distance_matrix + epsilon), axis=1)
    for i in range(n):
        for j in range(n):
            if i != j:
                node_centrality[i, j] = (degree_centrality[i] + degree_centrality[j]) / (2 * np.sum(degree_centrality))
            else:
                 node_centrality[i,j] = 0


    # 4. Clustering Tendency (Simple implementation based on distance)
    clustering_tendency = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            # Calculate average distance to other nodes
            avg_dist_i = np.mean(distance_matrix[i, 1:])
            avg_dist_j = np.mean(distance_matrix[j, 1:])

            # Encourage connections if both nodes are relatively close to other nodes
            clustering_tendency[i, j] = clustering_tendency[j, i] = max(0, 1 - (distance_matrix[i, j] / (avg_dist_i + avg_dist_j + epsilon)))


    # Adaptive Weighting (Example - could be further tuned)
    alpha = 0.4  # Distance and Demand Ratio
    beta = 0.3  # Capacity Utilization
    gamma = 0.15 # Node Centrality
    delta = 0.15 # Clustering Tendency

    heuristics = alpha * distance_demand_ratio + beta * capacity_utilization + gamma * node_centrality + delta * clustering_tendency

    # 5. Adaptive Sparsification
    density = np.sum(heuristics > 0) / (n * (n - 1)) # Calculate the matrix density
    k_nearest = max(2, min(10, int(n * 0.1)))  # Adjust k based on problem size

    threshold = np.percentile(heuristics[heuristics > 0], max(1, 40 - int(density * 40))) # threshold is dynamically adjusted based on the density
    for i in range(n):
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]

        for j in range(n):
            if heuristics[i, j] < threshold and j not in nearest_neighbors:
                heuristics[i, j] = 0


    # Normalize
    max_val = np.max(heuristics)
    if max_val > 0:
        heuristics = heuristics / max_val

    return heuristics
```
