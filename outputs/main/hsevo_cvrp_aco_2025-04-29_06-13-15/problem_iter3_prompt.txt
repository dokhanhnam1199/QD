{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\nCurrent heuristics:\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1.  Distance: Edges with shorter distances are preferred.\n    2.  Demand Feasibility:  Penalizes edges that would immediately violate capacity constraints if used early in a route.\n    3.  Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4.  Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will \"attract\" closer nodes to form clusters.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # Add a small value to avoid division by zero\n    epsilon = 1e-6\n\n    # 1. Distance component (inverse relationship)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # 2. Demand Feasibility component\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0  # No self-loops\n\n            # If using this edge would exceed vehicle capacity (assuming starting from depot), penalize\n            if demands[i] + demands[j] > capacity and i == 0: # starting node\n                demand_heuristic[i, j] = 0.1  # A small value but not zero so it is not totally ignored\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                 demand_heuristic[i,j] = 0.05\n\n\n    # 3. Depot Proximity (encourage returning to depot if far and demand is high)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):  # Exclude depot itself\n        # Calculate average distance from node i to all other nodes (excluding the depot)\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0] # If only one other point exist use the distance to depot.\n\n        # Encourage going back to the depot from this node IF it is far and demands are relatively high.\n        # Depot preference is weighted based on avg_distance and demand compared to capacity\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference #symmetry\n\n    # 4. Gravitational Attraction: Node `i` attracts closeby node `j`\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0  # Adjust to control attraction strength.\n    for i in range(1, n):  # Start from 1 to exclude the depot itself as a gravity center. Depot is served by the previous depot_heuristic.\n        for j in range(1, n): # Start from 1 to exclude the depot itself being attracted by the gravitational heuristic.\n\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon) # F = G*m1*m2/r^2\n\n    # Combine the heuristics\n    heuristics = distance_heuristic * demand_heuristic + depot_heuristic + gravitational_heuristic\n\n\n    # Normalize to be between 0 and 1, can help stability of stochastic sampling methods\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\nNow, think outside the box write a mutated function `heuristics_v2` better than current version.\nYou can use some hints below:\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, let's redefine effective self-reflection for heuristic design.\n\n*   **Keywords:** Multi-faceted Evaluation, Adaptive Tuning, Contextual Awareness, Performance Analysis.\n*   **Advice:** Actively analyze *why* a heuristic succeeds/fails in specific instances. Consider environmental factors (e.g., problem structure, data distribution). Prioritize adaptive weight tuning during execution.\n*   **Avoid:** Focusing solely on overall averages. Ignoring the influence of problem-specific characteristics. Fixed or arbitrary parameter settings.\n*   **Explanation:** Shift from broad considerations to a deep understanding of performance drivers. This enables targeted improvements and robust heuristic design.\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}