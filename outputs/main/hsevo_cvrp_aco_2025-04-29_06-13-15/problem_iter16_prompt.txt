{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines distance, demand, savings, and angle heuristics with adaptive weighting and sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0):\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # Angle-based Clustering\n    angle_heuristic = np.zeros((n, n))\n    depot_x, depot_y = coordinates[0]\n    for i in range(1, n):\n        angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)\n        for j in range(i + 1, n):\n            angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)\n            angle_diff = min(abs(angle_i - angle_j), 2 * np.pi - abs(angle_i - angle_j))\n            angle_preference = np.exp(-angle_diff)\n            angle_heuristic[i, j] = angle_preference\n            angle_heuristic[j, i] = angle_preference\n\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)\n\n\n    # Adaptive Weighting - adjusted based on capacity ratio.\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n-1))\n    alpha = 0.3 + 0.2 * capacity_ratio # Distance weight\n    beta = 0.0 # depot proximity is removed here\n    gamma = 0.3 + 0.1 * capacity_ratio # Savings weight\n    delta = 0.2 - 0.1 * capacity_ratio # angle heuristic\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + gamma * savings_heuristic * demand_heuristic + delta * angle_heuristic * demand_heuristic\n\n    # Adaptive Sparsification based on percentile and k-NN\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 40) # Adaptive threshold based on percentile\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}