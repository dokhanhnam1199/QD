```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Implements a heuristic for the CVRP based on a combination of distance, demand,
    and angle considerations.  This function attempts to create more informed prior
    probabilities for edges in the solution.

    Args:
        distance_matrix: A numpy array representing the distances between nodes.
        coordinates: A numpy array representing the (x, y) coordinates of the nodes.
        demands: A numpy array representing the demand of each node.
        capacity: The capacity of each vehicle.

    Returns:
        A numpy array representing the heuristic values for each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Constants to tune the heuristic
    distance_weight = 1.0
    demand_weight = 0.5  # Penalize high-demand edges
    angle_weight = 0.3  # Encourages smoother routes
    capacity_penalty = 2.0 #Additional penalty of going to high demand customer

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            distance_term = distance_weight / distance_matrix[i, j] if distance_matrix[i,j] > 0 else 0 # Favor shorter distances
            demand_term = (1 - demand_weight * demands[j] / capacity)  # Penalize edges leading to high-demand nodes

            # Calculate angle between edges (i->j) and (j-> depot) as proxy for smooth route.
            # Lower values indicate direct route to depot
            if i == 0: #depot to customer
              angle_term = 0 #don't take into consideration
            else:
              vector_ij = coordinates[j] - coordinates[i]
              vector_j0 = coordinates[0] - coordinates[j]
              norm_ij = np.linalg.norm(vector_ij)
              norm_j0 = np.linalg.norm(vector_j0)
              if norm_ij > 0 and norm_j0 > 0:
                dot_product = np.dot(vector_ij, vector_j0)
                cosine_angle = dot_product / (norm_ij * norm_j0)
                angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))
                angle_term = (1 - angle_weight * angle / np.pi)
              else:
                angle_term = 0

            #Additional penalty for high demand customers.
            if demands[j] > (capacity/2):
               demand_term = demand_term / capacity_penalty
            
            heuristic_matrix[i, j] = distance_term * demand_term * angle_term #Combine factors


    return heuristic_matrix
```
