```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling principles.

    This version incorporates distance, demand, and spatial distribution to guide the search towards promising edges.

    Args:
        distance_matrix: n x n distance matrix between nodes.
        coordinates: n x 2 array of node coordinates (Euclidean).
        demands: n-dimensional array of customer demands.
        capacity: Vehicle capacity.

    Returns:
        n x n matrix of heuristic values, indicating the promise of including each edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (feel free to experiment with these)
    distance_weight = 1.0
    demand_weight = 1.0
    spatial_weight = 0.5  # weight assigned to influence of neighboring demand
    depot_proximity_weight = 0.5  # reward proximity to depot

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # 1. Distance component: Inverse of distance (shorter is better)
            distance_heuristic = distance_weight / (distance_matrix[i, j] + 1e-9) # avoid division by zero

            # 2. Demand component: Penalize edges connecting nodes with high combined demand relative to capacity.
            #    We are using harmonic mean because high demands from either customer should deter the connection
            demand_i = demands[i]
            demand_j = demands[j]
            combined_demand = (2 * demand_i * demand_j) / (demand_i + demand_j + 1e-9)

            demand_heuristic = (1- min(1.0, combined_demand / capacity)) * demand_weight

            # 3. Spatial Distribution component: Consider nearby nodes with high demand
            spatial_heuristic = 0.0
            neighbor_radius = np.mean(distance_matrix) / 2  # Dynamically adjusted radius
            neighbor_count = 0
            for k in range(n):
                if k != i and k != j and distance_matrix[i, k] < neighbor_radius: # find neighbor
                    spatial_heuristic += demands[k]
                    neighbor_count += 1
                if k != i and k != j and distance_matrix[j, k] < neighbor_radius:
                    spatial_heuristic += demands[k]
                    neighbor_count += 1
            if neighbor_count > 0:
                 spatial_heuristic = (1 - min(1, spatial_heuristic / (neighbor_count * capacity + 1e-9))) * spatial_weight
            else:
                spatial_heuristic = spatial_weight

            #4. Proximity to Depot
            depot_proximity = 1 - 0.9 * max(distance_matrix[0,i], distance_matrix[0,j]) / np.mean(distance_matrix)
            depot_heuristic = depot_proximity * depot_proximity_weight

            # Combine components - adjust weights to fine-tune the heuristic
            heuristic_matrix[i, j] = distance_heuristic + demand_heuristic + spatial_heuristic + depot_heuristic

    return heuristic_matrix
```
