```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version incorporates distance, demand, angle, and depot proximity considerations.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # Avoid division by zero by adding a small epsilon
    epsilon = 1e-6

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
                continue

            # Base heuristic: inverse distance (more attractive for shorter distances)
            distance_heuristic = 1 / (distance_matrix[i, j] + epsilon)

            # Demand heuristic: penalize edges connecting high-demand nodes directly if capacity is limited.
            # Encourage returning to the depot (node 0) if the demand is high.
            demand_penalty = (demands[i] + demands[j]) / (2 * capacity + epsilon)
            demand_heuristic = 1 - np.clip(demand_penalty, 0, 1)  # Clip to ensure it's not negative
            if i == 0 or j == 0:  # Favor returns to the depot when close to full capacity.
                demand_heuristic = 1.0

            # Angle heuristic: Encourage smoother turns by penalizing sharp angles.
            # Approximated using the cosine rule. If the angle is small, the penalty will be small
            # leading to higher overall heuristic. The smaller the angle, the closer cosine to 1.
            angle_heuristic = 1.0  # Assume perfect smoothing if insufficient nodes to form angle

            if i != 0 and j != 0:
                angle_heuristic = 0.0
                # Find nearest node that is not equal to node i and j.
                nn_idx = -1; dist = np.inf
                for k in range(n):
                  if k != i and k!= j:
                    if distance_matrix[i, k] < dist:
                      dist = distance_matrix[i,k]
                      nn_idx = k

                if nn_idx != -1:
                    a = distance_matrix[i, j]
                    b = distance_matrix[i, nn_idx]
                    c = distance_matrix[j, nn_idx]
                    # Catch exception arising from floating errors.
                    try:
                      angle_heuristic = (a**2 + b**2 - c**2) / (2 * a * b + epsilon)
                      angle_heuristic = np.clip(angle_heuristic, -1.0, 1.0)  # Clip cosine value within valid range
                      angle_heuristic = (angle_heuristic + 1.0) / 2.0 # maps the angle to be between 0 and 1
                    except Exception as e:
                        angle_heuristic = 0.5 # sets angle heuristic to indifference
            # Depot proximity: if both i and j are far from the depot (node 0), penalize the edge.
            depot_proximity_penalty = (distance_matrix[0, i] + distance_matrix[0, j]) / (2 * np.max(distance_matrix) + epsilon) # normalized.
            depot_proximity_heuristic = 1 - np.clip(depot_proximity_penalty, 0, 1)  # If very far, value -> 0. Otherwise, value closer to 1.

            # Combine heuristics with weights (can be tuned)
            heuristics[i, j] = (
                0.5 * distance_heuristic +
                0.15 * demand_heuristic +
                0.25 * angle_heuristic +
                0.1 * depot_proximity_heuristic
            )

    return heuristics
```
