```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP using a combination of distance, demand, and angular considerations.

    Args:
        distance_matrix: Distance matrix (n x n).
        coordinates: Node coordinates (n x 2).
        demands: Node demands (n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of heuristic values (n x n). Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Depot location (assuming it's the first node).
    depot_x, depot_y = coordinates[0]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops

            else:
                # Combination of factors:

                # 1. Distance factor (inverse distance)
                distance_factor = 1 / distance_matrix[i, j]

                # 2. Demand factor: Prioritize edges connecting nodes with combined demand
                # that is not excessive relative to vehicle capacity.
                demand_factor = 1.0 / (1 + min(demands[i] + demands[j], capacity))

                # 3. Angular factor:  Nodes closer to the 'angle' from depot are preferred.
                # It encourages routing away from the depot in a broad sweep.

                # Calculate angles from the depot to each node. Avoid division by zero.
                angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)
                angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)
                angular_difference = abs(angle_i - angle_j)
                # Penalize large angular differences.
                angular_factor = 1.0 / (1 + angular_difference)

                # Incorporate depot proximity. It is desirable to return to depot at certain point.
                depot_distance_factor_i = 1.0 / (1 + distance_matrix[0, i])
                depot_distance_factor_j = 1.0 / (1 + distance_matrix[0, j])
                depot_proximity_factor = depot_distance_factor_i + depot_distance_factor_j

                # Combine all factors with weights. Tune weights to fit the problem at hand.
                heuristic_matrix[i, j] = (
                    0.5 * distance_factor +
                    0.15 * demand_factor +
                    0.15 * angular_factor +
                    0.2 * depot_proximity_factor
                )


    return heuristic_matrix
```
