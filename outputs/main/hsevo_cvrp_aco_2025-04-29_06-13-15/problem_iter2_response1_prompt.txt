{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\n### Better code\ndef heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates several factors to estimate edge desirability:\n    1. Inverse Distance: Shorter distances are generally more desirable.\n    2. Depot Proximity: Edges connected to the depot (node 0) are often crucial for route construction.\n    3. Demand Consideration: Penalizes edges connecting high-demand nodes to avoid overloading vehicles early in a route.\n    4. Closeness to Depot: If customer j is near to the depot than customer i then give higher priorities.\n    5. Angle between nodes i and j. Prefer shorter angle for faster visiting.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Vector of customer demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    depot_x, depot_y = coordinates[0]\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0  # No self-loops\n                continue\n\n            # 1. Inverse Distance\n            distance_factor = 1 / (distance_matrix[i, j] + 1e-9)  # Add a small value to avoid division by zero.\n\n            # 2. Depot Proximity\n            depot_proximity_factor = 0.0\n            if i == 0 or j == 0:\n                depot_proximity_factor = 1.0\n\n            # 3. Demand Consideration\n            demand_penalty = 1.0\n            demand_penalty = np.exp(-(demands[i] + demands[j]) / (2 * capacity) )  # Exponential decay for high demands\n\n            # 4. Closeness to depot:\n            distance_i_to_depot = np.sqrt((coordinates[i, 0] - depot_x)**2 + (coordinates[i, 1] - depot_y)**2)\n            distance_j_to_depot = np.sqrt((coordinates[j, 0] - depot_x)**2 + (coordinates[j, 1] - depot_y)**2)\n\n            closeness_factor = 0.0\n            if distance_j_to_depot < distance_i_to_depot:\n                closeness_factor = 0.5 # Adding a weight.\n\n            # 5. Angle\n\n            dx1 = coordinates[i, 0] - depot_x\n            dy1 = coordinates[i, 1] - depot_y\n            dx2 = coordinates[j, 0] - depot_x\n            dy2 = coordinates[j, 1] - depot_y\n            angle1 = np.arctan2(dy1, dx1)\n            angle2 = np.arctan2(dy2, dx2)\n            angle_diff = np.abs(angle1 - angle2)\n            angle_factor = 1/(angle_diff + 1e-9)\n            heuristics[i, j] = distance_factor * (1 + depot_proximity_factor) * demand_penalty + closeness_factor + angle_factor\n            # Combination of factors\n            #heuristics[i, j] = distance_factor + depot_proximity_factor - demand_factor\n    return heuristics\n\n### Worse code\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristics for CVRP using a combination of distance, demand, and angular considerations.\n\n    Args:\n        distance_matrix: Distance matrix (n x n).\n        coordinates: Node coordinates (n x 2).\n        demands: Node demands (n).\n        capacity: Vehicle capacity.\n\n    Returns:\n        A matrix of heuristic values (n x n). Higher values indicate more promising edges.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Depot location (assuming it's the first node).\n    depot_x, depot_y = coordinates[0]\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n\n            else:\n                # Combination of factors:\n\n                # 1. Distance factor (inverse distance)\n                distance_factor = 1 / distance_matrix[i, j]\n\n                # 2. Demand factor: Prioritize edges connecting nodes with combined demand\n                # that is not excessive relative to vehicle capacity.\n                demand_factor = 1.0 / (1 + min(demands[i] + demands[j], capacity))\n\n                # 3. Angular factor:  Nodes closer to the 'angle' from depot are preferred.\n                # It encourages routing away from the depot in a broad sweep.\n\n                # Calculate angles from the depot to each node. Avoid division by zero.\n                angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)\n                angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)\n                angular_difference = abs(angle_i - angle_j)\n                # Penalize large angular differences.\n                angular_factor = 1.0 / (1 + angular_difference)\n\n                # Incorporate depot proximity. It is desirable to return to depot at certain point.\n                depot_distance_factor_i = 1.0 / (1 + distance_matrix[0, i])\n                depot_distance_factor_j = 1.0 / (1 + distance_matrix[0, j])\n                depot_proximity_factor = depot_distance_factor_i + depot_distance_factor_j\n\n                # Combine all factors with weights. Tune weights to fit the problem at hand.\n                heuristic_matrix[i, j] = (\n                    0.5 * distance_factor +\n                    0.15 * demand_factor +\n                    0.15 * angular_factor +\n                    0.2 * depot_proximity_factor\n                )\n\n\n    return heuristic_matrix\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic incorporates a gravitational attraction component, while the worst uses a simpler angle factor. Also, the best normalizes the combined heuristics to between 0 and 1, potentially improving stability. The worst uses fixed weights, potentially limiting adaptability.\n\nComparing (2nd best) vs (2nd worst), we see that \"Heuristics 2nd\" and \"Heuristics 19th\" exhibit noticeable distinctions. \"Heuristics 2nd\" employs gravitational attraction, demand feasibility, and depot proximity while \"Heuristics 19th\" focuses on angle relative to the depot.\n\nComparing (1st) vs (2nd), there are no difference so both are the same.\n\nComparing (3rd) vs (4th), we see that \"Heuristics 3rd\" calculates an angle between edges (i->j) and (j-> depot) as a proxy for a smooth route, also including additional penalty for high demand customers. \"Heuristics 4th\" measures the angle each node creates to the depot and combine angle and demand penalty.\n\nComparing (second worst) vs (worst), \"Heuristics 19th\" calculates angle between nodes relative to the depot, encouraging edges connecting nodes with similar angles. \"Heuristics 20th\" calculates angle between the vectors from node i to node j and from node 0 (depot) to node j, preferring edges that don't make sharp turns.\n\nOverall: The better heuristics incorporate more sophisticated factors like gravitational attraction and spatial distribution, while also normalizing the output. Simpler approaches relying solely on distance, demand, and basic angle calculations tend to perform worse. The weighting of different factors and handling of edge cases (e.g., division by zero) also seem to play a crucial role. Depot proximity is a frequently used concept that appears in many of the better heuristics.\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, let's redefine effective self-reflection for heuristic design.\n\n*   **Keywords:** Multi-faceted Evaluation, Adaptive Tuning, Contextual Awareness, Performance Analysis.\n*   **Advice:** Actively analyze *why* a heuristic succeeds/fails in specific instances. Consider environmental factors (e.g., problem structure, data distribution). Prioritize adaptive weight tuning during execution.\n*   **Avoid:** Focusing solely on overall averages. Ignoring the influence of problem-specific characteristics. Fixed or arbitrary parameter settings.\n*   **Explanation:** Shift from broad considerations to a deep understanding of performance drivers. This enables targeted improvements and robust heuristic design.\n\n\nYour task is to write an improved function `heuristics_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}