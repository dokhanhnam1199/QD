{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1.  Distance: Edges with shorter distances are preferred.\n    2.  Demand Feasibility:  Penalizes edges that would immediately violate capacity constraints if used early in a route.\n    3.  Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4.  Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will \"attract\" closer nodes to form clusters.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # Add a small value to avoid division by zero\n    epsilon = 1e-6\n\n    # 1. Distance component (inverse relationship)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # 2. Demand Feasibility component\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0  # No self-loops\n\n            # If using this edge would exceed vehicle capacity (assuming starting from depot), penalize\n            if demands[i] + demands[j] > capacity and i == 0: # starting node\n                demand_heuristic[i, j] = 0.1  # A small value but not zero so it is not totally ignored\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                 demand_heuristic[i,j] = 0.05\n\n\n    # 3. Depot Proximity (encourage returning to depot if far and demand is high)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):  # Exclude depot itself\n        # Calculate average distance from node i to all other nodes (excluding the depot)\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0] # If only one other point exist use the distance to depot.\n\n        # Encourage going back to the depot from this node IF it is far and demands are relatively high.\n        # Depot preference is weighted based on avg_distance and demand compared to capacity\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference #symmetry\n\n    # 4. Gravitational Attraction: Node `i` attracts closeby node `j`\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0  # Adjust to control attraction strength.\n    for i in range(1, n):  # Start from 1 to exclude the depot itself as a gravity center. Depot is served by the previous depot_heuristic.\n        for j in range(1, n): # Start from 1 to exclude the depot itself being attracted by the gravitational heuristic.\n\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon) # F = G*m1*m2/r^2\n\n    # Combine the heuristics\n    heuristics = distance_heuristic * demand_heuristic + depot_heuristic + gravitational_heuristic\n\n\n    # Normalize to be between 0 and 1, can help stability of stochastic sampling methods\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1.  Distance: Edges with shorter distances are preferred.\n    2.  Demand Feasibility:  Penalizes edges that would immediately violate capacity constraints if used early in a route.\n    3.  Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4.  Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will \"attract\" closer nodes to form clusters.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # Add a small value to avoid division by zero\n    epsilon = 1e-6\n\n    # 1. Distance component (inverse relationship)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # 2. Demand Feasibility component\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0  # No self-loops\n\n            # If using this edge would exceed vehicle capacity (assuming starting from depot), penalize\n            if demands[i] + demands[j] > capacity and i == 0: # starting node\n                demand_heuristic[i, j] = 0.1  # A small value but not zero so it is not totally ignored\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                 demand_heuristic[i,j] = 0.05\n\n\n    # 3. Depot Proximity (encourage returning to depot if far and demand is high)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):  # Exclude depot itself\n        # Calculate average distance from node i to all other nodes (excluding the depot)\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0] # If only one other point exist use the distance to depot.\n\n        # Encourage going back to the depot from this node IF it is far and demands are relatively high.\n        # Depot preference is weighted based on avg_distance and demand compared to capacity\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference #symmetry\n\n    # 4. Gravitational Attraction: Node `i` attracts closeby node `j`\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0  # Adjust to control attraction strength.\n    for i in range(1, n):  # Start from 1 to exclude the depot itself as a gravity center. Depot is served by the previous depot_heuristic.\n        for j in range(1, n): # Start from 1 to exclude the depot itself being attracted by the gravitational heuristic.\n\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon) # F = G*m1*m2/r^2\n\n    # Combine the heuristics\n    heuristics = distance_heuristic * demand_heuristic + depot_heuristic + gravitational_heuristic\n\n\n    # Normalize to be between 0 and 1, can help stability of stochastic sampling methods\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Implements a heuristic for the CVRP based on a combination of distance, demand,\n    and angle considerations.  This function attempts to create more informed prior\n    probabilities for edges in the solution.\n\n    Args:\n        distance_matrix: A numpy array representing the distances between nodes.\n        coordinates: A numpy array representing the (x, y) coordinates of the nodes.\n        demands: A numpy array representing the demand of each node.\n        capacity: The capacity of each vehicle.\n\n    Returns:\n        A numpy array representing the heuristic values for each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Constants to tune the heuristic\n    distance_weight = 1.0\n    demand_weight = 0.5  # Penalize high-demand edges\n    angle_weight = 0.3  # Encourages smoother routes\n    capacity_penalty = 2.0 #Additional penalty of going to high demand customer\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n\n            distance_term = distance_weight / distance_matrix[i, j] if distance_matrix[i,j] > 0 else 0 # Favor shorter distances\n            demand_term = (1 - demand_weight * demands[j] / capacity)  # Penalize edges leading to high-demand nodes\n\n            # Calculate angle between edges (i->j) and (j-> depot) as proxy for smooth route.\n            # Lower values indicate direct route to depot\n            if i == 0: #depot to customer\n              angle_term = 0 #don't take into consideration\n            else:\n              vector_ij = coordinates[j] - coordinates[i]\n              vector_j0 = coordinates[0] - coordinates[j]\n              norm_ij = np.linalg.norm(vector_ij)\n              norm_j0 = np.linalg.norm(vector_j0)\n              if norm_ij > 0 and norm_j0 > 0:\n                dot_product = np.dot(vector_ij, vector_j0)\n                cosine_angle = dot_product / (norm_ij * norm_j0)\n                angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))\n                angle_term = (1 - angle_weight * angle / np.pi)\n              else:\n                angle_term = 0\n\n            #Additional penalty for high demand customers.\n            if demands[j] > (capacity/2):\n               demand_term = demand_term / capacity_penalty\n            \n            heuristic_matrix[i, j] = distance_term * demand_term * angle_term #Combine factors\n\n\n    return heuristic_matrix\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates a heuristic matrix for the Capacitated Vehicle Routing Problem (CVRP).\n    This version considers distance, demand, and proximity to the depot.\n\n    Args:\n        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes.\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).\n        demands (np.ndarray): A vector of customer demands.\n        capacity (int): The vehicle capacity.\n\n    Returns:\n        np.ndarray: A heuristic matrix where each element indicates the desirability\n                     of including the corresponding edge in a route.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Avoid division by zero.\n    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)\n\n    # Proximity to depot. Measure the angle each node creates to the depot.\n    depot_x, depot_y = coordinates[0]\n    angles = np.zeros(n_nodes)\n\n    for i in range(1, n_nodes):\n        x, y = coordinates[i]\n        dx = x - depot_x\n        dy = y - depot_y\n        angles[i] = np.arctan2(dy, dx)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # Do not allow self loops.\n            else:\n                # Prioritize shorter distances.\n                distance_factor = 1 / distance_matrix[i, j]\n\n                # Penalize edges connecting to nodes with high demand (except the depot).\n                demand_penalty_i = 1 if i == 0 else demands[i] / capacity\n                demand_penalty_j = 1 if j == 0 else demands[j] / capacity\n\n                # Add term to include node with larger angle\n                angle_diff = abs(angles[i]-angles[j])\n\n                #Combine angle and demand penalty\n                heuristic_matrix[i, j] = distance_factor / (demand_penalty_i * demand_penalty_j) + angle_diff/np.pi # Normalize\n\n    return heuristic_matrix\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates a heuristic matrix for the Capacitated Vehicle Routing Problem (CVRP).\n    This version considers distance, demand, and proximity to the depot.\n\n    Args:\n        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes.\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).\n        demands (np.ndarray): A vector of customer demands.\n        capacity (int): The vehicle capacity.\n\n    Returns:\n        np.ndarray: A heuristic matrix where each element indicates the desirability\n                     of including the corresponding edge in a route.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Avoid division by zero.\n    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)\n\n    # Proximity to depot. Measure the angle each node creates to the depot.\n    depot_x, depot_y = coordinates[0]\n    angles = np.zeros(n_nodes)\n\n    for i in range(1, n_nodes):\n        x, y = coordinates[i]\n        dx = x - depot_x\n        dy = y - depot_y\n        angles[i] = np.arctan2(dy, dx)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # Do not allow self loops.\n            else:\n                # Prioritize shorter distances.\n                distance_factor = 1 / distance_matrix[i, j]\n\n                # Penalize edges connecting to nodes with high demand (except the depot).\n                demand_penalty_i = 1 if i == 0 else demands[i] / capacity\n                demand_penalty_j = 1 if j == 0 else demands[j] / capacity\n\n                # Add term to include node with larger angle\n                angle_diff = abs(angles[i]-angles[j])\n\n                #Combine angle and demand penalty\n                heuristic_matrix[i, j] = distance_factor / (demand_penalty_i * demand_penalty_j) + angle_diff/np.pi # Normalize\n\n    return heuristic_matrix\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates a heuristic matrix for the Capacitated Vehicle Routing Problem (CVRP).\n    This version considers distance, demand, and proximity to the depot.\n\n    Args:\n        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes.\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).\n        demands (np.ndarray): A vector of customer demands.\n        capacity (int): The vehicle capacity.\n\n    Returns:\n        np.ndarray: A heuristic matrix where each element indicates the desirability\n                     of including the corresponding edge in a route.\n    \"\"\"\n    n_nodes = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix)\n\n    # Avoid division by zero.\n    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)\n\n    # Proximity to depot. Measure the angle each node creates to the depot.\n    depot_x, depot_y = coordinates[0]\n    angles = np.zeros(n_nodes)\n\n    for i in range(1, n_nodes):\n        x, y = coordinates[i]\n        dx = x - depot_x\n        dy = y - depot_y\n        angles[i] = np.arctan2(dy, dx)\n\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # Do not allow self loops.\n            else:\n                # Prioritize shorter distances.\n                distance_factor = 1 / distance_matrix[i, j]\n\n                # Penalize edges connecting to nodes with high demand (except the depot).\n                demand_penalty_i = 1 if i == 0 else demands[i] / capacity\n                demand_penalty_j = 1 if j == 0 else demands[j] / capacity\n\n                # Add term to include node with larger angle\n                angle_diff = abs(angles[i]-angles[j])\n\n                #Combine angle and demand penalty\n                heuristic_matrix[i, j] = distance_factor / (demand_penalty_i * demand_penalty_j) + angle_diff/np.pi # Normalize\n\n    return heuristic_matrix\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for CVRP based on distance, demand, and angle.\n\n    Args:\n        distance_matrix: Distance between nodes.\n        coordinates: Coordinates of each node.\n        demands: Demand of each node.\n        capacity: Vehicle capacity.\n\n    Returns:\n        Heuristic matrix indicating edge desirability.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Idea:  Combine distance (shorter is better), demand (lower is better given cap),\n    #        and angular considerations (avoid sharp turns). Also, bias away from high-demand nodes\n    #        except for the first hop (encourage initial diverse routes).\n\n    # Normalize demands\n    normalized_demands = demands / np.max(demands)  # Scale to 0-1\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:  # No self-loops\n\n                distance_factor = 1 / distance_matrix[i, j]\n                demand_factor = 1 - normalized_demands[j]  # Higher demand -> lower desirability\n                if i == 0: # depot. always visit all nodes\n                  demand_factor = 1.0 # remove demand as factor for initial route leaving the depot\n\n                # Angle heuristic: Penalize sharp turns.\n                # Calculate angle between vector i->j and depot->i\n\n                depot_x, depot_y = coordinates[0]\n                i_x, i_y = coordinates[i]\n                j_x, j_y = coordinates[j]\n                \n                # Calculate vectors\n                vector_ij = np.array([j_x - i_x, j_y - i_y])\n                vector_di = np.array([i_x - depot_x, i_y - depot_y])\n\n                # Normalize vectors to prevent magnitude affecting the result. Important!\n                vector_ij = vector_ij / (np.linalg.norm(vector_ij) + 1e-9)\n                vector_di = vector_di / (np.linalg.norm(vector_di) + 1e-9)\n\n\n                # Calculate dot product and clip to ensure acos works even with floating-point errors\n                dot_product = np.clip(np.dot(vector_ij, vector_di), -1.0, 1.0) #Ensure valid range\n\n                # Calculate angle (in radians). Larger angle -> worse desirability (penalize)\n                angle = np.arccos(dot_product)\n                angle_factor = 1 - (angle / np.pi) # Scale to 0 - 1, larger angle-> small factor.\n\n                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor\n            else:\n                heuristic_matrix[i, j] = 0  # No self-loops\n\n    # Normalize to 0-1 for consistent behavior\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix /= max_heuristic\n    else:\n        heuristic_matrix = np.ones_like(heuristic_matrix) / n # if every edge has a heuristic of 0\n\n    return heuristic_matrix\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP) based on distance, demand, and node proximity.\n\n    Args:\n        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes.\n        coordinates (np.ndarray): Euclidean coordinates of the nodes.\n        demands (np.ndarray): A vector of customer demands.\n        capacity (int): The vehicle capacity.\n\n    Returns:\n        np.ndarray: A matrix of heuristics values for each edge, indicating how promising it is to include the edge in a solution.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n\n    # Heuristic 1: Inverse distance - shorter distances are preferred\n    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero\n\n    # Heuristic 2: Demand-based penalty - penalize edges that connect nodes with high combined demand, exceeding capacity. Edges to the depot are always favored\n    demand_penalty = np.ones_like(distance_matrix)\n    for i in range(1, n):  # Skip depot (index 0) for the inner loop\n        for j in range(1, n):\n            if i != j:\n                if demands[i] + demands[j] > capacity:\n                    demand_penalty[i, j] = 0.1  # Severely penalize if sum exceeds capacity\n                else:\n                    demand_penalty[i,j] = 1\n\n    #Heuristic 3: Closeness to Depot Penalty.  Nodes farther away from depot penalize each other more strongly. This tries to pull edges closer to the depot earlier.\n    depot_penalty = np.ones_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1,n):\n            if i != j:\n                depot_distance_i = distance_matrix[0, i]\n                depot_distance_j = distance_matrix[0, j]\n                depot_penalty[i, j] = max(0.1, 1.0 / (0.1 + (depot_distance_i + depot_distance_j)/2 )) # Ensure a non-zero penalty. Larger distanes penalize more\n\n    #Favor connections to/from the depot\n    for i in range(1, n):\n      demand_penalty[0,i] = 1\n      demand_penalty[i,0] = 1\n      depot_penalty[0,i] = 1\n      depot_penalty[i,0] = 1\n\n\n\n\n    # Combine the heuristics - balance distance and demand considerations\n    heuristics_matrix = distance_heuristic * demand_penalty * depot_penalty\n\n    return heuristics_matrix\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates several factors to estimate edge desirability:\n    1. Inverse Distance: Shorter distances are generally more desirable.\n    2. Depot Proximity: Edges connected to the depot (node 0) are often crucial for route construction.\n    3. Demand Consideration: Penalizes edges connecting high-demand nodes to avoid overloading vehicles early in a route.\n    4. Closeness to Depot: If customer j is near to the depot than customer i then give higher priorities.\n    5. Angle between nodes i and j. Prefer shorter angle for faster visiting.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Vector of customer demands (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    depot_x, depot_y = coordinates[0]\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0  # No self-loops\n                continue\n\n            # 1. Inverse Distance\n            distance_factor = 1 / (distance_matrix[i, j] + 1e-9)  # Add a small value to avoid division by zero.\n\n            # 2. Depot Proximity\n            depot_proximity_factor = 0.0\n            if i == 0 or j == 0:\n                depot_proximity_factor = 1.0\n\n            # 3. Demand Consideration\n            demand_penalty = 1.0\n            demand_penalty = np.exp(-(demands[i] + demands[j]) / (2 * capacity) )  # Exponential decay for high demands\n\n            # 4. Closeness to depot:\n            distance_i_to_depot = np.sqrt((coordinates[i, 0] - depot_x)**2 + (coordinates[i, 1] - depot_y)**2)\n            distance_j_to_depot = np.sqrt((coordinates[j, 0] - depot_x)**2 + (coordinates[j, 1] - depot_y)**2)\n\n            closeness_factor = 0.0\n            if distance_j_to_depot < distance_i_to_depot:\n                closeness_factor = 0.5 # Adding a weight.\n\n            # 5. Angle\n\n            dx1 = coordinates[i, 0] - depot_x\n            dy1 = coordinates[i, 1] - depot_y\n            dx2 = coordinates[j, 0] - depot_x\n            dy2 = coordinates[j, 1] - depot_y\n            angle1 = np.arctan2(dy1, dx1)\n            angle2 = np.arctan2(dy2, dx2)\n            angle_diff = np.abs(angle1 - angle2)\n            angle_factor = 1/(angle_diff + 1e-9)\n            heuristics[i, j] = distance_factor * (1 + depot_proximity_factor) * demand_penalty + closeness_factor + angle_factor\n            # Combination of factors\n            #heuristics[i, j] = distance_factor + depot_proximity_factor - demand_factor\n    return heuristics\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for CVRP based on a combination of distance, demand, and spatial considerations.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes.\n        coordinates (np.ndarray): Euclidean coordinates of nodes.\n        demands (np.ndarray): Demand of each node.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators for each edge (same shape as distance_matrix).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Inverse distance (gravitational analogy - closer is better)\n    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add small constant to avoid division by zero\n\n    # Demand-aware penalty (penalize edges connecting nodes with high demand - capacity constraints)\n    demand_penalty = np.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            demand_penalty[i, j] = (demands[i] + demands[j]) / (2 * capacity)  # Scale penalty based on demand relative to capacity\n    \n    # Depot proximity bias (favor edges near the depot - central planning authority).\n    depot_proximity = np.zeros_like(distance_matrix)\n    for i in range(n):\n      for j in range(n):\n        depot_proximity[i,j] = 1 / (distance_matrix[0, i] + distance_matrix[0,j] + 1e-9)\n    # Angle-based heuristic (Encourage routes that don't have sharp turns - minimize jerky movements).\n\n    angle_factor = np.zeros_like(distance_matrix)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                vector_i = coordinates[i] - coordinates[0]  # Vector from depot to node i\n                vector_j = coordinates[j] - coordinates[0]  # Vector from depot to node j\n\n                # Compute cosine of the angle between the vectors\n                dot_product = np.dot(vector_i, vector_j)\n                magnitude_i = np.linalg.norm(vector_i)\n                magnitude_j = np.linalg.norm(vector_j)\n\n                if magnitude_i > 0 and magnitude_j > 0:\n                    cos_angle = dot_product / (magnitude_i * magnitude_j)\n                    angle_factor[i, j] = (1 + cos_angle)/2  #Scale to [0,1]. Higher is better (straighter paths)\n                else:\n                    angle_factor[i, j] = 0 # Handle edge cases.\n\n    # Combine the heuristics (assign weights based on relative importance)\n    heuristics = (0.5 * inverse_distance +\n                  0.15 * (1 - demand_penalty) +  # Invert the penalty so higher is better\n                  0.15 * depot_proximity +\n                  0.2 * angle_factor\n                  )\n\n    return heuristics\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for CVRP using a combination of distance, demand, and angular considerations.\n\n    Args:\n        distance_matrix: Distance matrix (n x n).\n        coordinates: Node coordinates (n x 2).\n        demands: Node demands (n).\n        capacity: Vehicle capacity.\n\n    Returns:\n        A matrix of heuristic values (n x n). Higher values indicate more promising edges.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Depot location (assuming it's the first node).\n    depot_x, depot_y = coordinates[0]\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n\n            else:\n                # Combination of factors:\n\n                # 1. Distance factor (inverse distance)\n                distance_factor = 1 / distance_matrix[i, j]\n\n                # 2. Demand factor: Prioritize edges connecting nodes with combined demand\n                # that is not excessive relative to vehicle capacity.\n                demand_factor = 1.0 / (1 + min(demands[i] + demands[j], capacity))\n\n                # 3. Angular factor:  Nodes closer to the 'angle' from depot are preferred.\n                # It encourages routing away from the depot in a broad sweep.\n\n                # Calculate angles from the depot to each node. Avoid division by zero.\n                angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)\n                angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)\n                angular_difference = abs(angle_i - angle_j)\n                # Penalize large angular differences.\n                angular_factor = 1.0 / (1 + angular_difference)\n\n                # Incorporate depot proximity. It is desirable to return to depot at certain point.\n                depot_distance_factor_i = 1.0 / (1 + distance_matrix[0, i])\n                depot_distance_factor_j = 1.0 / (1 + distance_matrix[0, j])\n                depot_proximity_factor = depot_distance_factor_i + depot_distance_factor_j\n\n                # Combine all factors with weights. Tune weights to fit the problem at hand.\n                heuristic_matrix[i, j] = (\n                    0.5 * distance_factor +\n                    0.15 * demand_factor +\n                    0.15 * angular_factor +\n                    0.2 * depot_proximity_factor\n                )\n\n\n    return heuristic_matrix\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for CVRP using a combination of distance, demand, and angular considerations.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Scale distance by demand\n    demand_scaled_distance = distance_matrix * (demands[np.newaxis, :] + demands[:, np.newaxis]) / (2 * capacity)  # Normalize by 2*capacity for relative cost\n    demand_scaled_distance = np.where(demand_scaled_distance == 0, np.inf, demand_scaled_distance) # Avoid division by zero and zero distances (self-loops)\n\n    # Angular penalty (discourage sharp turns at depot)\n    depot_x, depot_y = coordinates[0]\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                continue\n            node_i_x, node_i_y = coordinates[i]\n            node_j_x, node_j_y = coordinates[j]\n\n            # Angles relative to the depot\n            angle_i = np.arctan2(node_i_y - depot_y, node_i_x - depot_x)\n            angle_j = np.arctan2(node_j_y - depot_y, node_j_x - depot_x)\n\n            angle_diff = np.abs(angle_i - angle_j)\n            angle_diff = np.minimum(angle_diff, 2 * np.pi - angle_diff)  # Ensure angle_diff is the shorter angle\n\n            angular_penalty = (angle_diff / np.pi)  # Scale to [0, 1]\n\n            # Adjust heuristic value based on distance, demand and angular penalty.\n            heuristics[i, j] = 1 / (demand_scaled_distance[i, j] + 0.1* angular_penalty) # add a small amount to ensure strictly positive\n            heuristics[j, i] = heuristics[i, j] # enforce symmetric heuristics\n\n    # Special treatment for depot edges. Prioritize edges to the depot.\n    for i in range(1, n):\n        heuristics[0, i] = 1.0 / (distance_matrix[0, i]* demands[i] / capacity+1e-6)  # Scale by demand relative to capacity\n        heuristics[i, 0] = heuristics[0, i]\n\n    #Make self-loops zero to prohibit them\n    for i in range(n):\n      heuristics[i, i] = 0\n\n    return heuristics\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for CVRP using a combination of distance, demand, and angular considerations.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n\n    # Scale distance by demand\n    demand_scaled_distance = distance_matrix * (demands[np.newaxis, :] + demands[:, np.newaxis]) / (2 * capacity)  # Normalize by 2*capacity for relative cost\n    demand_scaled_distance = np.where(demand_scaled_distance == 0, np.inf, demand_scaled_distance) # Avoid division by zero and zero distances (self-loops)\n\n    # Angular penalty (discourage sharp turns at depot)\n    depot_x, depot_y = coordinates[0]\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                continue\n            node_i_x, node_i_y = coordinates[i]\n            node_j_x, node_j_y = coordinates[j]\n\n            # Angles relative to the depot\n            angle_i = np.arctan2(node_i_y - depot_y, node_i_x - depot_x)\n            angle_j = np.arctan2(node_j_y - depot_y, node_j_x - depot_x)\n\n            angle_diff = np.abs(angle_i - angle_j)\n            angle_diff = np.minimum(angle_diff, 2 * np.pi - angle_diff)  # Ensure angle_diff is the shorter angle\n\n            angular_penalty = (angle_diff / np.pi)  # Scale to [0, 1]\n\n            # Adjust heuristic value based on distance, demand and angular penalty.\n            heuristics[i, j] = 1 / (demand_scaled_distance[i, j] + 0.1* angular_penalty) # add a small amount to ensure strictly positive\n            heuristics[j, i] = heuristics[i, j] # enforce symmetric heuristics\n\n    # Special treatment for depot edges. Prioritize edges to the depot.\n    for i in range(1, n):\n        heuristics[0, i] = 1.0 / (distance_matrix[0, i]* demands[i] / capacity+1e-6)  # Scale by demand relative to capacity\n        heuristics[i, 0] = heuristics[0, i]\n\n    #Make self-loops zero to prohibit them\n    for i in range(n):\n      heuristics[i, i] = 0\n\n    return heuristics\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates heuristics for CVRP based on distance, demand, and vehicle capacity,\n    prioritizing edges that connect nodes with moderate demand that, when combined,\n    do not exceed vehicle capacity, and penalizing edges that are too long or\n    connect to very high-demand nodes. It also gives slight preference to shorter\n    edges overall, and connections to depot are given higher consideration\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Demand of each node (n). Depot demand is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Heuristic values for each edge (n x n).\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Scale distance for better handling\n    scaled_distance = distance_matrix / np.max(distance_matrix)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n\n            # Base heuristic: Inverse of distance (shorter edges are better)\n            heuristic_matrix[i, j] = 1 / (scaled_distance[i, j] + 0.0001) #prevent division by zero\n\n            # Demand consideration: Nodes with moderate demand are more desirable\n            demand_penalty = (demands[i] + demands[j]) / (2 * capacity)\n            heuristic_matrix[i, j] /= (demand_penalty + 0.5)  # Penalty increases as combined demand approaches capacity. Avoid division by zero\n\n            # Heavily Penalize edges connecting nodes with extreme demands if demand will overflow\n            if demands[i] > 0.7 * capacity or demands[j] > 0.7 * capacity:\n                heuristic_matrix[i, j] /= 5  # Much stronger penalty\n\n            # Add slight preference for edges close to depot\n            if i == 0 or j == 0:\n                heuristic_matrix[i, j] *= 1.5\n            \n            # Small boost for mid-range demand nodes as they have higher chance of being combined\n            if 0.15*capacity < demands[i] < 0.45*capacity or 0.15*capacity < demands[j] < 0.45*capacity:\n                heuristic_matrix[i, j] *= 1.1\n\n    return heuristic_matrix\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n    This version incorporates distance, demand, angle, and depot proximity considerations.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix (shape: n by n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n\n    # Avoid division by zero by adding a small epsilon\n    epsilon = 1e-6\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristics[i, j] = 0  # No self-loops\n                continue\n\n            # Base heuristic: inverse distance (more attractive for shorter distances)\n            distance_heuristic = 1 / (distance_matrix[i, j] + epsilon)\n\n            # Demand heuristic: penalize edges connecting high-demand nodes directly if capacity is limited.\n            # Encourage returning to the depot (node 0) if the demand is high.\n            demand_penalty = (demands[i] + demands[j]) / (2 * capacity + epsilon)\n            demand_heuristic = 1 - np.clip(demand_penalty, 0, 1)  # Clip to ensure it's not negative\n            if i == 0 or j == 0:  # Favor returns to the depot when close to full capacity.\n                demand_heuristic = 1.0\n\n            # Angle heuristic: Encourage smoother turns by penalizing sharp angles.\n            # Approximated using the cosine rule. If the angle is small, the penalty will be small\n            # leading to higher overall heuristic. The smaller the angle, the closer cosine to 1.\n            angle_heuristic = 1.0  # Assume perfect smoothing if insufficient nodes to form angle\n\n            if i != 0 and j != 0:\n                angle_heuristic = 0.0\n                # Find nearest node that is not equal to node i and j.\n                nn_idx = -1; dist = np.inf\n                for k in range(n):\n                  if k != i and k!= j:\n                    if distance_matrix[i, k] < dist:\n                      dist = distance_matrix[i,k]\n                      nn_idx = k\n\n                if nn_idx != -1:\n                    a = distance_matrix[i, j]\n                    b = distance_matrix[i, nn_idx]\n                    c = distance_matrix[j, nn_idx]\n                    # Catch exception arising from floating errors.\n                    try:\n                      angle_heuristic = (a**2 + b**2 - c**2) / (2 * a * b + epsilon)\n                      angle_heuristic = np.clip(angle_heuristic, -1.0, 1.0)  # Clip cosine value within valid range\n                      angle_heuristic = (angle_heuristic + 1.0) / 2.0 # maps the angle to be between 0 and 1\n                    except Exception as e:\n                        angle_heuristic = 0.5 # sets angle heuristic to indifference\n            # Depot proximity: if both i and j are far from the depot (node 0), penalize the edge.\n            depot_proximity_penalty = (distance_matrix[0, i] + distance_matrix[0, j]) / (2 * np.max(distance_matrix) + epsilon) # normalized.\n            depot_proximity_heuristic = 1 - np.clip(depot_proximity_penalty, 0, 1)  # If very far, value -> 0. Otherwise, value closer to 1.\n\n            # Combine heuristics with weights (can be tuned)\n            heuristics[i, j] = (\n                0.5 * distance_heuristic +\n                0.15 * demand_heuristic +\n                0.25 * angle_heuristic +\n                0.1 * depot_proximity_heuristic\n            )\n\n    return heuristics\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Improves upon v1 by considering demand, distance, and spatial clustering.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Avoid division by zero.\n    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)\n\n    # Combination of factors. Weights can be tuned.\n    alpha = 0.5  # Importance of distance\n    beta = 0.3   # Importance of demand feasibility (higher demand, lower heuristic)\n    gamma = 0.2  # Importance of cluster affinity\n\n    # Heuristic based on inverse distance\n    distance_heuristic = 1 / distance_matrix\n\n    # Heuristic based on demand feasibility.  Encourage edges to nodes\n    # that are unlikely to exceed capacity *early* in a route. Penalize if connecting would\n    # likely immediately exceed capacity\n    demand_heuristic = np.ones_like(distance_matrix, dtype=float)\n    for i in range(1, n):  # Skip depot\n        for j in range(1, n): #Skip depot\n            if i != j:\n                if demands[i] + demands[j] > capacity:\n                    demand_heuristic[i, j] = 0.1 # severely penalize the connection\n                else:\n                     demand_heuristic[i, j] = 1 - (demands[i] + demands[j]) / (2*capacity) # Linearly decreasing, but not lower than zero.\n\n    # Heuristic based on spatial clustering using a simple density estimate\n    # penalize for edges going outside local region to maintain more \"local\" routes\n    cluster_heuristic = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                 # Simple heuristic: Density based on inverse distance to other nodes\n                 density_i = np.sum(1 / distance_matrix[i, 1:]) - (1/ distance_matrix[i,i]) if np.sum(1 / distance_matrix[i, 1:]) < np.inf else 0 # Avoid division by zero, substract term 1/d_ii as distance_matrix[i,i] = inf\n                 density_j = np.sum(1 / distance_matrix[j, 1:]) - (1/ distance_matrix[j,j]) if np.sum(1 / distance_matrix[j, 1:]) < np.inf else 0 # Avoid division by zero\n                 # penalize connections to nodes with much lower density\n                 cluster_heuristic[i,j] = min(density_i, density_j) / max(density_i, density_j) if max(density_i, density_j) > 0 else 0 #Between 0 and 1\n\n    # Combine heuristics\n    heuristic_matrix = (alpha * distance_heuristic +\n                        beta * demand_heuristic +\n                        gamma * cluster_heuristic)\n\n    # Depot edges should be generally favored to return to depot\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 1.2  # Slightly favor leaving the depot\n        heuristic_matrix[i, 0] *= 1.2  # Slightly favor returning to the depot\n\n    return heuristic_matrix\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling principles.\n\n    This version incorporates distance, demand, and spatial distribution to guide the search towards promising edges.\n\n    Args:\n        distance_matrix: n x n distance matrix between nodes.\n        coordinates: n x 2 array of node coordinates (Euclidean).\n        demands: n-dimensional array of customer demands.\n        capacity: Vehicle capacity.\n\n    Returns:\n        n x n matrix of heuristic values, indicating the promise of including each edge in a solution.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Parameters (feel free to experiment with these)\n    distance_weight = 1.0\n    demand_weight = 1.0\n    spatial_weight = 0.5  # weight assigned to influence of neighboring demand\n    depot_proximity_weight = 0.5  # reward proximity to depot\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n\n            # 1. Distance component: Inverse of distance (shorter is better)\n            distance_heuristic = distance_weight / (distance_matrix[i, j] + 1e-9) # avoid division by zero\n\n            # 2. Demand component: Penalize edges connecting nodes with high combined demand relative to capacity.\n            #    We are using harmonic mean because high demands from either customer should deter the connection\n            demand_i = demands[i]\n            demand_j = demands[j]\n            combined_demand = (2 * demand_i * demand_j) / (demand_i + demand_j + 1e-9)\n\n            demand_heuristic = (1- min(1.0, combined_demand / capacity)) * demand_weight\n\n            # 3. Spatial Distribution component: Consider nearby nodes with high demand\n            spatial_heuristic = 0.0\n            neighbor_radius = np.mean(distance_matrix) / 2  # Dynamically adjusted radius\n            neighbor_count = 0\n            for k in range(n):\n                if k != i and k != j and distance_matrix[i, k] < neighbor_radius: # find neighbor\n                    spatial_heuristic += demands[k]\n                    neighbor_count += 1\n                if k != i and k != j and distance_matrix[j, k] < neighbor_radius:\n                    spatial_heuristic += demands[k]\n                    neighbor_count += 1\n            if neighbor_count > 0:\n                 spatial_heuristic = (1 - min(1, spatial_heuristic / (neighbor_count * capacity + 1e-9))) * spatial_weight\n            else:\n                spatial_heuristic = spatial_weight\n\n            #4. Proximity to Depot\n            depot_proximity = 1 - 0.9 * max(distance_matrix[0,i], distance_matrix[0,j]) / np.mean(distance_matrix)\n            depot_heuristic = depot_proximity * depot_proximity_weight\n\n            # Combine components - adjust weights to fine-tune the heuristic\n            heuristic_matrix[i, j] = distance_heuristic + demand_heuristic + spatial_heuristic + depot_heuristic\n\n    return heuristic_matrix\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling principles.\n\n    This version incorporates distance, demand, and spatial distribution to guide the search towards promising edges.\n\n    Args:\n        distance_matrix: n x n distance matrix between nodes.\n        coordinates: n x 2 array of node coordinates (Euclidean).\n        demands: n-dimensional array of customer demands.\n        capacity: Vehicle capacity.\n\n    Returns:\n        n x n matrix of heuristic values, indicating the promise of including each edge in a solution.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Parameters (feel free to experiment with these)\n    distance_weight = 1.0\n    demand_weight = 1.0\n    spatial_weight = 0.5  # weight assigned to influence of neighboring demand\n    depot_proximity_weight = 0.5  # reward proximity to depot\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n                continue\n\n            # 1. Distance component: Inverse of distance (shorter is better)\n            distance_heuristic = distance_weight / (distance_matrix[i, j] + 1e-9) # avoid division by zero\n\n            # 2. Demand component: Penalize edges connecting nodes with high combined demand relative to capacity.\n            #    We are using harmonic mean because high demands from either customer should deter the connection\n            demand_i = demands[i]\n            demand_j = demands[j]\n            combined_demand = (2 * demand_i * demand_j) / (demand_i + demand_j + 1e-9)\n\n            demand_heuristic = (1- min(1.0, combined_demand / capacity)) * demand_weight\n\n            # 3. Spatial Distribution component: Consider nearby nodes with high demand\n            spatial_heuristic = 0.0\n            neighbor_radius = np.mean(distance_matrix) / 2  # Dynamically adjusted radius\n            neighbor_count = 0\n            for k in range(n):\n                if k != i and k != j and distance_matrix[i, k] < neighbor_radius: # find neighbor\n                    spatial_heuristic += demands[k]\n                    neighbor_count += 1\n                if k != i and k != j and distance_matrix[j, k] < neighbor_radius:\n                    spatial_heuristic += demands[k]\n                    neighbor_count += 1\n            if neighbor_count > 0:\n                 spatial_heuristic = (1 - min(1, spatial_heuristic / (neighbor_count * capacity + 1e-9))) * spatial_weight\n            else:\n                spatial_heuristic = spatial_weight\n\n            #4. Proximity to Depot\n            depot_proximity = 1 - 0.9 * max(distance_matrix[0,i], distance_matrix[0,j]) / np.mean(distance_matrix)\n            depot_heuristic = depot_proximity * depot_proximity_weight\n\n            # Combine components - adjust weights to fine-tune the heuristic\n            heuristic_matrix[i, j] = distance_heuristic + demand_heuristic + spatial_heuristic + depot_heuristic\n\n    return heuristic_matrix\n\n[Heuristics 19th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristic for CVRP based on distance, demand, and angle.\n\n    Args:\n        distance_matrix: Distance matrix between nodes.\n        coordinates: Coordinates of each node.\n        demands: Demand of each node.\n        capacity: Vehicle capacity.\n\n    Returns:\n        A matrix indicating the desirability of each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Calculate angle between nodes relative to depot\n    depot_x, depot_y = coordinates[0]\n    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0\n                continue\n\n            distance_factor = 1 / distance_matrix[i, j]\n\n            # Penalize edges connecting nodes with high demands if either i or j is not the depot\n            demand_penalty = 1.0\n            if i != 0 and j != 0:\n                demand_penalty = 1 / (demands[i] + demands[j])\n\n            # Encourage edges connecting nodes with similar angles (close to the depot)\n            angle_diff = abs(angles[i] - angles[j])\n            angle_factor = np.exp(-angle_diff)  # Exponential decay based on angle difference\n\n            heuristic_matrix[i, j] = distance_factor * demand_penalty * angle_factor\n\n    return heuristic_matrix\n\n[Heuristics 20th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristic function for CVRP using a combination of distance, demand, and angle considerations.\n\n    Args:\n        distance_matrix: Distance matrix between nodes (n x n).\n        coordinates: Euclidean coordinates of nodes (n x 2).\n        demands: Customer demands (n).\n        capacity: Vehicle capacity.\n\n    Returns:\n        Heuristic matrix (n x n) indicating the desirability of including each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Parameters to control the influence of different factors\n    distance_weight = 0.5\n    demand_weight = 0.3\n    angle_weight = 0.2\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0  # No self-loops\n            else:\n                # Distance factor: Inverse of distance\n                distance_factor = 1 / distance_matrix[i, j]\n\n                # Demand factor:  Encourage connecting to nodes with demands that fit vehicle capacity.\n                # Penalize exceeding capacity more heavily.\n\n                demand_factor = 1 / (demands[j] + 1e-6) # Avoid division by zero\n                if demands[i] + demands[j] > capacity:\n                    demand_factor /=2\n\n                # Angle factor:  Prefer edges that don't make sharp turns\n                # Calculate the angle between the vectors from node i to node j and from node 0 (depot) to node j\n                if i != 0 and j != 0:\n                    vector_ij = coordinates[j] - coordinates[i]\n                    vector_0j = coordinates[j] - coordinates[0]\n\n                    # Calculate the dot product and magnitudes\n                    dot_product = np.dot(vector_ij, vector_0j)\n                    magnitude_ij = np.linalg.norm(vector_ij)\n                    magnitude_0j = np.linalg.norm(vector_0j)\n\n                    # Calculate the cosine of the angle\n                    if magnitude_ij > 0 and magnitude_0j > 0:\n                        cos_angle = dot_product / (magnitude_ij * magnitude_0j)\n                        # Ensure cos_angle is within [-1, 1] to avoid errors\n                        cos_angle = np.clip(cos_angle, -1.0, 1.0)\n                        angle = np.arccos(cos_angle)  # Angle in radians\n                        angle_factor = 1 - (angle / np.pi) # Normalize between 0 and 1\n\n                    else:\n                        angle_factor = 0.5 # Neutral value if vectors are zero\n                else:\n                    angle_factor = 0.5 #Neutral if one node is the depot.\n\n\n                # Combine the factors\n                heuristic_matrix[i, j] = (\n                    distance_weight * distance_factor +\n                    demand_weight * demand_factor +\n                    angle_weight * angle_factor\n                )\n\n    return heuristic_matrix\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}