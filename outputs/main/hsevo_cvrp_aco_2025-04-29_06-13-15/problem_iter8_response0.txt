```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """Heuristic: Combines distance, demand, angle, depot proximity with adaptive weighting."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))
    epsilon = 1e-6

    # Calculate tightness of capacity constraint
    capacity_ratio = np.sum(demands) / (capacity * (n - 1)) #excluding depot

    for i in range(n):
        for j in range(n):
            if i == j:
                continue

            dist_h = 1 / (distance_matrix[i, j] + epsilon)
            demand_h = 1 - np.clip((demands[i] + demands[j]) / (2 * capacity + epsilon), 0, 1)
            if i == 0 or j == 0:
                demand_h = 1.0

            angle_h = 1.0
            if i != 0 and j != 0:
                angle_h = 0.0

                # Calculate angle to depot
                depot_x, depot_y = coordinates[0]
                i_x, i_y = coordinates[i]
                j_x, j_y = coordinates[j]

                vector_ij = np.array([j_x - i_x, j_y - i_y])
                vector_di = np.array([i_x - depot_x, i_y - depot_y])

                vector_ij = vector_ij / (np.linalg.norm(vector_ij) + epsilon)
                vector_di = vector_di / (np.linalg.norm(vector_di) + epsilon)

                dot_product = np.clip(np.dot(vector_ij, vector_di), -1.0, 1.0)
                angle = np.arccos(dot_product)
                angle_h = 1 - (angle / np.pi)


            depot_prox_h = 1 - np.clip((distance_matrix[0, i] + distance_matrix[0, j]) / (2 * np.max(distance_matrix) + epsilon), 0, 1)

            # Adaptive weights based on capacity tightness
            weight_dist = 0.5
            weight_demand = 0.15 + 0.2 * capacity_ratio  # Increase weight if capacity is tight
            weight_angle = 0.25 - 0.1 * capacity_ratio   # Decrease weight if capacity is tight
            weight_depot = 0.1

            heuristic_matrix[i, j] = (
                weight_dist * dist_h +
                weight_demand * demand_h +
                weight_angle * angle_h +
                weight_depot * depot_prox_h
            )

    # Normalize heuristic values
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        heuristic_matrix /= max_heuristic
    else:
        heuristic_matrix = np.ones_like(heuristic_matrix) / n


    # Sparsify the matrix based on mean heuristic value
    threshold = np.mean(heuristic_matrix) * 0.5
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
