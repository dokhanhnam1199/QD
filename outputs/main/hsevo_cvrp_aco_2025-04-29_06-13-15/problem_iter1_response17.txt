```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and angle.

    Args:
        distance_matrix: Distance between nodes.
        coordinates: Coordinates of each node.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        Heuristic matrix indicating edge desirability.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Idea:  Combine distance (shorter is better), demand (lower is better given cap),
    #        and angular considerations (avoid sharp turns). Also, bias away from high-demand nodes
    #        except for the first hop (encourage initial diverse routes).

    # Normalize demands
    normalized_demands = demands / np.max(demands)  # Scale to 0-1

    for i in range(n):
        for j in range(n):
            if i != j:  # No self-loops

                distance_factor = 1 / distance_matrix[i, j]
                demand_factor = 1 - normalized_demands[j]  # Higher demand -> lower desirability
                if i == 0: # depot. always visit all nodes
                  demand_factor = 1.0 # remove demand as factor for initial route leaving the depot

                # Angle heuristic: Penalize sharp turns.
                # Calculate angle between vector i->j and depot->i

                depot_x, depot_y = coordinates[0]
                i_x, i_y = coordinates[i]
                j_x, j_y = coordinates[j]
                
                # Calculate vectors
                vector_ij = np.array([j_x - i_x, j_y - i_y])
                vector_di = np.array([i_x - depot_x, i_y - depot_y])

                # Normalize vectors to prevent magnitude affecting the result. Important!
                vector_ij = vector_ij / (np.linalg.norm(vector_ij) + 1e-9)
                vector_di = vector_di / (np.linalg.norm(vector_di) + 1e-9)


                # Calculate dot product and clip to ensure acos works even with floating-point errors
                dot_product = np.clip(np.dot(vector_ij, vector_di), -1.0, 1.0) #Ensure valid range

                # Calculate angle (in radians). Larger angle -> worse desirability (penalize)
                angle = np.arccos(dot_product)
                angle_factor = 1 - (angle / np.pi) # Scale to 0 - 1, larger angle-> small factor.

                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor
            else:
                heuristic_matrix[i, j] = 0  # No self-loops

    # Normalize to 0-1 for consistent behavior
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        heuristic_matrix /= max_heuristic
    else:
        heuristic_matrix = np.ones_like(heuristic_matrix) / n # if every edge has a heuristic of 0

    return heuristic_matrix
```
