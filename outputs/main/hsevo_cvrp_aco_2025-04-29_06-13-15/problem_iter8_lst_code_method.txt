{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1.  Distance: Edges with shorter distances are preferred.\n    2.  Demand Feasibility: Penalizes edges that would immediately violate capacity constraints if used early in a route.\n    3.  Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4.  Gravitational Attraction: Mimics the gravitational attraction of black holes: Nodes with high demand and/or far from depot will \"attract\" closer nodes to form clusters.\n    5.  Savings Heuristic Integration: Incorporates the savings heuristic to encourage merging routes.\n    6.  Sparsification: Sets unpromising edges to zero to focus the search.\n    7.  Clustering Coefficient: Encourages connections between nodes within local clusters\n    8.  Adaptive Weighting: Adjusts weights based on problem characteristics (e.g., tightness of capacity)\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # 4. Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0\n    for i in range(1, n):\n        for j in range(1, n):\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n\n    # 5. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n\n    # 7. Clustering Coefficient approximation (Local Density)\n    clustering_heuristic = np.zeros((n, n))\n    k_nearest = 6  # Consider only k-nearest neighbors for clustering\n    for i in range(1, n):\n        nearest_neighbors = np.argsort(distance_matrix[i, 1:])[:k_nearest] + 1  # k-nearest neighbors excluding depot, adjusting index\n        for j in range(1, n):\n            if i != j:\n                common_neighbors = 0\n                for neighbor_i in nearest_neighbors:\n                    if neighbor_i in (np.argsort(distance_matrix[j, 1:])[:k_nearest] + 1):\n                        common_neighbors += 1\n                clustering_heuristic[i, j] = common_neighbors / k_nearest\n\n    # 8. Adaptive Weighting\n    # Adjust weights based on problem characteristics (e.g., capacity tightness)\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n - 1))  # Approximate tightness\n    alpha = 0.3\n    beta = 0.15\n    gamma = 0.1\n    delta = 0.15\n    eta = 0.1\n    mu = 0.2\n\n    # Adjust alpha (distance) and beta (depot) based on capacity ratio\n    alpha += 0.1 * capacity_ratio  # Increase importance of distance if capacity is tight\n    beta -= 0.05 * capacity_ratio  # Decrease importance of going to depot if capacity is tight (more local clusters)\n\n    # Combine the heuristics with adaptive weights. Weights could be tuned by a metaheuristic\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * gravitational_heuristic + delta * savings_heuristic + mu * clustering_heuristic\n\n    # 6. Sparsification\n    # Only keep edges with a heuristic value above a certain threshold or that are among the k-nearest neighbors.\n    k_nearest = 10  # consider only k-nearest neighbors.\n    threshold = np.percentile(heuristics[heuristics > 0], 30)  # Dynamic threshold (e.g., 30th percentile)\n\n    for i in range(n):\n        # Find k-nearest neighbors\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1] #excluding self loop and depot\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Heuristics for CVRP combining distance, demand, depot proximity, savings, and gravitational attraction with sparsification.\"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                 demand_heuristic[i,j] = 0.05\n\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # 4. Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0\n    for i in range(1, n):\n        for j in range(1, n):\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n\n    # 5. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_heuristic[i, j] = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[j, i] = savings_heuristic[i, j]\n\n    # Adaptive Weighting\n    avg_demand = np.mean(demands[1:])\n    demand_ratio = avg_demand / capacity\n\n    weight_distance = 0.4\n    weight_demand = 0.3\n    weight_depot = 0.1 + demand_ratio * 0.2\n    weight_gravitational = 0.1\n    weight_savings = 0.1 - demand_ratio * 0.05\n\n    heuristics = (weight_distance * distance_heuristic * demand_heuristic +\n                  weight_depot * depot_heuristic +\n                  weight_gravitational * gravitational_heuristic +\n                  weight_savings * savings_heuristic)\n\n    # Sparsification\n    threshold = np.mean(heuristics) * 0.2\n    heuristics[heuristics < threshold] = 0\n\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Heuristics for CVRP combining distance, demand, depot proximity, savings, and gravitational attraction with sparsification.\"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                 demand_heuristic[i,j] = 0.05\n\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # 4. Gravitational Attraction\n    gravitational_heuristic = np.zeros((n, n))\n    gravitational_constant = 1.0\n    for i in range(1, n):\n        for j in range(1, n):\n            mass_i = demands[i]\n            mass_j = demands[j]\n            if i == j:\n                gravitational_heuristic[i,j] = 0\n                continue\n            gravitational_heuristic[i, j] = gravitational_constant * (mass_i * mass_j) / (distance_matrix[i, j]**2 + epsilon)\n\n    # 5. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_heuristic[i, j] = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[j, i] = savings_heuristic[i, j]\n\n    # Adaptive Weighting\n    avg_demand = np.mean(demands[1:])\n    demand_ratio = avg_demand / capacity\n\n    weight_distance = 0.4\n    weight_demand = 0.3\n    weight_depot = 0.1 + demand_ratio * 0.2\n    weight_gravitational = 0.1\n    weight_savings = 0.1 - demand_ratio * 0.05\n\n    heuristics = (weight_distance * distance_heuristic * demand_heuristic +\n                  weight_depot * depot_heuristic +\n                  weight_gravitational * gravitational_heuristic +\n                  weight_savings * savings_heuristic)\n\n    # Sparsification\n    threshold = np.mean(heuristics) * 0.2\n    heuristics[heuristics < threshold] = 0\n\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1. Distance: Edges with shorter distances are preferred.\n    2. Demand Feasibility: Penalizes edges that would immediately violate capacity constraints.\n    3. Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4. Savings Heuristic Integration: Encourages merging routes based on savings.\n    5. Angle-based Clustering: Encourages connections within angular sectors from the depot.\n    6. Adaptive Weighting: Adjusts the importance of heuristics based on problem characteristics.\n    7. Sparsification: Sets unpromising edges to zero to focus the search.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0): # Only penalize depot connections exceeding capacity.\n                 demand_heuristic[i, j] = 0.1  # Reduced penalty\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity: #Prevent from selecting nodes that exceed the capacity\n                demand_heuristic[i,j] = 0.05 #reduced penalty\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / (np.max(distance_matrix) + epsilon)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # 4. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n\n    # 5. Angle-based Clustering\n    angle_heuristic = np.zeros((n, n))\n    depot_x, depot_y = coordinates[0]\n    for i in range(1, n):\n        angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)\n        for j in range(i + 1, n):\n            angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)\n            angle_diff = min(abs(angle_i - angle_j), 2 * np.pi - abs(angle_i - angle_j))\n            angle_preference = np.exp(-angle_diff)  # Higher value for smaller angle differences\n            angle_heuristic[i, j] = angle_preference\n            angle_heuristic[j, i] = angle_preference\n\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)\n\n\n    # 6. Adaptive Weighting\n    # Adjust weights based on problem characteristics (e.g., tightness of capacity)\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n-1)) #Total demand vs max total vehicle capacity needed\n    alpha = 0.35 #Distance\n    beta = 0.1 #Depot\n    gamma = 0.25 #Savings\n    delta = 0.3 # Angle\n\n    # Combine the heuristics with adaptive weights\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * savings_heuristic * demand_heuristic + delta * angle_heuristic * demand_heuristic\n\n    # 7. Sparsification\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 40)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1. Distance: Edges with shorter distances are preferred.\n    2. Demand Feasibility: Penalizes edges that would immediately violate capacity constraints.\n    3. Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4. Savings Heuristic Integration: Encourages merging routes based on savings.\n    5. Angle-based Clustering: Encourages connections within angular sectors from the depot.\n    6. Adaptive Weighting: Adjusts the importance of heuristics based on problem characteristics.\n    7. Sparsification: Sets unpromising edges to zero to focus the search.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0): # Only penalize depot connections exceeding capacity.\n                 demand_heuristic[i, j] = 0.1  # Reduced penalty\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity: #Prevent from selecting nodes that exceed the capacity\n                demand_heuristic[i,j] = 0.05 #reduced penalty\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / (np.max(distance_matrix) + epsilon)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # 4. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n\n    # 5. Angle-based Clustering\n    angle_heuristic = np.zeros((n, n))\n    depot_x, depot_y = coordinates[0]\n    for i in range(1, n):\n        angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)\n        for j in range(i + 1, n):\n            angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)\n            angle_diff = min(abs(angle_i - angle_j), 2 * np.pi - abs(angle_i - angle_j))\n            angle_preference = np.exp(-angle_diff)  # Higher value for smaller angle differences\n            angle_heuristic[i, j] = angle_preference\n            angle_heuristic[j, i] = angle_preference\n\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)\n\n\n    # 6. Adaptive Weighting\n    # Adjust weights based on problem characteristics (e.g., tightness of capacity)\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n-1)) #Total demand vs max total vehicle capacity needed\n    alpha = 0.35 #Distance\n    beta = 0.1 #Depot\n    gamma = 0.25 #Savings\n    delta = 0.3 # Angle\n\n    # Combine the heuristics with adaptive weights\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * savings_heuristic * demand_heuristic + delta * angle_heuristic * demand_heuristic\n\n    # 7. Sparsification\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 40)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1. Distance: Edges with shorter distances are preferred.\n    2. Demand Feasibility: Penalizes edges that would immediately violate capacity constraints.\n    3. Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4. Savings Heuristic Integration: Encourages merging routes based on savings.\n    5. Angle-based Clustering: Encourages connections within angular sectors from the depot.\n    6. Adaptive Weighting: Adjusts the importance of heuristics based on problem characteristics.\n    7. Sparsification: Sets unpromising edges to zero to focus the search.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and (i == 0 or j == 0): # Only penalize depot connections exceeding capacity.\n                 demand_heuristic[i, j] = 0.1  # Reduced penalty\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity: #Prevent from selecting nodes that exceed the capacity\n                demand_heuristic[i,j] = 0.05 #reduced penalty\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / (np.max(distance_matrix) + epsilon)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # 4. Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n\n    # 5. Angle-based Clustering\n    angle_heuristic = np.zeros((n, n))\n    depot_x, depot_y = coordinates[0]\n    for i in range(1, n):\n        angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)\n        for j in range(i + 1, n):\n            angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)\n            angle_diff = min(abs(angle_i - angle_j), 2 * np.pi - abs(angle_i - angle_j))\n            angle_preference = np.exp(-angle_diff)  # Higher value for smaller angle differences\n            angle_heuristic[i, j] = angle_preference\n            angle_heuristic[j, i] = angle_preference\n\n    angle_heuristic = (angle_heuristic - np.min(angle_heuristic)) / (np.max(angle_heuristic) - np.min(angle_heuristic) + epsilon)\n\n\n    # 6. Adaptive Weighting\n    # Adjust weights based on problem characteristics (e.g., tightness of capacity)\n    capacity_ratio = np.sum(demands[1:]) / (capacity * (n-1)) #Total demand vs max total vehicle capacity needed\n    alpha = 0.35 #Distance\n    beta = 0.1 #Depot\n    gamma = 0.25 #Savings\n    delta = 0.3 # Angle\n\n    # Combine the heuristics with adaptive weights\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + gamma * savings_heuristic * demand_heuristic + delta * angle_heuristic * demand_heuristic\n\n    # 7. Sparsification\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 40)\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Heuristic combining distance, demand, angle, and depot proximity with sparsification.\"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n    normalized_demands = demands / np.max(demands)  # Scale to 0-1\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                distance_factor = 1 / distance_matrix[i, j]\n                demand_factor = 1 - normalized_demands[j]\n                if i == 0:\n                    demand_factor = 1.0\n\n                # Angle heuristic relative to the depot\n                depot_x, depot_y = coordinates[0]\n                i_x, i_y = coordinates[i]\n                j_x, j_y = coordinates[j]\n\n                vector_ij = np.array([j_x - i_x, j_y - i_y])\n                vector_di = np.array([i_x - depot_x, i_y - depot_y])\n\n                vector_ij = vector_ij / (np.linalg.norm(vector_ij) + 1e-9)\n                vector_di = vector_di / (np.linalg.norm(vector_di) + 1e-9)\n\n                dot_product = np.clip(np.dot(vector_ij, vector_di), -1.0, 1.0)\n                angle = np.arccos(dot_product)\n                angle_factor = 1 - (angle / np.pi)\n\n                # Depot proximity: encourage nodes close to depot\n                depot_distance_i = distance_matrix[0, i]\n                depot_distance_j = distance_matrix[0, j]\n                depot_proximity_factor = 1 / (depot_distance_i + depot_distance_j + 1e-9)\n\n                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor * depot_proximity_factor\n            else:\n                heuristic_matrix[i, j] = 0\n\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix /= max_heuristic\n    else:\n        heuristic_matrix = np.ones_like(heuristic_matrix) / n\n\n    # Sparsification: zero out weak edges\n    mean_heuristic = np.mean(heuristic_matrix)\n    heuristic_matrix[heuristic_matrix < 0.5 * mean_heuristic] = 0 # adaptive sparsification\n\n    return heuristic_matrix\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Heuristic combining distance, demand, angle, and depot proximity with sparsification.\"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n    normalized_demands = demands / np.max(demands)  # Scale to 0-1\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                distance_factor = 1 / distance_matrix[i, j]\n                demand_factor = 1 - normalized_demands[j]\n                if i == 0:\n                    demand_factor = 1.0\n\n                # Angle heuristic relative to the depot\n                depot_x, depot_y = coordinates[0]\n                i_x, i_y = coordinates[i]\n                j_x, j_y = coordinates[j]\n\n                vector_ij = np.array([j_x - i_x, j_y - i_y])\n                vector_di = np.array([i_x - depot_x, i_y - depot_y])\n\n                vector_ij = vector_ij / (np.linalg.norm(vector_ij) + 1e-9)\n                vector_di = vector_di / (np.linalg.norm(vector_di) + 1e-9)\n\n                dot_product = np.clip(np.dot(vector_ij, vector_di), -1.0, 1.0)\n                angle = np.arccos(dot_product)\n                angle_factor = 1 - (angle / np.pi)\n\n                # Depot proximity: encourage nodes close to depot\n                depot_distance_i = distance_matrix[0, i]\n                depot_distance_j = distance_matrix[0, j]\n                depot_proximity_factor = 1 / (depot_distance_i + depot_distance_j + 1e-9)\n\n                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor * depot_proximity_factor\n            else:\n                heuristic_matrix[i, j] = 0\n\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix /= max_heuristic\n    else:\n        heuristic_matrix = np.ones_like(heuristic_matrix) / n\n\n    # Sparsification: zero out weak edges\n    mean_heuristic = np.mean(heuristic_matrix)\n    heuristic_matrix[heuristic_matrix < 0.5 * mean_heuristic] = 0 # adaptive sparsification\n\n    return heuristic_matrix\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Heuristic combining distance, demand, angle, and depot proximity with sparsification.\"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n    normalized_demands = demands / np.max(demands)  # Scale to 0-1\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                distance_factor = 1 / distance_matrix[i, j]\n                demand_factor = 1 - normalized_demands[j]\n                if i == 0:\n                    demand_factor = 1.0\n\n                # Angle heuristic relative to the depot\n                depot_x, depot_y = coordinates[0]\n                i_x, i_y = coordinates[i]\n                j_x, j_y = coordinates[j]\n\n                vector_ij = np.array([j_x - i_x, j_y - i_y])\n                vector_di = np.array([i_x - depot_x, i_y - depot_y])\n\n                vector_ij = vector_ij / (np.linalg.norm(vector_ij) + 1e-9)\n                vector_di = vector_di / (np.linalg.norm(vector_di) + 1e-9)\n\n                dot_product = np.clip(np.dot(vector_ij, vector_di), -1.0, 1.0)\n                angle = np.arccos(dot_product)\n                angle_factor = 1 - (angle / np.pi)\n\n                # Depot proximity: encourage nodes close to depot\n                depot_distance_i = distance_matrix[0, i]\n                depot_distance_j = distance_matrix[0, j]\n                depot_proximity_factor = 1 / (depot_distance_i + depot_distance_j + 1e-9)\n\n                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor * depot_proximity_factor\n            else:\n                heuristic_matrix[i, j] = 0\n\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix /= max_heuristic\n    else:\n        heuristic_matrix = np.ones_like(heuristic_matrix) / n\n\n    # Sparsification: zero out weak edges\n    mean_heuristic = np.mean(heuristic_matrix)\n    heuristic_matrix[heuristic_matrix < 0.5 * mean_heuristic] = 0 # adaptive sparsification\n\n    return heuristic_matrix\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1. Distance: Edges with shorter distances are preferred.\n    2. Demand Feasibility: Penalizes edges that would immediately violate capacity constraints.\n    3. Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4. Savings Heuristic Integration: Incorporates the savings heuristic to encourage merging routes.\n    5. Clustering Encouragement: Encourages connections within spatial clusters.\n    6. Sparsification: Sets unpromising edges to zero to focus the search, adaptively.\n    7. Adaptive Weighting: Dynamically adjusts weights based on problem characteristics.\n    8. Demand Density: Considers demand density around each node.\n    9. Angle to Depot: Prioritizes connections that reduce the angle formed by (node i - depot - node j) to encourage direct routes\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component (normalized)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Depot Proximity (normalized and enhanced)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # 4. Savings Heuristic (normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 5. Clustering Encouragement (based on spatial proximity)\n    clustering_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            dist_ij = distance_matrix[i, j]\n            # Encourage connections between nodes that are close relative to their distance to the depot\n            clustering_heuristic[i, j] = clustering_heuristic[j, i] = np.exp(-dist_ij / (distance_matrix[i, 0] + distance_matrix[j, 0] + epsilon))\n\n    # 6. Demand Density\n    demand_density_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                continue\n            # Measure demand density around each node\n            neighborhood_size = 5 #number of neighbors to consider\n            i_neighbors = np.argsort(distance_matrix[i, 1:])[:neighborhood_size] + 1\n            j_neighbors = np.argsort(distance_matrix[j, 1:])[:neighborhood_size] + 1\n\n            i_density = np.sum(demands[i_neighbors]) / np.sum(distance_matrix[i, i_neighbors]) if np.sum(distance_matrix[i, i_neighbors]) > 0 else 0\n            j_density = np.sum(demands[j_neighbors]) / np.sum(distance_matrix[j, j_neighbors]) if np.sum(distance_matrix[j, j_neighbors]) > 0 else 0\n            demand_density_heuristic[i,j] = demand_density_heuristic[j, i] = i_density + j_density\n\n    demand_density_heuristic = (demand_density_heuristic - np.min(demand_density_heuristic)) / (np.max(demand_density_heuristic) - np.min(demand_density_heuristic) + epsilon)\n\n    #7. Angle to Depot\n    angle_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                continue\n            vector_i = coordinates[i] - coordinates[0]\n            vector_j = coordinates[j] - coordinates[0]\n\n            # Calculate the cosine of the angle\n            cosine_angle = np.dot(vector_i, vector_j) / (np.linalg.norm(vector_i) * np.linalg.norm(vector_j) + epsilon)\n\n            # Convert cosine to angle in radians\n            angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))\n\n            angle_heuristic[i, j] = angle_heuristic[j, i] =  1- (angle / np.pi) # Normalize to [0, 1] (higher is better, smaller angle)\n\n    # Adaptive Weighting (adjust based on problem size/characteristics)\n    n_customers = n - 1\n    alpha = 0.3 #distance\n    beta = 0.15 #depot proximity\n    gamma = 0.20 #savings\n    delta = 0.15 #clustering\n    eta = 0.1 #demand density\n    phi = 0.1 #angle heuristic\n    # Adjust weights (example: emphasize depot proximity more for larger problems)\n    if n_customers > 50:\n        beta += 0.05\n        alpha -= 0.05 #reduce alpha a bit\n    if capacity < np.mean(demands) * 5: # Tighter capacity constraints, increase savings\n        gamma += 0.05\n\n    # Combine the heuristics\n    heuristics = (alpha * distance_heuristic * demand_heuristic +\n                  beta * depot_heuristic +\n                  gamma * savings_heuristic +\n                  delta * clustering_heuristic +\n                  eta * demand_density_heuristic +\n                  phi * angle_heuristic)\n\n    # 8. Sparsification (adaptive threshold based on heuristic values)\n    threshold = np.percentile(heuristics[heuristics > 0], 40) # Increased sparsity\n\n    k_nearest = 12 #consider k-nearest neighbors, increase it a bit\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    This version incorporates:\n    1. Distance: Edges with shorter distances are preferred.\n    2. Demand Feasibility: Penalizes edges that would immediately violate capacity constraints.\n    3. Depot Proximity: Prioritizes returning to the depot from nodes that are far from other customers and have high demand.\n    4. Savings Heuristic Integration: Incorporates the savings heuristic to encourage merging routes.\n    5. Clustering Encouragement: Encourages connections within spatial clusters.\n    6. Sparsification: Sets unpromising edges to zero to focus the search, adaptively.\n    7. Adaptive Weighting: Dynamically adjusts weights based on problem characteristics.\n    8. Demand Density: Considers demand density around each node.\n    9. Angle to Depot: Prioritizes connections that reduce the angle formed by (node i - depot - node j) to encourage direct routes\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n). The demand of depot is demands[0].\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component (normalized)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n    distance_heuristic = (distance_heuristic - np.min(distance_heuristic)) / (np.max(distance_heuristic) - np.min(distance_heuristic) + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Depot Proximity (normalized and enhanced)\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i, 0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n    depot_heuristic = (depot_heuristic - np.min(depot_heuristic)) / (np.max(depot_heuristic) - np.min(depot_heuristic) + epsilon)\n\n\n    # 4. Savings Heuristic (normalized)\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings  # Savings are symmetric\n    savings_heuristic = (savings_heuristic - np.min(savings_heuristic)) / (np.max(savings_heuristic) - np.min(savings_heuristic) + epsilon)\n\n    # 5. Clustering Encouragement (based on spatial proximity)\n    clustering_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            dist_ij = distance_matrix[i, j]\n            # Encourage connections between nodes that are close relative to their distance to the depot\n            clustering_heuristic[i, j] = clustering_heuristic[j, i] = np.exp(-dist_ij / (distance_matrix[i, 0] + distance_matrix[j, 0] + epsilon))\n\n    # 6. Demand Density\n    demand_density_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                continue\n            # Measure demand density around each node\n            neighborhood_size = 5 #number of neighbors to consider\n            i_neighbors = np.argsort(distance_matrix[i, 1:])[:neighborhood_size] + 1\n            j_neighbors = np.argsort(distance_matrix[j, 1:])[:neighborhood_size] + 1\n\n            i_density = np.sum(demands[i_neighbors]) / np.sum(distance_matrix[i, i_neighbors]) if np.sum(distance_matrix[i, i_neighbors]) > 0 else 0\n            j_density = np.sum(demands[j_neighbors]) / np.sum(distance_matrix[j, j_neighbors]) if np.sum(distance_matrix[j, j_neighbors]) > 0 else 0\n            demand_density_heuristic[i,j] = demand_density_heuristic[j, i] = i_density + j_density\n\n    demand_density_heuristic = (demand_density_heuristic - np.min(demand_density_heuristic)) / (np.max(demand_density_heuristic) - np.min(demand_density_heuristic) + epsilon)\n\n    #7. Angle to Depot\n    angle_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                continue\n            vector_i = coordinates[i] - coordinates[0]\n            vector_j = coordinates[j] - coordinates[0]\n\n            # Calculate the cosine of the angle\n            cosine_angle = np.dot(vector_i, vector_j) / (np.linalg.norm(vector_i) * np.linalg.norm(vector_j) + epsilon)\n\n            # Convert cosine to angle in radians\n            angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))\n\n            angle_heuristic[i, j] = angle_heuristic[j, i] =  1- (angle / np.pi) # Normalize to [0, 1] (higher is better, smaller angle)\n\n    # Adaptive Weighting (adjust based on problem size/characteristics)\n    n_customers = n - 1\n    alpha = 0.3 #distance\n    beta = 0.15 #depot proximity\n    gamma = 0.20 #savings\n    delta = 0.15 #clustering\n    eta = 0.1 #demand density\n    phi = 0.1 #angle heuristic\n    # Adjust weights (example: emphasize depot proximity more for larger problems)\n    if n_customers > 50:\n        beta += 0.05\n        alpha -= 0.05 #reduce alpha a bit\n    if capacity < np.mean(demands) * 5: # Tighter capacity constraints, increase savings\n        gamma += 0.05\n\n    # Combine the heuristics\n    heuristics = (alpha * distance_heuristic * demand_heuristic +\n                  beta * depot_heuristic +\n                  gamma * savings_heuristic +\n                  delta * clustering_heuristic +\n                  eta * demand_density_heuristic +\n                  phi * angle_heuristic)\n\n    # 8. Sparsification (adaptive threshold based on heuristic values)\n    threshold = np.percentile(heuristics[heuristics > 0], 40) # Increased sparsity\n\n    k_nearest = 12 #consider k-nearest neighbors, increase it a bit\n\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity,\n    savings and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n\n    # Combine heuristics\n    alpha = 0.4\n    beta = 0.2\n    delta = 0.4\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + delta * savings_heuristic\n\n    # Sparsify the matrix using k-NN\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 30)\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    CVRP heuristic: Combines distance, demand, depot proximity,\n    savings and sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # Savings Heuristic\n    savings_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_heuristic[i, j] = savings\n            savings_heuristic[j, i] = savings\n\n    # Combine heuristics\n    alpha = 0.4\n    beta = 0.2\n    delta = 0.4\n\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic + delta * savings_heuristic\n\n    # Sparsify the matrix using k-NN\n    k_nearest = 10\n    threshold = np.percentile(heuristics[heuristics > 0], 30)\n    for i in range(n):\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Combines distance, demand, depot proximity, and sparsification.\n    Uses adaptive weights and k-NN sparsification.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # 1. Distance component\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # 2. Demand Feasibility\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                demand_heuristic[i,j] = 0.05\n\n    # 3. Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # Combine the heuristics with adaptive weights.\n    alpha = 0.5\n    beta = 0.5\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * depot_heuristic\n\n    # Sparsification\n    k_nearest = 10 #consider only k-nearest neighbors.\n    threshold = np.percentile(heuristics[heuristics > 0], 30)\n\n    for i in range(n):\n        # Find k-nearest neighbors\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k_nearest+1]\n\n        for j in range(n):\n            if heuristics[i, j] < threshold and j not in nearest_neighbors:\n                heuristics[i, j] = 0\n\n    # Normalize to be between 0 and 1\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle, and depot proximity with adaptive weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n    normalized_demands = demands / np.max(demands)\n    depot_x, depot_y = coordinates[0]\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0\n                continue\n\n            distance_factor = 1 / distance_matrix[i, j] if distance_matrix[i,j] > 0 else 0\n            demand_factor = 1 - normalized_demands[j]\n            if i == 0:\n                demand_factor = 1.0\n\n            i_x, i_y = coordinates[i]\n            j_x, j_y = coordinates[j]\n\n            vector_ij = np.array([j_x - i_x, j_y - i_y])\n            vector_di = np.array([i_x - depot_x, i_y - depot_y])\n\n            vector_ij = vector_ij / (np.linalg.norm(vector_ij) + 1e-9)\n            vector_di = vector_di / (np.linalg.norm(vector_di) + 1e-9)\n\n            dot_product = np.clip(np.dot(vector_ij, vector_di), -1.0, 1.0)\n            angle = np.arccos(dot_product)\n            angle_factor = 1 - (angle / np.pi)\n\n            depot_distance_i = distance_matrix[0, i]\n            depot_distance_j = distance_matrix[0, j]\n            depot_proximity_factor = 1 / (depot_distance_i + depot_distance_j + 1e-9)\n\n            #Adaptive weighting based on demand\n            demand_weight = 0.5 + 0.5 * normalized_demands[j] #increase weight for high demand nodes\n            heuristic_matrix[i, j] = distance_factor * (demand_weight * demand_factor + (1-demand_weight) * (angle_factor * depot_proximity_factor))\n\n    #Sparsification: zero out less promising edges\n    mean_heuristic = np.mean(heuristic_matrix)\n    heuristic_matrix[heuristic_matrix < 0.5 * mean_heuristic] = 0\n\n    return heuristic_matrix\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Combines distance, demand, angle, and depot proximity with adaptive weighting.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n    normalized_demands = demands / np.max(demands)\n    depot_x, depot_y = coordinates[0]\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                heuristic_matrix[i, j] = 0\n                continue\n\n            distance_factor = 1 / distance_matrix[i, j] if distance_matrix[i,j] > 0 else 0\n            demand_factor = 1 - normalized_demands[j]\n            if i == 0:\n                demand_factor = 1.0\n\n            i_x, i_y = coordinates[i]\n            j_x, j_y = coordinates[j]\n\n            vector_ij = np.array([j_x - i_x, j_y - i_y])\n            vector_di = np.array([i_x - depot_x, i_y - depot_y])\n\n            vector_ij = vector_ij / (np.linalg.norm(vector_ij) + 1e-9)\n            vector_di = vector_di / (np.linalg.norm(vector_di) + 1e-9)\n\n            dot_product = np.clip(np.dot(vector_ij, vector_di), -1.0, 1.0)\n            angle = np.arccos(dot_product)\n            angle_factor = 1 - (angle / np.pi)\n\n            depot_distance_i = distance_matrix[0, i]\n            depot_distance_j = distance_matrix[0, j]\n            depot_proximity_factor = 1 / (depot_distance_i + depot_distance_j + 1e-9)\n\n            #Adaptive weighting based on demand\n            demand_weight = 0.5 + 0.5 * normalized_demands[j] #increase weight for high demand nodes\n            heuristic_matrix[i, j] = distance_factor * (demand_weight * demand_factor + (1-demand_weight) * (angle_factor * depot_proximity_factor))\n\n    #Sparsification: zero out less promising edges\n    mean_heuristic = np.mean(heuristic_matrix)\n    heuristic_matrix[heuristic_matrix < 0.5 * mean_heuristic] = 0\n\n    return heuristic_matrix\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristics: Combines distance, demand, depot proximity, and angle prioritization.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    # Distance component (inverse relationship)\n    distance_heuristic = 1 / (distance_matrix + epsilon)\n\n    # Demand Feasibility component\n    demand_heuristic = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                demand_heuristic[i, j] = 0\n            if demands[i] + demands[j] > capacity and i == 0:\n                demand_heuristic[i, j] = 0.1\n            elif demands[i] + demands[j] > capacity and j == 0:\n                demand_heuristic[i, j] = 0.1\n            elif i != 0 and demands[i] > capacity or j != 0 and demands[j] > capacity:\n                 demand_heuristic[i,j] = 0.05\n\n    # Depot Proximity\n    depot_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        avg_distance = np.sum(distance_matrix[i, 1:]) / (n - 2) if n > 2 else distance_matrix[i,0]\n        depot_preference = (avg_distance / np.max(distance_matrix)) * (demands[i] / capacity)\n        depot_heuristic[i, 0] = depot_preference\n        depot_heuristic[0, i] = depot_preference\n\n    # Angle Prioritization\n    angle_heuristic = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                best_k = -1\n                min_dist = float('inf')\n                for k in range(1, n):\n                    if k != i and k != j:\n                        dist = distance_matrix[i, k] + distance_matrix[j, k]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_k = k\n                if best_k != -1:\n                    a = distance_matrix[i,j]\n                    b = distance_matrix[i, best_k]\n                    c = distance_matrix[j, best_k]\n                    angle = np.arccos((b**2 + c**2 - a**2) / (2 * b * c + epsilon))\n                    angle_heuristic[i,j] = 1 - (angle / np.pi)\n\n    # Sparsification\n    avg_distance = np.sum(distance_matrix) / (n * (n - 1))\n    sparsification_threshold = 2.5 * avg_distance\n    sparsification_mask = distance_matrix <= sparsification_threshold\n\n    # Combine heuristics with adaptive scaling\n    alpha = 0.4\n    beta = 0.2\n    gamma = 0.15\n    theta = 0.25\n    heuristics = alpha * distance_heuristic * demand_heuristic + beta * demand_heuristic + gamma * depot_heuristic + theta * angle_heuristic\n\n    heuristics = heuristics * sparsification_mask\n\n    max_val = np.max(heuristics)\n    if max_val > 0:\n        heuristics = heuristics / max_val\n\n    return heuristics\n\n[Heuristics 18th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines distance, demand, angle, and depot proximity with sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            dist_h = 1 / (distance_matrix[i, j] + epsilon)\n            demand_h = 1 - np.clip((demands[i] + demands[j]) / (2 * capacity + epsilon), 0, 1)\n            if i == 0 or j == 0:\n                demand_h = 1.0\n\n            angle_h = 1.0\n            if i != 0 and j != 0:\n                angle_h = 0.0\n                nn_idx = -1; dist = np.inf\n                for k in range(n):\n                    if k != i and k != j:\n                        if distance_matrix[i, k] < dist:\n                            dist = distance_matrix[i, k]\n                            nn_idx = k\n\n                if nn_idx != -1:\n                    a = distance_matrix[i, j]\n                    b = distance_matrix[i, nn_idx]\n                    c = distance_matrix[j, nn_idx]\n                    try:\n                        angle_h = (a**2 + b**2 - c**2) / (2 * a * b + epsilon)\n                        angle_h = np.clip(angle_h, -1.0, 1.0)\n                        angle_h = (angle_h + 1.0) / 2.0\n                    except:\n                        angle_h = 0.5\n\n            depot_prox_h = 1 - np.clip((distance_matrix[0, i] + distance_matrix[0, j]) / (2 * np.max(distance_matrix) + epsilon), 0, 1)\n\n            heuristics[i, j] = (\n                0.5 * dist_h +\n                0.15 * demand_h +\n                0.25 * angle_h +\n                0.1 * depot_prox_h\n            )\n\n    # Sparsify the matrix\n    threshold = np.mean(heuristics) * 0.2\n    heuristics[heuristics < threshold] = 0\n\n    return heuristics\n\n[Heuristics 19th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines distance, demand, angle, and depot proximity with sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            dist_h = 1 / (distance_matrix[i, j] + epsilon)\n            demand_h = 1 - np.clip((demands[i] + demands[j]) / (2 * capacity + epsilon), 0, 1)\n            if i == 0 or j == 0:\n                demand_h = 1.0\n\n            angle_h = 1.0\n            if i != 0 and j != 0:\n                angle_h = 0.0\n                nn_idx = -1; dist = np.inf\n                for k in range(n):\n                    if k != i and k != j:\n                        if distance_matrix[i, k] < dist:\n                            dist = distance_matrix[i, k]\n                            nn_idx = k\n\n                if nn_idx != -1:\n                    a = distance_matrix[i, j]\n                    b = distance_matrix[i, nn_idx]\n                    c = distance_matrix[j, nn_idx]\n                    try:\n                        angle_h = (a**2 + b**2 - c**2) / (2 * a * b + epsilon)\n                        angle_h = np.clip(angle_h, -1.0, 1.0)\n                        angle_h = (angle_h + 1.0) / 2.0\n                    except:\n                        angle_h = 0.5\n\n            depot_prox_h = 1 - np.clip((distance_matrix[0, i] + distance_matrix[0, j]) / (2 * np.max(distance_matrix) + epsilon), 0, 1)\n\n            heuristics[i, j] = (\n                0.5 * dist_h +\n                0.15 * demand_h +\n                0.25 * angle_h +\n                0.1 * depot_prox_h\n            )\n\n    # Sparsify the matrix\n    threshold = np.mean(heuristics) * 0.2\n    heuristics[heuristics < threshold] = 0\n\n    return heuristics\n\n[Heuristics 20th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"CVRP heuristic: Combines distance, demand, angle, and depot proximity with sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros((n, n))\n    epsilon = 1e-6\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            dist_h = 1 / (distance_matrix[i, j] + epsilon)\n            demand_h = 1 - np.clip((demands[i] + demands[j]) / (2 * capacity + epsilon), 0, 1)\n            if i == 0 or j == 0:\n                demand_h = 1.0\n\n            angle_h = 1.0\n            if i != 0 and j != 0:\n                angle_h = 0.0\n                nn_idx = -1; dist = np.inf\n                for k in range(n):\n                    if k != i and k != j:\n                        if distance_matrix[i, k] < dist:\n                            dist = distance_matrix[i, k]\n                            nn_idx = k\n\n                if nn_idx != -1:\n                    a = distance_matrix[i, j]\n                    b = distance_matrix[i, nn_idx]\n                    c = distance_matrix[j, nn_idx]\n                    try:\n                        angle_h = (a**2 + b**2 - c**2) / (2 * a * b + epsilon)\n                        angle_h = np.clip(angle_h, -1.0, 1.0)\n                        angle_h = (angle_h + 1.0) / 2.0\n                    except:\n                        angle_h = 0.5\n\n            depot_prox_h = 1 - np.clip((distance_matrix[0, i] + distance_matrix[0, j]) / (2 * np.max(distance_matrix) + epsilon), 0, 1)\n\n            heuristics[i, j] = (\n                0.5 * dist_h +\n                0.15 * demand_h +\n                0.25 * angle_h +\n                0.1 * depot_prox_h\n            )\n\n    # Sparsify the matrix\n    threshold = np.mean(heuristics) * 0.2\n    heuristics[heuristics < threshold] = 0\n\n    return heuristics\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}