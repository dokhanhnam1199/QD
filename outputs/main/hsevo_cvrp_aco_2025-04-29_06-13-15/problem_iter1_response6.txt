```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP)
    via stochastic solution sampling. This version incorporates a capacity-aware
    nearest neighbor approach with a probabilistic element.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Demand of each node (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge
                    in a solution (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Inverse distance as a base heuristic (nodes closer are more likely to be connected)
    inverse_distance = 1 / (distance_matrix + np.eye(n))  # Avoid division by zero
    np.fill_diagonal(inverse_distance, 0)

    # Capacity awareness: Penalize edges that would likely violate capacity constraints
    for i in range(n):
        for j in range(n):
            if i == j or i == 0:
                continue  # Skip depot-to-depot or self-loops

            # Heuristic penalty if adding demand of j to current tour demand
            # would push it closer to the capacity limit. We simulate tour formation
            # starting at each node. The probability declines as the likely
            # load increases toward vehicle capacity
            if demands[i] + demands[j] > capacity : #Immediate failure
                heuristic_matrix[i, j] = 0.000001 # Very low probability edge


            else:
              # Penalize edge if node j is already "close" to depot 0 by the
              # amount exceeding certain threshold
              penalty = 0
              distance_to_depot_threshold = 2 * distance_matrix.mean()
              if distance_matrix[j,0] > distance_to_depot_threshold:
                  penalty =  (distance_matrix[j,0] - distance_to_depot_threshold) /distance_matrix[j,0]

              heuristic_matrix[i, j] = inverse_distance[i, j] * np.exp(-penalty) # exponential penalty term

            # Adding random factor for exploration
            heuristic_matrix[i, j] += np.random.uniform(0, 0.1)  # Small random exploration

    # Depot connections are very valuable so enforce them unless
    # demands[i] > capacity
    for i in range(1, n): #from 1 to n-1 as depot index is 0.
        if demands[i] > capacity:
            heuristic_matrix[0, i] = 0.000001 # cannot form a trip on its own
        else:
             heuristic_matrix[0, i] = 2 * inverse_distance[0, i]
             heuristic_matrix[i, 0] = heuristic_matrix[0, i]  #Ensure symmetry of the matrix



    # Normalize to probabilities
    row_sums = heuristic_matrix.sum(axis=1, keepdims=True)
    heuristic_matrix = heuristic_matrix / (row_sums + 1e-9)  # Avoid division by zero
    return heuristic_matrix
```
