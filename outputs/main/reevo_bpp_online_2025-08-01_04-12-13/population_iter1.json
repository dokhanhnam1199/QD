[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on a Best Fit strategy.\n\n    This heuristic attempts to place the item into the bin where it fits most tightly,\n    i.e., the bin that would have the smallest non-negative remaining capacity after\n    the item is placed. This typically leads to a good packing density.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins where the item does not fit will have a very low (negative infinity) priority.\n    \"\"\"\n    # Calculate the remaining capacity if the item were to be placed in each bin.\n    # A negative value means the item does not fit in that bin.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores. Bins where the item does not fit\n    # should have an extremely low priority to ensure they are not chosen.\n    # Using -np.inf makes them effectively unselectable.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Create a boolean mask for bins where the item actually fits (remaining capacity >= 0).\n    fits_mask = remaining_after_placement >= 0\n\n    # For the bins where the item fits, assign a priority score.\n    # We want to prioritize the smallest positive 'remaining_after_placement' value.\n    # By taking the negative of 'remaining_after_placement', smaller positive values\n    # become larger negative values (closer to zero), meaning a higher priority.\n    # For example:\n    #   - If remaining_after_placement is 0.1, priority is -0.1.\n    #   - If remaining_after_placement is 0.5, priority is -0.5.\n    # Since -0.1 > -0.5, the bin with 0.1 remaining capacity after placement\n    # will have a higher priority and be preferred.\n    priorities[fits_mask] = -remaining_after_placement[fits_mask]\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Best-Fit-like strategy.\n\n    Bins that can accommodate the item are prioritized based on how little space they would have\n    remaining after the item is placed. Specifically, a smaller remaining space yields a higher\n    priority score (as this is a 'best fit' approach, aiming to leave minimal waste).\n    Bins that cannot accommodate the item are assigned a very low (negative infinity) priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to negative infinity.\n    # Bins that cannot fit the item will retain this low priority, ensuring they are not chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins currently have enough capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the remaining capacity if the item were placed.\n    # According to the Best Fit heuristic, we want to choose the bin that leaves the smallest\n    # remaining capacity (i.e., the \"snuggest\" fit).\n    remaining_after_placement = bins_remain_cap[can_fit_mask] - item\n\n    # To convert this 'minimization' goal (minimize remaining_after_placement) into a\n    # 'maximization' priority score (where a higher score is better), we negate the value.\n    # For example:\n    #   - If remaining_after_placement is 0.1, priority is -0.1.\n    #   - If remaining_after_placement is 0.5, priority is -0.5.\n    # Since -0.1 > -0.5, the bin leaving 0.1 remaining capacity will have a higher priority.\n    priorities[can_fit_mask] = -remaining_after_placement\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic implements a Best-Fit-like strategy: it prioritizes bins\n    that, after accommodating the item, would have the smallest amount of\n    remaining capacity. This aims to \"snugly\" fit the item and leave larger\n    spaces in other bins for future larger items, or to pack items densely.\n\n    Bins where the item does not fit receive a very low (negative infinity) priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the potential remaining capacity if the item were placed in each bin.\n    # A smaller positive value indicates a \"snugger\" fit.\n    potential_remaining_after_fit = bins_remain_cap - item\n\n    # Initialize all priority scores to a very low value.\n    # This ensures bins where the item does not fit are never selected.\n    priority_scores = np.full_like(bins_remain_cap, np.finfo(np.float64).min)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    valid_bins_mask = potential_remaining_after_fit >= 0\n\n    # For valid bins, the priority score is the negative of the remaining capacity.\n    # This means:\n    # - A perfect fit (0 remaining) gets a score of 0 (highest possible).\n    # - A small positive remaining capacity (e.g., 0.1) gets a score like -0.1.\n    # - A large positive remaining capacity (e.g., 0.5) gets a score like -0.5.\n    # When using np.argmax, the bin with the smallest positive `potential_remaining_after_fit`\n    # will have the score closest to zero (i.e., the highest score) and thus be selected.\n    priority_scores[valid_bins_mask] = -potential_remaining_after_fit[valid_bins_mask]\n\n    return priority_scores",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit-like strategy.\n\n    The Best Fit heuristic prioritizes placing an item into the bin that,\n    after accommodating the item, will have the smallest remaining capacity.\n    This aims to leave larger spaces available for larger items that might arrive later.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a priority of -infinity.\n    \"\"\"\n    # Initialize all priorities to a very low value (-infinity).\n    # This ensures that bins where the item cannot fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining space for the bins where the item can fit.\n    # For Best Fit, we want to minimize this remaining space.\n    remaining_space_if_fit = bins_remain_cap[can_fit_mask] - item\n\n    # To convert this minimization problem into a maximization problem (where the\n    # bin with the highest priority is chosen), we take the negative of the\n    # remaining space. A smaller positive remaining space will result in a\n    # larger (less negative) priority score.\n    # For example:\n    # - If remaining_space is 0.1, priority = -0.1\n    # - If remaining_space is 0.2, priority = -0.2\n    # Since -0.1 > -0.2, the tighter fit gets a higher priority.\n    priorities[can_fit_mask] = -remaining_space_if_fit\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a Best Fit heuristic.\n\n    The Best Fit heuristic aims to minimize the remaining space in a bin after placing an item.\n    This typically leads to tighter packing and can reduce the total number of bins used.\n    A bin with a smaller remaining capacity after placing the item will receive a higher priority score.\n    Bins where the item does not fit receive a very low (negative infinity) priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher score indicates higher priority.\n    \"\"\"\n    # Initialize priorities for all bins to a very low number (-infinity).\n    # This ensures that bins where the item cannot fit are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Only proceed if there is at least one bin where the item can fit.\n    if np.any(can_fit_mask):\n        # For the bins where the item fits, calculate the remaining space\n        # after the item is placed.\n        remaining_space_after_fit = bins_remain_cap[can_fit_mask] - item\n\n        # Best Fit strategy aims to minimize this remaining space.\n        # To convert this into a \"higher is better\" priority score, we negate\n        # the remaining space. A smaller positive remaining space (e.g., 0.05)\n        # will result in a larger (less negative) priority score (-0.05).\n        # A larger positive remaining space (e.g., 0.5) will result in a\n        # smaller (more negative) priority score (-0.5).\n        # A perfect fit (remaining_space_after_fit = 0) will yield a priority of 0,\n        # which is the highest possible priority for a fitting bin.\n        priorities[can_fit_mask] = -remaining_space_after_fit\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version implements a Best Fit (BF) strategy. It prioritizes bins\n    that, after accommodating the item, would have the least remaining capacity.\n    Bins where the item does not fit are given a very low priority.\n\n    A higher priority score means a more preferred bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the current item were placed in it.\n    # This value indicates how much space would be left after the placement.\n    potential_remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores for all bins.\n    # By default, set the score to negative infinity for bins where the item cannot fit.\n    # This ensures these bins will never be selected unless there are no other suitable options.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify bins where the item can actually fit.\n    # A bin is suitable if its remaining capacity is greater than or equal to the item size.\n    fits_mask = potential_remaining_after_placement >= 0\n\n    # For bins where the item fits, assign a priority score.\n    # The Best Fit strategy aims to minimize the remaining space in a bin.\n    # To translate this minimization into a maximization (for priority score),\n    # we take the negative of the `potential_remaining_after_placement`.\n    # This means:\n    # - A perfect fit (0 remaining capacity) gets a score of 0 (highest possible for fitting bins).\n    # - A very tight fit (small positive remaining capacity) gets a small negative score.\n    # - A loose fit (large positive remaining capacity) gets a large negative score.\n    # Thus, higher (less negative) scores indicate better, tighter fits.\n    priority_scores[fits_mask] = -potential_remaining_after_placement[fits_mask]\n\n    return priority_scores",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit heuristic with a unique scoring mechanism.\n\n    This function prioritizes bins that, after placing the item, would have the\n    smallest remaining capacity. This is known as the Best Fit heuristic,\n    which aims to leave the \"tightest\" possible fit, thereby potentially saving\n    larger gaps for future larger items.\n\n    For bins where the item fits:\n    The priority is calculated as the negative of the remaining space\n    after placing the item (`-(bin_capacity - item)`). A smaller positive\n    remaining space results in a larger (closer to zero) negative value,\n    which translates to a higher priority when selecting the maximum.\n\n    For bins where the item does not fit:\n    These bins are assigned a very low priority (negative infinity) to ensure\n    they are never selected unless no other options are available (which should\n    be handled by the packing algorithm by opening a new bin).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n    # Initialize all priorities to a very low value. This effectively marks\n    # bins where the item cannot fit as non-viable options.\n    priorities = np.full_like(bins_remain_cap, np.NINF, dtype=float)\n\n    # Create a boolean mask for bins where the item *can* fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins where the item can fit, calculate their priority score.\n    # The Best Fit strategy aims to minimize the leftover space.\n    # To translate this into a \"maximize priority\" problem, we use the\n    # negative of the leftover space: `-(bins_remain_cap - item)`.\n    #\n    # Example:\n    # Item = 0.3\n    # Bin A: capacity 0.5 -> Leftover: 0.2 -> Priority: -0.2\n    # Bin B: capacity 0.3 -> Leftover: 0.0 -> Priority:  0.0 (Perfect fit, highest priority)\n    # Bin C: capacity 0.7 -> Leftover: 0.4 -> Priority: -0.4\n    #\n    # The bin with 0.0 priority is the highest, correctly identifying the\n    # Best Fit option (or one of them, if multiple perfect fits exist).\n    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)\n\n    return priorities",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 33, in priority_v2\n    # Maximizing '-remaining_space' achieves this:\n  File \"/home/dokhanhnam1199/.local/lib/python3.10/site-packages/numpy/__init__.py\", line 400, in __getattr__\n    raise AttributeError(\nAttributeError: `np.NINF` was removed in the NumPy 2.0 release. Use `-np.inf` instead.\n6\n1\n"
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a variation of the Best Fit (BF) heuristic.\n\n    This priority function aims to find the bin that, if the item were placed,\n    would leave the least amount of remaining capacity (tightest fit).\n    Bins that cannot accommodate the item are given a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate more preferred bins.\n    \"\"\"\n    # Calculate the remaining space for each bin if the item were placed.\n    # This will be non-negative for bins that can fit the item, and negative otherwise.\n    remaining_space = bins_remain_cap - item\n\n    # Initialize all priority scores to a very low value (negative infinity).\n    # This ensures that bins which cannot fit the item are always deprioritized\n    # below any bin that can fit the item.\n    priority_scores = np.full_like(bins_remain_cap, np.finfo(np.float64).min)\n\n    # Identify bins where the item can actually fit (remaining_space is non-negative).\n    can_fit_mask = remaining_space >= 0\n\n    # For bins where the item can fit:\n    # We want to minimize the 'remaining_space' (i.e., find the tightest fit).\n    # Maximizing '-remaining_space' achieves this:\n    # - A remaining_space of 0 (perfect fit) yields a priority of 0 (highest for valid fits).\n    # - A small positive remaining_space (tight fit) yields a small negative priority (e.g., -0.1).\n    # - A large positive remaining_space (loose fit) yields a large negative priority (e.g., -0.9).\n    priority_scores[can_fit_mask] = -remaining_space[can_fit_mask]\n\n    return priority_scores",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on a\n    Best Fit Decreasing-like strategy for online Bin Packing.\n\n    This strategy prioritizes bins that, after placing the item, will have the\n    smallest remaining space. This is often effective as it attempts to \"snugly\"\n    fit items, leaving larger empty spaces for subsequent larger items.\n\n    Strategy:\n    1. Initialize priorities for all bins to a very low value (-infinity). This ensures\n       that bins where the item cannot fit are never selected.\n    2. For each bin where the item can fit, calculate the space that would remain\n       after placing the item (`remaining_space = current_bin_capacity - item_size`).\n    3. Assign a priority score to these fitting bins such that a smaller\n       `remaining_space` results in a higher priority score. This is achieved by\n       taking the negative of the `remaining_space` (`priority = -remaining_space`).\n       Maximizing `-remaining_space` is equivalent to minimizing `remaining_space`.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest priority score should be selected.\n    \"\"\"\n    # Initialize priorities to negative infinity. Bins that cannot fit the item\n    # will retain this value, ensuring they are not chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining space for bins where the item can fit\n    # This is the space that would be left if the item were placed in that bin.\n    remaining_space_if_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priority scores to the fitting bins.\n    # We want to minimize 'remaining_space_if_fit', which is equivalent to\n    # maximizing '-remaining_space_if_fit'.\n    priorities[can_fit_mask] = -remaining_space_if_fit\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This function implements a Best Fit-like heuristic.\n    It prioritizes bins that, after placing the item, will have the least remaining\n    capacity. This leads to a \"tightest fit\" strategy, which is often effective\n    in reducing the total number of bins used.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a better fit. Bins that cannot accommodate the item\n        receive a very low (negative infinity) priority.\n    \"\"\"\n    # Initialize priorities for all bins to a very low value.\n    # This ensures that bins incapable of fitting the item are not chosen\n    # if a valid option exists. Using -np.inf makes them effectively unselectable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can actually fit the current item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the remaining space if the item were placed there.\n    # In Best Fit, we want to minimize this remaining space.\n    # To turn this into a priority (where higher is better), we take the negative of the\n    # remaining space. For example:\n    # - If remaining space is 0.1, priority is -0.1\n    # - If remaining space is 0.5, priority is -0.5\n    # When selecting the maximum priority, -0.1 is preferred over -0.5,\n    # correctly identifying the bin with the least remaining space.\n    remaining_space_if_placed = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = -remaining_space_if_placed\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]