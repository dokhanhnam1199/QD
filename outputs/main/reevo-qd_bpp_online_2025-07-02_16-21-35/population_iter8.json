[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing heuristic-inspired component: prefer bins with enough space\n    # This encourages packing into bins that can accommodate the item\n    eligible_bins = bins_remain_cap >= item\n    priorities[eligible_bins] += 1  # Give a base priority to eligible bins\n    \n    # Best Fit heuristic-inspired component: prioritize bins with minimum wasted space\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Ignore bins where item doesn't fit.\n\n    min_waste = np.min(waste) #Get the minimum waste.\n    best_fit_bins = np.isclose(waste, min_waste) #Check each bin that satisfies the min_waste\n    priorities[best_fit_bins] += 2  # Give high priority to bins with minimal waste\n\n    # Capacity Utilization heuristic-inspired: Prefer using bins that are almost full\n    capacity_utilization = item / bins_remain_cap\n    capacity_utilization[~eligible_bins] = 0  # Ignore ineligible bins\n\n    priorities += capacity_utilization\n    \n    #Small adjustments to enhance performace\n\n    priorities[bins_remain_cap == 0] = -np.inf  #Never pick a bin that's already full.\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.0,
    "mi": 85.50357955339227,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Eligibility: Prefer bins with enough space\n    eligible_bins = bins_remain_cap >= item\n    priorities[eligible_bins] += 1.0  # Base priority to eligible bins\n    \n    # Wasted Space: Prioritize bins with minimum wasted space\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Ignore bins where item doesn't fit.\n    min_waste = np.min(waste)\n    best_fit_bins = np.isclose(waste, min_waste)\n    priorities[best_fit_bins] += 2.0  # Higher priority for minimal waste\n\n    # Capacity Utilization: Prefer using bins that are almost full, but only if eligible\n    capacity_utilization = item / bins_remain_cap\n    capacity_utilization[~eligible_bins] = 0  # Ignore ineligible bins\n\n    priorities += capacity_utilization\n    \n    # Avoid Full Bins: Never pick a bin that's already full.\n    priorities[bins_remain_cap == 0] = -np.inf\n    \n    # Further improvement: Add a slight preference to bins that are closer to full *after* adding the item, but only among eligible bins\n    post_fill_ratio = (bins_remain_cap[eligible_bins] - item) / bins_remain_cap[eligible_bins] if np.any(eligible_bins) else np.array([])\n    if post_fill_ratio.size > 0:\n        priorities[eligible_bins] -= np.abs(post_fill_ratio) * 0.5 # Prefer bins that become fuller after placement, but don't overemphasize\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 260.0,
    "mi": 78.02876066214223,
    "token_count": 194.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Eligibility: Prioritize bins where the item fits\n    eligible_bins = bins_remain_cap >= item\n    priorities[eligible_bins] += 1\n\n    # Waste Minimization: Prioritize bins with minimal remaining waste after placing the item\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Mark ineligible bins with infinite waste\n\n    min_waste = np.min(waste[eligible_bins]) if np.any(eligible_bins) else np.inf\n    best_fit_bins = np.isclose(waste, min_waste) & eligible_bins\n    priorities[best_fit_bins] += 3  # Increased priority for best fit\n\n    # Capacity Utilization: Incentivize filling bins close to capacity\n    capacity_utilization = item / bins_remain_cap\n    capacity_utilization[~eligible_bins] = 0\n\n    priorities += capacity_utilization\n\n    # Avoid creating full bins unless necessary: Penalty for bins becoming exactly full\n    almost_full_bins = np.isclose(waste, 0) & eligible_bins\n    priorities[almost_full_bins] -= 0.5 #Slight penalty\n        \n    # Previously full bins are invalid\n    priorities[bins_remain_cap == 0] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 225.71696739799185,
    "mi": 80.29471788234572,
    "token_count": 213.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing heuristic-inspired component: prefer bins with enough space\n    # This encourages packing into bins that can accommodate the item\n    eligible_bins = bins_remain_cap >= item\n    priorities[eligible_bins] += 1  # Give a base priority to eligible bins\n    \n    # Best Fit heuristic-inspired component: prioritize bins with minimum wasted space\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Ignore bins where item doesn't fit.\n\n    min_waste = np.min(waste) #Get the minimum waste.\n    best_fit_bins = np.isclose(waste, min_waste) #Check each bin that satisfies the min_waste\n    priorities[best_fit_bins] += 2  # Give high priority to bins with minimal waste\n\n    # Capacity Utilization heuristic-inspired: Prefer using bins that are almost full, but not too full (avoid very small remaining capacity)\n    capacity_utilization = item / bins_remain_cap\n    capacity_utilization[~eligible_bins] = 0  # Ignore ineligible bins\n\n    # Add a penalty for bins that will have very small remaining capacity after placing the item\n    nearly_full_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    nearly_full_bins = (bins_remain_cap - item) <= 0.1  #If remaining capacity is less than 0.1, penalize\n    nearly_full_penalty[nearly_full_bins & eligible_bins] = -0.5 #Slightly reduce priority\n\n    priorities += capacity_utilization + nearly_full_penalty\n    \n    #Small adjustments to enhance performance\n\n    priorities[bins_remain_cap == 0] = -np.inf  #Never pick a bin that's already full.\n\n    #Prioritize bins that have already had items placed in them, without overfilling.\n\n    already_used_bins = (bins_remain_cap < 1) & eligible_bins #Assume bin capacity is 1.  Bins less than 1 but eligible.\n    priorities[already_used_bins] += 0.75\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 189.98960215439456,
    "mi": 82.63711386323203,
    "token_count": 202.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: bins that can't fit the item get a priority of -inf\n    eligible_bins = bins_remain_cap >= item\n    priorities[~eligible_bins] = -np.inf\n\n    # Initial priority boost for eligible bins\n    priorities[eligible_bins] += 1\n\n    # Waste calculation: amount of space wasted if item is placed in the bin\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Assign infinite waste if the item doesn't fit\n\n    # Prioritize bins with smaller waste\n    min_waste = np.min(waste[eligible_bins]) if np.any(eligible_bins) else np.inf  # Get min waste among eligible bins\n    best_fit_bins = np.isclose(waste, min_waste)\n    priorities[best_fit_bins] += 3  # Higher priority for best fit\n    \n    # Capacity utilization: how much of the bin's capacity will be used\n    capacity_utilization = item / bins_remain_cap\n    capacity_utilization[~eligible_bins] = 0  # Ignore ineligible bins for utilization\n\n    # Add capacity utilization to the priority\n    priorities += capacity_utilization\n\n    # Discourage perfect fills slightly (can lead to fragmentation)\n    perfect_fit = np.isclose(waste, 0)\n    priorities[perfect_fit] -= 0.5\n\n    # Post-fill ratio: remaining capacity after placing the item, relative to the bin size\n    post_fill_ratio = (bins_remain_cap - item) / bins_remain_cap\n    post_fill_ratio[~eligible_bins] = 0  # Ignore ineligible bins\n\n    # Give slight preference to bins that will have a good post-fill ratio\n    priorities += post_fill_ratio * 0.5 #Scale the value.\n\n    # Avoid already full bins\n    priorities[bins_remain_cap == 0] = -np.inf\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 228.32510677099592,
    "mi": 82.34929898925337,
    "token_count": 206.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: bins that can't fit the item get a priority of -inf\n    eligible_bins = bins_remain_cap >= item\n    priorities[~eligible_bins] = -np.inf\n\n    # Initial priority boost for eligible bins\n    priorities[eligible_bins] += 1\n\n    # Waste calculation: amount of space wasted if item is placed in the bin\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Assign infinite waste if the item doesn't fit\n\n    # Prioritize bins with smaller waste\n    min_waste = np.min(waste[eligible_bins]) if np.any(eligible_bins) else np.inf  # Get min waste among eligible bins\n    best_fit_bins = np.isclose(waste, min_waste)\n    priorities[best_fit_bins] += 3  # Higher priority for best fit\n\n    # Capacity utilization: how much of the bin's capacity will be used\n    capacity_utilization = item / bins_remain_cap\n    capacity_utilization[~eligible_bins] = 0  # Ignore ineligible bins for utilization\n\n    # Add capacity utilization to the priority, scaling it to avoid dominating other factors\n    priorities += capacity_utilization * 2\n\n    # Discourage perfect fills slightly (can lead to fragmentation)\n    perfect_fit = np.isclose(waste, 0)\n    priorities[perfect_fit] -= 0.75\n\n    # Post-fill ratio: remaining capacity after placing the item, relative to the bin size\n    post_fill_ratio = (bins_remain_cap - item) / bins_remain_cap\n    post_fill_ratio[~eligible_bins] = 0  # Ignore ineligible bins\n\n    # Give slight preference to bins that will have a good post-fill ratio, scaling it\n    priorities += post_fill_ratio * 1.0\n\n    # Avoid already full bins\n    priorities[bins_remain_cap == 0] = -np.inf\n\n    # Slightly prefer bins with higher remaining capacity to group smaller items together later.\n    priorities += bins_remain_cap / np.max(bins_remain_cap) * 0.2 if np.max(bins_remain_cap) > 0 else 0\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 22.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 322.841223638941,
    "mi": 72.65718442904281,
    "token_count": 263.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: ensure the item fits\n    eligible_bins = bins_remain_cap >= item\n\n    # Initialize priorities for ineligible bins to negative infinity\n    priorities[~eligible_bins] = -np.inf\n\n    # First Fit Decreasing influence: reward bins that can accommodate the item\n    priorities[eligible_bins] += 1\n\n    # Best Fit influence: minimize wasted space, but with adjustments\n    waste = bins_remain_cap - item\n    waste[~eligible_bins] = np.inf  # Ignore bins where item doesn't fit.\n\n    min_waste = np.min(waste)\n    best_fit_bins = np.isclose(waste, min_waste)\n    priorities[best_fit_bins] += 3  # Higher priority to best fit\n\n    # Capacity utilization: encourage packing into bins close to full, but penalize near-perfect fills\n    capacity_utilization = item / bins_remain_cap\n    capacity_utilization[~eligible_bins] = 0  # Ignore ineligible bins\n\n    priorities += capacity_utilization\n\n    # Fragmentation avoidance: penalize bins that will be left with small remaining capacity *after* packing\n    remaining_after_pack = bins_remain_cap - item\n    small_remaining = (remaining_after_pack > 0) & (remaining_after_pack <= 0.2)  # e.g., <= 20% of bin size\n    priorities[small_remaining] -= 1  # Small penalty\n\n    # Discourage perfect fills unless there is no better choice.\n    perfect_fill = np.isclose(remaining_after_pack, 0)\n    if np.any(priorities > -np.inf) and np.any(perfect_fill) and not np.all(perfect_fill):\n        priorities[perfect_fill] -= 0.5 # slightly reduce priority, but still viable if no other choice\n\n    # Never pick a bin that's already full.\n    priorities[bins_remain_cap == 0] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 230.62385799360038,
    "mi": 80.58210068989591,
    "token_count": 208.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: bins that can't fit the item get a priority of -inf\n    eligible_bins = bins_remain_cap >= item\n    priorities[~eligible_bins] = -np.inf\n\n    # Initial priority boost for eligible bins\n    priorities[eligible_bins] += 1\n\n    # Waste calculation: amount of space wasted if item is placed in the bin\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Assign infinite waste if the item doesn't fit\n\n    # Prioritize bins with smaller waste\n    min_waste = np.min(waste[eligible_bins]) if np.any(eligible_bins) else np.inf  # Get min waste among eligible bins\n    best_fit_bins = np.isclose(waste, min_waste)\n    priorities[best_fit_bins] += 3  # Higher priority for best fit\n\n    # Capacity utilization: how much of the bin's capacity will be used\n    capacity_utilization = item / bins_remain_cap\n    capacity_utilization[~eligible_bins] = 0  # Ignore ineligible bins for utilization\n\n    # Add capacity utilization to the priority, scaling it to avoid dominating other factors\n    priorities += capacity_utilization * 2\n\n    # Discourage perfect fills slightly (can lead to fragmentation)\n    perfect_fit = np.isclose(waste, 0)\n    priorities[perfect_fit] -= 0.75\n\n    # Post-fill ratio: remaining capacity after placing the item, relative to the bin size\n    post_fill_ratio = (bins_remain_cap - item) / bins_remain_cap\n    post_fill_ratio[~eligible_bins] = 0  # Ignore ineligible bins\n\n    # Give slight preference to bins that will have a good post-fill ratio, scaling it\n    priorities += post_fill_ratio * 1.0\n\n    # Avoid already full bins\n    priorities[bins_remain_cap == 0] = -np.inf\n\n    # Slightly prefer bins with higher remaining capacity to group smaller items together later.\n    priorities += bins_remain_cap / np.max(bins_remain_cap) * 0.2 if np.max(bins_remain_cap) > 0 else 0\n\n    # Introduce a bin count penalty: Prefer using existing bins before opening new ones.\n    # This is done by penalizing bins with capacity close to the original bin capacity.\n    bin_size = np.max(bins_remain_cap)  # Assuming all bins have the same initial capacity.\n    if bin_size > 0:\n        new_bin_threshold = 0.95 * bin_size  # Define a threshold for considering a bin \"new\".\n        new_bin_penalty = -0.5  # Define the penalty for \"new\" bins.\n        new_bins = bins_remain_cap >= new_bin_threshold\n        priorities[new_bins] += new_bin_penalty\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 302.14829520647913,
    "mi": 79.49164726096986,
    "token_count": 231.0,
    "exec_success": true
  }
]