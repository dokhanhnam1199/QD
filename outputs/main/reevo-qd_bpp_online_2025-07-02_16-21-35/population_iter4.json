[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing heuristic-inspired component: prefer bins with enough space\n    # This encourages packing into bins that can accommodate the item\n    eligible_bins = bins_remain_cap >= item\n    priorities[eligible_bins] += 1  # Give a base priority to eligible bins\n    \n    # Best Fit heuristic-inspired component: prioritize bins with minimum wasted space\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Ignore bins where item doesn't fit.\n\n    min_waste = np.min(waste) #Get the minimum waste.\n    best_fit_bins = np.isclose(waste, min_waste) #Check each bin that satisfies the min_waste\n    priorities[best_fit_bins] += 2  # Give high priority to bins with minimal waste\n\n    # Capacity Utilization heuristic-inspired: Prefer using bins that are almost full\n    capacity_utilization = item / bins_remain_cap\n    capacity_utilization[~eligible_bins] = 0  # Ignore ineligible bins\n\n    priorities += capacity_utilization\n    \n    #Small adjustments to enhance performace\n\n    priorities[bins_remain_cap == 0] = -np.inf  #Never pick a bin that's already full.\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.0,
    "mi": 85.50357955339227,
    "token_count": 100.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Eligibility: Prefer bins with enough space\n    eligible_bins = bins_remain_cap >= item\n    priorities[eligible_bins] += 1.0  # Base priority to eligible bins\n    \n    # Wasted Space: Prioritize bins with minimum wasted space\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Ignore bins where item doesn't fit.\n    min_waste = np.min(waste)\n    best_fit_bins = np.isclose(waste, min_waste)\n    priorities[best_fit_bins] += 2.0  # Higher priority for minimal waste\n\n    # Capacity Utilization: Prefer using bins that are almost full, but only if eligible\n    capacity_utilization = item / bins_remain_cap\n    capacity_utilization[~eligible_bins] = 0  # Ignore ineligible bins\n\n    priorities += capacity_utilization\n    \n    # Avoid Full Bins: Never pick a bin that's already full.\n    priorities[bins_remain_cap == 0] = -np.inf\n    \n    # Further improvement: Add a slight preference to bins that are closer to full *after* adding the item, but only among eligible bins\n    post_fill_ratio = (bins_remain_cap[eligible_bins] - item) / bins_remain_cap[eligible_bins] if np.any(eligible_bins) else np.array([])\n    if post_fill_ratio.size > 0:\n        priorities[eligible_bins] -= np.abs(post_fill_ratio) * 0.5 # Prefer bins that become fuller after placement, but don't overemphasize\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 260.0,
    "mi": 78.02876066214223,
    "token_count": 194.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Eligibility: Prioritize bins where the item fits\n    eligible_bins = bins_remain_cap >= item\n    priorities[eligible_bins] += 1\n\n    # Waste Minimization: Prioritize bins with minimal remaining waste after placing the item\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Mark ineligible bins with infinite waste\n\n    min_waste = np.min(waste[eligible_bins]) if np.any(eligible_bins) else np.inf\n    best_fit_bins = np.isclose(waste, min_waste) & eligible_bins\n    priorities[best_fit_bins] += 3  # Increased priority for best fit\n\n    # Capacity Utilization: Incentivize filling bins close to capacity\n    capacity_utilization = item / bins_remain_cap\n    capacity_utilization[~eligible_bins] = 0\n\n    priorities += capacity_utilization\n\n    # Avoid creating full bins unless necessary: Penalty for bins becoming exactly full\n    almost_full_bins = np.isclose(waste, 0) & eligible_bins\n    priorities[almost_full_bins] -= 0.5 #Slight penalty\n        \n    # Previously full bins are invalid\n    priorities[bins_remain_cap == 0] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 225.71696739799185,
    "mi": 80.29471788234572,
    "token_count": 213.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing heuristic-inspired component: prefer bins with enough space\n    # This encourages packing into bins that can accommodate the item\n    eligible_bins = bins_remain_cap >= item\n    priorities[eligible_bins] += 1  # Give a base priority to eligible bins\n    \n    # Best Fit heuristic-inspired component: prioritize bins with minimum wasted space\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Ignore bins where item doesn't fit.\n\n    min_waste = np.min(waste) #Get the minimum waste.\n    best_fit_bins = np.isclose(waste, min_waste) #Check each bin that satisfies the min_waste\n    priorities[best_fit_bins] += 2  # Give high priority to bins with minimal waste\n\n    # Capacity Utilization heuristic-inspired: Prefer using bins that are almost full, but not too full (avoid very small remaining capacity)\n    capacity_utilization = item / bins_remain_cap\n    capacity_utilization[~eligible_bins] = 0  # Ignore ineligible bins\n\n    # Add a penalty for bins that will have very small remaining capacity after placing the item\n    nearly_full_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    nearly_full_bins = (bins_remain_cap - item) <= 0.1  #If remaining capacity is less than 0.1, penalize\n    nearly_full_penalty[nearly_full_bins & eligible_bins] = -0.5 #Slightly reduce priority\n\n    priorities += capacity_utilization + nearly_full_penalty\n    \n    #Small adjustments to enhance performance\n\n    priorities[bins_remain_cap == 0] = -np.inf  #Never pick a bin that's already full.\n\n    #Prioritize bins that have already had items placed in them, without overfilling.\n\n    already_used_bins = (bins_remain_cap < 1) & eligible_bins #Assume bin capacity is 1.  Bins less than 1 but eligible.\n    priorities[already_used_bins] += 0.75\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 189.98960215439456,
    "mi": 82.63711386323203,
    "token_count": 202.0,
    "exec_success": true
  }
]