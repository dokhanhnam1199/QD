```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # First-Fit Decreasing heuristic-inspired component:
    # Prioritize bins that can fit the item with minimal wasted space.
    fit_mask = bins_remain_cap >= item
    if np.any(fit_mask):
        waste = bins_remain_cap[fit_mask] - item
        priorities[fit_mask] = 1 / (waste + 0.0001)  # Avoid division by zero
    else:
        #If no bin can fit the item, assign negative priority for future consideration (rare scenario). Large negative value
        priorities = -1000*np.ones_like(bins_remain_cap, dtype=float) # or a proportional cost based on overflow perhaps? This part is subtle.
        return priorities


    # Best-Fit heuristic-inspired component:
    # Further refine the priorities based on how well the item "fits" relative to capacity.
    ratios = item / bins_remain_cap
    priorities = priorities * (1 - np.abs(ratios - 0.75))  # Prioritize ratios closer to 0.75 to better distribute load. Can be tuned.

    # Small remaining capacity bonus to encourage complete packing:
    small_cap_bonus_mask = (bins_remain_cap > item) & (bins_remain_cap < 1.25*item) #Arbitrary value of 1.25 can be optimized based on bin size and item sizes in problem set.
    priorities[small_cap_bonus_mask] += 0.5  # Bonus to complete filling a near full bin
    return priorities
```
