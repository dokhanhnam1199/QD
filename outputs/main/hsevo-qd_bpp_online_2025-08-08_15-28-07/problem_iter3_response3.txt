```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    available_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if not np.any(available_bins_mask):
        return priorities

    available_bins_cap = bins_remain_cap[available_bins_mask]

    # Heuristic: Prioritize bins that leave the least remaining space after packing,
    # but also consider bins that have a lot of remaining space as a secondary factor.
    # This aims to reduce fragmentation while keeping larger bins open for larger items.

    # Calculate a "tightness" score: inverse of remaining capacity
    tightness_scores = 1.0 / (available_bins_cap - item + 1e-9)

    # Calculate a "generosity" score: proportional to remaining capacity
    # We normalize this to avoid it dominating the tightness score too much
    max_cap = np.max(bins_remain_cap) # Consider the maximum capacity of any bin
    generosity_scores = available_bins_cap / (max_cap + 1e-9)

    # Combine scores. A simple weighted sum.
    # We want to give more weight to tightness (fitting snugly)
    # but also reward larger available capacity to avoid filling up too quickly.
    # The weights (0.7 for tightness, 0.3 for generosity) can be tuned.
    combined_scores = 0.7 * tightness_scores + 0.3 * generosity_scores

    priorities[available_bins_mask] = combined_scores

    return priorities
```
