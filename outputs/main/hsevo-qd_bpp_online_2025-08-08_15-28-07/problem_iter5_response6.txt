```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines "Best Fit" (tightest fit) with a slight penalty for extremely tight fits.
    This aims to minimize waste while avoiding bins that are *too* full, potentially leaving more options.
    """
    available_bins_mask = bins_remain_cap >= item
    
    if not np.any(available_bins_mask):
        return np.zeros_like(bins_remain_cap)

    priorities = np.zeros_like(bins_remain_cap)
    
    available_bins_cap = bins_remain_cap[available_bins_mask]
    
    # Heuristic: Prioritize bins that are a "tight fit" but slightly penalize
    # those that would leave *very* little space. This is a modification of
    # Best Fit, inspired by some attempts to avoid overly constrained bins.
    # We use the ratio of bin capacity to the space left after packing,
    # plus a small penalty related to the item size.
    
    # Calculate the space remaining after packing for available bins.
    remaining_space = available_bins_cap - item
    
    # Introduce a smoothing factor to slightly reduce priority for very tight fits.
    # This factor is proportional to the item size. A larger item might warrant
    # a slightly larger buffer. `0.15 * item` means we add 15% of the item size
    # to the remaining space in the denominator.
    smoothing_factor = 0.15 * item 
    
    # The denominator is `remaining_space + smoothing_factor`.
    # This means if `remaining_space` is very small, the `smoothing_factor`
    # has a larger relative impact, reducing the overall priority compared to a pure "Best Fit".
    # We add a small epsilon for numerical stability.
    denominator = remaining_space + smoothing_factor + 1e-9
    
    # The priority is `available_bins_cap / denominator`.
    # This metric rewards larger bins (numerator) but also penalizes very small `denominator`,
    # which corresponds to `remaining_space` being small. The smoothing factor moderates
    # the preference for the absolute tightest fits.
    priorities_for_available = available_bins_cap / denominator
    
    # Assign the calculated priorities back to the original structure.
    priorities[available_bins_mask] = priorities_for_available
    
    return priorities
```
