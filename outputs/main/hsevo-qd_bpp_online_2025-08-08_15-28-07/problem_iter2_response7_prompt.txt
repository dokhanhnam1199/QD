{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    # Calculate the remaining capacity after adding the item for fitting bins\n    remaining_caps_after_fit = bins_remain_cap[can_fit_mask] - item\n    \n    # The priority is higher for bins that will be almost full after adding the item\n    # A small positive value is added to ensure that fitting bins have higher priority than non-fitting bins.\n    # The degree of \"almost full\" is inversely proportional to the remaining capacity.\n    # A smaller remaining capacity leads to a higher priority.\n    priorities[can_fit_mask] = 1.0 / (remaining_caps_after_fit + 1e-6) # Add epsilon to avoid division by zero\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n### Analyze & experience\n- Comparing Heuristic 1 (inverse distances) with Heuristic 2 (sigmoid with weighted sum), Heuristic 1 is simpler and directly targets bins that provide a tight fit by using the inverse ratio of capacities. Heuristic 2 attempts to balance tightness and overall capacity using a sigmoid, but its complexity might not translate to better performance without careful tuning of weights and scaling factors.\n\nComparing Heuristic 3-8 (\"Almost Full Fit\" using `1.0 / (remaining_caps_after_fit + epsilon)`) with Heuristic 9 (Best Fit using `-remaining_capacity`), Heuristics 3-8 directly implement the \"Almost Full Fit\" by prioritizing bins that leave minimal space after placement. Heuristic 9 is a cleaner Best Fit implementation by directly minimizing the negative remaining capacity. The repeated \"Almost Full Fit\" heuristics (3-8) suggest a strong focus on minimizing residual space, which is a core aspect of efficient bin packing.\n\nComparing Heuristic 10 (multiplicative combination for \"Almost Full Fit\") with Heuristic 3-8, Heuristic 10 attempts to combine tight fit (`1/fits`) with initial bin fullness (`item/bins_remain_cap`), which might offer a more nuanced \"Almost Full\" strategy. However, the simpler inverse of `fits` (as in 3-8) is a more direct interpretation of minimizing residual space.\n\nComparing Heuristic 19 and 20 (Sigmoid Fit Score with peak around ideal ratio) with others, these heuristics try to find a balance between not too full and not too empty bins using a sigmoid function to model preference. They are more complex than direct \"tightest fit\" heuristics but aim to optimize for a specific packing characteristic. Heuristic 19/20's approach of creating a peak around an ideal ratio is a sophisticated way to model \"good fit\" using sigmoids.\n\nHeuristics 14-18 (all zeros) are clearly the worst as they provide no discriminatory priority. Heuristics 11-13 (Epsilon-Greedy) add an exploration component to a Best Fit strategy, which is more applicable in learning scenarios than for deterministic heuristic design.\n\nOverall: Heuristics that directly target minimizing residual space (like \"Almost Full Fit\" or \"Best Fit\") appear to be generally strong. Complexity increases with sigmoid-based approaches, which might offer benefits if tuned correctly but can also introduce fragility. Simple, direct mappings often perform well.\n- \nHere's a redefined approach to self-reflection for heuristic design:\n\n*   **Keywords:** Goal-oriented, iterative, context-aware, measurable impact.\n*   **Advice:** Focus on achieving the heuristic's core objective, not just superficial characteristics. Measure performance against defined goals, not just against \"tight fit.\"\n*   **Avoid:** Over-emphasis on simplicity at the expense of effectiveness. Assuming \"tight fit\" automatically equates to good performance.\n*   **Explanation:** True effectiveness comes from solving the problem. Continuously test and refine based on actual outcomes, adapting the heuristic to the specific problem context.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}