```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap)
    
    # Favors bins that can fit the item exactly
    exact_fit_mask = bins_remain_cap == item
    priorities[exact_fit_mask] = 1.0
    
    # Favors bins with minimal remaining capacity after fitting the item, 
    # but only if they can fit the item
    fit_mask = bins_remain_cap >= item
    if np.any(fit_mask & ~exact_fit_mask):
        remaining_capacities_after_fit = bins_remain_cap[fit_mask & ~exact_fit_mask] - item
        min_remaining_capacity = np.min(remaining_capacities_after_fit)
        
        # Assign higher priority to bins with less wasted space
        priorities[fit_mask & ~exact_fit_mask] = 1.0 - (remaining_capacities_after_fit - min_remaining_capacity) / (bins_remain_cap[fit_mask & ~exact_fit_mask].max() - item)
        
    # Penalize bins that cannot fit the item
    priorities[~fit_mask] = -np.inf 
    
    # Normalize priorities to be between 0 and 1, ensuring exact fits are highest
    valid_priorities = priorities[np.isfinite(priorities)]
    if len(valid_priorities) > 0:
        min_p, max_p = np.min(valid_priorities), np.max(valid_priorities)
        if max_p > min_p:
            priorities[np.isfinite(priorities)] = (priorities[np.isfinite(priorities)] - min_p) / (max_p - min_p)
        else:
            priorities[np.isfinite(priorities)] = 0.5 # All bins have same priority if no difference

    return priorities
```
