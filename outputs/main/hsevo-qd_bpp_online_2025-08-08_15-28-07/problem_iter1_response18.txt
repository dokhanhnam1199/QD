```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Epsilon-Greedy."""
    epsilon = 0.2  # Exploration rate
    n_bins = len(bins_remain_cap)
    priorities = np.zeros(n_bins)

    # Greedy choice: Find bins that can fit the item
    suitable_bins_indices = np.where(bins_remain_cap >= item)[0]

    if len(suitable_bins_indices) > 0:
        # Calculate preference for suitable bins
        # Prioritize bins that leave less remaining space after packing (Best Fit heuristic)
        remaining_capacities_after_packing = bins_remain_cap[suitable_bins_indices] - item
        # Higher priority for smaller remaining capacity
        preferences = 1 / (1 + remaining_capacities_after_packing)
        
        # Normalize preferences to sum to 1 for probability distribution
        if np.sum(preferences) > 0:
            probabilities = preferences / np.sum(preferences)
        else:
            probabilities = np.ones(len(suitable_bins_indices)) / len(suitable_bins_indices)

        # Epsilon-Greedy: With probability epsilon, choose a random suitable bin
        if np.random.rand() < epsilon:
            random_index = np.random.choice(len(suitable_bins_indices))
            priorities[suitable_bins_indices[random_index]] = 1.0
        else:
            # With probability 1-epsilon, choose the bin with the highest preference
            best_fit_index_in_suitable = np.argmax(preferences)
            priorities[suitable_bins_indices[best_fit_index_in_suitable]] = 1.0
    else:
        # If no bin can fit the item, we can't assign a priority in this context
        # (or we might consider creating a new bin, but that's outside this function's scope)
        pass

    return priorities
```
