```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best Fit and a Sigmoid-based preference for near-optimal residual capacity."""
    
    # Calculate priorities based on Best Fit: prioritize bins that leave minimal remaining capacity.
    # Use negative remaining capacity to ensure higher values for smaller remaining capacities.
    best_fit_scores = -bins_remain_cap

    # Identify bins that can fit the item.
    can_fit_mask = bins_remain_cap >= item
    
    # For bins that can fit, calculate a secondary score using a sigmoid function.
    # This sigmoid favors bins where remaining capacity is close to the item size (but slightly larger).
    # We want a peak around remaining_capacity = item * ideal_factor.
    ideal_factor = 1.1  # Prefer bins leaving ~10% of item size as residual capacity
    k_steepness = 6.0   # Controls the sharpness of the preference peak

    # Calculate the ratio of remaining capacity to item size.
    # Use a small epsilon to avoid division by zero if item is negligible.
    ratios = np.where(item > 1e-9, bins_remain_cap / item, 1.0)

    # Sigmoid 1: Increases as ratio increases (favors less full bins).
    # Peaks when ratio > ideal_factor.
    sigmoid1 = 1 / (1 + np.exp(-k_steepness * (ratios - ideal_factor)))

    # Sigmoid 2: Decreases as ratio increases (favors more full bins).
    # Peaks when ratio < ideal_factor.
    sigmoid2 = 1 / (1 + np.exp(k_steepness * (ratios - ideal_factor)))

    # Combine sigmoids to create a peak preference around ideal_factor.
    # This score is high for bins that are neither too empty nor too full.
    sigmoid_scores = sigmoid1 * sigmoid2

    # Initialize priorities to zero.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Apply the combined scores only to bins that can fit the item.
    # We want to combine the "best fit" tendency with the "ideal residual capacity" preference.
    # A simple multiplicative approach can work:
    # A bin is good if it's a good fit (high best_fit_scores) AND it has an ideal residual capacity (high sigmoid_scores).
    # However, best_fit_scores are negative, so a simple multiplication might not be intuitive.
    
    # Let's prioritize based on the sigmoid score for bins that can fit,
    # and use best-fit as a tie-breaker or as the primary driver.
    # A common approach is to add a scaled sigmoid score to the best-fit score.
    # We scale the sigmoid scores to influence the best-fit score without overwhelming it.
    # The sigmoid scores are in [0, 0.25] (peak value of sigmoid1*sigmoid2 is at ratio=ideal_factor, which is 0.5*0.5=0.25).
    # Scaling it by a factor, e.g., 10, would make it comparable to best-fit scores.

    # Scale sigmoid scores to have a significant impact
    scaled_sigmoid_scores = sigmoid_scores * 10.0 

    # Combine the two scores. Bins that can fit get a combined score.
    # Best fit is still the primary driver (negative values means smaller remaining space is better).
    # The sigmoid score adds a bonus for being "just right".
    priorities[can_fit_mask] = best_fit_scores[can_fit_mask] + scaled_sigmoid_scores[can_fit_mask]

    # Ensure bins that cannot fit have zero priority.
    priorities[~can_fit_mask] = -np.inf # Assign a very low priority to bins that cannot fit

    return priorities
```
