```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins by favoring tight fits and initially fuller bins."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item
    
    fits = bins_remain_cap[can_fit_mask] - item
    initial_rem_caps = bins_remain_cap[can_fit_mask]

    # Primary score: Inverse of remaining capacity after item placement (tightest fit)
    # Maximizes the "fullness" achieved by placing the item.
    tight_fit_score = 1.0 / (fits + 1e-9)
    
    # Secondary score: Inverse of initial remaining capacity (prefers fuller bins)
    # Adds a bonus for bins that were already less empty.
    initial_fill_score = 1.0 / (initial_rem_caps + 1e-9)
    
    # Combine scores multiplicatively: rewards bins that are both tight-fitting and initially fuller.
    # This aims to find a balance for "Almost Full Fit".
    priorities[can_fit_mask] = tight_fit_score * initial_fill_score
    
    return priorities
```
