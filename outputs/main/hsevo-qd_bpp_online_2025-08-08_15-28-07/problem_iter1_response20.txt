```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a First Fit approach modified for priority.

    The priority is set to 1 for bins that can accommodate the item, and 0 otherwise.
    This heuristic aims to place the item in the first available bin that fits it.
    To align with the "highest priority score is selected" logic, we can conceptualize
    that any bin that can fit the item has a higher priority than a bin that cannot.
    Among the bins that can fit the item, the "first fit" selection will implicitly happen
    if the downstream logic iterates through the priorities from left to right.
    Alternatively, to make the "first fit" more explicit in the priority itself,
    we could assign a decreasing priority to bins that can fit the item. For this
    implementation, we'll assign a high priority (1) to all fitting bins and a low
    priority (0) to non-fitting bins, assuming the selection mechanism iterates.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.where(bins_remain_cap >= item, 1, 0)
    return priorities
```
