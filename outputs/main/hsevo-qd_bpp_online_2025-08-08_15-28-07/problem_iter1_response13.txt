```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # Calculate the "tightness" of the fit for each bin
    # A smaller remaining capacity after placing the item means a "tighter" fit
    fits = bins_remain_cap - item
    
    # We want to prioritize bins that are "almost full"
    # This means bins with a small positive remaining capacity after fitting the item
    # Bins where the item doesn't fit (fits < 0) should have a low priority.
    
    # Assign a high priority to bins that can fit the item (fits >= 0)
    # The priority is inversely proportional to the remaining capacity after fitting.
    # To avoid division by zero or very small numbers, we can add a small epsilon.
    epsilon = 1e-9
    
    # Only consider bins that have enough capacity for the item
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate priorities for bins that can fit the item
    # A larger priority score indicates a preferred bin.
    # We want bins with the smallest positive 'fits'.
    # So, we can use 1 / (fits + epsilon) for bins where fits >= 0.
    # For bins where fits < 0, the priority is 0.
    
    priorities[can_fit_mask] = 1.0 / (fits[can_fit_mask] + epsilon)
    
    # To further refine, let's ensure that bins that leave *more* remaining capacity
    # have a lower priority among the "almost full" bins.
    # The current `1 / (fits + epsilon)` already does this: a larger `fits` means
    # a smaller `1 / (fits + epsilon)`.

    # Let's consider a threshold to distinguish "almost full" from "sufficiently empty".
    # A common heuristic is to prioritize bins that would be "almost full" after placement.
    # If the remaining capacity after placing the item (fits) is below a certain threshold,
    # we give it a higher priority.
    
    # Let's define "almost full" as leaving less than, say, 10% of the bin's original capacity free.
    # This threshold is relative to the bin's original capacity, which we don't have here directly.
    # A simpler approach is to consider a small absolute remaining capacity.
    # Or, we can consider the ratio of remaining capacity to item size.
    
    # Let's stick to the "tightest fit" concept for simplicity within the "Almost Full Fit" idea.
    # The inverse of remaining capacity after placement captures this.
    
    # Consider a scenario where we want to distinguish between bins that become very empty
    # vs. bins that become moderately empty.
    # The current `1.0 / (fits[can_fit_mask] + epsilon)` assigns higher priority to smaller `fits`.
    
    # To implement "Almost Full Fit" more explicitly, we can penalize bins that become too empty.
    # If `fits[i]` is large, it means the bin is left very empty.
    # We want to favor bins where `fits[i]` is small but positive.
    
    # Let's adjust the priority to give a boost to bins that are *closer* to being full.
    # The `1.0 / (fits[can_fit_mask] + epsilon)` already does this.
    
    # Alternative approach: Prioritize bins based on how much capacity *remains*.
    # The "Almost Full Fit" strategy suggests that we prefer to put an item into a bin
    # such that the remaining capacity is minimized, but the item still fits.
    # This means we want to minimize `bins_remain_cap[i] - item`.
    # Therefore, bins with smaller `bins_remain_cap[i] - item` should have higher priority.
    # The inverse `1 / (bins_remain_cap[i] - item)` achieves this.
    
    # Let's ensure bins that are already very full (small `bins_remain_cap`) but can fit the item
    # get a high priority if they leave a small remainder.
    
    # The current `priorities[can_fit_mask] = 1.0 / (fits[can_fit_mask] + epsilon)` directly implements
    # favoring the tightest fit among those that can accommodate the item. This is a core aspect
    # of "Almost Full Fit".
    
    # To make it more "almost full" specific, we could perhaps add a bonus for bins whose
    # original capacity (if we knew it) was already somewhat occupied. But we only have remaining capacity.
    
    # Let's refine the priority: High priority for tight fits.
    # If a bin has `bins_remain_cap[i] = 5` and item is `3`, `fits = 2`. Priority `1/2`.
    # If a bin has `bins_remain_cap[i] = 10` and item is `3`, `fits = 7`. Priority `1/7`.
    # This correctly prioritizes the bin that becomes "more full" or "less empty".
    
    # What if we also want to prioritize bins that are already relatively full *before* the item is placed?
    # This is implicit if the remaining capacity is small.
    
    # Let's consider a slightly different metric. Maybe a bonus for being "close" to full.
    # How to define "close"?
    # If `bins_remain_cap[i]` is small, the bin is already somewhat full.
    
    # Let's try a two-part heuristic:
    # 1. Prioritize bins that are "almost full" by looking at their current `bins_remain_cap`.
    # 2. Among those, pick the tightest fit.
    
    # Heuristic idea: Priority = (small_remaining_capacity) + (tight_fit_score)
    
    # Let's define a penalty for bins that are very empty.
    # For `bins_remain_cap[i] >= item`:
    # Priority contribution from being "almost full": maybe `1 / (bins_remain_cap[i] + epsilon)`
    # Priority contribution from "tight fit": `1 / (bins_remain_cap[i] - item + epsilon)`
    
    # If we simply prioritize the tightest fit, `1.0 / (fits[can_fit_mask] + epsilon)` is good.
    # This means if an item is 5:
    # Bin A: remaining cap 10, fits 5. Priority = 1/5
    # Bin B: remaining cap 7, fits 2. Priority = 1/2
    # Bin C: remaining cap 4, cannot fit. Priority = 0
    # Bin D: remaining cap 6, fits 1. Priority = 1/1
    # Bin E: remaining cap 12, fits 7. Priority = 1/7
    # Order of preference: D, B, A, E. This seems reasonable for "tightest fit".
    
    # For "Almost Full Fit", maybe we want to emphasize bins that *remain* very full.
    # So, a bin with remaining capacity `r` after placement contributes `1/r` to priority.
    # What if we also consider the initial state?
    # Bin X: initial rem cap 10, item 7, fits 3. Initial rel cap 10/TOTAL_CAP. Final rel cap 3/TOTAL_CAP.
    # Bin Y: initial rem cap 20, item 7, fits 13. Initial rel cap 20/TOTAL_CAP. Final rel cap 13/TOTAL_CAP.
    
    # Let's reconsider the "Almost Full" aspect. It's about the state *after* packing.
    # A bin is "almost full" if its remaining capacity is small.
    # The most "almost full" state is achieved when the item *just fits*, i.e., `bins_remain_cap[i] - item` is minimal and non-negative.
    
    # A common way to implement "Almost Full Fit" is to maximize the probability of a bin becoming full.
    # This means minimizing the remaining capacity after placing the item.
    
    # Let's think about what would make a bin *less* desirable.
    # 1. Not having enough capacity for the item.
    # 2. Having a lot of remaining capacity after placing the item (i.e., becoming very empty).
    
    # So, we want bins with `bins_remain_cap[i] >= item` and `bins_remain_cap[i] - item` as small as possible.
    # This is precisely what `1.0 / (fits[can_fit_mask] + epsilon)` does.
    
    # However, to be "Almost Full", perhaps we should also give some preference based on the *original* remaining capacity.
    # If we have two bins that yield the same `fits` value, which one do we prefer?
    # E.g., Item 3.
    # Bin 1: remaining 10, fits 7. Priority 1/7
    # Bin 2: remaining 20, fits 17. Priority 1/17.
    # Bin 1 is preferred. This is correct.
    
    # What if the problem intends to bias towards bins that were *already* closer to full?
    # If we consider two bins that both fit the item and result in the same remaining capacity `r`.
    # Bin A: initial remaining cap `r + item`.
    # Bin B: initial remaining cap `r + item`.
    # In this case, the current priority function would give them the same score.
    
    # To incorporate "Almost Full" more distinctly, let's introduce a term that rewards smaller *initial* remaining capacities, but only if the item fits.
    
    # Priority = (tightness_score) * (initial_fill_score)
    # Tightness score: `1 / (fits + epsilon)`
    # Initial fill score: A measure of how full the bin was initially.
    # This can be `1 / (bins_remain_cap[i] + epsilon)`.
    
    # Let's try:
    # `priority[i] = 1 / (bins_remain_cap[i] - item + epsilon) * 1 / (bins_remain_cap[i] + epsilon)`
    
    # Let's test this with item 3:
    # Bin A: remaining 10, fits 7. Initial 10. Priority = (1/7) * (1/10) = 1/70
    # Bin B: remaining 7, fits 4. Initial 7. Priority = (1/4) * (1/7) = 1/28
    # Bin C: remaining 6, fits 3. Initial 6. Priority = (1/3) * (1/6) = 1/18
    # Bin D: remaining 5, fits 2. Initial 5. Priority = (1/2) * (1/5) = 1/10
    # Bin E: remaining 12, fits 9. Initial 12. Priority = (1/9) * (1/12) = 1/108
    
    # Order of preference: D, C, B, A, E.
    # This prioritizes bins that were initially more full AND result in a tighter fit.
    # This seems to capture "Almost Full Fit" well.
    
    priorities[can_fit_mask] = (1.0 / (fits[can_fit_mask] + epsilon)) * (1.0 / (bins_remain_cap[can_fit_mask] + epsilon))
    
    # However, the term `1.0 / (bins_remain_cap[can_fit_mask] + epsilon)` favors bins that are *currently* almost full, irrespective of how the item fits.
    # The core of "Almost Full Fit" is about the state *after* the item is placed.
    # A bin is "almost full" if its remaining capacity is small.
    # So the priority should be directly related to `fits`.
    
    # Let's reconsider the first interpretation: prioritize the tightest fit.
    # `priority[i] = 1.0 / (bins_remain_cap[i] - item + epsilon)` for `bins_remain_cap[i] >= item`.
    
    # If "Almost Full Fit" means we want to avoid creating *very empty* bins, then small positive `fits` are good.
    
    # Let's re-evaluate the phrasing: "pack an item as soon as it is received" and "smallest number of fixed-sized bins".
    # The goal is to minimize the number of bins. This means making each bin as full as possible before opening a new one.
    # "Almost Full Fit" suggests that when placing an item, we want to move a bin closer to being "full".
    # A bin is closer to being full if its remaining capacity is reduced.
    # The greatest reduction happens with the tightest fit.
    
    # Consider a scenario:
    # Bin 1: remaining capacity 10. Item 7. Fits 3.
    # Bin 2: remaining capacity 10. Item 4. Fits 6.
    # We have item 3.
    # If we place item 3 in Bin 1: remaining becomes 7.
    # If we place item 3 in Bin 2: remaining becomes 7.
    # The current priority `1.0 / (fits[can_fit_mask] + epsilon)` would give both the same priority (1/7).
    
    # If "Almost Full Fit" implies a preference for bins that are *already* somewhat occupied, we could consider the current remaining capacity.
    # Let's try prioritizing bins based on their remaining capacity first, then tightness.
    # Or combine them.
    
    # Heuristic v2.1: Prioritize by tightest fit, but add a slight bonus if the bin is currently quite full.
    # `priority = (1 / (fits + epsilon)) + (some_bonus_if_bins_remain_cap_is_small)`
    
    # Let's define "quite full" as `bins_remain_cap[i] < Threshold`.
    # This threshold would typically be related to the bin capacity, which we don't have.
    
    # Simpler approach: the inverse of `fits` is the primary driver.
    # To emphasize "almost full", perhaps we should ensure that bins with *large* `fits` get very low priority.
    # The current inverse already does this.
    
    # Let's refine `priority_v1`'s basic idea: `priorities[can_fit_mask] = 1.0 / (fits[can_fit_mask] + epsilon)`
    # This maximizes the usage of bins.
    
    # How can we make it more "Almost Full"?
    # Maybe a different transformation of `fits`.
    # E.g., `exp(-k * fits)` for some `k > 0`. This gives higher priority to smaller `fits`.
    # If `fits` is large, `exp(-k * fits)` is small.
    # If `fits` is small positive, `exp(-k * fits)` is close to 1.
    # If `fits` is 0, `exp(0) = 1`.
    
    # Let's consider the difference `bins_remain_cap[i] - item`.
    # We want small positive values for this.
    
    # Let's try to model the "desirability" of a bin.
    # Desirable bins are:
    # 1. Capable of holding the item.
    # 2. When the item is placed, the remaining capacity is minimized.
    # 3. (Perhaps) The bin was already not excessively empty before placing the item.
    
    # The original formulation `1.0 / (fits + epsilon)` addresses #1 and #2 directly.
    # If item=3, bins_rem_cap = [10, 7, 6, 5, 12]
    # fits = [7, 4, 3, 2, 9]
    # prios = [1/7, 1/4, 1/3, 1/2, 1/9]
    
    # If we want to emphasize the "almost full" aspect, maybe we should square the priority?
    # Or raise it to a power greater than 1?
    # Let's try: `priorities[can_fit_mask] = (1.0 / (fits[can_fit_mask] + epsilon))**2`
    # This would make the preference for tighter fits even stronger.
    # With item=3:
    # fits = [7, 4, 3, 2, 9]
    # prios_v1 = [0.14, 0.25, 0.33, 0.50, 0.11]
    # prios_squared = [0.02, 0.0625, 0.11, 0.25, 0.012]
    # The order remains the same, but the differences are amplified.
    
    # This emphasizes the tightest fit even more. This IS a good interpretation of "Almost Full Fit".
    # It means we are really pushing to fill bins to capacity, minimizing wasted space.
    
    # Let's consider what happens if `fits` are negative. Our `can_fit_mask` handles this.
    
    # What if `bins_remain_cap[i]` is large, say 1000, and item is 3. `fits = 997`. Priority = 1/997.
    # If another bin has `bins_remain_cap[i] = 5` and item is 3. `fits = 2`. Priority = 1/2.
    # The bin with initial capacity 5 is correctly prioritized if it's a tighter fit.
    
    # Could there be a case where we want to prefer a bin that has a lot of capacity left,
    # if the item is very small and many bins are only slightly occupied?
    # The "Almost Full Fit" implies the opposite: we prefer bins that are ALMOST full.
    # So, the current formulation where we reward small `fits` seems correct.
    
    # Let's use the `1.0 / (fits[can_fit_mask] + epsilon)` as the core idea.
    # To make it more "Almost Full", perhaps we should consider how "full" the bin was BEFORE the item was placed.
    # If a bin has remaining capacity R, its "fullness" could be considered 1 - R/TotalCapacity.
    # Since we don't have TotalCapacity, we can use a relative measure, or just use R directly.
    # Bins with smaller R are "more full".
    
    # Let's try a combined priority:
    # Primary driver: Tightness of fit (minimize remaining space).
    # Secondary driver: Current "fullness" of the bin (prefer less empty bins).
    
    # Combine them using multiplication or addition.
    # If addition: `priority = (1.0 / (fits[can_fit_mask] + epsilon)) + (1.0 / (bins_remain_cap[can_fit_mask] + epsilon))`
    # Item=3:
    # fits=[7, 4, 3, 2, 9], bins_rem_cap=[10, 7, 6, 5, 12]
    # P1 = 1/fits: [0.14, 0.25, 0.33, 0.50, 0.11]
    # P2 = 1/bins_rem_cap: [0.10, 0.14, 0.17, 0.20, 0.08]
    # Sum = P1+P2:
    # Bin 1 (10): 0.14 + 0.10 = 0.24
    # Bin 2 (7):  0.25 + 0.14 = 0.39
    # Bin 3 (6):  0.33 + 0.17 = 0.50
    # Bin 4 (5):  0.50 + 0.20 = 0.70
    # Bin 5 (12): 0.11 + 0.08 = 0.19
    # Order: 4, 3, 2, 1, 5.
    # This prioritizes the tightest fit first (Bin 4), and among equally tight fits (not present here), it would prefer the one that was more full initially.
    
    # Let's consider two bins with item 3:
    # Bin A: rem_cap=7, fits=4. P1=0.25, P2=0.14. Sum=0.39
    # Bin B: rem_cap=10, fits=7. P1=0.14, P2=0.10. Sum=0.24
    # Bin A is preferred. This is good.
    
    # Consider two bins where the 'fits' are the same: Item=3.
    # Bin X: rem_cap=5, fits=2. P1=0.5, P2=0.2. Sum=0.7
    # Bin Y: rem_cap=8, fits=2. P1=0.5, P2=0.125. Sum=0.625
    # Bin X is preferred. This is good because it was more full initially.
    
    # This additive approach `(1.0 / (fits[can_fit_mask] + epsilon)) + (1.0 / (bins_remain_cap[can_fit_mask] + epsilon))`
    # seems to balance both criteria for "Almost Full Fit": the tightest fit, and preferring bins that are already substantially occupied.
    
    # Let's check potential issues:
    # If `bins_remain_cap` is very small (e.g., 1) and item is small (e.g., 0.5).
    # fits = 0.5. bins_remain_cap = 1.
    # P1 = 1/0.5 = 2. P2 = 1/1 = 1. Sum = 3.
    
    # If `bins_remain_cap` is very large, e.g., 100, item is 3.
    # fits = 97. bins_remain_cap = 100.
    # P1 = 1/97 ≈ 0.01. P2 = 1/100 = 0.01. Sum = 0.02.
    # The priority from the initial fill becomes relatively less impactful when the remaining capacity is large.
    
    # The relative scaling of the two terms might be important.
    # If we want to emphasize tightness more, we could multiply by a factor.
    # `priority = A * (1.0 / (fits[can_fit_mask] + epsilon)) + B * (1.0 / (bins_remain_cap[can_fit_mask] + epsilon))`
    
    # For now, let's use a simple additive combination with equal weights.
    # This is `priority_v2`'s implementation.
    
    # Let's reconsider the multiplicative approach:
    # `priorities[can_fit_mask] = (1.0 / (fits[can_fit_mask] + epsilon)) * (1.0 / (bins_remain_cap[can_fit_mask] + epsilon))`
    # Item=3:
    # fits=[7, 4, 3, 2, 9], bins_rem_cap=[10, 7, 6, 5, 12]
    # P1 = 1/fits: [0.14, 0.25, 0.33, 0.50, 0.11]
    # P2 = 1/bins_rem_cap: [0.10, 0.14, 0.17, 0.20, 0.08]
    # Prod = P1 * P2:
    # Bin 1 (10): 0.14 * 0.10 = 0.014
    # Bin 2 (7):  0.25 * 0.14 = 0.035
    # Bin 3 (6):  0.33 * 0.17 ≈ 0.056
    # Bin 4 (5):  0.50 * 0.20 = 0.10
    # Bin 5 (12): 0.11 * 0.08 ≈ 0.009
    # Order: 4, 3, 2, 1, 5.
    # The multiplicative version prioritizes bins where *both* criteria are met strongly.
    # It punishes bins that are either not a tight fit OR were very empty initially.
    # The additive version might prefer a bin that is slightly less tight but much fuller initially.
    
    # The term "Almost Full Fit" suggests focusing on the state *after* fitting.
    # So, `1 / fits` is the most direct representation of "how close to full after fitting".
    # The "Almost Full" part implies we want to reduce wasted space, which is precisely what `1/fits` prioritizes for positive `fits`.
    
    # What if the problem means "prefer bins that will *become* almost full", but with some consideration for the initial state?
    
    # Let's simplify and go back to the core idea of "tightest fit".
    # The strategy is "Almost Full Fit". This means we want to pack items such that bins get as full as possible.
    # When placing an item, we want to choose a bin where the item fits, and the remaining capacity is minimized.
    # So, minimize `bins_remain_cap[i] - item`.
    # Maximizing `1 / (bins_remain_cap[i] - item + epsilon)` for `bins_remain_cap[i] >= item` is the most direct implementation of this.
    
    # Let's re-evaluate the "priority" concept. The bin with the HIGHEST priority score is selected.
    
    # Final consideration: the definition of "Almost Full Fit".
    # It's often interpreted as preferring bins with the smallest positive slack `s_i = C - x_i - item_j` where `C` is bin capacity.
    # This translates to minimizing `bins_remain_cap[i] - item`.
    # The function `f(x) = 1/x` is monotonically decreasing for x>0.
    # So maximizing `1 / (slack + epsilon)` means minimizing `slack`.
    
    # The question is whether there's an additional component related to the *initial* remaining capacity.
    # If the goal is to minimize the number of bins, then making each bin as full as possible is the key.
    # This implies minimizing `bins_remain_cap[i] - item`.
    
    # Let's consider a scenario where `TotalCapacity = 10`.
    # Item = 3.
    # Bin A: rem_cap = 5. Item fits (remaining 2). Priority (1/2). Initial fullness ~50%. Final fullness ~70%.
    # Bin B: rem_cap = 10. Item fits (remaining 7). Priority (1/7). Initial fullness ~0%. Final fullness ~30%.
    # Bin A is clearly preferred.
    
    # What if the item is 2?
    # Bin A: rem_cap = 5. Item fits (remaining 3). Priority (1/3). Initial fullness ~50%. Final fullness ~70%.
    # Bin B: rem_cap = 10. Item fits (remaining 8). Priority (1/8). Initial fullness ~0%. Final fullness ~20%.
    # Bin A is still preferred.
    
    # What if item = 8?
    # Bin A: rem_cap = 10. Item fits (remaining 2). Priority (1/2). Initial fullness ~0%. Final fullness ~20%.
    # Bin B: rem_cap = 5. Item does not fit. Priority 0.
    # Bin A is preferred.
    
    # The function `priorities[can_fit_mask] = 1.0 / (fits[can_fit_mask] + epsilon)` seems to be the most direct interpretation of "tightest fit" or "minimizing remaining space".
    
    # Let's consider if there's a specific way to make it *more* "almost full".
    # If `bins_remain_cap[i]` is very close to `item`, that bin is "almost full" relative to the item size.
    # If `bins_remain_cap[i]` is much larger than `item`, the bin is less "almost full" in this sense.
    
    # Maybe a term that favors bins where `bins_remain_cap[i] / item` is small?
    # This would be `item / bins_remain_cap[i]`.
    
    # Let's try `priority = (1.0 / (fits + epsilon)) * (item / bins_remain_cap)` for bins that can fit.
    # Item=3:
    # fits=[7, 4, 3, 2, 9], bins_rem_cap=[10, 7, 6, 5, 12]
    # P1 = 1/fits: [0.14, 0.25, 0.33, 0.50, 0.11]
    # P2 = item/bins_rem_cap: [3/10, 3/7, 3/6, 3/5, 3/12] = [0.3, 0.43, 0.5, 0.6, 0.25]
    # Prod = P1 * P2:
    # Bin 1 (10): 0.14 * 0.3 = 0.042
    # Bin 2 (7):  0.25 * 0.43 = 0.1075
    # Bin 3 (6):  0.33 * 0.5 = 0.165
    # Bin 4 (5):  0.50 * 0.6 = 0.30
    # Bin 5 (12): 0.11 * 0.25 = 0.0275
    # Order: 4, 3, 2, 1, 5.
    # This is the same order as before. This function emphasizes bins that are both tight fitting AND where the bin had less room to begin with (relative to item size).
    
    # This combination seems robust. Let's use the multiplicative form.
    
    priorities[can_fit_mask] = (1.0 / (fits[can_fit_mask] + epsilon)) * (item / (bins_remain_cap[can_fit_mask] + epsilon))
    
    return priorities
```
