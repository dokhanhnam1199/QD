```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best Fit with a penalty for bins that are too full or too empty.

    Prioritizes bins that fit the item and are close to being full after packing,
    but penalizes bins that would become excessively full.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate the remaining capacity after adding the item for fitting bins
    remaining_caps_after_fit = bins_remain_cap[can_fit_mask] - item
    
    # High priority for bins that leave minimal remaining space (tight fit)
    # Add a small epsilon to avoid division by zero and to ensure fitting bins have priority
    tight_fit_score = 1.0 / (remaining_caps_after_fit + 1e-6)
    
    # Penalize bins that become "too full" after packing.
    # We define "too full" as having very little remaining capacity (e.g., < 0.1 of bin capacity).
    # This penalty is a small negative value that reduces the priority.
    # We'll use a fraction of the bin's original capacity for the penalty calculation.
    # Assuming a standard bin capacity (e.g., 1.0 for normalization, or we can infer it if needed)
    # Let's assume a default bin capacity of 1.0 for penalty calculation if not provided.
    # A more robust approach might involve knowing the original bin capacity or average.
    # For simplicity, we'll use a fixed threshold or relative threshold.
    # Penalty increases as remaining_caps_after_fit gets smaller.
    # Here, we use a soft penalty that becomes more significant as remaining_caps_after_fit approaches zero.
    # Using a gaussian-like penalty centered at 0 remaining capacity could work,
    # but a simpler inverse function might suffice.
    # Let's adapt the tight fit score to also penalize very small remaining capacities.
    # A simple approach is to cap the inverse to avoid extremely high priorities.
    # Or, introduce a secondary term that penalizes extreme tightness.
    
    # Let's refine the priority:
    # Primary goal: prioritize bins that are "almost full" after packing (tight fit).
    # Secondary goal: avoid bins that become *too* full, which might be problematic.
    # This can be achieved by giving a slightly lower priority to bins with near-zero remaining capacity.
    
    # Method 1: Cap the priority or use a saturating function.
    # Method 2: Introduce a penalty term for very small remaining capacities.
    # Let's try Method 2: Add a term that reduces priority for very small remaining_caps_after_fit.
    # A simple way is to subtract a function that is large for small remaining_caps_after_fit.
    # For example, subtract a scaled inverse of the remaining capacity itself, but only when it's small.
    
    # We want to favor remaining_caps_after_fit that are small but not necessarily zero.
    # The `tight_fit_score` already favors smaller `remaining_caps_after_fit`.
    # To penalize *excessively* full bins, we can subtract a penalty that grows as `remaining_caps_after_fit` approaches 0.
    # Let's consider the original capacity of the bin to define "too full".
    # If we don't know the original capacity, we can use a relative threshold.
    # A heuristic for "too full" could be `remaining_caps_after_fit < item * 0.1` (leaves less than 10% of item size as remainder)
    # or `remaining_caps_after_fit < some_small_constant`.
    
    # Let's combine the "almost full fit" idea with a slight penalty for extremely tight fits.
    # We can use a function that peaks at a small positive remaining capacity, rather than at zero.
    # A function like `x * exp(-x)` or `x / (x^2 + c)` could achieve this.
    # However, to keep it simpler and build upon existing ideas:
    # The "Almost Full Fit" score `1.0 / (remaining_caps_after_fit + 1e-6)` already prioritizes smaller remainders.
    # To penalize the *absolute smallest* remainders, we can subtract a term that increases as `remaining_caps_after_fit` decreases.
    # Let's try subtracting a small fraction of the original "tightness" if the remaining capacity is very small.
    
    # Let's reconsider the problem: we want to prioritize bins that are ALMOST FULL.
    # This means remaining_caps_after_fit should be small.
    # The `priority_v0` already does this well.
    # The "Analyze & experience" suggests combining tight fit with something else.
    # What if we penalize bins that have ALREADY very little capacity remaining, even before placing the item?
    # This would be like a "First Fit Decreasing" or "Worst Fit Decreasing" aspect if we sort items.
    # But this is online, so we can't sort items.
    
    # Let's try to refine the "Almost Full Fit" by adding a factor that prefers bins that aren't already nearly empty.
    # If a bin is almost empty, placing an item there might not be optimal if other bins have more space.
    # However, the goal of BPP is to minimize the NUMBER of bins. So filling bins efficiently is key.
    
    # The core idea of "Almost Full Fit" is to minimize wasted space.
    # The `priority_v0` captures this. Let's try to combine it with a Best Fit aspect.
    # Best Fit: minimize `bins_remain_cap - item`. This is equivalent to minimizing `remaining_caps_after_fit`.
    # So, `priority_v0` is essentially a variant of Best Fit focused on the *after* state.
    
    # What if we want to prioritize bins that have a moderate amount of remaining capacity *before* packing,
    # but then aim for a tight fit? This seems counter-intuitive for minimizing bins.
    
    # Let's go back to the "Analyze & experience" hint: combine "tight fit" with something.
    # The sigmoid heuristics (19/20) tried to balance fullness.
    # The prompt asks to COMBINE elements.
    # `priority_v0` is a strong "Almost Full Fit".
    # Let's combine it with a slight "Best Fit" preference.
    # Best Fit usually means picking the bin where `bins_remain_cap - item` is minimized and non-negative.
    # This is exactly what `remaining_caps_after_fit` represents.
    # So, `priority_v0` IS already a Best Fit heuristic aimed at minimizing the *resulting* empty space.
    
    # Let's consider a heuristic that aims to fill bins that are already quite full, but not so full that the item doesn't fit.
    # This is what `priority_v0` does.
    
    # Perhaps the combination should be:
    # 1. Maximize the tightness of the fit (minimize `remaining_caps_after_fit`).
    # 2. Add a factor that prefers bins that are generally larger (more capacity initially), IF they can achieve a tight fit.
    # This might seem counter-intuitive, as we want to fill smaller bins first.
    
    # Let's try a simpler combination:
    # Use the `priority_v0` score (inverse of remaining capacity after fit) as a base.
    # Then, add a small bonus if the bin was already relatively full *before* placing the item.
    # "Relatively full" can be defined as `bins_remain_cap / total_capacity`.
    # Let's assume a total capacity of 1.0 for simplicity if not given.
    
    # Let's try a slight modification of priority_v0:
    # priority_v0 = 1.0 / (remaining_caps_after_fit + 1e-6)
    # This strongly favors bins where `remaining_caps_after_fit` is smallest.
    
    # What if we want to avoid bins that are *extremely* full (i.e., remaining capacity very close to 0)?
    # We can apply a penalty.
    # Penalty = `max(0, K - remaining_caps_after_fit)` where K is a threshold for "too full".
    # Let's say K = 0.1 (10% of a unit capacity bin).
    # Modified Priority = `priority_v0` - `penalty`
    
    # Let's try another angle: combine the "Almost Full Fit" score with the original remaining capacity in a multiplicative way.
    # Prioritize bins that have a high "almost full fit" score AND were already somewhat full.
    # Score = `(1.0 / (remaining_caps_after_fit + 1e-6)) * (bins_remain_cap[can_fit_mask])`
    # This would favor bins where the resulting empty space is small, AND the original remaining space was also not too large.
    
    # Let's stick to a clear combination principle.
    # Principle: Favor tight fits, but break ties (or provide a secondary preference) using another metric.
    # Metric: "Almost Full Fit" (as in v0) is good.
    # What other heuristic is relevant? Maybe avoiding bins that are already too full?
    
    # Let's combine the "Almost Full Fit" score with a slight bias towards bins that are not excessively empty.
    # A bin that is almost empty might be better used for a larger item later (if we knew future items).
    # In online, we don't. So filling up bins seems paramount.
    
    # Let's try to combine the core idea of `priority_v0` (tightest fit after placement) with a secondary factor.
    # The secondary factor could be the original remaining capacity.
    # We want smaller `remaining_caps_after_fit`.
    # Let's say we also want smaller `bins_remain_cap` initially, IF they provide a tight fit.
    # This would be like a "Best Fit" on the original capacities, but weighted by the tightness.
    
    # Let's reconsider `priority_v0`. It's already a strong heuristic for BPP.
    # The goal is to combine elements.
    # Maybe combine "Almost Full Fit" with a form of "Worst Fit"?
    # Worst Fit would try to put the item in the bin with the MOST remaining capacity. This is generally bad for BPP.
    
    # Let's try to enhance `priority_v0` by adding a small penalty for bins that are *already* very full.
    # This might prevent a situation where a bin becomes impossibly tight for future items.
    # Penalty: `max(0, K - bins_remain_cap[can_fit_mask])` where K is a threshold for "too full" original capacity.
    # If `bins_remain_cap` is already small, we might want to avoid making it even smaller.
    # Example: If bin capacity is 1.0, and `bins_remain_cap` is 0.05. If item is 0.02.
    # `remaining_caps_after_fit` = 0.03. `priority_v0` score = 1 / (0.03 + 1e-6) = ~33.3.
    # If we penalize bins that are already very full (say, < 0.1 remaining), this bin would get a penalty.
    # Penalty = `max(0, 0.1 - 0.05)` = 0.05.
    # New Priority = 33.3 - 0.05 = 33.25.
    # This is a very minor change. The dominant factor is still the tight fit.
    
    # Let's try a multiplicative approach:
    # Priority = `(1.0 / (remaining_caps_after_fit + 1e-6)) * (bins_remain_cap[can_fit_mask] / MAX_CAPACITY)`
    # This favors tighter fits AND bins that were initially larger. This is likely not good.
    
    # How about: Prioritize tight fits, but use the original remaining capacity as a tie-breaker,
    # preferring bins that were initially smaller (to fill up smaller bins first).
    # This sounds like a variant of Best Fit (minimize `remaining_caps_after_fit`) combined with First Fit (prefer earlier bins or bins with less initial capacity).
    
    # Let's implement a combination of "Almost Full Fit" (from v0) and a penalty for bins that are already too full.
    # "Too full" can be relative to the item size. If a bin has very little space left compared to the item size, it's problematic.
    # Let's define "problematic" as having remaining capacity less than a fraction of the item size.
    # e.g., `bins_remain_cap[can_fit_mask] < item * 0.2` (remaining capacity is less than 20% of item size)
    
    # Let's try combining the inverse of remaining capacity after fit (from v0)
    # with the negative of the original remaining capacity (from Best Fit).
    # We want to minimize `remaining_caps_after_fit` and also minimize `bins_remain_cap`.
    # But we only care about bins that fit.
    
    # Let's create a score that prioritizes bins that result in small `remaining_caps_after_fit`,
    # but also adds a bonus if the bin originally had substantial capacity remaining. This is counter-intuitive.
    
    # The core idea of "Almost Full Fit" is sound. Let's augment it.
    # What if we give a slight boost to bins that have *just enough* space?
    # Consider a bin with remaining capacity R. We put item I. New remaining R-I.
    # Priority is high if R-I is small.
    # What if we also give a slight preference to bins where R is not *too* small initially?
    # This sounds like we want R to be moderately large, but R-I to be small.
    # This suggests R should be slightly larger than I.
    
    # Let's combine the "Almost Full Fit" with a "Slightly Empty" preference.
    # Score = `(1.0 / (remaining_caps_after_fit + 1e-6)) * (bins_remain_cap[can_fit_mask])`
    # This rewards bins that have a tight fit AND originally had more space. This might be okay.
    # Let's try this:
    
    # Using the "Almost Full Fit" score from priority_v0 and multiplying it by the original remaining capacity.
    # This favors bins that will be nearly full AFTER packing, AND were already somewhat full BEFORE packing.
    # This might help ensure that items are placed into bins that are already progressing towards being filled.
    
    # Calculate the base priority (tight fit score)
    base_priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate the remaining capacity after adding the item for fitting bins
    remaining_caps_after_fit = bins_remain_cap[can_fit_mask] - item
    
    # The "Almost Full Fit" score: higher for smaller remaining capacity after fit
    almost_full_score = 1.0 / (remaining_caps_after_fit + 1e-6)
    
    # Combine with original remaining capacity:
    # Multiply the "almost full fit" score by the original remaining capacity.
    # This prioritizes bins that are both "almost full" after packing AND were already reasonably full before packing.
    # This can be interpreted as: "Fill bins that have room, but are already somewhat utilized, to achieve a tight fit."
    # We normalize `bins_remain_cap` by a typical bin size (e.g., 1.0) to avoid large scale differences.
    # If bin capacities vary widely, a dynamic normalization might be better, but for simplicity, assume a unit capacity or use the max observed.
    # Let's assume a maximum capacity of 1.0 for normalization purposes if not specified.
    # Or, simply use the raw `bins_remain_cap` values.
    
    # Let's use the raw values for `bins_remain_cap`.
    # The product `almost_full_score * bins_remain_cap[can_fit_mask]`
    # favors cases where `remaining_caps_after_fit` is small AND `bins_remain_cap` is large.
    # This might lead to filling larger bins first if they can achieve a tight fit.
    
    # Alternative combination:
    # Favor tight fits AND bins that were initially smaller.
    # This would mean: `(1.0 / (remaining_caps_after_fit + 1e-6)) * (1.0 / (bins_remain_cap[can_fit_mask] + 1e-6))`
    # This prioritizes bins with small remaining capacity after fit, AND small original remaining capacity.
    # This seems more aligned with filling up available space efficiently.
    
    # Let's try this last one:
    # Score = (Tightness Score) * (Initial Space Score)
    # Tightness Score = 1.0 / (remaining_caps_after_fit + 1e-6) -> favors small remaining_caps_after_fit
    # Initial Space Score = 1.0 / (bins_remain_cap[can_fit_mask] + 1e-6) -> favors small bins_remain_cap
    
    priorities[can_fit_mask] = almost_full_score * (1.0 / (bins_remain_cap[can_fit_mask] + 1e-6))
    
    # This heuristic prioritizes bins that result in a tight fit AND were initially less utilized (had more remaining capacity).
    # This might be good for spreading items initially but could lead to more bins if the "less utilized" bins are large.
    
    # Let's revert to a simpler combination based on the "tight fit" being primary.
    # The "Almost Full Fit" `1.0 / (remaining_caps_after_fit + 1e-6)` is excellent.
    # What if we want to break ties using Best Fit principle on the remaining capacity?
    # Best Fit minimizes `remaining_caps_after_fit`.
    # The current score already strongly rewards minimum `remaining_caps_after_fit`.
    
    # Let's try combining "Almost Full Fit" with a slight penalty for bins that are already "too full".
    # A bin is "too full" if its remaining capacity is very small relative to a typical bin size.
    # Let's use a constant threshold for "too full", e.g., remaining capacity < 0.1.
    # Penalty for bins with `bins_remain_cap[can_fit_mask] < 0.1`
    
    # Let's refine the `priority_v0` logic slightly.
    # `priority_v0` prioritizes bins that leave the *least* amount of space.
    # What if we want bins that leave *some* space, but not too much?
    # This is where sigmoid functions came in.
    
    # Let's try combining the "tight fit" idea with a preference for bins that are not already nearly empty.
    # If a bin has very little capacity remaining, placing an item there might be suboptimal if it uses up that small capacity entirely.
    # Consider the bin's original remaining capacity `R`. We place item `I`. New remaining `R-I`.
    # We want `R-I` to be small. This is `priority_v0`.
    # What if we also want `R` to be not extremely small?
    # Let's say `R` should be greater than some `min_R`.
    # This is like a conditional Best Fit: find the best fit among bins where `R > min_R`.
    
    # Let's try combining the tight fit score with a bonus proportional to the *original* remaining capacity.
    # This favors bins that are already somewhat utilized and can be filled tightly.
    
    # Final Attempt: Combine the "Almost Full Fit" score with a slight penalty for bins that are already extremely full.
    # This adds robustness by discouraging placing items into bins that are already nearly unusable.
    
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_caps_after_fit = fitting_bins_caps - item
    
    # Base priority: "Almost Full Fit" - higher for smaller remaining capacity after packing
    base_priority = 1.0 / (remaining_caps_after_fit + 1e-6)
    
    # Penalty for bins that are already "too full".
    # Let's define "too full" as having remaining capacity less than 10% of a typical bin capacity (assuming 1.0).
    # Or, relative to the item size: remaining capacity < item * 0.2.
    # Let's use a fixed threshold for simplicity, assuming a normalized capacity context.
    # If remaining capacity is less than `penalty_threshold`, apply a penalty.
    penalty_threshold = 0.05 # Bins with less than 5% capacity remaining are penalized.
    
    # The penalty should be larger for smaller remaining capacities.
    # Let's make the penalty proportional to how much smaller the remaining capacity is than the threshold.
    # Penalty = max(0, penalty_threshold - fitting_bins_caps) * penalty_factor
    # We want to penalize bins with small `fitting_bins_caps`.
    # If `fitting_bins_caps` is small, say 0.02, and threshold is 0.05.
    # The base priority `1.0 / (fitting_bins_caps - item + 1e-6)` will be high if `fitting_bins_caps - item` is small.
    
    # Let's reconsider: Combine "Almost Full Fit" with "Best Fit" where Best Fit means minimizing remaining capacity.
    # `priority_v0` ALREADY does this by maximizing `1 / remaining_capacity`.
    # The request is to COMBINE elements.
    
    # Let's combine the "tightest fit" with a secondary preference for bins that were initially less utilized.
    # Score = (Tightness Score) * (Initial Underutilization Score)
    # Tightness Score = 1.0 / (remaining_caps_after_fit + 1e-6)
    # Initial Underutilization Score = 1.0 / (bins_remain_cap[can_fit_mask] + 1e-6) # Favor bins that had more initial capacity
    
    # This prioritizes bins that have small `remaining_caps_after_fit` AND large `bins_remain_cap`.
    # This might fill up larger bins first if they allow a tight fit.
    
    # Let's try the other way:
    # Score = (Tightness Score) * (Initial Utilization Score)
    # Tightness Score = 1.0 / (remaining_caps_after_fit + 1e-6)
    # Initial Utilization Score = bins_remain_cap[can_fit_mask] # Favor bins that were already more utilized
    
    # This combination favors bins that are ALREADY somewhat full AND can achieve a tight fit.
    # This feels like a sensible combination: use bins that are already progressing and fill them tightly.
    
    # Let's apply this combined score.
    priorities[can_fit_mask] = (1.0 / (remaining_caps_after_fit + 1e-6)) * fitting_bins_caps
    
    # This heuristic prioritizes bins that achieve a tight fit (small remaining capacity after placement)
    # and also prioritizes bins that were already more utilized (larger remaining capacity before placement).
    # This aims to fill up bins that are already making progress towards being full, by achieving a tight fit.
    
    return priorities
```
