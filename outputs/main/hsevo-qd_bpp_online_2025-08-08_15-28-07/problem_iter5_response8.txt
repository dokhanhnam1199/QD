```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines tight fit preference with a preference for initially fuller bins."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    available_bins_cap = bins_remain_cap[can_fit_mask]
    
    # Primary score: Favor tight fits (minimize remaining capacity after fit)
    # Using 1 / (remaining_capacity + epsilon) to prioritize smaller remainders.
    tight_fit_score = 1.0 / (available_bins_cap - item + 1e-9)
    
    # Secondary score: Favor initially fuller bins (minimize current remaining capacity)
    # Using 1 / (current_capacity + epsilon) to prioritize bins that are already less empty.
    initial_fill_score = 1.0 / (available_bins_cap + 1e-9)
    
    # Combine scores multiplicatively: Reward bins that are both a tight fit AND initially fuller.
    # This aims to capture the "sweet spot" of fitting snugly into an already utilized bin.
    priorities[can_fit_mask] = tight_fit_score * initial_fill_score
    
    return priorities
```
