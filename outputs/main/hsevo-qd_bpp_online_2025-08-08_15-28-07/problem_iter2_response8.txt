```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit (minimizing residual space) with a preference for
    bins that are not excessively empty, using a sigmoid-like penalty for
    overly large remaining capacities.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)
    epsilon = 1e-9  # Small value to avoid division by zero

    for i in range(len(bins_remain_cap)):
        if bins_remain_cap[i] >= item:
            remaining_after_fit = bins_remain_cap[i] - item
            
            # Heuristic 1: Best Fit - prioritize less remaining capacity
            best_fit_score = -remaining_after_fit

            # Heuristic 2: Penalize bins that are too empty after fit
            # A sigmoid-like penalty, higher penalty for larger remaining_after_fit
            # Values significantly larger than item get a larger penalty.
            # The idea is to avoid leaving too much empty space if possible,
            # while still preferring tighter fits.
            over_capacity_penalty = 0.5 * (1 / (1 + np.exp((remaining_after_fit - item) / (bins_remain_cap[i] + epsilon))))
            
            # Combine scores: prioritize tight fit, but slightly penalize very empty bins
            # This rewards tight fits more, but also slightly discourages placing
            # an item in a bin that becomes very empty.
            priorities[i] = best_fit_score - over_capacity_penalty

    return priorities
```
