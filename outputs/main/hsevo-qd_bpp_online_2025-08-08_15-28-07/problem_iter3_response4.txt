```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    available_bins_mask = bins_remain_cap >= item
    
    if not np.any(available_bins_mask):
        return np.zeros_like(bins_remain_cap)
    
    available_bins_cap = bins_remain_cap[available_bins_mask]
    
    # Prioritize bins that leave the least remaining capacity after packing the item.
    # This is a variation of Best Fit, aiming for tighter packing.
    # We use the inverse of the remaining capacity to make higher values better.
    # Adding a small constant (1e-9) to avoid division by zero.
    remaining_capacity_after_packing = available_bins_cap - item
    
    # A small positive value for bins that will have zero remaining capacity
    # to ensure they are prioritized over bins with slight positive remaining capacity.
    priorities = 1.0 / (remaining_capacity_after_packing + 1e-9)
    
    # Also, consider bins that can almost fit the item perfectly (remaining capacity close to item size)
    # as a secondary preference. This can help in cases where an exact fit is not possible
    # but a near-fit can set up for future good fits.
    # We can add a term that favors bins where 'bin_cap - item' is small.
    # The weight of this secondary preference needs tuning, here it's a smaller fraction.
    # A large remaining capacity after packing is generally bad, so we want to penalize it.
    # A simple way is to use the reciprocal of remaining capacity.
    # Let's use a Gaussian-like kernel centered around 0 remaining capacity.
    
    # Gaussian-like score for being close to an exact fit
    # Using exp(-(x^2)/sigma^2) where x = remaining_capacity_after_packing
    # sigma controls the width of the peak. A smaller sigma means stricter requirement.
    # We want the peak at remaining_capacity_after_packing = 0.
    sigma = 0.1  # Tune this parameter
    gaussian_score = np.exp(-(remaining_capacity_after_packing**2) / (2 * sigma**2))
    
    # Combine the two scores. The primary score is the inverse of remaining capacity.
    # The secondary score (Gaussian) boosts bins that are closer to an exact fit.
    # We can weight the Gaussian score.
    gaussian_weight = 0.5 # Tune this parameter
    
    combined_priorities = priorities + gaussian_weight * gaussian_score
    
    # Ensure we return priorities for all original bins, with 0 for unavailable ones
    final_priorities = np.zeros_like(bins_remain_cap)
    final_priorities[available_bins_mask] = combined_priorities
    
    return final_priorities
```
