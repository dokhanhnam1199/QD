```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines 'Best Fit' for tight packing with a 'Segmoid Fit' for avoiding overly empty bins.
    Prioritizes bins that leave minimal, positive space, but still prefer slightly emptier bins over precisely full ones.
    """
    # Ensure item size is positive to avoid division by zero and logical errors.
    if item <= 1e-9:
        # If item is negligible, all bins are equally valid. Return a uniform score.
        return np.ones_like(bins_remain_cap) * 0.5

    # --- Strategy 1: Best Fit (Minimize waste) ---
    # Prioritize bins that leave minimal positive remaining capacity.
    # Use sigmoid to map small positive waste to high scores.
    # `waste = bins_remain_cap - item`. We want small positive waste.
    # `z = -k * waste`. When waste is small positive, z is small negative, sigmoid is ~0.5.
    # This is the opposite. We want high score for small POSITIVE waste.
    # Let's use `z = k * (bins_remain_cap - item)`. We want `bins_remain_cap` to be `item + small_positive`.
    # This means `z` should be small and positive. Sigmoid(`z`) will be > 0.5.
    # To get a peak at small positive waste, we can use a Gaussian-like shape derived from sigmoids.
    # `sigmoid(k * (ratio - ideal_ratio)) * sigmoid(-k * (ratio - ideal_ratio))` where ratio = bins_remain_cap / item

    # Define parameters for the sigmoid scoring
    k_steepness = 7.0  # Controls the sharpness of the preference curve
    ideal_ratio = 1.1  # Prefer bins that leave ~10% of item size as remaining capacity

    # Calculate ratios of remaining capacity to item size.
    ratios = bins_remain_cap / item

    # Create two sigmoid components to form a peak preference around ideal_ratio.
    # Sigmoid 1: Increases with ratio, favoring bins that are not too full.
    # `sigmoid(k * (ratios - ideal_ratio))` is high when `ratios > ideal_ratio`.
    score_part1 = 1 / (1 + np.exp(-k_steepness * (ratios - ideal_ratio)))

    # Sigmoid 2: Decreases with ratio, favoring bins that are not too empty (but still fit).
    # `sigmoid(-k * (ratios - ideal_ratio))` is high when `ratios < ideal_ratio`.
    score_part2 = 1 / (1 + np.exp(k_steepness * (ratios - ideal_ratio)))

    # Combine the two sigmoids. The product creates a peak around `ideal_ratio`.
    # Bins with `ratios < 1` (cannot fit) will have `score_part1` near 0, thus total priority near 0.
    # Bins with `ratios >> ideal_ratio` will have `score_part2` near 0, thus total priority near 0.
    priorities = score_part1 * score_part2

    # Explicitly set priority to 0 for bins that cannot fit the item.
    # `ratios < 1` is already handled by `score_part1` being close to 0.
    # However, for robustness, we can enforce it.
    cannot_fit_mask = bins_remain_cap < item
    priorities[cannot_fit_mask] = 0.0

    return priorities
```
