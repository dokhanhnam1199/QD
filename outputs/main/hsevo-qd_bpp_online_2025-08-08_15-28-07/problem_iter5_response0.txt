```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins with a tight fit, while slightly favoring bins with more overall capacity for future items.
    This aims to balance immediate packing efficiency with future flexibility.
    """
    # Calculate remaining capacity after placing the item
    remaining_after_fit = bins_remain_cap - item

    # Mask for bins where the item fits
    fits_mask = remaining_after_fit >= 0

    # Initialize priorities to zero for bins where the item doesn't fit
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # --- Component 1: Prioritize tight fits (Best Fit) ---
    # Use sigmoid on negative of remaining capacity after fit.
    # Higher priority for smaller positive remaining capacity.
    # Sensitivity controls how strongly we penalize looser fits.
    best_fit_sensitivity = 3.0
    best_fit_arg = np.where(fits_mask, -best_fit_sensitivity * remaining_after_fit, -1e9)
    best_fit_score = 1 / (1 + np.exp(-best_fit_arg))

    # --- Component 2: Favor bins with more overall remaining capacity ---
    # Use sigmoid on scaled remaining capacity. Higher capacity gets a score closer to 1.
    # Normalizing by a typical bin capacity (e.g., 100) helps scale the input.
    # The scaling factor reduces the influence of very large capacities.
    capacity_scaling = 50.0
    capacity_score = 1 / (1 + np.exp(-(bins_remain_cap / capacity_scaling)))

    # --- Combine Scores ---
    # Weighted combination. Favoring best fit more, but giving some weight to overall capacity.
    # Weights can be tuned based on performance.
    weight_best_fit = 0.7
    weight_capacity = 0.3

    # Apply the combined score only to bins where the item fits
    combined_score = weight_best_fit * best_fit_score + weight_capacity * capacity_score
    priorities[fits_mask] = combined_score[fits_mask]

    return priorities
```
