```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    available_bins_mask = bins_remain_cap >= item
    
    if not np.any(available_bins_mask):
        return np.zeros_like(bins_remain_cap)

    priorities = np.zeros_like(bins_remain_cap)
    
    available_bins_cap = bins_remain_cap[available_bins_mask]
    
    # Heuristic: Prefer bins that are almost full, but can still fit the item.
    # This aims to leave larger capacity bins for potentially larger future items.
    # We can achieve this by penalizing bins with very large remaining capacities.
    # A simple way is to use the inverse of the remaining capacity, but we need to ensure
    # it doesn't overly favor bins that are too small.
    
    # Option 1: Focus on the 'tightest fit' as before, but add a slight preference for
    # bins with more capacity if the difference is negligible.
    # This is similar to v1 but might have a subtle shift in preference.
    
    # Option 2: Introduce a penalty for very large remaining capacities.
    # This could be a function of the remaining capacity itself.
    # Let's try a function that rewards bins that are 'moderately' full.
    # For example, a function that peaks at a certain remaining capacity.
    # A Gaussian-like function or a negative quadratic could work, but simpler
    # is better for online settings.
    
    # Let's stick to a variation of the "tight fit" concept but consider the *impact*
    # of placing the item. Placing an item in a bin leaves a certain amount of capacity.
    # We want to leave a 'useful' amount of capacity.
    
    # Metric: Measure how "good" the resulting remaining capacity is.
    # Good could mean it's still large enough for a typical item, but not excessively large.
    
    # Let's consider the ratio of item size to remaining capacity.
    # A smaller ratio means the item is a smaller fraction of the bin's remaining space.
    # This is the inverse of v1's approach.
    
    # Another idea: Prioritize bins where the remaining capacity after packing
    # is closest to the bin's original capacity minus some "ideal" item size.
    # This is hard to define without knowing future items.
    
    # Let's refine the "tight fit" idea. v1 uses `available_bins_cap / (available_bins_cap - item + 1e-9)`.
    # This favors bins where `available_bins_cap - item` is small.
    # What if we instead consider the `available_bins_cap` itself?
    # We want to use bins that are already somewhat full, to leave the emptier bins
    # for larger items later.
    
    # Let's try prioritizing bins that have *more* remaining capacity, but
    # still fit the item. This is counter-intuitive to "tightest fit" but might
    # be better for online scenarios by preserving "tight" bins.
    # This is effectively a "Worst Fit" variant.
    
    # Let's try a combination: prioritize bins that are "tight" but not *too* small,
    # and penalize bins that are very large.
    
    # Revised Approach: Prioritize bins that offer a good "balance" - not too full, not too empty.
    # We can define "good balance" as the remaining capacity being closer to some average,
    # or not being excessively large.
    
    # Let's try: Prioritize bins that have *just enough* space, but if multiple bins
    # have that, pick the one that leaves *more* space. This is a sort of "Best Fit"
    # with a tie-breaker.
    
    # The problem is that "tightest fit" (v1) is generally good because it fills bins
    # more completely. The goal is to minimize the number of bins.
    
    # Let's reconsider v1's metric: `available_bins_cap / (available_bins_cap - item + 1e-9)`
    # This is high when `available_bins_cap - item` is small.
    # What if we invert the logic slightly? We want to use bins that have space,
    # but we don't want to leave *too much* leftover space in the bins we use.
    
    # Consider the ratio of the item size to the bin's *original* capacity if known.
    # If not known, we can use `bins_remain_cap`.
    
    # Let's try prioritizing bins where the remaining capacity *after* packing is
    # as small as possible but still positive and useful.
    # This means `bins_remain_cap - item` should be small.
    # So, `bins_remain_cap` should be just slightly larger than `item`.
    
    # Let's try to rank bins based on `bins_remain_cap`.
    # Option A: Descending order of `bins_remain_cap` (Worst Fit). This tries to keep small bins empty.
    # Option B: Ascending order of `bins_remain_cap` (Best Fit, but only among available).
    
    # v1 is essentially a variant of Best Fit.
    # Let's try a heuristic that aims to create "balanced" bins.
    # We want to avoid leaving bins that are almost empty or almost full.
    
    # Let's try a metric that rewards bins whose remaining capacity is "close" to the item size.
    # `abs(bins_remain_cap - item)` -> we want this to be small.
    # But this only works if the item fits.
    
    # Let's combine "tight fit" with a preference for bins that are not excessively full.
    # We can penalize bins with very large remaining capacities.
    
    # Metric: `f(remaining_capacity)`. We want `f` to be high for values close to `item`,
    # and decreasing as `remaining_capacity` gets much larger than `item`.
    
    # How about: `(bins_remain_cap - item + 1e-9) / bins_remain_cap`
    # This is the proportion of space *left over*. We want this to be small.
    # So we want `1 - (item / bins_remain_cap)` to be small.
    # This means we want `item / bins_remain_cap` to be large, which is similar to v1.
    
    # Let's try a heuristic that directly targets reducing the number of bins.
    # The current heuristic v1 prioritizes bins that are "tightest", meaning `bins_remain_cap - item` is minimized.
    # This is a form of "Best Fit".
    
    # Alternative idea: Prioritize bins that are "most full" among those that can fit the item.
    # This is "Worst Fit" among available bins.
    # Let's try to implement "Worst Fit" to see if it performs better for certain online scenarios.
    # Worst Fit: Select the bin with the largest remaining capacity that can accommodate the item.
    
    # For Worst Fit, we want to maximize `bins_remain_cap` among `available_bins`.
    # So, the priority should be proportional to `available_bins_cap`.
    
    worst_fit_priorities = np.zeros_like(bins_remain_cap)
    worst_fit_priorities[available_bins_mask] = available_bins_cap
    
    # Let's compare this with v1's logic. v1 is `available_bins_cap / (available_bins_cap - item + 1e-9)`.
    # This is large when `available_bins_cap` is slightly larger than `item`.
    # Worst fit is `available_bins_cap`. This is large when `available_bins_cap` is large.
    
    # What if we try to balance these?
    # Prioritize bins that are "tight" but not *too* tight.
    # A bin that is `item + epsilon` remaining is good (tight fit).
    # A bin that is `item + large_value` remaining is not so good for tight fit, but good for worst fit.
    
    # Let's consider the "slack" or "wasted space" if the item is placed.
    # Slack = `bins_remain_cap - item`. We want to minimize this.
    # v1 prioritizes bins with minimal slack.
    
    # Let's try a heuristic that prioritizes bins where the remaining capacity is
    # not too large. For example, we could use a function that decreases as
    # `bins_remain_cap` increases beyond a certain threshold.
    
    # Consider the "density" of the bin if the item is placed.
    # Density = `item / (original_capacity)`. Not available.
    
    # Let's try to be "greedy" but not *too* greedy.
    # v1 is greedy towards tight fits.
    # Worst Fit is greedy towards large remaining capacities.
    
    # Let's try a hybrid approach.
    # Prioritize bins that have remaining capacity `C` such that `item <= C < item * K` for some K.
    # Among those, pick the one closest to `item`.
    
    # A simpler approach: Penalize very large remaining capacities.
    # Let `remaining_cap_after_packing = bins_remain_cap - item`.
    # We want `remaining_cap_after_packing` to be small.
    # But we don't want `bins_remain_cap` itself to be too small.
    
    # Let's try a metric that encourages using bins that are moderately full.
    # `priority = bins_remain_cap / (bins_remain_cap + item)`
    # This metric ranges from 0 (item is 0) to 1 (item is very large compared to capacity).
    # We want to use bins that are already somewhat full.
    # So, higher `bins_remain_cap` should lead to higher priority.
    # This is similar to Worst Fit.
    
    # Let's try to penalize bins that leave *too much* space.
    # Consider the ratio of the item to the bin's remaining capacity: `item / bins_remain_cap`.
    # Higher ratio is better (item is a larger fraction).
    # This is what v1 implicitly does.
    
    # Let's try a different perspective: aim to leave bins in a state where they are
    # "most likely" to be useful for future items.
    # This often means leaving bins with moderate amounts of space.
    
    # Let's try to create a priority that is high for bins that are "moderately" full.
    # We can use a function that peaks when `bins_remain_cap` is some multiple of `item` or
    # some average capacity.
    
    # Let's consider the "efficiency" of the bin if the item is placed.
    # Efficiency = `item / bins_remain_cap`. Higher is better. This is v1's driver.
    
    # What if we consider the remaining capacity after packing? `R = bins_remain_cap - item`.
    # We want `R` to be small.
    # Consider `1 / (R + epsilon)`? This is v1.
    
    # Let's try to introduce a penalty for bins that have very large remaining capacity.
    # `priority = bins_remain_cap / (bins_remain_cap - item + 1e-9)`  (v1)
    # What if we modify the denominator?
    # `priority = bins_remain_cap / (bins_remain_cap - item + item/2 + 1e-9)`
    # This would slightly penalize bins where `bins_remain_cap - item` is very small compared to `item`.
    
    # Let's consider the ratio of leftover space to the item size: `(bins_remain_cap - item) / item`
    # We want this to be small. So `item / (bins_remain_cap - item)` should be large. v1.
    
    # Let's consider the negative of the remaining capacity that would be left:
    # `- (bins_remain_cap - item)`. We want to maximize this.
    # This means we want to minimize `bins_remain_cap - item`. This is v1.
    
    # Consider the problem statement: "smallest number of bins".
    # This means maximizing the utilization of each bin.
    
    # Let's try a heuristic that is sensitive to the *magnitude* of the leftover space.
    # v1's `inv_dist = C / (C - i)` where C is remain_cap, i is item.
    # If C = 10, i = 8, inv_dist = 10 / 2 = 5
    # If C = 100, i = 8, inv_dist = 100 / 92 = 1.08
    # If C = 10, i = 2, inv_dist = 10 / 8 = 1.25
    
    # This means v1 favors bins where `C - i` is small.
    
    # Let's try to penalize bins that are *too* close to `item`.
    # A bin with remaining capacity `item + epsilon` is good, but maybe a bin with
    # `item + 0.5 * item` is also good.
    
    # Let's try a metric that is high for bins that are moderately full.
    # We can use a function like `f(x) = x * exp(-x/K)` where x is remaining capacity.
    # This peaks and then decays. But we need to factor in the item.
    
    # Consider the ratio of the item size to the bin's *current* remaining capacity.
    # `item / bins_remain_cap`. Higher is better. This is essentially what v1 is doing
    # because `C / (C-i)` for small `C-i` is roughly `C/C = 1`, and for small `C`,
    # `C/(C-i)` can be large if `C-i` is small.
    
    # Let's try to smooth out the "tight fit" preference.
    # Instead of just `C / (C-i)`, let's consider a function that is high when `C` is
    # moderately larger than `i`.
    
    # How about `bins_remain_cap / (item + bins_remain_cap)`?
    # This ratio is high when `bins_remain_cap` is large compared to `item`. This is Worst Fit.
    
    # Let's try prioritizing bins based on the *resulting* remaining capacity.
    # `resulting_cap = bins_remain_cap - item`.
    # We want `resulting_cap` to be as small as possible, but still "useful".
    # "Useful" could mean it's not excessively small (e.g., smaller than the smallest possible item).
    
    # Let's try a metric that rewards bins whose remaining capacity is not too large.
    # `priority = 1 / (bins_remain_cap - item + 1e-9)` This penalizes large remaining space.
    # But we want to select from `available_bins`.
    
    # Let's try a hybrid of v1 and Worst Fit.
    # v1: `f(C, i) = C / (C - i)` (favors C close to i)
    # Worst Fit: `g(C) = C` (favors large C)
    
    # Let's try: `priority = (bins_remain_cap - item + 1e-9) / bins_remain_cap`
    # This is the proportion of unused space. We want to minimize this.
    # So we want to maximize `bins_remain_cap / (bins_remain_cap - item + 1e-9)`. This is v1 again.
    
    # Let's try a different penalty for large bins.
    # Suppose bin capacity is B.
    # v1: `bins_remain_cap / (bins_remain_cap - item + 1e-9)`
    # What if we want to favor bins where `bins_remain_cap` is closer to `item` but not *too* close?
    
    # Let's try a metric that rewards bins that have *some* space, but not excessive space.
    # A bin with remaining capacity `R`. We want `R` to be "just right".
    # Consider `R / (R + K)` where K is a constant. This approaches 1 for large R.
    # Consider `R / (item + R)`. This favors large R.
    
    # Let's try to penalize bins that leave too much space by dividing by a function of `bins_remain_cap`.
    # `priority = bins_remain_cap / (bins_remain_cap - item + 1e-9)` (v1)
    # `priority = bins_remain_cap / (bins_remain_cap - item + item/2 + 1e-9)`
    # The denominator is larger, making the priority smaller for bins that are "too tight".
    # This might not be ideal.
    
    # Let's focus on the goal: minimize bins.
    # This means maximizing bin utilization.
    # v1 ("Best Fit") is usually good for this.
    # Let's think about scenarios where v1 might fail.
    # If we have many small items, v1 will fill bins tightly. This is good.
    # If we have large items coming, we might regret filling bins too tightly with small items.
    
    # Let's try a heuristic that is a bit more "open" to larger bins, acting like
    # a smoothed Worst Fit.
    # Instead of just `bins_remain_cap`, let's consider `f(bins_remain_cap)`.
    
    # Consider the ratio of the item size to the average remaining capacity of available bins.
    # This requires knowing the sum/count of available bins, which might be too slow.
    
    # Let's focus on a simple modification of v1.
    # v1 is `C / (C - i)`. This is large when `C-i` is small.
    # What if we introduce a slight penalty for very small `C-i`?
    
    # Let's try a metric that considers the "quality" of the remaining space.
    # `(bins_remain_cap - item)` is the leftover.
    # We want this leftover to be small, but not zero.
    
    # Let's try a function that rewards bins whose remaining capacity is
    # within a certain range relative to the item.
    # For example, bins where `item <= bins_remain_cap < 2 * item`.
    # Among these, pick the one with smallest `bins_remain_cap`.
    
    # This seems overly complicated for an online heuristic.
    
    # Let's consider the absolute difference: `abs(bins_remain_cap - item)`.
    # We want this to be small. But this only applies if `bins_remain_cap >= item`.
    
    # Let's try a simpler heuristic: Prioritize bins that have the most remaining capacity.
    # This is Worst Fit.
    # `worst_fit_priorities = np.zeros_like(bins_remain_cap)`
    # `worst_fit_priorities[available_bins_mask] = available_bins_cap`
    
    # Another common heuristic is First Fit. For online, we can't use First Fit directly
    # because we don't know the order of items yet.
    
    # Let's try a modified "Best Fit" that discourages using bins that are *too* full.
    # v1 is `C / (C - i)`.
    # Let's try `C / (C - i + C/4)`
    # This adds a quarter of the remaining capacity to the denominator, thus reducing the priority.
    # This will slightly favor bins with more remaining capacity.
    
    # Let's test `priority = bins_remain_cap / (bins_remain_cap - item + bins_remain_cap / 4 + 1e-9)`
    
    # Available bins capacity: `available_bins_cap`
    # Item size: `item`
    
    # Let's try a metric that considers the ratio of the item to the *original* capacity,
    # but since original capacity is not available, we use `bins_remain_cap`.
    
    # Consider a "balanced fit": prefer bins where the remaining capacity is neither too small nor too large.
    # Let's try to penalize bins that are extremely full.
    
    # A simple approach: penalize bins whose remaining capacity is very close to the item size.
    # v1: `C / (C - i)` -> High for small `C-i`.
    # We want to slightly reduce priority for very small `C-i`.
    
    # How about: `priority = (bins_remain_cap - item + 1e-9) / (bins_remain_cap + 1e-9)`
    # This is the proportion of space used. We want to maximize this.
    # This is `1 - item / (bins_remain_cap + 1e-9)`.
    # Maximizing this means minimizing `item / (bins_remain_cap + 1e-9)`.
    # This means maximizing `bins_remain_cap / item`.
    # This favors bins with large remaining capacity if `item` is small.
    # This is a form of Worst Fit.
    
    # Let's try a simple modification to v1 that slightly favors bins with more space.
    # v1: `C / (C - i)`
    # Let's try: `(C - i + K) / (C - i)` for some small K.
    # This is `1 + K / (C - i)`. This would increase priority for bins with smaller `C-i`.
    # Not what we want.
    
    # Let's try to smooth the preference for tight fits.
    # Instead of `C/(C-i)`, use `C/(C-i + alpha*i)` where alpha is small.
    # This makes the denominator larger, reducing priority for very tight fits.
    # `alpha = 0.1` (10%)
    
    alpha = 0.2 # A parameter to control the smoothing
    
    # Calculate priorities for available bins.
    # The idea is to favor bins that are "tight" but not extremely tight,
    # and penalize bins that are too empty.
    # The metric `bins_remain_cap / (bins_remain_cap - item + alpha * item + 1e-9)`
    # aims to achieve this.
    # If `bins_remain_cap - item` is very small, the `alpha * item` term in the denominator
    # becomes relatively larger, reducing the priority compared to v1.
    # If `bins_remain_cap` is very large, `bins_remain_cap - item` is also large,
    # and the priority will be close to 1, which is low.
    
    # Let's use `alpha * bins_remain_cap` instead of `alpha * item`
    # `priority = bins_remain_cap / (bins_remain_cap - item + alpha * bins_remain_cap + 1e-9)`
    # This ratio is `1 / (1 - item/bins_remain_cap + alpha + 1e-9/bins_remain_cap)`
    # This still favors larger `bins_remain_cap`.
    
    # Let's stick to the idea of slightly penalizing the "tightest fit".
    # v1: `C / (C-i)`
    # Modified: `C / (C - i + \text{penalty})`
    # The penalty should be small, and perhaps related to the item size itself.
    
    # Let's try `penalty = min(item, bins_remain_cap - item)`
    # This is trying to smooth out the "best fit" by adding a small amount to the denominator.
    
    # Let's use a metric that is high for bins that are "moderately full".
    # Consider the "gap" `bins_remain_cap - item`. We want this gap to be small but not minuscule.
    # Let's try to penalize bins where `bins_remain_cap` is very large.
    
    # Consider a function `f(x) = x * exp(-x/K)`. Peaks at K.
    # `x = bins_remain_cap - item`. We want this to be small.
    
    # Let's try a different angle: what if we prioritize bins that, after packing,
    # leave a remaining capacity that is "most useful"?
    # "Most useful" could mean it's not too small and not too large.
    
    # Let's try to invert the logic of v1 slightly.
    # v1: `C / (C-i)` (favors small C-i)
    # Try: `(C-i) / C` (favors large C-i, i.e., small C) - this is "Best Fit".
    # Try: `(C-i) / (C-i + K)` (favors small C-i, but saturates)
    
    # Let's consider the ratio of the item to the bin's *total* capacity (if known).
    # Since it's not known, `bins_remain_cap` is the best we have.
    
    # Let's try a heuristic that directly addresses the "leave large bins open" idea.
    # Prioritize bins that have a moderate amount of remaining capacity.
    # We can achieve this by using a function that peaks.
    
    # Consider `priority = (bins_remain_cap - item) * exp(-(bins_remain_cap - item) / some_scale)`
    # This would peak when `bins_remain_cap - item = some_scale`.
    # But `some_scale` is hard to determine dynamically.
    
    # Let's try to smooth the "tight fit" by adding a small fraction of the item size
    # to the difference `bins_remain_cap - item`.
    
    # `priority = bins_remain_cap / (bins_remain_cap - item + 0.1 * item + 1e-9)`
    # This will slightly reduce the priority for bins that are very tight fits,
    # making them less preferred than v1.
    
    # Let's test this formula for `priority_v2`.
    # `available_bins_cap` are the capacities of bins that can fit the item.
    
    # `remaining_space = available_bins_cap - item`
    # `smoothing_factor = 0.1 * item` # A small fraction of the item size
    # `denominator = remaining_space + smoothing_factor + 1e-9`
    # `priorities_for_available = available_bins_cap / denominator`
    
    # This seems like a plausible modification to v1 that might perform better
    # in scenarios where keeping slightly larger bins is beneficial.
    
    remaining_space = available_bins_cap - item
    
    # Smoothing factor to slightly penalize extremely tight fits.
    # We add a fraction of the item size to the remaining space.
    # This makes the denominator larger, thus reducing the priority for bins
    # where remaining_space is very small.
    smoothing_factor = 0.15 * item # Tunable parameter
    
    # Ensure the denominator is never zero or negative, and add smoothing.
    # The `+ 1e-9` is for numerical stability.
    denominator = remaining_space + smoothing_factor + 1e-9
    
    # Calculate priorities: prefer bins where the item is a larger fraction of the bin's capacity,
    # but slightly penalize the tightest fits.
    priorities_for_available = available_bins_cap / denominator
    
    # Assign these priorities back to the original array structure.
    priorities[available_bins_mask] = priorities_for_available
    
    return priorities
```
