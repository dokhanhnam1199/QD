```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    available_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if not np.any(available_bins_mask):
        return priorities

    available_bins_cap = bins_remain_cap[available_bins_mask]
    
    # Calculate the "tightness" of the fit. A smaller residual capacity is generally preferred.
    # We use (available_bins_cap - item) which is the remaining capacity after placing the item.
    # To prioritize bins with less remaining capacity (tighter fit), we want to give higher scores
    # to smaller values of (available_bins_cap - item).
    # Taking the inverse of this value achieves this: smaller difference -> larger inverse.
    # Adding a small epsilon to the denominator prevents division by zero if an item perfectly fits.
    residuals = available_bins_cap - item
    
    # A common strategy is to favor bins that are already somewhat full,
    # as this can lead to better overall packing. We can achieve this by
    # considering the inverse of the *current* remaining capacity of the available bins.
    # Bins with less remaining capacity are preferred.
    # We combine these two ideas.

    # Score 1: Favoring tighter fits (smaller residual capacity)
    # A higher score means a better fit.
    tight_fit_scores = 1.0 / (residuals + 1e-9)

    # Score 2: Favoring bins that are already more full (smaller current remaining capacity)
    # A higher score means a fuller bin.
    fullness_scores = 1.0 / (available_bins_cap + 1e-9)

    # Combine the scores. We can use a weighted sum.
    # A simple approach is to give equal weight, or dynamically weight them.
    # For this version, let's try to balance both:
    # Prioritize bins that leave the least amount of empty space (tight fit)
    # AND are already substantially filled.
    # We can multiply the inverse residuals by a factor related to fullness.
    # Or, let's use a logarithmic transformation to dampen extreme values and then sum.

    # Let's try a simpler heuristic that aims to be more adaptive by
    # considering not just the immediate fit, but also the potential
    # for future packing.
    # Consider the "waste" created by placing the item in a bin.
    # Waste = remaining_capacity - item
    # We want to minimize waste.
    # So, we want to maximize 1 / (remaining_capacity - item + epsilon).
    # This is similar to v1, but let's think about what makes a bin "good" beyond just fitting.
    # A bin that is nearly full is good, but also a bin that has just enough space
    # for the current item is good.

    # A different perspective: What if we want to maximize the probability
    # that this bin can accommodate *future* items?
    # This is hard to predict.

    # Let's re-evaluate the advice: "Adaptive, contextual, performance-driven, goal-alignment."
    # "Shift focus from a priori simplicity to a posteriori performance."
    # "Design heuristics that adapt to the problem's specific characteristics and performance feedback"
    # This implies we might need to consider statistics of past item sizes or bin usages.
    # However, without access to historical data or a training mechanism within the function call,
    # we're limited to the current item and current bin states.

    # Let's try a heuristic that prioritizes bins that are "almost full" but still fit the item.
    # This can be represented by the inverse of the remaining capacity after placing the item,
    # but we might want to penalize bins that are *too* empty for the current item.
    # Or, a bin that is *almost* full such that this item perfectly fills it might be very good.

    # Consider a score that is high when (available_bins_cap - item) is small,
    # and also considers how full the bin *was* before placing the item.
    # Let's consider the ratio of the item size to the bin's remaining capacity.
    # A ratio close to 1 means a tight fit.
    # `item / available_bins_cap`

    # Another angle: "Best Fit Decreasing" is a common offline strategy. For online,
    # "Best Fit" is often used. Best Fit means choosing the bin with the smallest
    # remaining capacity that can still accommodate the item.
    # This means minimizing `available_bins_cap - item`.
    # So, we want to maximize `1 / (available_bins_cap - item + epsilon)`.
    # This is what v1 essentially does.

    # Let's try to incorporate the "fullness" of the bin more directly.
    # Suppose we have bins with remaining capacities [10, 5, 2]. Item size is 3.
    # Available bins are [10, 5].
    # v1 would calculate:
    # For bin with cap 10: 10 / (10 - 3 + eps) = 10 / 7 ≈ 1.42
    # For bin with cap 5:  5 / (5 - 3 + eps) = 5 / 2 = 2.5
    # v1 picks the bin with capacity 5.

    # What if we want to prioritize bins that are ALMOST full, even if they are not the tightest fit for *this* item?
    # Example: Bin capacities [10, 5]. Item size 1.
    # Available bins: [10, 5].
    # v1:
    # Cap 10: 10 / (10 - 1 + eps) = 10 / 9 ≈ 1.11
    # Cap 5:  5 / (5 - 1 + eps) = 5 / 4 = 1.25
    # v1 picks bin with capacity 5.

    # Alternative: Prioritize bins that are "most full" among the available ones.
    # This would mean picking the bin with the smallest remaining capacity *before* placing the item.
    # So, pick bin with capacity 5.

    # Let's combine: We want a tight fit, but among tight fits, we prefer fuller bins.
    # Or, among fuller bins, we prefer tighter fits.

    # Let's define priority as a score that is high if the bin is "good".
    # What is a "good" bin?
    # 1. It can fit the item.
    # 2. It leaves minimal wasted space. (Maximize `1 / (cap - item)`)
    # 3. It is already substantially full. (Maximize `1 / cap`)

    # Let's try a multiplicative approach: combining the inverse residual and inverse capacity.
    # score = (1 / (residuals + 1e-9)) * (1 / (available_bins_cap + 1e-9))
    # score = 1 / ((residuals + 1e-9) * (available_bins_cap + 1e-9))

    # Consider the penalty for *not* using a bin.
    # If we put the item in bin `i`, the "cost" is `bins_remain_cap[i] - item`.
    # We want to minimize this cost.
    # So we want to maximize `1 / (bins_remain_cap[i] - item + epsilon)`.

    # Let's consider the "opportunity cost". By using a bin, we reduce its capacity.
    # If we use a nearly full bin for a small item, we might be wasting the bin's potential for larger items later.
    # This suggests we should favor using bins that are *just* large enough, or less full bins.
    # This contradicts the "fuller bins are better" idea.

    # Let's go back to the advice: "adaptive, contextual, performance-driven".
    # The simplest form of "context" we have is the current item size and bin capacities.
    # "Performance-driven" suggests we might try to learn or adapt over time, but this function is stateless.
    # So, we need a heuristic that, based on the *current snapshot*, makes a choice that is *likely* to lead to good performance.

    # Consider the "regret" of not picking a bin.
    # If we pick bin A, we don't get to use its remaining capacity for something else.
    # If we pick bin B, we don't get to use its remaining capacity.

    # Let's define a score based on how "efficiently" the item is packed into the bin.
    # Efficiency could be measured as `item / bin_capacity_before_packing`.
    # We want to maximize this, meaning we prefer to pack larger items into larger bins (if capacity allows).
    # But we also want to minimize the number of bins.

    # Let's try a heuristic that combines the Best Fit idea (minimize `residual`) with
    # the idea of using up existing capacity effectively.
    # If we have two bins that are equally "tight" fits (same residual),
    # which one should we pick?
    # Maybe the one that was fuller? Or emptier?

    # What if we consider the "value" of the bin capacity?
    # Let's define a score that increases with tightness and increases with existing fullness.
    # score = f(item, bin_rem_cap)
    # We want to maximize this score.

    # Option: Prioritize bins that leave the smallest *relative* remainder.
    # Relative remainder = (bin_rem_cap - item) / bin_rem_cap
    # We want to minimize this relative remainder.
    # So, maximize 1 / ((bin_rem_cap - item) / bin_rem_cap + epsilon)
    # Maximize bin_rem_cap / (bin_rem_cap - item + epsilon)
    # This is very similar to v1, but now it's `bin_rem_cap` in numerator instead of `available_bins_cap`.

    # Let's try a heuristic that focuses on reducing the *total* remaining capacity across all bins.
    # If we place `item` in `bins_remain_cap[i]`, the new remaining capacity is `bins_remain_cap[i] - item`.
    # The change in total remaining capacity is `(bins_remain_cap[i] - item) - bins_remain_cap[i] = -item`.
    # This is constant regardless of which bin we choose. So this doesn't help differentiate.

    # Let's try to make v1 more "contextual" by giving a bonus to bins that are very full.
    # We already calculated `inverse_distances` which favors tight fits.
    # Let's add a component that favors bins that are generally "full".
    # A measure of fullness could be `1.0 / bins_remain_cap`.

    # Let's combine `inverse_distances` (from v1) with `fullness_scores`.
    # We can sum them or multiply them.
    # Summing: `priorities[available_bins_mask] = inverse_distances + fullness_scores`
    # Multiplying: `priorities[available_bins_mask] = inverse_distances * fullness_scores`

    # Let's analyze the multiplication:
    # `score = (available_bins_cap / (available_bins_cap - item + 1e-9)) * (1 / (available_bins_cap + 1e-9))`
    # `score = 1 / ((available_bins_cap - item + 1e-9) * (available_bins_cap + 1e-9) / available_bins_cap)`
    # `score = available_bins_cap / ((available_bins_cap - item + 1e-9) * (available_bins_cap + 1e-9))`
    # This amplifies the preference for tight fits when the bin is also full.
    # Example: Item=3. Bins: Cap=10, Cap=5.
    # Bin 1 (Cap 10):
    #   v1: 10 / (10-3+eps) = 10/7 ≈ 1.42
    #   v2 (mult): (10/7) * (1/10) = 1.42 / 10 = 0.142
    # Bin 2 (Cap 5):
    #   v1: 5 / (5-3+eps) = 5/2 = 2.5
    #   v2 (mult): (5/2) * (1/5) = 2.5 / 5 = 0.5
    # This still picks bin 5.

    # Let's try summing:
    # `score = (available_bins_cap / (available_bins_cap - item + 1e-9)) + (1 / (available_bins_cap + 1e-9))`
    # Example: Item=3. Bins: Cap=10, Cap=5.
    # Bin 1 (Cap 10):
    #   v1: 1.42
    #   fullness: 1/10 = 0.1
    #   v2 (sum): 1.42 + 0.1 = 1.52
    # Bin 2 (Cap 5):
    #   v1: 2.5
    #   fullness: 1/5 = 0.2
    #   v2 (sum): 2.5 + 0.2 = 2.7
    # This still picks bin 5.

    # The advice "Avoid over-reliance on 'tight fit' or 'almost full' metaphors"
    # suggests we should look for something else.
    # What if we consider the *proportion* of remaining capacity to the item size?
    # `available_bins_cap / item`
    # If this ratio is small, it's a tighter fit. We want to minimize this ratio.
    # So we want to maximize `item / available_bins_cap`.

    # Let's consider the "cost" of using a bin, where cost is the remaining capacity itself.
    # We want to use a bin that has enough capacity, and among those, pick the one with the smallest capacity.
    # This is "Best Fit".
    # `priority = 1 / (available_bins_cap + epsilon)` (higher score for smaller capacity)

    # What if we consider the *difference* between `available_bins_cap` and `item`?
    # We want to minimize `available_bins_cap - item`.
    # So we want to maximize `1 / (available_bins_cap - item + epsilon)`. This is v1.

    # Let's try to make it "adaptive" by considering the *average* remaining capacity
    # or the *distribution* of remaining capacities. This is beyond the scope of this function.

    # Let's revisit the "tightness" idea but with a different perspective.
    # Instead of `1 / residual`, let's use a function that is high for small residuals.
    # A Gaussian-like function centered at 0 residual might work, but it's complex.

    # Let's consider a metric that is high when the remaining capacity is *just* enough or slightly more than the item.
    # For example, a function `f(residual)` where `f(0)` is high, and it decreases as `residual` increases.
    # `f(x) = 1 / (x + 1)` or `f(x) = exp(-x)`.

    # Let's try a different approach inspired by "First Fit Decreasing" but for online.
    # We want to pack large items first. But we don't control the item arrival order.
    # When an item arrives, we want to place it such that it "disrupts" the packing the least,
    # or opens up the best possibilities for future items.

    # Consider a score that represents the "quality" of the fit.
    # A good fit means minimal waste.
    # Let's try a score that rewards fitting the item into a bin that is already quite full.
    # Score = (1 / (available_bins_cap - item + 1e-9)) * (available_bins_cap)
    # This prioritizes bins where the item takes up a large fraction of the remaining capacity,
    # and among those, it prioritizes bins that were initially more full.

    # Example: Item=3. Bins: Cap=10, Cap=5.
    # Bin 1 (Cap 10):
    #   residual = 7
    #   score = (10 / (10 - 3 + eps)) * 10 = (10/7) * 10 ≈ 1.42 * 10 = 14.2
    # Bin 2 (Cap 5):
    #   residual = 2
    #   score = (5 / (5 - 3 + eps)) * 5 = (5/2) * 5 = 2.5 * 5 = 12.5
    # This heuristic picks the bin with capacity 10. This favors using bins that are more full.

    # Let's try the opposite: prioritize bins that are less full, among those that fit.
    # This could be `1 / (available_bins_cap - item + 1e-9) * (1 / available_bins_cap)`
    # This is the multiplicative score we saw earlier.

    # Let's consider a penalty based on the remaining capacity *after* packing.
    # We want to minimize `available_bins_cap - item`.
    # A simple transformation for prioritization is `1 / (available_bins_cap - item + epsilon)`.

    # Let's try to create a score that is sensitive to the relative difference.
    # We want `available_bins_cap - item` to be small.
    # Consider the ratio `(available_bins_cap - item) / available_bins_cap`. We want to minimize this.
    # So, maximize `available_bins_cap / (available_bins_cap - item + epsilon)`. This is v1.

    # What if we want to make sure we don't fill up bins too quickly with small items?
    # This suggests we should avoid placing a small item into a bin that is already quite full,
    # if there's another bin that is less full but can still accommodate it.

    # Let's consider a score that penalizes using up a bin that is already close to capacity.
    # Score = `(1 / (available_bins_cap - item + epsilon))` - `penalty(available_bins_cap)`
    # Or, `(1 / (available_bins_cap - item + epsilon)) * f(available_bins_cap)`
    # If `f` decreases with `available_bins_cap`, we prefer less full bins.

    # Let's try a score that rewards filling a bin as much as possible.
    # This means minimizing the remaining capacity `available_bins_cap - item`.
    # So, we want to maximize `1 / (available_bins_cap - item + epsilon)`.

    # Let's reconsider the "adaptive" aspect.
    # The "context" is the item size and the current bin state.
    # If we have many bins with similar remaining capacities, the choice matters less for immediate fit.
    # If we have one bin that is "perfectly" sized (residual=0), that might be ideal.
    # If we have bins that are very full, they might be good candidates.

    # Let's try a score that is proportional to how much of the bin's *remaining capacity* is used.
    # `item / available_bins_cap`. Maximize this.
    # This favors packing larger items into bins that have just enough space.

    # Example: Item=3. Bins: Cap=10, Cap=5.
    # Bin 1 (Cap 10):
    #   score = 3 / 10 = 0.3
    # Bin 2 (Cap 5):
    #   score = 3 / 5 = 0.6
    # This picks bin 5.

    # Example: Item=1. Bins: Cap=10, Cap=5.
    # Bin 1 (Cap 10):
    #   score = 1 / 10 = 0.1
    # Bin 2 (Cap 5):
    #   score = 1 / 5 = 0.2
    # This picks bin 5.

    # Let's combine the Best Fit idea (minimize residual) with the "item utilization" idea.
    # Best Fit is `1 / (residual + epsilon)`.
    # Item Utilization is `item / available_bins_cap`.

    # Consider a score that is the inverse of the sum of residual and a penalty for using a very full bin.
    # This is getting complicated without empirical testing.

    # Let's try to implement a heuristic that is sensitive to the "gap" between `available_bins_cap` and `item`.
    # We want this gap to be small.
    # `gap = available_bins_cap - item`
    # We want to prioritize small gaps.
    # Consider the score: `1.0 / (gap + 1e-9)` - This is v1.

    # What if we want to penalize using a bin where `available_bins_cap` is much larger than `item`?
    # Example: Item=1. Bins: [100, 10]. Both fit.
    # v1:
    # Bin 100: 100 / (100 - 1 + eps) = 100 / 99 ≈ 1.01
    # Bin 10:  10 / (10 - 1 + eps) = 10 / 9 ≈ 1.11
    # v1 picks bin 10.

    # Let's try a heuristic that emphasizes fitting the item into a bin that is ALMOST full.
    # A bin is "almost full" if `available_bins_cap` is close to the bin's original capacity.
    # This information is not available here.

    # Let's focus on the available capacity.
    # If we have `available_bins_cap` and `item`.
    # We want to select a bin `i` such that `available_bins_cap[i]` is minimized, subject to `available_bins_cap[i] >= item`.
    # This is "Best Fit".
    # So, we want to maximize `1.0 / (available_bins_cap[i] + epsilon)`.

    # Let's try combining "Best Fit" with a measure of how "tight" the fit is.
    # Tightness = `item / available_bins_cap`. We want to maximize this.
    # So, combine `1.0 / (available_bins_cap + epsilon)` and `item / available_bins_cap`.

    # Try adding them:
    # `score = 1.0 / (available_bins_cap + epsilon) + item / available_bins_cap`
    # Example: Item=3. Bins: Cap=10, Cap=5.
    # Bin 10: 1/10 + 3/10 = 0.1 + 0.3 = 0.4
    # Bin 5:  1/5 + 3/5 = 0.2 + 0.6 = 0.8
    # Picks bin 5.

    # Example: Item=1. Bins: Cap=10, Cap=5.
    # Bin 10: 1/10 + 1/10 = 0.1 + 0.1 = 0.2
    # Bin 5:  1/5 + 1/5 = 0.2 + 0.2 = 0.4
    # Picks bin 5.

    # This heuristic prioritizes bins that are less full AND have a relatively good fit.

    # Let's try a different combination inspired by "Minimize Waste".
    # Waste = `available_bins_cap - item`. We want to minimize this.
    # Maximize `1 / (available_bins_cap - item + epsilon)`. (This is v1)

    # What if we consider the reciprocal of the *slack*?
    # Slack = `available_bins_cap - item`.
    # Score = `1.0 / (slack + 1e-9)`

    # Let's try to introduce a non-linearity or a different functional form.
    # Consider the "fullness ratio" of the bin if the item is placed in it.
    # `fill_ratio_after = item / (available_bins_cap - (available_bins_cap - item))` which is `item / available_bins_cap`.
    # This is the utilization.

    # Let's try to boost the score for bins where the item fills a large *proportion* of the remaining space.
    # This is `item / (available_bins_cap - item)` - this is what v1 is indirectly maximizing.

    # Consider the ratio of available capacity to the item size.
    # If this ratio is close to 1, it's a good fit.
    # We want to minimize `available_bins_cap / item`.
    # So, maximize `item / available_bins_cap`.

    # Let's try a score that is the product of "tightness" and "fullness".
    # Tightness score: `1.0 / (available_bins_cap - item + 1e-9)`
    # Fullness score: `1.0 / (available_bins_cap + 1e-9)`
    # Product score: `(available_bins_cap) / ((available_bins_cap - item + 1e-9) * (available_bins_cap + 1e-9))`

    # Example: Item=3. Bins: Cap=10, Cap=5.
    # Bin 10: 10 / ((10-3+eps) * (10+eps)) = 10 / (7 * 10) = 1/7 ≈ 0.142
    # Bin 5:  5 / ((5-3+eps) * (5+eps)) = 5 / (2 * 5) = 5/10 = 0.5
    # Picks bin 5.

    # This heuristic favors tighter fits AND fuller bins.

    # Let's consider a score that emphasizes minimizing the residual, but with a penalty
    # if the bin is "too empty".
    # A bin is "too empty" if `available_bins_cap` is much larger than `item`.
    # So, we could subtract `C * available_bins_cap` from `1 / (available_bins_cap - item + epsilon)`.

    # `score = 1.0 / (available_bins_cap - item + 1e-9) - C * available_bins_cap`
    # Let's choose C such that it's a penalty. For example, C=0.1.

    # Example: Item=3. Bins: Cap=10, Cap=5.
    # Bin 10: 1/(10-3+eps) - 0.1*10 = 1/7 - 1 ≈ 1.42 - 1 = 0.42
    # Bin 5:  1/(5-3+eps) - 0.1*5 = 1/2 - 0.5 = 0.5 - 0.5 = 0.0
    # This picks bin 10.

    # Example: Item=1. Bins: Cap=10, Cap=5.
    # Bin 10: 1/(10-1+eps) - 0.1*10 = 1/9 - 1 ≈ 1.11 - 1 = 0.11
    # Bin 5:  1/(5-1+eps) - 0.1*5 = 1/4 - 0.5 = 0.25 - 0.5 = -0.25
    # This picks bin 10.

    # This heuristic penalizes using less full bins, favoring tighter fits more strongly.
    # The coefficient C would need tuning.

    # Let's try a heuristic that prioritizes bins that leave a small *relative* remaining capacity.
    # Relative remaining capacity = `(available_bins_cap - item) / available_bins_cap`.
    # We want to minimize this ratio. So, maximize its inverse: `available_bins_cap / (available_bins_cap - item + epsilon)`.
    # This is v1.

    # Let's consider the "degree of filling" as `item / B`, where B is original bin capacity.
    # We don't have B.

    # What if we consider the sum of available capacities as a context?
    # Not possible within the function signature.

    # Let's try a heuristic that is aggressive in filling bins, prioritizing tighter fits.
    # The reciprocal of the residual `1.0 / (available_bins_cap - item + 1e-9)` is the core.
    # To differentiate between similar residuals, we could add a secondary criterion.
    # Secondary criterion: Prioritize bins that are already more full.
    # This means favoring smaller `available_bins_cap`.
    # So, we want to add a term that is higher for smaller `available_bins_cap`.
    # A simple term is `1.0 / (available_bins_cap + epsilon)`.

    # Let's define `v2` as the sum of these two:
    # `score = (1.0 / (available_bins_cap - item + 1e-9)) + (1.0 / (available_bins_cap + 1e-9))`
    # This prioritizes tight fits, and among those, it prioritizes fuller bins.

    # Let's use the same calculation as v1 but perhaps modify the calculation of the distance.
    # v1: `inverse_distances = available_bins_cap / (available_bins_cap - item + 1e-9)`
    # This is essentially `1 + item / (available_bins_cap - item + 1e-9)`.
    # It rewards a large `item / residual` ratio.

    # Let's try to combine the "best fit" (minimize `available_bins_cap - item`)
    # with "first fit" idea, which is more about reducing the number of bins.

    # What if we prioritize bins that are "almost full" by a small margin?
    # Consider `f(residual) = exp(-residual)`.
    # We want to maximize `exp(-(available_bins_cap - item))`.

    # Let's try a heuristic that is sensitive to the ratio `item / available_bins_cap`.
    # We want this ratio to be high, meaning the item is a significant portion of the bin's remaining capacity.
    # Score = `item / available_bins_cap`

    # Let's try to create a score that is high when `available_bins_cap` is close to `item`.
    # We want to minimize `available_bins_cap - item`.
    # So, we want to maximize `1.0 / (available_bins_cap - item + 1e-9)`.

    # Let's try to scale this by the initial bin capacity, if available. It's not.

    # Consider a score that combines tightness and fullness.
    # A good bin is one that fits the item snugly AND is already reasonably full.
    # Score = (Item utilization) * (Bin fullness)
    # Item utilization = `item / available_bins_cap`
    # Bin fullness = `1.0 / available_bins_cap` (Higher is fuller)
    # Score = `(item / available_bins_cap) * (1.0 / available_bins_cap)`
    # Score = `item / (available_bins_cap**2 + 1e-9)`

    # Example: Item=3. Bins: Cap=10, Cap=5.
    # Bin 10: 3 / (10*10) = 3 / 100 = 0.03
    # Bin 5:  3 / (5*5) = 3 / 25 = 0.12
    # Picks bin 5.

    # Example: Item=1. Bins: Cap=10, Cap=5.
    # Bin 10: 1 / (10*10) = 1 / 100 = 0.01
    # Bin 5:  1 / (5*5) = 1 / 25 = 0.04
    # Picks bin 5.

    # This heuristic favors bins that are less full.

    # Let's try to make it more "adaptive" by considering the *relative* gap.
    # Gap = `available_bins_cap - item`.
    # We want this gap to be small.
    # Consider `score = 1.0 / (available_bins_cap - item + 1e-9)`. This is v1.

    # Let's try to combine "minimize residual" and "minimize remaining capacity".
    # Best Fit: minimize `available_bins_cap - item`. Maximize `1 / (res + eps)`.
    # First Fit: pick first available.
    # Worst Fit: maximize `available_bins_cap - item`. Minimize `1 / (res + eps)`.

    # Let's try a heuristic that prioritizes bins that are "just right".
    # A bin is "just right" if `available_bins_cap` is close to `item`.
    # So, we want `available_bins_cap - item` to be small.
    # Maximize `1.0 / (available_bins_cap - item + 1e-9)`. This is v1.

    # Let's think about "performance-driven". What if we try to pack items into bins
    # such that the number of items per bin is maximized, or the total remaining capacity
    # is minimized.

    # Consider a score that is the inverse of the "waste" created.
    # Waste = `available_bins_cap - item`.
    # Maximize `1.0 / (available_bins_cap - item + 1e-9)`. This is v1.

    # Let's try to implement a heuristic that captures the idea of "tight fit"
    # but also considers the overall fullness of the bin.
    # The prompt advises against "tight fit" metaphors.

    # Let's consider the problem as trying to utilize the space as much as possible.
    # We want to pick a bin where the item occupies a large fraction of its *remaining* capacity.
    # Metric: `item / available_bins_cap`. We want to maximize this.
    # This is equivalent to minimizing `available_bins_cap / item`.

    # Let's combine "Best Fit" (`1 / (res + eps)`) with this utilization metric (`item / avail_cap`).
    # If we add them:
    # `score = 1.0 / (available_bins_cap - item + 1e-9) + item / available_bins_cap`
    # Example: Item=3. Bins: Cap=10, Cap=5.
    # Bin 10: 1/(7) + 3/10 = 0.142 + 0.3 = 0.442
    # Bin 5:  1/(2) + 3/5 = 0.5 + 0.6 = 1.1
    # Picks bin 5.

    # If we multiply them:
    # `score = (1.0 / (available_bins_cap - item + 1e-9)) * (item / available_bins_cap)`
    # `score = item / ((available_bins_cap - item + 1e-9) * available_bins_cap)`

    # Example: Item=3. Bins: Cap=10, Cap=5.
    # Bin 10: 3 / (7 * 10) = 3 / 70 ≈ 0.042
    # Bin 5:  3 / (2 * 5) = 3 / 10 = 0.3
    # Picks bin 5.

    # This suggests that prioritizing bins that are less full but offer a tight fit is preferred by this metric.

    # Let's try a different approach. What if we want to maximize the remaining capacity *after* packing the item,
    # but only among bins that are "efficiently" used?

    # The prompt also mentions "goal-alignment". For bin packing, the goal is usually minimizing the number of bins.
    # Heuristics that lead to more packed bins are generally better.

    # Let's consider the "regret" of not using a bin.
    # If we use bin `i`, the regret is the remaining capacity `available_bins_cap[i] - item`.
    # We want to minimize regret.
    # So, we want to minimize `available_bins_cap[i] - item`.
    # This is Best Fit.

    # Let's try a heuristic that is sensitive to the *ratio* of the bin's remaining capacity to the item size.
    # We want this ratio to be as close to 1 as possible.
    # Metric: `available_bins_cap / item`. We want to minimize this.
    # So, maximize `item / available_bins_cap`.

    # Let's combine Best Fit (`1 / (residual + eps)`) with this ratio (`item / available_bins_cap`).
    # Consider a score that is the *product* of these two desirable properties.
    # `score = (1.0 / (available_bins_cap - item + 1e-9)) * (item / available_bins_cap)`
    # `score = item / ((available_bins_cap - item + 1e-9) * available_bins_cap)`

    # Let's analyze this again:
    # It prioritizes bins where `item / available_bins_cap` is high AND `1 / (available_bins_cap - item)` is high.
    # This means it prioritizes bins where the item is a large fraction of the bin's capacity,
    # AND the residual capacity is small.

    # Example: Item=3. Bins: Cap=10, Cap=5.
    # Bin 10: 3 / ((10-3+eps) * 10) = 3 / (7 * 10) ≈ 0.042
    # Bin 5:  3 / ((5-3+eps) * 5) = 3 / (2 * 5) = 3 / 10 = 0.3
    # Picks bin 5.

    # Example: Item=1. Bins: Cap=10, Cap=5.
    # Bin 10: 1 / ((10-1+eps) * 10) = 1 / (9 * 10) ≈ 0.011
    # Bin 5:  1 / ((5-1+eps) * 5) = 1 / (4 * 5) = 1 / 20 = 0.05
    # Picks bin 5.

    # This heuristic seems to favor bins that are less full but provide a good fit.
    # It's similar to v1 but with a different scaling.

    # Let's try to introduce a penalty for using bins that are "too full" relative to the item.
    # If `available_bins_cap` is much larger than `item`, the `item / available_bins_cap` ratio will be small.
    # This heuristic already implicitly penalizes bins that are too large.

    # What if we try to prioritize bins that are "nearly full" but can still fit the item?
    # This means `available_bins_cap` is close to its original capacity, but we don't know that.
    # So we need to use `available_bins_cap` itself.

    # Let's consider a score that is high when `available_bins_cap - item` is minimized,
    # and as a tie-breaker, `available_bins_cap` is also minimized.
    # This is equivalent to picking the bin that is "best fit" and then "first fit" among best fits.

    # Let's try a heuristic that rewards using bins that are "almost full",
    # meaning `available_bins_cap` is large, but still fitting the item.
    # We want `available_bins_cap - item` to be small.
    # Score = `available_bins_cap - C * (available_bins_cap - item)`
    # If C=1, score = `item`.
    # If C > 1, we penalize the residual more.

    # Let's use the sum of two inverted terms:
    # Term 1: Prioritize small remaining capacity after packing (tight fit)
    # `1.0 / (available_bins_cap - item + 1e-9)`
    # Term 2: Prioritize bins that are already fuller (smaller current remaining capacity)
    # `1.0 / (available_bins_cap + 1e-9)`

    # Let's try a weighted sum:
    # `score = w1 * (1.0 / (available_bins_cap - item + 1e-9)) + w2 * (1.0 / (available_bins_cap + 1e-9))`
    # If w1=1, w2=0, it's essentially v1.
    # If w1=0, w2=1, it's pure "Best Fit".

    # Let's try w1=1, w2=0.5. This leans towards tight fits but also considers fullness.

    # Final attempt at a novel heuristic for this context:
    # We want to minimize the wasted space.
    # Wasted space = `available_bins_cap - item`.
    # We want to select a bin that minimizes this.
    # So, we want to maximize `1.0 / (available_bins_cap - item + 1e-9)`.

    # Let's consider the *ratio* of the item size to the bin's available capacity.
    # `item / available_bins_cap`. We want this ratio to be as high as possible.
    # This indicates the item takes up a significant portion of the bin's current remaining space.

    # Let's try to combine these two ideas.
    # Heuristic: Prioritize bins where the item utilization is high AND the residual capacity is low.
    # Metric = `(item / available_bins_cap) * (1.0 / (available_bins_cap - item + 1e-9))`
    # Metric = `item / (available_bins_cap * (available_bins_cap - item + 1e-9))`

    # Example: Item=3. Bins: Cap=10, Cap=5.
    # Bin 10: 3 / (10 * (10 - 3 + eps)) = 3 / (10 * 7) = 3 / 70 ≈ 0.042
    # Bin 5:  3 / (5 * (5 - 3 + eps)) = 3 / (5 * 2) = 3 / 10 = 0.3
    # Picks bin 5.

    # Example: Item=1. Bins: Cap=10, Cap=5.
    # Bin 10: 1 / (10 * (10 - 1 + eps)) = 1 / (10 * 9) ≈ 0.011
    # Bin 5:  1 / (5 * (5 - 1 + eps)) = 1 / (5 * 4) = 1 / 20 = 0.05
    # Picks bin 5.

    # This heuristic appears to favor bins that are less full but offer a good ratio of item size to bin capacity.
    # It's a variation of "Best Fit" scaled by item utilization.

    # Let's consider the prompt's advice: "adaptive, contextual, performance-driven, goal-alignment."
    # "Shift focus from a priori simplicity to a posteriori performance."
    # The current heuristic `item / (available_bins_cap * (available_bins_cap - item + 1e-9))`
    # is a plausible attempt to balance fitting the item well (`1/(res+eps)`) with efficiently using the bin (`item/avail_cap`).

    # Another idea: What if we want to select a bin that, after packing, has a remaining capacity
    # that is also likely to be useful? This is hard to predict.

    # Let's try a simple modification to v1.
    # v1 is `available_bins_cap / (available_bins_cap - item + 1e-9)`.
    # This is approximately `1 + item / (available_bins_cap - item)`.
    # It rewards a large ratio of `item / residual_space`.

    # Let's try to boost bins that are already more full.
    # So, we can add a term `1.0 / available_bins_cap`.
    # `score = (available_bins_cap / (available_bins_cap - item + 1e-9)) + (1.0 / (available_bins_cap + 1e-9))`

    # Example: Item=3. Bins: Cap=10, Cap=5.
    # Bin 10: (10/7) + (1/10) ≈ 1.42 + 0.1 = 1.52
    # Bin 5:  (5/2) + (1/5) = 2.5 + 0.2 = 2.7
    # Picks bin 5.

    # Example: Item=1. Bins: Cap=10, Cap=5.
    # Bin 10: (10/9) + (1/10) ≈ 1.11 + 0.1 = 1.21
    # Bin 5:  (5/4) + (1/5) = 1.25 + 0.2 = 1.45
    # Picks bin 5.

    # This heuristic favors tighter fits and among similar tightness, favors fuller bins.

    # Let's try to implement this sum as `priority_v2`.

    # The heuristic should be:
    # For each available bin `i` with remaining capacity `C_i`:
    # Calculate a score `S_i`.
    # Pick the bin with the maximum `S_i`.

    # We have `available_bins_cap`.
    # Let's define two components for the score:
    # 1. Tightness: Minimize `C_i - item`. Maximize `1 / (C_i - item + epsilon)`.
    # 2. Fullness: Minimize `C_i`. Maximize `1 / (C_i + epsilon)`.

    # `tightness_score = 1.0 / (available_bins_cap - item + 1e-9)`
    # `fullness_score = 1.0 / (available_bins_cap + 1e-9)`

    # Combine them: Let's use a weighted sum.
    # `score = w1 * tightness_score + w2 * fullness_score`
    # A simple choice is w1=1, w2=1 for equal emphasis.
    # Or perhaps w1=2, w2=1 to slightly emphasize tightness.

    # Let's use equal weights for simplicity as `priority_v2`.
    priorities[available_bins_mask] = (1.0 / (available_bins_cap - item + 1e-9)) + (1.0 / (available_bins_cap + 1e-9))

    return priorities
```
