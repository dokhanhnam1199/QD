```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    available_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap)

    if not np.any(available_bins_mask):
        return priorities

    available_bins_cap = bins_remain_cap[available_bins_mask]

    # Prioritize bins that leave the least remaining capacity after packing the item
    # This is a variation of the "Best Fit" strategy
    # We want to maximize the "waste" in the bin if it's not a perfect fit,
    # or minimize waste if it's a perfect fit.
    # A good proxy is to maximize (bin_capacity - item) / bin_capacity for non-perfect fits
    # and give a very high score to perfect fits.

    perfect_fit_mask = np.abs(available_bins_cap - item) < 1e-9
    non_perfect_fit_mask = ~perfect_fit_mask

    scores = np.zeros_like(available_bins_cap)

    # High score for perfect fits
    if np.any(perfect_fit_mask):
        scores[perfect_fit_mask] = 1.0

    # For non-perfect fits, prioritize bins that are "almost full" after packing
    # This encourages filling bins as much as possible.
    # We can use a metric like (bin_capacity - item) to represent the remaining space.
    # We want to minimize this remaining space, so we can invert it or use its inverse.
    # A common approach is to use (bin_capacity - item) as a penalty, and we want to minimize it.
    # To turn this into a priority (higher is better), we can use 1 / (remaining_space + epsilon).
    # Or, more robustly, we can use a function that gives higher scores to smaller remaining spaces.
    # Let's try a score that is inversely proportional to the remaining capacity after packing,
    # but with a preference for leaving *some* space rather than being completely full if not a perfect fit.
    # A simple approach is to maximize the ratio of packed item to remaining capacity,
    # effectively prioritizing bins where the item takes up a larger proportion of the remaining space.
    if np.any(non_perfect_fit_mask):
        non_perfect_caps = available_bins_cap[non_perfect_fit_mask]
        remaining_after_packing = non_perfect_caps - item
        # Use a score that emphasizes bins that are nearly full but not perfectly full.
        # A higher score means less remaining capacity after packing.
        # A simple heuristic: 1 / (remaining_capacity_after_packing + epsilon)
        # To avoid issues with very small remaining capacities, we can add a small constant.
        # Or, consider a score that penalizes leaving too much space:
        # For example, (bin_capacity - item) / bin_capacity, which ranges from 0 to 1.
        # Smaller remaining space (closer to 0) gives a score closer to 1.
        # This means we prefer bins where the item fits snugly, but not perfectly.
        scores[non_perfect_fit_mask] = (non_perfect_caps - item) / (non_perfect_caps + 1e-9)

    priorities[available_bins_mask] = scores

    return priorities
```
