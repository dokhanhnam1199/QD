[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering waste, fill ratio, and adaptive randomization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasible bins get the lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate wasted space if the item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize based on wasted space (smaller waste is better)\n    priorities[bins_remain_cap >= item] = -wasted_space[bins_remain_cap >= item] / bins_remain_cap.max()\n    \n    # Encourage filling bins, bonus based on fill ratio AFTER placement\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    priorities[bins_remain_cap >= item] += fill_ratio_after[bins_remain_cap >= item] * 0.3\n    \n    # Adaptive Randomization: Reduce randomization as bins become fuller.\n    randomization_strength = 0.1 * item * (bins_remain_cap.max() - bins_remain_cap) / bins_remain_cap.max()\n    priorities[bins_remain_cap >= item] += np.random.rand(np.sum(bins_remain_cap >= item)) * randomization_strength[bins_remain_cap >= item]\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.836457917830076,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, adaptive fill ratio, controlled randomization, and bin diversity for bin prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    feasible_bins = bins_remain_cap >= item\n\n    # Prioritize based on wasted space (smaller waste is better)\n    min_remaining_cap = np.min(bins_remain_cap)\n    priorities[feasible_bins] = -(wasted_space[feasible_bins] / min_remaining_cap) # Relative waste.\n\n    # Encourage filling bins, bonus based on fill ratio AFTER placement. Adaptive bonus.\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    item_scale = item / bins_remain_cap.max() # scale between 0 and 1.\n    priorities[feasible_bins] += fill_ratio_after[feasible_bins] * (0.2 + 0.3 * item_scale)  # bonus now depends on item size too.\n\n    # Add a small amount of randomization, scaled by item size, for exploration\n    num_items_packed = np.sum(bins_remain_cap < bins_remain_cap.max())  # crude proxy. Could be refined if necessary.\n    randomization_factor = max(0.01, 0.05 - num_items_packed * 0.0001) # Decay randomization\n    priorities[feasible_bins] += np.random.normal(0, 1, np.sum(feasible_bins)) * randomization_factor * (1 - item_scale) # Smaller items get more randomization\n\n    # Penalize bins that are too empty, but make the penalty dynamic and less aggressive\n    empty_bin_penalty = (bins_remain_cap / bins_remain_cap.max())\n    priorities[feasible_bins] -= empty_bin_penalty[feasible_bins] * (0.01 + 0.04 * (1 - fill_ratio_after[feasible_bins])) # Emptier bins get more penalty.\n\n    # Bonus for bins nearing full capacity\n    almost_full = (wasted_space < 0.1 * bins_remain_cap.max()) & feasible_bins\n    priorities[almost_full] += 0.05\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.0885520542481055,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Enhanced heuristic combining best-fit, fill ratio, and adaptive penalties.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[bins_remain_cap < item] = -np.inf  # Infeasible bins\n\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize based on wasted space\n    priorities[bins_remain_cap >= item] = -wasted_space[bins_remain_cap >= item]\n\n    # Adaptive fill ratio bonus, scaled by item size\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    item_scale = item / bins_remain_cap.max()\n    fill_bonus_weight = 0.3 * item_scale\n    priorities[bins_remain_cap >= item] += fill_ratio_after[bins_remain_cap >= item] * fill_bonus_weight\n\n    # Controlled randomization, favors exploration for smaller items\n    randomization_strength = 0.05 * (1 - item_scale)\n    priorities[bins_remain_cap >= item] += np.random.rand(np.sum(bins_remain_cap >= item)) * randomization_strength * item\n\n    # Adaptive bin-emptiness penalty\n    bin_capacity_ratio = bins_remain_cap / bins_remain_cap.max()\n    empty_bin_penalty_weight = 0.1\n    priorities[bins_remain_cap >= item] -= bin_capacity_ratio[bins_remain_cap >= item] * empty_bin_penalty_weight\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, adaptive fill ratio, controlled randomization, and dynamic bin-emptiness penalty.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get the lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Calculate wasted space\n    wasted_space = bins_remain_cap - item\n    feasible_bins = bins_remain_cap >= item\n\n    # Prioritize based on wasted space (smaller waste is better)\n    priorities[feasible_bins] = -wasted_space[feasible_bins]\n\n    # Adaptive fill ratio bonus (scale by item size relative to bin size)\n    item_scale = item / bins_remain_cap.max()\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    fill_ratio_bonus = fill_ratio_after * (0.2 + 0.3 * item_scale)  # Higher bonus for larger items\n    priorities[feasible_bins] += fill_ratio_bonus[feasible_bins]\n\n    # Controlled randomization (scale randomization by (1 - item_scale)\n    randomization_factor = 0.05 * (1 - item_scale)  # Less randomization for larger items\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * randomization_factor * item\n\n    # Adaptive bin-emptiness penalty (heavier penalty for emptier bins)\n    empty_bin_penalty = (bins_remain_cap / bins_remain_cap.max())\n    priorities[feasible_bins] -= empty_bin_penalty[feasible_bins] * (0.02 + 0.03 * empty_bin_penalty[feasible_bins])\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill ratio, controlled randomization,\n    and adaptive bin-emptiness penalty for online bin packing.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    feasible_bins = bins_remain_cap >= item\n\n    # Prioritize based on wasted space (smaller waste is better)\n    priorities[feasible_bins] = -wasted_space[feasible_bins]\n\n    # Encourage filling bins, bonus based on fill ratio AFTER placement\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    priorities[feasible_bins] += fill_ratio_after[feasible_bins] * 0.2\n\n    # Adaptive randomization, scale by (1 - item_scale) to favor smaller items\n    item_scale = item / bins_remain_cap.max()\n    randomization_factor = max(0.01, 0.05 * (1 - item_scale))\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * randomization_factor\n\n    # Adaptive bin-emptiness penalty (heavier penalty for emptier bins)\n    empty_bin_penalty = (1 - bins_remain_cap / bins_remain_cap.max())**2  # Quadratic penalty\n    priorities[feasible_bins] -= empty_bin_penalty[feasible_bins] * 0.05\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, adaptive fill ratio, controlled randomization, \n    and dynamic bin-emptiness penalty for bin prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasible bins get the lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Calculate wasted space\n    wasted_space = bins_remain_cap - item\n    feasible_bins = bins_remain_cap >= item\n    \n    # Prioritize based on wasted space (smaller waste is better)\n    priorities[feasible_bins] = -wasted_space[feasible_bins]\n    \n    # Adaptive fill ratio bonus based on item size relative to bin size\n    item_scale = item / bins_remain_cap.max()\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    fill_ratio_bonus = fill_ratio_after * (0.2 + 0.3 * item_scale)  # Adaptive bonus\n    priorities[feasible_bins] += fill_ratio_bonus[feasible_bins]\n    \n    # Controlled randomization, scale randomization by (1 - item_scale)\n    randomization_factor = 0.05 * (1 - item_scale) # Favor exploration for smaller items\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * randomization_factor\n    \n    # Adaptive bin-emptiness penalty\n    empty_bin_penalty = (bins_remain_cap / bins_remain_cap.max())\n    priorities[feasible_bins] -= empty_bin_penalty[feasible_bins] * (0.02 + 0.03 * (1 - bins_remain_cap / bins_remain_cap.max()))[feasible_bins] #Dynamic penalty\n    \n    # Bonus for bins nearing full capacity\n    almost_full = (wasted_space / bins_remain_cap.max() < 0.05) & feasible_bins #Threshold tuning\n    priorities[almost_full] += 0.1\n    \n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, adaptive fill ratio, controlled randomization, and bin-emptiness discouragement.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    feasible_bins = bins_remain_cap >= item\n\n    # Prioritize based on wasted space (smaller waste is better)\n    priorities[feasible_bins] = -wasted_space[feasible_bins]\n\n    # Adaptive fill ratio bonus, scale by item size relative to bin size\n    item_scale = item / bins_remain_cap.max()\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap)\n    priorities[feasible_bins] += fill_ratio_after[feasible_bins] * 0.2 * item_scale\n\n    # Controlled randomization, scale randomization by (1 - item_scale)\n    randomization_factor = 0.05 * (1 - item_scale)\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * randomization_factor\n\n    # Adaptive bin-emptiness penalty, heavier penalty for emptier bins\n    empty_bin_penalty = (1 - bins_remain_cap / bins_remain_cap.max())\n    priorities[feasible_bins] -= empty_bin_penalty[feasible_bins] * 0.1\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on waste, fill ratio, controlled randomization, and adaptive penalties.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities - np.inf  # All bins are infeasible\n\n    # Waste minimization with non-linear penalty\n    wasted_space = bins_remain_cap - item\n    wasted_space[~feasible_bins] = np.inf\n    priorities[feasible_bins] -= (wasted_space[feasible_bins] / bins_remain_cap.max())**2 #non-linear penalty\n\n    # Adaptive fill ratio bonus\n    fill_ratio_after = item / (bins_remain_cap[feasible_bins])\n    priorities[feasible_bins] += fill_ratio_after * 0.1\n\n    # Controlled randomization, scaled by (1 - item_scale)\n    item_scale = item / bins_remain_cap.max()\n    randomization_factor = 0.02 * (1 - item_scale)\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * randomization_factor\n    \n    #Adaptive bin-emptiness penalty\n    empty_penalty = (bins_remain_cap / bins_remain_cap.max())[feasible_bins]\n    priorities[feasible_bins] -= empty_penalty * 0.01 # scale down\n\n    # Bonus for bins nearing full capacity, reduced magnitude\n    almost_full = (wasted_space[feasible_bins] / bins_remain_cap.max()) < 0.05\n    priorities[feasible_bins][almost_full] += 0.01 # smaller bonus.\n\n    return priorities",
    "response_id": 7,
    "tryHS": true,
    "obj": 4.038691663342641,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                fill_ratio_weight: float = 0.4,\n                randomization_factor: float = 0.07,\n                empty_bin_penalty_weight: float = 0.03) -> np.ndarray:\n    \"\"\"Combines best-fit, fill ratio, randomization, empty bin penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    does_fit = bins_remain_cap >= item\n\n    if not np.any(does_fit):\n        priorities[:] = -np.inf  # Item doesn't fit, very low priority\n        return priorities\n\n    # Waste minimization\n    remaining_space = bins_remain_cap[does_fit] - item\n    priorities[does_fit] = -remaining_space\n\n    # Fill ratio bonus\n    fill_ratio = item / bins_remain_cap[does_fit]\n    priorities[does_fit] += fill_ratio * fill_ratio_weight\n\n    # Randomization\n    priorities[does_fit] += np.random.rand(np.sum(does_fit)) * randomization_factor * item\n\n    # Empty bin penalty\n    bin_utilization = bins_remain_cap[does_fit] / np.max(bins_remain_cap)\n    priorities[does_fit] -= (1 - bin_utilization) * empty_bin_penalty_weight\n    \n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using best-fit, fill ratio, adaptive randomization, and emptiness penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[bins_remain_cap < item] = -np.inf\n\n    wasted_space = bins_remain_cap - item\n    # Primary best-fit\n    priorities[bins_remain_cap >= item] = -wasted_space[bins_remain_cap >= item]**2 / bins_remain_cap.max()\n\n    # Adaptive fill ratio bonus\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    item_scale = item / bins_remain_cap.max()\n    fill_bonus_weight = 0.3 * item_scale\n    priorities[bins_remain_cap >= item] += fill_ratio_after[bins_remain_cap >= item] * fill_bonus_weight\n\n    # Adaptive Randomization, less when fuller\n    randomization_strength = 0.1 * item * (bins_remain_cap.max() - bins_remain_cap) / bins_remain_cap.max()\n    priorities[bins_remain_cap >= item] += np.random.rand(np.sum(bins_remain_cap >= item)) * randomization_strength[bins_remain_cap >= item]\n\n    # Adaptive bin-emptiness penalty\n    empty_bin_penalty = (bins_remain_cap / bins_remain_cap.max()) * (1 - item / bins_remain_cap.max())\n    empty_bin_penalty_weight = 0.03\n    priorities[bins_remain_cap >= item] -= empty_bin_penalty[bins_remain_cap >= item] * empty_bin_penalty_weight\n\n    # Bonus for bins that fit the item almost perfectly\n    almost_perfect_fit = np.exp(-wasted_space[bins_remain_cap >= item] * 5 / item)\n    priorities[bins_remain_cap >= item] += almost_perfect_fit * 0.1\n    \n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.47746310331074,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill ratio, adaptive randomization, and dynamic penalty for bin prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    feasible_bins = bins_remain_cap >= item\n\n    # Prioritize based on wasted space (smaller waste is better)\n    priorities[feasible_bins] = -wasted_space[feasible_bins]\n\n    # Encourage filling bins, bonus based on fill ratio AFTER placement\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    priorities[feasible_bins] += fill_ratio_after[feasible_bins] * 0.3  # Increased fill ratio weight\n\n    # Adaptive Randomization: Scale randomization based on the variance of remaining capacities.\n    # Higher variance suggests more diverse bin states, thus increased exploration\n    capacity_variance = np.var(bins_remain_cap[feasible_bins]) if np.any(feasible_bins) else 0.0\n    randomization_strength = 0.01 + 0.04 * (capacity_variance / bins_remain_cap.max()) # Scale randomization\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * randomization_strength * item\n    \n    # Dynamic Empty Bin Penalty:  Penalize near-empty bins, but adjust penalty strength dynamically.\n    # Stronger penalty if average bin occupancy is high (to avoid creating too many almost-empty bins).\n    average_occupancy = 1 - np.mean(bins_remain_cap / bins_remain_cap.max())\n    empty_bin_penalty_strength = 0.02 + 0.08 * average_occupancy # Dynamically adjust penalty\n\n    empty_bin_penalty = (bins_remain_cap / bins_remain_cap.max())\n    priorities[feasible_bins] -= empty_bin_penalty[feasible_bins] * empty_bin_penalty_strength\n\n    # Bonus for bins with remaining capacity close to the item size. Prevents fragmentation\n    closeness = np.abs(bins_remain_cap[feasible_bins] - item)\n    closeness_bonus = np.exp(-closeness / (0.2 * bins_remain_cap.max())) # Gaussian-like bonus\n    priorities[feasible_bins] += closeness_bonus * 0.1\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill ratio, controlled randomization, and adaptive penalization for bin prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Infeasible bins get lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize based on wasted space (smaller waste is better)\n    valid_bins = bins_remain_cap >= item\n    priorities[valid_bins] = -wasted_space[valid_bins]\n    \n    # Encourage filling bins, bonus based on fill ratio AFTER placement, adaptive bonus\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    # Adaptive bonus based on item size. Larger items get a higher bonus, since filling is more important\n    fill_bonus = fill_ratio_after[valid_bins] * (0.1 + 0.2 * (item))\n    priorities[valid_bins] += fill_bonus\n    \n    # Add a small amount of randomization, scaled by item size, for exploration, reduced randomization\n    priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * 0.02 * item\n    \n    # Penalize bins that are too empty, adaptive penalty\n    empty_bin_ratio = bins_remain_cap / bins_remain_cap.max()\n    # Adaptive penalty, penalize emptier bins more harshly, especially if item is large\n    empty_bin_penalty = empty_bin_ratio[valid_bins] * (0.02 + 0.03 * item)\n    priorities[valid_bins] -= empty_bin_penalty\n    \n    # Promote bins close to full capacity after placing item. Discourage creating very small remaining spaces.\n    nearly_full_bonus = np.zeros_like(bins_remain_cap, dtype=float)\n    nearly_full_threshold = 0.1 * bins_remain_cap.max() # Consider \"nearly full\" if remaining capacity < 10% of max\n    nearly_full_bins = (wasted_space >= 0) & (wasted_space <= nearly_full_threshold)\n    nearly_full_bonus[nearly_full_bins] = 0.1  # Flat bonus to these bins.\n\n    priorities[valid_bins] += nearly_full_bonus[valid_bins]\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit, fill ratio, adaptive randomization, and bin diversity\n    for bin prioritization, with an emphasis on exploration and preventing\n    premature bin commitment.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get the lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Calculate wasted space\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize based on wasted space (smaller waste is better)\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] = -wasted_space[feasible_bins]\n\n    # Fill ratio bonus, adaptive to the item size and bin capacity\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    \n    # Adaptive fill ratio bonus, scaled by item size and remaining capacity\n    adaptive_fill_bonus = fill_ratio_after * (0.2 + 0.1 * (item / bins_remain_cap.max()))\n    priorities[feasible_bins] += adaptive_fill_bonus[feasible_bins]\n    \n    # Adaptive Randomization: More randomization for smaller items and fuller bins\n    randomization_strength = 0.05 * item * (1 + bins_remain_cap / bins_remain_cap.max())\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * randomization_strength[feasible_bins]\n    \n    # Bin Diversity Bonus: Encourage using bins with diverse fill levels.\n    # This is done by giving a bonus to bins whose remaining capacity is \n    # furthest from the average remaining capacity of all feasible bins.\n    if np.sum(feasible_bins) > 1:\n        avg_remaining_cap = np.mean(bins_remain_cap[feasible_bins])\n        diversity_bonus = np.abs(bins_remain_cap - avg_remaining_cap) / bins_remain_cap.max()\n        priorities[feasible_bins] += diversity_bonus[feasible_bins] * 0.05\n\n    # Prevent early commitment to bins that are almost full. Penalize bins with very small remaining capacity\n    almost_full_penalty = np.where(bins_remain_cap < 1.1*item, (1-(bins_remain_cap/ (1.1*item))),0) #apply the penalty only if the bin is almost full\n    \n    \n    priorities[feasible_bins] -= almost_full_penalty[feasible_bins] * 0.1 # scaled by a factor of 0.1 for balance.\n    \n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.038691663342641,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response3.txt_stdout.txt",
    "code_path": "problem_iter9_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit, fill ratio, adaptive randomization, and bin diversity for bin prioritization.\n    This version dynamically adjusts parameters based on item size and bin capacities.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize based on wasted space (smaller waste is better)\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] = -wasted_space[feasible_bins]\n    \n    # Encourage filling bins, bonus based on fill ratio AFTER placement, adaptively scaled\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    fill_bonus_scale = min(0.3, item / bins_remain_cap.max())  # Smaller items get a slightly larger fill bonus\n    priorities[feasible_bins] += fill_ratio_after[feasible_bins] * fill_bonus_scale\n\n    # Adaptive randomization based on item size and bin availability\n    num_feasible = np.sum(feasible_bins)\n    if num_feasible > 0:\n        randomization_scale = 0.02 * item * (1 + np.log1p(num_feasible))  # More options, more exploration\n        priorities[feasible_bins] += np.random.rand(num_feasible) * randomization_scale\n\n    # Penalize bins that are too empty, adaptive penalty\n    empty_bin_ratio = bins_remain_cap / bins_remain_cap.max()\n    empty_bin_penalty_scale = min(0.1, 1/(1+item)) # Scale back penalty for very small items\n    priorities[feasible_bins] -= empty_bin_ratio[feasible_bins] * empty_bin_penalty_scale\n\n    # Bin Diversity bonus: give a slight bonus to bins with capacities furthest from mean capacity\n    mean_capacity = np.mean(bins_remain_cap[bins_remain_cap > 0]) # Ignore empty bins when calculating the mean\n    if mean_capacity > 0: #Avoid dividing by zero if all bins are empty\n        capacity_deviation = np.abs(bins_remain_cap - mean_capacity) / bins_remain_cap.max()\n        diversity_bonus_scale = 0.01 * (1 + np.log1p(item)) # Give slighly larger bonus for larger items\n        priorities[feasible_bins] += capacity_deviation[feasible_bins] * diversity_bonus_scale\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.1284403669724865,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response4.txt_stdout.txt",
    "code_path": "problem_iter9_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill ratio, controlled randomization, and adaptive penalties for bin prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasible bins get the lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate wasted space if the item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize based on wasted space (smaller waste is better)\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] = -wasted_space[feasible_bins]\n    \n    # Encourage filling bins, bonus based on fill ratio AFTER placement\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    priorities[feasible_bins] += fill_ratio_after[feasible_bins] * 0.3  # Increased fill ratio importance\n    \n    # Adaptive randomization: Smaller items get more randomization\n    randomization_scale = 0.1 * (1 - item / bins_remain_cap.max())  # Scale based on item size\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * randomization_scale\n    \n    # Adaptive empty bin penalty: Penalize near-empty bins more strongly when items are large\n    empty_bin_ratio = bins_remain_cap / bins_remain_cap.max()\n    empty_bin_penalty = empty_bin_ratio * (item / bins_remain_cap.max())  # Penalty scales with item size\n    priorities[feasible_bins] -= empty_bin_penalty[feasible_bins] * 0.1\n    \n    # Bin balancing: Slightly prioritize bins with lower fill levels overall\n    average_fill_level = np.mean(bins_remain_cap)\n    bin_balance_bonus = (average_fill_level - bins_remain_cap) / bins_remain_cap.max()\n    priorities[feasible_bins] += bin_balance_bonus[feasible_bins] * 0.05\n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, fill_ratio_weight: float = 0.14186947394776347,\n                 randomization_scale: float = 0.027543638469598338, empty_penalty_scale: float = 0.01028656195916193,\n                 almost_full_threshold: float = 0.07250345035700985, almost_full_bonus: float = 0.01859654179121566) -> np.ndarray:\n    \"\"\"Prioritizes bins based on waste, fill ratio, controlled randomization, and adaptive penalties.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities - np.inf  # All bins are infeasible",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "exec_success": true
  }
]