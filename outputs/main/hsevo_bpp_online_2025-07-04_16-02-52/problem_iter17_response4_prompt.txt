{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit, fill ratio, diversity, and adaptive randomization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get the lowest priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Feasible bins only\n    feasible_mask = bins_remain_cap >= item\n    feasible_bins_cap = bins_remain_cap[feasible_mask]\n\n    if feasible_bins_cap.size == 0:\n        return priorities\n\n    # Waste-based prioritization (smaller waste is better)\n    wasted_space = feasible_bins_cap - item\n    priorities[feasible_mask] = -wasted_space\n\n    # Fill ratio bonus, tuned for better sensitivity\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    priorities[feasible_mask] += fill_ratio_after * 0.3\n\n    # Bin diversity incentive: Reward bins with remaining capacity close to the item size\n    diversity_score = np.exp(-np.abs(wasted_space - item) / (0.1 * bins_remain_cap.max()))\n    priorities[feasible_mask] += diversity_score * 0.15\n\n    # Adaptive randomization, scaling with both item and available capacity\n    randomization_strength = 0.05 * item * (1 - wasted_space / bins_remain_cap.max())\n    priorities[feasible_mask] += np.random.rand(feasible_bins_cap.size) * randomization_strength\n\n    # Dynamic empty bin penalty, adjusting to the current bin landscape\n    average_bin_usage = np.mean(bins_remain_cap) / bins_remain_cap.max()\n    empty_bin_penalty = (bins_remain_cap / bins_remain_cap.max()) * (1 - average_bin_usage)\n    priorities[feasible_mask] -= empty_bin_penalty[feasible_mask] * 0.1\n    \n    # Encourage filling bins, bonus based on fill ratio AFTER placement\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    priorities[feasible_mask] += fill_ratio_after * 0.2\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n                fill_ratio_weight: float = 0.8056242630372064,\n                randomization_strength_base: float = 0.06711721301957442,\n                empty_bin_penalty_weight_base: float = 0.05954891384078274,\n                empty_bin_penalty_weight_occupancy_factor: float = 0.1461073097991506,\n                almost_perfect_fit_scale: float = 6.032531043023081,\n                almost_perfect_fit_weight: float = 0.26548219489652797) -> np.ndarray:\n    \"\"\"Combines adaptive fill ratio, waste minimization, and controlled randomization.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities - np.inf\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the best heuristic includes an \"empty bin penalty\" and \"reward for bins close to full,\" while the worst focuses on waste minimization, fill ratio, and randomization. The best heuristic also uses average fill to scale its \"empty bin penalty,\" while the worst doesn't consider the overall bin landscape.\n\nComparing (2nd best) vs (second worst), we see (2nd) includes an \"empty bin penalty,\" while (second worst) gives diversity bonus. The second best focuses wastespace and fillratio bonuses. The adaptive randomization strategies differ. Second best use  `item * (bins_remain_cap.max() - bins_remain_cap) / bins_remain_cap.max()` for randomization strength, while (second worst) use `0.1 * item * (np.max(bins_remain_cap) - bins_remain_cap[feasible_bins]) / np.max(bins_remain_cap)`.\n\nComparing (1st) vs (2nd), we see (1st) includes `Reward bins close to full before insertion` to encourage packing, whereas the (2nd) does not.\n\nComparing (3rd) vs (4th), we see that (3rd) use non-linear wasted space and adaptive fill ratio bonus, whereas (4th) use waste-based prioritization (smaller waste is better) for prioritizing.\n\nComparing (second worst) vs (worst), we see that both include adaptive randomization to some extent. (second worst) gives diversity bonus, and the (worst) gives bonus for almost full bins.\n\nOverall:\nThe better-performing heuristics incorporate a wider range of factors beyond just waste minimization and fill ratio. They include elements like penalties for using almost-empty bins, rewards for using almost-full bins, diversity incentives, and adaptive randomization. Scaling factors based on item size, remaining bin capacity, and overall bin landscape (average fill level) seem to improve performance. Non-linear penalties for wasted space also appear beneficial.\n- \nOkay, I'm ready to help design better heuristics, focusing on avoiding the pitfalls of ineffective self-reflection and aiming for that $999K improvement! Here's a redefined approach to \"current self-reflection\":\n\n*   **Keywords:** Adaptive, Dynamic, Exploration/Exploitation Balance, Non-linear Penalties.\n*   **Advice:** Design heuristics that dynamically adapt to the state of the problem, emphasizing exploration with small items and exploitation of nearly full bins. Use non-linear penalties for wasted space.\n*   **Avoid:** Overly simplistic, static heuristics, complex and inefficient calculations, and relying solely on remaining capacity.\n*   **Explanation:** Effective heuristics should be state-aware, balancing exploration and exploitation by dynamically adjusting parameters based on item characteristics and bin states, while avoiding premature commitment and overly simplistic or computationally expensive strategies.\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}