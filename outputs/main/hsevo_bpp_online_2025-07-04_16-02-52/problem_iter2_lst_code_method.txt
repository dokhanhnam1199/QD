{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):  # At least one bin can fit the item\n        # Prioritize bins that leave the least waste (smallest remaining capacity *after* packing)\n        remaining_capacities_after_packing = np.where(valid_bins, bins_remain_cap - item, np.inf)  # inf for bins that cannot fit\n\n        # Find the minimum remaining capacity after packing, considering *only* the bins that can fit.  Important!\n        min_remaining_cap = np.min(remaining_capacities_after_packing)\n\n\n        # A higher score means the item is preferable for packing the current item\n        priorities = -np.abs(remaining_capacities_after_packing - min_remaining_cap) # Smaller waste = higher priority\n        priorities[~valid_bins] = -np.inf  # Never choose bins that can't fit\n        #Boosting by the relative remaining capacity - small improvement in packing, but important\n\n        #Boosting if almost full: encourages filling nearly full bins, can free up bins later.\n        priorities[valid_bins] += (bins_remain_cap[valid_bins]/np.max(bins_remain_cap))*0.1  #Adding scaling parameter\n    else:\n        # No bin can fit - should never happen with unlimited bin creation in online bin packing, but good to handle edge cases.\n        # Should ideally create a new bin, but that's handled outside this function.  Return all negative infinity.\n        priorities[:] = -np.inf\n\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic: Prioritize bins where the item fits and leaves the least waste.\n    # If item doesn't fit, assign a very low priority.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate remaining space after adding the item.\n            remaining_space = cap - item\n            # Give higher priority to bins with smaller remaining space, but not zero to avoid numerical issues.\n            priorities[i] = 1 / (remaining_space + 0.001)  # Inverse of remaining space\n        else:\n            # Item doesn't fit; very low priority.\n            priorities[i] = -1e9  # A very large negative number to penalize infeasibility\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins where the item fits, giving preference to bins\n    that would have the least amount of space left over. If the item doesn't\n    fit, it penalizes the bin based on how much the item exceeds the remaining\n    capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Item fits: higher priority for less remaining space *after* placing the item.\n            priorities[i] = cap - item  # Remaining space after placing the item\n            priorities[i] = -priorities[i] # The smaller remaining space is, the more priority.\n            priorities[i] += 10 # Give fit items extra weight.\n        else:\n            # Item does not fit: penalize based on how much item exceeds the capacity.\n            priorities[i] = cap - item #negative number of exceeding size\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic: Prioritize bins where the item fits and leaves the least waste.\n    # If item doesn't fit, assign a very low priority.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate remaining space after adding the item.\n            remaining_space = cap - item\n            # Give higher priority to bins with smaller remaining space, but not zero to avoid numerical issues.\n            priorities[i] = 1 / (remaining_space + 0.001)  # Inverse of remaining space\n        else:\n            # Item doesn't fit; very low priority.\n            priorities[i] = -1e9  # A very large negative number to penalize infeasibility\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic: Prioritize bins where the item fits and leaves the least waste.\n    # If item doesn't fit, assign a very low priority.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate remaining space after adding the item.\n            remaining_space = cap - item\n            # Give higher priority to bins with smaller remaining space, but not zero to avoid numerical issues.\n            priorities[i] = 1 / (remaining_space + 0.001)  # Inverse of remaining space\n        else:\n            # Item doesn't fit; very low priority.\n            priorities[i] = -1e9  # A very large negative number to penalize infeasibility\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A bin is viable if its remaining capacity is >= item size.\n    viable_bins = bins_remain_cap >= item\n\n    # If there are no viable bins, assign a very low priority to all bins.\n    # In real life, you'd open a new bin, but let's not handle that case.\n    if not np.any(viable_bins):\n        return priorities - np.inf  # Or a very large negative number. Avoids inf with calculations below.\n\n    # Prioritize bins that have a \"good fit\" - meaning that the remaining space\n    # after adding the item will be small, but not too small.\n    remaining_after_fit = bins_remain_cap - item\n    # Add to the viable_bins condition that the remaining space is nonnegative\n    # Already asserted with viable_bins\n\n    # Give a bonus to bins where remaining_after_fit is small.  We can reward tighter fits.\n    fit_bonus = np.exp(-np.abs(remaining_after_fit) / item)  # The closer to 0, the better\n\n    # Penalize large remaining capacities.\n    # This encourages filling up bins rather than leaving big gaps.  Consider adding a scaling factor.\n    capacity_penalty = bins_remain_cap / bins_remain_cap.max() if bins_remain_cap.max() > 0 else 0 # if bins_remain_cap.max() == 0 assign to 0\n\n    priorities = viable_bins * (fit_bonus - 0.1 * capacity_penalty) # fit bonus is already multiplied with viable bins\n\n    # Adding a small random factor to break ties randomly and potentially explore the solution space.\n    priorities += np.random.rand(len(bins_remain_cap)) * 1e-6\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a very low priority (large negative value) to bins that cannot fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate the wasted space if the item is placed in the bin\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize bins with smaller wasted space (more efficient packing)\n    priorities[bins_remain_cap >= item] = -wasted_space[bins_remain_cap >= item]\n    \n    # Add a small bonus for bins that are already somewhat full.  This encourages\n    # using existing bins before starting new ones.  This is a heuristic so can be tuned.\n    priorities[bins_remain_cap >= item] += (1 - bins_remain_cap[bins_remain_cap >= item]) * 0.1\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Feynman's heuristic: A blend of best-fit, first-fit, and a dash of quantum randomness.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # 1. Best Fit Tendency (Attractive Potential)\n    residual_space = bins_remain_cap - item\n    best_fit_priority = np.where(residual_space >= 0, np.exp(-np.abs(residual_space)), -np.inf) # exponential decay towards a perfect fit. Infeasible bins get -inf\n\n    # 2. First Fit Influence (Kinetic Energy Term)\n    first_fit_priority = np.arange(len(bins_remain_cap), 0, -1) # Give earlier bins a slight edge if they fit.\n\n    # 3. Capacity Consideration (Potential Well)\n    capacity_priority = bins_remain_cap / np.sum(bins_remain_cap)  # Bins with more capacity are slightly preferred\n\n    # 4. Quantum Randomness (Tunneling Probability) - Adds Exploration\n    random_noise = np.random.normal(0, 0.01, len(bins_remain_cap))  # small random fluctuations\n\n    # 5. Combine the Priorities (Superposition of States)\n    priorities = best_fit_priority + 0.5 * first_fit_priority + 0.1 * capacity_priority + random_noise\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Emphasizes bins that can fit the item relatively well and avoids near-full bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Give a small penalty if the item doesn't fit at all.\n    does_fit = bins_remain_cap >= item\n    priorities[~does_fit] = -1e9  # Very low priority if it doesn't fit.\n\n    # Give higher priority to bins where the item fits relatively well.\n    # Calculate a \"fit ratio\" (remaining space after fitting / original bin size).\n\n    remaining_after_fit = bins_remain_cap - item\n    fit_ratio = remaining_after_fit / bins_remain_cap #Larger space remaining after fitting means higher fit_ratio\n\n    # Emphasize bins that have relatively good fit\n    priorities[does_fit] = fit_ratio[does_fit] + 1e-6 * bins_remain_cap[does_fit] # small addition in bin capacity to favour bins with larger space\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Emphasizes bins that can fit the item relatively well and avoids near-full bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Give a small penalty if the item doesn't fit at all.\n    does_fit = bins_remain_cap >= item\n    priorities[~does_fit] = -1e9  # Very low priority if it doesn't fit.\n\n    # Give higher priority to bins where the item fits relatively well.\n    # Calculate a \"fit ratio\" (remaining space after fitting / original bin size).\n\n    remaining_after_fit = bins_remain_cap - item\n    fit_ratio = remaining_after_fit / bins_remain_cap #Larger space remaining after fitting means higher fit_ratio\n\n    # Emphasize bins that have relatively good fit\n    priorities[does_fit] = fit_ratio[does_fit] + 1e-6 * bins_remain_cap[does_fit] # small addition in bin capacity to favour bins with larger space\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Emphasizes bins that can fit the item relatively well and avoids near-full bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Give a small penalty if the item doesn't fit at all.\n    does_fit = bins_remain_cap >= item\n    priorities[~does_fit] = -1e9  # Very low priority if it doesn't fit.\n\n    # Give higher priority to bins where the item fits relatively well.\n    # Calculate a \"fit ratio\" (remaining space after fitting / original bin size).\n\n    remaining_after_fit = bins_remain_cap - item\n    fit_ratio = remaining_after_fit / bins_remain_cap #Larger space remaining after fitting means higher fit_ratio\n\n    # Emphasize bins that have relatively good fit\n    priorities[does_fit] = fit_ratio[does_fit] + 1e-6 * bins_remain_cap[does_fit] # small addition in bin capacity to favour bins with larger space\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with remaining capacity slightly larger than the item size,\n    while penalizing bins that are either too small or too large. It also introduces a small\n    random factor to break ties and explore different packing configurations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n\n    # Penalize bins where the item doesn't fit (waste < 0). Give them a very low priority.\n    priorities = np.where(waste < 0, -np.inf, 0)\n\n    # Prioritize bins where waste is small but positive.  A quadratic function is used to shape the priorities.\n    # The ideal waste is near zero, and the priority decreases as waste increases.\n    # We can tune the parameters to control the shape of the priority function.\n    ideal_waste = 0.1 * item  # Aim for a bit of waste (e.g., 10% of item size)\n    priority_scale = 10 # scaling factor to influence how strongly the waste affects priority\n\n    valid_bins = waste >= 0\n    priorities[valid_bins] = priority_scale * np.exp(-((waste[valid_bins] - ideal_waste)**2) / (2 * (item/5)**2)) # Gaussian-like priority based on remaining space\n\n    # Introduce a small amount of noise to encourage exploration.\n    noise = np.random.normal(0, 0.1, size=bins_remain_cap.shape) # Normal distributed noise, scale 0.1.\n    priorities = priorities + noise\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with remaining capacity slightly larger than the item size,\n    while penalizing bins that are either too small or too large. It also introduces a small\n    random factor to break ties and explore different packing configurations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n\n    # Penalize bins where the item doesn't fit (waste < 0). Give them a very low priority.\n    priorities = np.where(waste < 0, -np.inf, 0)\n\n    # Prioritize bins where waste is small but positive.  A quadratic function is used to shape the priorities.\n    # The ideal waste is near zero, and the priority decreases as waste increases.\n    # We can tune the parameters to control the shape of the priority function.\n    ideal_waste = 0.1 * item  # Aim for a bit of waste (e.g., 10% of item size)\n    priority_scale = 10 # scaling factor to influence how strongly the waste affects priority\n\n    valid_bins = waste >= 0\n    priorities[valid_bins] = priority_scale * np.exp(-((waste[valid_bins] - ideal_waste)**2) / (2 * (item/5)**2)) # Gaussian-like priority based on remaining space\n\n    # Introduce a small amount of noise to encourage exploration.\n    noise = np.random.normal(0, 0.1, size=bins_remain_cap.shape) # Normal distributed noise, scale 0.1.\n    priorities = priorities + noise\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with remaining capacity slightly larger than the item size,\n    while penalizing bins that are either too small or too large. It also introduces a small\n    random factor to break ties and explore different packing configurations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n\n    # Penalize bins where the item doesn't fit (waste < 0). Give them a very low priority.\n    priorities = np.where(waste < 0, -np.inf, 0)\n\n    # Prioritize bins where waste is small but positive.  A quadratic function is used to shape the priorities.\n    # The ideal waste is near zero, and the priority decreases as waste increases.\n    # We can tune the parameters to control the shape of the priority function.\n    ideal_waste = 0.1 * item  # Aim for a bit of waste (e.g., 10% of item size)\n    priority_scale = 10 # scaling factor to influence how strongly the waste affects priority\n\n    valid_bins = waste >= 0\n    priorities[valid_bins] = priority_scale * np.exp(-((waste[valid_bins] - ideal_waste)**2) / (2 * (item/5)**2)) # Gaussian-like priority based on remaining space\n\n    # Introduce a small amount of noise to encourage exploration.\n    noise = np.random.normal(0, 0.1, size=bins_remain_cap.shape) # Normal distributed noise, scale 0.1.\n    priorities = priorities + noise\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A bin must have enough space\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n      # If no eligible bin exists, return a small non-zero priority to indicate any bin.\n      return np.full_like(bins_remain_cap, 1e-6)\n\n    # 1. Best Fit heuristic: Prioritize bins that leave the least space.\n    residual_capacities = bins_remain_cap - item\n    residual_capacities[~eligible_bins] = np.inf  # Exclude non-eligible bins\n\n    min_residual = np.min(residual_capacities)\n    best_fit_bins = np.isclose(residual_capacities, min_residual) #account for ties\n\n    priorities[best_fit_bins] += 1.0\n\n    # 2. Try to avoid fragmentation: bins near full should be prioritized after Best Fit.\n    # A non-linear bonus is added, meaning the fuller the bin is before the item, the higher\n    # the reward is for filling it more, compared to a relatively empty bin.\n\n    fullness = bins_remain_cap / np.max(bins_remain_cap) #scale from 0 to 1 based on capacity\n\n    priorities[eligible_bins] += np.power(fullness[eligible_bins],2)\n\n    #3 Avoid selecting bins if it will lead to small remainders after allocation. This will cause increased fragmentation.\n    too_small = (residual_capacities>0) & (residual_capacities < (np.max(bins_remain_cap)*0.1))\n    priorities[too_small] -= 0.5\n\n    #4 Add a small random component for exploration and to break symmetry\n    priorities[eligible_bins] += np.random.uniform(0, 0.1, size=np.sum(eligible_bins))\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Very small remaining capacity is penalized heavily\n    priorities[bins_remain_cap < 0.001] = -np.inf\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Prioritize bins that can fit the item\n    can_fit = remaining_after_add >= 0\n    \n    # If no bin can fit the item, prioritize the least filled bin\n    if not np.any(can_fit):\n        priorities = -bins_remain_cap\n        return priorities\n    \n    \n    #For bins that can fit, the fuller the bin the higher the priority\n    priorities[can_fit] = bins_remain_cap[can_fit]\n\n    # Adding a bonus to bins that fit almost exactly, encouraging full bins\n    almost_full = (remaining_after_add >= 0) & (remaining_after_add <= 0.1)\n    priorities[almost_full] += 5  # A bonus for almost full bins\n    \n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Very small remaining capacity is penalized heavily\n    priorities[bins_remain_cap < 0.001] = -np.inf\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Prioritize bins that can fit the item\n    can_fit = remaining_after_add >= 0\n    \n    # If no bin can fit the item, prioritize the least filled bin\n    if not np.any(can_fit):\n        priorities = -bins_remain_cap\n        return priorities\n    \n    \n    #For bins that can fit, the fuller the bin the higher the priority\n    priorities[can_fit] = bins_remain_cap[can_fit]\n\n    # Adding a bonus to bins that fit almost exactly, encouraging full bins\n    almost_full = (remaining_after_add >= 0) & (remaining_after_add <= 0.1)\n    priorities[almost_full] += 5  # A bonus for almost full bins\n    \n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., 0).  Avoid -inf when the item is larger than bin\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the fill ratio: how much of the bin will be filled by the item.\n    fill_ratio = item / bins_remain_cap\n    fill_ratio[bins_remain_cap < item] = 0  # Set ratio to 0 if the item doesn't fit\n\n    # Prefer bins where the item fits reasonably well (high fill_ratio)\n    # but avoid filling the bin completely (reducing fragmentation).\n    # We add a capacity bonus as the remain cap increases but penalize as the gap gets really small\n    suitable_bins = bins_remain_cap >= item\n    capacity_bonus = (bins_remain_cap / np.max(bins_remain_cap)) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n    gap_penalty = np.exp(-50*(bins_remain_cap-item)**2) # a quick drop when item gets too close. Tune 50 parameter to change this\n    priorities[suitable_bins] = fill_ratio[suitable_bins] + capacity_bonus[suitable_bins] - gap_penalty[suitable_bins]\n\n    # Assign a very small penalty for bins where the item doesn't fit (discourage, but don't eliminate)\n    priorities[bins_remain_cap < item] = -0.001\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by quantum mechanics and path integrals: consider the 'energy'\n    required to place the item into each bin. A lower 'energy' (more stable state)\n    should have higher priority. This uses a potential energy function related to\n    the remaining space in the bin after placing the item.  We also need to\n    introduce some 'tunneling' probability for bins that are almost full\n    to encourage exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Small constant to avoid division by zero and log of zero\n    epsilon = 1e-9\n\n    # Calculate remaining capacity after placing the item.  Negative values mean item doesn't fit.\n    remaining_cap = bins_remain_cap - item\n\n    # \"Potential Energy\" function:  higher energy for nearly full or over-full bins\n    potential_energy = np.where(remaining_cap > 0, 1 / (remaining_cap + epsilon), 1e9) # High energy if it overflows\n\n    # \"Tunneling\" effect: even if the bin is almost full, there's a small chance we still consider it, promoting exploration.\n    # A slightly filled bin is prefereable though, according to potential energy.\n    tunneling_probability = np.exp(-np.abs(remaining_cap) * 10)  # Decay fast with more fill\n\n    # Combine potential energy and tunneling: lower energy + some tunneling = higher priority\n    priorities = -potential_energy + tunneling_probability\n    \n    # Ensure we aren't selecting impossible options\n    priorities = np.where(bins_remain_cap >= item, priorities, -1e9)  # Make impossible options super low priority.\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by quantum mechanics and path integrals: consider the 'energy'\n    required to place the item into each bin. A lower 'energy' (more stable state)\n    should have higher priority. This uses a potential energy function related to\n    the remaining space in the bin after placing the item.  We also need to\n    introduce some 'tunneling' probability for bins that are almost full\n    to encourage exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Small constant to avoid division by zero and log of zero\n    epsilon = 1e-9\n\n    # Calculate remaining capacity after placing the item.  Negative values mean item doesn't fit.\n    remaining_cap = bins_remain_cap - item\n\n    # \"Potential Energy\" function:  higher energy for nearly full or over-full bins\n    potential_energy = np.where(remaining_cap > 0, 1 / (remaining_cap + epsilon), 1e9) # High energy if it overflows\n\n    # \"Tunneling\" effect: even if the bin is almost full, there's a small chance we still consider it, promoting exploration.\n    # A slightly filled bin is prefereable though, according to potential energy.\n    tunneling_probability = np.exp(-np.abs(remaining_cap) * 10)  # Decay fast with more fill\n\n    # Combine potential energy and tunneling: lower energy + some tunneling = higher priority\n    priorities = -potential_energy + tunneling_probability\n    \n    # Ensure we aren't selecting impossible options\n    priorities = np.where(bins_remain_cap >= item, priorities, -1e9)  # Make impossible options super low priority.\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}