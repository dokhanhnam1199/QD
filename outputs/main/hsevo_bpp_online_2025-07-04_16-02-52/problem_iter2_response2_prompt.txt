{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with remaining capacity slightly larger than the item size,\n    while penalizing bins that are either too small or too large. It also introduces a small\n    random factor to break ties and explore different packing configurations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n\n    # Penalize bins where the item doesn't fit (waste < 0). Give them a very low priority.\n    priorities = np.where(waste < 0, -np.inf, 0)\n\n    # Prioritize bins where waste is small but positive.  A quadratic function is used to shape the priorities.\n    # The ideal waste is near zero, and the priority decreases as waste increases.\n    # We can tune the parameters to control the shape of the priority function.\n    ideal_waste = 0.1 * item  # Aim for a bit of waste (e.g., 10% of item size)\n    priority_scale = 10 # scaling factor to influence how strongly the waste affects priority\n\n    valid_bins = waste >= 0\n    priorities[valid_bins] = priority_scale * np.exp(-((waste[valid_bins] - ideal_waste)**2) / (2 * (item/5)**2)) # Gaussian-like priority based on remaining space\n\n    # Introduce a small amount of noise to encourage exploration.\n    noise = np.random.normal(0, 0.1, size=bins_remain_cap.shape) # Normal distributed noise, scale 0.1.\n    priorities = priorities + noise\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A bin must have enough space\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n      # If no eligible bin exists, return a small non-zero priority to indicate any bin.\n      return np.full_like(bins_remain_cap, 1e-6)\n\n    # 1. Best Fit heuristic: Prioritize bins that leave the least space.\n    residual_capacities = bins_remain_cap - item\n    residual_capacities[~eligible_bins] = np.inf  # Exclude non-eligible bins\n\n    min_residual = np.min(residual_capacities)\n    best_fit_bins = np.isclose(residual_capacities, min_residual) #account for ties\n\n    priorities[best_fit_bins] += 1.0\n\n    # 2. Try to avoid fragmentation: bins near full should be prioritized after Best Fit.\n    # A non-linear bonus is added, meaning the fuller the bin is before the item, the higher\n    # the reward is for filling it more, compared to a relatively empty bin.\n\n    fullness = bins_remain_cap / np.max(bins_remain_cap) #scale from 0 to 1 based on capacity\n\n    priorities[eligible_bins] += np.power(fullness[eligible_bins],2)\n\n    #3 Avoid selecting bins if it will lead to small remainders after allocation. This will cause increased fragmentation.\n    too_small = (residual_capacities>0) & (residual_capacities < (np.max(bins_remain_cap)*0.1))\n    priorities[too_small] -= 0.5\n\n    #4 Add a small random component for exploration and to break symmetry\n    priorities[eligible_bins] += np.random.uniform(0, 0.1, size=np.sum(eligible_bins))\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st heuristic directly calculates the `min_remaining_cap` among valid bins and prioritizes bins based on their proximity to this minimum, also incorporating a small bonus for bins that are almost full and using numpy operations, leading to a more efficient and potentially better packing strategy. The 20th heuristic uses a \"potential energy\" and \"tunneling\" analogy, which might be less direct and less effective in practice due to the specific formulation of the energy and tunneling terms. Also the 1st heuristic is more concise.\n\nComparing (2nd) vs (19th), the 2nd heuristic prioritizes bins based on the inverse of remaining space and assigns very low priority to bins where the item doesn't fit, using a loop-based approach. The 19th heuristic tries to apply more complex calculations.\n\nComparing (3rd) vs (4th), the 3rd uses a simpler logic assigning priorities and extra weights to the fit items. The 4th uses the inverse of remaining space.\n\nComparing (second worst) vs (worst), the 19th and 20th heuristics are near identical.\n\nOverall: The better heuristics use numpy operations to achieve better efficiency. They calculate remaining capacities and derive priority based on capacity. More complex heuristics do not guarantee better performance.\n- \nOkay, here's a refined concept of \"Current Self-Reflection\" tailored for designing better packing heuristics, steering clear of potential pitfalls:\n\n*   **Keywords:** Capacity-focused, Computationally Efficient, Adaptive Exploration, Iterative Refinement.\n\n*   **Advice:** Emphasize quick capacity checks, explore simple randomization for diversification, and design for incremental improvement through iterative testing.\n\n*   **Avoid:** Overly complex strategies, analogies without clear performance benefits, and premature optimization.\n\n*   **Explanation:** Focus on rapid evaluation and adaptation based on remaining space. Simple, fast heuristics, combined with controlled randomness, allow efficient exploration and iterative refinement through experimentation.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}