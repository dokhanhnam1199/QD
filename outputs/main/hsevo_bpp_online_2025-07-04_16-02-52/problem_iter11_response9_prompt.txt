{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines best-fit, fill ratio, adaptive randomization, and bin diversity\n    for bin prioritization, with an emphasis on exploration and preventing\n    premature bin commitment.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get the lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Calculate wasted space\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize based on wasted space (smaller waste is better)\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] = -wasted_space[feasible_bins]\n\n    # Fill ratio bonus, adaptive to the item size and bin capacity\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    \n    # Adaptive fill ratio bonus, scaled by item size and remaining capacity\n    adaptive_fill_bonus = fill_ratio_after * (0.2 + 0.1 * (item / bins_remain_cap.max()))\n    priorities[feasible_bins] += adaptive_fill_bonus[feasible_bins]\n    \n    # Adaptive Randomization: More randomization for smaller items and fuller bins\n    randomization_strength = 0.05 * item * (1 + bins_remain_cap / bins_remain_cap.max())\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * randomization_strength[feasible_bins]\n    \n    # Bin Diversity Bonus: Encourage using bins with diverse fill levels.\n    # This is done by giving a bonus to bins whose remaining capacity is \n    # furthest from the average remaining capacity of all feasible bins.\n    if np.sum(feasible_bins) > 1:\n        avg_remaining_cap = np.mean(bins_remain_cap[feasible_bins])\n        diversity_bonus = np.abs(bins_remain_cap - avg_remaining_cap) / bins_remain_cap.max()\n        priorities[feasible_bins] += diversity_bonus[feasible_bins] * 0.05\n\n    # Prevent early commitment to bins that are almost full. Penalize bins with very small remaining capacity\n    almost_full_penalty = np.where(bins_remain_cap < 1.1*item, (1-(bins_remain_cap/ (1.1*item))),0) #apply the penalty only if the bin is almost full\n    \n    \n    priorities[feasible_bins] -= almost_full_penalty[feasible_bins] * 0.1 # scaled by a factor of 0.1 for balance.\n    \n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins considering waste, fill ratio, and adaptive randomization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasible bins get the lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate wasted space if the item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize based on wasted space (smaller waste is better)\n    priorities[bins_remain_cap >= item] = -wasted_space[bins_remain_cap >= item] / bins_remain_cap.max()\n    \n    # Encourage filling bins, bonus based on fill ratio AFTER placement\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    priorities[bins_remain_cap >= item] += fill_ratio_after[bins_remain_cap >= item] * 0.3\n    \n    # Adaptive Randomization: Reduce randomization as bins become fuller.\n    randomization_strength = 0.1 * item * (bins_remain_cap.max() - bins_remain_cap) / bins_remain_cap.max()\n    priorities[bins_remain_cap >= item] += np.random.rand(np.sum(bins_remain_cap >= item)) * randomization_strength[bins_remain_cap >= item]\n    \n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first employs a more comprehensive approach, incorporating waste minimization with a non-linear penalty, adaptive fill ratio bonuses, controlled randomization scaled by item size, adaptive bin-emptiness penalties, and bonuses for bins nearing full capacity. The 20th prioritizes waste, fill ratio, and adaptive randomization, but lacks the non-linear penalty for waste, the adaptive bin-emptiness penalty, and the bonus for almost full bins. Comparing (5th) vs (16th), the 5th introduces bin diversity and prevents early commitment to almost full bins, which are absent in the 16th. Comparing (14th) vs (15th), these functions are identical stubs with only infeasible bin handling, making them the worst. Comparing (1st) vs (5th), the first has a simpler approach, while the fifth adds more fine-grained control over penalties/bonuses based on multiple factors (item size, remaining capacity, etc). Overall: better heuristics have more comprehensive penalty and bonus mechanisms (adaptive fill ratios, bin-emptiness considerations, and near-capacity bonuses) and incorporate randomness. These mechanisms are frequently scaled based on item size and/or remaining bin capacity.\n- \nOkay, I understand. To refine \"Current self-reflection\" into something more effective for designing heuristics, avoiding the pitfalls of \"Ineffective self-reflection,\" here's a breakdown:\n\n*   **Keywords:** Multi-faceted optimization, adaptive parameters, controlled exploration, balanced approach, performance improvement.\n\n*   **Advice:** Design heuristics that simultaneously consider multiple relevant factors (e.g., waste, fill ratio, bin usage). Implement adaptive mechanisms where parameters (randomness, penalties) respond dynamically to item characteristics and bin states. Employ controlled randomness to promote exploration without sacrificing solution quality.\n\n*   **Avoid:** Overly simplistic or computationally expensive methods, relying solely on a single objective, and analogies that lack clear practical value.\n\n*   **Explanation:** Effective heuristics are rarely built upon a single idea or simple calculation. The sweet spot lies in intelligently integrating different factors and allowing the heuristic to adapt to the specific problem instance. Exploration is crucial, but it needs to be managed strategically, not just randomly thrown in.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}