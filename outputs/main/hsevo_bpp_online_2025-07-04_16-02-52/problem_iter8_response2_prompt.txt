{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit, fill ratio, and controlled randomization for bin prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Infeasible bins get lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize based on wasted space (smaller waste is better)\n    priorities[bins_remain_cap >= item] = -wasted_space[bins_remain_cap >= item]\n    \n    # Encourage filling bins, bonus based on fill ratio AFTER placement\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    priorities[bins_remain_cap >= item] += fill_ratio_after[bins_remain_cap >= item] * 0.2\n    \n    # Add a small amount of randomization, scaled by item size, for exploration\n    priorities[bins_remain_cap >= item] += np.random.rand(np.sum(bins_remain_cap >= item)) * 0.05 * item\n    \n    # Penalize bins that are too empty\n    empty_bin_penalty = (bins_remain_cap / bins_remain_cap.max())\n    priorities[bins_remain_cap >= item] -= empty_bin_penalty[bins_remain_cap >= item] * 0.05\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit, fill ratio, controlled randomization, and a bin-emptiness discouragement with adaptive parameters for enhanced bin prioritization.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get the lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize based on wasted space (smaller waste is better) - primary best-fit driver\n    priorities[bins_remain_cap >= item] = -wasted_space[bins_remain_cap >= item]\n\n    # Adaptive fill ratio bonus: scale by item size relative to bin size\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    item_scale = item / bins_remain_cap.max()  # Normalize item size to bin capacity\n    fill_bonus_weight = 0.3 * item_scale  # Larger items get a larger fill bonus, relatively\n    priorities[bins_remain_cap >= item] += fill_ratio_after[bins_remain_cap >= item] * fill_bonus_weight\n\n    # Controlled randomization: scale randomization by (1 - item_scale) to favor exploration for smaller items\n    randomization_strength = 0.05 * (1 - item_scale)\n    priorities[bins_remain_cap >= item] += np.random.rand(np.sum(bins_remain_cap >= item)) * randomization_strength * item\n\n    # Adaptive bin-emptiness penalty:  Heavier penalty for emptier bins, scaled by remaining capacity\n    bin_capacity_ratio = bins_remain_cap / bins_remain_cap.max()\n    empty_bin_penalty_weight = 0.1  #Adjust for the empty bin penalty\n    priorities[bins_remain_cap >= item] -= bin_capacity_ratio[bins_remain_cap >= item] * empty_bin_penalty_weight\n\n    # Encourage bins nearing full capacity to be filled by increasing its priority.\n    nearly_full_bonus = np.where(bins_remain_cap >= item, (bins_remain_cap.max() - bins_remain_cap) / bins_remain_cap.max(), 0)\n    nearly_full_bonus_weight = 0.2\n    priorities[bins_remain_cap >= item] += nearly_full_bonus[bins_remain_cap >= item] * nearly_full_bonus_weight\n\n    return priorities\n\n### Analyze & experience\n- *   Comparing (1st) vs (2nd), they are identical.\n*   Comparing (3rd) vs (4th), they are identical except the 3rd code allows to set hyperparameter.\n*   Comparing (5th) vs (6th), they are identical except the 5th code allows to set hyperparameter.\n*   Comparing (6th) vs (7th) to (11th), they are identical.\n*   Comparing (1st) vs (12th), the 1st code has empty bin penalty and the 12th code has not. The 1st code has randomization factor scaled by item size and 12th code uses normal distribution. The 1st code explicitly set -inf for infeasible bins.\n*   Comparing (1st) vs (13th), the 13th code has adaptive fill ratio bonus (scale by item size relative to bin size); controlled randomization (scale randomization by (1 - item_scale) to favor exploration for smaller items); adaptive bin-emptiness penalty (heavier penalty for emptier bins, scaled by remaining capacity); encourage bins nearing full capacity.\n*   Comparing (1st) vs (14th), the 14th code uses `min_remaining_cap` as waste minimization.\n*   Comparing (1st) vs (15th), the 15th code does not have `empty_bin_penalty` and `randomization`.\n*   Comparing (1st) vs (16th), the 16th code uses `min_remaining_cap` for waste minimization and does not have `empty_bin_penalty`.\n*   Comparing (1st) vs (17th), the 17th code does not have `empty_bin_penalty` and `randomization`.\n*   Comparing (1st) vs (18th), the 18th code is the same as the 13th code.\n*   Comparing (1st) vs (19th), the 19th code uses non-linear transformation to penalize larger wasted space more heavily; adaptive randomization; bonus for bins that fit the item almost perfectly.\n*   Comparing (19th) vs (20th), they are identical.\n*   Comparing (second worst) vs (worst), they are identical.\n\nOverall: The best heuristics include: best-fit, fill ratio, controlled randomization and bin-emptiness discouragement with adaptive parameters. The worst heuristics only consider minimal waste and fill ratio.\n- \nHere's a refined definition of \"Current self-reflection\" for designing better heuristics, incorporating your guidance:\n\n*   **Keywords:** Adaptive parameters, multi-objective balance, exploration, penalization, performance analysis.\n\n*   **Advice:** Design adaptive heuristics dynamically adjusting to problem state (item sizes, bin capacities). Quantify and balance waste, fill ratios, and runtime. Incorporate strategic exploration using problem-aware randomization.\n\n*   **Avoid:** Overly complex analogies. Sole reliance on simple metrics like remaining capacity. Prioritizing speed without regard to solution quality.\n\n*   **Explanation:** Effective heuristics require balancing competing objectives through adaptive, problem-aware parameters. Monitor heuristic performance on diverse instances to identify areas for improvement.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}