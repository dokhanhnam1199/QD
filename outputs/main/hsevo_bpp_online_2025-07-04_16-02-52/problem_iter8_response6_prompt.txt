{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit, fill ratio, controlled randomization, and bin diversity for bin prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    feasible_bins = bins_remain_cap >= item\n\n    # Prioritize based on wasted space (smaller waste is better)\n    priorities[feasible_bins] = -wasted_space[feasible_bins]\n\n    # Encourage filling bins, bonus based on fill ratio AFTER placement\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    priorities[feasible_bins] += fill_ratio_after[feasible_bins] * 0.2\n\n    # Add a small amount of randomization, scaled by item size, for exploration, and reduce over time as more items are packed\n    num_items_packed = np.sum(bins_remain_cap < bins_remain_cap.max())  # crude proxy. Could be refined if necessary.\n    randomization_factor = max(0.01, 0.05 - num_items_packed * 0.0001) # Decay randomization\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * randomization_factor * item\n\n    # Penalize bins that are too empty, but make the penalty dynamic and less aggressive\n    empty_bin_penalty = (bins_remain_cap / bins_remain_cap.max())\n    priorities[feasible_bins] -= empty_bin_penalty[feasible_bins] * 0.02  # Reduced penalty\n\n    # Bin Diversity Bonus: Give a small bonus to bins with very different fill levels to encourage exploration.\n\n    if np.sum(feasible_bins) > 1: # Only apply if there's more than one option\n        fill_levels = bins_remain_cap[feasible_bins] / bins_remain_cap.max()\n        fill_level_std = np.std(fill_levels)\n\n        priorities[feasible_bins] += fill_level_std * 0.03  # encourage diversity, small weight\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on minimal waste and fill ratio, using numpy.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    does_fit = bins_remain_cap >= item\n\n    if np.any(does_fit):\n        remaining_space = bins_remain_cap[does_fit] - item\n        # Prioritize smaller remaining space\n        priorities[does_fit] = 1 / (remaining_space + 0.001)\n        # Bonus for bins that are filled more completely\n        fill_ratio = item / (bins_remain_cap[does_fit] + 0.001)\n        priorities[does_fit] += fill_ratio\n    else:\n        priorities[:] = -1e9 # Item doesn't fit, very low priority\n    return priorities\n\n### Analyze & experience\n- *   Comparing (1st) vs (2nd), they are identical.\n*   Comparing (3rd) vs (4th), they are identical except the 3rd code allows to set hyperparameter.\n*   Comparing (5th) vs (6th), they are identical except the 5th code allows to set hyperparameter.\n*   Comparing (6th) vs (7th) to (11th), they are identical.\n*   Comparing (1st) vs (12th), the 1st code has empty bin penalty and the 12th code has not. The 1st code has randomization factor scaled by item size and 12th code uses normal distribution. The 1st code explicitly set -inf for infeasible bins.\n*   Comparing (1st) vs (13th), the 13th code has adaptive fill ratio bonus (scale by item size relative to bin size); controlled randomization (scale randomization by (1 - item_scale) to favor exploration for smaller items); adaptive bin-emptiness penalty (heavier penalty for emptier bins, scaled by remaining capacity); encourage bins nearing full capacity.\n*   Comparing (1st) vs (14th), the 14th code uses `min_remaining_cap` as waste minimization.\n*   Comparing (1st) vs (15th), the 15th code does not have `empty_bin_penalty` and `randomization`.\n*   Comparing (1st) vs (16th), the 16th code uses `min_remaining_cap` for waste minimization and does not have `empty_bin_penalty`.\n*   Comparing (1st) vs (17th), the 17th code does not have `empty_bin_penalty` and `randomization`.\n*   Comparing (1st) vs (18th), the 18th code is the same as the 13th code.\n*   Comparing (1st) vs (19th), the 19th code uses non-linear transformation to penalize larger wasted space more heavily; adaptive randomization; bonus for bins that fit the item almost perfectly.\n*   Comparing (19th) vs (20th), they are identical.\n*   Comparing (second worst) vs (worst), they are identical.\n\nOverall: The best heuristics include: best-fit, fill ratio, controlled randomization and bin-emptiness discouragement with adaptive parameters. The worst heuristics only consider minimal waste and fill ratio.\n- \nHere's a refined definition of \"Current self-reflection\" for designing better heuristics, incorporating your guidance:\n\n*   **Keywords:** Adaptive parameters, multi-objective balance, exploration, penalization, performance analysis.\n\n*   **Advice:** Design adaptive heuristics dynamically adjusting to problem state (item sizes, bin capacities). Quantify and balance waste, fill ratios, and runtime. Incorporate strategic exploration using problem-aware randomization.\n\n*   **Avoid:** Overly complex analogies. Sole reliance on simple metrics like remaining capacity. Prioritizing speed without regard to solution quality.\n\n*   **Explanation:** Effective heuristics require balancing competing objectives through adaptive, problem-aware parameters. Monitor heuristic performance on diverse instances to identify areas for improvement.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}