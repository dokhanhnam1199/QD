{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\nCurrent heuristics:\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit, fill ratio, and controlled randomization for bin prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Infeasible bins get lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate wasted space if item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize based on wasted space (smaller waste is better)\n    priorities[bins_remain_cap >= item] = -wasted_space[bins_remain_cap >= item]\n    \n    # Encourage filling bins, bonus based on fill ratio AFTER placement\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    priorities[bins_remain_cap >= item] += fill_ratio_after[bins_remain_cap >= item] * 0.2\n    \n    # Add a small amount of randomization, scaled by item size, for exploration\n    priorities[bins_remain_cap >= item] += np.random.rand(np.sum(bins_remain_cap >= item)) * 0.05 * item\n    \n    # Penalize bins that are too empty\n    empty_bin_penalty = (bins_remain_cap / bins_remain_cap.max())\n    priorities[bins_remain_cap >= item] -= empty_bin_penalty[bins_remain_cap >= item] * 0.05\n    \n    return priorities\n\nNow, think outside the box write a mutated function `priority_v2` better than current version.\nYou can use some hints below:\n- \nOkay, I understand. To refine \"Current self-reflection\" into something more effective for designing heuristics, avoiding the pitfalls of \"Ineffective self-reflection,\" here's a breakdown:\n\n*   **Keywords:** Multi-faceted optimization, adaptive parameters, controlled exploration, balanced approach, performance improvement.\n\n*   **Advice:** Design heuristics that simultaneously consider multiple relevant factors (e.g., waste, fill ratio, bin usage). Implement adaptive mechanisms where parameters (randomness, penalties) respond dynamically to item characteristics and bin states. Employ controlled randomness to promote exploration without sacrificing solution quality.\n\n*   **Avoid:** Overly simplistic or computationally expensive methods, relying solely on a single objective, and analogies that lack clear practical value.\n\n*   **Explanation:** Effective heuristics are rarely built upon a single idea or simple calculation. The sweet spot lies in intelligently integrating different factors and allowing the heuristic to adapt to the specific problem instance. Exploration is crucial, but it needs to be managed strategically, not just randomly thrown in.\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}