{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on waste, fill ratio, controlled randomization, and adaptive penalties.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities - np.inf  # All bins are infeasible\n\n    # Waste minimization with non-linear penalty\n    wasted_space = bins_remain_cap - item\n    wasted_space[~feasible_bins] = np.inf\n    priorities[feasible_bins] -= (wasted_space[feasible_bins] / bins_remain_cap.max())**2 #non-linear penalty\n\n    # Adaptive fill ratio bonus\n    fill_ratio_after = item / (bins_remain_cap[feasible_bins])\n    priorities[feasible_bins] += fill_ratio_after * 0.1\n\n    # Controlled randomization, scaled by (1 - item_scale)\n    item_scale = item / bins_remain_cap.max()\n    randomization_factor = 0.02 * (1 - item_scale)\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * randomization_factor\n    \n    #Adaptive bin-emptiness penalty\n    empty_penalty = (bins_remain_cap / bins_remain_cap.max())[feasible_bins]\n    priorities[feasible_bins] -= empty_penalty * 0.01 # scale down\n\n    # Bonus for bins nearing full capacity, reduced magnitude\n    almost_full = (wasted_space[feasible_bins] / bins_remain_cap.max()) < 0.05\n    priorities[feasible_bins][almost_full] += 0.01 # smaller bonus.\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit, fill ratio, controlled randomization, and adaptive penalties for bin prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasible bins get the lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate wasted space if the item is placed in each bin\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize based on wasted space (smaller waste is better)\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] = -wasted_space[feasible_bins]\n    \n    # Encourage filling bins, bonus based on fill ratio AFTER placement\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    priorities[feasible_bins] += fill_ratio_after[feasible_bins] * 0.3  # Increased fill ratio importance\n    \n    # Adaptive randomization: Smaller items get more randomization\n    randomization_scale = 0.1 * (1 - item / bins_remain_cap.max())  # Scale based on item size\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * randomization_scale\n    \n    # Adaptive empty bin penalty: Penalize near-empty bins more strongly when items are large\n    empty_bin_ratio = bins_remain_cap / bins_remain_cap.max()\n    empty_bin_penalty = empty_bin_ratio * (item / bins_remain_cap.max())  # Penalty scales with item size\n    priorities[feasible_bins] -= empty_bin_penalty[feasible_bins] * 0.1\n    \n    # Bin balancing: Slightly prioritize bins with lower fill levels overall\n    average_fill_level = np.mean(bins_remain_cap)\n    bin_balance_bonus = (average_fill_level - bins_remain_cap) / bins_remain_cap.max()\n    priorities[feasible_bins] += bin_balance_bonus[feasible_bins] * 0.05\n    \n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first employs a more comprehensive approach, incorporating waste minimization with a non-linear penalty, adaptive fill ratio bonuses, controlled randomization scaled by item size, adaptive bin-emptiness penalties, and bonuses for bins nearing full capacity. The 20th prioritizes waste, fill ratio, and adaptive randomization, but lacks the non-linear penalty for waste, the adaptive bin-emptiness penalty, and the bonus for almost full bins. Comparing (5th) vs (16th), the 5th introduces bin diversity and prevents early commitment to almost full bins, which are absent in the 16th. Comparing (14th) vs (15th), these functions are identical stubs with only infeasible bin handling, making them the worst. Comparing (1st) vs (5th), the first has a simpler approach, while the fifth adds more fine-grained control over penalties/bonuses based on multiple factors (item size, remaining capacity, etc). Overall: better heuristics have more comprehensive penalty and bonus mechanisms (adaptive fill ratios, bin-emptiness considerations, and near-capacity bonuses) and incorporate randomness. These mechanisms are frequently scaled based on item size and/or remaining bin capacity.\n- \nOkay, I understand. To refine \"Current self-reflection\" into something more effective for designing heuristics, avoiding the pitfalls of \"Ineffective self-reflection,\" here's a breakdown:\n\n*   **Keywords:** Multi-faceted optimization, adaptive parameters, controlled exploration, balanced approach, performance improvement.\n\n*   **Advice:** Design heuristics that simultaneously consider multiple relevant factors (e.g., waste, fill ratio, bin usage). Implement adaptive mechanisms where parameters (randomness, penalties) respond dynamically to item characteristics and bin states. Employ controlled randomness to promote exploration without sacrificing solution quality.\n\n*   **Avoid:** Overly simplistic or computationally expensive methods, relying solely on a single objective, and analogies that lack clear practical value.\n\n*   **Explanation:** Effective heuristics are rarely built upon a single idea or simple calculation. The sweet spot lies in intelligently integrating different factors and allowing the heuristic to adapt to the specific problem instance. Exploration is crucial, but it needs to be managed strategically, not just randomly thrown in.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}