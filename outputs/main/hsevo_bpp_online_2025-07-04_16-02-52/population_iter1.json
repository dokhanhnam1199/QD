[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a very low priority (large negative value) to bins that cannot fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate the wasted space if the item is placed in the bin\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize bins with smaller wasted space (more efficient packing)\n    priorities[bins_remain_cap >= item] = -wasted_space[bins_remain_cap >= item]\n    \n    # Add a small bonus for bins that are already somewhat full.  This encourages\n    # using existing bins before starting new ones.  This is a heuristic so can be tuned.\n    priorities[bins_remain_cap >= item] += (1 - bins_remain_cap[bins_remain_cap >= item]) * 0.1\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the concept of spacetime curvature in General Relativity.  The 'curvature'\n    represents how much a bin's fullness would change given the item. Bins that are already\n    relatively full (high 'mass density') exert a greater 'gravitational pull' and thus should\n    be prioritized.  This aims to create a more even distribution of items across bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero\n    bins_remain_cap = np.clip(bins_remain_cap, 1e-9, None)  # Ensure bins_remain_cap is always positive\n\n    # 'Curvature' is a non-linear transformation of available space to prioritize\n    # nearly-full bins. High 'bin_load' leads to a larger change after adding the item.\n    bin_load = 1 - bins_remain_cap  # Bins already filled have high bin_load\n    curvature = bin_load**2 / bins_remain_cap # Simulates gravity like effect where almost full bins have higher priorities\n\n    # The item's mass/energy determines how significantly to perturb 'spacetime' around bins.\n    perturbation = item * curvature\n\n    # Prioritization based on \"gravitational\" pull\n    priorities = perturbation\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., 0).  Avoid -inf when the item is larger than bin\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the fill ratio: how much of the bin will be filled by the item.\n    fill_ratio = item / bins_remain_cap\n    fill_ratio[bins_remain_cap < item] = 0  # Set ratio to 0 if the item doesn't fit\n\n    # Prefer bins where the item fits reasonably well (high fill_ratio)\n    # but avoid filling the bin completely (reducing fragmentation).\n    # We add a capacity bonus as the remain cap increases but penalize as the gap gets really small\n    suitable_bins = bins_remain_cap >= item\n    capacity_bonus = (bins_remain_cap / np.max(bins_remain_cap)) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n    gap_penalty = np.exp(-50*(bins_remain_cap-item)**2) # a quick drop when item gets too close. Tune 50 parameter to change this\n    priorities[suitable_bins] = fill_ratio[suitable_bins] + capacity_bonus[suitable_bins] - gap_penalty[suitable_bins]\n\n    # Assign a very small penalty for bins where the item doesn't fit (discourage, but don't eliminate)\n    priorities[bins_remain_cap < item] = -0.001\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Prioritize bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1  # Base priority for being able to fit\n\n    # Give higher priority to bins with smaller remaining capacity *but* that can still fit\n    remaining_capacity_if_fit = bins_remain_cap[can_fit] - item\n    priorities[can_fit] += 1.0 / (remaining_capacity_if_fit + 1e-9)  # Avoid division by zero\n\n    # Prioritize bins that are nearly full after placing the item, to fill them up\n    fullness_ratio = (bins_remain_cap - item) / bins_remain_cap\n    priorities[can_fit] += np.clip(1 - np.abs(fullness_ratio[can_fit]),0,1)\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Prioritize bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1\n\n    # Give higher priority to bins with smaller remaining capacity if it fits\n    remaining_after_fit = bins_remain_cap[can_fit] - item\n    priorities[can_fit] += 1 / (remaining_after_fit + 0.0001) # Avoid division by zero\n\n    # Slightly prefer bins that are close to full, even if it barely fits, so that we don't create almost empty bins\n    priorities[can_fit] += (1 - remaining_after_fit / bins_remain_cap[can_fit])\n\n    # For bins that can't fit, strongly penalize\n    priorities[~can_fit] -= 1000  # Or any very large penalty\n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the heavens! A harmonious blend of efficient space utilization\n    and strategic foresight guides our priorities. Larger bins attract\n    smaller items, while bins closely fitting the item size are favored,\n    but with a slight penalty for near-perfect fits to promote balance.\n    Think of it as celestial mechanics applied to bin packing!\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Favor bins that are large enough\n            priority = 0.0\n\n            # Smaller items are attracted to larger bins\n            priority += cap  # Give some preference for larger bin size\n\n            # The closer the fit, the better, but penalize near-perfect fits\n            fit_ratio = item / cap\n            priority += np.exp(-10 * (fit_ratio - 0.95)**2) # a slight penalty if near perfect fit to encourage re-use of partially filled bins.\n            priority += np.exp(-10 * (fit_ratio - 1.0)**2) # a stronger penalty if perfect fit is required for this single item ( encourages bins with more flexibility in future use)\n\n\n            priorities[i] = priority\n        else:\n            priorities[i] = -np.inf  # Disqualify bins that are too small\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.9999924 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by black hole accretion disks and Hawking radiation.  We want to\n    fill bins that are 'just right' -- not too empty (inefficient) and not\n    almost full (risk of exceeding capacity, high 'radiation' from near-overflow).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # A 'Hawking radiation' inspired term: Higher penalty closer to full bin\n            #  (Smaller remaining capacity after packing)\n\n            remaining_after_pack = cap - item\n            #Use modified sigmoid, to control behavior close to full\n            sigmoid_scale = 10\n            radiation_term = 1 / (1 + np.exp(sigmoid_scale*(remaining_after_pack/cap - 0.5)))  # scales remaining to 0-1 range\n\n\n            #Prefer to put in bins with moderate filling; Avoid near empty or nearly full.\n            #Parabola with min at 0.5 represents desired fill fraction\n            fill_fraction = (cap - item) / (1 + item) if item < cap else 0  #Avoid div by zero\n\n            ideal_filling_term = -((fill_fraction-0.5)**2)  #Want close to .5 for utilization\n\n            #Combine both effects for bin priority, also scale terms to adjust importance\n            priorities[i] = 0.8*ideal_filling_term - 0.2 * radiation_term # Adjust weights to control exploration-exploitation\n            # Make bins that can't fit very low priority\n        else:\n            priorities[i] = -np.inf # Very Low priority\n\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999969020000094 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Feynman's heuristic: A blend of best-fit, first-fit, and a dash of quantum randomness.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # 1. Best Fit Tendency (Attractive Potential)\n    residual_space = bins_remain_cap - item\n    best_fit_priority = np.where(residual_space >= 0, np.exp(-np.abs(residual_space)), -np.inf) # exponential decay towards a perfect fit. Infeasible bins get -inf\n\n    # 2. First Fit Influence (Kinetic Energy Term)\n    first_fit_priority = np.arange(len(bins_remain_cap), 0, -1) # Give earlier bins a slight edge if they fit.\n\n    # 3. Capacity Consideration (Potential Well)\n    capacity_priority = bins_remain_cap / np.sum(bins_remain_cap)  # Bins with more capacity are slightly preferred\n\n    # 4. Quantum Randomness (Tunneling Probability) - Adds Exploration\n    random_noise = np.random.normal(0, 0.01, len(bins_remain_cap))  # small random fluctuations\n\n    # 5. Combine the Priorities (Superposition of States)\n    priorities = best_fit_priority + 0.5 * first_fit_priority + 0.1 * capacity_priority + random_noise\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.337854008775429,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    eligible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(eligible_bins):\n        # Calculate the wasted space if the item is placed in each eligible bin.\n        wasted_space = bins_remain_cap[eligible_bins] - item\n\n        # Give higher priority to bins with less wasted space.\n        # Add a small value to prevent division by zero, which might occur\n        # when wasted_space is close to zero for bins filled to near-capacity\n        priorities[eligible_bins] = 1 / (wasted_space + 1e-6)\n        \n        # Boost priority for almost full bins. If a bin becomes nearly full after adding item,\n        # prioritize it even higher to prevent smaller bins from being unnecessarily opened.\n        almost_full = (bins_remain_cap[eligible_bins] - item) <= 0.1 \n        priorities[eligible_bins][almost_full] *= 2 #Increase by some factor\n    else:\n        #No eligible bins, penalize all existing bins by a negligible value\n        #Prioritizing opening a new bin by giving very low (or zero) priority to existing bins.\n        priorities[:] = 0 # Assign zero priority to all bins\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.198244914240141,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that are just large enough to fit the item\n    and penalizes bins that are either much too small or much too large.\n    Bins that cannot fit the item receive a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give very low priority to bins that can't fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # For feasible bins, calculate a priority based on how well the item fits.\n    feasible_mask = ~infeasible_mask\n    remaining_capacities = bins_remain_cap[feasible_mask]\n\n    # Calculate the \"fit ratio\" - how much of the bin's capacity is used\n    fit_ratios = item / remaining_capacities\n\n    # A fit ratio close to 1 is ideal.  We use a Gaussian-like penalty\n    # for ratios that deviate from 1.  The std dev (sigma) controls\n    # how strict we are about the fit.  A smaller sigma means we\n    # heavily penalize bins that are much larger than the item.\n    sigma = 0.2  # Adjust as needed; smaller = tighter fit required\n    priorities[feasible_mask] = np.exp(-0.5 * ((fit_ratios - 1) / sigma)**2)\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Give a very high priority to bins that can fit the item almost perfectly\n    perfect_fit_threshold = 0.95\n    perfect_fit_bonus = 1000\n    \n    # Give a bonus for bins that can fit the item\n    fit_bonus = 100\n    \n    # Penalize bins that can't fit the item\n    penalty = -1000\n    \n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            if item / cap >= perfect_fit_threshold:\n                priorities[i] = perfect_fit_bonus + (item / cap) # Added the ratio in to make sure we add in bins with lowest capacity, the perfect ratio\n            else:\n                priorities[i] = fit_bonus + (item / cap)\n        else:\n            priorities[i] = penalty\n            \n    return priorities",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.178300757877951,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This function employs a heuristic inspired by concepts of space-time distortion.\n    A bin's priority is determined by a combination of its remaining capacity relative to the item size\n    and a 'potential energy' term related to how close the item's size is to filling the bin completely.\n    A perfect fit is ideal, so the closer we get to a perfect fit, the higher the priority.  Bins that are\n    too small to fit the item are given a very low priority (negative infinity).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap < item:\n            priorities[i] = -np.inf  # Item doesn't fit\n        else:\n            # 'Space-time curvature' term: Higher capacity, initially lower priority,\n            # but we balance this with the fit. The larger the remaining capacity compared to the item,\n            # initially the lower the score.\n\n            # 'Potential Energy' term:  Based on how well the item fits.  A perfect fit is best, so we reward close fits.\n            # The closer (cap - item) is to 0, the higher this term. This helps push towards filling bins.\n            fit_metric = np.exp(-5 * (cap - item) / item)  # Exponential decay if it's not a great fit.\n\n            priorities[i] = 0.5 * (item / cap) + 0.5 * fit_metric # Combined score, balancing fill with total fit.\n    return priorities",
    "response_id": 11,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999978109999915 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the laws of motion and gravitation, the priority function attempts to balance the desire to fill bins (maximizing gravitational \"attraction\") with the risk of leaving too much unused space (minimizing the effective \"mass\").\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, consider only bins where the item can fit\n    valid_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    if not np.any(valid_bins):\n        # If the item does not fit in any bin, give all bins equal priority.\n        # This might be changed later to prioritize bins closest to fitting\n        # return np.ones_like(bins_remain_cap, dtype=float) #All zero is fine too, as any index chosen.\n\n        #Alternative strategy: If no bins fit, prioritize the one *closest* to fitting\n        priorities = -abs(bins_remain_cap - item)\n        return priorities\n\n    # For valid bins, calculate a priority score:\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    # Newton's Law of Gravitation analogy: F = G * m1 * m2 / r^2\n    # Here, 'item' is m1 (constant), 'remaining_space' is related to r\n    # We want to minimize 'remaining_space', but not to zero or negative.\n    # bins_remain_cap is related to m2, representing the bin's \"potential\" for utilization.\n\n    # A small constant to avoid division by zero and to provide a slight baseline priority\n    epsilon = 1e-6\n    \n    # \"Gravitational Attraction\" component: Inverse relationship with remaining space\n    attraction = 1.0 / (remaining_space + epsilon)\n\n    # \"Bin Potential\" component: Directly proportional to bin's remaining capacity\n    bin_potential = bins_remain_cap[valid_bins]\n\n    # Combine the two components: A weighted sum or product\n    # A product allows a stronger emphasis on fitting well (small remaining space)\n    # without overly favoring large remaining capacity if space is wasted\n\n    priorities[valid_bins] = attraction * bin_potential  #A product here allows more refined prioritization\n    #priorities[valid_bins] = attraction + bin_potential\n    \n    # A scaling to make priorities more interpretable (optional)\n    max_priority = np.max(priorities)\n    if max_priority > 0:\n        priorities = priorities / max_priority #scale the prioritiess\n\n    return priorities",
    "response_id": 12,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Emphasizes bins that can fit the item relatively well and avoids near-full bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Give a small penalty if the item doesn't fit at all.\n    does_fit = bins_remain_cap >= item\n    priorities[~does_fit] = -1e9  # Very low priority if it doesn't fit.\n\n    # Give higher priority to bins where the item fits relatively well.\n    # Calculate a \"fit ratio\" (remaining space after fitting / original bin size).\n\n    remaining_after_fit = bins_remain_cap - item\n    fit_ratio = remaining_after_fit / bins_remain_cap #Larger space remaining after fitting means higher fit_ratio\n\n    # Emphasize bins that have relatively good fit\n    priorities[does_fit] = fit_ratio[does_fit] + 1e-6 * bins_remain_cap[does_fit] # small addition in bin capacity to favour bins with larger space\n\n    return priorities",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.487435181491823,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):  # At least one bin can fit the item\n        # Prioritize bins that leave the least waste (smallest remaining capacity *after* packing)\n        remaining_capacities_after_packing = np.where(valid_bins, bins_remain_cap - item, np.inf)  # inf for bins that cannot fit\n\n        # Find the minimum remaining capacity after packing, considering *only* the bins that can fit.  Important!\n        min_remaining_cap = np.min(remaining_capacities_after_packing)\n\n\n        # A higher score means the item is preferable for packing the current item\n        priorities = -np.abs(remaining_capacities_after_packing - min_remaining_cap) # Smaller waste = higher priority\n        priorities[~valid_bins] = -np.inf  # Never choose bins that can't fit\n        #Boosting by the relative remaining capacity - small improvement in packing, but important\n\n        #Boosting if almost full: encourages filling nearly full bins, can free up bins later.\n        priorities[valid_bins] += (bins_remain_cap[valid_bins]/np.max(bins_remain_cap))*0.1  #Adding scaling parameter\n    else:\n        # No bin can fit - should never happen with unlimited bin creation in online bin packing, but good to handle edge cases.\n        # Should ideally create a new bin, but that's handled outside this function.  Return all negative infinity.\n        priorities[:] = -np.inf\n\n\n    return priorities",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Uses a heuristic that balances bin utilization and available space,\n    favoring bins that can accommodate the item with minimal wasted space\n    while also considering the overall fullness of the bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Give zero priority if the item doesn't fit\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # Calculate the wasted space if the item is added to each bin.  Use a capped waste, \n    # as excess capacity shouldn't exponentially increase a bin's priority\n    waste = bins_remain_cap - item\n    capped_waste = np.minimum(waste, item)  # Cap waste at size of item.  More waste is wasteful\n\n    # Calculate the utilization of each bin if the item is added.\n    utilization = (1 - bins_remain_cap / 1.0) # Assuming bin capacity of 1.  Generalize later.\n\n    # Heuristic: Favor bins with small waste and some utilization.  More utilization is better, so long\n    # as it doesn't mean a ton of wasted space.\n    priorities[~infeasible] = utilization[~infeasible] - (capped_waste[~infeasible]**2)  # Minimize square waste\n\n    return priorities",
    "response_id": 15,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 21, in priority_v2\n    wasted_space = bins_remain_cap[eligible_bins] - item\nOverflowError: cannot convert float infinity to integer\n"
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Only consider bins that have enough remaining capacity\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # First-Fit Decreasing-ish strategy\n        # Prioritize bins that leave the LEAST amount of wasted space *after* the item is placed\n        wasted_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = -wasted_space #Smaller wasted space = Higher priority\n        \n        # Adjust priorities based on how FULL the bin becomes. Encourages packing close to capacity.\n        post_fill_ratio = (bins_remain_cap[eligible_bins] - item) / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += (1 - post_fill_ratio)  #Higher fill = higher priority\n        \n        # Adding small penalty if it fits perfectly (or almost perfectly). This reduces local optimal which is close to perfect fit.\n        perfect_fit = np.isclose(bins_remain_cap[eligible_bins], item) # perfect fit if tolerance = 1e-8\n        priorities[eligible_bins][perfect_fit] -= 0.1\n\n    else:\n        #No bins fit this item. Give low priority across the board except if we're near the end\n        #which encourages the creation of a new bin\n        #This prevents long sequences of creating lots of bins that don't have much items.\n        #If all bins cannot fit then no bins is preferred unless its last couple of iterations.\n        priorities[:] = -1e9 # Very low priority\n        \n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 26, in priority_v2\n    \nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A bin must have enough space\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n      # If no eligible bin exists, return a small non-zero priority to indicate any bin.\n      return np.full_like(bins_remain_cap, 1e-6)\n\n    # 1. Best Fit heuristic: Prioritize bins that leave the least space.\n    residual_capacities = bins_remain_cap - item\n    residual_capacities[~eligible_bins] = np.inf  # Exclude non-eligible bins\n\n    min_residual = np.min(residual_capacities)\n    best_fit_bins = np.isclose(residual_capacities, min_residual) #account for ties\n\n    priorities[best_fit_bins] += 1.0\n\n    # 2. Try to avoid fragmentation: bins near full should be prioritized after Best Fit.\n    # A non-linear bonus is added, meaning the fuller the bin is before the item, the higher\n    # the reward is for filling it more, compared to a relatively empty bin.\n\n    fullness = bins_remain_cap / np.max(bins_remain_cap) #scale from 0 to 1 based on capacity\n\n    priorities[eligible_bins] += np.power(fullness[eligible_bins],2)\n\n    #3 Avoid selecting bins if it will lead to small remainders after allocation. This will cause increased fragmentation.\n    too_small = (residual_capacities>0) & (residual_capacities < (np.max(bins_remain_cap)*0.1))\n    priorities[too_small] -= 0.5\n\n    #4 Add a small random component for exploration and to break symmetry\n    priorities[eligible_bins] += np.random.uniform(0, 0.1, size=np.sum(eligible_bins))\n\n    return priorities",
    "response_id": 17,
    "tryHS": false,
    "obj": 15.17750299162346,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins where the item fits, giving preference to bins\n    that would have the least amount of space left over. If the item doesn't\n    fit, it penalizes the bin based on how much the item exceeds the remaining\n    capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Item fits: higher priority for less remaining space *after* placing the item.\n            priorities[i] = cap - item  # Remaining space after placing the item\n            priorities[i] = -priorities[i] # The smaller remaining space is, the more priority.\n            priorities[i] += 10 # Give fit items extra weight.\n        else:\n            # Item does not fit: penalize based on how much item exceeds the capacity.\n            priorities[i] = cap - item #negative number of exceeding size\n    return priorities",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with remaining capacity slightly larger than the item size,\n    but also penalizes bins that are too full (little remaining space) or too empty\n    (wasteful allocation).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap < item:\n            priorities[i] = -np.inf  # Cannot fit, very low priority\n        else:\n            # Reward bins where remaining capacity is close to the item size, but not too close\n            # to avoid fragmentation. Aim for leaving some space, but not too much.\n\n            # Calculate wasted space if the item is placed in the bin\n            wasted_space = cap - item\n\n            # Priority is high if wasted space is within a reasonable range\n            # Adjust the range as needed to tune performance\n            if 0 <= wasted_space <= item * 0.5:  # Favor bins where wasted space is between 0 and half the item size\n                priorities[i] = 1 / (wasted_space + 1e-6)  # Avoid division by zero and prioritize smaller waste\n            else:\n                # Penalize bins with too much or too little wasted space\n                priorities[i] = -abs(wasted_space - item * 0.25) # Penalize the deviation from ideal waste, e.g. quarter of the item.\n\n    return priorities",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Very small remaining capacity is penalized heavily\n    priorities[bins_remain_cap < 0.001] = -np.inf\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Prioritize bins that can fit the item\n    can_fit = remaining_after_add >= 0\n    \n    # If no bin can fit the item, prioritize the least filled bin\n    if not np.any(can_fit):\n        priorities = -bins_remain_cap\n        return priorities\n    \n    \n    #For bins that can fit, the fuller the bin the higher the priority\n    priorities[can_fit] = bins_remain_cap[can_fit]\n\n    # Adding a bonus to bins that fit almost exactly, encouraging full bins\n    almost_full = (remaining_after_add >= 0) & (remaining_after_add <= 0.1)\n    priorities[almost_full] += 5  # A bonus for almost full bins\n    \n    return priorities",
    "response_id": 20,
    "tryHS": false,
    "obj": 149.2919824491424,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A bin is viable if its remaining capacity is >= item size.\n    viable_bins = bins_remain_cap >= item\n\n    # If there are no viable bins, assign a very low priority to all bins.\n    # In real life, you'd open a new bin, but let's not handle that case.\n    if not np.any(viable_bins):\n        return priorities - np.inf  # Or a very large negative number. Avoids inf with calculations below.\n\n    # Prioritize bins that have a \"good fit\" - meaning that the remaining space\n    # after adding the item will be small, but not too small.\n    remaining_after_fit = bins_remain_cap - item\n    # Add to the viable_bins condition that the remaining space is nonnegative\n    # Already asserted with viable_bins\n\n    # Give a bonus to bins where remaining_after_fit is small.  We can reward tighter fits.\n    fit_bonus = np.exp(-np.abs(remaining_after_fit) / item)  # The closer to 0, the better\n\n    # Penalize large remaining capacities.\n    # This encourages filling up bins rather than leaving big gaps.  Consider adding a scaling factor.\n    capacity_penalty = bins_remain_cap / bins_remain_cap.max() if bins_remain_cap.max() > 0 else 0 # if bins_remain_cap.max() == 0 assign to 0\n\n    priorities = viable_bins * (fit_bonus - 0.1 * capacity_penalty) # fit bonus is already multiplied with viable bins\n\n    # Adding a small random factor to break ties randomly and potentially explore the solution space.\n    priorities += np.random.rand(len(bins_remain_cap)) * 1e-6\n\n    return priorities",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    A higher score indicates a more desirable bin to place the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Initialize a very small constant to avoid division by zero and log of zero.\n    epsilon = 1e-9  \n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # 1. Remaining Capacity: Favor bins with smaller remaining capacity\n            #    after packing the item. This encourages filling bins as much as possible.\n            remaining_after_pack = cap - item\n            priorities[i] += (1 / (remaining_after_pack + epsilon))  # Avoid division by zero\n            \n            # 2. Relative Fill: Favor bins where the item fills a larger proportion\n            #    of the bin's remaining capacity.\n            fill_ratio = item / (cap + epsilon) # Avoid division by zero\n            priorities[i] += fill_ratio\n            \n            # 3. Avoid excessive fragmentation: Penalize bins where adding item results in a tiny space.\n            #Heuristic: If after placing the current item into the ith bin, the remaining capacity of that bin will be smaller than item/2 we add a small bonus for not fragmenting\n            if remaining_after_pack <= item/2:\n                priorities[i]+= 0.5\n            \n            \n        else:\n            priorities[i] = -np.inf  # Item doesn't fit.\n\n    return priorities",
    "response_id": 22,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999991850000015 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by observations on radioactive decay and energy levels.\n    We favor bins where the item fills a significant but not overwhelming portion of the remaining capacity.\n    This encourages a more even distribution and reduces the chances of large, unused gaps.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Apply a score based on how well the item fits into each bin.\n    # We'll use a Gaussian-like function centered around a target fill ratio.\n\n    target_fill_ratio = 0.8  # Aim for bins to be about 80% full after adding the item.\n    std_dev = 0.2          # Adjust the standard deviation for the width of the \"sweet spot\".\n\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            fill_ratio = item / cap\n            # Use Gaussian-like distribution\n            priorities[i] = np.exp(-((fill_ratio - target_fill_ratio)**2) / (2 * std_dev**2))\n\n            # Consider the remaining space after the item is added. Penalize excessive waste\n            remaining_space = cap - item\n            waste_penalty = np.exp(-(remaining_space/item)**2)  # Penalize large remaining space\n\n            priorities[i] *= waste_penalty\n\n        else:\n             priorities[i] = -100 # greatly reduce the chance of using infeasible bins.\n    return priorities",
    "response_id": 23,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999976360000005 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the principles of resonance and harmonic oscillation,\n    we seek a balance between filling the bin and avoiding excessive waste.\n    The formula incorporates a penalty for bins that are too full or too empty\n    after packing the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate the remaining capacity after packing\n            remaining_cap = cap - item\n\n            # A \"resonance\" factor favoring bins where the item fits snugly\n            resonance = np.exp(-np.abs(remaining_cap - item) / (item + 1e-9)) # gaussian centered at item_size, small sigma. This term is to encourage \"equal space filling\".\n\n            # A \"packing density\" factor favouring higher filling rates\n            packing_density = (item / cap) # Simple ratio is fine.\n\n            # A \"waste avoidance\" penalty that exponentially disfavors bins with too much remaining space. Avoid small items in big bins.\n            waste_penalty = np.exp(-remaining_cap / (item+1e-9)) # exponential decay.\n\n            priorities[i] = resonance * packing_density * waste_penalty\n\n        else:\n            priorities[i] = -1e9  # Disqualify bins that are too small\n\n    return priorities",
    "response_id": 24,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997800999995 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., 0).\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate remaining capacity after adding the item.\n    remaining_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = remaining_capacities >= 0\n\n    # Assign high priority to bins with small remaining capacity after packing,\n    # but only if they can fit the item. This encourages fuller bins.\n    priorities[valid_bins] = 1 / (remaining_capacities[valid_bins] + 1e-6)  # Add a small constant to avoid division by zero\n\n    # Give a slight bonus to bins that are almost full to begin with. This encourages\n    # closing out bins.  Prioritize bins with high initial fill ratios if they can fit.\n    initial_fill_ratios = (1 - bins_remain_cap / np.max(bins_remain_cap)) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n\n    priorities[valid_bins] += initial_fill_ratios[valid_bins] * 0.5 # Scale fill ratio effect\n\n    # Slightly penalize bins with significantly more capacity than the item, as they are not a good fit.\n    capacity_difference = bins_remain_cap - item\n    relatively_large_capacity = (capacity_difference > (2 * item)) & valid_bins\n    priorities[relatively_large_capacity] -= 0.2\n\n    return priorities",
    "response_id": 25,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 30, in priority_v2\n    #Bonus for filling the bin almost completely (avoid fragmentation)\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Hawking radiation inspired weighting: Smaller bins (closer to black hole event horizon) get higher priority, *if* they can fit the item.\n    # Avoids fragmentation if large items arrive later.\n\n    # Also, penalize bins that are too full after adding the item, mimicking entropy increase.\n    \n    for i, remaining_cap in enumerate(bins_remain_cap):\n        if remaining_cap >= item:\n            priorities[i] = (1.0 / remaining_cap)  # Smaller remaining capacity -> higher base priority\n\n            # Fine-tune based on remaining capacity *after* placing the item. Aim for higher fill.\n            remaining_after = remaining_cap - item\n            if remaining_after > 0:\n                # Quadratic penalty for having *too much* space remaining. Empirically tuned.\n                priorities[i] -= 0.5 * (remaining_after / bins_remain_cap.max())**2 #normalized remaining gap\n\n            #Bonus for filling the bin almost completely (avoid fragmentation)\n            if remaining_after < 0.1*bins_remain_cap.max() and remaining_after >= 0: #Arbitrary threshold of 10%\n                priorities[i] += 0.2\n        else:\n            priorities[i] = -np.inf # Assign negative infinity if the bin can't fit the item\n\n    return priorities",
    "response_id": 26,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99999009999999 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by quantum mechanics and path integrals: consider the 'energy'\n    required to place the item into each bin. A lower 'energy' (more stable state)\n    should have higher priority. This uses a potential energy function related to\n    the remaining space in the bin after placing the item.  We also need to\n    introduce some 'tunneling' probability for bins that are almost full\n    to encourage exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Small constant to avoid division by zero and log of zero\n    epsilon = 1e-9\n\n    # Calculate remaining capacity after placing the item.  Negative values mean item doesn't fit.\n    remaining_cap = bins_remain_cap - item\n\n    # \"Potential Energy\" function:  higher energy for nearly full or over-full bins\n    potential_energy = np.where(remaining_cap > 0, 1 / (remaining_cap + epsilon), 1e9) # High energy if it overflows\n\n    # \"Tunneling\" effect: even if the bin is almost full, there's a small chance we still consider it, promoting exploration.\n    # A slightly filled bin is prefereable though, according to potential energy.\n    tunneling_probability = np.exp(-np.abs(remaining_cap) * 10)  # Decay fast with more fill\n\n    # Combine potential energy and tunneling: lower energy + some tunneling = higher priority\n    priorities = -potential_energy + tunneling_probability\n    \n    # Ensure we aren't selecting impossible options\n    priorities = np.where(bins_remain_cap >= item, priorities, -1e9)  # Make impossible options super low priority.\n\n    return priorities",
    "response_id": 27,
    "tryHS": false,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic: Prioritize bins where the item fits and leaves the least waste.\n    # If item doesn't fit, assign a very low priority.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate remaining space after adding the item.\n            remaining_space = cap - item\n            # Give higher priority to bins with smaller remaining space, but not zero to avoid numerical issues.\n            priorities[i] = 1 / (remaining_space + 0.001)  # Inverse of remaining space\n        else:\n            # Item doesn't fit; very low priority.\n            priorities[i] = -1e9  # A very large negative number to penalize infeasibility\n\n    return priorities",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with remaining capacity slightly larger than the item size,\n    while penalizing bins that are either too small or too large. It also introduces a small\n    random factor to break ties and explore different packing configurations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n\n    # Penalize bins where the item doesn't fit (waste < 0). Give them a very low priority.\n    priorities = np.where(waste < 0, -np.inf, 0)\n\n    # Prioritize bins where waste is small but positive.  A quadratic function is used to shape the priorities.\n    # The ideal waste is near zero, and the priority decreases as waste increases.\n    # We can tune the parameters to control the shape of the priority function.\n    ideal_waste = 0.1 * item  # Aim for a bit of waste (e.g., 10% of item size)\n    priority_scale = 10 # scaling factor to influence how strongly the waste affects priority\n\n    valid_bins = waste >= 0\n    priorities[valid_bins] = priority_scale * np.exp(-((waste[valid_bins] - ideal_waste)**2) / (2 * (item/5)**2)) # Gaussian-like priority based on remaining space\n\n    # Introduce a small amount of noise to encourage exploration.\n    noise = np.random.normal(0, 0.1, size=bins_remain_cap.shape) # Normal distributed noise, scale 0.1.\n    priorities = priorities + noise\n\n    return priorities",
    "response_id": 29,
    "tryHS": false,
    "obj": 7.080175508575988,
    "exec_success": true
  }
]