{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on waste and fill ratio, efficiently.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        remaining_capacities_after_packing = np.where(valid_bins, bins_remain_cap - item, np.inf)\n        min_remaining_cap = np.min(remaining_capacities_after_packing)\n\n        priorities = -np.abs(remaining_capacities_after_packing - min_remaining_cap)\n        priorities[~valid_bins] = -np.inf\n        fill_ratio = item / bins_remain_cap\n        fill_ratio[bins_remain_cap < item] = 0  # Set ratio to 0 if the item doesn't fit\n\n        priorities[valid_bins] += fill_ratio[valid_bins] * 0.1\n\n    else:\n        priorities[:] = -np.inf\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get the lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Calculate wasted space.\n    wasted_space = bins_remain_cap - item\n\n    # Primary priority: Minimize wasted space.  Slight change: exponentiate wasted space to penalize larger waste more.\n    priorities[bins_remain_cap >= item] = -wasted_space[bins_remain_cap >= item]**2\n\n    # Bonus for bins that are already somewhat full. Increase the bonus weight.\n    priorities[bins_remain_cap >= item] += (1 - bins_remain_cap[bins_remain_cap >= item]) * 0.25\n\n    # Introduce a small amount of randomness to avoid getting stuck in local minima.\n    # The scale of randomness is adaptive based on the item size; smaller items get smaller random adjustments.\n    priorities[bins_remain_cap >= item] += np.random.rand(np.sum(bins_remain_cap >= item)) * 0.05 * item\n\n    # Further prioritize bins close to the item size without exceeding it significantly.\n    # This encourages a better \"fit\" and reduces fragmentation.\n    near_fit = (bins_remain_cap >= item) & (wasted_space <= item * 0.2)  # Waste is <= 20% of item size\n    priorities[near_fit] += 0.15 #Give them a slight bonus\n    \n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins where item fits with minimal waste, using numpy.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    does_fit = bins_remain_cap >= item\n    \n    if np.any(does_fit): #Check if any bin fits the item\n        remaining_space = bins_remain_cap[does_fit] - item\n        priorities[does_fit] = 1 / (remaining_space + 0.001) #Prioritize small remain space\n    else:\n        priorities[:] = -1e9 #Item doesn't fit, very low priority\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get lowest priority\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Wasted space is still a key factor\n    wasted_space = bins_remain_cap - item\n    priorities[bins_remain_cap >= item] = -wasted_space[bins_remain_cap >= item]\n\n    # Encourage filling bins, but with more emphasis based on how full they *could* be\n    # The closer to full *after* placement, the higher the bonus.\n    fill_ratio_after = (1 - wasted_space / bins_remain_cap.max())\n    priorities[bins_remain_cap >= item] += fill_ratio_after[bins_remain_cap >= item] * 0.2  # Increased weight on fill ratio\n\n    # Add a small amount of randomization to explore different bin placements.\n    # This helps to escape local optima.\n    priorities[bins_remain_cap >= item] += np.random.rand(np.sum(bins_remain_cap >= item)) * 0.05\n    \n    # Penalize bins that are very empty, even if they fit. This encourages using bins\n    # that are already partially full.\n    empty_bin_penalty = (bins_remain_cap / bins_remain_cap.max())\n    priorities[bins_remain_cap >= item] -= empty_bin_penalty[bins_remain_cap >= item] * 0.05\n    \n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins that fit the item, favoring those with less remaining space after packing.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    fit_mask = bins_remain_cap >= item\n    \n    if np.any(fit_mask):\n        remaining_space = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = -remaining_space # Smaller remaining space gets higher priority\n        priorities[fit_mask] += 10 #Give extra weight to bins that fit\n    else:\n        priorities = bins_remain_cap - item # Penalize bins where the item doesn't fit\n        \n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on waste and fill ratio, efficiently.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        remaining_capacities_after_packing = np.where(valid_bins, bins_remain_cap - item, np.inf)\n        min_remaining_cap = np.min(remaining_capacities_after_packing)\n\n        priorities = -np.abs(remaining_capacities_after_packing - min_remaining_cap)\n        priorities[~valid_bins] = -np.inf\n        fill_ratio = item / bins_remain_cap\n        fill_ratio[bins_remain_cap < item] = 0  # Set ratio to 0 if the item doesn't fit\n\n        priorities[valid_bins] += fill_ratio[valid_bins] * 0.1\n\n    else:\n        priorities[:] = -np.inf\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins where item fits with minimal waste, using numpy.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    does_fit = bins_remain_cap >= item\n    \n    if np.any(does_fit): #Check if any bin fits the item\n        remaining_space = bins_remain_cap[does_fit] - item\n        priorities[does_fit] = 1 / (remaining_space + 0.001) #Prioritize small remain space\n    else:\n        priorities[:] = -1e9 #Item doesn't fit, very low priority\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, fill_ratio_weight: float = 0.3961882647668603) -> np.ndarray:\n    \"\"\"Prioritizes bins based on waste and fill ratio, efficiently.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        remaining_capacities_after_packing = np.where(valid_bins, bins_remain_cap - item, np.inf)\n        min_remaining_cap = np.min(remaining_capacities_after_packing)\n\n        priorities = -np.abs(remaining_capacities_after_packing - min_remaining_cap)\n        priorities[~valid_bins] = -np.inf\n        fill_ratio = item / bins_remain_cap\n        fill_ratio[bins_remain_cap < item] = 0  # Set ratio to 0 if the item doesn't fit\n\n        priorities[valid_bins] += fill_ratio[valid_bins] * fill_ratio_weight\n\n    else:\n        priorities[:] = -np.inf\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a very low priority (large negative value) to bins that cannot fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate the wasted space if the item is placed in the bin\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize bins with smaller wasted space (more efficient packing)\n    priorities[bins_remain_cap >= item] = -wasted_space[bins_remain_cap >= item]\n    \n    # Add a small bonus for bins that are already somewhat full.  This encourages\n    # using existing bins before starting new ones.  This is a heuristic so can be tuned.\n    priorities[bins_remain_cap >= item] += (1 - bins_remain_cap[bins_remain_cap >= item]) * 0.1\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on remaining capacity, best fit and exploration.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasible bins get a very low priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -1e9\n\n    # Calculate waste for feasible bins\n    feasible_mask = ~infeasible_mask\n    waste = bins_remain_cap[feasible_mask] - item\n\n    # Prioritize bins with smaller waste, add small constant to avoid division by zero.\n    priorities[feasible_mask] = 1 / (waste + 0.001)\n\n    # Add a bit of noise for exploration\n    noise = np.random.normal(0, 0.01, size=bins_remain_cap.shape)\n    priorities += noise\n    \n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on remaining capacity, best fit and exploration.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasible bins get a very low priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -1e9\n\n    # Calculate waste for feasible bins\n    feasible_mask = ~infeasible_mask\n    waste = bins_remain_cap[feasible_mask] - item\n\n    # Prioritize bins with smaller waste, add small constant to avoid division by zero.\n    priorities[feasible_mask] = 1 / (waste + 0.001)\n\n    # Add a bit of noise for exploration\n    noise = np.random.normal(0, 0.01, size=bins_remain_cap.shape)\n    priorities += noise\n    \n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on remaining capacity after item placement.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    waste = bins_remain_cap - item\n    # Very low priority if item doesn't fit\n    priorities = np.where(waste < 0, -np.inf, priorities)\n\n    valid_bins = waste >= 0\n    # Prioritize smaller waste, add small random noise for exploration\n    priorities[valid_bins] = 1 / (waste[valid_bins] + 0.001) + np.random.normal(0, 0.01, size=np.sum(valid_bins))\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on remaining capacity after item placement.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    waste = bins_remain_cap - item\n    # Very low priority if item doesn't fit\n    priorities = np.where(waste < 0, -np.inf, priorities)\n\n    valid_bins = waste >= 0\n    # Prioritize smaller waste, add small random noise for exploration\n    priorities[valid_bins] = 1 / (waste[valid_bins] + 0.001) + np.random.normal(0, 0.01, size=np.sum(valid_bins))\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on best-fit and remaining capacity.\"\"\"\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Infeasible bins get -inf priority\n    priorities = np.where(remaining_after_add >= 0, bins_remain_cap, -np.inf)\n\n    # Add bonus for almost full bins to encourage efficient packing\n    almost_full = (remaining_after_add >= 0) & (remaining_after_add <= 0.1)\n    priorities[almost_full] += 5\n\n    # If no bin can fit, prioritize the fullest bin\n    if np.all(priorities == -np.inf):\n        priorities = bins_remain_cap\n    \n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on best-fit and remaining capacity.\"\"\"\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Infeasible bins get -inf priority\n    priorities = np.where(remaining_after_add >= 0, bins_remain_cap, -np.inf)\n\n    # Add bonus for almost full bins to encourage efficient packing\n    almost_full = (remaining_after_add >= 0) & (remaining_after_add <= 0.1)\n    priorities[almost_full] += 5\n\n    # If no bin can fit, prioritize the fullest bin\n    if np.all(priorities == -np.inf):\n        priorities = bins_remain_cap\n    \n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit ratio, capacity, and adds small random exploration.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    does_fit = bins_remain_cap >= item\n    priorities[~does_fit] = -1e9\n\n    remaining_after_fit = bins_remain_cap - item\n    fit_ratio = remaining_after_fit / bins_remain_cap\n\n    priorities[does_fit] = fit_ratio[does_fit] + 1e-6 * bins_remain_cap[does_fit] + 1e-9 * np.random.rand(np.sum(does_fit))\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit ratio, capacity, and adds small random exploration.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    does_fit = bins_remain_cap >= item\n    priorities[~does_fit] = -1e9\n\n    remaining_after_fit = bins_remain_cap - item\n    fit_ratio = remaining_after_fit / bins_remain_cap\n\n    priorities[does_fit] = fit_ratio[does_fit] + 1e-6 * bins_remain_cap[does_fit] + 1e-9 * np.random.rand(np.sum(does_fit))\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit ratio, capacity, and adds small random exploration.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    does_fit = bins_remain_cap >= item\n    priorities[~does_fit] = -1e9\n\n    remaining_after_fit = bins_remain_cap - item\n    fit_ratio = remaining_after_fit / bins_remain_cap\n\n    priorities[does_fit] = fit_ratio[does_fit] + 1e-6 * bins_remain_cap[does_fit] + 1e-9 * np.random.rand(np.sum(does_fit))\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit ratio, capacity, and adds small random exploration.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    does_fit = bins_remain_cap >= item\n    priorities[~does_fit] = -1e9\n\n    remaining_after_fit = bins_remain_cap - item\n    fit_ratio = remaining_after_fit / bins_remain_cap\n\n    priorities[does_fit] = fit_ratio[does_fit] + 1e-6 * bins_remain_cap[does_fit] + 1e-9 * np.random.rand(np.sum(does_fit))\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit ratio, capacity, and adds small random exploration.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    does_fit = bins_remain_cap >= item\n    priorities[~does_fit] = -1e9\n\n    remaining_after_fit = bins_remain_cap - item\n    fit_ratio = remaining_after_fit / bins_remain_cap\n\n    priorities[does_fit] = fit_ratio[does_fit] + 1e-6 * bins_remain_cap[does_fit] + 1e-9 * np.random.rand(np.sum(does_fit))\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}