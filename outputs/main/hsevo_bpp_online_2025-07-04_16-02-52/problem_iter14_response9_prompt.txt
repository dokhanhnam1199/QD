{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit, fill ratio, bin utilization, and adaptive randomization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Mark infeasible bins with negative infinity\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Calculate remaining space after placing the item in each bin\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize bins with minimal wasted space (Best-Fit component)\n    priorities[bins_remain_cap >= item] = -wasted_space[bins_remain_cap >= item]\n\n    # Fill ratio bonus, scaled by remaining capacity.  Emphasizes filling nearly full bins.\n    fill_ratio_after = (bins_remain_cap - wasted_space) / bins_remain_cap.max()\n    priorities[bins_remain_cap >= item] += fill_ratio_after[bins_remain_cap >= item] * 0.3\n\n    # Adaptive Randomization: Smaller items get more randomization.\n    randomization_strength = 0.1 / (1 + item) # Inverse relationship\n    priorities[bins_remain_cap >= item] += np.random.rand(np.sum(bins_remain_cap >= item)) * randomization_strength\n\n    # Bin Utilization Penalty: Penalize bins with very low fill levels to encourage using partially filled bins.\n    utilization_ratio = bins_remain_cap / bins_remain_cap.max()\n    priorities[bins_remain_cap >= item] -= (1 - utilization_ratio[bins_remain_cap >= item]) * 0.1\n\n    # Bonus for bins that would become nearly full after placing the item\n    nearly_full_threshold = 0.9\n    nearly_full_bonus = np.where((bins_remain_cap >= item) & (fill_ratio_after >= nearly_full_threshold), 0.2, 0)\n    priorities[bins_remain_cap >= item] += nearly_full_bonus[bins_remain_cap >= item]\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on waste, fill ratio, controlled randomization and bin diversity.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities - np.inf\n\n    # Waste minimization with non-linear penalty\n    wasted_space = bins_remain_cap - item\n    wasted_space[~feasible_bins] = np.inf\n    priorities[feasible_bins] -= (wasted_space[feasible_bins] / bins_remain_cap.max())**2\n\n    # Adaptive fill ratio bonus\n    fill_ratio_after = item / (bins_remain_cap[feasible_bins])\n    priorities[feasible_bins] += fill_ratio_after * 0.1\n\n    # Controlled randomization, scaled by (1 - item_scale)\n    item_scale = item / bins_remain_cap.max()\n    randomization_factor = 0.02 * (1 - item_scale)\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * randomization_factor\n\n    # Encourage filling bins, bonus based on fill ratio AFTER placement\n    fill_ratio_after_all = (bins_remain_cap - wasted_space) / bins_remain_cap.max() #using scaled version\n    priorities[feasible_bins] += fill_ratio_after_all[feasible_bins] * 0.2 #reduce scaling to 0.2\n\n    # Slightly penalize bins that are already very full.\n    almost_full = (wasted_space < 0.1*bins_remain_cap.max()) & feasible_bins\n    priorities[almost_full] -= 0.01\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see that both heuristics are identical.\nComparing (3rd) vs (4th), (5th) vs (6th), (9th) vs (10th), (11th) vs (12th), (13th) vs (14th), (15th) vs (16th), (17th) vs (18th), (19th) vs (20th), we also see that both heuristics are identical.\n\nComparing (1st) vs (3rd), we observe several key differences. Heuristic 3 introduces the concept of adaptive scaling and bonus/penalty mechanisms based on item size and bin capacity. These adaptive approaches, specifically the adaptive fill ratio bonus, randomization factor, and bin-emptiness penalty, are not present in Heuristic 1. Additionally, Heuristic 3 includes a bonus for bins nearing full capacity and penalizes bins that are nearly full to encourage diversity.\n\nComparing (3rd) vs (4th), Heuristic 4 introduces a non-linear penalty for wasted space, scaling it by the maximum bin capacity, whereas Heuristic 3 uses a linear penalty and normalizes by the max bin capacity. Also, Heuristic 4 scales randomization by the item and bin capacity, whereas Heuristic 3 scales only by item size.\n\nComparing (4th) vs (5th), Heuristic 5 introduces `bin_diversity_bonus` based on the standard deviation of the remaining bin capacities to prioritize bins with more diverse fill levels. Also, the fill ratio weight and the empty/full bin penalties are made adaptive in H5, depending on item size. H4 only uses item scale to adapt the fill bonus weight and uses fixed weights for penalty.\n\nComparing (5th) vs (7th), Heuristic 7 simplifies the randomization strength and uses inverse relationship to the item size. It also introduces a nearly full bonus with fixed threshold.\n\nComparing (7th) vs (8th), Heuristic 8 adds diversity score based on how close the wasted space is to the item size. It also incorporates a dynamic empty bin penalty adjusting to the current bin landscape.\n\nComparing (8th) vs (10th), Heuristic 10 removes diversity score and dynamic empty bin penalty. It simplifies adaptive randomization and near full penalty, using less parameters.\n\nOverall: The better heuristics introduce adaptive scaling of bonuses/penalties, considering item size and bin capacity. They promote bin diversity and prevent early commitment to bins that are almost full, while adaptive randomization scales based on bin fullness to diversify selection.\n- \nOkay, let's refine \"Current Self-Reflection\" for better heuristic design, avoiding the pitfalls of \"Ineffective Self-Reflection.\" Here's a breakdown:\n\n*   **Keywords:** Adaptive parameters, balanced approach, multiple factors (waste, fill ratio, exploration), dynamic adjustment, overall landscape.\n\n*   **Advice:** Design heuristics that dynamically adapt based on item/bin states, balancing waste minimization with exploration. Prioritize heuristics that consider the interplay between parameters and their impact on solution quality.\n\n*   **Avoid:** Overly simplistic heuristics focused solely on remaining capacity, complex analogies, relying solely on random factors without a clear strategy.\n\n*   **Explanation:** Move beyond simple rules. Focus on creating a system that reacts intelligently to the current packing state, leveraging diverse factors in a coordinated manner for robust performance.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}