```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Tesla's Intuition for TSP Edge Importance.

    This function estimates the "promise" of each edge in a TSP problem
    based on a combination of factors: distance, neighborhood density,
    and overall connectivity. It leverages principles of electromagnetic
    induction (where proximity enhances interaction) and network theory.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances
                                     between cities.  distance_matrix[i, j] is the
                                     distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each
                    element represents the heuristic score of including the
                    corresponding edge in the TSP tour. Higher scores indicate
                    more promising edges.

    Technical details:
    1. Inverse Distance: Shorter distances are generally more desirable, so we
       start with the inverse of the distance.  This represents a basic attraction.
    2. Neighborhood Influence: We calculate a "neighborhood density" for each city.
       This is based on the idea that a city with many close neighbors might be a
       good "hub" for connecting different parts of the tour. We sum the inverse
       distances to nearby cities as a measure of neighborhood density.
       The score is adjusted using (1 + neighbor_influence[i] + neighbor_influence[j]), so a city near highly connected hubs will have a good chance to be a part of the route.
    3. Connectivity Reinforcement: A penalty is applied if two cities are highly inter-connected to other hubs, otherwise it will lead to sub-optimal convergence.

    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Tesla's Principle #1: Inverse Distance
    inverse_distance = 1.0 / (distance_matrix + 1e-6)  # Avoid division by zero

    # Tesla's Principle #2: Neighborhood Influence (Electromagnetic Induction Analogy)
    neighbor_influence = np.sum(inverse_distance, axis=1)

    # Combine the factors, with a focus on local density and a tempering effect from direct distance
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics[i, j] = inverse_distance[i, j] * (1 + neighbor_influence[i] + neighbor_influence[j])
            else:
                heuristics[i, j] = 0 # Avoid self-loops
    return heuristics
```
