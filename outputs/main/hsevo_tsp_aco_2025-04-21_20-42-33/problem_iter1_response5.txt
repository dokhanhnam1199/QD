```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improves upon the simple inverse distance heuristic by incorporating
    a factor that favors edges connecting to nodes with higher average distance
    to other nodes. This encourages connections to nodes that are more "central"
    within the graph, potentially leading to shorter overall tours.
    The intuition is to penalize choosing the shortest link between some
    very tight cluster of nearby nodes before connecting with the rest of the points.

    Args:
        distance_matrix: A numpy array representing the distance matrix.

    Returns:
        A numpy array of the same shape as distance_matrix, representing the heuristic values
        for each edge.
    """

    n = distance_matrix.shape[0]
    avg_distances = np.mean(distance_matrix, axis=1) # Calculate average distance from each node to all others
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] = (1 / distance_matrix[i, j]) * (avg_distances[i] + avg_distances[j]) # Scale the inverse distance
            else:
                heuristic_matrix[i, j] = 0.0  # No self-loops

    return heuristic_matrix
```
