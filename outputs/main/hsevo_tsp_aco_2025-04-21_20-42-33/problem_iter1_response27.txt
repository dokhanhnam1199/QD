```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A more sophisticated heuristic for the Traveling Salesman Problem (TSP).
    This version combines inverse distance with a node centrality measure
    to estimate the desirability of including each edge in the tour.
    Feynman's stochastic sampling hints, informed by "potentiality."
    """
    n = distance_matrix.shape[0]

    # 1. Inverse distance: Closer cities are generally better connected.
    inverse_distance = 1.0 / (distance_matrix + np.eye(n)) # avoid division by zero and self-loops
    np.fill_diagonal(inverse_distance, 0) #remove self-loops

    # 2. Node centrality (degree centrality approximation): Nodes that are 
    #    centrally located tend to have shorter paths.  Approximate degree
    #    centrality using inverse sum of distances from each node. This
    #    captures nodes close to other nodes, thereby reduces total path lengths.
    node_centrality = np.sum(inverse_distance, axis=1)
    node_centrality_matrix = np.outer(node_centrality, node_centrality)

    # 3. Combine the two factors.  Emphasize the effect of the central nodes
    #    as it is related to reducing global path length.
    heuristic_matrix = inverse_distance * np.sqrt(node_centrality_matrix) #Geometric Mean
    np.fill_diagonal(heuristic_matrix, 0) # self-loop will influence stochastic sampler

    # Normalize to make it a probability-like prior. Helps the stochastic sampler
    # use the heuristic better.
    heuristic_matrix = (heuristic_matrix + 1e-9) / np.sum(heuristic_matrix + 1e-9)  #Adding tiny values to avoid zero probability

    return heuristic_matrix
```
