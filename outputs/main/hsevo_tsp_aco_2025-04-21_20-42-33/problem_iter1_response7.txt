```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A heuristic for the Traveling Salesman Problem (TSP) that considers
    both distance and global graph structure to estimate the desirability
    of including each edge in the optimal tour.  It uses a combination
    of inverse distance (basic desirability) and a measure of connectivity
    via the shortest paths between nodes. The idea is to slightly favor edges
    that bridge disconnected parts of the graph or connect nodes that are otherwise
    far apart in terms of path length.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances
                                       between nodes. distance_matrix[i, j] is the
                                       distance between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each
                    element represents the desirability (heuristic value) of
                    including the corresponding edge in the TSP tour. Higher
                    values indicate more desirable edges.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Basic desirability: inverse of distance
    base_heuristic = 1.0 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # All-pairs shortest path lengths (using the distance matrix)
    path_lengths = np.zeros((n, n))
    for i in range(n):
      for j in range(n):
        path_lengths[i,j] = distance_matrix[i, j]
    for k in range(n):
      for i in range(n):
        for j in range(n):
          path_lengths[i, j] = min(path_lengths[i, j], path_lengths[i, k] + path_lengths[k, j])


    # Connectivity bonus:
    # The bonus is higher if nodes i and j are far apart in terms of path length,
    # suggesting the edge (i,j) can significantly shorten the tour.

    connectivity_bonus = path_lengths / (np.max(path_lengths) + 1e-9)

    heuristic_matrix = base_heuristic + (1 - connectivity_bonus) # Combine with inverse distance
    #heuristic_matrix = np.clip(heuristic_matrix, 0, 1)  # Ensure values are non-negative
    return heuristic_matrix
```
