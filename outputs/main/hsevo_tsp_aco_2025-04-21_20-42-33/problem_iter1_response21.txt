```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics function for solving the Traveling Salesman Problem (TSP)
    via stochastic solution sampling. This version incorporates several
    ideas to improve the quality of the edge priors:

    1.  Inverse distance, as closer cities are more likely to be neighbors
    2.  Edge Centrality: Edges that lie on shorter paths between many nodes are preferable
    3.  Nearest Neighbor: Each node is more likely connected with its nearest neighbors
    4.  A slight global randomization, allowing escaping from local minima.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance
            matrix between cities. distance_matrix[i][j] is the distance
            between city i and city j.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix,
            representing the prior probabilities (or heuristic scores) for
            including each edge in a solution.  Higher values indicate a
            more promising edge.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small value to avoid division by zero

    # 2. Edge Centrality heuristic: approximated via closeness centrality

    # Calculate shortest paths between all pairs of nodes using Floyd-Warshall algorithm, inspired from internet
    dist = np.copy(distance_matrix)
    for k in range(n):
      for i in range(n):
        for j in range(n):
          dist[i, j] = min(dist[i, j], dist[i, k] + dist[k, j])

    closeness_centrality = np.zeros((n,n))
    for i in range(n):
      for j in range(n):
        closeness_centrality[i][j] = 1/(dist[i,j] + 1e-9)


    # 3. Nearest Neighbor heuristic.  Each node is more likely to be connected to its nearest neighbors.
    nearest_neighbors = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        # Find the indices of the k-nearest neighbors (excluding itself). Let k be 3
        k = min(3, n-1) # Handle the edge case that n can be smaller than 3

        neighbors = np.argpartition(distance_matrix[i], k+1)[:k+1]
        neighbors = neighbors[neighbors != i]
        if len(neighbors)> 0:

          for j in neighbors:
            nearest_neighbors[i][j] = 1 # Prioritize to connect to neighbors.

    #4. Incorporate heuristics scores
    heuristics = inverse_distance + closeness_centrality + nearest_neighbors
    # Normalize to be between 0 and 1
    heuristics = (heuristics - np.min(heuristics)) / (np.max(heuristics) - np.min(heuristics) + 1e-9)

    # 5. Add a small amount of randomness to allow exploring different routes
    randomness = np.random.rand(n, n) * 0.1
    heuristics += randomness
    heuristics = np.clip(heuristics, 0, 1)  # Clip values to be within [0, 1]

    return heuristics
```
