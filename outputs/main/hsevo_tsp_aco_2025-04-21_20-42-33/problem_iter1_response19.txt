```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improves upon the basic inverse distance heuristic by incorporating a
    nearest neighbor component. Favors edges connecting nodes that are
    relatively close to each other *and* that aren't already strongly
    connected to many other nodes. This attempts to balance proximity with
    avoiding premature closure of the tour, which can lead to suboptimal paths
    later on.

    Args:
        distance_matrix: A numpy ndarray representing the distance matrix.

    Returns:
        A numpy ndarray of the same shape as distance_matrix, representing the
        heuristic values for each edge. Higher values indicate a more promising
        edge to include in the TSP tour.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Normalize distances to be between 0 and 1.  Small distances are good.
    normalized_distances = distance_matrix / np.max(distance_matrix)

    # Inverse distance: Shorter distances are better.  Add a small constant
    # to the denominator to avoid division by zero.
    inverse_distance = 1 / (normalized_distances + 0.0001)

    # Degree penalty:  Nodes with many short edges are penalized.
    degree_penalty = np.zeros((n, n))
    for i in range(n):
        # Sum of inverse distances from node i to all other nodes.
        row_sum = np.sum(inverse_distance[i, :])

        # Normalize, and apply it symmetrically to all neighbors of i.  The
        # higher the sum of inverse distances from node i to all other nodes, the
        # higher the penalty applied to any node *connected* to i.
        if row_sum > 0:
            penalty = row_sum
            degree_penalty[i, :] = penalty
            degree_penalty[:, i] = penalty
    # Ensure degree penalty is reasonable by scaling
    degree_penalty = degree_penalty / np.max(degree_penalty + 0.0001)
    
    heuristic_matrix = inverse_distance / (degree_penalty + 0.0001)  # Combine inverse distance and degree penalty

    # Zero out the diagonal elements to prevent self-loops
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
