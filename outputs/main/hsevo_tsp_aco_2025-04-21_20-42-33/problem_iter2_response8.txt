```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines inverse distance with shortest path penalization and node
    degree influence for informed edge selection.
    """
    n = distance_matrix.shape[0]

    # Basic desirability: inverse of distance
    base_heuristic = 1.0 / (distance_matrix + 1e-9)

    # Shortest path lengths (using the distance matrix)
    path_lengths = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            path_lengths[i, j] = distance_matrix[i, j]
    for k in range(n):
        for i in range(n):
            for j in range(n):
                path_lengths[i, j] = min(path_lengths[i, j], path_lengths[i, k] + path_lengths[k, j])
    connectivity_bonus = path_lengths / (np.max(path_lengths) + 1e-9)
    heuristic_matrix = base_heuristic + (1 - connectivity_bonus)

    # Node degree penalty
    degrees = np.sum(distance_matrix < np.inf, axis=0) -1 #exclude self-loop

    degree_penalty = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            degree_penalty[i, j] = (degrees[i] + degrees[j])
    degree_penalty = degree_penalty / np.max(degree_penalty) if np.max(degree_penalty) > 0 else 0

    heuristic_matrix = heuristic_matrix * (1 - 0.1 * degree_penalty) # Penalize higher degree connections

    # Controlled randomness
    heuristic_matrix = heuristic_matrix + np.random.rand(*heuristic_matrix.shape) * 0.01
    heuristic_matrix = np.where(heuristic_matrix <= 0, 0.0001, heuristic_matrix) # Ensure non-zero
    return heuristic_matrix
```
