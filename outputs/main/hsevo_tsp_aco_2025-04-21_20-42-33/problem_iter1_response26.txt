```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Stephen Hawking's Heuristic for TSP: Gravitational Lens Analogy

    Inspired by how gravity bends light around massive objects (black holes, galaxies),
    this heuristic favors edges that 'bend' the overall tour in a globally efficient way.
    It combines distance with a 'curvature' factor: shorter distances are better (like
    stronger gravity), but edges that bridge large gaps or connect to/from nodes far
    from the current partial tour are also prioritized (simulate long-range
    gravitational influence).

    Args:
        distance_matrix: A numpy array representing the distance between cities.

    Returns:
        A numpy array of the same shape as distance_matrix, representing the desirability
        of including each edge in the TSP tour.  Higher values indicate a more desirable edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Add a small constant to avoid division by zero
    epsilon = 1e-9

    for i in range(n):
        for j in range(n):
            if i != j:
                # Inverse distance - shorter edges are initially favored. Like gravitational force.
                attraction = 1.0 / (distance_matrix[i, j] + epsilon)

                # "Curvature" factor:  Approximates the advantage of using this edge
                # based on the *average* distance of nodes i and j to all other nodes.
                # Higher average distance of (i,j) to other nodes means including (i,j) is important for traveling to a node far away from both of them

                # mean_dist_i = np.mean(distance_matrix[i, :])  #mean distance between node i and every node in the problem, including i.
                # mean_dist_j = np.mean(distance_matrix[j, :]) #mean distance between node j and every node in the problem, including j.

                mean_dist_i = np.sum(distance_matrix[i, :]) / (n - 1 + epsilon) #mean distance between node i and every node in the problem, excluding i.
                mean_dist_j = np.sum(distance_matrix[j, :]) / (n - 1 + epsilon) #mean distance between node j and every node in the problem, excluding j.

                # This 'spread' encourages edges that connect 'outlying' nodes,
                # nodes that are, on average, far away from all other nodes.  This
                # helps jump between clusters, akin to bending spacetime to reach a distant point.

                spread_factor = mean_dist_i + mean_dist_j
                # The spread factor can be tuned to make more of a difference relative to distance.
                # This parameter is a global "gravitational constant" to amplify or reduce the effect of gravity
                gravitational_constant = 1.0  #experiment with tuning parameter to make different the spread/attract balance.  1.5 seems good for the toy problem

                heuristic_matrix[i, j] = attraction * (1 + gravitational_constant * spread_factor)

            else:
                heuristic_matrix[i, j] = 0  # Avoid self-loops

    return heuristic_matrix
```
