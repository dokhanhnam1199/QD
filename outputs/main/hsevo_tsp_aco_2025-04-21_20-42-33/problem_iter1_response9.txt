```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A more sophisticated heuristic for the Traveling Salesman Problem.

    This heuristic combines several factors:
    1. Inverse distance: Shorter distances are generally more desirable.
    2. Node degree bias: Preferentially selects edges connected to nodes with fewer connected edges so far
    3. Global average distance: Adjusts edge weights based on the overall average distance in the matrix.  Edges significantly shorter than average are boosted.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i, j] is the distance between node i and node j.  Inf or 0 indicates no direct connection. Diagonal elements should be Inf.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element
                      indicates how promising that edge is. Higher values indicate more promising edges.
    """

    n = distance_matrix.shape[0]

    # 1. Inverse distance
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Avoid division by zero

    # 2. Degree bias (initially uniform). Later to be adjusted iteratively, but not within the pure heuristic function. This simulates the concept of "nearest neighbor" like behavior.
    degree_bias = np.ones((n, n))

    # 3. Global average distance (robustly calculated)
    valid_distances = distance_matrix[distance_matrix != np.inf]
    avg_distance = np.mean(valid_distances) if valid_distances.size > 0 else 0.0 # in case all edges are blocked

    # Combine the factors. Significantly shorter edges get a boost.
    heuristic_matrix = inverse_distance * degree_bias * (1 + np.maximum(0.0, (avg_distance - distance_matrix) / avg_distance))

    # Ensure no connection to self
    for i in range(n):
        heuristic_matrix[i, i] = 0.0  # No loops

    return heuristic_matrix
```
