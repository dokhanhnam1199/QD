```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improves upon simple inverse distance by considering the average distance
    to a node's nearest neighbors.  This favors edges that connect
    nodes to their closer neighbors, increasing the likelihood of
    locally optimal segments.  Also introduces a small amount of random
    noise to encourage exploration.

    Args:
        distance_matrix: A numpy ndarray representing the distance matrix.

    Returns:
        A numpy ndarray of the same shape as the input, representing
        prior indicators of how promising each edge is.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    for i in range(n):
        # Find nearest neighbors for node i, excluding itself.
        neighbors = np.argsort(distance_matrix[i, :])[1:min(4, n)]  # Top 3 nearest neighbors (or fewer if n < 4)

        # Calculate the average distance to the nearest neighbors.
        avg_neighbor_distance = np.mean(distance_matrix[i, neighbors])

        for j in range(n):
            if i != j:
                # Heuristic is the inverse of the distance, adjusted by the
                # average distance to nearest neighbors. The closer the neighbors on average,
                # the higher the weighting. The closer two given nodes (i and j), the higher the weighting.
                # The adjustment also ensures we favor more densely connected graphs by giving them an edge.
                heuristics[i, j] = (avg_neighbor_distance / distance_matrix[i, j])

                # Add some noise to the heuristic value to explore potentially suboptimal paths
                noise = np.random.normal(0, 0.05)
                heuristics[i, j] += noise

                # Ensure the values are not zero.
                heuristics[i, j] = max(heuristics[i, j], 0.0001) # Prevents zero divide, gives a base value.

    return heuristics
```
