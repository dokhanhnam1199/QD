```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for the Traveling Salesman Problem (TSP) based on a combination of distance,
    node degree, and a stochastic exploration component.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                      distance_matrix[i, j] is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing the desirability
                    of including each edge in a TSP tour. Higher values indicate more desirable edges.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros((n, n))

    # 1. Inverse Distance: Shorter distances are generally better.  Avoid division by zero.
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))
    # Make diagonal elements 0
    np.fill_diagonal(inverse_distance, 0)

    # 2. Node Degree Preference: Prefer connecting to nodes with fewer connections made so far.
    #    This promotes exploration and helps avoid prematurely closing sub-tours.

    # Placeholder: Assume no connections initially. We can incorporate a dynamic
    # degree preference later if needed within a search algorithm using this heuristic.
    # For now, a simple "degree_incentive" encourages connections to all nodes.
    degree_incentive = np.ones((n, n))  # encourage connections, remove when some edges already selected

    # 3. Stochastic Exploration: Add a small random component to encourage exploration of
    #    less obvious edges. This helps escape local optima.  Scale randomness with problem size.
    random_component = np.random.rand(n, n) * 0.1 / n

    # Combine the heuristics: Weighted sum of the individual components.  Experiment with weights.
    heuristics = 0.7 * inverse_distance + 0.2 * degree_incentive + 0.1 * random_component

    return heuristics
```
