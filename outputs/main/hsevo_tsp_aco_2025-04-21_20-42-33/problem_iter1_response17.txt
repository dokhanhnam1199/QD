```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for the Traveling Salesman Problem (TSP) based on distance and
    a stochastic element (simulating quantum fluctuations!).

    The idea is to combine inverse distance (cities that are closer
    are more likely to be adjacent in the optimal tour) with a bit of
    "quantum" randomness, as if the path explores slightly beyond the immediate
    greediness.  Larger distances also get small but nonzero probability
    to occasionally break locality and allow potentially long, advantageous
    jumps that may escape local minima.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i, j]
                                       is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix,
                      representing the heuristic values for each edge.
                      Higher values indicate a more promising edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Apply inverse distance heuristic, with some "quantum" tweaks
    for i in range(n):
        for j in range(n):
            if i != j:
                distance = distance_matrix[i, j]
                # Heuristic component: inversely proportional to distance
                heuristic_val = 1.0 / (distance + 1e-9)  # Avoid division by zero

                # "Quantum" fluctuation: Introduce small random noise proportional to distance.
                # This adds exploration and can escape local minima.
                heuristic_val += np.random.normal(0, 0.01 / (distance + 1e-9))

                # Ensure non-negativity (probability-like)
                heuristic_matrix[i, j] = max(0.0, heuristic_val)
            else:
                heuristic_matrix[i, j] = 0.0  # Disallow self-loops
    return heuristic_matrix
```
