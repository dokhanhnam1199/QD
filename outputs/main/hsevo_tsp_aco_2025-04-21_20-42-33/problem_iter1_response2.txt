```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A more sophisticated heuristic for the Traveling Salesman Problem (TSP).

    This version considers:
    1. Inverse distance (as in v1): Shorter distances are more desirable.
    2. Node degree desirability: Nodes with fewer close neighbors should be prioritized
       to be connected early, preventing them from being isolated later.  This
       encourages a more globally optimal arrangement.
    3. Avoid long edges to already well-connected nodes: Edges connecting to high-degree nodes are penalized proportionally to their length.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i, j]
                                      is the distance between node i and node j.
                                      It is assumed that distance_matrix[i, i] = np.inf.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element
                    represents the desirability of including the corresponding edge
                    in a TSP solution. Higher values indicate more desirable edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # 1. Inverse Distance: Base desirability on the inverse of the distance.  Avoid division by zero by adding a small constant to the denominator.
    heuristic_matrix = 1 / (distance_matrix + 1e-9)

    # 2. Node Degree Desirability
    neighbor_counts = np.sum(distance_matrix < np.mean(distance_matrix[distance_matrix != np.inf]), axis=0)  # Count the neighbors each node has within a reasonable mean distance.

    for i in range(n):
        for j in range(n):
            if i != j:
                # Prioritize edges connecting to nodes with few neighbors
                heuristic_matrix[i, j] *= (1 + (n - neighbor_counts[i] - neighbor_counts[j])/n) #Boost for poorly connected nodes. Avoid connecting poorly connected nodes with poorly connected nodes.

    #3. Penalize Long edges to already well-connected nodes
    for i in range(n):
        for j in range(n):
            if i!= j:
                heuristic_matrix[i, j] /= (1 + (distance_matrix[i,j] * neighbor_counts[i]/n) +  (distance_matrix[i,j] * neighbor_counts[j]/n))



    return heuristic_matrix
```
