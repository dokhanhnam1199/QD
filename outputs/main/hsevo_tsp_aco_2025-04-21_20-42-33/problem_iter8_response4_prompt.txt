{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n### Better code\ndef heuristics_v0(distance_matrix: np.ndarray) -> np.ndarray:\n\n\n    \"\"\"TSP heuristic: Adaptive penalty, shortest paths, sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # 1. Inverse distance\n    inverse_distance = 1 / (distance_matrix + 1e-9)\n\n    # 2. Shortest path estimate (Dijkstra)\n    graph = scipy.sparse.csr_matrix(distance_matrix)\n    shortest_paths = dijkstra(graph, directed=False, indices=range(n))\n\n    # 3. Adaptive Degree Bias\n    degree_penalty = np.ones_like(distance_matrix)\n\n    # Calculate degrees and average degree based on inverse distances\n    degrees = np.sum(inverse_distance, axis=1) - np.diag(inverse_distance)\n    avg_degree = np.mean(degrees)\n\n    # Apply penalty only to edges connected to nodes with above-average degree\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if degrees[i] > avg_degree:\n                    degree_penalty[i, j] *= max(0.1, avg_degree / (degrees[i] + 1e-9))  # Reduced penalty\n                if degrees[j] > avg_degree:\n                    degree_penalty[i, j] *= max(0.1, avg_degree / (degrees[j] + 1e-9))  # Reduced penalty\n\n    # 4. Combine heuristics: Favor short edges on short paths, penalized by degree\n    heuristic_matrix = inverse_distance * degree_penalty / (shortest_paths + 1e-9)\n\n    # 5. Sparsification: Remove weak edges based on percentile\n    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 25)  # More aggressive\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    # 6. Normalize\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n      heuristic_matrix /= max_heuristic\n\n    return heuristic_matrix\n\n### Worse code\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"TSP heuristic: Combines inverse distance, adaptive degree bias, shortest paths, and node potential with sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Inverse distance\n    inverse_distance = 1 / (distance_matrix + 1e-9)\n\n    # Shortest path estimate (Dijkstra)\n    graph = scipy.sparse.csr_matrix(distance_matrix)\n    shortest_paths = dijkstra(graph, directed=False, indices=range(n))\n\n    # Adaptive degree bias\n    degree_penalty = np.ones((n, n))\n    degrees = np.sum(inverse_distance, axis=1)\n    avg_degree = np.mean(degrees)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                penalty_i = max(0.1, avg_degree / (degrees[i] + 1e-9)) # Ensure penalty is never zero to avoid division by zero later\n                penalty_j = max(0.1, avg_degree / (degrees[j] + 1e-9))\n                degree_penalty[i, j] = penalty_i * penalty_j\n            else:\n                degree_penalty[i, j] = 0\n\n    # Node potential (a global heuristic - closeness centrality approximation)\n    total_distance = np.sum(distance_matrix, axis=1)\n    node_potential = np.mean(total_distance) / (total_distance + 1e-9)\n    potential_matrix = np.outer(node_potential, node_potential)\n\n    # Combination strategy: weighted geometric mean\n    alpha = 0.6\n    beta = 0.3\n    gamma = 0.1 #weights\n\n    heuristic_matrix = (inverse_distance**alpha) * (degree_penalty**beta) * (potential_matrix**(gamma)) / (shortest_paths + 1e-9)\n\n\n    # Sparsification (adaptive threshold)\n    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 30) # Adjusted percentile\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n\n    # Post-Normalization\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix /= max_heuristic\n\n    return heuristic_matrix\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), the first heuristic uses sparsification with a fixed percentile (20), while the second uses a higher percentile (75) and adds controlled randomness. The first one performs sparsification before normalization while the second performs sparsification after normalization.\n\nComparing (2nd) vs (3rd), the third heuristic introduces stochasticity based on heuristic values (higher heuristic -> lower temperature) and uses a more aggressive sparsification (30th percentile).  The second heuristic adds randomness with a fixed temperature. The third heuristic makes the temperature adaptive.\n\nComparing (3rd) vs (4th), the fourth heuristic only applies the degree penalty if the degree is above the average and adds a small amount of randomness, ensuring non-zero values. The third heuristic applies a degree penalty regardless of being above average and applies a stochastic temperature scaled by heuristic value.\n\nComparing (4th) vs (5th), the fifth heuristic reduces the penalty applied to nodes with above-average degrees.\n\nComparing (5th) vs (6th), they are identical.\n\nComparing (1st) vs (17th), the adaptive degree penalty in (17th) applies penalty only when both nodes have row sums greater than the mean while first heuristic always applies a degree penalty.\n\nComparing (16th) vs (17th), The adaptive node degree penalty in 17th simply divides the heuristic matrix. In 16th, a pheromone inspired component is incorporated as a weighted sum.\n\nComparing (19th) vs (20th), they are identical. Comparing (1st) vs (20th), (1st) applies adaptive degree bias via geometric means, and sparsifies via percentile, whereas 20th uses weighted sum with degree penalty and a \"node potential\" term.\n\nOverall: The better heuristics tend to combine inverse distance with shortest paths and adaptive degree biases. Sparsification, controlled randomness, and normalization are also important. Adaptive temperature based on heuristic value and using geometric mean seems to perform better than using constant temperature or weighted sums. Penalizing high-degree nodes, encouraging exploration, and using node potential can further improve the heuristic. Applying sparsification earlier seems beneficial.\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, here's a refined view of self-reflection for designing better TSP heuristics, focusing on actionability and avoiding common pitfalls:\n\n*   **Keywords:** Component importance, adaptive penalties, sparsification timing, controlled randomness.\n\n*   **Advice:** Quantify the impact of each component (distance, degree, shortest path) during heuristic construction. Track their influence on solution quality to guide adaptive parameter adjustments.\n\n*   **Avoid:** Premature commitment to fixed parameter settings. Avoid overly complex, untestable combinations of components initially.\n\n*   **Explanation:** Continuous monitoring and evaluation are crucial. Instead of assuming a combination works, measure its effect.\n\n\nYour task is to write an improved function `heuristics_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}