```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Implements a heuristic function for the Traveling Salesman Problem (TSP).
    This function prioritizes shorter edges and penalizes edges that are
    part of longer connections between nodes. It also adds a small amount
    of randomness to avoid getting stuck in local optima and ensures a non-zero heuristic value.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i][j]
                                       represents the distance between node i and node j.

    Returns:
        np.ndarray: A heuristic matrix of the same shape as the distance_matrix,
                      representing the desirability of including each edge in the solution.
    """

    # Avoid division by zero
    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)

    # Prioritize shorter edges (inverse of distance)
    heuristic = 1 / distance_matrix

    # Penalize edges part of longer paths to discourage long detours.
    # We consider the shortest path length between other nodes besides i and j.
    # The longer the paths, the greater the penalization of edge(i,j).
    num_nodes = distance_matrix.shape[0]
    penalty = np.zeros_like(distance_matrix)
    for i in range(num_nodes):
        for j in range(num_nodes):
            if i != j:
                shortest_path_sum = 0
                for k in range(num_nodes):
                    if k != i and k != j:
                        min_dist_k = np.inf
                        for l in range(num_nodes):
                            if l != i and l != j and l != k:
                                min_dist_k = min(min_dist_k, distance_matrix[k][l])
                        shortest_path_sum += min_dist_k
                penalty[i][j] = shortest_path_sum / (num_nodes - 2) if (num_nodes > 2) else 0


    penalty = penalty / np.max(penalty) if np.max(penalty) > 0 else 0 # Normalize for balanced influence

    heuristic = heuristic * (1 - 0.5 * penalty)  # Reduce weight on edge(i,j) based on the shortest path sum penalty.

    # Add small random factor to avoid local optima
    heuristic = heuristic + np.random.rand(*heuristic.shape) * 0.01

    # Ensure the heuristic is not zero (important for stochastic sampling)
    heuristic = np.where(heuristic <= 0, 0.0001, heuristic)

    return heuristic
```
