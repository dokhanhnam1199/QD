```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A heuristic function for the Traveling Salesman Problem (TSP) that
    combines distance-based and global structure information to estimate
    the "promise" of including each edge in an optimal solution.

    The idea is to give high prior probability to:
    1. Shorter edges
    2. Edges that connect nodes which are far apart (avoid clustering).
    3. Edges that connect nodes to their nearest neighbours

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance
                                       matrix between cities. distance_matrix[i, j]
                                       gives the distance between city i and city j.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix,
                    representing the heuristic values for each edge. Higher
                    values indicate a more promising edge.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance heuristic
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small value to avoid division by zero

    # Heuristic encouraging connections between nodes that are far apart,
    # based on the intuition that solutions should not just connect
    # nearby clusters together.
    mean_distance = np.mean(distance_matrix)
    std_distance = np.std(distance_matrix)

    #Nearest neighbor heuristic
    nearest_neighbors = np.zeros_like(distance_matrix, dtype = float)
    for i in range(n):
      sorted_indices = np.argsort(distance_matrix[i,:])
      #consider the nearest k neighbors.  Larger k encourages more connections to neighbors.
      k = min(5, n - 1) #avoid array out of bounds, and avoid connecting a node to itself
      for j in sorted_indices[1:k+1]: #exclude itself

        nearest_neighbors[i,j] = 1.0

    heuristics = inverse_distance + (distance_matrix > mean_distance + 0.5 * std_distance) * inverse_distance + nearest_neighbors

    #Normalize to [0,1]
    max_heuristic = np.max(heuristics)
    min_heuristic = np.min(heuristics)
    heuristics = (heuristics - min_heuristic) / (max_heuristic - min_heuristic)


    return heuristics
```
