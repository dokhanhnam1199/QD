```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines inverse distance, shortest paths, and degree-based adjustment.
    Prioritizes shorter paths and avoids high-degree connections.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance
    base_heuristic = 1.0 / (distance_matrix + 1e-9)

    # Shortest paths
    path_lengths = np.zeros((n, n))
    for i in range(n):
      for j in range(n):
        path_lengths[i,j] = distance_matrix[i, j]
    for k in range(n):
      for i in range(n):
        for j in range(n):
          path_lengths[i, j] = min(path_lengths[i, j], path_lengths[i, k] + path_lengths[k, j])

    connectivity_bonus = path_lengths / (np.max(path_lengths) + 1e-9)
    heuristic_matrix = base_heuristic + (1 - connectivity_bonus)

    # Degree-based adjustment (penalize high-degree connections)
    degrees = np.sum(base_heuristic, axis=0) # Sum of inverse distances
    for i in range(n):
        for j in range(n):
             heuristic_matrix[i, j] /= (degrees[i] + degrees[j])**0.2 # Reduced degree penalty


    return heuristic_matrix
```
