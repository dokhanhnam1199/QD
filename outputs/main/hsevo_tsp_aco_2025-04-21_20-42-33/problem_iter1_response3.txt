```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Generates a heuristic matrix for the Traveling Salesman Problem (TSP) 
    based on a combination of distance, node degree, and clustering coefficient approximation.

    The goal is to provide a more informed prior about the likelihood of an edge
    being part of an optimal TSP tour.  Edges connecting nodes that are close, 
    well-connected within the broader graph, and that do not represent high-degree
    nodes (avoiding hubs that might lead to sub-optimal paths) are favored.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the pairwise
                                       distances between nodes.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each
                     element indicates the heuristic "promise" of the corresponding edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Basic distance heuristic (inverse distance): Closer is better
    distance_heuristic = 1.0 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # Node Degree heuristic: Penalize high degree nodes (avoid hubs)
    # Approximate degree based on inverse distances (sum of inverse distances to other nodes)
    node_degrees = np.sum(distance_heuristic, axis=1, keepdims=True) # shape (n, 1)
    degree_heuristic = 1.0 / (node_degrees @ node_degrees.T + 1e-9) # Penalize edges connecting nodes with potentially high degree. Outer product for all pairs.

    # Clustering Coefficient Approximation: Encourage connections within clusters.
    # If two nodes have many common neighbors (based on inverse distances),
    # the connection between them is more likely to be good.
    clustering_heuristic = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                # Number of "common neighbors" is approxiamted by sum of dot products
                # Each element is then multiplied by distance and degree values.
                common_neighbors_score = np.sum(distance_heuristic[i, :] * distance_heuristic[j, :])
                clustering_heuristic[i, j] = common_neighbors_score


    # Combine heuristics (weighted average) - experimentation may be needed to adjust weights
    alpha = 0.5   # Weight for distance heuristic
    beta = 0.3    # Weight for degree heuristic
    gamma = 0.2  # Weight for clustering heuristic

    heuristic_matrix = alpha * distance_heuristic + beta * degree_heuristic + gamma * clustering_heuristic


    # Ensure symmetry (TSP is typically symmetric):
    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2

    # Avoid self-loops:
    np.fill_diagonal(heuristic_matrix, 0)


    return heuristic_matrix
```
