[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a \"Best Fit\" heuristic logic for online bin packing.\n    Following the reflection, it avoids overly aggressive or explicit bonuses.\n    Instead, it assigns a higher priority to bins that, after accommodating the item,\n    would have the smallest remaining capacity. A perfect fit (zero remaining capacity)\n    naturally receives the highest priority in this scheme. Bins where the item does\n    not fit are assigned a very low (negative infinity) priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest priority score is the \"best fit\".\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A negative value indicates that the item does not fit in that bin.\n    potential_remaining_capacity = bins_remain_cap - item\n\n    # Initialize all priorities to a very low value (negative infinity).\n    # This effectively \"disqualifies\" bins that cannot fit the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    # A bin fits if its potential remaining capacity is non-negative.\n    fits_mask = potential_remaining_capacity >= 0\n\n    # For bins where the item fits, set their priority.\n    # To implement \"Best Fit\" (minimize remaining space), we want to maximize\n    # a score where a smaller positive `potential_remaining_capacity` leads\n    # to a higher score. This is achieved by taking the negative of the\n    # potential remaining capacity.\n    #\n    # Examples:\n    # - If remaining capacity is 0 (perfect fit), priority is 0.\n    # - If remaining capacity is 1, priority is -1.\n    # - If remaining capacity is 5, priority is -5.\n    #\n    # Since 0 > -1 > -5, a perfect fit naturally receives the highest priority,\n    # followed by the smallest positive remaining capacities.\n    priorities[fits_mask] = -potential_remaining_capacity[fits_mask]\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin based on the Best Fit (BF) strategy,\n    embodying simplicity and natural handling of edge cases.\n\n    The Best Fit strategy aims to place an item into the bin that will leave the\n    smallest amount of remaining empty space after the item is placed. This heuristic\n    is generally effective in minimizing the total number of bins used for Bin Packing\n    Problems.\n\n    This implementation prioritizes bins as follows:\n    1. **Non-fitting bins:** Bins where the item cannot be placed (remaining capacity\n       is less than the item size) are assigned a score of negative infinity. This\n       ensures they are never selected.\n    2. **Fitting bins (Best Fit):** For bins where the item fits, the score is calculated\n       such that bins leaving less remaining capacity receive a higher priority.\n       The score is `item - bins_remain_cap`.\n       - A smaller `bins_remain_cap` value (closer to `item`) results in a score\n         closer to zero (less negative), indicating higher priority.\n       - A **perfect fit** (where `bins_remain_cap` is exactly equal to `item`)\n         naturally results in a score of `0.0`, which is the highest possible score\n         from this calculation, effectively giving perfect fits the top priority\n         without requiring special handling or bonus rules.\n\n    This approach avoids complex conditional logic or floating-point tolerances\n    for special cases, as the core Best Fit calculation inherently provides the\n    desired prioritization for perfect fits and handles non-fits cleanly.\n\n    Args:\n        item: Size of the item to be placed.\n        bins_remain_cap: NumPy array representing the current remaining capacity of each bin.\n\n    Return:\n        NumPy array of the same size as `bins_remain_cap`, containing the priority score\n        for each bin. A higher score indicates a more desirable bin for the current item.\n    \"\"\"\n    # Initialize all priority scores to negative infinity. This ensures that any bin\n    # where the item cannot fit will have the lowest possible priority.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins have enough remaining capacity to accommodate the item.\n    # This comparison is robust for typical floating-point scenarios.\n    can_fit_mask = item <= bins_remain_cap\n\n    # For the bins where the item can fit, calculate their priority score based on Best Fit.\n    # We want to minimize the remaining space (`bins_remain_cap - item`).\n    # To convert this minimization problem into a maximization problem (where higher score is better),\n    # we can use the negative of the remaining space, or equivalently `item - bins_remain_cap`.\n    # This naturally assigns higher scores to bins that result in less empty space.\n    # Example: item=0.5\n    # - Bin 1 (cap=1.0): score = 0.5 - 1.0 = -0.5 (leaves 0.5 space)\n    # - Bin 2 (cap=0.7): score = 0.5 - 0.7 = -0.2 (leaves 0.2 space, better fit)\n    # - Bin 3 (cap=0.5): score = 0.5 - 0.5 = 0.0  (perfect fit, leaves 0.0 space, best)\n    # The maximum score (0.0) correctly indicates the optimal choice.\n    priority_scores[can_fit_mask] = item - bins_remain_cap[can_fit_mask]\n\n    return priority_scores",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic implements a Best Fit (BF) strategy. It prioritizes bins\n    that will result in the smallest remaining capacity after the item is placed.\n    Bins where the item does not fit are assigned the lowest possible priority.\n\n    This approach inherently prioritizes 'perfect fits' (where remaining capacity\n    is zero) because a remaining capacity of zero yields a priority score of 0,\n    which is mathematically higher than any negative score resulting from a\n    non-zero remaining capacity. This aligns with the reflection to avoid\n    arbitrary, extreme bonuses for perfect fits, as Best Fit naturally handles\n    these cases effectively by design.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority.\n    \"\"\"\n    # Calculate the potential remaining capacity for each bin if the item were placed there.\n    # Note: Some values in this array might be negative if the item does not fit.\n    potential_remainders = bins_remain_cap - item\n\n    # Create a boolean mask: True for bins where the item can fit (remaining_after_placement >= 0).\n    can_fit_mask = potential_remainders >= 0\n\n    # Initialize priority scores.\n    # For bins where the item fits: the score is the negative of the potential remaining capacity.\n    # This means a smaller positive remainder (tighter fit) results in a larger\n    # (closer to zero) priority score. A perfect fit (remainder 0) gets a score of 0.\n    # For bins where the item does not fit: assign a very low priority (-np.inf)\n    # to ensure these bins are never selected unless no other bins are available\n    # (in which case the system typically opens a new bin).\n    priorities = np.where(can_fit_mask, -potential_remainders, -np.inf)\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit heuristic.\n\n    This version adheres to the \"Best Fit\" principle, which aims to place\n    the item in the bin where it fits most snugly (i.e., leaves the smallest\n    positive remaining capacity). This approach is generally robust and\n    effective in practice for online bin packing, often leading to efficient\n    space utilization and minimizing the number of bins used.\n\n    The \"strict fit criteria\" implies that a bin is considered suitable only\n    if the item can be placed without exceeding its capacity (remaining capacity\n    must be non-negative). No special bonuses for perfect fits are applied,\n    keeping the heuristic \"simpler\" as suggested.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate more desirable bins. Bins where the item does\n        not fit will have a very low (negative infinity) priority to ensure\n        they are never selected.\n    \"\"\"\n    # Calculate the potential remaining capacity in each bin if the item were placed.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priority scores for all bins to negative infinity.\n    # This ensures that bins where the item cannot fit are never chosen.\n    # Use float dtype to accommodate -np.inf.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins the item can actually fit into.\n    # A bin fits if its potential remaining capacity is non-negative.\n    can_fit_mask = potential_remaining_cap >= 0\n\n    # For bins where the item fits, apply the Best Fit logic.\n    # Best Fit aims to minimize the remaining capacity after placement.\n    # To represent this as a priority score where higher is better, we negate\n    # the potential remaining capacity. A smaller (closer to zero) positive\n    # remainder will then result in a larger (less negative or positive)\n    # priority score, making it more attractive for selection.\n    priority_scores[can_fit_mask] = -potential_remaining_cap[can_fit_mask]\n\n    return priority_scores",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic implements a robust \"Best Fit\" strategy for online Bin Packing.\n    It prioritizes bins that will have the smallest *positive* remaining capacity\n    after the item is placed. This encourages keeping larger contiguous spaces\n    available in other bins. Bins where the item does not fit are assigned the\n    lowest possible priority.\n\n    This version focuses on simplicity and robustness:\n    1. **Robust Fit Check**: Uses a straightforward comparison (`bins_remain_cap >= item`)\n       to determine if an item fits, avoiding the complexities and potential pitfalls\n       of floating-point tolerance in identifying \"perfect fits\" or general fit criteria.\n    2. **Simple Prioritization**: Directly applies the Best Fit principle without\n       adding complex \"perfect fit bonuses\" or other intricate scoring mechanisms,\n       as simpler criteria often lead to more predictable and robust behavior.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable bin.\n    \"\"\"\n    # Initialize all priority scores to a very small negative number (-infinity).\n    # This ensures that bins where the item cannot fit are effectively disqualified\n    # from selection, unless no other options are available (which typically means\n    # a new bin would be opened in a full BPP algorithm, not handled by this function).\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins have sufficient remaining capacity for the item.\n    # This is a robust check: if the bin's capacity is less than the item size,\n    # the item simply does not fit. No floating-point tolerance is needed here\n    # beyond standard IEEE 754 precision for `item` and `bins_remain_cap`.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins where the item can fit:\n    # Calculate the remaining capacity if the item were placed.\n    # The Best Fit strategy aims to *minimize* this remaining capacity\n    # (i.e., `bins_remain_cap[i] - item`).\n    # To convert this minimization into a maximization priority score (where\n    # a higher score is better), we take the negative of the remaining capacity.\n    # Example:\n    # - If item is 3 and bin has 3 (perfect fit), remainder = 0, score = 0.\n    # - If item is 3 and bin has 4, remainder = 1, score = -1.\n    # - If item is 3 and bin has 10, remainder = 7, score = -7.\n    # A score of 0 is highest (most desirable), -1 is next, etc.\n    if np.any(can_fit_mask):\n        remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n        priority_scores[can_fit_mask] = -remaining_after_fit\n\n    return priority_scores",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a pure Best Fit heuristic.\n\n    This version avoids any explicit \"perfect fit bonus\" and instead relies\n    on the inherent property of the Best Fit heuristic: a perfect fit (zero\n    remaining capacity) will naturally yield the highest priority score\n    among all bins where the item fits. This ensures a continuous ranking\n    of bins based on how snugly the item fits, prioritizing the smallest\n    possible remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate more desirable bins. Bins where the item does\n        not fit will have a very low (negative infinity) priority to ensure\n        they are never selected.\n    \"\"\"\n    # Calculate the remaining capacity in each bin if the current item were placed there.\n    # This is a vectorized operation, applying to all bins simultaneously.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priority scores. Bins that cannot fit the item must have a\n    # very low priority (e.g., negative infinity) to ensure they are not chosen.\n    # We use a float dtype to accommodate -np.inf.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the indices of bins where the item can actually fit.\n    # A bin fits if its potential remaining capacity is non-negative.\n    can_fit_indices = potential_remaining_cap >= 0\n\n    # For bins where the item fits, assign a priority score.\n    # For Best Fit, we want to minimize `potential_remaining_cap`.\n    # By taking the negative of `potential_remaining_cap`, a smaller positive\n    # remaining capacity (which is desired for best fit) will result in a\n    # larger (less negative, i.e., higher) priority score.\n    # A perfect fit (0 remaining capacity) will result in a score of 0,\n    # which will be the highest score among all valid fits.\n    priority_scores[can_fit_indices] = -potential_remaining_cap[can_fit_indices]\n\n    return priority_scores",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a pure Best Fit heuristic without artificial over-prioritization.\n\n    This heuristic attempts to place an item into the bin that, if the item\n    were placed in it, would leave the smallest non-negative remaining capacity.\n    This strategy aims to keep bins as 'tight' as possible, potentially preserving\n    larger contiguous spaces in other bins for future, larger items.\n\n    This version adheres to the principle that simplicity in the priority function\n    often leads to more robust performance in online scenarios, avoiding\n    complex special-casing or artificial boosting of specific outcomes (like perfect fits)\n    beyond what the core Best Fit logic naturally provides. A perfect fit is\n    naturally the 'best' best fit, as it results in the smallest possible remaining space (zero).\n\n    Algorithm:\n    1. Initialize all bin priorities to negative infinity. This ensures bins\n       where the item cannot fit are never selected.\n    2. For all bins where the item *can* fit (i.e., `bins_remain_cap >= item`):\n        a. Calculate the hypothetical remaining space if the item were placed:\n           `remaining_space = bin_capacity - item_size`.\n        b. The priority for such a bin is the *negative* of this `remaining_space`.\n           This transforms the minimization problem (minimize remaining space)\n           into a maximization problem (maximize priority score).\n           - A perfect fit (0 remaining space) will yield a priority of 0.\n           - A near-perfect fit (small positive remaining space, e.g., 1.0)\n             will yield a slightly negative priority (e.g., -1.0).\n           - A loose fit (larger positive remaining space, e.g., 5.0)\n             will yield a more negative priority (e.g., -5.0).\n           Thus, bins with smaller remaining spaces (including perfect fits) naturally\n           receive higher (less negative or zero) priority scores.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more preferred bin.\n    \"\"\"\n    # Initialize all priorities to negative infinity. This ensures bins where the item\n    # does not fit are effectively disqualified.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify bins where the item can physically fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining space for only those bins where the item can fit.\n    remaining_space_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priorities. For Best Fit, we want to minimize the remaining space.\n    # To represent this as a priority (where higher is better), we take the negative\n    # of the remaining space. A smaller positive remaining space (or zero for perfect fit)\n    # results in a higher (less negative or zero) priority score.\n    priorities[can_fit_mask] = -remaining_space_after_fit\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version implements a Best-Fit-like strategy, prioritizing bins that,\n    after accommodating the item, would have the least remaining capacity (i.e., are \"snugly fit\").\n    Bins where the item does not fit receive a very low priority to ensure they are never chosen\n    if there's any bin where the item fits.\n\n    This design naturally integrates the \"perfect fit\" case (where remaining capacity is zero)\n    into the primary heuristic. A perfect fit will result in a hypothetical remaining capacity\n    of 0, leading to a priority score of 0, which is the highest possible score among bins\n    where the item fits. This avoids the need for arbitrary, extreme bonuses\n    for perfect fits, aligning with the principle of integrating ideal cases naturally.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the hypothetical remaining capacity if the item were placed in each bin.\n    # A smaller positive value here indicates a \"tighter\" fit (Best Fit).\n    hypothetical_remaining = bins_remain_cap - item\n\n    # Initialize priority scores with a very low value (-infinity) for all bins.\n    # This ensures bins where the item cannot fit will not be selected unless no other bin fits.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits.\n    # An item fits if the hypothetical_remaining capacity is non-negative.\n    fits_mask = hypothetical_remaining >= 0\n\n    # For bins where the item fits, assign a priority score.\n    # To implement Best Fit (minimize remaining capacity after placement),\n    # we take the negative of the hypothetical remaining capacity.\n    # This way, smaller positive remaining capacities result in larger (less negative) priority scores.\n    # Example:\n    # - If remaining = 0 (perfect fit), priority = 0 (highest possible for fitting bins).\n    # - If remaining = 5, priority = -5.\n    # - If remaining = 10, priority = -10.\n    # Maximizing this priority score will naturally pick the bin with the smallest remaining space.\n    priority_scores[fits_mask] = -hypothetical_remaining[fits_mask]\n\n    return priority_scores",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit heuristic.\n\n    The Best Fit heuristic aims to place the item in the bin where it fits\n    most snugly, i.e., leaving the smallest possible remaining capacity after\n    placement. This naturally prioritizes \"perfect fits\" (where remaining\n    capacity is zero) over other \"snug fits\" (where remaining capacity is small\n    but positive). This approach avoids explicit bonus handling for perfect fits,\n    maintaining simplicity as suggested by the reflection.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate more desirable bins. Bins where the item does\n        not fit will have a very low (negative infinity) priority to ensure\n        they are never selected.\n    \"\"\"\n    # Calculate the remaining capacity in each bin if the current item were placed there.\n    # This is a vectorized operation, applying to all bins simultaneously.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priority scores. Bins that cannot fit the item must have a\n    # very low priority (e.g., negative infinity) to ensure they are not chosen.\n    # We use a float dtype to accommodate -np.inf.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the indices of bins where the item can actually fit.\n    # A bin fits if its potential remaining capacity is non-negative.\n    # Using a small tolerance for floating point precision if necessary, but\n    # for simplicity and typical BPP, direct comparison is often sufficient.\n    can_fit_indices = potential_remaining_cap >= 0\n\n    # For bins where the item fits, assign a priority score.\n    # For Best Fit, we want to minimize `potential_remaining_cap`.\n    # By taking the negative of `potential_remaining_cap`, a smaller positive\n    # remaining capacity (which is desired for best fit) will result in a\n    # larger (less negative, i.e., higher) priority score.\n    # A perfect fit (potential_remaining_cap == 0) will result in a priority of 0,\n    # which is the highest possible score among valid fits, naturally prioritizing it.\n    priority_scores[can_fit_indices] = -potential_remaining_cap[can_fit_indices]\n\n    return priority_scores",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic implements a Best Fit (BF) strategy, optimized based on\n    the reflection points for simplicity and robustness against floating-point issues.\n\n    1.  **Simpler Best Fit handles perfect fits naturally:**\n        The core of this strategy is to calculate the remaining capacity if\n        the item is placed in each bin and then prioritize bins that leave\n        the smallest amount of space. This is achieved by negating the\n        remaining capacity.\n        -   A perfect fit (0 remaining capacity) will naturally result in\n            a priority score of 0, which is the highest possible score for a\n            valid placement.\n        -   Bins with a small positive remaining capacity will yield a\n            priority score close to 0 (e.g., -0.1 for 0.1 remaining),\n            correctly ranking them below perfect fits but above looser fits.\n        This eliminates the need for an explicit, arbitrarily large \"perfect\n        fit bonus\" and simplifies the logic while preserving the desired behavior.\n\n    2.  **Strict remaining capacity checks avoid invalid placements from\n        floating-point inaccuracies:**\n        Bins are considered suitable only if the remaining capacity after\n        placing the item is strictly non-negative (`>= 0`). This prevents\n        any scenario where an item might technically \"overflow\" a bin, even\n        by a tiny amount due to floating-point precision issues (e.g.,\n        if `bin_cap - item` results in `-1e-15`). Bins where the item\n        does not fit according to this strict criterion are assigned the\n        lowest possible priority (`-np.inf`).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # This can result in negative values for bins where the item does not fit.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item can strictly fit.\n    # A bin fits if the remaining capacity is zero or positive.\n    # This is the \"strict remaining capacity check\".\n    can_fit_mask = remaining_after_placement >= 0\n\n    # Initialize priority scores.\n    # Use np.where to efficiently assign scores based on the `can_fit_mask`.\n    # For bins that can fit: The priority is the negative of the remaining capacity.\n    #   A smaller positive remainder (tighter fit) results in a larger (less negative) score.\n    #   A perfect fit (0 remainder) results in a score of 0, which is the highest valid score.\n    # For bins that cannot fit: Assign -np.inf to ensure they are never selected\n    # unless no valid bins exist (in which case a new bin would typically be opened).\n    priority_scores = np.where(can_fit_mask, -remaining_after_placement, -np.inf)\n\n    return priority_scores",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]