{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log.\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n      return np.full_like(bins_remain_cap, -np.inf)  # No valid bins\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf #invalid bins\n\n    # Give high priority to bins that can fit the item without much waste.\n    priority = -waste\n\n    # Adjust priority based on how full the bin would be. Favor almost full bins.\n    fill_ratio = (bins_remain_cap - waste) / bins_remain_cap\n    fill_ratio[np.isinf(fill_ratio)] = 0  # Correct invalid fills\n    priority += fill_ratio*100  # Scale up the fill ratio effect.\n\n    # Penalize bins where the item barely fits (high waste).\n    close_fit_penalty = np.exp(waste)\n    close_fit_penalty[np.isinf(close_fit_penalty)] = 0\n\n    priority -= close_fit_penalty\n\n    #Ensure the priority of invalid bins are always very small\n    priority[bins_remain_cap< item]= -np.inf\n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill ratio with a bonus for near-full bins.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n    too_small_penalty = -1e9\n\n    if not np.any(can_fit):\n        space_needed = item - bins_remain_cap\n        return -space_needed # Prioritize bins needing least space\n\n    fill_ratio = item / bins_remain_cap\n    priorities = np.where(can_fit, fill_ratio, too_small_penalty)\n\n    remaining_space = bins_remain_cap - item\n    almost_full_bonus = np.exp(-5 * (remaining_space / bins_remain_cap))\n    priorities = np.where(can_fit, priorities + almost_full_bonus, too_small_penalty)\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log.\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n      return np.full_like(bins_remain_cap, -np.inf)  # No valid bins\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf #invalid bins\n\n    # Give high priority to bins that can fit the item.\n    priority = np.where(waste >= 0, 1, -np.inf)\n\n\n    #Adjust priority based on fill ratio, but scale it gently\n    fill_ratio = (bins_remain_cap - waste) / bins_remain_cap\n    fill_ratio[np.isinf(fill_ratio)] = 0  # Correct invalid fills\n\n    priority += fill_ratio * 10 #Scale back fill ratio\n\n    # Penalize small waste, but only a bit (avoid over-penalizing good fits)\n    waste_penalty = np.where((waste > 0) & (waste <= 0.1), -1, 0)\n    priority += waste_penalty\n    # If almost full bins available, give more priority to that\n    almost_full_bonus = np.where((fill_ratio >= 0.9), 2, 0)\n    priority += almost_full_bonus\n\n\n    #Ensure the priority of invalid bins are always very small\n    priority[bins_remain_cap< item]= -np.inf\n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log.\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n      return np.full_like(bins_remain_cap, -np.inf)  # No valid bins\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf #invalid bins\n\n    # Give high priority to bins that can fit the item without much waste.\n    priority = -waste\n\n    # Adjust priority based on how full the bin would be. Favor almost full bins.\n    fill_ratio = (bins_remain_cap - waste) / bins_remain_cap\n    fill_ratio[np.isinf(fill_ratio)] = 0  # Correct invalid fills\n    priority += fill_ratio*100  # Scale up the fill ratio effect.\n\n    # Penalize bins where the item barely fits (high waste).\n    close_fit_penalty = np.exp(waste)\n    close_fit_penalty[np.isinf(close_fit_penalty)] = 0\n\n    priority -= close_fit_penalty\n\n    #Ensure the priority of invalid bins are always very small\n    priority[bins_remain_cap< item]= -np.inf\n    return priority\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log.\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n      return np.full_like(bins_remain_cap, -np.inf)  # No valid bins\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf #invalid bins\n\n    # Give high priority to bins that can fit the item without much waste.\n    priority = -waste\n\n    # Adjust priority based on how full the bin would be. Favor almost full bins.\n    fill_ratio = (bins_remain_cap - waste) / bins_remain_cap\n    fill_ratio[np.isinf(fill_ratio)] = 0  # Correct invalid fills\n    priority += fill_ratio*100  # Scale up the fill ratio effect.\n\n    # Penalize bins where the item barely fits (high waste).\n    close_fit_penalty = np.exp(waste)\n    close_fit_penalty[np.isinf(close_fit_penalty)] = 0\n\n    priority -= close_fit_penalty\n\n    #Ensure the priority of invalid bins are always very small\n    priority[bins_remain_cap< item]= -np.inf\n    return priority\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill ratio, near-full bonus, and anti-fragmentation.\"\"\"\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if np.any(feasible_bins):\n        # Fill ratio priority\n        fill_ratio = item / bins_remain_cap[feasible_bins]\n        priorities[feasible_bins] = fill_ratio\n\n        # Near-full bonus\n        remaining_space = bins_remain_cap[feasible_bins] - item\n        almost_full_bonus = np.exp(-5 * remaining_space) #sharper than linear to emphasize near full\n        priorities[feasible_bins] += almost_full_bonus\n\n    else:\n        # If no bin fits, prioritize bins closest to fitting\n        space_needed = item - bins_remain_cap\n        priorities = -space_needed #Prioritize smallest need\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log.\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n      return np.full_like(bins_remain_cap, -np.inf)  # No valid bins\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf #invalid bins\n\n    # Give high priority to bins that can fit the item without much waste.\n    priority = -waste\n\n    # Adjust priority based on how full the bin would be. Favor almost full bins.\n    fill_ratio = (bins_remain_cap - waste) / bins_remain_cap\n    fill_ratio[np.isinf(fill_ratio)] = 0  # Correct invalid fills\n    priority += fill_ratio*100  # Scale up the fill ratio effect.\n\n    # Penalize bins where the item barely fits (high waste).\n    close_fit_penalty = np.exp(waste)\n    close_fit_penalty[np.isinf(close_fit_penalty)] = 0\n\n    priority -= close_fit_penalty\n\n    #Ensure the priority of invalid bins are always very small\n    priority[bins_remain_cap< item]= -np.inf\n    return priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log.\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n      return np.full_like(bins_remain_cap, -np.inf)  # No valid bins\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf #invalid bins\n\n    # Give high priority to bins that can fit the item.\n    priority = np.where(waste >= 0, 1, -np.inf)\n\n\n    #Adjust priority based on fill ratio, but scale it gently\n    fill_ratio = (bins_remain_cap - waste) / bins_remain_cap\n    fill_ratio[np.isinf(fill_ratio)] = 0  # Correct invalid fills\n\n    priority += fill_ratio * 10 #Scale back fill ratio\n\n    # Penalize small waste, but only a bit (avoid over-penalizing good fits)\n    waste_penalty = np.where((waste > 0) & (waste <= 0.1), -1, 0)\n    priority += waste_penalty\n    # If almost full bins available, give more priority to that\n    almost_full_bonus = np.where((fill_ratio >= 0.9), 2, 0)\n    priority += almost_full_bonus\n\n\n    #Ensure the priority of invalid bins are always very small\n    priority[bins_remain_cap< item]= -np.inf\n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill ratio and penalizes waste, avoids near misses.\"\"\"\n    remaining_after_packing = bins_remain_cap - item\n    \n    # Infeasible bins get lowest priority.\n    priorities = np.where(remaining_after_packing >= 0, 0.0, -np.inf)\n\n    # Fill ratio after packing, prioritize high utilization.\n    fill_ratio_after = item / bins_remain_cap\n    priorities = np.where(remaining_after_packing >=0, fill_ratio_after, priorities)\n    \n    # Penalize bins with too little waste (risk of near miss on next item).\n    waste_penalty = -np.exp(-bins_remain_cap/item*5) #Heavily penalize approaching 0 cap\n    priorities = np.where(remaining_after_packing >= 0, priorities + waste_penalty, priorities)\n    \n    # Return correct priority for edge cases\n    priorities = np.nan_to_num(priorities, nan=-np.inf)\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check and immediate disqualification.\n    feasible = bins_remain_cap >= item\n    priority[~feasible] = -np.inf  # Disqualify infeasible bins immediately\n    if not np.any(feasible):\n        return priority #Return all bins with -inf if there is no feasible bins.\n\n    # 2. Remaining capacity after placing the item.\n    remaining_capacity = bins_remain_cap - item\n\n    # 3. Prioritize bins with smaller waste but not too small. Avoid almost full bins\n    # unless no better choice exists. We use a scaled reciprocal of waste.\n    # Avoid zero division\n\n    waste = remaining_capacity[feasible]\n    min_waste = np.min(waste) #Find min waste\n    eps = 1e-6\n    priority[feasible] = (1 / (waste + eps)) * 10 # Scale the priority\n\n    # 4. Adjust for Fill Ratio: a balance favoring fuller bins, but avoid tiny remaining space.\n    fill_ratio = item / bins_remain_cap\n    fill_ratio[~feasible] = 0 #Setting fill ratio of infeasible bins to 0.\n\n    priority[feasible] += fill_ratio[feasible] * 5 # Scale the fill ratio effect.\n\n    # 5. Moderate penalty for bins that are *almost* full after placing the item.\n    #  This encourages using bins with more spare capacity when available.\n    almost_full_threshold = 0.10 # e.g., less than 10% remaining capacity is considered \"almost full\".\n\n    almost_full = (remaining_capacity > 0) & (remaining_capacity <= bins_remain_cap * almost_full_threshold) #check if there are bins with almost full after placing item\n    priority[almost_full] -= 2 # Moderate penalty\n\n\n    # 6. Adjust the priority with the best bin if we are desperate to fit this item\n    if(np.max(priority) == -np.inf):\n        priority[np.argmax(bins_remain_cap)] = 1 #Choosing the bin with the most capcity, if nothing else works.\n\n\n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check and immediate disqualification.\n    feasible = bins_remain_cap >= item\n    priority[~feasible] = -np.inf  # Disqualify infeasible bins immediately\n    if not np.any(feasible):\n        return priority #Return all bins with -inf if there is no feasible bins.\n\n    # 2. Remaining capacity after placing the item.\n    remaining_capacity = bins_remain_cap - item\n\n    # 3. Prioritize bins with smaller waste but not too small. Avoid almost full bins\n    # unless no better choice exists. We use a scaled reciprocal of waste.\n    # Avoid zero division\n\n    waste = remaining_capacity[feasible]\n    min_waste = np.min(waste) #Find min waste\n    eps = 1e-6\n    priority[feasible] = (1 / (waste + eps)) * 10 # Scale the priority\n\n    # 4. Adjust for Fill Ratio: a balance favoring fuller bins, but avoid tiny remaining space.\n    fill_ratio = item / bins_remain_cap\n    fill_ratio[~feasible] = 0 #Setting fill ratio of infeasible bins to 0.\n\n    priority[feasible] += fill_ratio[feasible] * 5 # Scale the fill ratio effect.\n\n    # 5. Moderate penalty for bins that are *almost* full after placing the item.\n    #  This encourages using bins with more spare capacity when available.\n    almost_full_threshold = 0.10 # e.g., less than 10% remaining capacity is considered \"almost full\".\n\n    almost_full = (remaining_capacity > 0) & (remaining_capacity <= bins_remain_cap * almost_full_threshold) #check if there are bins with almost full after placing item\n    priority[almost_full] -= 2 # Moderate penalty\n\n\n    # 6. Adjust the priority with the best bin if we are desperate to fit this item\n    if(np.max(priority) == -np.inf):\n        priority[np.argmax(bins_remain_cap)] = 1 #Choosing the bin with the most capcity, if nothing else works.\n\n\n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check and immediate disqualification.\n    feasible = bins_remain_cap >= item\n    priority[~feasible] = -np.inf  # Disqualify infeasible bins immediately\n    if not np.any(feasible):\n        return priority #Return all bins with -inf if there is no feasible bins.\n\n    # 2. Remaining capacity after placing the item.\n    remaining_capacity = bins_remain_cap - item\n\n    # 3. Prioritize bins with smaller waste but not too small. Avoid almost full bins\n    # unless no better choice exists. We use a scaled reciprocal of waste.\n    # Avoid zero division\n\n    waste = remaining_capacity[feasible]\n    min_waste = np.min(waste) #Find min waste\n    eps = 1e-6\n    priority[feasible] = (1 / (waste + eps)) * 10 # Scale the priority\n\n    # 4. Adjust for Fill Ratio: a balance favoring fuller bins, but avoid tiny remaining space.\n    fill_ratio = item / bins_remain_cap\n    fill_ratio[~feasible] = 0 #Setting fill ratio of infeasible bins to 0.\n\n    priority[feasible] += fill_ratio[feasible] * 5 # Scale the fill ratio effect.\n\n    # 5. Moderate penalty for bins that are *almost* full after placing the item.\n    #  This encourages using bins with more spare capacity when available.\n    almost_full_threshold = 0.10 # e.g., less than 10% remaining capacity is considered \"almost full\".\n\n    almost_full = (remaining_capacity > 0) & (remaining_capacity <= bins_remain_cap * almost_full_threshold) #check if there are bins with almost full after placing item\n    priority[almost_full] -= 2 # Moderate penalty\n\n\n    # 6. Adjust the priority with the best bin if we are desperate to fit this item\n    if(np.max(priority) == -np.inf):\n        priority[np.argmax(bins_remain_cap)] = 1 #Choosing the bin with the most capcity, if nothing else works.\n\n\n    return priority\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                almost_full_threshold: float = 0.1148909173281832,\n                almost_full_bonus: float = 0.19368803542391697,\n                anti_frag_weight: float = 0.10534646269589695) -> np.ndarray:\n    \"\"\"Combines fill ratio, near-full bonus, and anti-fragmentation. Avoids overly complex functions.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return np.full_like(bins_remain_cap, -np.inf)\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                almost_full_threshold: float = 0.1148909173281832,\n                almost_full_bonus: float = 0.19368803542391697,\n                anti_frag_weight: float = 0.10534646269589695) -> np.ndarray:\n    \"\"\"Combines fill ratio, near-full bonus, and anti-fragmentation. Avoids overly complex functions.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return np.full_like(bins_remain_cap, -np.inf)\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_capacity = bins_remain_cap - item\n\n    # Initialize priority array\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get the lowest priority\n    priority[remaining_capacity < 0] = -np.inf\n\n    # Feasible bins:\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Fill Ratio: Prefer bins that result in a higher fill ratio, but avoid perfect fit\n        fill_ratio = (bins_remain_cap[feasible_bins] - remaining_capacity[feasible_bins]) / bins_remain_cap[feasible_bins]\n\n        # Avoid perfect fit to allow flexibility for future items. Instead favor close to perfect\n        perfect_fit = (remaining_capacity[feasible_bins] == 0)\n        fill_ratio[perfect_fit] = 0 # setting the fill ratio to 0 if it is a perfect fit.\n        priority[feasible_bins] = fill_ratio * 100\n\n\n        # 2. Balance Waste: Penalize very small remaining capacity to reduce fragmentation\n        waste = remaining_capacity[feasible_bins]\n        small_waste = (waste > 0) & (waste <= 0.1)  # tunable threshold\n        priority[feasible_bins][small_waste] -= 50 #tunable param\n\n        #3. Prioritize bins with enough space to accommodate half the size of current item\n        enough_space = waste >= item/2\n        priority[feasible_bins][enough_space] += 20 #tunable param\n\n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_capacity = bins_remain_cap - item\n\n    # Initialize priority array\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get the lowest priority\n    priority[remaining_capacity < 0] = -np.inf\n\n    # Feasible bins:\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Fill Ratio: Prefer bins that result in a higher fill ratio, but avoid perfect fit\n        fill_ratio = (bins_remain_cap[feasible_bins] - remaining_capacity[feasible_bins]) / bins_remain_cap[feasible_bins]\n\n        # Avoid perfect fit to allow flexibility for future items. Instead favor close to perfect\n        perfect_fit = (remaining_capacity[feasible_bins] == 0)\n        fill_ratio[perfect_fit] = 0 # setting the fill ratio to 0 if it is a perfect fit.\n        priority[feasible_bins] = fill_ratio * 100\n\n\n        # 2. Balance Waste: Penalize very small remaining capacity to reduce fragmentation\n        waste = remaining_capacity[feasible_bins]\n        small_waste = (waste > 0) & (waste <= 0.1)  # tunable threshold\n        priority[feasible_bins][small_waste] -= 50 #tunable param\n\n        #3. Prioritize bins with enough space to accommodate half the size of current item\n        enough_space = waste >= item/2\n        priority[feasible_bins][enough_space] += 20 #tunable param\n\n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_capacity = bins_remain_cap - item\n\n    # Initialize priority array\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get the lowest priority\n    priority[remaining_capacity < 0] = -np.inf\n\n    # Feasible bins:\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Fill Ratio: Prefer bins that result in a higher fill ratio, but avoid perfect fit\n        fill_ratio = (bins_remain_cap[feasible_bins] - remaining_capacity[feasible_bins]) / bins_remain_cap[feasible_bins]\n\n        # Avoid perfect fit to allow flexibility for future items. Instead favor close to perfect\n        perfect_fit = (remaining_capacity[feasible_bins] == 0)\n        fill_ratio[perfect_fit] = 0 # setting the fill ratio to 0 if it is a perfect fit.\n        priority[feasible_bins] = fill_ratio * 100\n\n\n        # 2. Balance Waste: Penalize very small remaining capacity to reduce fragmentation\n        waste = remaining_capacity[feasible_bins]\n        small_waste = (waste > 0) & (waste <= 0.1)  # tunable threshold\n        priority[feasible_bins][small_waste] -= 50 #tunable param\n\n        #3. Prioritize bins with enough space to accommodate half the size of current item\n        enough_space = waste >= item/2\n        priority[feasible_bins][enough_space] += 20 #tunable param\n\n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_capacity = bins_remain_cap - item\n\n    # Initialize priority array\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get the lowest priority\n    priority[remaining_capacity < 0] = -np.inf\n\n    # Feasible bins:\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Fill Ratio: Prefer bins that result in a higher fill ratio, but avoid perfect fit\n        fill_ratio = (bins_remain_cap[feasible_bins] - remaining_capacity[feasible_bins]) / bins_remain_cap[feasible_bins]\n\n        # Avoid perfect fit to allow flexibility for future items. Instead favor close to perfect\n        perfect_fit = (remaining_capacity[feasible_bins] == 0)\n        fill_ratio[perfect_fit] = 0 # setting the fill ratio to 0 if it is a perfect fit.\n        priority[feasible_bins] = fill_ratio * 100\n\n\n        # 2. Balance Waste: Penalize very small remaining capacity to reduce fragmentation\n        waste = remaining_capacity[feasible_bins]\n        small_waste = (waste > 0) & (waste <= 0.1)  # tunable threshold\n        priority[feasible_bins][small_waste] -= 50 #tunable param\n\n        #3. Prioritize bins with enough space to accommodate half the size of current item\n        enough_space = waste >= item/2\n        priority[feasible_bins][enough_space] += 20 #tunable param\n\n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_capacity = bins_remain_cap - item\n\n    # Initialize priority array\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get the lowest priority\n    priority[remaining_capacity < 0] = -np.inf\n\n    # Feasible bins:\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Fill Ratio: Prefer bins that result in a higher fill ratio, but avoid perfect fit\n        fill_ratio = (bins_remain_cap[feasible_bins] - remaining_capacity[feasible_bins]) / bins_remain_cap[feasible_bins]\n\n        # Avoid perfect fit to allow flexibility for future items. Instead favor close to perfect\n        perfect_fit = (remaining_capacity[feasible_bins] == 0)\n        fill_ratio[perfect_fit] = 0 # setting the fill ratio to 0 if it is a perfect fit.\n        priority[feasible_bins] = fill_ratio * 100\n\n\n        # 2. Balance Waste: Penalize very small remaining capacity to reduce fragmentation\n        waste = remaining_capacity[feasible_bins]\n        small_waste = (waste > 0) & (waste <= 0.1)  # tunable threshold\n        priority[feasible_bins][small_waste] -= 50 #tunable param\n\n        #3. Prioritize bins with enough space to accommodate half the size of current item\n        enough_space = waste >= item/2\n        priority[feasible_bins][enough_space] += 20 #tunable param\n\n    return priority\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_capacity = bins_remain_cap - item\n\n    # Initialize priority array\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get the lowest priority\n    priority[remaining_capacity < 0] = -np.inf\n\n    # Feasible bins:\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Fill Ratio: Prefer bins that result in a higher fill ratio, but avoid perfect fit\n        fill_ratio = (bins_remain_cap[feasible_bins] - remaining_capacity[feasible_bins]) / bins_remain_cap[feasible_bins]\n\n        # Avoid perfect fit to allow flexibility for future items. Instead favor close to perfect\n        perfect_fit = (remaining_capacity[feasible_bins] == 0)\n        fill_ratio[perfect_fit] = 0 # setting the fill ratio to 0 if it is a perfect fit.\n        priority[feasible_bins] = fill_ratio * 100\n\n\n        # 2. Balance Waste: Penalize very small remaining capacity to reduce fragmentation\n        waste = remaining_capacity[feasible_bins]\n        small_waste = (waste > 0) & (waste <= 0.1)  # tunable threshold\n        priority[feasible_bins][small_waste] -= 50 #tunable param\n\n        #3. Prioritize bins with enough space to accommodate half the size of current item\n        enough_space = waste >= item/2\n        priority[feasible_bins][enough_space] += 20 #tunable param\n\n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}