{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best aspects of v0 and v1. Fill-based priority, perfect fit bonus, considers initial capacity.\"\"\"\n    priorities = np.full(bins_remain_cap.shape, -np.inf)\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n        return priorities\n    \n    priorities[eligible_bins] = bins_remain_cap[eligible_bins] - item #Minimizing waste\n    \n    perfect_fit = bins_remain_cap[eligible_bins] == item\n    if np.any(perfect_fit):\n        priorities[eligible_bins][perfect_fit] = np.inf #Big bonus for perfect fit.\n    \n    # Prioritize based on how full the bins would be\n    fill_ratio = (bins_remain_cap[eligible_bins] - item) / bins_remain_cap[eligible_bins]\n    priorities[eligible_bins] = -fill_ratio #Prioritize higher fill\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid priority: fill ratio, near-full bonus, anti-fragmentation, scaled capacity.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    fill_ratio = item / bins_remain_cap\n    priorities[feasible_bins] = fill_ratio[feasible_bins]\n\n    almost_full = (bins_remain_cap - item) < 0.1\n    priorities[feasible_bins & almost_full] += 0.5\n\n    remainder = bins_remain_cap - item\n    priorities[feasible_bins] += (1 - (remainder[feasible_bins] / np.max(bins_remain_cap))) * 0.2\n\n    priorities[feasible_bins] += (item / (bins_remain_cap[feasible_bins] + 0.0001)) * 0.1\n\n    too_small = bins_remain_cap < item\n    priorities[too_small] = -np.inf\n    \n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log.\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.full_like(bins_remain_cap, -np.inf)  # No valid bins\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # invalid bins\n\n    # Give high priority to bins that can fit the item without much waste.\n    priority = -waste\n\n    # Adjust priority based on how full the bin would be. Favor almost full bins.\n    fill_ratio = (bins_remain_cap - waste) / bins_remain_cap\n    fill_ratio[np.isinf(fill_ratio)] = 0  # Correct invalid fills\n    priority += fill_ratio * 100  # Scale up the fill ratio effect.\n\n    # Penalize bins where the item barely fits (high waste).  Make the penalty adaptive.\n    close_fit_penalty = np.exp(waste / (item + 1e-6))  # Normalize waste by item size.  Avoid division by zero.\n    close_fit_penalty[np.isinf(close_fit_penalty)] = 0\n\n    priority -= close_fit_penalty\n\n    # Bonus for bins that make the bin completely full\n    almost_full_bonus = np.exp(-np.abs(waste)) # Give a bonus if waste is close to zero\n    priority += almost_full_bonus * 50\n\n    # Small bonus for bins that are more than half full\n    half_full_bonus = (bins_remain_cap > np.mean(bins_remain_cap)) * 10\n    priority += half_full_bonus\n    #Ensure the priority of invalid bins are always very small\n    priority[bins_remain_cap < item] = -np.inf\n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines gravitational force and almost-full heuristics.\"\"\"\n\n    gravitational_constant = 1.0\n    distances = np.abs(bins_remain_cap - item)\n    forces = (gravitational_constant * bins_remain_cap) / (distances + 0.0001)**2\n    penalty = np.where(item > bins_remain_cap, -np.inf, 0)\n    priorities = forces + penalty\n\n    #Almost Full heuristic\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n      almost_full = np.where(feasible_bins)[0]\n      priorities[almost_full] += 1.0 / bins_remain_cap[almost_full]\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best aspects of v0 and v1. Fill-based priority, perfect fit bonus, considers initial capacity.\"\"\"\n    priorities = np.full(bins_remain_cap.shape, -np.inf)\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n        return priorities\n    \n    priorities[eligible_bins] = bins_remain_cap[eligible_bins] - item #Minimizing waste\n    \n    perfect_fit = bins_remain_cap[eligible_bins] == item\n    if np.any(perfect_fit):\n        priorities[eligible_bins][perfect_fit] = np.inf #Big bonus for perfect fit.\n    \n    # Prioritize based on how full the bins would be\n    fill_ratio = (bins_remain_cap[eligible_bins] - item) / bins_remain_cap[eligible_bins]\n    priorities[eligible_bins] = -fill_ratio #Prioritize higher fill\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log.\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.full_like(bins_remain_cap, -np.inf)  # No valid bins\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # invalid bins\n\n    # Give high priority to bins that can fit the item without much waste.\n    priority = -waste\n\n    # Adjust priority based on how full the bin would be. Favor almost full bins.\n    fill_ratio = (bins_remain_cap - waste) / bins_remain_cap\n    fill_ratio[np.isinf(fill_ratio)] = 0  # Correct invalid fills\n    priority += fill_ratio * 100  # Scale up the fill ratio effect.\n\n    # Penalize bins where the item barely fits (high waste).  Make the penalty adaptive.\n    close_fit_penalty = np.exp(waste / (item + 1e-6))  # Normalize waste by item size.  Avoid division by zero.\n    close_fit_penalty[np.isinf(close_fit_penalty)] = 0\n\n    priority -= close_fit_penalty\n\n    # Bonus for bins that make the bin completely full\n    almost_full_bonus = np.exp(-np.abs(waste)) # Give a bonus if waste is close to zero\n    priority += almost_full_bonus * 50\n\n    # Small bonus for bins that are more than half full\n    half_full_bonus = (bins_remain_cap > np.mean(bins_remain_cap)) * 10\n    priority += half_full_bonus\n    #Ensure the priority of invalid bins are always very small\n    priority[bins_remain_cap < item] = -np.inf\n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill ratio and waste penalty for bin selection.\"\"\"\n    remaining_after_packing = bins_remain_cap - item\n    \n    # Bins where the item doesn't fit get a very low priority.\n    priorities = np.where(remaining_after_packing >= 0, 0.0, -np.inf)\n\n    # Prioritize bins based on fill ratio *after* packing. We want high utilization.\n    fill_ratio_after = item / bins_remain_cap\n\n    # Add a bonus for filling a significant portion of the remaining space, up to a point.\n    # This promotes utilization, but not at the cost of over-filling.\n    priorities = np.where(remaining_after_packing >=0, fill_ratio_after, priorities)\n    \n    # Penalize bins that are too full (waste potential). Use exponential to heavily penalize near zero remain cap.\n    waste_penalty = -np.exp(-bins_remain_cap/item*5) #Heavily penalize approaching 0 cap\n    priorities = np.where(remaining_after_packing >= 0, priorities + waste_penalty, priorities)\n    \n    # Handle the case of division by zero for any bins with zero remaining capacity\n    # by setting them to lowest possible priority before fit consideration.\n    priorities = np.nan_to_num(priorities, nan=-np.inf)\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, too_small_penalty: float = -5502405977.670808, exponent_multiplier: float = -8.471824223010275) -> np.ndarray:\n    \"\"\"Combines exponential boost for near-full bins with fill-ratio consideration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n    remaining_space = bins_remain_cap - item\n    \n    # Exponential boost for near-full, combined with fill ratio.\n    fill_ratio = (bins_remain_cap - item) / bins_remain_cap\n    priorities = np.where(can_fit, np.exp(exponent_multiplier * (remaining_space/bins_remain_cap)) + (1-fill_ratio), too_small_penalty)\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log.\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n        return np.full_like(bins_remain_cap, -np.inf)  # No valid bins\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # invalid bins\n\n    # Give high priority to bins that can fit the item without much waste.\n    priority = -waste\n\n    # Adjust priority based on how full the bin would be. Favor almost full bins.\n    fill_ratio = (bins_remain_cap - waste) / bins_remain_cap\n    fill_ratio[np.isinf(fill_ratio)] = 0  # Correct invalid fills\n    priority += fill_ratio * 100  # Scale up the fill ratio effect.\n\n    # Penalize bins where the item barely fits (high waste) but also favor bins that create minimal waste\n    close_fit_penalty = np.exp(waste)\n    close_fit_penalty[np.isinf(close_fit_penalty)] = 0\n    priority -= close_fit_penalty\n\n    # Introduce a small bonus for bins with larger remaining capacity, encouraging space consolidation.\n    # This can help prevent creating many nearly-empty bins. However avoid bins that are too large\n    capacity_bonus = np.where(bins_remain_cap > item, np.log(bins_remain_cap), 0)\n    priority += capacity_bonus\n\n    # Adaptive scaling for fill ratio\n    adaptive_fill_scale = 50 + 50 * np.mean(fill_ratio)  # Scale based on average fill\n    priority += fill_ratio * adaptive_fill_scale\n\n    # Ensure the priority of invalid bins are always very small\n    priority[bins_remain_cap < item] = -np.inf\n\n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines exponential boost for near-full bins with fill-ratio consideration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    too_small_penalty = -1e9\n    can_fit = bins_remain_cap >= item\n    remaining_space = bins_remain_cap - item\n    \n    # Exponential boost for near-full, combined with fill ratio.\n    fill_ratio = (bins_remain_cap - item) / bins_remain_cap\n    priorities = np.where(can_fit, np.exp(-5 * (remaining_space/bins_remain_cap)) + (1-fill_ratio), too_small_penalty)\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Initialize priority array.\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify valid bins (bins with enough remaining capacity).\n    valid_bins = bins_remain_cap >= item\n\n    # If no valid bins, return -inf priority for all bins.\n    if not np.any(valid_bins):\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Calculate remaining capacity after placing the item in each bin.\n    remaining_capacity = bins_remain_cap - item\n\n    # Calculate waste for valid bins; otherwise, set to infinity.\n    waste = np.copy(remaining_capacity)\n    waste[remaining_capacity < 0] = np.inf\n\n    # Calculate fill ratio (how full the bin would be).\n    fill_ratio = (bins_remain_cap - waste) / bins_remain_cap\n    fill_ratio[np.isinf(fill_ratio)] = 0  # Handle cases where bins_remain_cap is zero\n    fill_ratio[fill_ratio < 0] = 0 #ensure fill ratio is not negative\n\n    # Prioritize bins based on fill ratio (higher fill ratio is better).\n    priority = fill_ratio * 100\n\n    # Adjust priority based on waste. Bins with very little waste get a bonus.\n    # Use a scaled exponential function to provide a sharper cutoff.\n    waste_penalty = np.exp(-waste * 5)  # Higher scaling factor for sharper cutoff\n    waste_penalty[np.isinf(waste_penalty)] = 0  #prevent inf values\n    priority += waste_penalty * 50  # Scale waste_penalty\n\n    # Add a bonus for bins that are nearly full *before* adding the item\n    pre_fill_ratio = (bins_remain_cap / np.max(bins_remain_cap)) # Normalize remaining capacity for consistent effect\n    priority += pre_fill_ratio * 20 #scale this effect\n\n    # Further refine the waste penalty based on item size.\n    # If item is relatively large, heavily penalize bins with very small waste\n    item_size_ratio = item / np.max(bins_remain_cap) # Normalize item size\n\n    if item_size_ratio > 0.5:  # If item is more than half the maximum bin capacity.\n        close_fit_penalty = np.exp(waste * 10) # Increased waste multiplier\n        close_fit_penalty[np.isinf(close_fit_penalty)] = 0\n        priority -= close_fit_penalty * 10\n\n    # Invalidate bins that can't fit the item.\n    priority[bins_remain_cap < item] = -np.inf\n\n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill ratio, remaining space, and initial capacity.\"\"\"\n\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if np.any(feasible_bins):\n        # Fill ratio priority\n        fill_ratio = item / bins_remain_cap\n        priorities[feasible_bins] = fill_ratio[feasible_bins]\n\n        # Remaining space priority (smaller remainder is better)\n        remaining_space = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] += (1 / (remaining_space + 0.00001)) * 0.3  # Small constant to avoid division by zero\n\n        # Initial capacity bonus (prioritize larger bins if they fit)\n        priorities[feasible_bins] += (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap)) * 0.1\n\n    else:\n        # If no bin fits, prioritize bins that are closest to fitting (least waste if we could split)\n        space_needed = item - bins_remain_cap\n        priorities = -space_needed #Negative because we prioritize smallest need\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill ratio, remaining space, and initial capacity.\"\"\"\n\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if np.any(feasible_bins):\n        # Fill ratio priority\n        fill_ratio = item / bins_remain_cap\n        priorities[feasible_bins] = fill_ratio[feasible_bins]\n\n        # Remaining space priority (smaller remainder is better)\n        remaining_space = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] += (1 / (remaining_space + 0.00001)) * 0.3  # Small constant to avoid division by zero\n\n        # Initial capacity bonus (prioritize larger bins if they fit)\n        priorities[feasible_bins] += (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap)) * 0.1\n\n    else:\n        # If no bin fits, prioritize bins that are closest to fitting (least waste if we could split)\n        space_needed = item - bins_remain_cap\n        priorities = -space_needed #Negative because we prioritize smallest need\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Initialize priority array.\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify valid bins (bins with enough remaining capacity).\n    valid_bins = bins_remain_cap >= item\n\n    # If no valid bins, return -inf priority for all bins.\n    if not np.any(valid_bins):\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Calculate remaining capacity after placing the item in each bin.\n    remaining_capacity = bins_remain_cap - item\n\n    # Calculate waste for valid bins; otherwise, set to infinity.\n    waste = np.copy(remaining_capacity)\n    waste[remaining_capacity < 0] = np.inf\n\n    # Calculate fill ratio (how full the bin would be).\n    fill_ratio = (bins_remain_cap - waste) / bins_remain_cap\n    fill_ratio[np.isinf(fill_ratio)] = 0  # Handle cases where bins_remain_cap is zero\n    fill_ratio[fill_ratio < 0] = 0 #ensure fill ratio is not negative\n\n    # Prioritize bins based on fill ratio (higher fill ratio is better).\n    priority = fill_ratio * 100\n\n    # Adjust priority based on waste. Bins with very little waste get a bonus.\n    # Use a scaled exponential function to provide a sharper cutoff.\n    waste_penalty = np.exp(-waste * 5)  # Higher scaling factor for sharper cutoff\n    waste_penalty[np.isinf(waste_penalty)] = 0  #prevent inf values\n    priority += waste_penalty * 50  # Scale waste_penalty\n\n    # Add a bonus for bins that are nearly full *before* adding the item\n    pre_fill_ratio = (bins_remain_cap / np.max(bins_remain_cap)) # Normalize remaining capacity for consistent effect\n    priority += pre_fill_ratio * 20 #scale this effect\n\n    # Further refine the waste penalty based on item size.\n    # If item is relatively large, heavily penalize bins with very small waste\n    item_size_ratio = item / np.max(bins_remain_cap) # Normalize item size\n\n    if item_size_ratio > 0.5:  # If item is more than half the maximum bin capacity.\n        close_fit_penalty = np.exp(waste * 10) # Increased waste multiplier\n        close_fit_penalty[np.isinf(close_fit_penalty)] = 0\n        priority -= close_fit_penalty * 10\n\n    # Invalidate bins that can't fit the item.\n    priority[bins_remain_cap < item] = -np.inf\n\n    return priority\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill ratio and remaining space.\"\"\"\n    remaining_after_packing = bins_remain_cap - item\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Fit check\n    fit_mask = remaining_after_packing >= 0\n    \n    if np.any(fit_mask):\n      #Fill ratio for suitable bins\n      fill_ratio_after = item / bins_remain_cap[fit_mask]\n      priorities[fit_mask] = fill_ratio_after\n      #Remaining space affect\n      remaining_space = bins_remain_cap[fit_mask] - item\n      priorities[fit_mask] = priorities[fit_mask] * (1/(remaining_space + 0.00001))\n      #Cap affect\n      priorities[fit_mask] = priorities[fit_mask] * bins_remain_cap[fit_mask]\n      \n\n    else:\n        space_needed = item - bins_remain_cap\n        priorities = -space_needed\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill ratio and remaining space.\"\"\"\n    remaining_after_packing = bins_remain_cap - item\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Fit check\n    fit_mask = remaining_after_packing >= 0\n    \n    if np.any(fit_mask):\n      #Fill ratio for suitable bins\n      fill_ratio_after = item / bins_remain_cap[fit_mask]\n      priorities[fit_mask] = fill_ratio_after\n      #Remaining space affect\n      remaining_space = bins_remain_cap[fit_mask] - item\n      priorities[fit_mask] = priorities[fit_mask] * (1/(remaining_space + 0.00001))\n      #Cap affect\n      priorities[fit_mask] = priorities[fit_mask] * bins_remain_cap[fit_mask]\n      \n\n    else:\n        space_needed = item - bins_remain_cap\n        priorities = -space_needed\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill ratio and remaining space.\"\"\"\n    remaining_after_packing = bins_remain_cap - item\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Fit check\n    fit_mask = remaining_after_packing >= 0\n    \n    if np.any(fit_mask):\n      #Fill ratio for suitable bins\n      fill_ratio_after = item / bins_remain_cap[fit_mask]\n      priorities[fit_mask] = fill_ratio_after\n      #Remaining space affect\n      remaining_space = bins_remain_cap[fit_mask] - item\n      priorities[fit_mask] = priorities[fit_mask] * (1/(remaining_space + 0.00001))\n      #Cap affect\n      priorities[fit_mask] = priorities[fit_mask] * bins_remain_cap[fit_mask]\n      \n\n    else:\n        space_needed = item - bins_remain_cap\n        priorities = -space_needed\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best aspects of v0 and v1, with focus on space utilization.\"\"\"\n    priorities = np.full(bins_remain_cap.shape, -np.inf) #Initialize with very low priority\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        priorities[valid_bins] = 0.0 #Give a base priority to valid bins\n\n        #Heuristic 1: Favor bins with tighter fit (similar to perfect fit bonus)\n        slack = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-slack)\n\n        #Heuristic 2: Give larger bins more weight to accomodate future items\n        priorities[valid_bins] += bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n\n        #Heuristic 3: Reward almost full bins (to encourage packing)\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-10*np.clip(remaining_space, a_min=0.001, a_max = None)) #Clip and boost factor 10.\n\n    else:\n        #Prioritize bins that are CLOSE to fitting, but penalize heavily\n        space_needed = item - bins_remain_cap\n        priorities = -space_needed * 10  #Large Negative Value\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best aspects of v0 and v1, with focus on space utilization.\"\"\"\n    priorities = np.full(bins_remain_cap.shape, -np.inf) #Initialize with very low priority\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        priorities[valid_bins] = 0.0 #Give a base priority to valid bins\n\n        #Heuristic 1: Favor bins with tighter fit (similar to perfect fit bonus)\n        slack = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-slack)\n\n        #Heuristic 2: Give larger bins more weight to accomodate future items\n        priorities[valid_bins] += bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n\n        #Heuristic 3: Reward almost full bins (to encourage packing)\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-10*np.clip(remaining_space, a_min=0.001, a_max = None)) #Clip and boost factor 10.\n\n    else:\n        #Prioritize bins that are CLOSE to fitting, but penalize heavily\n        space_needed = item - bins_remain_cap\n        priorities = -space_needed * 10  #Large Negative Value\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best aspects of v0 and v1, with focus on space utilization.\"\"\"\n    priorities = np.full(bins_remain_cap.shape, -np.inf) #Initialize with very low priority\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        priorities[valid_bins] = 0.0 #Give a base priority to valid bins\n\n        #Heuristic 1: Favor bins with tighter fit (similar to perfect fit bonus)\n        slack = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-slack)\n\n        #Heuristic 2: Give larger bins more weight to accomodate future items\n        priorities[valid_bins] += bins_remain_cap[valid_bins] / np.max(bins_remain_cap)\n\n        #Heuristic 3: Reward almost full bins (to encourage packing)\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-10*np.clip(remaining_space, a_min=0.001, a_max = None)) #Clip and boost factor 10.\n\n    else:\n        #Prioritize bins that are CLOSE to fitting, but penalize heavily\n        space_needed = item - bins_remain_cap\n        priorities = -space_needed * 10  #Large Negative Value\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}