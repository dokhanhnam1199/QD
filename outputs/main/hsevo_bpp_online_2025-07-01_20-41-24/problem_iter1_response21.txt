```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the interplay of energy and spacetime, we can consider the
    'gravitational pull' of each bin based on its remaining capacity, and the
    'resistance' of the item based on its size.  The best bin is the one that
    minimizes the total 'energy' after the item is placed.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # First, let's handle bins that can't fit the item
    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf  # Very low priority

    # Now, consider only bins that can fit the item.
    fit_indices = np.where(bins_remain_cap >= item)[0]

    if len(fit_indices) > 0:
        remaining_after_fit = bins_remain_cap[fit_indices] - item
        # Heuristic 1: Smaller remaining space is better (fuller bins are preferred).
        # This is analogous to minimizing the 'potential energy' in the bin.

        priorities[fit_indices] = 1.0 / (remaining_after_fit + 1e-6) #Avoid division by zero and gives high priority to nearly full bins.

        #Heuristic 2: Also prioritize bins which were quite full to begin with.
        priorities[fit_indices] += 1.0 / (bins_remain_cap[fit_indices] + 1e-6)


        # Heuristic 3: slightly prefer bins which are *just* big enough. Try to fill completely rather than wasting space.
        priorities[fit_indices] += np.exp(-10*(remaining_after_fit/item))


    return priorities
```
