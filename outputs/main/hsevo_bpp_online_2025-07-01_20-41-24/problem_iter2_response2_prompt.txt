{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(valid_bins):\n        # Focus on bins where the item fits\n        remaining_space = bins_remain_cap[valid_bins] - item\n        # Prioritize bins with smaller remaining space after adding the item.\n        # This tries to fill up bins more completely.  Avoids fragmenting the bin\n        priorities[valid_bins] = 1.0 / (remaining_space + 0.00001) #Adding a small number to avoid division by zero\n        #Give larger bins with enough room more weight to accommodate future items. This is because adding to larger bins has more space to be filled up.\n        priorities[valid_bins]= priorities[valid_bins] * bins_remain_cap[valid_bins]\n\n\n    else:\n        # If no bin fits, try to penalize near-misses less harshly, by prioritizing bins that are close to fitting.\n        space_needed = item - bins_remain_cap\n        priorities = -space_needed # Negative because we prioritize smallest need\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities to a very low value.\n    priorities = np.full(bins_remain_cap.shape, -np.inf)\n\n    # Bins that can accommodate the item get a base priority.\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1.0\n\n        # Heuristic 1: Reward bins that fit the item \"perfectly\" based on a small penalty (think Newton's Method: small corrections)\n        # This prevents creating many nearly-empty bins by favouring tighter fits.\n\n        slack = bins_remain_cap[valid_bins] - item\n        #Penalty inversely proportional to the slack\n        perfect_fit_bonus = np.exp(-slack**2) # Gaussian centred on zero, so best fit gets highest reward\n\n        priorities[valid_bins] += perfect_fit_bonus\n\n\n        # Heuristic 2: Penalize bins that have very high capacity but the item is relatively small compared to the bin's capacity.\n        # Try to use bins that are smaller first\n\n        capacity_ratio = item / bins_remain_cap[valid_bins]\n        large_bin_penalty = - (1 - capacity_ratio)**2  # Square it to make the penalty more pronounced\n\n        priorities[valid_bins] += large_bin_penalty #Subtract the penalty so lower ratio values get penalised more.\n\n\n        #Heuristic 3: If an item leaves little space remaining, reward it. This pushes packing of bins and improves space utilitization.\n\n        remaining_space = bins_remain_cap[valid_bins] - item\n        near_full_reward = np.exp(-1/np.clip(bins_remain_cap[valid_bins] - item, a_min=0.001, a_max = None)) #Clip to avoid division by 0 or very large values.\n\n        priorities[valid_bins] += near_full_reward\n    return priorities\n\n### Analyze & experience\n- *   **Comparing (1st) vs (20th),** the best heuristic uses an exponential function to prioritize partially filled bins, giving a capped boost based on remaining space relative to the total capacity, and a hard penalty for bins that cannot fit the item. The worst heuristic uses a fill ratio and quadratic penalty, normalizing the penalty by the maximum bin capacity. The first one focuses on efficient fitting using relative space, while the last attempts to balance fill ratio and a penalty, but may over-penalize.\n\n*   **Comparing (2nd) vs (19th),** the second best heuristic uses a combination of heuristics, including minimizing remaining space, prioritizing initially full bins, and slightly preferring bins just big enough. The 19th (duplicate of 18th), calculates a \"fit\" score, a normalized \"fullness\" score, and a \"rarity\" score based on exponential decay. The second best balances multiple factors with heuristics while the 19th normalizes remain capacity to calculate fullness.\n\n*   **Comparing (3rd) vs (4th),** the 3rd prioritizes bins where the item fits with a combined `cap*item / (remaining_space + 1e-9)` score and uses a simple negative value for bins that cannot fit. The 4th prioritizes bins based on fill ratio, adds a bonus for almost full bins after item addition, introduces a fragmentation penalty, and inverts remaining capacity scaled by item size. The 3rd is simpler but less nuanced than the 4th, which incorporates more factors.\n\n*   **Comparing (second worst) vs (worst),** the second worst heuristic (19th), which calculates a \"fit\" score, a normalized \"fullness\" score, and a \"rarity\" score based on exponential decay, heavily penalizing bins where the item doesn't fit. The worst heuristic (20th),uses a fill ratio and quadratic penalty, normalizing the penalty by the maximum bin capacity. The 19th uses a combination of scores whereas the last one uses ratio and penalty functions.\n\n*   **Overall:** The better heuristics use a combination of strategies like prioritizing almost full bins, penalizing waste, and considering the initial capacity of the bins. They often involve exponential functions or ratios to create a nuanced priority score. The worse heuristics tend to rely on simpler calculations or penalties that may not effectively balance the various factors involved in bin packing. Normalization plays a crucial role in several heuristics. Also, several heuristics are repeated (e.g., 6th and 4th, 10th and 9th, 19th and 18th).\n- \nOkay, let's redefine \"Current Self-Reflection\" to make it more effective for designing better bin packing heuristics, focusing on avoiding pitfalls that lead to ineffective analysis.\n\nHere's a refined approach:\n\n*   **Keywords:** Data-driven, adaptive, iterative, performance metrics, failure analysis, diversity.\n\n*   **Advice:** Analyze heuristic performance on diverse datasets. Track key metrics (bin count, runtime, waste). Use failures to refine priority functions and explore parameter tuning. Encourage exploration of diverse heuristic combinations.\n\n*   **Avoid:** Over-reliance on intuition, neglecting edge cases, ignoring computational cost, lack of performance measurement.\n\n*   **Explanation:** Shift from solely formula-based to data-driven. Emphasize iterative improvement using performance data across varied scenarios. Actively identify failure points to drive refinement and adaptation.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}