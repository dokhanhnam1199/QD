```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    valid_bins = bins_remain_cap >= item
    if not np.any(valid_bins):
        return np.full_like(bins_remain_cap, -np.inf)

    waste = bins_remain_cap - item
    priority = np.zeros_like(bins_remain_cap, dtype=float)
    priority[waste < 0] = -np.inf  # Invalidate bins where item doesn't fit
    valid_indices = waste >= 0

    if not np.any(valid_indices):
       return priority #no valid bins

    waste_valid = waste[valid_indices]
    bins_remain_cap_valid = bins_remain_cap[valid_indices]
    # Prioritize bins with minimal waste using a sigmoid function.
    # Sigmoid provides a smooth transition of preference.

    waste_penalty = 1 / (1 + np.exp(10 * (waste_valid / bins_remain_cap_valid - 0.1)))  # Adjusted sigmoid params

    priority[valid_indices] += waste_penalty * 50  # Scale penalty effect

    # Reward bins that will be filled optimally
    fill_ratio = (bins_remain_cap_valid - waste_valid) / bins_remain_cap_valid
    priority[valid_indices] += fill_ratio * 75 #Scale Fill Ratio

    # Add bonus to bins that have a large capacity
    priority[valid_indices] += np.log1p(bins_remain_cap_valid)*5

    # Prioritize bins with larger remaining capacity (but only moderately)
    # Helps distribute items and avoids overfilling small bins early on.
    capacity_bonus = np.sqrt(bins_remain_cap_valid)
    priority[valid_indices] += capacity_bonus * 2 #Scale capacity bonus


    # Small penalty if item fits perfectly
    perfect_fit = (waste_valid == 0)
    priority[valid_indices][perfect_fit] -= 1

    return priority
```
