```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Initialize priority array.
    priority = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify valid bins (bins with enough remaining capacity).
    valid_bins = bins_remain_cap >= item

    # If no valid bins, return -inf priority for all bins.
    if not np.any(valid_bins):
        return np.full_like(bins_remain_cap, -np.inf)

    # Calculate remaining capacity after placing the item in each bin.
    remaining_capacity = bins_remain_cap - item

    # Calculate waste for valid bins; otherwise, set to infinity.
    waste = np.copy(remaining_capacity)
    waste[remaining_capacity < 0] = np.inf

    # Calculate fill ratio (how full the bin would be).
    fill_ratio = (bins_remain_cap - waste) / bins_remain_cap
    fill_ratio[np.isinf(fill_ratio)] = 0  # Handle cases where bins_remain_cap is zero
    fill_ratio[fill_ratio < 0] = 0 #ensure fill ratio is not negative

    # Prioritize bins based on fill ratio (higher fill ratio is better).
    priority = fill_ratio * 100

    # Adjust priority based on waste. Bins with very little waste get a bonus.
    # Use a scaled exponential function to provide a sharper cutoff.
    waste_penalty = np.exp(-waste * 5)  # Higher scaling factor for sharper cutoff
    waste_penalty[np.isinf(waste_penalty)] = 0  #prevent inf values
    priority += waste_penalty * 50  # Scale waste_penalty

    # Add a bonus for bins that are nearly full *before* adding the item
    pre_fill_ratio = (bins_remain_cap / np.max(bins_remain_cap)) # Normalize remaining capacity for consistent effect
    priority += pre_fill_ratio * 20 #scale this effect

    # Further refine the waste penalty based on item size.
    # If item is relatively large, heavily penalize bins with very small waste
    item_size_ratio = item / np.max(bins_remain_cap) # Normalize item size

    if item_size_ratio > 0.5:  # If item is more than half the maximum bin capacity.
        close_fit_penalty = np.exp(waste * 10) # Increased waste multiplier
        close_fit_penalty[np.isinf(close_fit_penalty)] = 0
        priority -= close_fit_penalty * 10

    # Invalidate bins that can't fit the item.
    priority[bins_remain_cap < item] = -np.inf

    return priority
```
