{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log.\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n      return np.full_like(bins_remain_cap, -np.inf)  # No valid bins\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf #invalid bins\n\n    # Give high priority to bins that can fit the item without much waste.\n    priority = -waste\n\n    # Adjust priority based on how full the bin would be. Favor almost full bins.\n    fill_ratio = (bins_remain_cap - waste) / bins_remain_cap\n    fill_ratio[np.isinf(fill_ratio)] = 0  # Correct invalid fills\n    priority += fill_ratio*100  # Scale up the fill ratio effect.\n\n    # Penalize bins where the item barely fits (high waste).\n    close_fit_penalty = np.exp(waste)\n    close_fit_penalty[np.isinf(close_fit_penalty)] = 0\n\n    priority -= close_fit_penalty\n\n    #Ensure the priority of invalid bins are always very small\n    priority[bins_remain_cap< item]= -np.inf\n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check and immediate disqualification.\n    feasible = bins_remain_cap >= item\n    priority[~feasible] = -np.inf  # Disqualify infeasible bins immediately\n    if not np.any(feasible):\n        return priority #Return all bins with -inf if there is no feasible bins.\n\n    # 2. Remaining capacity after placing the item.\n    remaining_capacity = bins_remain_cap - item\n\n    # 3. Prioritize bins with smaller waste but not too small. Avoid almost full bins\n    # unless no better choice exists. We use a scaled reciprocal of waste.\n    # Avoid zero division\n\n    waste = remaining_capacity[feasible]\n    min_waste = np.min(waste) #Find min waste\n    eps = 1e-6\n    priority[feasible] = (1 / (waste + eps)) * 10 # Scale the priority\n\n    # 4. Adjust for Fill Ratio: a balance favoring fuller bins, but avoid tiny remaining space.\n    fill_ratio = item / bins_remain_cap\n    fill_ratio[~feasible] = 0 #Setting fill ratio of infeasible bins to 0.\n\n    priority[feasible] += fill_ratio[feasible] * 5 # Scale the fill ratio effect.\n\n    # 5. Moderate penalty for bins that are *almost* full after placing the item.\n    #  This encourages using bins with more spare capacity when available.\n    almost_full_threshold = 0.10 # e.g., less than 10% remaining capacity is considered \"almost full\".\n\n    almost_full = (remaining_capacity > 0) & (remaining_capacity <= bins_remain_cap * almost_full_threshold) #check if there are bins with almost full after placing item\n    priority[almost_full] -= 2 # Moderate penalty\n\n\n    # 6. Adjust the priority with the best bin if we are desperate to fit this item\n    if(np.max(priority) == -np.inf):\n        priority[np.argmax(bins_remain_cap)] = 1 #Choosing the bin with the most capcity, if nothing else works.\n\n\n    return priority\n\n### Analyze & experience\n- *Comparing (1st) vs (20th), we see*: The best heuristic uses a combination of waste minimization, fill ratio maximization, and a penalty for close fits implemented using numpy operations; The worst gives priority based on fill ratio, avoidance of perfect fits, penalization for small waste and prioritizing bins with enough space. This suggests that directly minimizing waste and accounting for fill ratio using numpy operations are important.\n*Comparing (2nd best) vs (second worst), we see*: The second-best heuristic uses fill ratio and near-full bonuses. The second worst prioritizes fill ratio and penalizes small waste and prioritizes enough space. Thus, exponential bonuses for almost full is prefered than linear functions for penalizing small waste.\n*Comparing (1st) vs (2nd), we see*: The best uses waste, fill ratio and waste penalty. The second best uses fill ratio, and near full bonus. The scaling factor and exact formula matters.\n*Comparing (3rd) vs (4th), we see*: The third uses fill ratio, penalizes small waste and bonus almost full. The fourth uses waste, fill ratio and waste penalty. A key difference is the waste_penalty. The fourth approach is ranked lower, suggesting that a more refined handling of remaining space is more effective.\n*Comparing (second worst) vs (worst), we see*: There is no difference.\n*Overall*: The better heuristics balances fill ratio, waste minimization, and fragmentation avoidance. Specifically, the better performing heuristics use numpy operations to directly compute waste, fill ratio, and apply penalties/bonuses. The best heuristic used a exponential penalty functions and scaled fill ration.\n- \nOkay, let's refine \"Current self-reflection\" to be more effective for designing bin packing heuristics.\n\nHere's a breakdown focusing on actionable advice and avoiding pitfalls:\n\n*   **Keywords:** Multifactorial evaluation, Performance bottlenecks, Fine-tuning, Non-linearity.\n\n*   **Advice:** Profile numpy operations to identify performance bottlenecks. Experiment systematically with different functional forms (exponential, logarithmic, sigmoid) for penalties/bonuses. Analyze the sensitivity of the heuristic to changes in scaling parameters.\n\n*   **Avoid:** Vague statements about \"considering\" factors. Avoid prematurely committing to specific functions without empirical validation.\n\n*   **Explanation:** Move beyond general goals. Focus on the *how* \u2013 profiling, experimentation, and sensitivity analysis are key to iterative improvement of heuristics.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}