{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\nCurrent heuristics:\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log.\n    valid_bins = bins_remain_cap > 0\n    if not np.any(valid_bins):\n      return np.full_like(bins_remain_cap, -np.inf)  # No valid bins\n\n    # Calculate the waste if the item is placed in each bin.\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf #invalid bins\n\n    # Give high priority to bins that can fit the item without much waste.\n    priority = -waste\n\n    # Adjust priority based on how full the bin would be. Favor almost full bins.\n    fill_ratio = (bins_remain_cap - waste) / bins_remain_cap\n    fill_ratio[np.isinf(fill_ratio)] = 0  # Correct invalid fills\n    priority += fill_ratio*100  # Scale up the fill ratio effect.\n\n    # Penalize bins where the item barely fits (high waste).\n    close_fit_penalty = np.exp(waste)\n    close_fit_penalty[np.isinf(close_fit_penalty)] = 0\n\n    priority -= close_fit_penalty\n\n    #Ensure the priority of invalid bins are always very small\n    priority[bins_remain_cap< item]= -np.inf\n    return priority\n\nNow, think outside the box write a mutated function `priority_v2` better than current version.\nYou can use some hints below:\n- \nOkay, let's redefine \"Current Self-Reflection\" to make it more effective for designing better bin packing heuristics, focusing on avoiding pitfalls that lead to ineffective analysis.\n\nHere's a refined approach:\n\n*   **Keywords:** Data-driven, adaptive, iterative, performance metrics, failure analysis, diversity.\n\n*   **Advice:** Analyze heuristic performance on diverse datasets. Track key metrics (bin count, runtime, waste). Use failures to refine priority functions and explore parameter tuning. Encourage exploration of diverse heuristic combinations.\n\n*   **Avoid:** Over-reliance on intuition, neglecting edge cases, ignoring computational cost, lack of performance measurement.\n\n*   **Explanation:** Shift from solely formula-based to data-driven. Emphasize iterative improvement using performance data across varied scenarios. Actively identify failure points to drive refinement and adaptation.\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}