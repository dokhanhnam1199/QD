```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines fill ratio and waste penalty for bin selection."""
    remaining_after_packing = bins_remain_cap - item
    
    # Bins where the item doesn't fit get a very low priority.
    priorities = np.where(remaining_after_packing >= 0, 0.0, -np.inf)

    # Prioritize bins based on fill ratio *after* packing. We want high utilization.
    fill_ratio_after = item / bins_remain_cap

    # Add a bonus for filling a significant portion of the remaining space, up to a point.
    # This promotes utilization, but not at the cost of over-filling.
    priorities = np.where(remaining_after_packing >=0, fill_ratio_after, priorities)
    
    # Penalize bins that are too full (waste potential). Use exponential to heavily penalize near zero remain cap.
    waste_penalty = -np.exp(-bins_remain_cap/item*5) #Heavily penalize approaching 0 cap
    priorities = np.where(remaining_after_packing >= 0, priorities + waste_penalty, priorities)
    
    # Handle the case of division by zero for any bins with zero remaining capacity
    # by setting them to lowest possible priority before fit consideration.
    priorities = np.nan_to_num(priorities, nan=-np.inf)

    return priorities
```
