```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins with capacity closest to the item size,
    but also penalizes bins that are too full (risk of waste) or too empty
    (inefficient packing).  It uses a combination of heuristics,
    inspired by the idea of wave functions collapsing into lower energy states.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Avoid division by zero, replace with a large negative number
    safe_bins_remain_cap = np.where(bins_remain_cap <= 0, -1e9, bins_remain_cap)

    # Proximity to ideal fit (item size)
    proximity = -np.abs(bins_remain_cap - item)

    # Penalize bins that are too full (waste potential). Use exponential to heavily penalize near zero remain cap.
    waste_penalty = -np.exp(-bins_remain_cap/item*5) #Heavily penalize approaching 0 cap

    # Penalize bins that are too empty. Using item*2 to check how much bigger can the bin be than the item.  Make it soft.
    emptiness_penalty = -np.abs(bins_remain_cap - item * 1.5)**0.5


    # Combine the factors
    priorities = proximity + waste_penalty + emptiness_penalty
    return priorities
```
