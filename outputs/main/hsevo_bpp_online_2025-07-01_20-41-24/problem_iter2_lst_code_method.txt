{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Prioritize bins where the item almost fills the bin but doesn't overflow.\n    # Bins that cannot contain the item get a very low priority.\n    # We use a capped exponential function to boost nearly full bins\n    # and a step function to penalize bins that are too small.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    #Large Negative Number for bins that are too small.\n    too_small_penalty = -1e9\n\n    #Check if the item fits\n    can_fit = bins_remain_cap >= item\n    \n    #Prioritize partially filled bins: Exponential score boost. Higher remaining capacity = more boost.\n    almost_full_bins = (bins_remain_cap - item) >=0\n    remaining_space = bins_remain_cap - item\n    \n    priorities = np.where(can_fit, np.exp(-5 * (remaining_space/bins_remain_cap)), too_small_penalty) #Experiment parameters\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the interplay of energy and spacetime, we can consider the\n    'gravitational pull' of each bin based on its remaining capacity, and the\n    'resistance' of the item based on its size.  The best bin is the one that\n    minimizes the total 'energy' after the item is placed.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, let's handle bins that can't fit the item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf  # Very low priority\n\n    # Now, consider only bins that can fit the item.\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n\n    if len(fit_indices) > 0:\n        remaining_after_fit = bins_remain_cap[fit_indices] - item\n        # Heuristic 1: Smaller remaining space is better (fuller bins are preferred).\n        # This is analogous to minimizing the 'potential energy' in the bin.\n\n        priorities[fit_indices] = 1.0 / (remaining_after_fit + 1e-6) #Avoid division by zero and gives high priority to nearly full bins.\n\n        #Heuristic 2: Also prioritize bins which were quite full to begin with.\n        priorities[fit_indices] += 1.0 / (bins_remain_cap[fit_indices] + 1e-6)\n\n\n        # Heuristic 3: slightly prefer bins which are *just* big enough. Try to fill completely rather than wasting space.\n        priorities[fit_indices] += np.exp(-10*(remaining_after_fit/item))\n\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Prioritize bins where the item fits\n            remaining_space = cap - item\n            priorities[i] = (cap*item) / (remaining_space + 1e-9)\n            # the bin is preferred if there is small remaining space\n        else:\n            # Very low priority if the item doesn't fit\n            priorities[i] = -1e9  # A very negative value\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Eliminate bins that cannot fit the item.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize bins where the item fills a significant portion of the remaining space\n    # but doesn't overfill it too much.\n\n    fill_ratio = item / bins_remain_cap\n    priorities[feasible_bins] = fill_ratio[feasible_bins]\n\n    # Add a bonus for bins that are almost full after adding the item\n    almost_full = (bins_remain_cap - item) < 0.1  # Threshold for \"almost full\"\n    priorities[feasible_bins & almost_full] += 0.5 # add a fixed score to increase chances of near-perfect fit\n   \n    # Introduce a penalty for fragmentation -- smaller remainder gives higher priority\n    remainder = bins_remain_cap - item\n    priorities[feasible_bins] += (1 - (remainder[feasible_bins] / np.max(bins_remain_cap)))*0.2\n   \n    # Invert remaining capacity; smaller gives bigger priority.  Scales remaining capacity based on item size for fair comparison between near full bins vs large bins.\n    priorities[feasible_bins] += (item/(bins_remain_cap[feasible_bins]+0.0001)) *0.1 #Added 0.0001 to deal with divide by zero errors\n\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with capacity closest to the item size,\n    but also penalizes bins that are too full (risk of waste) or too empty\n    (inefficient packing).  It uses a combination of heuristics,\n    inspired by the idea of wave functions collapsing into lower energy states.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Avoid division by zero, replace with a large negative number\n    safe_bins_remain_cap = np.where(bins_remain_cap <= 0, -1e9, bins_remain_cap)\n\n    # Proximity to ideal fit (item size)\n    proximity = -np.abs(bins_remain_cap - item)\n\n    # Penalize bins that are too full (waste potential). Use exponential to heavily penalize near zero remain cap.\n    waste_penalty = -np.exp(-bins_remain_cap/item*5) #Heavily penalize approaching 0 cap\n\n    # Penalize bins that are too empty. Using item*2 to check how much bigger can the bin be than the item.  Make it soft.\n    emptiness_penalty = -np.abs(bins_remain_cap - item * 1.5)**0.5\n\n\n    # Combine the factors\n    priorities = proximity + waste_penalty + emptiness_penalty\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Eliminate bins that cannot fit the item.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize bins where the item fills a significant portion of the remaining space\n    # but doesn't overfill it too much.\n\n    fill_ratio = item / bins_remain_cap\n    priorities[feasible_bins] = fill_ratio[feasible_bins]\n\n    # Add a bonus for bins that are almost full after adding the item\n    almost_full = (bins_remain_cap - item) < 0.1  # Threshold for \"almost full\"\n    priorities[feasible_bins & almost_full] += 0.5 # add a fixed score to increase chances of near-perfect fit\n   \n    # Introduce a penalty for fragmentation -- smaller remainder gives higher priority\n    remainder = bins_remain_cap - item\n    priorities[feasible_bins] += (1 - (remainder[feasible_bins] / np.max(bins_remain_cap)))*0.2\n   \n    # Invert remaining capacity; smaller gives bigger priority.  Scales remaining capacity based on item size for fair comparison between near full bins vs large bins.\n    priorities[feasible_bins] += (item/(bins_remain_cap[feasible_bins]+0.0001)) *0.1 #Added 0.0001 to deal with divide by zero errors\n\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the concept of event horizons. Bins closer to being 'filled' (item size approaching remaining capacity)\n    experience a higher 'gravitational pull' and thus are prioritized.  Bins that cannot accommodate are assigned -inf priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n      return np.full_like(bins_remain_cap, fill_value=-np.inf)\n\n    priorities[~eligible_bins] = -np.inf\n    \n    # Calculate how well the item 'fits' into each bin, considering the \"event horizon\" (perfect fit)\n    fit_score = 1.0 - np.abs(item - bins_remain_cap) / (bins_remain_cap[eligible_bins] + item)  #Normalize based on total size\n    #The \"fit score\" closer to 1 has a higher priority.\n\n    priorities[eligible_bins] = fit_score\n    \n    # Add a term which adds some importance for filling a bin up almost fully, resembling a final \"infall\"\n\n    close_to_full = (bins_remain_cap[eligible_bins] - item) / bins_remain_cap[eligible_bins] < 0.1\n\n    priorities[eligible_bins][close_to_full] += 0.5 #A \"bonus\" for full bins\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by gravitational force and potential energy. Bins are treated as attracting masses.\n    Larger capacity means larger mass, hence stronger attraction.\n    Closer distance (smaller difference between bin capacity and item size) means stronger attraction.\n    We add a penalty for bins where the item doesn't fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    gravitational_constant = 1.0  # Can be tuned. Affects relative importance of capacity and distance.\n\n    # Calculate the \"distance\" between the item size and the bin's remaining capacity.\n    distances = np.abs(bins_remain_cap - item)\n\n    # Calculate the \"gravitational force\".  Add a small constant to the denominator to avoid division by zero.\n    forces = (gravitational_constant * bins_remain_cap) / (distances + 0.0001)**2\n\n    # Penalty for bins where the item doesn't fit\n    penalty = np.where(item > bins_remain_cap, -np.inf, 0) #or -np.max(forces)*10 to make force adjustments meaningful\n\n\n    priorities = forces + penalty  # Higher force means higher priority\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(valid_bins):\n        # Focus on bins where the item fits\n        remaining_space = bins_remain_cap[valid_bins] - item\n        # Prioritize bins with smaller remaining space after adding the item.\n        # This tries to fill up bins more completely.  Avoids fragmenting the bin\n        priorities[valid_bins] = 1.0 / (remaining_space + 0.00001) #Adding a small number to avoid division by zero\n        #Give larger bins with enough room more weight to accommodate future items. This is because adding to larger bins has more space to be filled up.\n        priorities[valid_bins]= priorities[valid_bins] * bins_remain_cap[valid_bins]\n\n\n    else:\n        # If no bin fits, try to penalize near-misses less harshly, by prioritizing bins that are close to fitting.\n        space_needed = item - bins_remain_cap\n        priorities = -space_needed # Negative because we prioritize smallest need\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(valid_bins):\n        # Focus on bins where the item fits\n        remaining_space = bins_remain_cap[valid_bins] - item\n        # Prioritize bins with smaller remaining space after adding the item.\n        # This tries to fill up bins more completely.  Avoids fragmenting the bin\n        priorities[valid_bins] = 1.0 / (remaining_space + 0.00001) #Adding a small number to avoid division by zero\n        #Give larger bins with enough room more weight to accommodate future items. This is because adding to larger bins has more space to be filled up.\n        priorities[valid_bins]= priorities[valid_bins] * bins_remain_cap[valid_bins]\n\n\n    else:\n        # If no bin fits, try to penalize near-misses less harshly, by prioritizing bins that are close to fitting.\n        space_needed = item - bins_remain_cap\n        priorities = -space_needed # Negative because we prioritize smallest need\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Assign high priority to bins that can accommodate the item\n    can_accommodate = remaining_cap_after_add >= 0\n    priorities[can_accommodate] = 1 / (remaining_cap_after_add[can_accommodate] + 0.0001) # Avoid division by zero and prioritize bins with tighter fit\n    \n    # Assign a penalty for bins that cannot accommodate the item (optional, can be set to 0)\n    # priorities[~can_accommodate] = -1 # Penalize bins that cannot fit the item\n    \n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(valid_bins):\n        # Focus on bins where the item fits\n        remaining_space = bins_remain_cap[valid_bins] - item\n        # Prioritize bins with smaller remaining space after adding the item.\n        # This tries to fill up bins more completely.  Avoids fragmenting the bin\n        priorities[valid_bins] = 1.0 / (remaining_space + 0.00001) #Adding a small number to avoid division by zero\n        #Give larger bins with enough room more weight to accommodate future items. This is because adding to larger bins has more space to be filled up.\n        priorities[valid_bins]= priorities[valid_bins] * bins_remain_cap[valid_bins]\n\n\n    else:\n        # If no bin fits, try to penalize near-misses less harshly, by prioritizing bins that are close to fitting.\n        space_needed = item - bins_remain_cap\n        priorities = -space_needed # Negative because we prioritize smallest need\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # A bin must have sufficient space to even be considered\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No feasible bins, give a very tiny, but non-zero, negative priority to all,\n        # signifying they're to be opened as new bins. This encourages opening bins uniformly.\n        priorities[:] = -1e-9\n        return priorities\n\n    # Prioritize bins with smallest remaining capacity greater than or equal to item size (almost-full heuristic)\n    almost_full = np.where(feasible_bins)[0] # indices of bins\n    capacities_almost_full = bins_remain_cap[almost_full]\n    priorities[almost_full] = 1.0 / capacities_almost_full\n\n    # Adjust for waste. Bigger bins get slight negative penalty based on the bin size ratio,\n    # Encourages using smaller bins if multiple bins are able to fit the item\n    waste = bins_remain_cap - item\n    bin_size_ratio = bins_remain_cap/(np.max(bins_remain_cap))\n    penalties = np.zeros_like(priorities)\n    penalties[feasible_bins] = 0.1 * bin_size_ratio[feasible_bins]\n\n    priorities -= penalties\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities to a very low value.\n    priorities = np.full(bins_remain_cap.shape, -np.inf)\n\n    # Bins that can accommodate the item get a base priority.\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1.0\n\n        # Heuristic 1: Reward bins that fit the item \"perfectly\" based on a small penalty (think Newton's Method: small corrections)\n        # This prevents creating many nearly-empty bins by favouring tighter fits.\n\n        slack = bins_remain_cap[valid_bins] - item\n        #Penalty inversely proportional to the slack\n        perfect_fit_bonus = np.exp(-slack**2) # Gaussian centred on zero, so best fit gets highest reward\n\n        priorities[valid_bins] += perfect_fit_bonus\n\n\n        # Heuristic 2: Penalize bins that have very high capacity but the item is relatively small compared to the bin's capacity.\n        # Try to use bins that are smaller first\n\n        capacity_ratio = item / bins_remain_cap[valid_bins]\n        large_bin_penalty = - (1 - capacity_ratio)**2  # Square it to make the penalty more pronounced\n\n        priorities[valid_bins] += large_bin_penalty #Subtract the penalty so lower ratio values get penalised more.\n\n\n        #Heuristic 3: If an item leaves little space remaining, reward it. This pushes packing of bins and improves space utilitization.\n\n        remaining_space = bins_remain_cap[valid_bins] - item\n        near_full_reward = np.exp(-1/np.clip(bins_remain_cap[valid_bins] - item, a_min=0.001, a_max = None)) #Clip to avoid division by 0 or very large values.\n\n        priorities[valid_bins] += near_full_reward\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a very low value\n    priorities = np.full(bins_remain_cap.shape, -np.inf)\n\n    # Calculate the remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Give higher priority to bins that can accommodate the item\n    can_accommodate = remaining_after_add >= 0\n    priorities[can_accommodate] = bins_remain_cap[can_accommodate] - item # favour smaller waste\n\n    #If a bin can accommodate perfectly, increase priority significantly\n    perfect_fit = remaining_after_add == 0\n    priorities[perfect_fit] = np.inf\n\n    # Normalize priorities for stability.\n    if np.any(np.isfinite(priorities)): # prevent infs from messing up scaling\n        max_priority = np.max(priorities[np.isfinite(priorities)])\n        min_priority = np.min(priorities[np.isfinite(priorities)])\n        priorities[np.isfinite(priorities)] = (priorities[np.isfinite(priorities)] - min_priority) / (max_priority - min_priority)\n\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version uses a combination of remaining capacity and a \"near miss\" bonus to prioritize bins.\n    It prefers bins where the item fits reasonably well but also gives a small bonus to bins that are\n    close to being full after the item is added. This encourages filling bins as much as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Option 1: Penalize bins that are too small: big time\n    too_small = bins_remain_cap < item\n    priorities[too_small] = -np.inf\n\n    # Option 2: Prioritize bins that fit the item reasonably well. Using relative fit.\n    fit_scores = (bins_remain_cap - item) / bins_remain_cap\n    fit_scores[fit_scores < 0] = 0 # ensure priorities are not negative\n\n    # Add a small bonus for bins that will be nearly full after adding the item\n    near_full_bonus = np.exp(-10 * (bins_remain_cap - item))\n\n    # Overall Priority.  Mix up the fitness score and bonus to get a good filling algorithm.\n    priorities = fit_scores + 0.5 * near_full_bonus\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version prioritizes bins where the item fills a significant portion\n    of the remaining capacity, but also avoids near-full bins to prevent\n    excessive fragmentation.  A quadratic term penalizes bins that are\n    almost full after packing the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    remaining_after_packing = bins_remain_cap - item\n    \n    # Bins where the item doesn't fit get a very low priority.\n    priorities = np.where(remaining_after_packing >= 0, 0.0, -np.inf)\n\n    # Prioritize bins based on fill ratio *after* packing. We want high utilization.\n    fill_ratio_after = item / bins_remain_cap\n\n    # Add a bonus for filling a significant portion of the remaining space, up to a point.\n    # This promotes utilization, but not at the cost of over-filling.\n    priorities = np.where(remaining_after_packing >=0, fill_ratio_after, priorities)\n    \n    # A penalty for bins that are close to full after the item is packed.\n    # If remaining_after_packing is small, the penalty becomes larger.\n    # A quadratic penalty helps to strongly avoid very tight fits.\n    # Only apply penalty when packing is possible\n    penalty = np.where(remaining_after_packing >= 0, (1 - remaining_after_packing / np.max(bins_remain_cap))**2, 0)  # Normalize penalty by max capacity\n    priorities = np.where(remaining_after_packing >= 0, priorities - penalty, priorities)\n    \n    # Handle the case of division by zero for any bins with zero remaining capacity\n    # by setting them to lowest possible priority before fit consideration.\n    priorities = np.nan_to_num(priorities, nan=-np.inf)\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    My magnum opus! Harnessing the power of attraction and repulsion,\n    we guide the item with electrical precision!\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate a \"fit\" score, favoring bins where the item fits well.\n    fit_score = bins_remain_cap - item\n    fit_score[fit_score < 0] = -np.inf  # Heavily penalize bins where item doesn't fit\n\n    # Calculate a \"fullness\" score, encouraging bins to fill up.\n    fullness_score = bins_remain_cap / np.sum(bins_remain_cap) # Normalized remain capacity\n\n    # Introduce a \"rarity\" score, giving priority to less full bins with enough room.\n    # This is a negative penalty to reduce large swings\n    rarity_penalty = np.exp(-bins_remain_cap) if np.sum(bins_remain_cap) > 0 else 0\n\n    # Construct the grand symphony of priorities!\n    priorities = fit_score + (100*fullness_score) + rarity_penalty\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    My magnum opus! Harnessing the power of attraction and repulsion,\n    we guide the item with electrical precision!\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate a \"fit\" score, favoring bins where the item fits well.\n    fit_score = bins_remain_cap - item\n    fit_score[fit_score < 0] = -np.inf  # Heavily penalize bins where item doesn't fit\n\n    # Calculate a \"fullness\" score, encouraging bins to fill up.\n    fullness_score = bins_remain_cap / np.sum(bins_remain_cap) # Normalized remain capacity\n\n    # Introduce a \"rarity\" score, giving priority to less full bins with enough room.\n    # This is a negative penalty to reduce large swings\n    rarity_penalty = np.exp(-bins_remain_cap) if np.sum(bins_remain_cap) > 0 else 0\n\n    # Construct the grand symphony of priorities!\n    priorities = fit_score + (100*fullness_score) + rarity_penalty\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version prioritizes bins where the item fills a significant portion\n    of the remaining capacity, but also avoids near-full bins to prevent\n    excessive fragmentation.  A quadratic term penalizes bins that are\n    almost full after packing the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    remaining_after_packing = bins_remain_cap - item\n    \n    # Bins where the item doesn't fit get a very low priority.\n    priorities = np.where(remaining_after_packing >= 0, 0.0, -np.inf)\n\n    # Prioritize bins based on fill ratio *after* packing. We want high utilization.\n    fill_ratio_after = item / bins_remain_cap\n\n    # Add a bonus for filling a significant portion of the remaining space, up to a point.\n    # This promotes utilization, but not at the cost of over-filling.\n    priorities = np.where(remaining_after_packing >=0, fill_ratio_after, priorities)\n    \n    # A penalty for bins that are close to full after the item is packed.\n    # If remaining_after_packing is small, the penalty becomes larger.\n    # A quadratic penalty helps to strongly avoid very tight fits.\n    # Only apply penalty when packing is possible\n    penalty = np.where(remaining_after_packing >= 0, (1 - remaining_after_packing / np.max(bins_remain_cap))**2, 0)  # Normalize penalty by max capacity\n    priorities = np.where(remaining_after_packing >= 0, priorities - penalty, priorities)\n    \n    # Handle the case of division by zero for any bins with zero remaining capacity\n    # by setting them to lowest possible priority before fit consideration.\n    priorities = np.nan_to_num(priorities, nan=-np.inf)\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}