{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    # and penalizes bins where the remaining capacity is large compared to the item size\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition - item) / (item + 1e-6)), \n                                   0)\n    \n    # Combine the two scores to get the final priority score\n    priority_scores = bin_fullness_score + remaining_cap_score\n    \n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Priority is inversely proportional to the remaining capacity after adding the item.\n    Encourages a tight fit and normalizes priority scores between 0 and 1.\n    \"\"\"\n    # Mask for bins that can hold the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Priority is inversely proportional to the remaining capacity after adding the item\n    priority = np.where(valid_bins, 1 / (bins_remain_cap - item + 1e-6), 0)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority > 0:\n        priority /= max_priority\n    \n    return priority\n\n### Analyze & experience\n- Comparing the best heuristic (`Heuristics 1st`) with the worst (`Heuristics 20th`), we see that the top heuristic combines bin fullness and remaining capacity scores effectively, while the worst heuristic has repetitive and less effective scoring. \nComparing (`Heuristics 2nd`) vs (`Heuristics 19th`), we see that the second-best heuristic introduces weighted scores and epsilon for stability, whereas the second-worst heuristic lacks these refinements.\nComparing (`Heuristics 1st`) vs (`Heuristics 2nd`), we observe that both prioritize bins based on fullness and fit, but (`Heuristics 2nd`) includes additional parameters for tuning.\n(`Heuristics 3rd`) vs (`Heuristics 18th`) shows that (`Heuristics 3rd`) prioritizes bins based on remaining capacity after addition and fullness, while (`Heuristics 18th`) uses a \"fit score\" and \"fullness score\".\nOverall, top heuristics tend to have more nuanced scoring systems, consider multiple factors like bin fullness and item fit, and include mechanisms for stability and tuning.\n- \nTo redefine 'Current self-reflection', let's first analyze it and then derive new insights.\n\n### Analysis\nThe 'Current self-reflection' emphasizes combining multiple relevant factors, introducing tunable parameters for flexibility, and ensuring stability. It also prioritizes bins based on how tightly they can fit an item and considers normalizing priority scores.\n\n### Redefined Current self-reflection\nGiven there's no 'Ineffective self-reflection' to avoid, we'll build upon the existing ideas and expand them. Here's a redefined version broken down into 4 bullet points:\n\n* **Keywords**: Multi-factor heuristics, tunable parameters, stability techniques, bin prioritization, normalization.\n* **Advice**: Experiment with different combinations of factors and tunable parameters to find the optimal heuristic. Consider using machine learning techniques to learn the optimal parameters.\n* **Avoid**: Potentially complex and computationally expensive methods that don't significantly improve the heuristic's performance.\n* **Explanation**: By focusing on a combination of relevant factors, tunable parameters, and stability, and by prioritizing bins and normalizing scores, we can create more effective and adaptable heuristics.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}