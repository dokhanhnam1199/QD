{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a 'best-fit' score, where bins with remaining capacity closest to 0 are preferred\n    best_fit_score = np.where(has_enough_capacity, 1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), 0)\n    \n    # The priority score is a combination of the 'best-fit' score and a term that prioritizes fuller bins\n    priority_scores = np.where(has_enough_capacity, 0.5 * best_fit_score + 0.5 * (1 - (bins_remain_cap / (np.max(bins_remain_cap) + 1e-6))), -1)\n    \n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Prioritizes bins that fit the item tightly and have smaller remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(bins_remain_cap >= item, -diff, -np.inf)\n    \n    # In case of a tie, prefer the bin with the smallest remaining capacity\n    # by adding a small bonus based on the remaining capacity\n    bonus = np.where(np.isclose(priority - np.max(priority), 0), -bins_remain_cap / np.max(bins_remain_cap[bins_remain_cap >= item]), 0)\n    priority += bonus\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority > -np.inf:\n        priority = (priority - (-np.inf)) / (max_priority - (-np.inf))\n    \n    return priority\n\n### Analyze & experience\n- Comparing the best heuristic (`Heuristics 1st`) with the worst (`Heuristics 20th`), we see that the top heuristic combines bin fullness and remaining capacity scores effectively, while the worst heuristic has repetitive and less effective scoring. \nComparing (`Heuristics 2nd`) vs (`Heuristics 19th`), we see that the second-best heuristic introduces weighted scores and epsilon for stability, whereas the second-worst heuristic lacks these refinements.\nComparing (`Heuristics 1st`) vs (`Heuristics 2nd`), we observe that both prioritize bins based on fullness and fit, but (`Heuristics 2nd`) includes additional parameters for tuning.\n(`Heuristics 3rd`) vs (`Heuristics 18th`) shows that (`Heuristics 3rd`) prioritizes bins based on remaining capacity after addition and fullness, while (`Heuristics 18th`) uses a \"fit score\" and \"fullness score\".\nOverall, top heuristics tend to have more nuanced scoring systems, consider multiple factors like bin fullness and item fit, and include mechanisms for stability and tuning.\n- \nTo redefine 'Current self-reflection', let's first analyze it and then derive new insights.\n\n### Analysis\nThe 'Current self-reflection' emphasizes combining multiple relevant factors, introducing tunable parameters for flexibility, and ensuring stability. It also prioritizes bins based on how tightly they can fit an item and considers normalizing priority scores.\n\n### Redefined Current self-reflection\nGiven there's no 'Ineffective self-reflection' to avoid, we'll build upon the existing ideas and expand them. Here's a redefined version broken down into 4 bullet points:\n\n* **Keywords**: Multi-factor heuristics, tunable parameters, stability techniques, bin prioritization, normalization.\n* **Advice**: Experiment with different combinations of factors and tunable parameters to find the optimal heuristic. Consider using machine learning techniques to learn the optimal parameters.\n* **Avoid**: Potentially complex and computationally expensive methods that don't significantly improve the heuristic's performance.\n* **Explanation**: By focusing on a combination of relevant factors, tunable parameters, and stability, and by prioritizing bins and normalizing scores, we can create more effective and adaptable heuristics.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}