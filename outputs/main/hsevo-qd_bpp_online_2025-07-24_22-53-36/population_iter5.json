[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines elements of priority_v0 and priority_v1 to create a more effective heuristic.\n    Prioritizes bins based on remaining capacity after addition, fullness, and fit.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate priority score based on remaining capacity after addition and fullness\n    priority_scores = np.where(has_enough_capacity, \n                               (bins_remain_cap.max() - remaining_cap_after_addition) / (bins_remain_cap + 1e-6), \n                               -1)\n    \n    # Introduce a bonus for bins that fit the item tightly\n    diff = np.abs(bins_remain_cap - item)\n    bonus = np.where(has_enough_capacity, -diff / (bins_remain_cap.max() + 1e-6), 0)\n    priority_scores += bonus\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority_scores)\n    if max_priority > 0:\n        priority_scores = np.where(priority_scores > 0, priority_scores / max_priority, priority_scores)\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.5395382709427,
    "mi": 89.11397979631421,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins that fit the item tightly, are more full, and have smaller remaining capacity.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate the priority score for bins with enough capacity\n    # Higher priority for bins that are more full and fit the item tightly\n    tight_fit_score = 1 / (bins_remain_cap - item + 1e-6)\n    fullness_score = 1 / (bins_remain_cap + 1e-6)  # Prefer bins with smaller remaining capacity\n    priority_scores = np.where(has_enough_capacity, tight_fit_score + fullness_score, -np.inf)\n    \n    return priority_scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.5395382709427,
    "mi": 89.11397979631421,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin, \n    balancing bin fullness and remaining capacity after addition.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate scores for bins with enough capacity\n    fullness_score = 1 - (bins_remain_cap / (bins_remain_cap + item))  # Score for bin fullness\n    fit_score = 1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6))  # Score for item fit\n    \n    # Combine scores with tunable weights\n    priority_scores_enough_cap = 0.6 * fullness_score + 0.4 * fit_score\n    \n    # Assign low priority to bins without enough capacity\n    priority_scores_not_enough_cap = -1 * np.ones_like(bins_remain_cap)\n    \n    # Combine priority scores for bins with and without enough capacity\n    priority_scores = np.where(has_enough_capacity, priority_scores_enough_cap, priority_scores_not_enough_cap)\n    \n    return priority_scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.5395382709427,
    "mi": 89.11397979631421,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines bin fullness and remaining capacity scores with tunable weights for priority calculation.\n    Rewards bins that are full and have remaining capacity close to the item size.\n    \"\"\"\n    # Check if bin has enough capacity\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate scores for bin fullness and remaining capacity after addition\n    bin_fullness_score = np.where(has_enough_capacity, 1 - ((bins_remain_cap - item) / (bins_remain_cap + 1e-6)), -1)\n    remaining_cap_score = np.where(has_enough_capacity, 1 / (1 + np.abs(bins_remain_cap - item) / (item + 1e-6)), 0)\n    \n    # Combine scores with weights (0.6 for bin fullness and 0.4 for remaining capacity score)\n    # Weights can be tuned for optimal performance\n    priority_scores = 0.6 * bin_fullness_score + 0.4 * remaining_cap_score\n    \n    return priority_scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.5395382709427,
    "mi": 89.11397979631421,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines tight fit and normalization strategies with tunable parameters for better performance.\n    \"\"\"\n    # Calculate remaining capacity after adding item to each bin\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Give high priority to bins where item fits and penalize those where it doesn't\n    priority = np.where(remaining_cap_after_add >= 0, 1 / (remaining_cap_after_add + 1e-6), -np.inf)\n    \n    # Add a bonus based on the remaining capacity to break ties\n    bonus = np.where(remaining_cap_after_add >= 0, -bins_remain_cap / np.max(bins_remain_cap[bins_remain_cap >= item]), 0)\n    priority += bonus\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.5395382709427,
    "mi": 89.11397979631421,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 1e-6, \n                bin_fullness_weight: float = 1.0, \n                fit_score_weight: float = 0.5) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on bin fullness and item fit.\n    Combines elements of top heuristics for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item - item) / (item + epsilon)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with weights\n    priority_scores = bin_fullness_weight * bin_fullness_score + fit_score_weight * fit_score\n    \n    return priority_scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 3.9888312724371757,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.5395382709427,
    "mi": 89.11397979631421,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines 'best-fit' and 'fullness' scores for bin prioritization.\n    Prioritizes bins that fit the item tightly and are fuller.\n    \"\"\"\n    # Check if bin has enough capacity\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate 'best-fit' score\n    remaining_cap_after_addition = bins_remain_cap - item\n    best_fit_score = np.where(has_enough_capacity, 1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), 0)\n    \n    # Calculate 'fullness' score with bonus for fuller bins in case of a tie\n    fullness_score = np.where(has_enough_capacity, (1 - (bins_remain_cap / (np.max(bins_remain_cap) + 1e-6))), -1)\n    priority = 0.5 * best_fit_score + 0.5 * fullness_score\n    \n    # Normalize priority scores\n    max_priority = np.max(priority)\n    if max_priority > -1:\n        priority = (priority - (-1)) / (max_priority - (-1))\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.5395382709427,
    "mi": 89.11397979631421,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines bin fullness and remaining capacity scores effectively with tunable weights.\n    Prioritizes bins that are more full and have enough capacity for the item.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate priority scores for bins with enough capacity\n    # Weighted sum of bin's fullness and remaining capacity after addition\n    fullness_score = 1 - (bins_remain_cap / (bins_remain_cap + item))  # Score for bin fullness\n    remaining_score = 1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6))  # Score for remaining capacity\n    priority_scores_enough_cap = 0.6 * fullness_score + 0.4 * remaining_score  # Weighted sum\n    \n    # Assign low priority to bins without enough capacity\n    priority_scores_not_enough_cap = -1 * np.ones_like(bins_remain_cap)\n    \n    # Combine priority scores\n    priority_scores = np.where(has_enough_capacity, priority_scores_enough_cap, priority_scores_not_enough_cap)\n    \n    return priority_scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.5395382709427,
    "mi": 89.11397979631421,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Combines best fit strategy with a bonus for smaller remaining capacity.\n    \"\"\"\n    # Check if the item can fit in each bin and calculate priority\n    valid_bins = bins_remain_cap >= item\n    # Prioritize bins that fit the item tightly\n    fit_score = -np.abs(bins_remain_cap - item)\n    # Add a small bonus based on the remaining capacity to break ties\n    bonus = bins_remain_cap * 1e-6\n    # Combine fit score and bonus\n    priority = np.where(valid_bins, fit_score + bonus, -np.inf)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.5395382709427,
    "mi": 89.11397979631421,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines tight fit and fullness scores for bin prioritization.\n    \"\"\"\n    # Check if bin has enough capacity\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate tight fit score (higher when bin capacity is closer to item size)\n    tight_fit_score = np.where(has_enough_capacity, 1 / (bins_remain_cap - item + 1e-6), 0)\n    \n    # Normalize tight fit scores\n    max_tight_fit = np.max(tight_fit_score)\n    tight_fit_score = tight_fit_score / max_tight_fit if max_tight_fit > 0 else np.zeros_like(bins_remain_cap)\n    \n    # Calculate fullness score (higher when bin is more full)\n    fullness_score = 1 - (bins_remain_cap / (np.max(bins_remain_cap) + 1e-6))\n    \n    # Combine scores with equal weight\n    priority = np.where(has_enough_capacity, 0.5 * tight_fit_score + 0.5 * fullness_score, 0)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.5395382709427,
    "mi": 89.11397979631421,
    "token_count": 133.0,
    "exec_success": true
  }
]