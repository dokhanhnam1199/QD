[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 0.0,
    "mi": 100.0,
    "token_count": 32.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item and are more full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # The priority score is higher for bins that are more full (i.e., have less remaining capacity)\n    # and have enough capacity for the item\n    priority_scores = np.where(has_enough_capacity, 1 / (bins_remain_cap + 1e-6), -1)\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Give higher priority to bins that have just enough capacity for the item\n    # and lower priority to bins that are almost empty or almost full\n    priority = np.where(bins_remain_cap >= item, \n                         1 - (bins_remain_cap - item) / bins_remain_cap, \n                         -1.0)  # negative priority for bins that can't fit the item\n    \n    # Replace NaN values (which occur when bins_remain_cap is zero) with -1.0\n    priority = np.nan_to_num(priority, nan=-1.0)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This priority function encourages packing items into bins that have just enough capacity,\n    thereby minimizing waste and optimizing bin usage.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # The priority is higher for bins where the item fits exactly or leaves minimal remaining capacity\n    priority = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on how well the item fits into the remaining capacity of each bin.\n    A higher priority is given to bins where the item fits perfectly or leaves a large remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Give high priority to bins where the item fits (i.e., remaining capacity after adding is non-negative)\n    # and penalize bins where the item doesn't fit\n    priority = np.where(remaining_cap_after_add >= 0, remaining_cap_after_add, -np.inf)\n    \n    # To avoid division by zero, add a small value to the denominator\n    epsilon = 1e-6\n    \n    # Give higher priority to bins with smaller remaining capacity after adding the item (i.e., a tighter fit)\n    # This is done by taking the reciprocal of the remaining capacity after adding the item\n    priority = np.where(remaining_cap_after_add >= 0, 1 / (remaining_cap_after_add + epsilon), priority)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with remaining capacity closest to the item size gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    diff[bins_remain_cap < item] = np.inf\n    \n    # Calculate the priority score as the negative of the difference (lower difference means higher priority)\n    priority = -diff\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_diff = np.max(-priority[bins_remain_cap >= item])\n    if max_diff > 0:\n        priority[bins_remain_cap >= item] /= max_diff\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still hold the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can hold the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Priority is inversely proportional to the remaining capacity for valid bins\n    priority = np.where(valid_bins, 1 / (bins_remain_cap + 1e-6), 0)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority > 0:\n        priority /= max_priority\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still hold the item gets the highest priority.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The bin that has just enough capacity to hold the item gets the highest priority\n    priority = np.where(bins_remain_cap >= item, 1 - bins_remain_cap + item, -1)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    min_priority = np.min(priority)\n    if max_priority == min_priority:\n        return np.zeros_like(bins_remain_cap)\n    else:\n        return (priority - min_priority) / (max_priority - min_priority)",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score as the negative of the difference (so that the bin with the smallest difference gets the highest priority)\n    # Add a small value to the difference to avoid division by zero when the item size matches the remaining capacity exactly\n    priority = - (diff + 1e-6)\n    \n    # Set the priority score to negative infinity for bins that cannot accommodate the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is inversely proportional to the remaining capacity \n    after adding the item and directly proportional to the current \n    remaining capacity. This encourages using bins that are not too \n    empty and can still fit the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot fit the item get a priority of negative infinity\n    priority = np.where(remaining_after_addition >= 0, \n                        bins_remain_cap / (remaining_after_addition + 1e-9), \n                        -np.inf)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority score is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n    If a bin cannot hold the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # A bin with remaining capacity closest to the item size gets the highest priority\n    priorities = np.where(bins_remain_cap >= item, \n                          -np.abs(bins_remain_cap - item),  # Closer to item size is better\n                          -np.inf)  # Cannot hold the item, so priority is negative infinity\n    \n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a more sophisticated heuristic.\n\n    The priority is determined based on how well the item fits into the remaining capacity of each bin.\n    Bins that have just enough capacity for the item get the highest priority.\n    Bins that are too small for the item get a priority of negative infinity.\n    The priority decreases as the remaining capacity increases beyond the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Create a mask to identify bins that are too small for the item\n    too_small_mask = bins_remain_cap < item\n    \n    # For bins that have enough capacity, calculate the priority based on how well the item fits\n    priority = np.where(~too_small_mask, - (bins_remain_cap - item), -np.inf)\n    \n    # To avoid putting items into the same bin repeatedly, we can slightly decrease the priority of bins that are less full\n    # Here we assume that bins with more remaining capacity are less full\n    # However, this part can be adjusted or removed based on specific needs or problem characteristics\n    \n    return priority",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still hold the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The bin that has just enough capacity to hold the item gets the highest priority\n    priority = np.where(bins_remain_cap >= item, 1 - (bins_remain_cap - item) / bins_remain_cap, 0)\n    \n    # To avoid division by zero when bins_remain_cap is zero\n    priority = np.where(bins_remain_cap == 0, 0, priority)\n    \n    return priority",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # and how well the item fits into the bin. A higher score means the bin is more suitable.\n    priority_scores = np.where(bins_remain_cap >= item, \n                               1 - (bins_remain_cap - item) / bins_remain_cap, \n                               -1.0)  # Assign a low priority if the item doesn't fit\n    \n    return priority_scores",
    "response_id": 12,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high when the bin has just enough capacity for the item\n    # and low when the bin is empty or has a lot of remaining capacity\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1e-6), 0)\n    \n    return priority",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with remaining capacity closest to the item size gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    cap_diff = np.abs(bins_remain_cap - item)\n    \n    # If the item can fit into a bin, the priority is inversely proportional to the difference\n    # between the remaining capacity and the item size. If it can't fit, the priority is 0 (or a very low value).\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + cap_diff), -1e9)\n    \n    return priority",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prefers bins that have just enough capacity to hold the item.\n    It discourages bins that are too empty or too full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item get a priority score of -inf\n    priority = np.where(remaining_after_addition >= 0, remaining_after_addition, -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1\n    # This is done to avoid numerical issues and make the scores more interpretable\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = np.where(priority != -np.inf, priority / max_priority, -np.inf)\n    else:\n        priority = np.zeros_like(priority)\n    \n    return priority",
    "response_id": 15,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still hold the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # For bins that can hold the item, the priority is inversely proportional to the remaining capacity\n    # For bins that cannot hold the item, the priority is negative infinity\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap + 1e-6), -np.inf)\n    \n    return priority",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # For each bin, check if the item can fit. If not, priority is -inf.\n    # For bins that can fit the item, priority is higher for bins with less remaining capacity\n    # (i.e., bins that are more full), to encourage packing items tightly.\n    priorities = np.where(bins_remain_cap >= item, -bins_remain_cap, -np.inf)\n    return priorities",
    "response_id": 17,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version uses a heuristic that prioritizes bins that have just enough capacity for the item.\n    The priority is calculated as the negative of the absolute difference between the remaining capacity and the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin as the negative of the absolute difference between the remaining capacity and the item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Set the priority score to negative infinity for bins that cannot hold the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n    If a bin cannot hold the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit in each bin\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate the priority for valid bins based on the remaining capacity\n    priority = np.where(valid_bins, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    return priority",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + diff), -1e9)\n    \n    return priority",
    "response_id": 20,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity that is just enough to hold the item gets the highest priority.\n    A bin that cannot hold the item gets a priority of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority for each bin\n    # If the bin cannot hold the item, set the priority to negative infinity\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Normalize the priority to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority == -np.inf:  # If all bins are too small\n        return np.zeros_like(bins_remain_cap)\n    else:\n        return priority / max_priority",
    "response_id": 21,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin. \n    Bins with remaining capacity closest to the item size are given higher priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # Bins with remaining capacity closest to the item size are given higher priority\n    # We use the negative absolute difference to simulate \"closest\"\n    priority_scores = -np.abs(bins_remain_cap - item)\n    \n    # To avoid putting items into bins that are too small, set the priority score to -inf for bins that cannot fit the item\n    priority_scores[bins_remain_cap < item] = -np.inf\n    \n    return priority_scores",
    "response_id": 22,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on the remaining capacity and the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on how well the item fits into the bin\n    # A higher score indicates a better fit\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Normalize the priority score to ensure it's in a comparable range\n    # Here, we use the negative of the remaining capacity after adding the item as the priority score\n    # This encourages the algorithm to fill the bins as much as possible\n    \n    return priority",
    "response_id": 23,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements the First-Fit decreasing heuristic with a twist.\n    It prioritizes bins that have just enough capacity for the item.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to prioritize bins that have just enough capacity for the item\n    # So, we use the negative of the remaining capacity after adding the item\n    # This way, bins that are too small will have a large negative score and be ignored\n    # Bins that are just the right size will have a score close to zero and be prioritized\n    priority_scores = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    return priority_scores",
    "response_id": 24,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority score is based on how well the item fits into the bin.\n    A higher score indicates a better fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priority = np.where(remaining_cap_after_addition >= 0, \n                        # For bins that can hold the item, the priority is inversely proportional to the remaining capacity\n                        # This encourages packing items tightly\n                        1 / (1 + remaining_cap_after_addition), \n                        # For bins that cannot hold the item, the priority is negative infinity\n                        -np.inf)\n    \n    return priority",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # and the size of the item. A bin with a remaining capacity closest to the \n    # item size will be given the highest priority.\n    priority = np.where(bins_remain_cap >= item, \n                        bins_remain_cap - item,  # Best fit strategy\n                        -np.inf)  # Avoid bins that are too small\n    \n    # In case of a tie, prefer the bin with the smallest remaining capacity\n    # to minimize the number of bins used.\n    priority = np.where(np.isclose(priority - np.max(priority), 0), \n                        bins_remain_cap, priority)\n    \n    return priority",
    "response_id": 26,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high if the bin has just enough capacity for the item\n    # and low if the bin is almost empty or almost full\n    scores = np.where(bins_remain_cap >= item, \n                       1 - (bins_remain_cap - item) / bins_remain_cap, \n                       0)\n    \n    # Normalize the scores to be between 0 and 1\n    max_score = np.max(scores)\n    if max_score > 0:\n        scores /= max_score\n    \n    return scores",
    "response_id": 27,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # We want to pack the item into the bin with the least remaining capacity that can still fit the item\n    # So, we give higher priority to bins with smaller remaining capacity (after packing the item)\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1e-6), 0)\n    \n    # Return the priority score for each bin\n    return priority",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign high priority to bins that have enough capacity and will have the least remaining capacity after adding the item\n    priority = np.where(remaining_cap_after_addition >= 0, -remaining_cap_after_addition, -np.inf)\n    \n    # Normalize the priority scores\n    max_priority = np.max(priority)\n    if max_priority == -np.inf:  # No bin has enough capacity\n        return np.zeros_like(bins_remain_cap)\n    else:\n        return priority - max_priority",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.52932501298082,
    "mi": 85.34402938958283,
    "token_count": 96.0,
    "exec_success": true
  }
]