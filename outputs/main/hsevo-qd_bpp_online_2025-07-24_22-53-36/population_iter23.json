[
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 1e-6, \n                bin_fullness_weight: float = 1.0, \n                fit_score_weight: float = 0.5) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on bin fullness and item fit.\n    Combines elements of top heuristics for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item - item) / (item + epsilon)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with weights\n    priority_scores = bin_fullness_weight * bin_fullness_score + fit_score_weight * fit_score\n    \n    return priority_scores",
    "response_id": 5,
    "tryHS": true,
    "obj": 3.9888312724371757,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.5395382709427,
    "mi": 89.11397979631421,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n    This version introduces tunable parameters for flexibility and stability.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Tunable parameters\n    alpha = 1.0  # weight for bin fullness score\n    beta = 1.0   # weight for remaining capacity score\n    gamma = 1.0  # weight for item size similarity score\n    \n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition) / (item + 1e-6)), \n                                   0)\n    \n    # Calculate a score that rewards bins where the item size is similar to the remaining capacity\n    item_size_similarity_score = np.where(has_enough_capacity, \n                                          1 / (1 + np.abs(bins_remain_cap - item) / (item + 1e-6)), \n                                          0)\n    \n    # Combine the scores with tunable weights to get the final priority score\n    priority_scores = alpha * bin_fullness_score + beta * remaining_cap_score + gamma * item_size_similarity_score\n    \n    # Normalize the priority scores\n    priority_scores = (priority_scores - np.min(priority_scores)) / (np.max(priority_scores) - np.min(priority_scores) + 1e-6)\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 245.34452978042594,
    "mi": 81.58029018456887,
    "token_count": 197.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response2.txt_stdout.txt",
    "code_path": "problem_iter7_code2.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 0.0007172075845624779, \n                bin_fullness_weight: float = 0.6832967170748634, \n                fit_score_weight: float = 0.7408009259100935,\n                capacity_threshold: float = -0.8405607021260366,\n                tight_fit_epsilon: float = 9.703058604165807e-05) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on bin fullness and item fit.\n    Combines elements of top heuristics for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= (item + capacity_threshold)\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item - item) / (item + tight_fit_epsilon)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with weights\n    priority_scores = bin_fullness_weight * bin_fullness_score + fit_score_weight * fit_score\n    \n    return priority_scores",
    "response_id": 2,
    "tryHS": true,
    "obj": 3.6796968488233035,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 223.47971260168305,
    "mi": 94.17249748151123,
    "token_count": 159.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin, \n    combining bin fullness and fit scores with tunable weights and normalization.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate bin fullness score\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate fit score (rewarding bins with remaining capacity close to the item size)\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition - item) / (item + 1e-6)), \n                                   0)\n    \n    # Introduce a bias towards bins with smaller indices to break ties\n    index_bias = -np.arange(len(bins_remain_cap)) / len(bins_remain_cap)\n    \n    # Combine scores with tunable weights\n    weights = np.array([0.6, 0.3, 0.1])  # Weights for bin_fullness_score, remaining_cap_score, and index_bias\n    priority_scores = (weights[0] * bin_fullness_score + \n                       weights[1] * remaining_cap_score + \n                       weights[2] * index_bias)\n    \n    # Normalize priority scores using tanh\n    priority_scores = np.tanh(priority_scores)\n    \n    return priority_scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 3.9888312724371757,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 194.51316411045156,
    "mi": 82.00550664234373,
    "token_count": 116.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  bins_remain_cap / (bins_remain_cap.max() + 1e-6), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    waste_score = np.where(has_enough_capacity, \n                           1 - np.abs(remaining_cap_after_addition) / (item + 1e-6), \n                           0)\n    \n    # Combine the two scores with tunable weights to get the final priority score\n    weights = np.array([0.6, 0.4])  # Tunable weights for bin_fullness_score and waste_score\n    priority_scores = weights[0] * bin_fullness_score + weights[1] * waste_score\n    \n    # Normalize the priority scores to improve robustness\n    priority_scores = (priority_scores - priority_scores.min()) / (priority_scores.max() - priority_scores.min() + 1e-6)\n    \n    return priority_scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.028719585161557,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 174.22857502740396,
    "mi": 77.9011541116184,
    "token_count": 127.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                alpha: float = 0.7454307908876299, beta: float = 0.7902598815273556, gamma: float = 1.0459991043943737, \n                eps: float = 0.0002858970292209872) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n    This version introduces tunable parameters for flexibility and stability.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        alpha: weight for bin fullness score.\n        beta: weight for remaining capacity score.\n        gamma: weight for item size similarity score.\n        eps: small value to prevent division by zero.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + eps)), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition) / (item + eps)), \n                                   0)\n    \n    # Calculate a score that rewards bins where the item size is similar to the remaining capacity\n    item_size_similarity_score = np.where(has_enough_capacity, \n                                          1 / (1 + np.abs(bins_remain_cap - item) / (item + eps)), \n                                          0)\n    \n    # Combine the scores with tunable weights to get the final priority score\n    priority_scores = alpha * bin_fullness_score + beta * remaining_cap_score + gamma * item_size_similarity_score\n    \n    # Normalize the priority scores\n    priority_scores = (priority_scores - np.min(priority_scores)) / (np.max(priority_scores) - np.min(priority_scores) + eps)\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 375.2635575392197,
    "mi": 80.68120506778389,
    "token_count": 223.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on bin fullness and item fit.\n    Combines simplicity with effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item with a small threshold\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + 1e-6), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item) / (item + 1e-6)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with equal weights\n    priority_scores = 0.5 * bin_fullness_score + 0.5 * fit_score\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.53642239625987,
    "mi": 93.5480559635434,
    "token_count": 115.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item and are more full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, 1 - (bins_remain_cap - item) / bins_remain_cap, 0)\n    \n    # Normalize the score to be between 0 and 1\n    priority_scores = bin_fullness_score\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 106.27403387250884,
    "mi": 87.7354952214408,
    "token_count": 137.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response7.txt_stdout.txt",
    "code_path": "problem_iter23_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines bin fullness and item fit scores with tunable weights and normalization for robustness.\n    Rewards bins that are fuller and fit the item tightly.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate bin fullness score, rewarding fuller bins\n    bin_fullness_score = np.where(has_enough_capacity, bins_remain_cap / (bins_remain_cap.max() + 1e-6), -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to zero (tight fit)\n    tight_fit_score = np.where(has_enough_capacity, 1 - np.abs(bins_remain_cap - item) / (item + 1e-6), 0)\n    \n    # Combine the two scores with tunable weights to get the final priority score\n    weights = np.array([0.6, 0.4])  # Tunable weights for bin_fullness_score and tight_fit_score\n    priority_scores = weights[0] * bin_fullness_score + weights[1] * tight_fit_score\n    \n    # Normalize the priority scores to improve robustness\n    priority_scores = (priority_scores - priority_scores.min()) / (priority_scores.max() - priority_scores.min() + 1e-6)\n    \n    return priority_scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.028719585161557,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 185.46604019833754,
    "mi": 89.78115586719106,
    "token_count": 133.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to zero\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 - bins_remain_cap[item > 0] / (item + 1e-6) if item > 0 else 0, \n                                   -1)\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 - (bins_remain_cap - item) / (bins_remain_cap + 1e-6), \n                                   -1)\n    \n    # Normalize the remaining capacity score to be between 0 and 1\n    max_score = np.max(remaining_cap_score)\n    min_score = np.min(remaining_cap_score)\n    normalized_score = (remaining_cap_score - min_score) / (max_score - min_score + 1e-6)\n    \n    # Calculate a score that rewards bins that are more full\n    bin_fullness_score = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Combine the two scores to get the final priority score\n    priority_scores = np.where(has_enough_capacity, normalized_score, 0)\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 110.36149671375918,
    "mi": 84.18703686934985,
    "token_count": 131.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_hs4.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 0.0008334094952061082, \n                bin_fullness_weight: float = 1.32867016711678, \n                fit_score_weight: float = 0.6646809873690805,\n                capacity_threshold: float = -0.5738018773006752) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on bin fullness and item fit.\n    Combines elements of top heuristics for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item + capacity_threshold\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item - item) / (item + epsilon)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with weights\n    priority_scores = bin_fullness_weight * bin_fullness_score + fit_score_weight * fit_score\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": true,
    "obj": 3.9888312724371757,
    "SLOC": 14.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 220.92066675263135,
    "mi": 94.2556614093467,
    "token_count": 150.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response3.txt_stdout.txt",
    "code_path": "problem_iter17_code3.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 1e-6, \n                bin_fullness_weight: float = 1.0, \n                fit_score_weight: float = 0.5) -> np.ndarray:\n    \"\"\"\n    Combines bin fullness and item fit scores with tunable weights for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    # Use the same normalization as in priority_v0 to enhance interpretability\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item - item) / (item + epsilon)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with weights\n    # Allow for tunable weights as in priority_v0\n    priority_scores = bin_fullness_weight * bin_fullness_score + fit_score_weight * fit_score\n    \n    return priority_scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 3.9888312724371757,
    "SLOC": 20.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 369.9781553203574,
    "mi": 87.5646394063371,
    "token_count": 232.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response4.txt_stdout.txt",
    "code_path": "problem_iter18_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  bins_remain_cap / (bins_remain_cap.max() + 1e-6), \n                                  0)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    waste_score = np.where(has_enough_capacity, \n                           1 - np.abs(remaining_cap_after_addition) / (item + 1e-6), \n                           -1)\n    \n    # Tunable weights for the scores\n    alpha, beta = 0.6, 0.4\n    \n    # Combine the two scores to get the final priority score with tunable weights\n    priority_scores = alpha * bin_fullness_score + beta * waste_score\n    \n    return priority_scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.028719585161557,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 144.75398259382442,
    "mi": 83.82966843925908,
    "token_count": 129.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 1e-6, \n                bin_fullness_weight: float = 1.0) -> np.ndarray:\n    \"\"\"\n    Combines bin fullness and item fit scores for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Simplify by using a straightforward fit score\n    fit_score = np.where(has_enough_capacity, 1 / (1 + np.abs(bins_remain_cap - item) / (item + epsilon)), 0)\n    \n    # Combine scores with a single tunable weight for simplicity\n    priority_scores = bin_fullness_weight * bin_fullness_score + (1 - bin_fullness_weight) * fit_score\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 145.94737505048093,
    "mi": 89.24445174245956,
    "token_count": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response0.txt_stdout.txt",
    "code_path": "problem_iter21_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item and \n    have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to zero\n    # Use a simple and effective scoring system\n    priority_scores = np.where(has_enough_capacity, \n                               1 / (1 + np.abs(bins_remain_cap - item)), \n                               0)\n    \n    # Normalize the scores to enhance interpretability\n    max_score = np.max(priority_scores)\n    if max_score > 0:\n        priority_scores = priority_scores / max_score\n    \n    return priority_scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 92.0,
    "mi": 83.77411880171489,
    "token_count": 107.0,
    "exec_success": true
  }
]