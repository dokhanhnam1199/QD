[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity after adding the item.\n    Prioritizes bins that fit the item tightly and normalizes scores.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign high priority to bins that can hold the item and have less remaining capacity\n    priority = np.where(remaining_after_addition >= 0, 1 / (remaining_after_addition + 1e-6), 0)\n    \n    # Normalize priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority > 0:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 89.21626845106506,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    \n    Prioritizes bins with the least remaining capacity after adding the item.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Assign high priority to bins that can hold the item and have less remaining capacity after addition\n    priorities = np.where(bins_remain_cap >= item, \n                          -remaining_cap_after_add,  # Less remaining capacity is better\n                          -np.inf)  # Cannot hold the item\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 89.21626845106506,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Prioritizes bins that fit the item tightly and normalizes scores.\n    \"\"\"\n    # Calculate priority scores based on remaining capacity after adding the item\n    priorities = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1e-6), -np.inf)\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 89.21626845106506,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Prioritizes bins that fit the item tightly and have smaller remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(bins_remain_cap >= item, -diff, -np.inf)\n    \n    # In case of a tie, prefer the bin with the smallest remaining capacity\n    # by adding a small bonus based on the remaining capacity\n    bonus = np.where(np.isclose(priority - np.max(priority), 0), -bins_remain_cap / np.max(bins_remain_cap[bins_remain_cap >= item]), 0)\n    priority += bonus\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority > -np.inf:\n        priority = (priority - (-np.inf)) / (max_priority - (-np.inf))\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 89.21626845106506,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins that fit the item tightly and are more full.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate the priority score for bins with enough capacity\n    # Higher priority for bins that are more full and fit the item tightly\n    priority_scores = np.where(has_enough_capacity, \n                               1 / (bins_remain_cap - item + 1e-6),  # Encourage tight fit\n                               -np.inf)  # Avoid bins that are too small\n    \n    return priority_scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 89.21626845106506,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin. \n    Prioritizes bins that fit the item tightly and normalizes scores.\n    \"\"\"\n    # Calculate priority score: high when bin has just enough capacity for item\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1e-6), 0)\n    \n    # Normalize priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    return priority / max_priority if max_priority > 0 else np.zeros_like(bins_remain_cap)",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 89.21626845106506,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin. \n    Prioritizes bins that fit the item tightly and have smaller remaining capacity.\n    \"\"\"\n    # Check if the item can fit in each bin and calculate priority\n    valid_bins = bins_remain_cap >= item\n    # Combine best fit strategy with preference for smaller remaining capacity\n    priority = np.where(valid_bins, -np.abs(bins_remain_cap - item) + bins_remain_cap * 1e-6, -np.inf)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 89.21626845106506,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority is inversely proportional to the remaining capacity after adding the item.\n    Encourages a tight fit and normalizes priority scores between 0 and 1.\n    \"\"\"\n    # Mask for bins that can hold the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Priority is inversely proportional to the remaining capacity after adding the item\n    priority = np.where(valid_bins, 1 / (bins_remain_cap - item + 1e-6), 0)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority > 0:\n        priority /= max_priority\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 89.21626845106506,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin by combining tight fit and remaining capacity strategies.\n    \"\"\"\n    # Calculate priority as negative absolute difference between remaining capacity and item size\n    priority = -np.abs(bins_remain_cap - item)\n    \n    # Set priority to -inf for bins that cannot hold the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Normalize priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = np.where(priority != -np.inf, (priority - np.min(priority)) / (max_priority - np.min(priority)), -np.inf)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 89.21626845106506,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority score for each bin based on remaining capacity and item size.\n    Combines tight fit and normalization strategies for better performance.\n    \"\"\"\n    # Calculate remaining capacity after adding item to each bin\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Give high priority to bins where item fits and penalize those where it doesn't\n    priority = np.where(remaining_cap_after_add >= 0, 1 / (remaining_cap_after_add + 1e-6), -np.inf)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 89.21626845106506,
    "token_count": 63.0,
    "exec_success": true
  }
]