{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    # and penalizes bins where the remaining capacity is large compared to the item size\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition - item) / (item + 1e-6)), \n                                   0)\n    \n    # Combine the two scores to get the final priority score\n    priority_scores = bin_fullness_score + remaining_cap_score\n    \n    return priority_scores\n\n[Heuristics 2nd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 1e-6, \n                bin_fullness_weight: float = 1.0, \n                fit_score_weight: float = 0.5) -> np.ndarray:\n    \"\"\"\n    Combines bin fullness and item fit scores with tunable weights for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    # Use the same normalization as in priority_v0 to enhance interpretability\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item - item) / (item + epsilon)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with weights\n    # Allow for tunable weights as in priority_v0\n    priority_scores = bin_fullness_weight * bin_fullness_score + fit_score_weight * fit_score\n    \n    return priority_scores\n\n[Heuristics 3rd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 1e-6, \n                bin_fullness_weight: float = 1.0, \n                fit_score_weight: float = 0.5) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on bin fullness and item fit.\n    Combines elements of top heuristics for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item - item) / (item + epsilon)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with weights\n    priority_scores = bin_fullness_weight * bin_fullness_score + fit_score_weight * fit_score\n    \n    return priority_scores\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin, \n    combining bin fullness and fit scores with tunable weights and normalization.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate bin fullness score\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate fit score (rewarding bins with remaining capacity close to the item size)\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition - item) / (item + 1e-6)), \n                                   0)\n    \n    # Introduce a bias towards bins with smaller indices to break ties\n    index_bias = -np.arange(len(bins_remain_cap)) / len(bins_remain_cap)\n    \n    # Combine scores with tunable weights\n    weights = np.array([0.6, 0.3, 0.1])  # Weights for bin_fullness_score, remaining_cap_score, and index_bias\n    priority_scores = (weights[0] * bin_fullness_score + \n                       weights[1] * remaining_cap_score + \n                       weights[2] * index_bias)\n    \n    # Normalize priority scores using tanh\n    priority_scores = np.tanh(priority_scores)\n    \n    return priority_scores\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin, \n    combining bin fullness and fit scores with tunable weights and normalization.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate bin fullness score\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate fit score (rewarding bins with remaining capacity close to the item size)\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition - item) / (item + 1e-6)), \n                                   0)\n    \n    # Introduce a bias towards bins with smaller indices to break ties\n    index_bias = -np.arange(len(bins_remain_cap)) / len(bins_remain_cap)\n    \n    # Combine scores with tunable weights\n    weights = np.array([0.6, 0.3, 0.1])  # Weights for bin_fullness_score, remaining_cap_score, and index_bias\n    priority_scores = (weights[0] * bin_fullness_score + \n                       weights[1] * remaining_cap_score + \n                       weights[2] * index_bias)\n    \n    # Normalize priority scores using tanh\n    priority_scores = np.tanh(priority_scores)\n    \n    return priority_scores\n\n[Heuristics 6th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 1e-6, \n                bin_fullness_weight: float = 1.0, \n                fit_score_weight: float = 0.5) -> np.ndarray:\n    \"\"\"\n    Combines bin fullness and item fit scores with tunable weights for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    # Use the same normalization as in priority_v0 to enhance interpretability\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item - item) / (item + epsilon)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with weights\n    # Allow for tunable weights as in priority_v0\n    priority_scores = bin_fullness_weight * bin_fullness_score + fit_score_weight * fit_score\n    \n    return priority_scores\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin, \n    combining bin fullness and fit scores with tunable weights and normalization.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate bin fullness score\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate fit score (rewarding bins with remaining capacity close to the item size)\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition - item) / (item + 1e-6)), \n                                   0)\n    \n    # Introduce a bias towards bins with smaller indices to break ties\n    index_bias = -np.arange(len(bins_remain_cap)) / len(bins_remain_cap)\n    \n    # Combine scores with tunable weights\n    weights = np.array([0.6, 0.3, 0.1])  # Weights for bin_fullness_score, remaining_cap_score, and index_bias\n    priority_scores = (weights[0] * bin_fullness_score + \n                       weights[1] * remaining_cap_score + \n                       weights[2] * index_bias)\n    \n    # Normalize priority scores using tanh\n    priority_scores = np.tanh(priority_scores)\n    \n    return priority_scores\n\n[Heuristics 8th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 1e-6, \n                bin_fullness_weight: float = 1.0, \n                fit_score_weight: float = 0.5) -> np.ndarray:\n    \"\"\"\n    Combines bin fullness and item fit scores with tunable weights for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    # Use the same normalization as in priority_v0 to enhance interpretability\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item - item) / (item + epsilon)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with weights\n    # Allow for tunable weights as in priority_v0\n    priority_scores = bin_fullness_weight * bin_fullness_score + fit_score_weight * fit_score\n    \n    return priority_scores\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  bins_remain_cap / (bins_remain_cap.max() + 1e-6), \n                                  0)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to zero\n    tight_fit_score = np.where(has_enough_capacity, \n                               1 - (remaining_cap_after_addition / (item + 1e-6)), \n                               0)\n    \n    # Combine the two scores with tunable weights to get the final priority score\n    w1, w2 = 0.6, 0.4  # Tunable weights for bin fullness and tight fit scores\n    priority_scores = w1 * bin_fullness_score + w2 * tight_fit_score\n    \n    return priority_scores\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  bins_remain_cap / (bins_remain_cap.max() + 1e-6), \n                                  0)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    waste_score = np.where(has_enough_capacity, \n                           1 - np.abs(remaining_cap_after_addition) / (item + 1e-6), \n                           -1)\n    \n    # Tunable weights for the scores\n    alpha, beta = 0.6, 0.4\n    \n    # Combine the two scores to get the final priority score with tunable weights\n    priority_scores = alpha * bin_fullness_score + beta * waste_score\n    \n    return priority_scores\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  bins_remain_cap / (bins_remain_cap.max() + 1e-6), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    waste_score = np.where(has_enough_capacity, \n                           1 - np.abs(remaining_cap_after_addition) / (item + 1e-6), \n                           0)\n    \n    # Combine the two scores with tunable weights to get the final priority score\n    weights = np.array([0.6, 0.4])  # Tunable weights for bin_fullness_score and waste_score\n    priority_scores = weights[0] * bin_fullness_score + weights[1] * waste_score\n    \n    # Normalize the priority scores to improve robustness\n    priority_scores = (priority_scores - priority_scores.min()) / (priority_scores.max() - priority_scores.min() + 1e-6)\n    \n    return priority_scores\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  bins_remain_cap / (bins_remain_cap.max() + 1e-6), \n                                  0)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to zero\n    tight_fit_score = np.where(has_enough_capacity, \n                               1 - (remaining_cap_after_addition / (item + 1e-6)), \n                               0)\n    \n    # Combine the two scores with tunable weights to get the final priority score\n    w1, w2 = 0.6, 0.4  # Tunable weights for bin fullness and tight fit scores\n    priority_scores = w1 * bin_fullness_score + w2 * tight_fit_score\n    \n    return priority_scores\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines bin fullness and item fit scores with tunable weights and normalization for robustness.\n    Rewards bins that are fuller and fit the item tightly.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate bin fullness score, rewarding fuller bins\n    bin_fullness_score = np.where(has_enough_capacity, bins_remain_cap / (bins_remain_cap.max() + 1e-6), -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to zero (tight fit)\n    tight_fit_score = np.where(has_enough_capacity, 1 - np.abs(bins_remain_cap - item) / (item + 1e-6), 0)\n    \n    # Combine the two scores with tunable weights to get the final priority score\n    weights = np.array([0.6, 0.4])  # Tunable weights for bin_fullness_score and tight_fit_score\n    priority_scores = weights[0] * bin_fullness_score + weights[1] * tight_fit_score\n    \n    # Normalize the priority scores to improve robustness\n    priority_scores = (priority_scores - priority_scores.min()) / (priority_scores.max() - priority_scores.min() + 1e-6)\n    \n    return priority_scores\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item and are more full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, 1 - (bins_remain_cap - item) / bins_remain_cap, 0)\n    \n    # Normalize the score to be between 0 and 1\n    priority_scores = bin_fullness_score\n    \n    return priority_scores\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to zero\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 - bins_remain_cap[item > 0] / (item + 1e-6) if item > 0 else 0, \n                                   -1)\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 - (bins_remain_cap - item) / (bins_remain_cap + 1e-6), \n                                   -1)\n    \n    # Normalize the remaining capacity score to be between 0 and 1\n    max_score = np.max(remaining_cap_score)\n    min_score = np.min(remaining_cap_score)\n    normalized_score = (remaining_cap_score - min_score) / (max_score - min_score + 1e-6)\n    \n    # Calculate a score that rewards bins that are more full\n    bin_fullness_score = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Combine the two scores to get the final priority score\n    priority_scores = np.where(has_enough_capacity, normalized_score, 0)\n    \n    return priority_scores\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to zero\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 - bins_remain_cap[item > 0] / (item + 1e-6) if item > 0 else 0, \n                                   -1)\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 - (bins_remain_cap - item) / (bins_remain_cap + 1e-6), \n                                   -1)\n    \n    # Normalize the remaining capacity score to be between 0 and 1\n    max_score = np.max(remaining_cap_score)\n    min_score = np.min(remaining_cap_score)\n    normalized_score = (remaining_cap_score - min_score) / (max_score - min_score + 1e-6)\n    \n    # Calculate a score that rewards bins that are more full\n    bin_fullness_score = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Combine the two scores to get the final priority score\n    priority_scores = np.where(has_enough_capacity, normalized_score, 0)\n    \n    return priority_scores\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on bin fullness and item fit.\n    Combines simplicity with effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item with a small threshold\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + 1e-6), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item) / (item + 1e-6)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with equal weights\n    priority_scores = 0.5 * bin_fullness_score + 0.5 * fit_score\n    \n    return priority_scores\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item and are more full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, 1 - (bins_remain_cap - item) / bins_remain_cap, 0)\n    \n    # Normalize the score to be between 0 and 1\n    priority_scores = bin_fullness_score\n    \n    return priority_scores\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n    This version introduces tunable parameters for flexibility and stability.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Tunable parameters\n    alpha = 1.0  # weight for bin fullness score\n    beta = 1.0   # weight for remaining capacity score\n    gamma = 1.0  # weight for item size similarity score\n    \n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition) / (item + 1e-6)), \n                                   0)\n    \n    # Calculate a score that rewards bins where the item size is similar to the remaining capacity\n    item_size_similarity_score = np.where(has_enough_capacity, \n                                          1 / (1 + np.abs(bins_remain_cap - item) / (item + 1e-6)), \n                                          0)\n    \n    # Combine the scores with tunable weights to get the final priority score\n    priority_scores = alpha * bin_fullness_score + beta * remaining_cap_score + gamma * item_size_similarity_score\n    \n    # Normalize the priority scores\n    priority_scores = (priority_scores - np.min(priority_scores)) / (np.max(priority_scores) - np.min(priority_scores) + 1e-6)\n    \n    return priority_scores\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n    This version introduces tunable parameters for flexibility and stability.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Tunable parameters\n    alpha = 1.0  # weight for bin fullness score\n    beta = 1.0   # weight for remaining capacity score\n    gamma = 1.0  # weight for item size similarity score\n    \n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition) / (item + 1e-6)), \n                                   0)\n    \n    # Calculate a score that rewards bins where the item size is similar to the remaining capacity\n    item_size_similarity_score = np.where(has_enough_capacity, \n                                          1 / (1 + np.abs(bins_remain_cap - item) / (item + 1e-6)), \n                                          0)\n    \n    # Combine the scores with tunable weights to get the final priority score\n    priority_scores = alpha * bin_fullness_score + beta * remaining_cap_score + gamma * item_size_similarity_score\n    \n    # Normalize the priority scores\n    priority_scores = (priority_scores - np.min(priority_scores)) / (np.max(priority_scores) - np.min(priority_scores) + 1e-6)\n    \n    return priority_scores\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}