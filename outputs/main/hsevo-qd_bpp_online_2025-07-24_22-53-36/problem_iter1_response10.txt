```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a more sophisticated heuristic.

    The priority is determined based on how well the item fits into the remaining capacity of each bin.
    Bins that have just enough capacity for the item get the highest priority.
    Bins that are too small for the item get a priority of negative infinity.
    The priority decreases as the remaining capacity increases beyond the item size.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Create a mask to identify bins that are too small for the item
    too_small_mask = bins_remain_cap < item
    
    # For bins that have enough capacity, calculate the priority based on how well the item fits
    priority = np.where(~too_small_mask, - (bins_remain_cap - item), -np.inf)
    
    # To avoid putting items into the same bin repeatedly, we can slightly decrease the priority of bins that are less full
    # Here we assume that bins with more remaining capacity are less full
    # However, this part can be adjusted or removed based on specific needs or problem characteristics
    
    return priority
```
