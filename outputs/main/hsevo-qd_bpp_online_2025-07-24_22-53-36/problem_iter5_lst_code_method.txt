{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    # and penalizes bins where the remaining capacity is large compared to the item size\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition - item) / (item + 1e-6)), \n                                   0)\n    \n    # Combine the two scores to get the final priority score\n    priority_scores = bin_fullness_score + remaining_cap_score\n    \n    return priority_scores\n\n[Heuristics 2nd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 0.0004274345164823599, \n                bin_fullness_weight: float = 1.3730195438323172, \n                remaining_cap_score_weight: float = 0.9219335188896174) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to prevent division by zero.\n        bin_fullness_weight: Weight for bin fullness score.\n        remaining_cap_score_weight: Weight for remaining capacity score.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    # and penalizes bins where the remaining capacity is large compared to the item size\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + epsilon)), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition - item) / (item + epsilon)), \n                                   0)\n    \n    # Combine the two scores to get the final priority score\n    priority_scores = bin_fullness_weight * bin_fullness_score + remaining_cap_score_weight * remaining_cap_score\n    \n    return priority_scores\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have the least remaining capacity after adding the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate the priority score based on the remaining capacity after adding the item\n    # and the current remaining capacity\n    # The priority score is higher for bins that are more full and have less remaining capacity after adding the item\n    priority_scores = np.where(has_enough_capacity, \n                               (bins_remain_cap.max() - remaining_cap_after_addition) / (bins_remain_cap + 1e-6), \n                               -1)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority_scores)\n    if max_priority > 0:\n        priority_scores = np.where(priority_scores > 0, priority_scores / max_priority, priority_scores)\n    \n    return priority_scores\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins that fit the item tightly and are more full.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate the priority score for bins with enough capacity\n    # Higher priority for bins that are more full and fit the item tightly\n    priority_scores = np.where(has_enough_capacity, \n                               1 / (bins_remain_cap - item + 1e-6),  # Encourage tight fit\n                               -np.inf)  # Avoid bins that are too small\n    \n    return priority_scores\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have the least remaining capacity after adding the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate the priority score for bins with enough capacity\n    # The priority score is a combination of the bin's fullness and the remaining capacity after adding the item\n    # We use a weighted sum to balance these two factors\n    priority_scores_enough_cap = 0.7 * (1 - (bins_remain_cap / (item + bins_remain_cap))) + 0.3 * (1 - (remaining_cap_after_addition / bins_remain_cap))\n    \n    # Assign a low priority score to bins without enough capacity\n    priority_scores_not_enough_cap = -1 * np.ones_like(bins_remain_cap)\n    \n    # Combine the priority scores for bins with and without enough capacity\n    priority_scores = np.where(has_enough_capacity, priority_scores_enough_cap, priority_scores_not_enough_cap)\n    \n    return priority_scores\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority is inversely proportional to the remaining capacity after adding the item.\n    Encourages a tight fit and normalizes priority scores between 0 and 1.\n    \"\"\"\n    # Mask for bins that can hold the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Priority is inversely proportional to the remaining capacity after adding the item\n    priority = np.where(valid_bins, 1 / (bins_remain_cap - item + 1e-6), 0)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority > 0:\n        priority /= max_priority\n    \n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority score for each bin based on remaining capacity and item size.\n    Combines tight fit and normalization strategies for better performance.\n    \"\"\"\n    # Calculate remaining capacity after adding item to each bin\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Give high priority to bins where item fits and penalize those where it doesn't\n    priority = np.where(remaining_cap_after_add >= 0, 1 / (remaining_cap_after_add + 1e-6), -np.inf)\n    \n    return priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Prioritizes bins that fit the item tightly and normalizes scores.\n    \"\"\"\n    # Calculate priority scores based on remaining capacity after adding the item\n    priorities = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1e-6), -np.inf)\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a 'best-fit' score, where bins with remaining capacity closest to 0 are preferred\n    best_fit_score = np.where(has_enough_capacity, 1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), 0)\n    \n    # The priority score is a combination of the 'best-fit' score and a term that prioritizes fuller bins\n    priority_scores = np.where(has_enough_capacity, 0.5 * best_fit_score + 0.5 * (1 - (bins_remain_cap / (np.max(bins_remain_cap) + 1e-6))), -1)\n    \n    return priority_scores\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have the least remaining capacity after adding the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate the priority score for bins with enough capacity\n    # The priority score is a combination of the bin's fullness and the remaining capacity after adding the item\n    # We use a weighted sum to balance these two factors\n    priority_scores_enough_cap = 0.7 * (1 - (bins_remain_cap / (item + bins_remain_cap))) + 0.3 * (1 - (remaining_cap_after_addition / bins_remain_cap))\n    \n    # Assign a low priority score to bins without enough capacity\n    priority_scores_not_enough_cap = -1 * np.ones_like(bins_remain_cap)\n    \n    # Combine the priority scores for bins with and without enough capacity\n    priority_scores = np.where(has_enough_capacity, priority_scores_enough_cap, priority_scores_not_enough_cap)\n    \n    return priority_scores\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin. \n    Prioritizes bins that fit the item tightly and have smaller remaining capacity.\n    \"\"\"\n    # Check if the item can fit in each bin and calculate priority\n    valid_bins = bins_remain_cap >= item\n    # Combine best fit strategy with preference for smaller remaining capacity\n    priority = np.where(valid_bins, -np.abs(bins_remain_cap - item) + bins_remain_cap * 1e-6, -np.inf)\n    \n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin. \n    Prioritizes bins that fit the item tightly and normalizes scores.\n    \"\"\"\n    # Calculate priority score: high when bin has just enough capacity for item\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1e-6), 0)\n    \n    # Normalize priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    return priority / max_priority if max_priority > 0 else np.zeros_like(bins_remain_cap)\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Prioritizes bins that fit the item tightly and have smaller remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(bins_remain_cap >= item, -diff, -np.inf)\n    \n    # In case of a tie, prefer the bin with the smallest remaining capacity\n    # by adding a small bonus based on the remaining capacity\n    bonus = np.where(np.isclose(priority - np.max(priority), 0), -bins_remain_cap / np.max(bins_remain_cap[bins_remain_cap >= item]), 0)\n    priority += bonus\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority > -np.inf:\n        priority = (priority - (-np.inf)) / (max_priority - (-np.inf))\n    \n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Prioritizes bins that fit the item tightly and have smaller remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(bins_remain_cap >= item, -diff, -np.inf)\n    \n    # In case of a tie, prefer the bin with the smallest remaining capacity\n    # by adding a small bonus based on the remaining capacity\n    bonus = np.where(np.isclose(priority - np.max(priority), 0), -bins_remain_cap / np.max(bins_remain_cap[bins_remain_cap >= item]), 0)\n    priority += bonus\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority > -np.inf:\n        priority = (priority - (-np.inf)) / (max_priority - (-np.inf))\n    \n    return priority\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Prioritizes bins that fit the item tightly and have smaller remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(bins_remain_cap >= item, -diff, -np.inf)\n    \n    # In case of a tie, prefer the bin with the smallest remaining capacity\n    # by adding a small bonus based on the remaining capacity\n    bonus = np.where(np.isclose(priority - np.max(priority), 0), -bins_remain_cap / np.max(bins_remain_cap[bins_remain_cap >= item]), 0)\n    priority += bonus\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority > -np.inf:\n        priority = (priority - (-np.inf)) / (max_priority - (-np.inf))\n    \n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Prioritizes bins that fit the item tightly and have smaller remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(bins_remain_cap >= item, -diff, -np.inf)\n    \n    # In case of a tie, prefer the bin with the smallest remaining capacity\n    # by adding a small bonus based on the remaining capacity\n    bonus = np.where(np.isclose(priority - np.max(priority), 0), -bins_remain_cap / np.max(bins_remain_cap[bins_remain_cap >= item]), 0)\n    priority += bonus\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority > -np.inf:\n        priority = (priority - (-np.inf)) / (max_priority - (-np.inf))\n    \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on remaining capacity and item size.\n    Prioritizes bins that fit the item tightly and have smaller remaining capacity.\n    \"\"\"\n    # Calculate the absolute difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(bins_remain_cap >= item, -diff, -np.inf)\n    \n    # In case of a tie, prefer the bin with the smallest remaining capacity\n    # by adding a small bonus based on the remaining capacity\n    bonus = np.where(np.isclose(priority - np.max(priority), 0), -bins_remain_cap / np.max(bins_remain_cap[bins_remain_cap >= item]), 0)\n    priority += bonus\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority > -np.inf:\n        priority = (priority - (-np.inf)) / (max_priority - (-np.inf))\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is not too small after adding the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a \"fit score\" for each bin, prioritizing bins where the item fits well\n    # i.e., the remaining capacity after adding the item is not too small\n    fit_score = np.where(has_enough_capacity, remaining_cap_after_addition / (bins_remain_cap + 1e-6), -1)\n    fit_score = np.clip(fit_score, 0, 1)  # Normalize fit score to [0, 1] range\n    \n    # The priority score is higher for bins that are more full (i.e., have less remaining capacity)\n    # and have enough capacity for the item\n    fullness_score = 1 - (bins_remain_cap / (np.max(bins_remain_cap) + 1e-6))  # Normalize fullness score to [0, 1] range\n    \n    # Combine fit score and fullness score to get the final priority score\n    priority_scores = np.where(has_enough_capacity, 0.5 * fit_score + 0.5 * fullness_score, -1)\n    \n    return priority_scores\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is not too small after adding the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a \"fit score\" for each bin, prioritizing bins where the item fits well\n    # i.e., the remaining capacity after adding the item is not too small\n    fit_score = np.where(has_enough_capacity, remaining_cap_after_addition / (bins_remain_cap + 1e-6), -1)\n    fit_score = np.clip(fit_score, 0, 1)  # Normalize fit score to [0, 1] range\n    \n    # The priority score is higher for bins that are more full (i.e., have less remaining capacity)\n    # and have enough capacity for the item\n    fullness_score = 1 - (bins_remain_cap / (np.max(bins_remain_cap) + 1e-6))  # Normalize fullness score to [0, 1] range\n    \n    # Combine fit score and fullness score to get the final priority score\n    priority_scores = np.where(has_enough_capacity, 0.5 * fit_score + 0.5 * fullness_score, -1)\n    \n    return priority_scores\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is not too small after adding the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a \"fit score\" for each bin, prioritizing bins where the item fits well\n    # i.e., the remaining capacity after adding the item is not too small\n    fit_score = np.where(has_enough_capacity, remaining_cap_after_addition / (bins_remain_cap + 1e-6), -1)\n    fit_score = np.clip(fit_score, 0, 1)  # Normalize fit score to [0, 1] range\n    \n    # The priority score is higher for bins that are more full (i.e., have less remaining capacity)\n    # and have enough capacity for the item\n    fullness_score = 1 - (bins_remain_cap / (np.max(bins_remain_cap) + 1e-6))  # Normalize fullness score to [0, 1] range\n    \n    # Combine fit score and fullness score to get the final priority score\n    priority_scores = np.where(has_enough_capacity, 0.5 * fit_score + 0.5 * fullness_score, -1)\n    \n    return priority_scores\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}