{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    # and penalizes bins where the remaining capacity is large compared to the item size\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition - item) / (item + 1e-6)), \n                                   0)\n    \n    # Combine the two scores to get the final priority score\n    priority_scores = bin_fullness_score + remaining_cap_score\n    \n    return priority_scores\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    # and penalizes bins where the remaining capacity is large compared to the item size\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition - item) / (item + 1e-6)), \n                                   0)\n    \n    # Combine the two scores to get the final priority score\n    priority_scores = bin_fullness_score + remaining_cap_score\n    \n    return priority_scores\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    # and penalizes bins where the remaining capacity is large compared to the item size\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition - item) / (item + 1e-6)), \n                                   0)\n    \n    # Combine the two scores to get the final priority score\n    priority_scores = bin_fullness_score + remaining_cap_score\n    \n    return priority_scores\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full and have a remaining capacity that is as close as possible to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    # and penalizes bins where the remaining capacity is large compared to the item size\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition - item) / (item + 1e-6)), \n                                   0)\n    \n    # Combine the two scores to get the final priority score\n    priority_scores = bin_fullness_score + remaining_cap_score\n    \n    return priority_scores\n\n[Heuristics 5th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 0.0007172075845624779, \n                bin_fullness_weight: float = 0.6832967170748634, \n                fit_score_weight: float = 0.7408009259100935,\n                capacity_threshold: float = -0.8405607021260366,\n                tight_fit_epsilon: float = 9.703058604165807e-05) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on bin fullness and item fit.\n    Combines elements of top heuristics for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= (item + capacity_threshold)\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item - item) / (item + tight_fit_epsilon)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with weights\n    priority_scores = bin_fullness_weight * bin_fullness_score + fit_score_weight * fit_score\n    \n    return priority_scores\n\n[Heuristics 6th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 0.0007172075845624779, \n                bin_fullness_weight: float = 0.6832967170748634, \n                fit_score_weight: float = 0.7408009259100935,\n                capacity_threshold: float = -0.8405607021260366,\n                tight_fit_epsilon: float = 9.703058604165807e-05) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on bin fullness and item fit.\n    Combines elements of top heuristics for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= (item + capacity_threshold)\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item - item) / (item + tight_fit_epsilon)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with weights\n    priority_scores = bin_fullness_weight * bin_fullness_score + fit_score_weight * fit_score\n    \n    return priority_scores\n\n[Heuristics 7th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 0.0007172075845624779, \n                bin_fullness_weight: float = 0.6832967170748634, \n                fit_score_weight: float = 0.7408009259100935,\n                capacity_threshold: float = -0.8405607021260366,\n                tight_fit_epsilon: float = 9.703058604165807e-05) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on bin fullness and item fit.\n    Combines elements of top heuristics for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= (item + capacity_threshold)\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item - item) / (item + tight_fit_epsilon)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with weights\n    priority_scores = bin_fullness_weight * bin_fullness_score + fit_score_weight * fit_score\n    \n    return priority_scores\n\n[Heuristics 8th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 0.0007172075845624779, \n                bin_fullness_weight: float = 0.6832967170748634, \n                fit_score_weight: float = 0.7408009259100935,\n                capacity_threshold: float = -0.8405607021260366,\n                tight_fit_epsilon: float = 9.703058604165807e-05) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on bin fullness and item fit.\n    Combines elements of top heuristics for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= (item + capacity_threshold)\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item - item) / (item + tight_fit_epsilon)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with weights\n    priority_scores = bin_fullness_weight * bin_fullness_score + fit_score_weight * fit_score\n    \n    return priority_scores\n\n[Heuristics 9th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 0.0007172075845624779, \n                bin_fullness_weight: float = 0.6832967170748634, \n                fit_score_weight: float = 0.7408009259100935,\n                capacity_threshold: float = -0.8405607021260366,\n                tight_fit_epsilon: float = 9.703058604165807e-05) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on bin fullness and item fit.\n    Combines elements of top heuristics for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= (item + capacity_threshold)\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item - item) / (item + tight_fit_epsilon)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with weights\n    priority_scores = bin_fullness_weight * bin_fullness_score + fit_score_weight * fit_score\n    \n    return priority_scores\n\n[Heuristics 10th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 1e-6, \n                bin_fullness_weight: float = 1.0, \n                fit_score_weight: float = 0.5) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on bin fullness and item fit.\n    Combines elements of top heuristics for effective bin prioritization.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate bin fullness score, rewarding bins that are fuller\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (bins_remain_cap - item) / (bins_remain_cap + epsilon), \n                                  -1)\n    \n    # Calculate fit score, prioritizing bins that fit the item tightly\n    fit_score = np.where(has_enough_capacity, \n                         1 / (1 + np.abs(bins_remain_cap - item - item) / (item + epsilon)), \n                         0)\n    \n    # Combine the two scores to get the final priority score with weights\n    priority_scores = bin_fullness_weight * bin_fullness_score + fit_score_weight * fit_score\n    \n    return priority_scores\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines tight fit and fullness scores for bin prioritization.\n    \"\"\"\n    # Check if bin has enough capacity\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate tight fit score (higher when bin capacity is closer to item size)\n    tight_fit_score = np.where(has_enough_capacity, 1 / (bins_remain_cap - item + 1e-6), 0)\n    \n    # Normalize tight fit scores\n    max_tight_fit = np.max(tight_fit_score)\n    tight_fit_score = tight_fit_score / max_tight_fit if max_tight_fit > 0 else np.zeros_like(bins_remain_cap)\n    \n    # Calculate fullness score (higher when bin is more full)\n    fullness_score = 1 - (bins_remain_cap / (np.max(bins_remain_cap) + 1e-6))\n    \n    # Combine scores with equal weight\n    priority = np.where(has_enough_capacity, 0.5 * tight_fit_score + 0.5 * fullness_score, 0)\n    \n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins that fit the item tightly, are more full, and have smaller remaining capacity.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate the priority score for bins with enough capacity\n    # Higher priority for bins that are more full and fit the item tightly\n    tight_fit_score = 1 / (bins_remain_cap - item + 1e-6)\n    fullness_score = 1 / (bins_remain_cap + 1e-6)  # Prefer bins with smaller remaining capacity\n    priority_scores = np.where(has_enough_capacity, tight_fit_score + fullness_score, -np.inf)\n    \n    return priority_scores\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins that fit the item tightly, are more full, and have smaller remaining capacity.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate the priority score for bins with enough capacity\n    # Higher priority for bins that are more full and fit the item tightly\n    tight_fit_score = 1 / (bins_remain_cap - item + 1e-6)\n    fullness_score = 1 / (bins_remain_cap + 1e-6)  # Prefer bins with smaller remaining capacity\n    priority_scores = np.where(has_enough_capacity, tight_fit_score + fullness_score, -np.inf)\n    \n    return priority_scores\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full, have a remaining capacity that is as close as possible to the item size,\n    and have a smaller index (to break ties in a more deterministic manner).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition) / (item + 1e-6)), \n                                   0)\n    \n    # Introduce a bias towards bins with smaller indices to break ties\n    index_bias = -np.arange(len(bins_remain_cap)) / len(bins_remain_cap)\n    \n    # Combine the scores with tunable weights to get the final priority score\n    weights = np.array([0.5, 0.4, 0.1])  # Weights for bin_fullness_score, remaining_cap_score, and index_bias respectively\n    priority_scores = (weights[0] * bin_fullness_score + \n                       weights[1] * remaining_cap_score + \n                       weights[2] * index_bias)\n    \n    # Normalize the priority scores to be within a certain range\n    priority_scores = np.tanh(priority_scores)\n    \n    return priority_scores\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full, have a remaining capacity that is as close as possible to the item size,\n    and have a smaller index (to break ties in a more deterministic manner).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition) / (item + 1e-6)), \n                                   0)\n    \n    # Introduce a bias towards bins with smaller indices to break ties\n    index_bias = -np.arange(len(bins_remain_cap)) / len(bins_remain_cap)\n    \n    # Combine the scores with tunable weights to get the final priority score\n    weights = np.array([0.5, 0.4, 0.1])  # Weights for bin_fullness_score, remaining_cap_score, and index_bias respectively\n    priority_scores = (weights[0] * bin_fullness_score + \n                       weights[1] * remaining_cap_score + \n                       weights[2] * index_bias)\n    \n    # Normalize the priority scores to be within a certain range\n    priority_scores = np.tanh(priority_scores)\n    \n    return priority_scores\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Combines best fit strategy with a bonus for smaller remaining capacity.\n    \"\"\"\n    # Check if the item can fit in each bin and calculate priority\n    valid_bins = bins_remain_cap >= item\n    # Prioritize bins that fit the item tightly\n    fit_score = -np.abs(bins_remain_cap - item)\n    # Add a small bonus based on the remaining capacity to break ties\n    bonus = bins_remain_cap * 1e-6\n    # Combine fit score and bonus\n    priority = np.where(valid_bins, fit_score + bonus, -np.inf)\n    \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity for the item, \n    are more full, have a remaining capacity that is as close as possible to the item size,\n    and have a smaller index (to break ties in favor of earlier bins).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate a score that rewards bins where the remaining capacity is close to zero (i.e., the bin is full)\n    bin_fullness_score = np.where(has_enough_capacity, \n                                  1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6)), \n                                  -1)\n    \n    # Calculate a score that rewards bins where the remaining capacity after addition is close to the item size\n    remaining_cap_score = np.where(has_enough_capacity, \n                                   1 / (1 + np.abs(remaining_cap_after_addition) / (item + 1e-6)), \n                                   0)\n    \n    # Introduce a bias towards bins with smaller indices to break ties\n    index_bias = -np.arange(len(bins_remain_cap)) / len(bins_remain_cap)\n    \n    # Combine the scores with tunable weights to get the final priority score\n    weights = np.array([0.5, 0.4, 0.1])  # weights for bin_fullness_score, remaining_cap_score, and index_bias\n    priority_scores = (weights[0] * bin_fullness_score + \n                       weights[1] * remaining_cap_score + \n                       weights[2] * index_bias)\n    \n    # Normalize the priority scores to be between 0 and 1\n    priority_scores = (priority_scores - np.min(priority_scores)) / (np.max(priority_scores) - np.min(priority_scores) + 1e-6)\n    \n    # Set the priority score to 0 for bins that don't have enough capacity\n    priority_scores = np.where(has_enough_capacity, priority_scores, 0)\n    \n    return priority_scores\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin. \n    Prioritizes bins that fit the item tightly, are more full, and have smaller remaining capacity.\n    \"\"\"\n    # Check if the bin has enough capacity for the item\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate the priority score for bins with enough capacity\n    # Higher priority for bins that are more full and fit the item tightly\n    tight_fit_score = 1 / (bins_remain_cap - item + 1e-6)\n    fullness_score = 1 / (bins_remain_cap + 1e-6)  # Prefer bins with smaller remaining capacity\n    priority_scores = np.where(has_enough_capacity, tight_fit_score + fullness_score, -np.inf)\n    \n    return priority_scores\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines bin fullness and remaining capacity scores effectively with tunable weights.\n    Prioritizes bins that are more full and have enough capacity for the item.\n    \"\"\"\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the bin has enough capacity\n    has_enough_capacity = remaining_cap_after_addition >= 0\n    \n    # Calculate priority scores for bins with enough capacity\n    # Weighted sum of bin's fullness and remaining capacity after addition\n    fullness_score = 1 - (bins_remain_cap / (bins_remain_cap + item))  # Score for bin fullness\n    remaining_score = 1 - (remaining_cap_after_addition / (bins_remain_cap + 1e-6))  # Score for remaining capacity\n    priority_scores_enough_cap = 0.6 * fullness_score + 0.4 * remaining_score  # Weighted sum\n    \n    # Assign low priority to bins without enough capacity\n    priority_scores_not_enough_cap = -1 * np.ones_like(bins_remain_cap)\n    \n    # Combine priority scores\n    priority_scores = np.where(has_enough_capacity, priority_scores_enough_cap, priority_scores_not_enough_cap)\n    \n    return priority_scores\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines bin fullness and remaining capacity scores with tunable weights for priority calculation.\n    Rewards bins that are full and have remaining capacity close to the item size.\n    \"\"\"\n    # Check if bin has enough capacity\n    has_enough_capacity = bins_remain_cap >= item\n    \n    # Calculate scores for bin fullness and remaining capacity after addition\n    bin_fullness_score = np.where(has_enough_capacity, 1 - ((bins_remain_cap - item) / (bins_remain_cap + 1e-6)), -1)\n    remaining_cap_score = np.where(has_enough_capacity, 1 / (1 + np.abs(bins_remain_cap - item) / (item + 1e-6)), 0)\n    \n    # Combine scores with weights (0.6 for bin fullness and 0.4 for remaining capacity score)\n    # Weights can be tuned for optimal performance\n    priority_scores = 0.6 * bin_fullness_score + 0.4 * remaining_cap_score\n    \n    return priority_scores\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}