[
     {
          "algorithm": "This algorithm samples random tours, refines them using 2-opt, and aggregates edge usage frequency to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm samples random tours, refines them using 2-opt, and aggregates edge usage frequency to create a heuristic matrix.}\"\"\"\n  n = distance_matrix.shape[0]\n  num_samples = 100  # Number of random tours to generate\n  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n  def calculate_tour_length(tour):\n    length = 0\n    for i in range(len(tour) - 1):\n      length += distance_matrix[tour[i], tour[i+1]]\n    length += distance_matrix[tour[-1], tour[0]]\n    return length\n\n  def two_opt_swap(tour, i, k):\n    new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]\n    return new_tour\n\n  def two_opt(tour):\n    best_tour = tour\n    improved = True\n    while improved:\n      improved = False\n      for i in range(1, n - 1):\n        for k in range(i + 1, n):\n          new_tour = two_opt_swap(best_tour, i, k)\n          if calculate_tour_length(new_tour) < calculate_tour_length(best_tour):\n            best_tour = new_tour\n            improved = True\n    return best_tour\n\n  for _ in range(num_samples):\n    # Generate a random tour\n    tour = np.random.permutation(n)\n\n    # Refine the tour using 2-opt\n    tour = two_opt(list(tour))\n\n    # Update the heuristics matrix based on edge usage\n    for i in range(n - 1):\n      heuristics_matrix[tour[i], tour[i+1]] += 1\n      heuristics_matrix[tour[i+1], tour[i]] += 1\n    heuristics_matrix[tour[-1], tour[0]] += 1\n    heuristics_matrix[tour[0], tour[-1]] += 1\n      \n  # Normalize the heuristics matrix\n  heuristics_matrix /= num_samples\n\n  return heuristics_matrix",
          "objective": 5.79349,
          "other_inf": null,
          "SLOC": 35.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 322.0227601751469
     },
     {
          "algorithm": "This algorithm initializes a matrix of heuristics with inverse distances, then refines these heuristics by sampling random paths and increasing the heuristic value for edges frequently used in short paths.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm initializes a matrix of heuristics with inverse distances, then refines these heuristics by sampling random paths and increasing the heuristic value for edges frequently used in short paths.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = 1.0 / (distance_matrix + np.eye(n))  # Initialize with inverse distance\n    np.fill_diagonal(heuristics_matrix, 0)\n\n    num_samples = 1000\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        unvisited_nodes = list(range(n))\n        current_node = start_node\n        unvisited_nodes.remove(current_node)\n        path = [current_node]\n        path_length = 0\n\n        while unvisited_nodes:\n            distances = distance_matrix[current_node, unvisited_nodes]\n            next_node_index = np.argmin(distances)\n            next_node = unvisited_nodes[next_node_index]\n            path.append(next_node)\n            path_length += distance_matrix[current_node, next_node]\n            current_node = next_node\n            unvisited_nodes.remove(next_node)\n\n        path.append(start_node)\n        path_length += distance_matrix[current_node, start_node]\n\n        # Update heuristics based on path length\n        if path_length < np.mean(distance_matrix) * n:\n            for i in range(n):\n                heuristics_matrix[path[i], path[i+1]] += 0.1\n                heuristics_matrix[path[i+1], path[i]] += 0.1\n    return heuristics_matrix",
          "objective": 6.22644,
          "other_inf": null,
          "SLOC": 35.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 322.0227601751469
     },
     {
          "algorithm": "This algorithm generates multiple random TSP solutions using nearest neighbor heuristic with random starting nodes, and uses the frequency of each edge appearing in these solutions as an indicator of its potential importance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm generates multiple random TSP solutions using nearest neighbor heuristic with random starting nodes, and uses the frequency of each edge appearing in these solutions as an indicator of its potential importance.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited = set(range(n))\n        unvisited.remove(current_node)\n        path = [current_node]\n\n        while unvisited:\n            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])\n            heuristics_matrix[current_node, nearest_neighbor] += 1\n            heuristics_matrix[nearest_neighbor, current_node] += 1\n            current_node = nearest_neighbor\n            path.append(current_node)\n            unvisited.remove(current_node)\n        \n        heuristics_matrix[current_node, start_node] += 1\n        heuristics_matrix[start_node, current_node] += 1\n\n    return heuristics_matrix",
          "objective": 6.23387,
          "other_inf": null,
          "SLOC": 35.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 322.0227601751469
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by combining inverse distance, nearest neighbor information, and a penalty for long edges, then normalizes it.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm constructs a heuristic matrix by combining inverse distance, nearest neighbor information, and a penalty for long edges, then normalizes it.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n\n    # Inverse distance heuristic\n    inverse_distance = 1.0 / (distance_matrix + np.eye(n))  # Avoid division by zero\n\n    # Nearest neighbor heuristic\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)\n    nearest_neighbor_bonus = np.zeros((n, n))\n    for i in range(n):\n        for j in range(1, min(4, n)):  # Bonus for top 3 nearest neighbors\n            neighbor = nearest_neighbors[i, j]\n            nearest_neighbor_bonus[i, neighbor] = 1.0 #/ j  # Higher bonus for closer neighbors\n            \n    # Penalty for long edges\n    mean_distance = np.mean(distance_matrix)\n    long_edge_penalty = np.where(distance_matrix > 2 * mean_distance, -0.5, 0)  # Penalize edges significantly longer than average\n\n    # Combine heuristics\n    heuristics_matrix = inverse_distance + nearest_neighbor_bonus + long_edge_penalty\n\n    # Normalize the heuristics matrix\n    min_val = np.min(heuristics_matrix)\n    max_val = np.max(heuristics_matrix)\n    if max_val > min_val:\n        heuristics_matrix = (heuristics_matrix - min_val) / (max_val - min_val)\n\n    return heuristics_matrix",
          "objective": 6.41158,
          "other_inf": null,
          "SLOC": 26.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 217.13097389073664
     },
     {
          "algorithm": "This algorithm constructs a heuristics matrix by combining inverse distance with shortest-path-based edge scores.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm constructs a heuristics matrix by combining inverse distance with shortest-path-based edge scores.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Inverse distance heuristic\n    inverse_distance = 1.0 / (distance_matrix + np.eye(n))\n    \n    # Shortest path based heuristic\n    shortest_path_matrix = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                \n                min_path_sum = float('inf')\n                for k in range(n):\n                    if k != i and k !=j:\n                        path_sum = distance_matrix[i,k] + distance_matrix[k,j]\n                        min_path_sum = min(min_path_sum, path_sum)\n\n                shortest_path_matrix[i,j] = min_path_sum\n\n    shortest_path_matrix = 1.0 / (shortest_path_matrix + np.eye(n))\n\n    # Combine heuristics (you can adjust the weights)\n    heuristics_matrix = 0.7 * inverse_distance + 0.3 * shortest_path_matrix\n\n    return heuristics_matrix",
          "objective": 6.77962,
          "other_inf": null,
          "SLOC": 35.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 322.0227601751469
     },
     {
          "algorithm": "This algorithm samples random tours, favoring shorter edges, and accumulates edge usage frequencies to produce a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples random tours, favoring shorter edges, and accumulates edge usage frequencies to produce a heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Initialize tour\n        current_node = np.random.randint(n)\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            # Probabilistically select next node based on distance\n            probabilities = np.zeros(n)\n            for node in unvisited_nodes:\n                probabilities[node] = 1 / (distance_matrix[current_node, node] + 1e-9)  # Avoid division by zero\n            probabilities /= np.sum(probabilities)  # Normalize to create a probability distribution\n\n            next_node = np.random.choice(list(unvisited_nodes), p=probabilities[list(unvisited_nodes)])\n            \n            tour.append(next_node)\n            unvisited_nodes.remove(next_node)\n            current_node = next_node\n\n        # Complete the tour by returning to the starting node\n        tour.append(tour[0])\n\n        # Update the heuristic matrix based on edges used in the tour\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1  # Ensure symmetry\n\n    heuristics_matrix /= num_samples  # Normalize to get frequencies\n    return heuristics_matrix",
          "objective": 6.91418,
          "other_inf": null,
          "SLOC": 26.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 217.13097389073664
     },
     {
          "algorithm": "This algorithm generates multiple random tours, selects a subset of the best tours, and then averages the inverse of the distances of the edges present in those tours to generate a heuristic matrix favoring edges frequently present in good tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm generates multiple random tours, selects a subset of the best tours, and then averages the inverse of the distances of the edges present in those tours to generate a heuristic matrix favoring edges frequently present in good tours.}\"\"\"\n  n = distance_matrix.shape[0]\n  num_tours = 100\n  best_tours_fraction = 0.1\n  \n  tours = []\n  tour_lengths = []\n  \n  for _ in range(num_tours):\n    # Generate a random tour\n    tour = np.random.permutation(n)\n    \n    # Calculate the tour length\n    tour_length = 0\n    for i in range(n - 1):\n      tour_length += distance_matrix[tour[i], tour[i+1]]\n    tour_length += distance_matrix[tour[n-1], tour[0]]\n    \n    tours.append(tour)\n    tour_lengths.append(tour_length)\n  \n  # Select the best tours\n  num_best_tours = int(num_tours * best_tours_fraction)\n  best_tour_indices = np.argsort(tour_lengths)[:num_best_tours]\n  best_tours = [tours[i] for i in best_tour_indices]\n  \n  # Create a heuristic matrix\n  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n  \n  for tour in best_tours:\n    for i in range(n - 1):\n      u = tour[i]\n      v = tour[i+1]\n      heuristics_matrix[u, v] += 1.0 / distance_matrix[u, v] if distance_matrix[u, v] > 0 else 0\n      heuristics_matrix[v, u] += 1.0 / distance_matrix[v, u] if distance_matrix[v, u] > 0 else 0\n    u = tour[n-1]\n    v = tour[0]\n    heuristics_matrix[u, v] += 1.0 / distance_matrix[u, v] if distance_matrix[u, v] > 0 else 0\n    heuristics_matrix[v, u] += 1.0 / distance_matrix[v, u] if distance_matrix[v, u] > 0 else 0\n  \n  # Normalize the heuristic matrix\n  return heuristics_matrix",
          "objective": 10.21162,
          "other_inf": null,
          "SLOC": 26.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 217.13097389073664
     },
     {
          "algorithm": "This algorithm estimates edge inclusion probabilities by iteratively sampling solutions using a nearest neighbor heuristic with stochastic perturbations and tracks edge frequencies across these samples.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm estimates edge inclusion probabilities by iteratively sampling solutions using a nearest neighbor heuristic with stochastic perturbations and tracks edge frequencies across these samples.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n\n    for _ in range(num_samples):\n        current_node = np.random.randint(n)\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        path = [current_node]\n\n        while unvisited_nodes:\n            distances = distance_matrix[current_node, :]\n            \n            # Perturb distances stochastically\n            probabilities = np.exp(-distances / np.mean(distances))  # Softmax\n            probabilities[current_node] = 0  # Avoid self-loop\n            probabilities = probabilities / np.sum(probabilities)  # Normalize\n           \n            # Select next node with probability proportional to perturbed distances\n            next_node = np.random.choice(n, p=probabilities)\n\n            # Ensure that the selected node is in the set of unvisited nodes\n            while next_node not in unvisited_nodes:\n               \n                probabilities = np.exp(-distances / np.mean(distances)) # Softmax\n                probabilities[current_node] = 0\n                probabilities = probabilities/ np.sum(probabilities)\n                next_node = np.random.choice(n, p = probabilities)\n\n\n            path.append(next_node)\n            unvisited_nodes.remove(next_node)\n            current_node = next_node\n\n        path.append(path[0]) # Return to start\n        \n        #Update heuristics matrix with edge frequencies\n        for i in range(n):\n            node1 = path[i]\n            node2 = path[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n            \n    heuristics_matrix = heuristics_matrix / num_samples #normalize to 0-1\n\n    return heuristics_matrix",
          "objective": 11.32845,
          "other_inf": null,
          "SLOC": 26.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 217.13097389073664
     },
     {
          "algorithm": "This algorithm samples multiple random tours, then calculates the frequency of each edge appearing in the shortest tours found in each sample, using this frequency to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple random tours, then calculates the frequency of each edge appearing in the shortest tours found in each sample, using this frequency to create a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    num_shortest = 10\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        tour_distance = 0\n        for i in range(n - 1):\n            tour_distance += distance_matrix[tour[i], tour[i+1]]\n        tour_distance += distance_matrix[tour[-1], tour[0]]\n\n        # Generate more tours and keep the shortest ones\n        shortest_tours = [(tour, tour_distance)]\n        for _ in range(100):\n            new_tour = np.random.permutation(n)\n            new_tour_distance = 0\n            for i in range(n - 1):\n                new_tour_distance += distance_matrix[new_tour[i], new_tour[i+1]]\n            new_tour_distance += distance_matrix[new_tour[-1], new_tour[0]]\n            \n            if len(shortest_tours) < num_shortest:\n                shortest_tours.append((new_tour, new_tour_distance))\n                shortest_tours = sorted(shortest_tours, key=lambda x: x[1])\n            else:\n                if new_tour_distance < shortest_tours[-1][1]:\n                    shortest_tours[-1] = (new_tour, new_tour_distance)\n                    shortest_tours = sorted(shortest_tours, key=lambda x: x[1])\n        \n        # Update heuristics matrix based on the edges in the shortest tours\n        for tour, _ in shortest_tours:\n            for i in range(n - 1):\n                heuristics_matrix[tour[i], tour[i+1]] += 1\n                heuristics_matrix[tour[i+1], tour[i]] += 1\n            heuristics_matrix[tour[-1], tour[0]] += 1\n            heuristics_matrix[tour[0], tour[-1]] += 1\n    \n    return heuristics_matrix",
          "objective": 11.64281,
          "other_inf": null,
          "SLOC": 35.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 322.0227601751469
     },
     {
          "algorithm": "This algorithm samples a number of random tours, and for each edge calculates the frequency with which it appears in the shortest tours, using this frequency as a heuristic value.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples a number of random tours, and for each edge calculates the frequency with which it appears in the shortest tours, using this frequency as a heuristic value.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    tour_lengths = np.zeros(num_samples)\n    tours = np.zeros((num_samples, n), dtype=int)\n    \n    for i in range(num_samples):\n        tour = np.random.permutation(n)\n        tours[i, :] = tour\n        tour_length = 0\n        for j in range(n - 1):\n            tour_length += distance_matrix[tour[j], tour[j+1]]\n        tour_length += distance_matrix[tour[-1], tour[0]]\n        tour_lengths[i] = tour_length\n    \n    # Select top 10% shortest tours\n    cutoff = np.percentile(tour_lengths, 10)\n    best_tours_indices = np.where(tour_lengths <= cutoff)[0]\n    best_tours = tours[best_tours_indices, :]\n    \n    heuristics_matrix = np.zeros((n, n))\n    for tour in best_tours:\n        for i in range(n - 1):\n            heuristics_matrix[tour[i], tour[i+1]] += 1\n            heuristics_matrix[tour[i+1], tour[i]] += 1\n        heuristics_matrix[tour[-1], tour[0]] += 1\n        heuristics_matrix[tour[0], tour[-1]] += 1\n    \n    # Normalize\n    if np.max(heuristics_matrix) > 0:\n        heuristics_matrix = heuristics_matrix / np.max(heuristics_matrix)\n    \n    return heuristics_matrix",
          "objective": 13.9016,
          "other_inf": null,
          "SLOC": 26.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 217.13097389073664
     },
     {
          "algorithm": "This algorithm generates multiple random tours, scores each edge based on its frequency in short tours, and returns a matrix representing edge importance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm generates multiple random tours, scores each edge based on its frequency in short tours, and returns a matrix representing edge importance.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    tour_lengths = []\n    tours = []\n\n    for _ in range(num_samples):\n        tour = np.random.permutation(n)\n        tours.append(tour)\n        tour_length = 0\n        for i in range(n - 1):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n        tour_length += distance_matrix[tour[-1], tour[0]]\n        tour_lengths.append(tour_length)\n\n    # Rank the tours by length\n    ranked_tours = sorted(zip(tour_lengths, tours))\n    \n    # Only consider the best tours for heuristic calculation\n    num_best_tours = min(100, num_samples)\n    for rank in range(num_best_tours):\n        tour_length, tour = ranked_tours[rank]\n        \n        # Update heuristics matrix based on edge presence\n        for i in range(n - 1):\n            heuristics_matrix[tour[i], tour[i+1]] += 1.0 * (num_best_tours - rank) / num_best_tours\n            heuristics_matrix[tour[i+1], tour[i]] += 1.0 * (num_best_tours - rank) / num_best_tours # Ensure symmetry\n        heuristics_matrix[tour[-1], tour[0]] += 1.0 * (num_best_tours - rank) / num_best_tours\n        heuristics_matrix[tour[0], tour[-1]] += 1.0 * (num_best_tours - rank) / num_best_tours # Ensure symmetry\n        \n    return heuristics_matrix",
          "objective": 14.38289,
          "other_inf": null,
          "SLOC": 26.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 217.13097389073664
     },
     {
          "algorithm": "This algorithm samples many random tours, and for each edge, counts how often that edge appears in a tour that is shorter than a dynamic threshold, returning a matrix reflecting the frequency of edge appearances in such \"good\" tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples many random tours, and for each edge, counts how often that edge appears in a tour that is shorter than a dynamic threshold, returning a matrix reflecting the frequency of edge appearances in such \"good\" tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    \n    shortest_tour_length = np.inf\n    \n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        tour_length = 0\n        for i in range(n - 1):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n        tour_length += distance_matrix[tour[-1], tour[0]]\n        \n        # Update shortest tour length\n        shortest_tour_length = min(shortest_tour_length, tour_length)\n        \n        # Dynamic threshold - allows more edges in earlier tours.\n        threshold = shortest_tour_length * (1 + 0.1 * (1 - (_ / num_samples)))\n\n        if tour_length < threshold:\n            # Update heuristics_matrix if the tour is good\n            for i in range(n - 1):\n                heuristics_matrix[tour[i], tour[i+1]] += 1\n                heuristics_matrix[tour[i+1], tour[i]] += 1  # Symmetric\n            heuristics_matrix[tour[-1], tour[0]] += 1\n            heuristics_matrix[tour[0], tour[-1]] += 1  # Symmetric\n    \n    return heuristics_matrix",
          "objective": 16.35836,
          "other_inf": null,
          "SLOC": 35.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 322.0227601751469
     },
     {
          "algorithm": "This algorithm samples random tours, then assigns higher values to edges more frequently appearing in shorter tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples random tours, then assigns higher values to edges more frequently appearing in shorter tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    \n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        \n        # Calculate the tour length\n        tour_length = 0\n        for i in range(n - 1):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n        tour_length += distance_matrix[tour[-1], tour[0]]\n        \n        # Update the heuristics matrix based on the tour length\n        for i in range(n - 1):\n            heuristics_matrix[tour[i], tour[i+1]] += 1 / tour_length\n            heuristics_matrix[tour[i+1], tour[i]] += 1 / tour_length # Ensure symmetry\n        heuristics_matrix[tour[-1], tour[0]] += 1 / tour_length\n        heuristics_matrix[tour[0], tour[-1]] += 1 / tour_length # Ensure symmetry\n        \n    return heuristics_matrix",
          "objective": 19.90033,
          "other_inf": null,
          "SLOC": 35.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 322.0227601751469
     },
     {
          "algorithm": "This algorithm samples multiple random solutions, evaluates their lengths, and assigns higher probabilities to edges that appear more frequently in shorter solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple random solutions, evaluates their lengths, and assigns higher probabilities to edges that appear more frequently in shorter solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random permutation of cities\n        permutation = np.random.permutation(n)\n        \n        # Calculate the total distance of the tour\n        tour_distance = 0\n        for i in range(n - 1):\n            tour_distance += distance_matrix[permutation[i], permutation[i+1]]\n        tour_distance += distance_matrix[permutation[-1], permutation[0]]\n        \n        # Update the heuristics matrix based on edges in this tour\n        for i in range(n - 1):\n            heuristics_matrix[permutation[i], permutation[i+1]] += 1 / tour_distance\n            heuristics_matrix[permutation[i+1], permutation[i]] += 1 / tour_distance #Symmetric matrix\n        heuristics_matrix[permutation[-1], permutation[0]] += 1 / tour_distance\n        heuristics_matrix[permutation[0], permutation[-1]] += 1 / tour_distance\n\n    return heuristics_matrix",
          "objective": 20.26141,
          "other_inf": null,
          "SLOC": 35.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 322.0227601751469
     },
     {
          "algorithm": "This algorithm samples a large number of random tours, calculates the total distance of each tour, and then assigns heuristic values to each edge based on how frequently it appears in the shorter tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples a large number of random tours, calculates the total distance of each tour, and then assigns heuristic values to each edge based on how frequently it appears in the shorter tours.}\"\"\"\n    num_nodes = distance_matrix.shape[0]\n    num_samples = 1000  # Increase for better accuracy\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    tour_lengths = []\n    tours = []\n\n    for _ in range(num_samples):\n        tour = np.random.permutation(num_nodes)\n        tour_distance = 0\n        for i in range(num_nodes - 1):\n            tour_distance += distance_matrix[tour[i], tour[i+1]]\n        tour_distance += distance_matrix[tour[-1], tour[0]]  # Return to start\n        tour_lengths.append(tour_distance)\n        tours.append(tour)\n        \n    # Normalize tour lengths (lower is better, so invert and normalize)\n    normalized_tour_lengths = 1 / np.array(tour_lengths)\n    normalized_tour_lengths /= np.sum(normalized_tour_lengths)\n    \n    for i, tour in enumerate(tours):\n        weight = normalized_tour_lengths[i]\n        for j in range(num_nodes - 1):\n            heuristics_matrix[tour[j], tour[j+1]] += weight\n            heuristics_matrix[tour[j+1], tour[j]] += weight  # Symmetric\n        heuristics_matrix[tour[-1], tour[0]] += weight\n        heuristics_matrix[tour[0], tour[-1]] += weight #Symmetric\n\n    return heuristics_matrix",
          "objective": 20.42605,
          "other_inf": null,
          "SLOC": 26.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 217.13097389073664
     },
     {
          "algorithm": "This algorithm samples multiple random tours, calculates the frequency of each edge appearing in short tours, and uses this frequency as a heuristic score for edge importance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple random tours, calculates the frequency of each edge appearing in short tours, and uses this frequency as a heuristic score for edge importance.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    \n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])  # Return to starting city\n\n        # Calculate the tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n\n        # If the tour is relatively short, update heuristics\n        if tour_length < np.mean(distance_matrix) * n * 1.5: # a threshold\n            for i in range(n):\n                heuristics_matrix[tour[i], tour[i+1]] += 1\n                heuristics_matrix[tour[i+1], tour[i]] += 1\n\n    # Normalize the heuristics matrix\n    max_val = np.max(heuristics_matrix)\n    if max_val > 0:\n        heuristics_matrix = heuristics_matrix / max_val\n\n    return heuristics_matrix",
          "objective": 21.09259,
          "other_inf": null,
          "SLOC": 26.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 217.13097389073664
     },
     {
          "algorithm": "This algorithm samples multiple random tours, and for each edge, it counts how many times it appears in the shortest tours found so far, normalizing by the number of shortest tours, and returning the normalized counts as a heuristic.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple random tours, and for each edge, it counts how many times it appears in the shortest tours found so far, normalizing by the number of shortest tours, and returning the normalized counts as a heuristic.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    shortest_distance = np.inf\n    shortest_tours = []\n    edge_counts = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0]) # Return to starting node\n        \n        # Calculate the distance of the tour\n        distance = 0\n        for i in range(n):\n            distance += distance_matrix[tour[i], tour[i+1]]\n        \n        # Update shortest distance and tours\n        if distance < shortest_distance:\n            shortest_distance = distance\n            shortest_tours = [tour]\n        elif distance == shortest_distance:\n            shortest_tours.append(tour)\n    \n    # Count edge occurrences in shortest tours\n    for tour in shortest_tours:\n        for i in range(n):\n            edge_counts[tour[i], tour[i+1]] += 1\n            edge_counts[tour[i+1], tour[i]] += 1 # since the matrix is symmetric\n\n    # Normalize edge counts by the number of shortest tours\n    heuristics_matrix = edge_counts / len(shortest_tours)\n    \n    return heuristics_matrix",
          "objective": 21.48898,
          "other_inf": null,
          "SLOC": 35.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 322.0227601751469
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by prioritizing edges with shorter distances and penalizing edges that would create short cycles or lead to isolated nodes, achieved through iterative sampling and refinement.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm constructs a heuristic matrix by prioritizing edges with shorter distances and penalizing edges that would create short cycles or lead to isolated nodes, achieved through iterative sampling and refinement.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Initialize heuristics with inverse of distance\n    heuristics_matrix = 1 / (distance_matrix + 1e-6)  # Avoid division by zero\n\n    num_samples = 100\n    for _ in range(num_samples):\n        # Sample a random tour using the current heuristics\n        current_node = np.random.randint(n)\n        tour = [current_node]\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n\n        while unvisited_nodes:\n            probabilities = heuristics_matrix[current_node, :]\n            probabilities[list(tour)] = 0  # Avoid revisiting nodes\n\n            # Normalize probabilities\n            if np.sum(probabilities) > 0:\n                probabilities /= np.sum(probabilities)\n            else:\n                # If all probabilities are zero, choose a random unvisited node\n                next_node = np.random.choice(list(unvisited_nodes))\n                tour.append(next_node)\n                unvisited_nodes.remove(next_node)\n                current_node = next_node\n                continue\n\n            next_node = np.random.choice(n, p=probabilities)\n            if next_node not in unvisited_nodes:\n                # Handle case where chosen node was already visited due to numerical issues\n                available_nodes = list(unvisited_nodes)\n                if available_nodes:\n                    next_node = np.random.choice(available_nodes)\n                else:\n                    break\n\n\n            tour.append(next_node)\n            unvisited_nodes.remove(next_node)\n            current_node = next_node\n            \n\n        if len(tour) == n:\n            tour.append(tour[0]) # Complete cycle\n            # Update heuristics based on the tour\n            for i in range(n):\n                node1 = tour[i]\n                node2 = tour[i+1]\n                heuristics_matrix[node1, node2] += 0.1\n                heuristics_matrix[node2, node1] += 0.1  # Ensure symmetry\n            \n\n    return heuristics_matrix",
          "objective": 26.38295,
          "other_inf": null,
          "SLOC": 35.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 322.0227601751469
     },
     {
          "algorithm": "This algorithm samples multiple near-optimal TSP solutions using a combination of nearest neighbor and random edge swaps, then aggregates the edge usage frequencies to estimate the likelihood of each edge belonging to an optimal solution.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple near-optimal TSP solutions using a combination of nearest neighbor and random edge swaps, then aggregates the edge usage frequencies to estimate the likelihood of each edge belonging to an optimal solution.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # 1. Nearest Neighbor Initialization\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited = set(range(n))\n        unvisited.remove(current_node)\n        tour = [current_node]\n\n        while unvisited:\n            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n        \n        tour.append(start_node)\n\n        # 2. Random Edge Swaps (2-opt) - Improve Solution\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if j == n:\n                        new_distance = distance_matrix[tour[i-1], tour[j-1]] + distance_matrix[tour[i], tour[0]]\n                        old_distance = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[j-1], tour[0]]\n                    else:\n                        new_distance = distance_matrix[tour[i-1], tour[j]] + distance_matrix[tour[i], tour[j-1]]\n                        old_distance = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[j], tour[j-1]]\n\n                    if new_distance < old_distance:\n                        tour[i:j] = reversed(tour[i:j])\n                        improved = True\n                        break\n                if improved:\n                    break\n            \n        # 3. Update Heuristics Matrix\n        for i in range(n):\n            heuristics_matrix[tour[i], tour[i+1]] += 1\n            heuristics_matrix[tour[i+1], tour[i]] += 1\n            \n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm samples multiple random tours, applies a 2-opt local search to each, and then averages the frequency with which each edge appears in the locally optimized tours to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple random tours, applies a 2-opt local search to each, and then averages the frequency with which each edge appears in the locally optimized tours to create a heuristic matrix.}\"\"\"\n    num_nodes = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    def calculate_tour_length(tour):\n        length = 0\n        for i in range(len(tour) - 1):\n            length += distance_matrix[tour[i], tour[i+1]]\n        length += distance_matrix[tour[-1], tour[0]]\n        return length\n\n    def two_opt_swap(tour, i, k):\n        new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]\n        return new_tour\n    \n    def two_opt(tour):\n        best_tour = tour\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, len(tour) - 1):\n                for k in range(i + 1, len(tour)):\n                    new_tour = two_opt_swap(best_tour, i, k)\n                    if calculate_tour_length(new_tour) < calculate_tour_length(best_tour):\n                        best_tour = new_tour\n                        improved = True\n                        break\n                if improved:\n                    break\n        return best_tour\n\n\n    for _ in range(num_samples):\n        # Create a random tour\n        tour = np.random.permutation(num_nodes)\n\n        # Apply 2-opt local search\n        optimized_tour = two_opt(list(tour))\n\n        # Update the heuristics matrix\n        for i in range(len(optimized_tour) - 1):\n            u = optimized_tour[i]\n            v = optimized_tour[i+1]\n            heuristics_matrix[u, v] += 1\n            heuristics_matrix[v, u] += 1\n        u = optimized_tour[-1]\n        v = optimized_tour[0]\n        heuristics_matrix[u, v] += 1\n        heuristics_matrix[v, u] += 1\n\n    # Normalize the heuristics matrix\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     }
]