import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm constructs a heuristic matrix by combining inverse distance with a weighted average of neighborhood distances, penalizing distant nodes within the neighborhood.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance heuristic
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))

    # Neighborhood distance heuristic
    neighborhood_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        total_distance = 0.0
        weighted_sum = 0.0
        for j in range(n):
            if i != j:
                distance = distance_matrix[i, j]
                weight = np.exp(-distance / (np.mean(distance_matrix) + 1e-6))  # Exponential decay based on distance
                weighted_sum += weight * distance
                total_distance += weight

        if total_distance > 0:
            neighborhood_matrix[i, :] = weighted_sum / total_distance

    neighborhood_matrix = 1.0 / (neighborhood_matrix + np.eye(n))

    # Combine heuristics
    heuristics_matrix = 0.6 * inverse_distance + 0.4 * neighborhood_matrix

    return heuristics_matrix
