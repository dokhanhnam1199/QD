import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines edge frequency in k-means clustered solutions with a distance-based score, normalized to create a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    
    # K-means clustering to group nodes
    from sklearn.cluster import KMeans
    kmeans = KMeans(n_clusters=int(np.sqrt(n)), random_state=0, n_init=10)  # Number of clusters scaled to problem size
    clusters = kmeans.fit_predict(distance_matrix)

    # Generate tours within each cluster
    cluster_tours = {}
    for cluster_id in range(kmeans.n_clusters):
        cluster_nodes = np.where(clusters == cluster_id)[0]
        if len(cluster_nodes) > 1:
            cluster_tours[cluster_id] = np.random.permutation(cluster_nodes)
        else:
            cluster_tours[cluster_id] = cluster_nodes  # Single node cluster
    
    # Edge frequency count
    edge_counts = np.zeros((n, n))
    for cluster_id in range(kmeans.n_clusters):
        tour = cluster_tours[cluster_id]
        if len(tour) > 1:
            for i in range(len(tour) - 1):
                u = tour[i]
                v = tour[i+1]
                edge_counts[u, v] += 1
                edge_counts[v, u] += 1  # Symmetric
            u = tour[-1]
            v = tour[0]
            edge_counts[u, v] += 1
            edge_counts[v, u] += 1

    # Distance-based score
    distance_score = 1.0 / (distance_matrix + np.eye(n))
    
    # Combine edge frequency and distance score
    heuristics_matrix = edge_counts + distance_score

    # Normalize the heuristic matrix
    min_val = np.min(heuristics_matrix)
    max_val = np.max(heuristics_matrix)
    if max_val > min_val:
        heuristics_matrix = (heuristics_matrix - min_val) / (max_val - min_val)
    
    return heuristics_matrix
