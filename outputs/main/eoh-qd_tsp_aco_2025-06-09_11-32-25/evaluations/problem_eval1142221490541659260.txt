import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm refines a heuristic matrix based on edge usage in multiple simulated annealing runs, rewarding edges frequently included in low-energy states.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = 1.0 / (distance_matrix + np.eye(n))
    np.fill_diagonal(heuristics_matrix, 0)

    def energy(path):
        length = 0
        for i in range(n):
            length += distance_matrix[path[i], path[(i + 1) % n]]
        return length

    def neighbor(path):
        i, j = np.random.choice(n, 2, replace=False)
        new_path = path[:]
        new_path[i], new_path[j] = new_path[j], new_path[i]
        return new_path

    def simulated_annealing(start_node, temp=100, cooling_rate=0.95, steps=1000):
        path = [start_node]
        unvisited = list(range(n))
        unvisited.remove(start_node)
        current_node = start_node
        while unvisited:
            next_node = min(unvisited, key=lambda x: distance_matrix[current_node, x])
            path.append(next_node)
            unvisited.remove(next_node)
            current_node = next_node
        path = path
        current_energy = energy(path)

        best_path = path[:]
        best_energy = current_energy

        for _ in range(steps):
            new_path = neighbor(path[:])
            new_energy = energy(new_path)
            if new_energy < current_energy or np.random.rand() < np.exp((current_energy - new_energy) / temp):
                path = new_path[:]
                current_energy = new_energy

                if current_energy < best_energy:
                    best_energy = current_energy
                    best_path = path[:]
            temp *= cooling_rate
        return best_path, best_energy
    
    num_runs = 50
    for _ in range(num_runs):
        start_node = np.random.randint(n)
        best_path, best_energy = simulated_annealing(start_node)

        if best_energy < np.mean(distance_matrix) * n:
            for i in range(n):
                heuristics_matrix[best_path[i], best_path[(i + 1) % n]] += 0.1
                heuristics_matrix[best_path[(i + 1) % n], best_path[i]] += 0.1
    
    return heuristics_matrix
