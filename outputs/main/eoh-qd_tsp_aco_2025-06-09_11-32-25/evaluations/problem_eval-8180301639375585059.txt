import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines tours by swapping edges to minimize distance, updating edge heuristic values based on the improvements found.}"""
    num_nodes = distance_matrix.shape[0]
    num_iterations = 500
    num_initial_tours = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    # Generate initial random tours
    tours = [np.random.permutation(num_nodes) for _ in range(num_initial_tours)]
    
    for _ in range(num_iterations):
        # Select a random tour
        tour_index = np.random.randint(num_initial_tours)
        tour = tours[tour_index]
        
        # Choose two random edges to swap
        i = np.random.randint(num_nodes)
        j = np.random.randint(num_nodes)
        if i == j:
            continue
        
        # Reverse the segment between i and j
        start = min(i, j)
        end = max(i, j)
        new_tour = np.concatenate((tour[:start], tour[start:end+1][::-1], tour[end+1:]))
        
        # Calculate the distance of the old and new tours
        old_distance = 0
        for k in range(num_nodes - 1):
            old_distance += distance_matrix[tour[k], tour[k+1]]
        old_distance += distance_matrix[tour[-1], tour[0]]
        
        new_distance = 0
        for k in range(num_nodes - 1):
            new_distance += distance_matrix[new_tour[k], new_tour[k+1]]
        new_distance += distance_matrix[new_tour[-1], new_tour[0]]
        
        # If the new tour is better, update the heuristics and replace the old tour
        if new_distance < old_distance:
            tours[tour_index] = new_tour
            
            # Update heuristics (increase value for edges in the improved tour)
            for k in range(num_nodes - 1):
                heuristics_matrix[new_tour[k], new_tour[k+1]] += 1
                heuristics_matrix[new_tour[k+1], new_tour[k]] += 1
            heuristics_matrix[new_tour[-1], new_tour[0]] += 1
            heuristics_matrix[new_tour[0], new_tour[-1]] += 1
            
    # Normalize the heuristics matrix
    if np.max(heuristics_matrix) > 0:
        heuristics_matrix = heuristics_matrix / np.max(heuristics_matrix)
    
    return heuristics_matrix
