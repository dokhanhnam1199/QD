import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines a heuristic matrix by probabilistically selecting edges based on both distance and the current heuristic values, favoring edges that are short and have a high heuristic score.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix, dtype=float)  # Initialize with ones to avoid initial zeros
    alpha = 0.1  # Weight for combining distance and heuristic information
    num_iterations = 100

    for _ in range(num_iterations):
        # Probabilistically select edges to build a tour (not necessarily a complete tour)
        edge_probabilities = np.zeros_like(distance_matrix, dtype=float)
        for i in range(n):
            for j in range(i + 1, n):  # Consider only upper triangle for efficiency and to avoid duplicates
                edge_probabilities[i, j] = (heuristics_matrix[i, j] ** alpha) / (distance_matrix[i, j] + 1e-9)  #Heuristic value affected by prior heuristic and the distance. adding small number to prevent the possibility of dividing by zero.
                edge_probabilities[j, i] = edge_probabilities[i, j]  # Ensure symmetry

        # Normalize probabilities row-wise so that probabilities sum to 1 in each row
        for i in range(n):
            row_sum = np.sum(edge_probabilities[i, :])
            if row_sum > 0:
                edge_probabilities[i, :] /= row_sum
            else:
                edge_probabilities[i, :] = np.ones(n) / n #If no edge is possible, set to be uniform probability.
        # Update heuristics matrix based on edge probabilities
        heuristics_matrix = (1 - alpha) * heuristics_matrix + alpha * edge_probabilities #Update based on the probability
    return heuristics_matrix
