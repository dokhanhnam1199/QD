import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm generates multiple random TSP solutions using nearest neighbor heuristic with random starting nodes and a temperature-based acceptance criterion, and uses the frequency of each edge appearing in these solutions as an indicator of its potential importance.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 100
    temperature = 10.0

    for _ in range(num_samples):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited = set(range(n))
        unvisited.remove(current_node)
        path = [current_node]

        while unvisited:
            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])
            
            # Introduce stochastic acceptance based on temperature
            if np.random.rand() < np.exp(-distance_matrix[current_node, nearest_neighbor] / temperature):
                
                heuristics_matrix[current_node, nearest_neighbor] += 1
                heuristics_matrix[nearest_neighbor, current_node] += 1
                current_node = nearest_neighbor
                path.append(current_node)
                if nearest_neighbor in unvisited:
                    unvisited.remove(nearest_neighbor)
                else:
                    break # In case we repeat the same node.
            else:
                #If the nearest neighbor is not visited, try visiting another node
                remaining_nodes = list(unvisited)
                if remaining_nodes:
                    next_neighbor = remaining_nodes[np.random.randint(len(remaining_nodes))]
                    heuristics_matrix[current_node, next_neighbor] += 0.2
                    heuristics_matrix[next_neighbor, current_node] += 0.2
                    current_node = next_neighbor
                    path.append(current_node)
                    if next_neighbor in unvisited:
                        unvisited.remove(next_neighbor)
                    else:
                        break
                else:
                    break
        
        heuristics_matrix[current_node, start_node] += 1
        heuristics_matrix[start_node, current_node] += 1

    return heuristics_matrix
