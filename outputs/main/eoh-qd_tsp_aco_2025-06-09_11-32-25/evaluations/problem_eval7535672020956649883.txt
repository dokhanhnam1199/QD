import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm to evolve a population of tours, evaluates edge frequencies in the best tours, and then uses these frequencies to construct a heuristic matrix.}"""
    num_nodes = distance_matrix.shape[0]
    population_size = 50
    num_generations = 30
    mutation_rate = 0.05

    def calculate_tour_length(tour):
        length = 0
        for i in range(len(tour) - 1):
            length += distance_matrix[tour[i], tour[i+1]]
        length += distance_matrix[tour[-1], tour[0]]
        return length

    def create_initial_population(population_size, num_nodes):
        population = []
        for _ in range(population_size):
            tour = np.random.permutation(num_nodes)
            population.append(list(tour))
        return population

    def selection(population, fitnesses, num_parents):
        parents = []
        sorted_indices = np.argsort(fitnesses)
        for i in range(num_parents):
            parents.append(population[sorted_indices[i]])
        return parents

    def crossover(parent1, parent2):
        start = np.random.randint(0, len(parent1))
        end = np.random.randint(start + 1, len(parent1) + 1)
        child = [-1] * len(parent1)
        
        for i in range(start, end):
            child[i] = parent1[i]

        index = 0
        for gene in parent2:
            if gene not in child:
                while child[index] != -1:
                    index += 1
                child[index] = gene
        return child

    def mutate(tour, mutation_rate):
        if np.random.rand() < mutation_rate:
            i = np.random.randint(0, len(tour))
            j = np.random.randint(0, len(tour))
            tour[i], tour[j] = tour[j], tour[i]
        return tour

    population = create_initial_population(population_size, num_nodes)

    for _ in range(num_generations):
        fitnesses = [calculate_tour_length(tour) for tour in population]
        parents = selection(population, fitnesses, population_size // 2)

        new_population = parents[:]  # Keep the parents

        while len(new_population) < population_size:
            parent1 = np.random.choice(parents)
            parent2 = np.random.choice(parents)
            child = crossover(parent1, parent2)
            child = mutate(child, mutation_rate)
            new_population.append(child)

        population = new_population

    # Evaluate edge frequencies in the best tours
    fitnesses = [calculate_tour_length(tour) for tour in population]
    best_tours_indices = np.argsort(fitnesses)[:population_size // 5] #take the 20% best tour
    best_tours = [population[i] for i in best_tours_indices]

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    for tour in best_tours:
        for i in range(len(tour) - 1):
            u = tour[i]
            v = tour[i+1]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1
        u = tour[-1]
        v = tour[0]
        heuristics_matrix[u, v] += 1
        heuristics_matrix[v, u] += 1
    
    heuristics_matrix /= len(best_tours)

    return heuristics_matrix
