import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple TSP solutions using a greedy approach followed by simulated annealing, then aggregates the edge usage frequencies to estimate edge importance.}"""
    n = distance_matrix.shape[0]
    num_samples = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # 1. Greedy Initialization
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited = set(range(n))
        unvisited.remove(current_node)
        tour = [current_node]

        while unvisited:
            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])
            tour.append(nearest_neighbor)
            unvisited.remove(nearest_neighbor)
            current_node = nearest_neighbor
        
        tour.append(start_node)

        # 2. Simulated Annealing - Improve Solution
        temperature = 1.0
        cooling_rate = 0.95
        
        for _ in range(1000):
            i = np.random.randint(1, n)
            j = np.random.randint(i + 1, n + 1)
            
            if j == n:
                new_distance = distance_matrix[tour[i-1], tour[j-1]] + distance_matrix[tour[i], tour[0]]
                old_distance = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[j-1], tour[0]]
            else:
                new_distance = distance_matrix[tour[i-1], tour[j]] + distance_matrix[tour[i], tour[j-1]]
                old_distance = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[j], tour[j-1]]

            delta = new_distance - old_distance
            
            if delta < 0 or np.random.rand() < np.exp(-delta / temperature):
                tour[i:j] = reversed(tour[i:j])

            temperature *= cooling_rate

        # 3. Update Heuristics Matrix
        for i in range(n):
            heuristics_matrix[tour[i], tour[i+1]] += 1
            heuristics_matrix[tour[i+1], tour[i]] += 1
            
    heuristics_matrix /= num_samples

    return heuristics_matrix
