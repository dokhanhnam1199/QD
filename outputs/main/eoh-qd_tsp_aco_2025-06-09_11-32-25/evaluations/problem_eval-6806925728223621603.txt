import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm combines edge frequencies from truncated local search tours with inverse distance to create a heuristic matrix.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 50
    truncation_length = 5

    # Inverse distance component
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))

    # Local search component
    edge_frequency = np.zeros_like(distance_matrix, dtype=float)
    for _ in range(num_iterations):
        # Start with a random tour
        tour = np.random.permutation(n)

        # Perform truncated local search (2-opt swaps)
        for _ in range(truncation_length):
            best_improvement = 0
            best_i, best_j = None, None
            for i in range(n):
                for j in range(i + 2, n):
                    delta = -distance_matrix[tour[i - 1], tour[i]] - distance_matrix[tour[j], tour[(j + 1) % n]] + distance_matrix[tour[i - 1], tour[j]] + distance_matrix[tour[i], tour[(j + 1) % n]]
                    if delta < best_improvement:
                        best_improvement = delta
                        best_i, best_j = i, j
            
            if best_improvement < 0:
                tour[best_i:best_j+1] = tour[best_i:best_j+1][::-1]
            else:
                break # Stop if no improvement found
                
        # Update edge frequencies
        for i in range(n):
            edge_frequency[tour[i], tour[(i + 1) % n]] += 1
            edge_frequency[tour[(i + 1) % n], tour[i]] += 1

    # Combine inverse distance and edge frequency
    heuristics_matrix = 0.6 * inverse_distance + 0.4 * (edge_frequency / num_iterations)

    return heuristics_matrix
