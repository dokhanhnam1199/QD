import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix based on savings from inserting nodes between existing edges and combines it with a penalty for distance.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Calculate savings for each pair of nodes i and j
    savings = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                max_saving = 0
                for k in range(n):
                    if k != i and k != j:
                        saving = distance_matrix[i, k] + distance_matrix[k, j] - distance_matrix[i, j]
                        max_saving = max(max_saving, saving)
                savings[i, j] = max_saving

    # Combine savings with a distance penalty
    mean_distance = np.mean(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                 heuristics_matrix[i, j] = savings[i, j] - (distance_matrix[i, j] / mean_distance) # Savings minus distance penalty.

    # Normalize the heuristic matrix
    min_val = np.min(heuristics_matrix)
    max_val = np.max(heuristics_matrix)
    if max_val > min_val:
        heuristics_matrix = (heuristics_matrix - min_val) / (max_val - min_val)

    return heuristics_matrix
