import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively constructs tours by adding the shortest available edge that doesn't create subtours, prioritizing edges used in previous iterations.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 10

    for iteration in range(num_iterations):
        # Initialize tour construction
        unvisited_nodes = set(range(n))
        tour = []
        current_node = np.random.choice(list(unvisited_nodes))
        tour.append(current_node)
        unvisited_nodes.remove(current_node)

        while unvisited_nodes:
            best_edge = None
            min_distance = np.inf

            for next_node in unvisited_nodes:
                distance = distance_matrix[current_node, next_node]
                if distance < min_distance:
                    min_distance = distance
                    best_edge = (current_node, next_node)

            current_node, next_node = best_edge

            #Check for subtours: Find the position of the next_node if it's already in tour
            if next_node in tour:
                unvisited_nodes.remove(next_node)
                continue
            tour.append(next_node)
            unvisited_nodes.remove(next_node)

        # Complete the tour
        tour.append(tour[0])

        # Update heuristics matrix
        for i in range(n):
            node1 = tour[i]
            node2 = tour[i + 1]
            heuristics_matrix[node1, node2] += (iteration + 1)  # Prioritize edges used in earlier iterations
            heuristics_matrix[node2, node1] += (iteration + 1)

    return heuristics_matrix
