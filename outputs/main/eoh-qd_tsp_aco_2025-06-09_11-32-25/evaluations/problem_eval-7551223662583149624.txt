import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples a large number of random tours, selects the best tours based on their lengths, and then calculates heuristic values for each edge based on the frequency of its appearance in these elite tours.}"""
    num_nodes = distance_matrix.shape[0]
    num_samples = 1000
    num_elite = 100  # Number of best tours to consider
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    tour_lengths = []
    tours = []

    for _ in range(num_samples):
        tour = np.random.permutation(num_nodes)
        tour_distance = 0
        for i in range(num_nodes - 1):
            tour_distance += distance_matrix[tour[i], tour[i+1]]
        tour_distance += distance_matrix[tour[-1], tour[0]]  # Return to start
        tour_lengths.append(tour_distance)
        tours.append(tour)
    
    # Get indices of the best tours
    elite_indices = np.argsort(tour_lengths)[:num_elite]
    
    # Calculate heuristics based on the elite tours
    for i in elite_indices:
        tour = tours[i]
        for j in range(num_nodes - 1):
            heuristics_matrix[tour[j], tour[j+1]] += 1
            heuristics_matrix[tour[j+1], tour[j]] += 1  # Symmetric
        heuristics_matrix[tour[-1], tour[0]] += 1
        heuristics_matrix[tour[0], tour[-1]] += 1  # Symmetric
    
    # Normalize the heuristic matrix
    heuristics_matrix /= np.sum(heuristics_matrix)
    
    return heuristics_matrix
