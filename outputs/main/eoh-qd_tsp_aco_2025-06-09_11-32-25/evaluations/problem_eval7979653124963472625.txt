import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm samples multiple random tours, and for each edge, it counts how many times it appears in the shortest tours found so far, weighting each tour's contribution inversely proportionally to its length, normalizing by the sum of inverse lengths of shortest tours, and returning the normalized counts as a heuristic.}
    """
    n = distance_matrix.shape[0]
    num_samples = 1000
    shortest_distance = np.inf
    shortest_tours = []
    tour_distances = []
    edge_counts = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # Generate a random tour
        tour = np.random.permutation(n)
        tour = np.append(tour, tour[0]) # Return to starting node
        
        # Calculate the distance of the tour
        distance = 0
        for i in range(n):
            distance += distance_matrix[tour[i], tour[i+1]]
        
        # Update shortest distance and tours
        if distance < shortest_distance:
            shortest_distance = distance
            shortest_tours = [tour]
            tour_distances = [distance]
        elif distance == shortest_distance:
            shortest_tours.append(tour)
            tour_distances.append(distance)
    
    # Count edge occurrences in shortest tours, weighted by inverse distance
    inverse_distances = [1/d for d in tour_distances]
    total_inverse_distance = sum(inverse_distances)

    for tour_idx, tour in enumerate(shortest_tours):
        weight = inverse_distances[tour_idx] / total_inverse_distance
        for i in range(n):
            edge_counts[tour[i], tour[i+1]] += weight
            edge_counts[tour[i+1], tour[i]] += weight # since the matrix is symmetric

    # Normalize edge counts
    heuristics_matrix = edge_counts
    
    return heuristics_matrix
