import numpy as np

def heuristics_v3(distance_matrix):
    """
    {This algorithm constructs a heuristics matrix by emphasizing the inverse distance and penalizing edges based on the average distance to all other nodes.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance heuristic
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))
    
    # Average distance penalty
    average_distance = np.mean(distance_matrix, axis=1)
    penalty_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            penalty_matrix[i, j] = average_distance[i] + average_distance[j]

    penalty_matrix = 1.0 / (penalty_matrix + np.eye(n))

    # Combine heuristics (you can adjust the weights)
    heuristics_matrix = 0.8 * inverse_distance - 0.2 * penalty_matrix

    return heuristics_matrix
