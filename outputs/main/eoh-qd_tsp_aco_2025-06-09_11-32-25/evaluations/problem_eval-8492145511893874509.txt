import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm samples random tours, refines them using 3-opt, and aggregates edge usage frequency while favoring shorter edges.}"""
  n = distance_matrix.shape[0]
  num_samples = 100
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  def calculate_tour_length(tour):
    length = 0
    for i in range(len(tour) - 1):
      length += distance_matrix[tour[i], tour[i+1]]
    length += distance_matrix[tour[-1], tour[0]]
    return length

  def two_opt_swap(tour, i, k):
    new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]
    return new_tour

  def three_opt_swap(tour, i, j, k):
      a, b, c, d, e, f = tour[:i], tour[i:j], tour[j:k], tour[k:], tour[i], tour[k-1]
      new_tour = tour[:i] + tour[i:j][::-1] + tour[j:k][::-1] + tour[k:]
      return new_tour

  def three_opt(tour):
    best_tour = tour
    improved = True
    while improved:
      improved = False
      for i in range(1, n - 2):
        for j in range(i + 1, n - 1):
            for k in range(j + 1, n):
              new_tour = best_tour[:i] + best_tour[i:j][::-1] + best_tour[j:k][::-1] + best_tour[k:]
              if calculate_tour_length(new_tour) < calculate_tour_length(best_tour):
                best_tour = new_tour
                improved = True
    return best_tour
  
  for _ in range(num_samples):
    tour = np.random.permutation(n)
    tour = three_opt(list(tour))

    tour_length = calculate_tour_length(tour)

    for i in range(n - 1):
      edge_weight = 1 / (distance_matrix[tour[i], tour[i+1]] + 1e-6)
      heuristics_matrix[tour[i], tour[i+1]] += edge_weight
      heuristics_matrix[tour[i+1], tour[i]] += edge_weight
    
    edge_weight = 1 / (distance_matrix[tour[-1], tour[0]] + 1e-6)
    heuristics_matrix[tour[-1], tour[0]] += edge_weight
    heuristics_matrix[tour[0], tour[-1]] += edge_weight
      
  heuristics_matrix /= num_samples

  return heuristics_matrix
