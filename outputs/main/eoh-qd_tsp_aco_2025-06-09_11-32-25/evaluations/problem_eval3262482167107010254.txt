import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach to evolve a population of tours, using the edge frequencies in the best tours of the final generation as heuristic values.}"""
    num_nodes = distance_matrix.shape[0]
    population_size = 50
    num_generations = 100
    mutation_rate = 0.01

    def calculate_tour_length(tour):
        length = 0
        for i in range(len(tour) - 1):
            length += distance_matrix[tour[i], tour[i+1]]
        length += distance_matrix[tour[-1], tour[0]]
        return length

    def create_initial_population(size):
        population = []
        for _ in range(size):
            population.append(np.random.permutation(num_nodes).tolist())
        return population

    def fitness(tour):
        return 1 / calculate_tour_length(tour)

    def selection(population):
        fitnesses = [fitness(tour) for tour in population]
        total_fitness = sum(fitnesses)
        probabilities = [f / total_fitness for f in fitnesses]
        selected_indices = np.random.choice(len(population), size=len(population), p=probabilities)
        selected_population = [population[i] for i in selected_indices]
        return selected_population

    def crossover(parent1, parent2):
        start = np.random.randint(0, num_nodes)
        end = np.random.randint(start + 1, num_nodes + 1)
        child = parent1[start:end]
        for gene in parent2:
            if gene not in child:
                child.append(gene)
        return child

    def mutate(tour):
        for i in range(len(tour)):
            if np.random.rand() < mutation_rate:
                j = np.random.randint(0, len(tour))
                tour[i], tour[j] = tour[j], tour[i]
        return tour

    population = create_initial_population(population_size)

    for _ in range(num_generations):
        selected_population = selection(population)
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_population[i % len(selected_population)]
            parent2 = selected_population[(i + 1) % len(selected_population)]
            child1 = crossover(parent1, parent2)
            child2 = crossover(parent2, parent1)
            new_population.append(mutate(child1))
            new_population.append(mutate(child2))
        population = new_population

    # Calculate heuristics matrix from the best tour in the final population
    best_tour = max(population, key=lambda tour: fitness(tour))
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(len(best_tour) - 1):
        u = best_tour[i]
        v = best_tour[i+1]
        heuristics_matrix[u, v] = 1.0
        heuristics_matrix[v, u] = 1.0
    u = best_tour[-1]
    v = best_tour[0]
    heuristics_matrix[u, v] = 1.0
    heuristics_matrix[v, u] = 1.0
    
    return heuristics_matrix
