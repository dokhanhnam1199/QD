import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm constructs a heuristics matrix by combining inverse distance with shortest-path-based edge scores.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance heuristic
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))
    
    # Shortest path based heuristic
    shortest_path_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                
                min_path_sum = float('inf')
                for k in range(n):
                    if k != i and k !=j:
                        path_sum = distance_matrix[i,k] + distance_matrix[k,j]
                        min_path_sum = min(min_path_sum, path_sum)

                shortest_path_matrix[i,j] = min_path_sum

    shortest_path_matrix = 1.0 / (shortest_path_matrix + np.eye(n))

    # Combine heuristics (you can adjust the weights)
    heuristics_matrix = 0.7 * inverse_distance + 0.3 * shortest_path_matrix

    return heuristics_matrix
