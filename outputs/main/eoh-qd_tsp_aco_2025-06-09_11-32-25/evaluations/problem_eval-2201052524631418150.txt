import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm combines edge information from minimum spanning tree and Delaunay triangulation to guide TSP solution sampling.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Minimum Spanning Tree heuristic (approximation)
    mst_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    # Prim's Algorithm (approximate MST)
    visited = [False] * n
    key = [float('inf')] * n
    key[0] = 0
    parent = [None] * n

    for _ in range(n):
        min_key = float('inf')
        u = None
        for v in range(n):
            if not visited[v] and key[v] < min_key:
                min_key = key[v]
                u = v

        visited[u] = True

        for v in range(n):
            if distance_matrix[u, v] > 0 and not visited[v] and distance_matrix[u, v] < key[v]:
                key[v] = distance_matrix[u, v]
                parent[v] = u

    for v in range(1, n):
        mst_matrix[v, parent[v]] = 1
        mst_matrix[parent[v], v] = 1
    
    # Delaunay Triangulation heuristic (approximation)
    delaunay_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    # Consider edges in Delaunay triangulation if no point is inside the circumcircle
    def is_delaunay_edge(i, j, points):
        for k in range(n):
            if k != i and k != j:
                x1, y1 = points[i]
                x2, y2 = points[j]
                x3, y3 = points[k]

                # Calculate circumcircle
                a = x1 - x3
                b = y1 - y3
                c = x2 - x3
                d = y2 - y3
                e = a * (x1 + x3) + b * (y1 + y3)
                f = c * (x2 + x3) + d * (y2 + y3)
                g = 2 * (a * (y2 - y3) - b * (x2 - x3))
                
                if g == 0:
                    continue  # Points are collinear, cannot define circumcircle

                center_x = (d * e - b * f) / g
                center_y = (a * f - c * e) / g
                radius_sq = (x1 - center_x)**2 + (y1 - center_y)**2
                
                if (x3 - center_x)**2 + (y3 - center_y)**2 < radius_sq:  # correct point inclusion check
                  continue # k already used to form circle, skip check
                
                if (x1 - center_x)**2 + (y1 - center_y)**2 < radius_sq:  # Check condition. k can't overlap with i
                  continue
                
                if (x2 - center_x)**2 + (y2 - center_y)**2 < radius_sq: # Check condition. k can't overlap with j
                  continue

                if (x3 - center_x)**2 + (y3 - center_y)**2 < radius_sq:
                  #print(f"Point {k} inside circumcircle formed by {i}, {j}, {3}")
                  return False
                
                #print(f"no points inside circumcircle of {i}, {j}") #correct

        return True
    
    # Generate some random 2D coordinates for the nodes
    points = np.random.rand(n, 2)

    for i in range(n):
        for j in range(i + 1, n):  # Only check upper triangle
            if is_delaunay_edge(i, j, points):
                delaunay_matrix[i, j] = 1
                delaunay_matrix[j, i] = 1
    
    # Combine heuristics
    heuristics_matrix = 0.6 * mst_matrix + 0.4 * delaunay_matrix

    return heuristics_matrix
