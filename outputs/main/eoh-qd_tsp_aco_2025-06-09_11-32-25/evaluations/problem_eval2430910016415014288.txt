import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining shortest path distances with a penalty based on node degree, favoring edges connecting nodes with lower degrees.}"""
    num_nodes = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate node degrees based on inverse distances (higher proximity = higher degree)
    node_degrees = np.zeros(num_nodes)
    for i in range(num_nodes):
        for j in range(num_nodes):
            if i != j:
                node_degrees[i] += 1 / (distance_matrix[i, j] + 1e-6)  # Adding small value to avoid division by zero

    # Create the heuristic matrix
    for i in range(num_nodes):
        for j in range(num_nodes):
            if i != j:
                heuristics_matrix[i, j] = (1 / (distance_matrix[i, j] + 1e-6)) + 0.1*(1/(node_degrees[i]+node_degrees[j]+1e-6)) #combination of distance and node degree, adding small value to avoid division by zero
    return heuristics_matrix
