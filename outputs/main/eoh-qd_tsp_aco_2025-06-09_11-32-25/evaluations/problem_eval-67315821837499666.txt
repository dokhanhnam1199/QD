import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm constructs a heuristic matrix by prioritizing edges with shorter distances and penalizing edges that would create short cycles or lead to isolated nodes, achieved through iterative sampling and refinement, with adjusted parameters for exploration and exploitation.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Initialize heuristics with inverse of distance
    heuristics_matrix = 1 / (distance_matrix + 1e-6)  # Avoid division by zero

    num_samples = 50  # Reduced number of samples for faster computation
    exploration_factor = 0.5 # Increased exploration
    reward_factor = 0.2

    for _ in range(num_samples):
        # Sample a random tour using the current heuristics
        current_node = np.random.randint(n)
        tour = [current_node]
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)

        while unvisited_nodes:
            probabilities = heuristics_matrix[current_node, :]
            probabilities[list(tour)] = 0  # Avoid revisiting nodes

            # Add exploration noise
            probabilities += exploration_factor * np.random.rand(n)
            
            # Normalize probabilities
            if np.sum(probabilities) > 0:
                probabilities /= np.sum(probabilities)
            else:
                # If all probabilities are zero, choose a random unvisited node
                next_node = np.random.choice(list(unvisited_nodes))
                tour.append(next_node)
                unvisited_nodes.remove(next_node)
                current_node = next_node
                continue

            next_node = np.random.choice(n, p=probabilities)
            if next_node not in unvisited_nodes:
                # Handle case where chosen node was already visited due to numerical issues
                available_nodes = list(unvisited_nodes)
                if available_nodes:
                    next_node = np.random.choice(available_nodes)
                else:
                    break


            tour.append(next_node)
            unvisited_nodes.remove(next_node)
            current_node = next_node
            

        if len(tour) == n:
            tour.append(tour[0]) # Complete cycle
            # Update heuristics based on the tour
            for i in range(n):
                node1 = tour[i]
                node2 = tour[i+1]
                heuristics_matrix[node1, node2] += reward_factor
                heuristics_matrix[node2, node1] += reward_factor  # Ensure symmetry
            

    return heuristics_matrix
