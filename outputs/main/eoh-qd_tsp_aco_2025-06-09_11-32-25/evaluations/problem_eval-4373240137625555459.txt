import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm samples random tours, refines them using 3-opt, and aggregates edge usage frequency with a decay factor to create a heuristic matrix.}"""
  n = distance_matrix.shape[0]
  num_samples = 50  # Reduced number of samples
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  decay_factor = 0.9  # Decay factor for previous heuristic values

  def calculate_tour_length(tour):
    length = 0
    for i in range(len(tour) - 1):
      length += distance_matrix[tour[i], tour[i+1]]
    length += distance_matrix[tour[-1], tour[0]]
    return length

  def three_opt_swap(tour, i, j, k):
    """Applies the 3-opt swap between indices i, j, and k."""
    
    # Define the segments
    A = tour[:i]
    B = tour[i:j]
    C = tour[j:k]
    D = tour[k:]

    # Consider all possible 3-opt swaps (8 in total, but we only need to consider 7 since the current order is already in the tour)
    options = [
        A + B + C + D,  # Original order (not used)
        A + B + C[::-1] + D,
        A + B[::-1] + C + D,
        A + B[::-1] + C[::-1] + D,
        A + C + B + D,
        A + C + B[::-1] + D,
        A + C[::-1] + B + D,
        A + C[::-1] + B[::-1] + D
    ]

    best_tour = min(options, key=calculate_tour_length)
    return best_tour

  def three_opt(tour):
      best_tour = tour
      improved = True
      while improved:
          improved = False
          for i in range(1, n - 2):
              for j in range(i + 1, n - 1):
                  for k in range(j + 1, n):
                      new_tour = three_opt_swap(best_tour, i, j, k)
                      if calculate_tour_length(new_tour) < calculate_tour_length(best_tour):
                          best_tour = new_tour
                          improved = True
      return best_tour


  for _ in range(num_samples):
    # Generate a random tour
    tour = np.random.permutation(n)

    # Refine the tour using 3-opt
    tour = three_opt(list(tour))

    # Update the heuristics matrix based on edge usage
    for i in range(n - 1):
      heuristics_matrix[tour[i], tour[i+1]] += 1
      heuristics_matrix[tour[i+1], tour[i]] += 1
    heuristics_matrix[tour[-1], tour[0]] += 1
    heuristics_matrix[tour[0], tour[-1]] += 1

  # Normalize the heuristics matrix
  heuristics_matrix /= num_samples

  # Apply decay to previous heuristic values
  #heuristics_matrix = decay_factor * heuristics_matrix + (1 - decay_factor) * new_heuristics_matrix

  return heuristics_matrix
