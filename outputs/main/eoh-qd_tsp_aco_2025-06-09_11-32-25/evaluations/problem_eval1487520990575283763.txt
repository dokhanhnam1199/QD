import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm constructs a heuristic matrix by combining inverse distance, nearest neighbor information with varying bonus levels, and a more nuanced penalty for long edges based on distance percentiles, then normalizes it.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Inverse distance heuristic
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))  # Avoid division by zero

    # Nearest neighbor heuristic with varying bonus
    nearest_neighbors = np.argsort(distance_matrix, axis=1)
    nearest_neighbor_bonus = np.zeros((n, n))
    for i in range(n):
        for j in range(1, min(6, n)):  # Bonus for top 5 nearest neighbors
            neighbor = nearest_neighbors[i, j]
            nearest_neighbor_bonus[i, neighbor] = 1.0 / j  # Decreasing bonus for further neighbors
            
    # Penalty for long edges based on percentiles
    percentile_75 = np.percentile(distance_matrix, 75)
    percentile_90 = np.percentile(distance_matrix, 90)
    long_edge_penalty = np.zeros((n, n))
    long_edge_penalty = np.where(distance_matrix > percentile_75, -0.2, long_edge_penalty) #mild penalty for edges greater than 75%
    long_edge_penalty = np.where(distance_matrix > percentile_90, -0.7, long_edge_penalty) #strong penalty for edges greater than 90%


    # Combine heuristics
    heuristics_matrix = inverse_distance + nearest_neighbor_bonus + long_edge_penalty

    # Normalize the heuristics matrix
    min_val = np.min(heuristics_matrix)
    max_val = np.max(heuristics_matrix)
    if max_val > min_val:
        heuristics_matrix = (heuristics_matrix - min_val) / (max_val - min_val)

    return heuristics_matrix
