import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples a number of random tours, and for each edge calculates the frequency with which it appears in the shortest tours, using this frequency as a heuristic value.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    tour_lengths = np.zeros(num_samples)
    tours = np.zeros((num_samples, n), dtype=int)
    
    for i in range(num_samples):
        tour = np.random.permutation(n)
        tours[i, :] = tour
        tour_length = 0
        for j in range(n - 1):
            tour_length += distance_matrix[tour[j], tour[j+1]]
        tour_length += distance_matrix[tour[-1], tour[0]]
        tour_lengths[i] = tour_length
    
    # Select top 10% shortest tours
    cutoff = np.percentile(tour_lengths, 10)
    best_tours_indices = np.where(tour_lengths <= cutoff)[0]
    best_tours = tours[best_tours_indices, :]
    
    heuristics_matrix = np.zeros((n, n))
    for tour in best_tours:
        for i in range(n - 1):
            heuristics_matrix[tour[i], tour[i+1]] += 1
            heuristics_matrix[tour[i+1], tour[i]] += 1
        heuristics_matrix[tour[-1], tour[0]] += 1
        heuristics_matrix[tour[0], tour[-1]] += 1
    
    # Normalize
    if np.max(heuristics_matrix) > 0:
        heuristics_matrix = heuristics_matrix / np.max(heuristics_matrix)
    
    return heuristics_matrix
