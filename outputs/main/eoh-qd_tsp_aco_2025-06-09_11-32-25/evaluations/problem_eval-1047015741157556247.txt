import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines stochastic sampling with edge weighting based on tour quality, where tours are generated by iteratively adding the edge that minimizes the increase in tour length while also considering a weighted random factor based on edge frequency in previous good tours.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 100
    best_tours_fraction = 0.1
    
    tours = []
    tour_lengths = []

    for _ in range(num_samples):
        start_node = np.random.randint(n)
        tour = [start_node]
        unvisited = set(range(n))
        unvisited.remove(start_node)
        
        while unvisited:
            current_node = tour[-1]
            
            # Calculate edge weights: distance + weighted random factor
            edge_weights = {}
            for neighbor in unvisited:
                distance_increase = distance_matrix[current_node, neighbor]
                frequency_weight = -heuristics_matrix[current_node, neighbor]  # Prefer edges with higher frequency
                edge_weights[neighbor] = distance_increase + frequency_weight * np.mean(distance_matrix) #scale frequency weight

            # Stochastic selection based on combined edge weights
            probabilities = np.exp(-np.array(list(edge_weights.values())) / np.mean(distance_matrix))
            probabilities = probabilities / np.sum(probabilities)
            
            next_node = list(edge_weights.keys())[np.random.choice(len(edge_weights), p=probabilities)]

            tour.append(next_node)
            unvisited.remove(next_node)

        tour.append(start_node)
        
        # Calculate tour length
        tour_length = 0
        for i in range(n):
            tour_length += distance_matrix[tour[i], tour[i+1]]

        tours.append(tour)
        tour_lengths.append(tour_length)

    # Select the best tours
    num_best_tours = int(num_samples * best_tours_fraction)
    best_tour_indices = np.argsort(tour_lengths)[:num_best_tours]
    best_tours = [tours[i] for i in best_tour_indices]
    
    # Update heuristics matrix based on edge frequency in best tours
    for tour in best_tours:
        for i in range(n):
            u = tour[i]
            v = tour[i+1]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1

    # Normalize heuristic matrix
    heuristics_matrix = heuristics_matrix / np.sum(heuristics_matrix) if np.sum(heuristics_matrix) > 0 else heuristics_matrix
    
    return heuristics_matrix
