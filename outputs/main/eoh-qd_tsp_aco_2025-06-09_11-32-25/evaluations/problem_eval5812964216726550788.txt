import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm adaptively adjusts edge probabilities based on the frequency of edges in short tours identified by a simple greedy search, penalizing edges that consistently lead to longer tours.}
    """
    n = distance_matrix.shape[0]
    num_iterations = 500
    alpha = 0.1 
    beta = 0.2

    # Initialize heuristics matrix with inverse distance
    heuristics_matrix = 1.0 / (distance_matrix + np.eye(n))
    
    for _ in range(num_iterations):
        # Construct a tour using a simple greedy approach
        current_node = np.random.randint(n)
        tour = [current_node]
        unvisited = set(range(n))
        unvisited.remove(current_node)
        
        while unvisited:
            next_node = min(unvisited, key=lambda x: distance_matrix[current_node, x] / (heuristics_matrix[current_node, x] + 1e-9))
            tour.append(next_node)
            unvisited.remove(next_node)
            current_node = next_node
        
        tour.append(tour[0])
        
        # Calculate tour distance
        tour_distance = sum(distance_matrix[tour[i], tour[i+1]] for i in range(n))
        
        # Update heuristics based on tour distance
        if tour_distance < np.mean(distance_matrix) * n:  # If tour is relatively short
            for i in range(n):
                heuristics_matrix[tour[i], tour[i+1]] *= (1 + alpha)  # Reward edges
                heuristics_matrix[tour[i+1], tour[i]] *= (1 + alpha)
        else:
            for i in range(n):
                heuristics_matrix[tour[i], tour[i+1]] *= (1 - beta)  # Penalize edges
                heuristics_matrix[tour[i+1], tour[i]] *= (1 - beta)
    
    # Normalize the heuristics matrix
    min_val = np.min(heuristics_matrix)
    max_val = np.max(heuristics_matrix)
    if max_val > min_val:
        heuristics_matrix = (heuristics_matrix - min_val) / (max_val - min_val)
    
    return heuristics_matrix
