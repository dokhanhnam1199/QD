import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm constructs a heuristic matrix by combining inverse distance, pheromone-inspired reinforcement, and penalty for edges inconsistent with Delaunay triangulation properties, then normalizes it.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Inverse distance heuristic
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))  # Avoid division by zero

    # Pheromone-inspired reinforcement (based on short paths)
    pheromone_matrix = np.zeros((n, n))
    shortest_distances = np.min(distance_matrix, axis=1, keepdims=True)
    pheromone_matrix = np.where(distance_matrix <= shortest_distances * 1.2, 0.5, 0)  # Reward edges close to shortest distance

    # Delaunay triangulation consistency penalty (approximate)
    delaunay_penalty = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                potential_triangle_sides = distance_matrix[i, :] + distance_matrix[:, j]
                min_triangle_side_sum = np.min(potential_triangle_sides)

                if distance_matrix[i,j] > min_triangle_side_sum:
                    delaunay_penalty[i,j] = -0.3 # Penalize edges violating triangle inequality

    # Combine heuristics
    heuristics_matrix = inverse_distance + pheromone_matrix + delaunay_penalty

    # Normalize the heuristics matrix
    min_val = np.min(heuristics_matrix)
    max_val = np.max(heuristics_matrix)
    if max_val > min_val:
        heuristics_matrix = (heuristics_matrix - min_val) / (max_val - min_val)

    return heuristics_matrix
