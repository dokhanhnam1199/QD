import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm constructs a heuristic matrix using a combination of inverse distance, a clustered neighbor bonus based on community detection, and a penalty for edges longer than a dynamic threshold, then normalizes it.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Inverse distance heuristic
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))  # Avoid division by zero

    # Clustered neighbor bonus (simplified community detection proxy)
    # Find a "center" node (e.g., the one with smallest sum of distances)
    center_node = np.argmin(np.sum(distance_matrix, axis=0))
    # Identify neighbors of the center node (nodes close to the center)
    neighbors = np.argsort(distance_matrix[center_node, :])[:min(5, n)] # consider top 5 neighbors as cluster
    clustered_neighbor_bonus = np.zeros((n, n))
    for i in range(n):
        if i in neighbors:
            for j in neighbors:
                clustered_neighbor_bonus[i, j] = 0.8 # high bonus for connection between cluster nodes

    # Dynamic penalty for long edges
    dynamic_threshold = np.median(distance_matrix) + np.std(distance_matrix) #adaptive threshold
    long_edge_penalty = np.where(distance_matrix > dynamic_threshold, -0.3, 0)

    # Combine heuristics
    heuristics_matrix = inverse_distance + clustered_neighbor_bonus + long_edge_penalty

    # Normalize the heuristics matrix
    min_val = np.min(heuristics_matrix)
    max_val = np.max(heuristics_matrix)
    if max_val > min_val:
        heuristics_matrix = (heuristics_matrix - min_val) / (max_val - min_val)

    return heuristics_matrix
