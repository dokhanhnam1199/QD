import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm uses a combination of edge betweenness centrality approximation and shortest path lengths to create a heuristic matrix favoring edges on shortest paths and those connecting central nodes.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Shortest path heuristic (approximate edge betweenness)
    shortest_path_counts = np.zeros((n, n))
    for i in range(n):
        for j in range(i + 1, n):
            # Simple shortest path approximation: direct connection
            shortest_path_counts[i, j] = shortest_path_counts[j, i] = 1.0 / distance_matrix[i, j] if distance_matrix[i,j] > 0 else 0

    # Node centrality heuristic (degree centrality using inverse distance)
    node_centrality = np.sum(1.0 / (distance_matrix + np.eye(n)), axis=1)

    # Combine heuristics
    for i in range(n):
        for j in range(n):
            heuristics_matrix[i, j] = shortest_path_counts[i, j] + node_centrality[i] + node_centrality[j]

    # Normalize the heuristics matrix
    min_val = np.min(heuristics_matrix)
    max_val = np.max(heuristics_matrix)
    if max_val > min_val:
        heuristics_matrix = (heuristics_matrix - min_val) / (max_val - min_val)

    return heuristics_matrix
