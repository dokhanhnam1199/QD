import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm generates multiple random TSP solutions using nearest neighbor heuristic with random starting nodes, and uses the inverse of the edge distance weighted by the frequency of each edge appearing in these solutions as an indicator of its potential importance.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 100

    for _ in range(num_samples):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited = set(range(n))
        unvisited.remove(current_node)
        path = [current_node]

        while unvisited:
            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])
            heuristics_matrix[current_node, nearest_neighbor] += 1/distance_matrix[current_node, nearest_neighbor]
            heuristics_matrix[nearest_neighbor, current_node] += 1/distance_matrix[nearest_neighbor, current_node]
            current_node = nearest_neighbor
            path.append(current_node)
            unvisited.remove(current_node)
        
        heuristics_matrix[current_node, start_node] += 1/distance_matrix[current_node, start_node]
        heuristics_matrix[start_node, current_node] += 1/distance_matrix[start_node, current_node]

    return heuristics_matrix
