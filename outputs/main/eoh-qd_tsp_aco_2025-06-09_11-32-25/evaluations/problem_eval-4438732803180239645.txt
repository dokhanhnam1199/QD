import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple near-optimal TSP solutions using nearest neighbor with stochastic acceptance and random edge swaps, then weights edge frequencies by tour length to favor shorter tours.}"""
    n = distance_matrix.shape[0]
    num_samples = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # 1. Nearest Neighbor Initialization with Stochastic Acceptance
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited = set(range(n))
        unvisited.remove(current_node)
        tour = [current_node]
        tour_length = 0

        while unvisited:
            nearest_neighbors = sorted(unvisited, key=lambda x: distance_matrix[current_node, x])
            
            # Stochastic Acceptance:  Accept the next nearest neighbor with a probability
            # inversely proportional to the distance.  This helps to escape local optima
            accepted_node = None
            for neighbor in nearest_neighbors:
                prob = np.exp(-distance_matrix[current_node, neighbor] / 10)  #Temperature parameter is 10
                if np.random.rand() < prob:
                    accepted_node = neighbor
                    break
            if accepted_node is None:
                accepted_node = nearest_neighbors[0]

            tour_length += distance_matrix[current_node, accepted_node]
            tour.append(accepted_node)
            unvisited.remove(accepted_node)
            current_node = accepted_node
        
        tour_length += distance_matrix[tour[-1], start_node]
        tour.append(start_node)
            
        # 2. Random Edge Swaps (2-opt) - Improve Solution
        improved = True
        while improved:
            improved = False
            for i in range(1, n):
                for j in range(i + 1, n + 1):
                    if j == n:
                        new_distance = distance_matrix[tour[i-1], tour[j-1]] + distance_matrix[tour[i], tour[0]]
                        old_distance = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[j-1], tour[0]]
                    else:
                        new_distance = distance_matrix[tour[i-1], tour[j]] + distance_matrix[tour[i], tour[j-1]]
                        old_distance = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[j], tour[j-1]]

                    if new_distance < old_distance:
                        tour[i:j] = reversed(tour[i:j])
                        tour_length += (new_distance - old_distance)
                        improved = True
                        break
                if improved:
                    break
            
        # 3. Update Heuristics Matrix, weighted by tour length
        weight = 1.0 / tour_length
        for i in range(n):
            heuristics_matrix[tour[i], tour[i+1]] += weight
            heuristics_matrix[tour[i+1], tour[i]] += weight
            
    heuristics_matrix /= num_samples

    return heuristics_matrix
