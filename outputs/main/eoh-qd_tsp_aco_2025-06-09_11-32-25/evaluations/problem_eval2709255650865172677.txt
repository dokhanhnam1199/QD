import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs tours by iteratively adding the shortest edge that doesn't create cycles or exceed a growing tour length threshold, favoring edges that connect to nodes with high degree based on a density measure.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 50

    for iteration in range(num_iterations):
        tour = []
        remaining_nodes = set(range(n))
        start_node = np.random.choice(list(remaining_nodes))
        tour.append(start_node)
        remaining_nodes.remove(start_node)
        
        tour_length = 0
        max_tour_length = np.mean(distance_matrix) * (n + iteration*0.1) #allow the tour to get progressively longer

        while remaining_nodes:
            possible_edges = []
            for node1 in tour:
                for node2 in remaining_nodes:
                    possible_edges.append((node1, node2))
            
            if not possible_edges:
                break
            
            edge_distances = [(edge[0], edge[1], distance_matrix[edge[0], edge[1]]) for edge in possible_edges]
            edge_distances.sort(key=lambda x: x[2])

            edge_added = False
            for edge in edge_distances:
                node1, node2, distance = edge
                
                if tour_length + distance <= max_tour_length:
                    tour.append(node2)
                    remaining_nodes.remove(node2)
                    tour_length += distance
                    edge_added = True
                    break
            
            if not edge_added:
                break

        if len(tour) > 1:
            for i in range(len(tour)-1):
                heuristics_matrix[tour[i], tour[i+1]] +=1
                heuristics_matrix[tour[i+1], tour[i]] +=1

    return heuristics_matrix
