import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm constructs a heuristic matrix by combining edge frequency in shortest paths with a cluster-based encouragement of intra-cluster connections.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Shortest path edge frequency
    shortest_path_counts = np.zeros((n, n))
    for start_node in range(n):
        dist = np.inf * np.ones(n)
        dist[start_node] = 0
        unvisited = set(range(n))
        while unvisited:
            current_node = min(unvisited, key=lambda node: dist[node])
            if dist[current_node] == np.inf:
                break  # No path to remaining nodes
            unvisited.remove(current_node)
            for neighbor in range(n):
                if distance_matrix[current_node, neighbor] != 0:
                    new_dist = dist[current_node] + distance_matrix[current_node, neighbor]
                    if new_dist < dist[neighbor]:
                        dist[neighbor] = new_dist
    
    # Cluster-based encouragement
    from sklearn.cluster import KMeans
    kmeans = KMeans(n_clusters=int(np.sqrt(n)), random_state=0, n_init=10)
    clusters = kmeans.fit_predict(distance_matrix)
    cluster_bonus = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if clusters[i] == clusters[j]:
                cluster_bonus[i, j] = 0.5

    # Combine heuristics
    heuristics_matrix = shortest_path_counts + cluster_bonus
    
    #Normalize
    min_val = np.min(heuristics_matrix)
    max_val = np.max(heuristics_matrix)
    if max_val > min_val:
        heuristics_matrix = (heuristics_matrix - min_val) / (max_val - min_val)
        
    return heuristics_matrix
