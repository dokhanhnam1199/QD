import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs tours using a greedy approach with random restarts, and averages the inverse rank of each edge's distance in the constructed tours as a heuristic.}"""
    n = distance_matrix.shape[0]
    num_restarts = 1000
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_restarts):
        start_node = np.random.randint(n)
        unvisited_nodes = set(range(n))
        tour = [start_node]
        unvisited_nodes.remove(start_node)
        
        current_node = start_node
        while unvisited_nodes:
            nearest_node = min(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])
            tour.append(nearest_node)
            unvisited_nodes.remove(nearest_node)
            current_node = nearest_node
        
        tour.append(start_node)
        
        edge_ranks = {}
        edges = []
        for i in range(n):
            u = tour[i]
            v = tour[i+1]
            edges.append((u,v))
        
        distances = [distance_matrix[u,v] for u,v in edges]
        
        ranked_edges = sorted(range(len(distances)), key=lambda k: distances[k])
        
        for rank, index in enumerate(ranked_edges):
            u, v = edges[index]
            heuristics_matrix[u, v] += 1/(rank+1)
            heuristics_matrix[v, u] += 1/(rank+1)

    heuristics_matrix /= num_restarts
    return heuristics_matrix
