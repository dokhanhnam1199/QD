import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm samples random tours using nearest neighbor, refines them using 3-opt, and aggregates edge usage frequency to create a heuristic matrix.}"""
  n = distance_matrix.shape[0]
  num_samples = 50  # Reduced number of samples
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  def calculate_tour_length(tour):
    length = 0
    for i in range(len(tour) - 1):
      length += distance_matrix[tour[i], tour[i+1]]
    length += distance_matrix[tour[-1], tour[0]]
    return length

  def three_opt_swap(tour, i, j, k):
      """Perform a 3-opt swap."""
      a, b, c, d, e, f = tour[i:i+1], tour[i+1:j+1], tour[j+1:k+1], tour[k+1:] ,tour[:i],tour[k+1:]
      options = [
          tour[:i+1] + tour[i+1:j+1] + tour[j+1:k+1] + tour[k+1:],  # original
          tour[:i+1] + tour[j+1:k+1][::-1] + tour[i+1:j+1][::-1] + tour[k+1:],
          tour[:i+1] + tour[i+1:j+1][::-1] + tour[j+1:k+1] + tour[k+1:],
          tour[:i+1] + tour[j+1:k+1] + tour[i+1:j+1] + tour[k+1:],
          tour[:i+1] + tour[j+1:k+1][::-1] + tour[i+1:j+1] + tour[k+1:],
          tour[:i+1] + tour[i+1:j+1] + tour[j+1:k+1][::-1] + tour[k+1:],
          tour[:i+1] + tour[k+1:j:-1] + tour[j:i:-1] + tour[k+1:]

      ]
      return options

  def three_opt(tour):
    best_tour = tour
    improved = True
    while improved:
      improved = False
      for i in range(1, n - 2):
        for j in range(i + 1, n - 1):
          for k in range(j + 1, n):
            new_tours = three_opt_swap(best_tour, i, j, k)
            lengths = [calculate_tour_length(t) for t in new_tours]
            if min(lengths) < calculate_tour_length(best_tour):
              best_tour = new_tours[lengths.index(min(lengths))]
              improved = True
    return best_tour

  def nearest_neighbor_tour(start_node):
      unvisited = set(range(n))
      unvisited.remove(start_node)
      tour = [start_node]
      current_node = start_node

      while unvisited:
          nearest_node = min(unvisited, key=lambda node: distance_matrix[current_node, node])
          tour.append(nearest_node)
          unvisited.remove(nearest_node)
          current_node = nearest_node

      return tour

  for start_node in range(n): # Iterate through each node as starting node
    # Generate a nearest neighbor tour
    tour = nearest_neighbor_tour(start_node)

    # Refine the tour using 3-opt
    tour = three_opt(tour)

    # Update the heuristics matrix based on edge usage
    for i in range(n - 1):
      heuristics_matrix[tour[i], tour[i+1]] += 1
      heuristics_matrix[tour[i+1], tour[i]] += 1
    heuristics_matrix[tour[-1], tour[0]] += 1
    heuristics_matrix[tour[0], tour[-1]] += 1

  # Normalize the heuristics matrix
  heuristics_matrix /= (num_samples*n)

  return heuristics_matrix
