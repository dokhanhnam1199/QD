import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively improves tours by swapping edges based on a cost function considering distance and global connectivity.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 100
    num_initial_tours = 10

    # Generate initial random tours
    initial_tours = []
    for _ in range(num_initial_tours):
        initial_tours.append(np.random.permutation(n))

    # Iterative improvement
    for iteration in range(num_iterations):
        for tour in initial_tours:
            # Randomly select two edges to swap
            i = np.random.randint(0, n)
            j = np.random.randint(0, n)
            if i == j:
                continue
            
            a = tour[i % n]
            b = tour[(i + 1) % n]
            c = tour[j % n]
            d = tour[(j + 1) % n]

            # Calculate cost change
            cost_change = distance_matrix[a, c] + distance_matrix[b, d] - distance_matrix[a, b] - distance_matrix[c, d]

            # Swap edges if cost decreases
            if cost_change < 0:
                
                new_tour = tour.copy()
                
                start = (i + 1) % n
                end = j % n
                
                sub_array = tour[start:end+1]
                sub_array = sub_array[::-1]
                
                new_tour[start:end+1] = sub_array
                
                tour = new_tour  # Update the tour


            # Update heuristics matrix (reward good edges)
            for k in range(n - 1):
                heuristics_matrix[tour[k], tour[k+1]] += 1.0 / (iteration + 1)
                heuristics_matrix[tour[k+1], tour[k]] += 1.0 / (iteration + 1)
            heuristics_matrix[tour[-1], tour[0]] += 1.0 / (iteration + 1)
            heuristics_matrix[tour[0], tour[-1]] += 1.0 / (iteration + 1)


    return heuristics_matrix
