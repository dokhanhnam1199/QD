import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a spanning tree approach, prioritizing edges present in a minimum spanning tree and penalizing edges significantly longer than the shortest path between nodes.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Minimum Spanning Tree (MST) heuristic
    import scipy.sparse.csgraph as csgraph
    mst = csgraph.minimum_spanning_tree(distance_matrix)
    mst_matrix = mst.toarray()

    # Shortest Path Distance Penalty
    shortest_path_distances = csgraph.floyd_warshall(distance_matrix)
    penalty_factor = 2 
    long_path_penalty = np.where(distance_matrix > penalty_factor * shortest_path_distances, -0.25, 0)

    heuristics_matrix = mst_matrix + long_path_penalty

    # Normalize
    min_val = np.min(heuristics_matrix)
    max_val = np.max(heuristics_matrix)
    if max_val > min_val:
        heuristics_matrix = (heuristics_matrix - min_val) / (max_val - min_val)
    
    return heuristics_matrix
