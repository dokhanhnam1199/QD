import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach to evolve a population of tours and uses the frequency of edges in the best tours to build a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    population_size = 50
    num_generations = 50
    mutation_rate = 0.05
    
    # Initialize population
    population = [np.random.permutation(n) for _ in range(population_size)]
    
    for _ in range(num_generations):
        # Evaluate fitness (tour length)
        fitness = np.zeros(population_size)
        for i in range(population_size):
            tour = population[i]
            tour_length = 0
            for j in range(n - 1):
                tour_length += distance_matrix[tour[j], tour[j+1]]
            tour_length += distance_matrix[tour[n-1], tour[0]]
            fitness[i] = tour_length
        
        # Selection (roulette wheel selection)
        probabilities = 1 / fitness  # Invert fitness to make shorter tours have higher probability
        probabilities /= np.sum(probabilities)
        
        new_population = []
        for _ in range(population_size):
            # Select two parents
            parent1_idx = np.random.choice(population_size, p=probabilities)
            parent2_idx = np.random.choice(population_size, p=probabilities)
            parent1 = population[parent1_idx]
            parent2 = population[parent2_idx]
            
            # Crossover (ordered crossover)
            start = np.random.randint(0, n)
            length = np.random.randint(1, n - 1)
            end = (start + length) % n
            
            if start < end:
                child = parent1[start:end].tolist()
                remaining = [node for node in parent2 if node not in child]
                child = remaining[:start] + child + remaining[start:]
            else:
                child = parent1[end:start].tolist()
                remaining = [node for node in parent2 if node not in child]
                child = child + remaining[start:] + remaining[:end]

            child = np.array(child)

            # Mutation (swap mutation)
            if np.random.rand() < mutation_rate:
                idx1, idx2 = np.random.choice(n, 2, replace=False)
                child[idx1], child[idx2] = child[idx2], child[idx1]
            
            new_population.append(child)
        
        population = new_population
    
    # After evolution, evaluate the final population and select the best tours
    fitness = np.zeros(population_size)
    for i in range(population_size):
        tour = population[i]
        tour_length = 0
        for j in range(n - 1):
            tour_length += distance_matrix[tour[j], tour[j+1]]
        tour_length += distance_matrix[tour[n-1], tour[0]]
        fitness[i] = tour_length

    best_tour_indices = np.argsort(fitness)[:population_size // 5] #select top 20%
    best_tours = [population[i] for i in best_tour_indices]

    # Build heuristic matrix based on edge frequency in the best tours
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for tour in best_tours:
        for i in range(n - 1):
            u = tour[i]
            v = tour[i + 1]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1
        u = tour[n - 1]
        v = tour[0]
        heuristics_matrix[u, v] += 1
        heuristics_matrix[v, u] += 1

    return heuristics_matrix
