import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining inverse distance with a penalty based on the number of nodes between two given nodes on the shortest path, aiming to avoid long detours.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = 1.0 / (distance_matrix + np.eye(n))  # Initialize with inverse distance
    np.fill_diagonal(heuristics_matrix, 0)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Find shortest path between i and j using Dijkstra
                dist = np.full(n, np.inf)
                dist[i] = 0
                visited = np.zeros(n, dtype=bool)
                
                for _ in range(n):
                    u = -1
                    min_dist = np.inf
                    for v in range(n):
                        if not visited[v] and dist[v] < min_dist:
                            min_dist = dist[v]
                            u = v

                    if u == -1:
                        break
                    
                    visited[u] = True

                    for v in range(n):
                        if not visited[v] and distance_matrix[u, v] > 0 and dist[u] + distance_matrix[u, v] < dist[v]:
                            dist[v] = dist[u] + distance_matrix[u, v]

                shortest_path_length = dist[j]
                
                # Calculate nodes between
                
                # Implement Dijkstra's algorithm to get predecessor matrix
                prev = np.full(n, -1, dtype=int)
                dist = np.full(n, np.inf)
                dist[i] = 0
                Q = list(range(n))

                while Q:
                    u = min(Q, key=lambda x: dist[x])
                    Q.remove(u)

                    for v in range(n):
                        if distance_matrix[u, v] > 0 and dist[u] + distance_matrix[u, v] < dist[v]:
                            dist[v] = dist[u] + distance_matrix[u, v]
                            prev[v] = u
                            
                # Reconstruct the shortest path
                path = []
                current = j
                while current != -1:
                    path.insert(0, current)
                    current = prev[current]

                # Count nodes between
                nodes_between = len(path) - 2

                # Penalize based on the number of nodes between i and j
                penalty = nodes_between * 0.01
                heuristics_matrix[i, j] -= penalty
                heuristics_matrix[j, i] -= penalty

    return heuristics_matrix
