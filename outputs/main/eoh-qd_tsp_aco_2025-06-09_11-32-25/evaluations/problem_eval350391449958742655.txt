import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm samples random tours, refines them using 2-opt, and aggregates edge usage frequency to create a heuristic matrix.}"""
  n = distance_matrix.shape[0]
  num_samples = 100  # Number of random tours to generate
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  def calculate_tour_length(tour):
    length = 0
    for i in range(len(tour) - 1):
      length += distance_matrix[tour[i], tour[i+1]]
    length += distance_matrix[tour[-1], tour[0]]
    return length

  def two_opt_swap(tour, i, k):
    new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]
    return new_tour

  def two_opt(tour):
    best_tour = tour
    improved = True
    while improved:
      improved = False
      for i in range(1, n - 1):
        for k in range(i + 1, n):
          new_tour = two_opt_swap(best_tour, i, k)
          if calculate_tour_length(new_tour) < calculate_tour_length(best_tour):
            best_tour = new_tour
            improved = True
    return best_tour

  for _ in range(num_samples):
    # Generate a random tour
    tour = np.random.permutation(n)

    # Refine the tour using 2-opt
    tour = two_opt(list(tour))

    # Update the heuristics matrix based on edge usage
    for i in range(n - 1):
      heuristics_matrix[tour[i], tour[i+1]] += 1
      heuristics_matrix[tour[i+1], tour[i]] += 1
    heuristics_matrix[tour[-1], tour[0]] += 1
    heuristics_matrix[tour[0], tour[-1]] += 1
      
  # Normalize the heuristics matrix
  heuristics_matrix /= num_samples

  return heuristics_matrix
