import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach, iteratively improving a population of tours by selection, crossover, and mutation based on tour length.}"""
    n = distance_matrix.shape[0]
    population_size = 50
    num_generations = 500
    mutation_rate = 0.01

    # Initialize population
    population = [np.random.permutation(n) for _ in range(population_size)]

    def calculate_tour_length(tour):
        length = 0
        for i in range(n - 1):
            length += distance_matrix[tour[i], tour[i+1]]
        length += distance_matrix[tour[-1], tour[0]]
        return length

    def selection(population):
        tour_lengths = [calculate_tour_length(tour) for tour in population]
        # Fitness proportional selection (roulette wheel)
        fitness = np.max(tour_lengths) - np.array(tour_lengths) + 1e-9  # Add small value to avoid division by zero
        probabilities = fitness / np.sum(fitness)
        indices = np.random.choice(population_size, size=population_size, replace=True, p=probabilities)
        selected_population = [population[i] for i in indices]
        return selected_population

    def crossover(parent1, parent2):
        # Order Crossover (OX1)
        start = np.random.randint(0, n)
        length = np.random.randint(1, n - 1)
        end = (start + length) % n

        if start < end:
            child = np.zeros(n, dtype=int) - 1
            child[start:end] = parent1[start:end]
            
            ptr = 0
            for gene in parent2:
                if gene not in child:
                    while child[ptr] != -1:
                        ptr = (ptr + 1) % n
                    child[ptr] = gene
        else:
            child = np.zeros(n, dtype=int) - 1
            child[start:] = parent1[start:]
            child[:end] = parent1[:end]

            ptr = 0
            for gene in parent2:
                if gene not in child:
                    while child[ptr] != -1:
                        ptr = (ptr + 1) % n
                    child[ptr] = gene
        return child

    def mutate(tour):
        # Swap mutation
        if np.random.rand() < mutation_rate:
            i, j = np.random.choice(n, 2, replace=False)
            tour[i], tour[j] = tour[j], tour[i]
        return tour
    
    # Main genetic algorithm loop
    for _ in range(num_generations):
        selected_population = selection(population)
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_population[i]
            parent2 = selected_population[i+1] if i+1 < population_size else selected_population[0]
            child1 = crossover(parent1, parent2)
            child2 = crossover(parent2, parent1)
            new_population.append(mutate(child1))
            new_population.append(mutate(child2))
        population = new_population
    
    # Heuristics matrix based on best tour from final population
    best_tour = min(population, key=calculate_tour_length)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n - 1):
        heuristics_matrix[best_tour[i], best_tour[i+1]] = 1
        heuristics_matrix[best_tour[i+1], best_tour[i]] = 1
    heuristics_matrix[best_tour[-1], best_tour[0]] = 1
    heuristics_matrix[best_tour[0], best_tour[-1]] = 1

    return heuristics_matrix
