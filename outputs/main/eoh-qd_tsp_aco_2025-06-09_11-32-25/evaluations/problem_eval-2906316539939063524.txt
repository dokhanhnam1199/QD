import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm generates multiple random tours, selects a subset of the best tours, and then uses the exponential of the negative tour length to weight the edges present in those tours to generate a heuristic matrix.}"""
  n = distance_matrix.shape[0]
  num_tours = 100
  
  tours = []
  tour_lengths = []
  
  for _ in range(num_tours):
    # Generate a random tour
    tour = np.random.permutation(n)
    
    # Calculate the tour length
    tour_length = 0
    for i in range(n - 1):
      tour_length += distance_matrix[tour[i], tour[i+1]]
    tour_length += distance_matrix[tour[n-1], tour[0]]
    
    tours.append(tour)
    tour_lengths.append(tour_length)
  
  # Create a heuristic matrix
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  
  for tour, tour_length in zip(tours, tour_lengths):
    weight = np.exp(-tour_length)
    for i in range(n - 1):
      u = tour[i]
      v = tour[i+1]
      heuristics_matrix[u, v] += weight
      heuristics_matrix[v, u] += weight
    u = tour[n-1]
    v = tour[0]
    heuristics_matrix[u, v] += weight
    heuristics_matrix[v, u] += weight
  
  return heuristics_matrix
