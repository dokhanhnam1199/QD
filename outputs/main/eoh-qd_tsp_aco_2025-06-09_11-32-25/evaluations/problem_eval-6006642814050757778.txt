import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines edge frequency in k-nearest neighbor tours with a cost-benefit analysis based on distance and overall graph density to create a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    k = min(5, n - 1)  # Consider k-nearest neighbors

    for i in range(n):
        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k+1] # Exclude self

        for neighbor in nearest_neighbors:
            # Edge Frequency based on k-NN tours:
            heuristics_matrix[i, neighbor] += 1
            heuristics_matrix[neighbor, i] += 1

    # Cost-Benefit Analysis based on distance and graph density
    mean_distance = np.mean(distance_matrix)
    for i in range(n):
      for j in range(i + 1, n):
        distance = distance_matrix[i, j]
        # Benefit: higher if edge connects disparate parts of the graph
        benefit = np.exp(-np.std(distance_matrix[i,:] + distance_matrix[j,:]))
        # Cost: higher if edge is long relative to average
        cost = distance / mean_distance

        heuristics_matrix[i, j] += benefit / (cost + 1e-9) # Adding small number to avoid division by zero
        heuristics_matrix[j, i] += benefit / (cost + 1e-9)

    # Normalize the heuristics matrix
    min_val = np.min(heuristics_matrix)
    max_val = np.max(heuristics_matrix)
    if max_val > min_val:
        heuristics_matrix = (heuristics_matrix - min_val) / (max_val - min_val)

    return heuristics_matrix
