import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach to evolve a population of tours and creates a heuristic matrix based on the edges present in the best evolved tours.}"""
    n = distance_matrix.shape[0]
    population_size = 50
    num_generations = 50
    mutation_rate = 0.05
    
    # Initialize population with random tours
    population = [np.random.permutation(n) for _ in range(population_size)]
    
    for _ in range(num_generations):
        # Evaluate fitness of each tour (tour length)
        fitness = np.zeros(population_size)
        for i in range(population_size):
            tour = population[i]
            tour_length = 0
            for j in range(n - 1):
                tour_length += distance_matrix[tour[j], tour[j+1]]
            tour_length += distance_matrix[tour[-1], tour[0]]
            fitness[i] = tour_length

        # Selection (roulette wheel selection)
        probabilities = 1 / fitness  # Invert fitness to make shorter tours have higher probability
        probabilities /= np.sum(probabilities)
        selected_indices = np.random.choice(population_size, size=population_size, replace=True, p=probabilities)
        selected_population = [population[i] for i in selected_indices]

        # Crossover (order crossover)
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_population[i]
            parent2 = selected_population[(i + 1) % population_size]  # Ensure even number of parents

            start = np.random.randint(0, n)
            length = np.random.randint(1, n - 1)
            end = (start + length) % n
            
            if start < end:
                child1_segment = parent1[start:end]
                child2_segment = parent2[start:end]
            else:
                child1_segment = np.concatenate((parent1[start:], parent1[:end]))
                child2_segment = np.concatenate((parent2[start:], parent2[:end]))

            child1 = np.zeros(n, dtype=int)
            child2 = np.zeros(n, dtype=int)

            child1[start:end] = child1_segment
            child2[start:end] = child2_segment
            
            child1_idx = end
            child2_idx = end
            
            parent2_idx = end
            parent1_idx = end

            while 0 in child1:
                val = parent2[parent2_idx % n]
                if val not in child1_segment:
                    child1[child1_idx % n] = val
                    child1_idx +=1
                parent2_idx += 1
            while 0 in child2:
                val = parent1[parent1_idx % n]
                if val not in child2_segment:
                    child2[child2_idx % n] = val
                    child2_idx +=1
                parent1_idx += 1
            new_population.append(child1)
            new_population.append(child2)

        # Mutation (swap mutation)
        for i in range(population_size):
            if np.random.rand() < mutation_rate:
                idx1 = np.random.randint(0, n)
                idx2 = np.random.randint(0, n)
                new_population[i][idx1], new_population[i][idx2] = new_population[i][idx2], new_population[i][idx1]

        population = new_population

    # After evolution, create heuristic matrix based on best tour
    best_tour_idx = np.argmin(fitness)
    best_tour = population[best_tour_idx]
    
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    for i in range(n - 1):
        heuristics_matrix[best_tour[i], best_tour[i+1]] = 1
        heuristics_matrix[best_tour[i+1], best_tour[i]] = 1
    heuristics_matrix[best_tour[-1], best_tour[0]] = 1
    heuristics_matrix[best_tour[0], best_tour[-1]] = 1

    return heuristics_matrix
