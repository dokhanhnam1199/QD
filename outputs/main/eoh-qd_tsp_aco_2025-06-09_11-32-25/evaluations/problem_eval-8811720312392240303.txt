import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach to evolve a population of tours, selecting the best tours at each generation and using their edges to update a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    population_size = 100
    num_generations = 50
    mutation_rate = 0.01
    
    # Initialize population
    population = [np.random.permutation(n) for _ in range(population_size)]
    
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    for generation in range(num_generations):
        # Calculate fitness (tour length) for each tour
        fitness = np.zeros(population_size)
        for i in range(population_size):
            tour = population[i]
            tour_length = 0
            for j in range(n - 1):
                tour_length += distance_matrix[tour[j], tour[j+1]]
            tour_length += distance_matrix[tour[-1], tour[0]]
            fitness[i] = tour_length
        
        # Selection (select the best tours based on fitness)
        selected_indices = np.argsort(fitness)[:population_size // 2] #Select top 50% best solution
        selected_tours = [population[i] for i in selected_indices]
        
        # Update heuristics matrix based on selected tours
        for tour in selected_tours:
            for i in range(n - 1):
                heuristics_matrix[tour[i], tour[i+1]] += 1
                heuristics_matrix[tour[i+1], tour[i]] += 1
            heuristics_matrix[tour[-1], tour[0]] += 1
            heuristics_matrix[tour[0], tour[-1]] += 1
        
        # Crossover and Mutation (create new population)
        new_population = selected_tours.copy() #Elitism: keep the best ones
        while len(new_population) < population_size:
            # Choose two parents randomly from selected tours
            parent1 = selected_tours[np.random.randint(len(selected_tours))]
            parent2 = selected_tours[np.random.randint(len(selected_tours))]
            
            # Crossover (e.g., ordered crossover)
            start = np.random.randint(n)
            length = np.random.randint(1, n - 1)
            child = np.zeros(n, dtype=int) - 1
            
            # Copy segment from parent1
            for i in range(length):
                child[(start + i) % n] = parent1[(start + i) % n]
            
            # Fill in remaining cities from parent2, avoiding duplicates
            parent2_idx = 0
            child_idx = 0
            while child_idx < n:
                if child[child_idx] == -1:
                    city = parent2[parent2_idx]
                    while city in child:
                        parent2_idx = (parent2_idx + 1) % n
                        city = parent2[parent2_idx]
                    child[child_idx] = city
                    parent2_idx = (parent2_idx + 1) % n
                child_idx += 1
            
            # Mutation
            for i in range(n):
                if np.random.rand() < mutation_rate:
                    j = np.random.randint(n)
                    child[i], child[j] = child[j], child[i]
            
            new_population.append(child)
        
        population = new_population[:population_size] #Truncate to avoid list explosion if something goes wrong

    return heuristics_matrix
