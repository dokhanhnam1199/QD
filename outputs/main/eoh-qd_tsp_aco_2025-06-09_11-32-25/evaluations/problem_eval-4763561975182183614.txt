import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm constructs a heuristic matrix based on the inverse of the distance matrix, enhanced by considering node connectivity based on short paths.}"""
  n = distance_matrix.shape[0]
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  # Initialize the heuristic matrix with the inverse of distances
  for i in range(n):
    for j in range(n):
      if i != j:
        heuristics_matrix[i, j] = 1.0 / distance_matrix[i, j]
      else:
        heuristics_matrix[i, j] = 0.0

  # Enhance the heuristic matrix by considering node connectivity based on short paths
  for i in range(n):
    for j in range(n):
      if i != j:
        # Find neighbors with short paths to node i and node j
        neighbors_i = np.argsort(distance_matrix[i, :])[1:6]  # Top 5 neighbors (excluding itself)
        neighbors_j = np.argsort(distance_matrix[j, :])[1:6]  # Top 5 neighbors (excluding itself)

        # Check if any neighbors of i are also neighbors of j
        common_neighbors = np.intersect1d(neighbors_i, neighbors_j)

        # If there are common neighbors, increase the heuristic value
        if len(common_neighbors) > 0:
          heuristics_matrix[i, j] += 0.5 * len(common_neighbors)

  return heuristics_matrix
