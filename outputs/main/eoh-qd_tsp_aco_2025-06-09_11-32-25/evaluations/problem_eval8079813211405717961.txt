import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm generates multiple random tours, selects a subset of the best tours, and then averages the inverse of the distances of the edges present in those tours to generate a heuristic matrix favoring edges frequently present in good tours.}"""
  n = distance_matrix.shape[0]
  num_tours = 100
  best_tours_fraction = 0.1
  
  tours = []
  tour_lengths = []
  
  for _ in range(num_tours):
    # Generate a random tour
    tour = np.random.permutation(n)
    
    # Calculate the tour length
    tour_length = 0
    for i in range(n - 1):
      tour_length += distance_matrix[tour[i], tour[i+1]]
    tour_length += distance_matrix[tour[n-1], tour[0]]
    
    tours.append(tour)
    tour_lengths.append(tour_length)
  
  # Select the best tours
  num_best_tours = int(num_tours * best_tours_fraction)
  best_tour_indices = np.argsort(tour_lengths)[:num_best_tours]
  best_tours = [tours[i] for i in best_tour_indices]
  
  # Create a heuristic matrix
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  
  for tour in best_tours:
    for i in range(n - 1):
      u = tour[i]
      v = tour[i+1]
      heuristics_matrix[u, v] += 1.0 / distance_matrix[u, v] if distance_matrix[u, v] > 0 else 0
      heuristics_matrix[v, u] += 1.0 / distance_matrix[v, u] if distance_matrix[v, u] > 0 else 0
    u = tour[n-1]
    v = tour[0]
    heuristics_matrix[u, v] += 1.0 / distance_matrix[u, v] if distance_matrix[u, v] > 0 else 0
    heuristics_matrix[v, u] += 1.0 / distance_matrix[v, u] if distance_matrix[v, u] > 0 else 0
  
  # Normalize the heuristic matrix
  return heuristics_matrix
