{
     "algorithm": "This algorithm samples random tours, refines them using 2-opt, and aggregates edge usage frequency to create a heuristic matrix.",
     "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm samples random tours, refines them using 2-opt, and aggregates edge usage frequency to create a heuristic matrix.}\"\"\"\n  n = distance_matrix.shape[0]\n  num_samples = 100  # Number of random tours to generate\n  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n  def calculate_tour_length(tour):\n    length = 0\n    for i in range(len(tour) - 1):\n      length += distance_matrix[tour[i], tour[i+1]]\n    length += distance_matrix[tour[-1], tour[0]]\n    return length\n\n  def two_opt_swap(tour, i, k):\n    new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]\n    return new_tour\n\n  def two_opt(tour):\n    best_tour = tour\n    improved = True\n    while improved:\n      improved = False\n      for i in range(1, n - 1):\n        for k in range(i + 1, n):\n          new_tour = two_opt_swap(best_tour, i, k)\n          if calculate_tour_length(new_tour) < calculate_tour_length(best_tour):\n            best_tour = new_tour\n            improved = True\n    return best_tour\n\n  for _ in range(num_samples):\n    # Generate a random tour\n    tour = np.random.permutation(n)\n\n    # Refine the tour using 2-opt\n    tour = two_opt(list(tour))\n\n    # Update the heuristics matrix based on edge usage\n    for i in range(n - 1):\n      heuristics_matrix[tour[i], tour[i+1]] += 1\n      heuristics_matrix[tour[i+1], tour[i]] += 1\n    heuristics_matrix[tour[-1], tour[0]] += 1\n    heuristics_matrix[tour[0], tour[-1]] += 1\n      \n  # Normalize the heuristics matrix\n  heuristics_matrix /= num_samples\n\n  return heuristics_matrix",
     "objective": 5.79349,
     "other_inf": null,
     "SLOC": 35.0,
     "cyclomatic_complexity": 3.0,
     "halstead": 322.0227601751469
}