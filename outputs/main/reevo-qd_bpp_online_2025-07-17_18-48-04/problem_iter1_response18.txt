```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # 1. Feasibility check: Bin must have enough capacity.
    feasible_bins = bins_remain_cap >= item
    
    # 2. Calculate remaining capacity AFTER adding the item to feasible bins.
    remaining_capacities = bins_remain_cap - item
    remaining_capacities[~feasible_bins] = -1  # Mark infeasible bins

    # 3. Prioritize bins based on how FULL they will be AFTER placing the item.
    #    Bins closer to being full get higher priority.  We want to fill bins,
    #    but also avoid bins becoming *too* full.  So we'll use a non-linear scaling.
    # We only assign priorities to feasible bins.
    
    fill_ratios = (bins_remain_cap[feasible_bins] - remaining_capacities[feasible_bins]) / bins_remain_cap[feasible_bins]  #How much of bin will be full
    
    priorities[feasible_bins] = fill_ratios ** 2  #Prioritize fuller bins more.  Squared to emphasize filling.

    # 4. Add a small bonus to bins that are close to full to encourage packing. Avoid leaving tiny fragments.
    close_to_full = np.logical_and(feasible_bins, remaining_capacities >= 0) # bins remaining capacities that are more than zero.
    
    near_full_threshold = 0.1 * np.mean(bins_remain_cap[feasible_bins]) if np.sum(feasible_bins) > 0 else 0.1 * np.mean(bins_remain_cap) if bins_remain_cap.size > 0 else 0 # dynamic threshold, prevents hardcoding.
    close_to_full_mask = np.logical_and(close_to_full, remaining_capacities <= near_full_threshold)
    
    priorities[close_to_full_mask] += 0.5  # Give these bins a boost
    

    return priorities
```
