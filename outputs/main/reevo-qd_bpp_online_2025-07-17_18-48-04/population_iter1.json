[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: High priority for bins that can accommodate the item.\n    can_accommodate = bins_remain_cap >= item\n    priorities[can_accommodate] += 1  # Basic reward for fitting.\n\n    # Rule 2: Prioritize bins with less remaining capacity if the item fits\n    # to reduce fragmentation\n    remaining_space = bins_remain_cap - item\n    priorities[can_accommodate] += (1 / (remaining_space[can_accommodate] + 0.0001))  # avoid division by zero. smaller remaining space -> higher priority.\n\n    # Rule 3: Penalize bins where the item doesn't fit (set to -inf), \n    # this might not be necessary as we will choose the highest score.\n    priorities[~can_accommodate] = -np.inf\n\n    # Rule 4: Give a small bonus for almost full bins before adding the item, to push for completion.\n    almost_full = (bins_remain_cap > item) & (bins_remain_cap < (item * 1.2)) #item + 20%\n    priorities[almost_full] += 0.5  # Moderate encouragement for filling bins nearing capacity\n    \n    # Rule 5: Slight randomization to break ties and explore more possibilities (optional)\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.01\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.028719585161557,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Very large remaining capacity = very low priority. Bins with very little remaining capacity are favored.\n    priorities = 1 / (bins_remain_cap + 1e-9)  # Avoid division by zero\n    \n    # Add a bonus if the item fits and doesn't leave too much space\n    fit_indices = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap[fit_indices] - item\n    priorities[fit_indices] += (item / (remaining_after_fit + item)) #item / (remaining_capacity + item)\n\n    #If the item is very big and fills almost the whole bin, it also has an advantage.\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = cap - item\n            # Prioritize bins where the item fits and minimize remaining waste\n            priorities[i] = (1 / (waste + 0.0001))  # Avoid division by zero and prioritize smaller waste\n            # Also, prioritize bins where remaining cap is closer to a useful size.\n            priorities[i] += np.exp(-abs(waste - item)/ (item + 0.0001))\n\n        else:\n            # Negative priority for bins that can't fit the item\n            priorities[i] = -1000  # A large negative value to discourage selection\n    return priorities",
    "response_id": 2,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997097999949 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Big enough bins have positive priority, others negative\n    fit_mask = bins_remain_cap >= item\n    \n    # Prioritize almost full bins\n    almost_full_mask = (bins_remain_cap >= item) & (bins_remain_cap <= 2 * item)\n    priorities[almost_full_mask] = 2 - bins_remain_cap[almost_full_mask] / item\n    \n    # Prioritize well-fitting bins that are not very full\n    well_fitting_mask = (bins_remain_cap >= item) & (bins_remain_cap > 2 * item)\n    priorities[well_fitting_mask] = (bins_remain_cap[well_fitting_mask] - item) / np.max(bins_remain_cap)\n    \n    # Assign negative priority to bins which cannot fit the item\n    priorities[~fit_mask] = -1\n    \n    return priorities",
    "response_id": 3,
    "obj": 26.8448344635022,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a high priority to bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1\n\n    # Prioritize bins with smallest remaining capacity that can fit the item.\n    # This encourages filling bins rather than leaving many bins partially full.\n    feasible_caps = bins_remain_cap[can_fit]\n    if len(feasible_caps) > 0:\n        priorities[can_fit] += (np.max(feasible_caps) - feasible_caps) / np.max(feasible_caps)\n\n    # Penalize bins where the item almost doesn't fit. This tries to avoid creating very small remaining spaces.\n    almost_fits = (bins_remain_cap > 0.9 * item) & (bins_remain_cap < item)\n    priorities[almost_fits] -= 0.5  # Reduced penalty compared to not fitting\n\n    #Give slight advantages to bins where the remaining capacity is close to standard deviation.\n    deviation = np.abs(bins_remain_cap-np.mean(bins_remain_cap))\n    priorities[can_fit] += np.exp(-deviation[can_fit])\n    \n    return priorities",
    "response_id": 4,
    "obj": 9.114479457518957,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Basic score based on remaining capacity after adding the item\n            remaining_after_add = cap - item\n            priorities[i] = 1 / (remaining_after_add + 0.00001)  # Avoid division by zero, prefer bins with tighter fit.\n\n            # Bonus if item fills a significant portion of the bin, prefer to completely fill bins\n            fill_ratio = item / cap\n            if fill_ratio > 0.75:\n                priorities[i] += 2 # large bonus for nearly full\n            elif fill_ratio > 0.5:\n                priorities[i] += 1  # medium bonus\n\n            # Small bonus to bins that are already partially full.\n            if cap < 1.0:  #Assuming bin capacity is 1, adjust as needed\n              priorities[i] += 0.5 # favour bins that are non-empty\n        else:\n            priorities[i] = -np.inf  # Cannot fit, so lowest priority\n    return priorities",
    "response_id": 5,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996852000004 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Reward bins where the item fits\n            remaining_space = cap - item\n            priorities[i] = (item / cap)  # Fill ratio, higher is better (fill as much as possible)\n            priorities[i] += (1 / (remaining_space + 1e-9)) # Penalize too much remaining space\n            priorities[i] += 1 # base reward\n\n    return priorities",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999966729001244 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Eliminate bins that cannot fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Very low priority\n\n    # 2. First Fit Decreasing (FFD) inspired: Prioritize bins with smallest remaining capacity that can still fit the item.\n    # This tries to fill up bins as much as possible before opening new ones.\n    feasible_mask = bins_remain_cap >= item\n    remaining_capacities = bins_remain_cap[feasible_mask]\n    \n    if len(remaining_capacities) > 0:\n        priorities[feasible_mask] = -remaining_capacities #Give negative priority to bins with small capacity\n\n        #3. Penalize waste (e.g., items barely fitting.) Reward bins with good fit.\n        waste = bins_remain_cap[feasible_mask] - item\n        waste_penalty = waste / item # ratio of remaining capacity / item_size\n        priorities[feasible_mask] += -0.1 * waste_penalty  # Adjust strength as needed.\n\n        # 4. Give small incentive to use the most empty bins.\n        max_cap = np.max(bins_remain_cap)\n        priorities += 0.001 * bins_remain_cap / max_cap\n    \n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First-Fit-Decreasing Inspired: Prioritize bins that can fit the item almost perfectly\n    # to reduce fragmentation.\n    \n    # Give a base score based on whether the item fits.  Bins that don't fit get -inf\n    fits = item <= bins_remain_cap\n    priorities[~fits] = -np.inf\n    \n    # Calculate wasted space if the item is placed in the bin\n    wasted_space = bins_remain_cap - item\n    \n    # Prioritize bins with minimal wasted space (avoid excessive fragmentation)\n    # Avoid division by zero by adding a small constant.\n    priorities[fits] = 1.0 / (wasted_space[fits] + 0.0001)  # Higher priority for less waste\n\n    # Add a bonus if the remaining capacity is close to a common fraction or a power of 2.\n    # common_fractions = [0.25, 0.5, 0.75]  # Consider using item size as the base instead.\n    \n    # capacity_ratios = bins_remain_cap / item  # bins_remain_cap is likely bigger than item\n\n    # prioritzing the perfect match\n    perfect_match = wasted_space == 0.0\n    priorities[perfect_match] = np.inf # Highest Priority\n\n    # Add a bonus if the remaining capacity is close to the item size\n    close_to_item = np.isclose(bins_remain_cap, item, rtol=0.1)\n    priorities[close_to_item] += 10 # Arbitrary bonus for closeness to the item\n\n    # Randomly break ties to explore different solutions. Add small random value\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.001 # Small random bonus for each bin\n\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n        return priorities  # All priorities are zero if no bin can fit\n\n    # 2. Remaining Capacity: Prefer bins with smaller remaining capacity after placing the item.\n    remaining_capacity_after_placement = bins_remain_cap - item\n    \n    # Scale to avoid zero division and give higher priority to lower remaining capacity after placement for bins that *can* hold the item\n    \n    priorities[feasible_bins] = 1 / (remaining_capacity_after_placement[feasible_bins] + 0.0001)\n    \n\n    #3. Bonus for almost full bins: Bins that become almost full get a boost.\n    almost_full_threshold = 0.1  # Define \"almost full\" as remaining capacity <= 10% of bin size. Assuming all bins have size 1\n    almost_full = remaining_capacity_after_placement <= almost_full_threshold\n\n    priorities[almost_full & feasible_bins] += 10 # add a high value bonus\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate waste if the item is placed in this bin.\n            waste = cap - item\n            # Prioritize bins that minimize waste but also avoid extremely small waste.\n            # Adding a small epsilon to avoid division by zero\n            priorities[i] = (item / cap) * (1 / (waste + 0.01))\n\n            # Penalize bins with very high remaining capacity (encourage filling partially used bins first)\n            priorities[i] *= (1 - (cap / np.max(bins_remain_cap))) if np.max(bins_remain_cap) > 0 else 1.0\n\n            # Give a small bonus to bins that have been used before (helps consolidation). This only matters if there is any item inside a bin.\n            if cap < np.max(bins_remain_cap):  # If the bin is not empty, boost the priority a bit.\n                priorities[i] += 0.1\n        else:\n            priorities[i] = -np.inf  # Cannot fit, so lowest priority.\n\n    return priorities",
    "response_id": 10,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997021999843 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Initialize with a low default priority\n    priorities[:] = -1.0\n    \n    # Calculate remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign high priority to bins that can fit the item\n    mask = remaining_capacities >= 0\n    priorities[mask] = 1.0\n\n    # Further differentiate based on how well the item fits.\n    # Bins that have closer remaining capacity to zero after adding the item should have even higher priority\n    priorities[mask] += 1.0 - (remaining_capacities[mask] / bins_remain_cap[mask])  # Normalize the remaining capacity\n    \n    # Give preference to bins with largest empty spaces after accommodating item if they fit\n    priorities[mask] += (bins_remain_cap[mask] - item) / bins_remain_cap.max() # using max bin cap as denominator to avoid high values.\n\n    # Handle bins that cannot fit: add a negative priority inversely proportional to their remaining capacity if we force to put it anyway, this way, it will select bins where item will have a minimum volume exceeding bin capacity. It tries to avoid big capacity overflow on bins. Not useful for standard bin packing. Kept only for some sort of adaptation\n    mask_not_fit = remaining_capacities < 0\n    priorities[mask_not_fit] = remaining_capacities[mask_not_fit] / bins_remain_cap.max()\n        \n    return priorities",
    "response_id": 11,
    "obj": 86.58755484643,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf  # Very low priority for infeasible bins\n\n    # 2. Remaining Capacity Utilization: Prefer bins with tighter fit\n    remaining_after_fit = bins_remain_cap - item\n    priorities[feasible_bins] = 1 / (remaining_after_fit[feasible_bins] + 1e-9)  # Avoid division by zero, prioritize smaller remaining capacity\n\n    # 3. Bonus for almost full bins to fill them up\n    almost_full = (bins_remain_cap > item) & (bins_remain_cap <= 2 * item)  # Check bins remaining capacity is slightly more than item size\n    priorities[almost_full] += 10  # Give these bins a boost, higher than other priority score\n\n    # 4. Add some randomness\n    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.1 # Small random number to introduce randomness\n\n    return priorities",
    "response_id": 12,
    "obj": 3.8591942560829726,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Reward bins that can fit the item\n            priorities[i] = (cap - item) / cap  # Remaining space ratio (smaller is better, so negative)\n            priorities[i] += 1 # Add a base value to make it positive and more influential. This gives preference to bins that can accommodate the item.\n\n            # Slightly penalize bins that are too large to avoid fragmentation\n            if cap > 2 * item:\n                priorities[i] -= 0.1 * (cap - 2 * item) / cap\n\n        else:\n            # Large negative priority if item doesn't fit\n            priorities[i] = -1000 # Extremely low priority\n    return priorities",
    "response_id": 13,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First-Fit-Decreasing Inspired: Prioritize bins that can fit the item, sorted by remaining capacity\n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        priorities[can_fit] = bins_remain_cap[can_fit]  # Prioritize higher remaining capacity\n        \n        # A little bit of noise to break ties.\n        priorities[can_fit] += np.random.rand(np.sum(can_fit)) * 0.0001\n\n    else:\n        # If no bin can fit, penalize bins close to fitting the item to avoid fragmentation\n        diff = item - bins_remain_cap\n        priorities = -diff # Higher the negative diff, more closer we are, hence a larger score\n    \n    return priorities",
    "response_id": 14,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility check: Bins that cannot accommodate the item get a very low priority.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # 2. Best Fit heuristic: Prefer bins with smallest remaining capacity AFTER adding the item.\n    # Only consider bins that *can* accommodate the item.\n\n    feasible_mask = ~infeasible_mask\n    remaining_after_fit = bins_remain_cap[feasible_mask] - item\n    \n    #Give bins filled closer to the cap a higher score\n    priorities[feasible_mask] = -np.abs(remaining_after_fit)\n\n\n    #3. Give a boost to almost-full bins. If we are very close to using the remaining space in a bin, fill it up.\n    almost_full_threshold = 0.1  #tune this. 10% remaining capacity. This encourages early bin closures\n    almost_full_mask = feasible_mask & (remaining_after_fit <= almost_full_threshold * bins_remain_cap[feasible_mask])\n    priorities[almost_full_mask] += 10  # add to base priority from -abs(remaining_after_fit) so bins marked here have preference, tune boost.\n\n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Initialize very low priority for bins that cannot fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # For bins that can fit, prioritize based on remaining capacity\n    # 1. Fill Rate: How much of the bin's capacity will be filled by the item.  Higher is generally better (more utilization)\n    fill_rates = item / bins_remain_cap\n    priorities[bins_remain_cap >= item] += fill_rates[bins_remain_cap >= item]\n\n    # 2. Avoid Too Much Waste: Penalize bins where the item fits but leaves a significant amount of empty space,\n    # because small remaining spaces are harder to fill later.  Introduce a parameter 'waste_threshold'\n    waste = bins_remain_cap - item\n    waste_threshold = np.mean(bins_remain_cap) / 2 # dynamic threshold\n\n    priorities[(bins_remain_cap >= item) & (waste > waste_threshold)] -= 0.5 # slight penalty for high waste\n\n\n    # 3. Smallest Waste: Prioritize bins that result in the smallest waste after adding item\n    # Apply this only to bins with capacities closer to item's size to focus packing efforts.\n    distance = np.abs(bins_remain_cap - item)\n    priorities[bins_remain_cap >= item] -=  distance[bins_remain_cap >= item] / np.max(bins_remain_cap)\n    \n    # 4. Prioritize nearly full bins before new bins, promote filling existing containers.\n    nearly_full = (bins_remain_cap >= item) & (bins_remain_cap < 1.5 * item) #check if after placing the new item bin will become nearly full.\n    priorities[nearly_full] += 0.75\n    \n\n    return priorities",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: Bins that can't fit the item get a very low priority\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Rule 2: For bins that *can* fit, prioritize bins with tighter fit \n    # (but not too tight, to avoid fragmentation). Use a quadratic function\n    # to favor bins closer to the item size but penalize those that are too close (small remaining space)\n    \n    valid_bins = bins_remain_cap >= item\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    # Use a function that peaks near zero and falls off as we move away. A parabola could work,\n    # centered around zero.  Also, penalize small remaining space.\n    priorities[valid_bins] = -np.abs(remaining_space - (item/2.0)) - 2* (remaining_space< (item/10.0))  # Prioritize half used (ish). Penalty if almost full.\n\n    # Rule 3: If there are *no* bins that can fit, put equal (low) priority in all of them\n    #         except ones that were close to fitting but not quite. These bins will then be opened, rather than bins we already filled (more wasteful)\n    \n    if np.all(priorities == -np.inf):\n        # Find bins that are \"close\" to fitting (e.g., within 10% of item size).\n\n        close_bins = (bins_remain_cap >= 0.9 * item) & (bins_remain_cap < item)\n        \n        #Assign moderate negative priority to these almost-fitting bins\n        priorities[close_bins] = -10.0\n\n        # Give same priority to any others to make one available.\n        other_bins = ~(close_bins) #All non close bins.\n        priorities[other_bins] = -20.0\n        \n        \n    return priorities",
    "response_id": 17,
    "obj": 9.453530115676102,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # 1. Feasibility check: Bin must have enough capacity.\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Calculate remaining capacity AFTER adding the item to feasible bins.\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[~feasible_bins] = -1  # Mark infeasible bins\n\n    # 3. Prioritize bins based on how FULL they will be AFTER placing the item.\n    #    Bins closer to being full get higher priority.  We want to fill bins,\n    #    but also avoid bins becoming *too* full.  So we'll use a non-linear scaling.\n    # We only assign priorities to feasible bins.\n    \n    fill_ratios = (bins_remain_cap[feasible_bins] - remaining_capacities[feasible_bins]) / bins_remain_cap[feasible_bins]  #How much of bin will be full\n    \n    priorities[feasible_bins] = fill_ratios ** 2  #Prioritize fuller bins more.  Squared to emphasize filling.\n\n    # 4. Add a small bonus to bins that are close to full to encourage packing. Avoid leaving tiny fragments.\n    close_to_full = np.logical_and(feasible_bins, remaining_capacities >= 0) # bins remaining capacities that are more than zero.\n    \n    near_full_threshold = 0.1 * np.mean(bins_remain_cap[feasible_bins]) if np.sum(feasible_bins) > 0 else 0.1 * np.mean(bins_remain_cap) if bins_remain_cap.size > 0 else 0 # dynamic threshold, prevents hardcoding.\n    close_to_full_mask = np.logical_and(close_to_full, remaining_capacities <= near_full_threshold)\n    \n    priorities[close_to_full_mask] += 0.5  # Give these bins a boost\n    \n\n    return priorities",
    "response_id": 18,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 37, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n9\n3\n48.43204266092217\n85.89195173073983\n104\n"
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Prioritize bins that can fit the item\n            remaining_after_fit = cap - item\n            priorities[i] = 1.0 / (0.001 + remaining_after_fit)  # Inverse of remaining space\n            # Add a bonus for bins that are close to being full after adding the item. Prevents creating too many nearly empty bins\n            if remaining_after_fit <= 0.1:\n                 priorities[i]+= 1.0\n\n            #Prioritize bins where item takes up a substantial part\n            priorities[i]+= min(1.0,item/cap)\n\n\n        else:\n            # Give bins that cannot fit item a very low priority (negative).\n            priorities[i] = -1000 #A Large negative number\n\n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Assign high priority to bins that can fit the item snugly\n    fit_mask = bins_remain_cap >= item\n    \n    if np.any(fit_mask):  # Check if there is at least one valid bin\n      slack = bins_remain_cap[fit_mask] - item\n      priorities[fit_mask] = np.exp(-slack) # Exponential decay to favor smaller slack\n    else:\n      #If no bin can fit, assign low priority to all bins with the largest remaining capacities.\n      max_cap = np.max(bins_remain_cap)\n      priorities[bins_remain_cap == max_cap] = -1.0\n      \n    \n    return priorities",
    "response_id": 20,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit-Decreasing inspired heuristic: prioritize bins where the item fits best\n    fit_mask = bins_remain_cap >= item\n    \n    if np.any(fit_mask): # only apply the formula on bins where items can fit\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 0.00001)  # Smaller slack -> Higher priority, added small constant to avoid divide by zero\n        \n        # Bonus for bins that are almost full after adding the item (to consolidate)\n        almost_full_mask = (slack >= 0) & (slack <= 0.1)  # If less than 0.1 left after adding\n        priorities[fit_mask][almost_full_mask[fit_mask]] += 10  # Arbitrary large bonus\n\n    else: # if it does not fit any existing bin, assign the highest priority to bin with largest capacity.\n        priorities[np.argmax(bins_remain_cap)] = 1\n\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Primary criterion: Favor bins that can fit the item.\n            remaining_space = cap - item\n            # Prioritize bins that leave less empty space (First Fit Decreasing heuristic idea). Avoids fragmentation\n            priorities[i] = 1 / (remaining_space + 0.0001)  # Add small constant to avoid division by zero\n\n            # Secondary criterion: If space left is smaller than the mean of all item sizes, encourage to fill.\n            # items_mean = np.mean(item)  # this mean calculation can be slow when called many times.\n            # if remaining_space <= items_mean: # Avoid excessive params; skip for simplicity.\n            #     priorities[i] *= 2\n\n            # Tertiary Criterion: Add a very small random number to add some diversity. Helps exploration.\n            priorities[i] += np.random.rand() * 0.00001\n        else:\n            # Penalize bins that cannot fit the item.\n            priorities[i] = -1000  # Very low priority\n\n    return priorities",
    "response_id": 22,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Assign a high priority to bins where the item fits and leaves minimal waste.\n    # Assign a low priority (or negative) to bins where the item doesn't fit.\n    \n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Priority is inversely proportional to the waste (cap - item) but also\n            # proportional to the utilization (item / cap). We add a small constant\n            # to avoid division by zero.\n\n            waste = cap - item\n            utilization = item / cap\n            priorities[i] = utilization / (waste + 0.0001) # higher utilization and lower waste = higher priority\n        else:\n            #Very negative priority to the bins where item doesn't fit.\n            priorities[i] = -1000  \n\n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Feasibility: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n        return priorities # No bin can fit, return all zero priorities.\n\n    # Calculate the wasted space if the item is placed in each feasible bin\n    wasted_space = bins_remain_cap - item\n    wasted_space[~feasible_bins] = np.inf  # Set wasted space to infinity for infeasible bins\n    \n    # Higher priority for bins with less wasted space\n    priorities = -wasted_space\n    \n    # Bonus for bins that are filled significantly after placing the item (to avoid fragmentation)\n    fill_ratios = (bins_remain_cap - wasted_space) / bins_remain_cap\n    \n    #Give significant fill ratios high priority\n    priorities = priorities + (fill_ratios >= 0.75) * 10  \n    \n    #Adjust priorties to be non-negative if negative\n    priorities = np.maximum(priorities, 0)\n    \n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate the wasted space if the item is placed in this bin.\n            wasted_space = cap - item\n\n            # Prioritize bins that can fit the item, but avoid bins that would\n            # result in excessive wasted space, or nearly full bins after placement\n            if wasted_space < 0.1: # Prefer almost full bins to fully utilize space. Tuneable parameter\n                priorities[i] = 10 #Arbitrary high number\n\n            else:\n                priorities[i] = (1/(wasted_space + 0.00001))  # Inverse of wasted space plus a small number to prevent zero divison\n\n\n    return priorities",
    "response_id": 25,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Give a higher priority to bins that can fit the item.\n            # Prioritize bins with smaller remaining capacity (First-Fit Decreasing principle).\n            priorities[i] = 1 / (cap - item + 0.0001)  # Avoid division by zero\n\n            # Small adjustment to prioritize bins that are closer to being full after placing the item\n            priorities[i] += 10*item/cap # Add a reward for higher fill rate.\n\n        else:\n            # Very low priority if the item doesn't fit. We penalize it heavily, but not -inf to prevent errors.\n            priorities[i] = -1000 #assigning a fixed penalty, could change based on the context.\n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Large enough bins\n    valid_bins = bins_remain_cap >= item\n    \n    if np.any(valid_bins):\n        # Encourage to fill bins as full as possible\n        fill_ratios = item / bins_remain_cap[valid_bins]\n        priorities[valid_bins] = fill_ratios\n\n        # Discourage bins where the remaining capacity is much larger than the item size.\n        # Smaller differences yield larger penalties.\n        capacity_diff = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-capacity_diff)  # Exponential decay of penalty.\n\n    # Slightly prefer bins that are already occupied (to create more \"half full bins\")\n    occupied = bins_remain_cap < np.max(bins_remain_cap)\n    priorities[occupied] += 0.1 * (bins_remain_cap[occupied] > 0)\n\n    # Make sure the scores do not become too small if remaining capacity is low\n    priorities += 1e-9\n    \n    return priorities",
    "response_id": 27,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Prefer bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1\n\n    # Heuristic 2: Prefer bins with the least remaining capacity after adding the item (First-Fit Decreasing like)\n    remaining_after_fit = bins_remain_cap[fit_mask] - item\n    if remaining_after_fit.size > 0:\n        priorities[fit_mask] += (1 - (remaining_after_fit / np.max(bins_remain_cap))).clip(0, 1) # scaled\n\n    # Heuristic 3: Heavily penalize bins that cannot fit the item (try to fill existing bins first)\n    priorities[~fit_mask] -= 0.5\n\n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Reward bins that can fit the item\n            priorities[i] = (cap - item) / cap  # Remaining space ratio after packing. Larger is better (less waste).\n            priorities[i] += 1 # Make positive\n        else:\n            # Penalize bins that cannot fit the item\n            priorities[i] = -np.inf  # Very low priority if it doesn't fit\n\n    return priorities",
    "response_id": 29,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 48.43204266092217,
    "mi": 85.89195173073983,
    "token_count": 104.0,
    "exec_success": true
  }
]