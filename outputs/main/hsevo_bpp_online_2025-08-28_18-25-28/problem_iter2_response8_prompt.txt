{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    remaining_caps = bins_remain_cap[valid_bins]\n    \n    fit_scores = item / remaining_caps\n    \n    exp_fit_scores = np.exp(-fit_scores)\n    \n    probabilities = exp_fit_scores / np.sum(exp_fit_scores)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = probabilities\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) > 0:\n        priorities[valid_bins] = bins_remain_cap[valid_bins] - item\n    else:\n        priorities[:] = -1\n    return priorities\n\n### Analyze & experience\n- Comparing heuristics 1st vs 2nd, both prioritize bins based on remaining capacity, but the 1st is a null heuristic (always returns zeros). The 2nd attempts to find the best fit (smallest remaining capacity after placing the item) and assigns higher priority to it. Comparing 2nd vs 3rd, they are nearly identical.  Comparing 3rd vs 4th, both use `1 / (waste + 1e-6)`, but the 4th uses `feasible_bins` instead of `valid_bins`. Comparing 4th vs 5th, the 5th uses a sigmoid function which seems more nuanced but could be less effective. Comparing 5th vs 6th, the 6th normalizes using a softmax approach, making it a probabilistic choice \u2013 a potentially good strategy. Comparing 6th vs 7th, the 7th picks the bin with minimum waste *across all feasible bins*, which is less refined than the 6th's probabilistic approach. Comparing 7th vs 8th, 8th is identical to 6th. Comparing 8th vs 9th, 9th is identical to 6th. Comparing 9th vs 10th, 10th uses min_waste similar to 7th but also adds a small number to the denominator and is less refined than the probabilistic choice made by 6th, 8th, and 9th. Comparing 10th vs 11th, the 11th introduces negative priorities which, while attempting to discourage infeasible bins, might be less informative than simply ignoring them. Comparing 11th vs 12th, 12th is a simplified version of 11th. Comparing 12th vs 13th, 13th is identical to 11th. Comparing 13th vs 14th, 14th simply returns the remaining capacity, lacking any normalization or prioritization beyond feasibility. Comparing 14th vs 15th, 15th is similar but assigns a negative priority to all bins if no valid bin exists. Comparing 15th vs 16th, 16th normalizes using item size, but this normalization seems arbitrary. Comparing 16th vs 17th, 17th is simpler, returning remaining capacity, with a slightly different handling of the no-valid-bin scenario. Comparing 17th vs 18th, 18th returns only the remain cap if the sum of valid bins is > 0. Comparing 18th vs 19th, 19th normalizes with item size like 16th. Comparing 19th vs 20th, 20th assigns -1 to all bins if no valid bins.\n\nOverall, heuristics using a normalized approach (like 6th, 8th, 9th) consistently outperform those relying on raw remaining capacity or introducing negative priorities. The use of softmax (6th, 8th, 9th) appears particularly effective.\n- \nOkay, let's refine \"Current self-reflection\" for superior heuristic design \u2013 aiming for that $999K! Here's a breakdown, explicitly addressing avoiding the pitfalls of ineffective self-reflection:\n\n* **Keywords:** Probabilistic Choice, Exploration-Exploitation, Softmax, Normalization, Diversity.\n* **Advice:**  Focus on *relative* fitness (Softmax temperature tuning is key!). Reward bin diversity *alongside* good fit.  Normalize item/bin scores to prevent dominance by scale.\n* **Avoid:** Absolute waste minimization, rigid prioritization, premature convergence to seemingly \"best\" bins.\n* **Explanation:**  Softmax promotes exploration. Normalization prevents bias. Balancing fit & diversity yields robust solutions, escaping local optima \u2013 vital for heuristic scalability.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}