{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit with adaptive softmax exploration, balancing exploitation and exploration.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    fit_scores = - (bins_remain_cap[possible_bins] - item)\n    temperature = np.mean(bins_remain_cap[possible_bins]) / item if np.mean(bins_remain_cap[possible_bins]) > 0 else 1.0\n    probabilities = np.exp(fit_scores / temperature)\n    probabilities /= np.sum(probabilities)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit with adaptive softmax exploration based on remaining capacity.\"\"\"\n    num_bins = len(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[possible_bins] - item\n    normalized_waste = 1.0 / (waste + 1e-6)\n    \n    bin_utilization = np.sum(possible_bins) / num_bins\n    temperature = 0.1 + 0.9 * (1.0 - bin_utilization)\n    \n    exp_values = np.exp(normalized_waste / temperature)\n    softmax_values = exp_values / np.sum(exp_values)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = softmax_values\n    \n    return priorities\n\n### Analyze & experience\n- Comparing `priority_v1` (1st) vs `priority_v2` (2nd), we observe `v1` is a null heuristic, assigning equal priority (0) to all bins, essentially random selection. `v2` introduces a basic best-fit approach, prioritizing bins that can accommodate the item and slightly boosting the best-fit bin. Comparing `v2` vs `priority_v2` (3rd), they are identical.  `priority_v2` (4th) attempts to add exploration via an exponential term and temperature, but the `argmax` step negates much of the exploration, essentially becoming a greedy algorithm. `priority_v2` (5th) and (6th) use softmax exploration with temperature scaling, but `v6` introduces a somewhat arbitrary exploration bonus. Comparing `priority_v2` (7th) and (8th), both are softmax explorations with adaptive temperature, but `v7` has unnecessary imports. `priority_v2` (9th), (10th), (11th) are identical to (8th).  `priority_v2` (12th) & (13th) are identical, both employ softmax. `priority_v2` (14th) introduces more temperature adjustment based on bin utilization which looks better than the previous options. `priority_v2` (15th) further refines temperature based on overall bin utilization. `priority_v2` (16th), (17th) and (19th) all appear identical, employing softmax with a constant boost to the best bin. `priority_v2` (18th) adjusts temperature based on the number of possible bins. The best heuristics consistently utilize softmax exploration with adaptive temperature scaling based on bin utilization or remaining capacity, aiming to balance exploitation (best fit) and exploration (trying different bins).  The use of unnecessary imports and arbitrary boosting factors detract from performance. Overall, the best heuristics are those that dynamically adjust exploration based on the current state of the bins.\n- \nOkay, let's dissect this and formulate truly insightful advice for heuristic design, aiming for that $999K reward! Here's a redefined \"Current Self-Reflection\" based on your input:\n\n* **Keywords:** Dynamic Exploration, Softmax Temperature, Bin Utilization, Waste Minimization, Adaptive Control.\n* **Advice:** Center heuristics around *adaptive* exploration \u2013 specifically, dynamically adjust softmax temperature based on bin utilization *and* remaining capacity. Prioritize simplicity; a strong best-fit core *with* dynamic softmax beats complex, convoluted methods.\n* **Avoid:** Static rewards, arbitrary boosts, `argmax` reliance, and unnecessary complexity. Resist normalization that isn\u2019t directly tied to the decision process. Don't focus solely on immediate gain (best-fit) *or* pure exploration.\n* **Explanation:** The core issue is balancing exploitation (best fit) and exploration (diversity). Dynamic temperature scaling in softmax *directly* responds to the problem state, encouraging exploration when bins are sparse and exploitation when nearing capacity. This adaptive behavior is key.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}