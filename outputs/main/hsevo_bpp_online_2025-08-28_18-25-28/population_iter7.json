[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines softmax prioritization with a small exploration bonus.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_capacities = bins_remain_cap[possible_bins]\n    scores = 1.0 / (1.0 + np.exp(-(remaining_capacities - item) / (item * 0.5)))\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = scores\n    probabilities = np.exp(priorities) / np.sum(np.exp(priorities))\n    return probabilities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.4674910251296325,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 108.04820237218406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with softmax exploration and a diversity reward.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = 1.0 / (waste + 1e-6)\n    temperature = 1.0\n    probabilities = np.exp(priorities / temperature)\n    probabilities /= np.sum(probabilities)\n    diversity_reward = 1.0 / (np.sum(possible_bins) + 1e-6)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities * diversity_reward\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 5.534503390506582,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 127.37720526058406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (v1) with softmax (v0) for balanced packing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    remaining_caps = bins_remain_cap[valid_bins]\n    fit_scores = item / remaining_caps\n    exp_fit_scores = np.exp(-fit_scores)\n    probabilities = exp_fit_scores / np.sum(exp_fit_scores)\n    priorities[valid_bins] = probabilities\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 44.97261104228487,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 1.0) -> np.ndarray:\n    \"\"\"Combines fit and diversity scores with temperature-scaled softmax.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    fit_scores = np.zeros_like(bins_remain_cap)\n    fit_scores[possible_bins] = 1.0 / (bins_remain_cap[possible_bins] - item + 1e-6)\n    bin_occupancy = 1.0 - bins_remain_cap / np.max(bins_remain_cap)\n    diversity_scores = bin_occupancy * possible_bins\n    combined_scores = 0.7 * fit_scores + 0.3 * diversity_scores\n    normalized_scores = combined_scores / np.sum(combined_scores) if np.sum(combined_scores) > 0 else np.zeros_like(combined_scores)\n    probabilities = np.exp(normalized_scores / temperature)\n    probabilities = probabilities / np.sum(probabilities)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 221.95334125177195,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with temperature-scaled probabilistic softmax selection.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(possible_bins):\n        temperature = 1.0\n        normalized_waste = 1.0 / (waste + 1e-6)\n        exp_values = np.exp(normalized_waste / temperature)\n        softmax_values = exp_values / np.sum(exp_values)\n        priorities[possible_bins] = softmax_values\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 5.534503390506582,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 81.7492568250068,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with softmax exploration, and introduces a diversity component.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    fit_scores = - (bins_remain_cap[possible_bins] - item)\n    diversity_scores = 1.0 / (np.sum(possible_bins) + 1e-6)\n    combined_scores = fit_scores + diversity_scores\n    temperature = 1.0\n    probabilities = np.exp(combined_scores / temperature)\n    probabilities /= np.sum(probabilities)\n\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.497407259672929,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 109.80793556946902,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with probabilistic softmax, adding a diversity reward.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[possible_bins] - item\n    normalized_waste = 1.0 / (waste + 1e-6)\n    temperature = 1.0\n    exp_values = np.exp(normalized_waste / temperature)\n    softmax_values = exp_values / np.sum(exp_values)\n\n    diversity_reward = 1.0 / (np.sum(possible_bins) + 1e-6)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = softmax_values * diversity_reward\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 5.534503390506582,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.32351694048162,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (inverse waste) with a temperature-scaled softmax for exploration.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    waste = bins_remain_cap[possible_bins] - item\n    fit_scores = 1.0 / (waste + 1e-6)\n    \n    temperature = 1.0\n    probabilities = np.exp(fit_scores / temperature)\n    probabilities /= np.sum(probabilities)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    \n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 5.534503390506582,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 81.7492568250068,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a temperature-scaled softmax selection for bin assignment, adding diversity.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    temperature = 1.0\n    fit_scores = (bins_remain_cap[possible_bins] - item)\n    exp_fit_scores = np.exp(-fit_scores / temperature)\n    diversity_scores = 1.0 / (np.sum(possible_bins) + 1e-6)\n    combined_scores = exp_fit_scores * diversity_scores\n    normalized_scores = combined_scores / np.sum(combined_scores)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = normalized_scores\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.497407259672929,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 111.48579046593244,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (v2) with a temperature-scaled softmax (v1) for improved exploration.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.full_like(bins_remain_cap, -1.0)\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = 1.0 / (waste + 1e-6)\n    temperature = 1.0\n    exp_priorities = np.exp(priorities / temperature)\n    probabilities = exp_priorities / np.sum(exp_priorities)\n    result = np.zeros_like(bins_remain_cap)\n    result[valid_bins] = probabilities\n    return result",
    "response_id": 9,
    "tryHS": false,
    "obj": 5.534503390506582,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 91.73835003173087,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    fill_levels = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n    fit_quality = (bins_remain_cap - item) / item\n    fit_quality[~possible_bins] = -1.0\n\n    temperature = 0.1 + (0.9 * np.random.rand())\n    \n    combined_scores = temperature * fit_quality + (1 - temperature) * fill_levels\n    \n    priorities[possible_bins] = np.exp(combined_scores[possible_bins]) / np.sum(np.exp(combined_scores[possible_bins]))\n    \n    best_bin_index = np.argmax(priorities)\n    priorities[best_bin_index] += 0.5\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 99.8703629836458,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 220.81007680238335,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n    \n    fill_levels = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n    fit_quality = (bins_remain_cap - item) / item\n\n    temperature = 0.5\n    \n    softmax_fill = np.exp(fill_levels / temperature) / np.sum(np.exp(fill_levels / temperature))\n    softmax_fit = np.exp(fit_quality / temperature) / np.sum(np.exp(fit_quality / temperature))\n    \n    combined_priority = 0.6 * softmax_fit + 0.4 * softmax_fill\n    \n    priorities[possible_bins] = combined_priority[possible_bins]\n    \n    best_bin_index = np.argmax(priorities[possible_bins])\n    best_bin_index = np.where(possible_bins)[0][best_bin_index]\n    \n    priorities[best_bin_index] += 1.0\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 223.47971260168305,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    fullness = 1 - bins_remain_cap / np.max(bins_remain_cap)\n    fit_quality = (bins_remain_cap - item) / item\n    \n    temperature = 0.5 + (np.sum(possible_bins) / n_bins) * 0.5\n    \n    combined_scores = (0.6 * fit_quality + 0.4 * fullness) * possible_bins\n    \n    softmax_scores = np.exp(combined_scores / temperature)\n    softmax_scores = softmax_scores / np.sum(softmax_scores)\n\n    priorities[possible_bins] = softmax_scores\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 215.90318620677482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    fullness = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    fit_quality = (bins_remain_cap - item) / item\n    \n    temperature = 1.0\n    \n    softmax_inputs = np.stack([fullness, fit_quality], axis=1)\n    \n    weighted_sum = temperature * softmax_inputs[:, 0] + (1 - temperature) * softmax_inputs[:, 1]\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = np.exp(weighted_sum[possible_bins]) / np.sum(np.exp(weighted_sum[possible_bins]))\n    \n    best_bin_index = np.argmax(priorities)\n    \n    priorities[best_bin_index] += 0.5\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 158.32466846199546,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    fill_levels = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    fit_quality = (bins_remain_cap - item) / item\n    fit_quality[~possible_bins] = -1\n\n    temperature = 0.5\n    priorities = np.zeros_like(bins_remain_cap)\n\n    softmax_input = temperature * fill_levels + (1 - temperature) * fit_quality\n    exp_values = np.exp(softmax_input - np.max(softmax_input))\n    probabilities = exp_values / np.sum(exp_values)\n\n    priorities[possible_bins] = probabilities[possible_bins]\n    \n    if np.sum(priorities) == 0:\n        best_bin_index = np.argmin(bins_remain_cap[possible_bins] - item)\n        priorities[possible_bins] = 0.0\n        priorities[possible_bins[best_bin_index]] = 1.0\n        \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 220.81007680238335,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, exploration_factor: float = 0.4045836123597859) -> np.ndarray:\n    \"\"\"Combines softmax prioritization with a small exploration bonus.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 4.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  }
]