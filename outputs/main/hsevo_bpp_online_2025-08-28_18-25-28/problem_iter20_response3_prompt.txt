{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with temperature-scaled softmax exploration, adapting temperature based on bin utilization.\"\"\"\n    n_bins = len(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros(n_bins)\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit with adaptive temperature-scaled softmax for exploration.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    waste = bins_remain_cap[possible_bins] - item\n    fit_quality = waste / item\n    temperature = 0.1 * np.mean(bins_remain_cap[possible_bins]) + 0.1\n    normalized_fit = 1.0 / (fit_quality + 1e-6)\n    exp_values = np.exp(normalized_fit / temperature)\n    softmax_values = exp_values / np.sum(exp_values)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = softmax_values\n    best_bin_index = np.argmax(priorities[possible_bins])\n    best_bin_index = np.where(possible_bins)[0][best_bin_index]\n    priorities[best_bin_index] += 0.2\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see the 1st heuristic incorporates temperature scaling based on bin utilization *and* a slight boost to the highest probability bin, refining best-fit with exploration. The 2nd is a very basic best-fit with a simple boost, lacking adaptive temperature control. \n\nComparing (3rd) vs (4th), both are essentially identical to the 1st and 2nd, respectively, with the same strengths and weaknesses.\n\nComparing (5th) vs (6th), both use adaptive softmax with bin utilization. The 6th refines temperature calculation, considering overall bin utilization and clamping to a reasonable range (0.1-1.0), leading to potentially more stable exploration.\n\nComparing (7th) vs (8th), they are identical. (8th) adds an explicit temperature parameter, offering some control but sacrificing the adaptive nature.\n\nComparing (9th) vs (8th), (9th) reduces the boost to the best bin to 0.5, while (8th) gives a boost of 2.0. This subtle change can reduce over-exploitation.\n\nComparing (11th) vs (13th), both incorporate exploration bonuses, but (13th) normalizes the priorities to sum to 1, improving probability distribution properties.\n\nComparing (14th) vs (15th), both use a 1/waste calculation, but (15th) incorporates a temperature factor and a more substantial exploration bonus, potentially enhancing exploration.\n\nComparing (16th) vs (17th), both are very similar and use an adaptive temperature-scaled softmax exploration. The only different is the if statement on the best bin index.\n\nComparing (18th) vs (19th), they are identical.\n\nComparing (20th) vs (1st), the 20th is similar to the 1st but uses a different temperature calculation and a larger bonus, which might lead to instability.\n\nOverall: Adaptive temperature scaling, based on bin utilization, consistently improves performance. Small exploration bonuses to the best bin can be helpful, but require careful tuning to avoid over-exploitation. Normalizing probabilities ensures a valid distribution. Utilizing more sophisticated temperature calculations, and ensuring the temperature remains within reasonable bounds, enhances stability. A focus on incorporating bin utilization for adapting exploration is a recurring theme in the better heuristics.\n- \nOkay, let's dissect this and formulate truly impactful advice for designing better heuristics, aiming for that $999K! Here\u2019s a breakdown based on the provided texts, focusing on *how* to improve, not just *what* to do:\n\n* **Keywords:** Adaptive Control, Bin Utilization, Softmax, Exploration-Exploitation Balance, Stability.\n* **Advice:** Design heuristics with *dynamic* parameters (temperature in softmax, exploration bonuses) directly tied to problem state (bin utilization, remaining capacity). Prioritize clear, modular code for easy adjustment & experimentation.\n* **Avoid:** Static rewards, `argmax` selections, overly complex logic, and redundant code. Don't focus solely on immediate \"best fit\" \u2013 long-term bin diversity is vital.\n* **Explanation:** The core issue is *reactivity*. Successful heuristics aren\u2019t pre-programmed; they *respond* to the evolving problem landscape. Adaptive temperature scaling and utilization-based bonuses ensure consistent exploration *where needed* \u2013 preventing premature convergence and maximizing overall efficiency.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}