[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with softmax prioritization, dynamically adjusting temperature.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_capacities = bins_remain_cap[possible_bins]\n    waste = remaining_capacities - item\n    normalized_waste = 1.0 / (waste + 1e-6)\n    temperature = 1.0 / (np.mean(bins_remain_cap[possible_bins]) + 1e-6)\n    exp_values = np.exp(normalized_waste / temperature)\n    softmax_values = exp_values / np.sum(exp_values)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = softmax_values\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 5.454726765057843,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 110.44611534953322,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a softmax exploration, dynamically adjusting temperature.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[possible_bins] - item\n    normalized_waste = 1.0 / (waste + 1e-6)\n    temperature = 1.0 / (np.mean(bins_remain_cap[possible_bins]) + 1e-6)\n    exp_values = np.exp(normalized_waste / temperature)\n    softmax_values = exp_values / np.sum(exp_values)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = softmax_values\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 5.454726765057843,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 110.44611534953322,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with softmax, dynamically adjusting temperature.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    remaining_caps = bins_remain_cap[valid_bins]\n    fit_scores = item / remaining_caps\n    exp_fit_scores = np.exp(-fit_scores)\n    probabilities = exp_fit_scores / np.sum(exp_fit_scores)\n    priorities[valid_bins] = probabilities\n    \n    temperature = 0.1 + (0.9 * np.random.rand())\n    best_bin_index = np.argmax(priorities)\n    priorities[best_bin_index] += temperature * 0.5\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 109.80793556946902,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with softmax prioritization for balanced bin packing.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_capacities = bins_remain_cap[possible_bins]\n    fit_scores = item / remaining_capacities\n    scores = 1.0 / (1.0 + np.exp(-fit_scores * 2.0))\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = scores\n    probabilities = priorities[possible_bins] / np.sum(priorities[possible_bins])\n    priorities[possible_bins] = probabilities\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 91.73835003173087,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a softmax exploration based on remaining capacity.\"\"\"\n    num_bins = len(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[possible_bins] - item\n    normalized_waste = 1.0 / (waste + 1e-6)\n    temperature = 0.1 + 0.9 * (1.0 - np.sum(possible_bins) / num_bins)\n    exp_values = np.exp(normalized_waste / temperature)\n    softmax_values = exp_values / np.sum(exp_values)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = softmax_values\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 5.534503390506582,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 148.60339807279118,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with softmax exploration.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_caps = bins_remain_cap[possible_bins]\n    fit_scores = item / remaining_caps\n    exp_fit_scores = np.exp(-fit_scores)\n    probabilities = exp_fit_scores / np.sum(exp_fit_scores)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 44.97261104228487,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a softmax to balance exploitation and exploration.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    fit_quality = (bins_remain_cap - item) / item\n    fit_quality[~possible_bins] = -1\n    \n    temperature = 0.5\n    softmax_input = temperature * fit_quality\n    exp_values = np.exp(softmax_input - np.max(softmax_input))\n    probabilities = exp_values / np.sum(exp_values)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities[possible_bins]\n    \n    if np.sum(priorities) == 0:\n        best_bin_index = np.argmin(bins_remain_cap[possible_bins] - item)\n        priorities[possible_bins] = 0.0\n        priorities[possible_bins[best_bin_index]] = 1.0\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 135.7068586817104,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a simple exploration bonus for less-full bins.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = 1.0 / (waste + 1e-6)\n    \n    best_bin_index = np.argmin(bins_remain_cap[possible_bins] - item)\n    \n    priorities[possible_bins] = priorities[possible_bins]\n    priorities[best_bin_index] = 2.0\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = priorities[possible_bins] + 1\n    priorities[best_bin_index] = 2.0\n    \n    return priorities",
    "response_id": 7,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 78.13781191217038,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with softmax exploration, focusing on bin utilization.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    fit_scores = - (bins_remain_cap[possible_bins] - item)\n    \n    temperature = np.mean(bins_remain_cap[possible_bins]) / item if np.mean(bins_remain_cap[possible_bins]) > 0 else 1.0\n    \n    probabilities = np.exp(fit_scores / temperature)\n    probabilities /= np.sum(probabilities)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    \n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 91.73835003173087,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a temperature-scaled softmax for exploration.\"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    waste = bins_remain_cap[possible_bins] - item\n    fit_quality = waste / item\n    temperature = 0.1 * np.mean(bins_remain_cap[possible_bins]) + 0.1\n    normalized_fit = 1.0 / (fit_quality + 1e-6)\n    exp_values = np.exp(normalized_fit / temperature)\n    softmax_values = exp_values / np.sum(exp_values)\n    priorities[possible_bins] = softmax_values\n    best_bin_index = np.argmax(priorities[possible_bins])\n    best_bin_index = np.where(possible_bins)[0][best_bin_index]\n    priorities[best_bin_index] += 0.5\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 5.534503390506582,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 146.71880002307702,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    remaining_caps = bins_remain_cap[possible_bins]\n    \n    fit_scores = 1.0 / (remaining_caps - item + 1e-6)\n    \n    exploration_bonus = 1.0 / (np.sum(bins_remain_cap) + 1e-6)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = fit_scores + exploration_bonus\n    \n    best_bin_index = np.argmax(priorities[possible_bins])\n    \n    best_bin_index_global = np.where(possible_bins)[0][best_bin_index]\n    \n    priorities[best_bin_index_global] *= 2.0\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n    \n    bin_fits = bins_remain_cap[possible_bins] - item\n    \n    best_bin_index = np.argmin(bin_fits)\n    \n    priorities[possible_bins] = 1.0\n    priorities[possible_bins[best_bin_index]] = 2.0\n    \n    avg_remaining_cap = np.mean(bins_remain_cap[possible_bins])\n    \n    \n    for i in np.where(possible_bins)[0]:\n        if bins_remain_cap[i] > avg_remaining_cap * 1.2:\n            priorities[i] += 0.5\n        elif bins_remain_cap[i] < avg_remaining_cap * 0.8:\n            priorities[i] += 0.2\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999970360000134 seconds"
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    remaining_capacities = bins_remain_cap[possible_bins]\n    waste = remaining_capacities - item\n    \n    best_bin_index = np.argmin(waste)\n    priorities[possible_bins] = 1.0\n    priorities[possible_bins[best_bin_index]] = 2.0\n    \n    avg_remaining = np.mean(bins_remain_cap[possible_bins])\n    \n    for i in range(n_bins):\n        if possible_bins[i]:\n            if bins_remain_cap[i] < avg_remaining * 0.5:\n                priorities[i] += 0.5\n            else:\n                priorities[i] += 0.2\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.427602712405275,
    "SLOC": 19.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 81.7492568250068,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response3.txt_stdout.txt",
    "code_path": "problem_iter9_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n\n    bin_utilizations = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    \n    best_fit_scores = np.where(possible_bins, bins_remain_cap - item, np.inf)\n    best_bin_index = np.argmin(best_fit_scores)\n    \n    exploration_factor = 0.1\n    \n    priorities[possible_bins] = 1.0 / (best_fit_scores[possible_bins] + 1e-6)\n    priorities[best_bin_index] += exploration_factor\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 92.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response4.txt_stdout.txt",
    "code_path": "problem_iter9_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    \n    remaining_capacities = bins_remain_cap[possible_bins]\n    \n    fit_scores = remaining_capacities - item\n    \n    \n    avg_remaining = np.mean(bins_remain_cap[possible_bins])\n    \n    exploration_bonus = np.exp(-(fit_scores - avg_remaining)**2 / (2 * (np.std(fit_scores)**2 + 1e-6)))\n    \n    \n    priorities[possible_bins] = exploration_bonus\n    \n    best_bin_index = np.argmax(priorities[possible_bins])\n    \n    priorities[possible_bins] = 0.0\n    priorities[possible_bins[best_bin_index]] = 1.0\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 126.65973476959637,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, exploration_bonus_epsilon: float = 3.774725051632658e-05) -> np.ndarray:\n    \"\"\"Combines best-fit with a simple exploration bonus for less-full bins.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 4.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  }
]