[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit and probabilistic choice using softmax for bin selection.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.full_like(bins_remain_cap, -1.0)\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = 1.0 / (waste + 1e-6)\n    \n    temperature = 1.0\n    exp_priorities = np.exp(priorities / temperature)\n    probabilities = exp_priorities / np.sum(exp_priorities)\n    \n    result = np.zeros_like(bins_remain_cap)\n    result[valid_bins] = probabilities\n    \n    return result",
    "response_id": 0,
    "tryHS": false,
    "obj": 5.534503390506582,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 91.73835003173087,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit approach (like v1) with softmax normalization\n    to balance exploitation and exploration.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    remaining_caps = bins_remain_cap[valid_bins]\n    fit_scores = item / remaining_caps\n    exp_fit_scores = np.exp(-fit_scores)\n    probabilities = exp_fit_scores / np.sum(exp_fit_scores)\n    priorities[valid_bins] = probabilities\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 44.97261104228487,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (waste minimization) with a softmax for probabilistic bin selection.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        waste = bins_remain_cap[feasible_bins] - item\n        min_waste = np.min(waste)\n        priorities[feasible_bins] = 1.0 / (min_waste + 1e-6)\n        \n        exp_priorities = np.exp(priorities)\n        probabilities = exp_priorities / np.sum(exp_priorities)\n        priorities = probabilities\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines softmax prioritization with a small exploration bonus.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_capacities = bins_remain_cap[possible_bins]\n    scores = 1.0 / (1.0 + np.exp(-(remaining_capacities - item) / (item * 0.5)))\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = scores\n    probabilities = np.exp(priorities) / np.sum(np.exp(priorities))\n    return probabilities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.4674910251296325,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 108.04820237218406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a probabilistic softmax selection for bin assignment.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    remaining_caps = bins_remain_cap[valid_bins]\n    fit_scores = item / remaining_caps\n    exp_fit_scores = np.exp(-fit_scores)\n    probabilities = exp_fit_scores / np.sum(exp_fit_scores)\n    priorities[valid_bins] = probabilities\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 44.97261104228487,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (waste minimization) with probabilistic softmax selection.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        remaining_capacities = bins_remain_cap[valid_bins]\n        waste = remaining_capacities - item\n        priorities[valid_bins] = np.exp(-waste / item)\n        priorities[valid_bins] /= np.sum(np.exp(-waste / item))\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 11, in priority_v2\n    \nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'divide' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n9\n2\n68.11428751370197\n"
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines softmax-based prioritization (from heuristics 6, 8, 9) with a waste-based component\n    to encourage both good fit and bin diversity.\n    \"\"\"\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_capacities = bins_remain_cap[feasible_bins]\n    waste = remaining_capacities - item\n    \n    scores = 1.0 / (waste + 1e-6)\n    \n    exp_scores = np.exp(scores)\n    probabilities = exp_scores / np.sum(exp_scores)\n\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[feasible_bins] = probabilities\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 5.534503390506582,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on a softmax of inverse waste, encouraging exploration.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.full_like(bins_remain_cap, -1.0)\n\n    waste = bins_remain_cap[valid_bins] - item\n    priorities = 1.0 / (waste + 1e-6)\n    \n    temperature = 1.0\n    probabilities = np.exp(priorities / temperature)\n    probabilities /= np.sum(probabilities)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = probabilities\n    \n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 5.534503390506582,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 91.73835003173087,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit (like v1) with softmax probability (like v6) for a balanced approach.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    remaining_caps = bins_remain_cap[valid_bins]\n    fit_scores = item / remaining_caps\n    exp_fit_scores = np.exp(-fit_scores)\n    probabilities = exp_fit_scores / np.sum(exp_fit_scores)\n    priorities[valid_bins] = probabilities\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 44.97261104228487,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit and probabilistic choice (softmax).\n    Normalizes waste and applies softmax for bin selection.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[possible_bins] - item\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    if np.any(possible_bins):\n        normalized_waste = 1.0 / (waste + 1e-6)\n        \n        temperature = 1.0 \n        exp_values = np.exp(normalized_waste / temperature)\n        softmax_values = exp_values / np.sum(exp_values)\n        priorities[possible_bins] = softmax_values\n    \n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 5.534503390506582,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 81.7492568250068,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 1.0) -> np.ndarray:\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    normalized_fit = (bins_remain_cap[possible_bins] - item) / bins_remain_cap[possible_bins]\n    normalized_fit = np.maximum(normalized_fit, 0)\n\n    diversity_reward = 1.0 / (np.sum(possible_bins) + 1e-6)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = np.exp(normalized_fit / temperature) * diversity_reward\n    priorities = priorities / np.sum(priorities)\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 115.94522208456974,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 1.0) -> np.ndarray:\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    fit_scores = np.zeros_like(bins_remain_cap)\n    fit_scores[possible_bins] = 1.0 / (bins_remain_cap[possible_bins] - item + 1e-6)\n\n    diversity_scores = np.zeros_like(bins_remain_cap)\n    bin_counts = np.zeros_like(bins_remain_cap)\n    bin_counts[possible_bins] = 1.0\n    diversity_scores[possible_bins] = 1.0 / (bin_counts[possible_bins] + 1e-6)\n\n    combined_scores = 0.7 * fit_scores + 0.3 * diversity_scores\n    \n    normalized_scores = np.exp(combined_scores / temperature)\n    normalized_scores /= np.sum(normalized_scores)\n\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = normalized_scores[possible_bins]\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 5.534503390506582,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 164.51539013493823,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 1.0) -> np.ndarray:\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    fit_scores = np.zeros_like(bins_remain_cap)\n    fit_scores[possible_bins] = - (bins_remain_cap[possible_bins] - item)\n    \n    diversity_scores = np.zeros_like(bins_remain_cap)\n    \n    filled_percentage = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    \n    diversity_scores[possible_bins] = filled_percentage[possible_bins]\n    \n    combined_scores = fit_scores + diversity_scores\n\n    normalized_scores = (combined_scores - np.min(combined_scores)) / (np.max(combined_scores) - np.min(combined_scores) + 1e-8)\n    \n    probabilities = np.exp(normalized_scores / temperature)\n    probabilities = probabilities / np.sum(probabilities)\n\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities[possible_bins]\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 177.87213211613133,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 1.0) -> np.ndarray:\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    fit_scores = (bins_remain_cap[possible_bins] - item)\n    fit_scores = np.exp(-fit_scores / temperature)\n    \n    diversity_scores = np.ones_like(fit_scores)\n    \n    combined_scores = fit_scores * diversity_scores\n    \n    normalized_scores = combined_scores / np.sum(combined_scores)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = normalized_scores\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.497407259672929,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 76.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 1.0) -> np.ndarray:\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    fit_scores = np.zeros_like(bins_remain_cap)\n    fit_scores[possible_bins] = 1.0 / (bins_remain_cap[possible_bins] - item + 1e-6)\n\n    diversity_scores = np.zeros_like(bins_remain_cap)\n    bin_occupancy = 1.0 - bins_remain_cap / np.max(bins_remain_cap)\n    diversity_scores[possible_bins] = bin_occupancy[possible_bins]\n\n    combined_scores = 0.7 * fit_scores + 0.3 * diversity_scores\n    \n    normalized_scores = combined_scores / np.sum(combined_scores) if np.sum(combined_scores) > 0 else np.zeros_like(combined_scores)\n\n    probabilities = np.exp(normalized_scores / temperature)\n    probabilities = probabilities / np.sum(probabilities)\n\n    priorities = np.zeros_like(bins_remain_cap)\n    if np.any(possible_bins):\n        best_bin_index = np.argmax(probabilities[possible_bins])\n        priorities[possible_bins] = probabilities[possible_bins]\n        priorities[possible_bins[best_bin_index]] = np.max(probabilities)\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 19.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 203.1220487258619,
    "exec_success": true
  }
]