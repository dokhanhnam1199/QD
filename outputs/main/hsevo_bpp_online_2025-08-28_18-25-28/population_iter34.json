[
  {
    "stdout_filepath": "problem_iter32_response0.txt_stdout.txt",
    "code_path": "problem_iter32_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with utilization-based adaptive softmax temperature.\"\"\"\n    n_bins = len(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_caps = bins_remain_cap[possible_bins]\n    fit_scores = 1.0 / (remaining_caps - item + 1e-6)\n    bin_utilization = np.mean(1.0 - (bins_remain_cap / np.max(bins_remain_cap) or 1e-6))\n    temperature = np.clip(1.0 - bin_utilization, 0.1, 2.0)\n    probabilities = np.exp(fit_scores / temperature)\n    probabilities /= np.sum(probabilities)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 12, in priority_v2\n    temperature = np.clip(1.0 - bin_utilization, 0.1, 1.0)\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n14\n3\n142.7018117963935\n"
  },
  {
    "stdout_filepath": "problem_iter32_response1.txt_stdout.txt",
    "code_path": "problem_iter32_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with temperature-scaled softmax for bin selection.\"\"\"\n    n_bins = len(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros(n_bins)\n    remaining_caps = bins_remain_cap[possible_bins]\n    fit_scores = 1.0 / (remaining_caps - item + 1e-6)\n    bin_utilization = np.sum(bins_remain_cap) / (n_bins * np.max(bins_remain_cap))\n    temperature = np.clip(1.0 - bin_utilization, 0.1, 1.0)\n    exp_scores = np.exp(fit_scores / temperature)\n    probabilities = exp_scores / np.sum(exp_scores)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    best_bin_index = np.argmax(priorities)\n    priorities[best_bin_index] += 0.1\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 5.534503390506582,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 148.60339807279118,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response2.txt_stdout.txt",
    "code_path": "problem_iter32_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with adaptive softmax, utilizing bin utilization for temperature.\"\"\"\n    n_bins = len(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_caps = bins_remain_cap[possible_bins]\n    fit_scores = - (remaining_caps - item)\n    bin_utilization = np.sum(bins_remain_cap) / (n_bins * np.max(bins_remain_cap) or 1e-6)\n    temperature = np.mean(remaining_caps) / item if np.mean(remaining_caps) > 0 else 1.0\n    temperature = np.clip(temperature * (1.0 - bin_utilization), 0.1, 1.0)\n    probabilities = np.exp(fit_scores / temperature)\n    probabilities /= np.sum(probabilities)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    best_bin_index = np.argmax(probabilities)\n    priorities[possible_bins[best_bin_index]] += 0.1\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 20, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n17\n4\n200.0\n"
  },
  {
    "stdout_filepath": "problem_iter32_response3.txt_stdout.txt",
    "code_path": "problem_iter32_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with temperature-scaled softmax, robustly.\"\"\"\n    n_bins = len(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros(n_bins)\n    remaining_capacities = bins_remain_cap[possible_bins]\n    fit_scores = - (bins_remain_cap[possible_bins] - item)\n    bin_utilizations = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n    temperature = 1.0 / (1.0 + np.mean(bin_utilizations))\n    temperature = np.clip(temperature, 0.1, 1.0)\n    probabilities = np.exp(fit_scores / temperature) / np.sum(np.exp(fit_scores / temperature))\n    priorities = np.zeros(n_bins)\n    priorities[possible_bins] = probabilities\n    best_bin_index = np.argmax(priorities)\n    priorities[best_bin_index] *= 1.2\n    return priorities",
    "response_id": 3,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 153.80110650593844,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response4.txt_stdout.txt",
    "code_path": "problem_iter32_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with adaptive softmax temperature, prioritizing bin utilization.\"\"\"\n    n_bins = len(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_caps = bins_remain_cap[possible_bins]\n    fit_scores = - (remaining_caps - item)\n    bin_utilization = np.sum(bins_remain_cap) / (n_bins * np.max(bins_remain_cap))\n    temperature = np.mean(remaining_caps) / item if np.mean(remaining_caps) > 0 else 1.0\n    temperature = np.clip(temperature * (1.0 - bin_utilization), 0.1, 1.0)\n    probabilities = np.exp(fit_scores / temperature)\n    probabilities /= np.sum(probabilities)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    best_bin_index = np.argmax(probabilities)\n    if possible_bins[best_bin_index]:\n        priorities[best_bin_index] += 0.1\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.2979656960510715,
    "SLOC": 18.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 179.74529681972018,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response5.txt_stdout.txt",
    "code_path": "problem_iter32_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with temperature-scaled softmax for robust bin selection.\"\"\"\n    n_bins = len(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros(n_bins)\n\n    remaining_capacities = bins_remain_cap[possible_bins]\n    fit_scores = - (bins_remain_cap[possible_bins] - item)\n    bin_utilizations = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n    temperature = 1.0 / (1.0 + np.mean(bin_utilizations))\n    temperature = np.clip(temperature, 0.1, 1.0)\n    probabilities = np.exp(fit_scores / temperature) / np.sum(np.exp(fit_scores / temperature))\n    priorities = np.zeros(n_bins)\n    priorities[possible_bins] = probabilities\n    best_bin_index = np.argmax(priorities)\n    priorities[best_bin_index] *= 1.2\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 153.80110650593844,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response6.txt_stdout.txt",
    "code_path": "problem_iter32_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with temperature-scaled softmax, adapting temperature to bin utilization.\"\"\"\n    n_bins = len(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros(n_bins)\n\n    remaining_capacities = bins_remain_cap[possible_bins]\n    fit_scores = - (bins_remain_cap[possible_bins] - item)\n    bin_utilizations = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n    temperature = 1.0 / (1.0 + np.mean(bin_utilizations))\n    temperature = np.clip(temperature, 0.1, 1.0)\n    probabilities = np.exp(fit_scores / temperature) / np.sum(np.exp(fit_scores / temperature))\n    priorities = np.zeros(n_bins)\n    priorities[possible_bins] = probabilities\n    best_bin_index = np.argmax(priorities)\n    priorities[best_bin_index] *= 1.2\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 153.80110650593844,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response7.txt_stdout.txt",
    "code_path": "problem_iter32_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with adaptive softmax, using bin utilization for temperature.\"\"\"\n    n_bins = len(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_caps = bins_remain_cap[possible_bins]\n    fit_scores = - (remaining_caps - item)\n    bin_utilization = np.sum(bins_remain_cap) / (n_bins * np.max(bins_remain_cap))\n    temperature = np.mean(remaining_caps) / item if np.mean(remaining_caps) > 0 else 1.0\n    temperature = np.clip(temperature * (1.0 - bin_utilization), 0.1, 1.0)\n    probabilities = np.exp(fit_scores / temperature)\n    probabilities /= np.sum(probabilities)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    best_bin_index = np.argmax(probabilities)\n    if possible_bins[best_bin_index]:\n        priorities[best_bin_index] += 0.1\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.2979656960510715,
    "SLOC": 18.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 179.74529681972018,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response8.txt_stdout.txt",
    "code_path": "problem_iter32_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with adaptive temperature-scaled softmax for robust bin selection.\"\"\"\n    n_bins = len(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    remaining_caps = bins_remain_cap[possible_bins]\n    fit_scores = 1.0 / (remaining_caps - item + 1e-6)\n    bin_utilization = np.sum(bins_remain_cap) / (n_bins * np.max(bins_remain_cap) or 1e-6)\n    temperature = np.clip(1.0 - bin_utilization, 0.1, 2.0)\n    exp_scores = np.exp(fit_scores / temperature)\n    probabilities = exp_scores / np.sum(exp_scores)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    best_bin_index = np.argmax(priorities)\n    priorities[best_bin_index] += 0.1\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 5.534503390506582,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 166.4210625757214,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter32_response9.txt_stdout.txt",
    "code_path": "problem_iter32_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with temperature-scaled softmax for robust bin selection.\"\"\"\n    n_bins = len(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros(n_bins)\n\n    fit_scores = bins_remain_cap[possible_bins] - item\n    \n    bin_utilization = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n    \n    temperature = 0.1 + 0.9 * np.mean(bin_utilization[possible_bins])\n    \n    scores = np.exp(-fit_scores / temperature)\n    \n    priorities = np.zeros(n_bins)\n    priorities[possible_bins] = scores / np.sum(scores)\n    \n    best_bin_index = np.argmin(fit_scores)\n    priorities[possible_bins] = np.where(np.arange(len(possible_bins)) == np.argmin(fit_scores), 2.0, 1.0)\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 145.71363126237387,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response0.txt_stdout.txt",
    "code_path": "problem_iter33_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    bin_utilization = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n    temperature = 0.1 + 0.9 * np.mean(bin_utilization)\n    temperature = np.clip(temperature, 0.1, 1.0)\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n    unnormalized_priorities = np.exp((bins_remain_cap[possible_bins] - item) / temperature)\n    priorities[possible_bins] = unnormalized_priorities / np.sum(unnormalized_priorities)\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 114.20025299224778,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response1.txt_stdout.txt",
    "code_path": "problem_iter33_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    bin_utilization = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n    temperature = 0.1 + 0.9 * np.mean(bin_utilization)\n    temperature = np.clip(temperature, 0.1, 1.0)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    bin_scores = np.exp(-(bins_remain_cap[possible_bins] - item) / temperature)\n    probabilities = bin_scores / np.sum(bin_scores)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.2979656960510715,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 126.65973476959637,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response2.txt_stdout.txt",
    "code_path": "problem_iter33_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    bin_utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    temperature = 0.1 + 0.9 * np.mean(bin_utilization)\n    temperature = np.clip(temperature, 0.1, 1.0)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    bin_fits = (bins_remain_cap[possible_bins] - item)\n    \n    probabilities = np.exp(-bin_fits / temperature)\n    probabilities /= np.sum(probabilities)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.2979656960510715,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 126.65973476959637,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response3.txt_stdout.txt",
    "code_path": "problem_iter33_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    bin_utilization = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n    temperature = 0.1 + 0.9 * np.mean(bin_utilization)\n    temperature = np.clip(temperature, 0.1, 1.0)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    scores = np.exp(-(bins_remain_cap[possible_bins] - item) / temperature)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = scores / np.sum(scores)\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.2979656960510715,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 126.65973476959637,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter33_response4.txt_stdout.txt",
    "code_path": "problem_iter33_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    bin_utilization = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n    temperature = 0.1 + 0.9 * np.mean(bin_utilization)\n    temperature = np.clip(temperature, 0.1, 1.0)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    bin_scores = np.zeros_like(bins_remain_cap)\n    bin_scores[possible_bins] = np.exp(-(bins_remain_cap[possible_bins] - item) / temperature)\n    \n    probabilities = bin_scores[possible_bins] / np.sum(bin_scores[possible_bins])\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.2979656960510715,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 126.65973476959637,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter34_response0.txt_stdout.txt",
    "code_path": "problem_iter34_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, temperature_scale: float = 1.2569111101781079, temperature_clip_min: float = 0.11550248375061366, temperature_clip_max: float = 1.2685458747827507, best_bin_boost: float = 1.352905866079845) -> np.ndarray:\n    \"\"\"Combines best-fit with temperature-scaled softmax, robustly.\"\"\"\n    n_bins = len(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros(n_bins)",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  }
]