[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit-Decreasing Inspired: Prioritize bins where the item fits best (smallest waste)\n    # but only consider bins where the item actually fits.\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        waste = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = 1 / (waste + 0.00001)  # Avoid division by zero, higher priority for less waste\n\n        # Additionally, prioritize bins that are close to full after placing the item.\n        fullness = 1 - waste / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += fullness * 0.5  # Weight fullness less than waste to avoid overfilling a single bin if small waste\n\n    # Penalize bins where the item doesn't fit\n    else:\n        priorities = np.full_like(bins_remain_cap, -1000.0) # Very low priority if the item can't fit\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Prioritize bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = 1\n\n    # If no bin can fit, use a fallback strategy\n    if not np.any(fit_mask):\n        # Prioritize bins with the largest remaining capacity as they would be less wasteful\n        priorities = bins_remain_cap\n        return priorities\n\n    # Add a bonus for bins where the item fills a large percentage of the remaining capacity\n    # but not exceeding the bin capacity\n    fill_ratio = item / bins_remain_cap[fit_mask]\n    priorities[fit_mask] += fill_ratio\n\n    # Add a penalty for creating very small remaining capacities after packing\n    remaining_after_pack = bins_remain_cap[fit_mask] - item\n    small_remaining_mask = remaining_after_pack < 0.1  # Arbitrary threshold\n    priorities[fit_mask][small_remaining_mask] -= 0.5\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Feasibility check: Assign very low priority to bins that cannot fit the item.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Best Fit logic: Prioritize bins that have just enough space for the item.\n    # Avoid creating too much wasted space.\n    diff = bins_remain_cap - item\n    \n    #Bins can take items have more priority\n    feasible_mask = bins_remain_cap >= item\n    priorities[feasible_mask] = -diff[feasible_mask]\n    \n    # Use a small value to avoid division by zero when bins are filled\n    epsilon = 1e-6\n\n    # Reward bins that are relatively empty (more opportunity to pack other items) but can still take the current item\n    normalized_remaining_cap = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)\n    priorities[feasible_mask] += 0.5 * normalized_remaining_cap[feasible_mask]  # Scale the reward, don't overpower best-fit\n\n    # Penalize bins with nearly full capacity\n    nearly_full_threshold = 0.9  # Can be adjusted based on performance\n    nearly_full_mask = (bins_remain_cap > item) & (normalized_remaining_cap > nearly_full_threshold) # only apply if bin can accomodate items\n    priorities[nearly_full_mask] -= 0.2 * normalized_remaining_cap[nearly_full_mask] #Scale the penalty down\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: Prefer bins that can accommodate the item\n    eligible_bins = bins_remain_cap >= item\n    priorities[eligible_bins] += 1  # Give a base priority to eligible bins\n\n    # Rule 2: Fill bins as full as possible (minimize wasted space)\n    wasted_space = bins_remain_cap - item\n    wasted_space[wasted_space < 0] = np.inf  # Penalize ineligible bins by setting a large wasted space.\n    priorities[eligible_bins] += 1.0 / (wasted_space[eligible_bins] + 0.00001) # Add inverse wasted space to priority\n    \n    # Rule 3:  Consider the fill ratio: higher is better, but less critical than feasibility or space\n    fill_ratio = item / bins_remain_cap\n    fill_ratio[~eligible_bins] = 0 # only penalize where we can\n    priorities += fill_ratio/100 #Add a slightly less impact to score\n\n    #Rule 4: Consider using empty bin\n    empty_bins = bins_remain_cap == np.max(bins_remain_cap)\n    if np.any(empty_bins):\n        priorities[empty_bins] +=0.5\n\n    return priorities",
    "response_id": 3,
    "obj": 84.99202233745513,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Primary criterion: Can the item fit?\n            priority = 1.0\n\n            # Secondary criterion: How much space will be left? Prefer bins that leave less space.\n            remaining_space = cap - item\n            priority += 1.0 / (remaining_space + 0.001)  # Avoid division by zero and give a slight boost to smaller remaining spaces.\n\n            # Tertiary criterion: Prefer bins that are fuller already (but can still accommodate the item)\n            priority += (1 - (cap / (np.max(bins_remain_cap)+0.001))) # normalize to max bin cap to get consistent results. Add epsilon to prevent division by zero when all caps are 0.\n\n            priorities[i] = priority\n        else:\n            priorities[i] = -1.0  # Assign a low priority if the item doesn't fit\n\n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996332000046 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Very high priority for bins that can fit the item snugly.\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1 / (bins_remain_cap[fit_mask] - item + 1e-9)\n\n    # Give a slight preference to bins that are already somewhat full\n    # (avoid creating too many nearly-empty bins).\n    priorities += (1 - bins_remain_cap / np.max(bins_remain_cap)) # Avoids division by zero if all are empty at first\n    \n\n    # Penalize bins that are too big, to try and keep them for larger items.\n    # This helps with worst-fit-decreasing like behavior.\n    priorities -= (bins_remain_cap - item) * (bins_remain_cap > item) / np.max(bins_remain_cap) # Only applies if it doesn't fit\n\n    # If no bin can fit, then all bins should be equally considered.\n    if not np.any(fit_mask):\n      priorities = np.ones_like(priorities) * (1/np.mean(bins_remain_cap)+1e-9)\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Prioritize bins that can fit the item\n            remaining_space = cap - item\n            priorities[i] = 1 / (remaining_space + 0.00001)  # Avoid division by zero, prioritize smaller remaining space\n\n            # Bonus for being close to full after adding the item\n            priorities[i] += np.exp(-remaining_space)  # Exponential decay with remaining space\n\n            # If item fills the bin completely, give very high priority\n            if remaining_space < 0.0001: # tolrance \n                priorities[i] += 100\n\n        else:\n            # Negative priority if the item doesn't fit\n            priorities[i] = -1000  #Very low negative number\n    return priorities",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996900000042 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: If a bin can fit the item perfectly, assign it the highest priority.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = np.inf  # Infinite priority\n\n    # Rule 2: If item does not fit the bin assign it -inf\n    no_fit = bins_remain_cap < item\n    priorities[no_fit] = -np.inf\n\n    # Rule 3: For bins that can fit, prioritize bins with smaller remaining capacity after placing the item.\n    # This encourages filling bins up and reducing fragmentation.\n    fit_bins = bins_remain_cap >= item\n    remaining_capacity_after_fit = bins_remain_cap[fit_bins] - item\n    #Prioritize bins with small remaining capacity\n    priorities[fit_bins] = 1 / (remaining_capacity_after_fit + 1e-9)\n\n    #Rule 4: For very small items, prioritize the almost full bin to avoid having lots of almost empty bins\n    small_item = item < 0.1\n    almost_full = bins_remain_cap > item\n    almost_full = np.logical_and(almost_full, bins_remain_cap < 0.2) # remaining cap is also small\n    if small_item and np.any(almost_full):\n        priorities[almost_full] = 100 #High priority\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Primary criterion: Fit the item, higher remaining capacity preferred\n            priorities[i] = cap - item  # Smaller waste is better (first fit decreasing principle)\n        else:\n            # Cannot fit, strongly discourage this bin (large negative priority)\n            priorities[i] = -1e9 # a very large negative value.\n\n    return priorities",
    "response_id": 8,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n    \n    # Give high priority to bins where the item fits and leaves minimal waste\n    fit_mask = remaining_after_add >= 0\n    \n    if np.any(fit_mask):\n        waste = remaining_after_add[fit_mask]\n        priorities[fit_mask] = 1 / (waste + 0.0001)  # Avoid division by zero. Higher priority for less waste.\n\n        # Bonus for bins that are close to full after adding the item\n        fullness = 1 - (waste / bins_remain_cap[fit_mask])\n        priorities[fit_mask] += fullness*2 # Adding scaled 'fullness' as priority\n\n    # Penalize bins where the item doesn't fit heavily\n    else:\n        priorities = np.full_like(bins_remain_cap, -1000.0)\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # 1. Feasibility: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf  # Assign very low priority to infeasible bins\n\n    # 2. Remaining capacity after packing: Prioritize bins that leave minimal waste\n    remaining_capacity = bins_remain_cap - item\n    remaining_capacity[~feasible_bins] = np.inf #ignore infeasible ones\n\n    # 3. Prioritize bins with smaller remaining capacity after packing (minimize waste)\n    #    Add a small constant to avoid division by zero. Larger item means more importance on remaining_capacity.\n\n    priorities[feasible_bins] = -remaining_capacity[feasible_bins] + item # Use -remaining_capacity as a higher number signifies less remaining cap\n\n    # 4. Secondary criteria: If remaining capacity is the same, prioritize bins that were previously more full\n\n    previous_fill_ratio = (1 - (bins_remain_cap / (bins_remain_cap + item) if (bins_remain_cap + item)[0] > 0 else 1 )) #Estimates original fill, add one for items that do not fit\n    previous_fill_ratio[~feasible_bins] = 0\n    priorities[feasible_bins] = priorities[feasible_bins] + 0.1*previous_fill_ratio[feasible_bins] #Make secondary significance\n\n    return priorities",
    "response_id": 10,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 17, in priority_v2\n    priorities[i] = (cap - item) / cap  # Higher priority to bins with less wasted space\nOverflowError: cannot convert float infinity to integer\n14\n5\n110.44611534953322\n78.81492371877928\n157\n"
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Reward bins that can fit the item\n            priorities[i] = (cap - item) / cap  # Higher priority to bins with less wasted space\n            #priorities[i] = 1 / (cap - item + 0.00001) #try to fill them tightly to encourage later items to go to later bins\n        else:\n            # Penalize bins that cannot fit the item. Negative priority\n            priorities[i] = -1000 # Set to a very low negative value\n\n    return priorities",
    "response_id": 11,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate how full the bin would be if the item was added\n            fill_ratio = item / cap\n            # Prioritize bins that would be filled to a higher degree\n            # but avoid filling them completely. A perfect fit is ideal\n            priorities[i] = 1 / abs(fill_ratio - 0.95) # close to 1 is better.\n            #If item exactly fits in the bin assign the highest priority\n            if abs(fill_ratio - 1) < 1e-6:\n                priorities[i] = 1000\n        else:\n            priorities[i] = -1 # negative priority since it can not be fit\n    return priorities",
    "response_id": 12,
    "obj": 4.038691663342641,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing inspired: Prioritize bins that can fit the item snugly.\n    # A larger positive value implies higher priority. If it can't fit assign a very low score\n    fit_check = bins_remain_cap >= item\n    priorities[fit_check] = bins_remain_cap[fit_check] - item\n\n    # Give a boost to almost full bins but that have enough capacity\n    almost_full = (bins_remain_cap > item) & (bins_remain_cap <= 2 * item)\n    priorities[almost_full] += 1.0\n\n    # Assign a very negative priority to bins that cannot fit the item.\n    priorities[bins_remain_cap < item] = -np.inf\n\n    return priorities",
    "response_id": 13,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Base priority: how much space is left after packing the item. Closer to 0, higher priority.\n            space_left = cap - item\n            priorities[i] = 1 / (space_left + 0.0001)  # Avoid division by zero\n\n            # Bonus for being close to half-full (trying to balance bin usage).\n            half_full_diff = np.abs(cap - item - (1/2))\n            priorities[i] += 0.5 * np.exp(-5*half_full_diff) # Gaussian function around optimal value\n\n            # Slight penalty for larger capacities to encourage using bins that are already somewhat full.\n            priorities[i] -= 0.1 * cap\n\n        else:\n            priorities[i] = -np.inf  # Bin is not suitable\n    return priorities",
    "response_id": 14,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996853999983 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First, give a high priority to bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1\n\n    # Prioritize bins where the item fills a large portion of the remaining capacity,\n    # but not so much that it leaves very little space.\n    fill_ratio = item / bins_remain_cap\n    sweet_spot = (fill_ratio > 0.5) & (fill_ratio <= 1.0) & can_fit # Try to fill > half the bin\n\n    priorities[sweet_spot] += 2\n\n    #Prioritize bins which maximize the bin filling. Avoids fragmentation\n    priorities[can_fit] += (bins_remain_cap[can_fit] - item)\n\n    # Penalize bins where adding the item would result in very little space remaining (fragmentation).\n\n    small_rem = (bins_remain_cap - item) <= 0.1 # e.g., <= 0.1 implies low utility for this bin.\n\n    priorities[small_rem & can_fit] -= 1\n\n    # If no bin can fit the item, or if no bins are available (all capacities are zero), return a default priority. This avoids errors such as division by zero when using this priority function\n    if not np.any(can_fit):\n        priorities = np.zeros_like(bins_remain_cap)\n        priorities[:] = -1  # Or some other default value.\n\n    return priorities",
    "response_id": 15,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 27, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n14\n5\n110.44611534953322\n78.81492371877928\n157\n"
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # First Fit Decreasing Inspired: Prefer bins with tighter fit\n            priorities[i] = (cap - item) / cap # Remaining capacity ratio; smaller is better\n            priorities[i] = 1 - priorities[i] # so make it inverse, prefer higher\n            # Add a bonus if the bin is almost full after packing\n            if (cap - item) <= 0.1:  # Tune this threshold\n                 priorities[i] += 0.5  # Tune this bonus\n\n        else:\n            priorities[i] = -1e9  # Very low priority, almost impossible\n\n    return priorities",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit-Decreasing inspired: prioritize bins that can fit the item snugly\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = bins_remain_cap[fit_mask] - item  # Smaller difference = higher priority\n\n    # Avoid fragmentation: heavily penalize bins that will have very small remaining capacity\n    small_remain_mask = (bins_remain_cap - item) > 0 & (bins_remain_cap - item) < 0.1\n    priorities[small_remain_mask] -= 100  # Large penalty for small remaining capacity\n\n    # Assign a high priority to bins that can fit, but are close to full after packing.\n    close_to_full_mask = (bins_remain_cap >= item) & ((bins_remain_cap - item) <= 0.2)\n    priorities[close_to_full_mask] += 50 # Add some priority\n\n    # Give negative priority to bins that can't fit.\n    priorities[bins_remain_cap < item] = -np.inf\n\n    return priorities",
    "response_id": 17,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 20, in priority_v2\n    \nTypeError: ufunc 'bitwise_and' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''\n14\n5\n110.44611534953322\n78.81492371877928\n157\n"
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Feasibility: Only consider bins that can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n        return priorities # All zero if no bin can accommodate\n\n    \n    # First Fit Decreasing Heuristic imitation: Prefer bins with smaller remaining capacity AFTER placing item\n    remaining_after_placement = bins_remain_cap - item\n    remaining_after_placement[remaining_after_placement < 0] = np.inf # set infeasible to inf for sorting\n    \n    # Rank feasible bins based on remaining capacity after item placement. Smaller is better.\n    ranks = np.argsort(remaining_after_placement)\n    \n    # Assign rank-based priorities. Higher rank (smaller remaining cap) gets higher priority\n    priority_values = np.linspace(1, 0.1, len(bins_remain_cap))  # Decreasing priority as rank decreases.\n    \n    valid_ranks = ranks[feasible_bins[ranks]]\n    priorities[valid_ranks] = priority_values[:len(valid_ranks)]  # valid_ranks handles potential rank change\n\n\n    # Bonus for \"almost full\" bins if item can be packed there:\n    almost_full_threshold = 0.9\n    almost_full_bins = (bins_remain_cap / (bins_remain_cap + item)) > almost_full_threshold\n    priorities[feasible_bins & almost_full_bins] += 0.25 #Add a small bonus if its \"almost full\" after placement\n\n    return priorities",
    "response_id": 18,
    "obj": 4.417630634224167,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a high priority to bins where the item fits with minimal waste.\n    # First, identify bins that can fit the item.\n    \n    fitting_bins = bins_remain_cap >= item\n    \n    if np.any(fitting_bins):  # Only consider bins where the item fits\n        waste = bins_remain_cap[fitting_bins] - item\n        \n        #Prioritize bins with minimum waste, inverse of waste\n        priorities[fitting_bins] = 1 / (waste + 1e-9) #Add small value to avoid divide by zero\n        \n        # Give extra priority to bins that are almost full after adding the item.\n        fullness = (item + bins_remain_cap[fitting_bins] - waste) /1 # normalize between 0 and 1. dividing by 1 as max bin capacity is 1\n        priorities[fitting_bins] += fullness\n    else:\n        #If no bin fits the item, prioritize bins with larger remaining capacity. This represents an approach to 'First-Fit Decreasing'.\n        priorities = bins_remain_cap\n        \n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Favor bins where the item fits.\n    fits = item <= bins_remain_cap\n    priorities[fits] += 1\n\n    # Heuristic 2:  Higher priority for bins where the item fills a large proportion of the bin,\n    # but avoid leaving too little space. Balance utilization and fragmentation.\n    fill_ratio = item / bins_remain_cap\n    priorities[fits] += fill_ratio[fits]\n\n    # Heuristic 3: Penalize bins that become too full after adding the item, since that reduces reusability\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = (remaining_after_fit > 0) & (remaining_after_fit < 0.1) # Less than 0.1 remains, very full\n    priorities[nearly_full] -= 0.5 # slight penality, but avoid excessive full bins\n\n    # Heuristic 4:  Give higher priority to bins with larger remaining capacity if it is larger than the item.\n    #                try to fully fill a small bin before attempting to fill larger bins.\n    large_bins = bins_remain_cap >= item\n    priorities[large_bins] += bins_remain_cap[large_bins] / np.max(bins_remain_cap) * 0.2\n\n    return priorities",
    "response_id": 20,
    "obj": 4.058635819704831,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Primary Criterion: Remaining capacity after packing (smaller is better). Favors near-full bins.\n            remaining_after_packing = cap - item\n            priorities[i] = 1.0 / (remaining_after_packing + 0.0001)  # Avoid division by zero\n\n            # Secondary Criterion: Utilization rate of the bin if the item were placed.  Favors better utilization.\n            utilization_rate = (1 - remaining_after_packing / 100) #Assuming bin size is 100\n            priorities[i] = priorities[i] * utilization_rate\n\n            #Tertiary Criterion: Prefer bins with slightly larger capacity to improve average filling ratio.\n            priorities[i] = priorities[i] * (cap / 100)\n\n        else:\n            priorities[i] = -1e9  # Very low priority for bins that cannot fit the item.\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Assign high priority to bins that can fit the item snugly\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]\n    priorities[fit_mask] = 1 - priorities[fit_mask]\n    #Prioritize smaller remaining capacity after the item is placed\n\n    # Assign very low priority to bins that cannot fit the item\n    priorities[~fit_mask] = -1e9  # A very negative value\n\n    #If a bin has capacity equals to item size, give it highest priority\n    perfect_fit = bins_remain_cap == item\n    priorities[perfect_fit] = 1e9\n\n    # If item is larger than all bins, put it to largest bin\n    if np.all(bins_remain_cap < item):\n        max_cap_idx = np.argmax(bins_remain_cap)\n        priorities[max_cap_idx] = 0 # Neutral Priority if all bins are unfit.\n\n    return priorities",
    "response_id": 22,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Rule out bins that cannot fit the item.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Very low priority\n\n    # 2. Best Fit Criterion: Prioritize bins with the smallest remaining space after placing the item.\n    #    This encourages filling bins as much as possible.\n    feasible_mask = ~infeasible_mask\n    remaining_space = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_space  # Smaller remaining space -> higher priority\n\n    # 3. Tie-breaking: If multiple bins have the same remaining space, prioritize bins with larger original capacity.\n    # This step requires knowing the original capacity (can be passed as another argument or pre-calculated).\n    # For now, assume all bins have the same capacity, so skip this step to avoid introducing external parameters\n\n    # 4. Penalize almost-full bins to avoid creating slivers\n    almost_full_mask = (bins_remain_cap > item) & (bins_remain_cap < 1.1*item)\n    priorities[almost_full_mask] -= 0.5\n\n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First-Fit Decreasing inspired priority\n    # Give high priority to bins that can accommodate the item\n    # and have relatively low remaining capacity.\n    \n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Prioritize bins with tighter fit\n            priorities[i] = 1 / (cap - item + 1e-9) # Avoid division by zero\n            # Boost the priority slightly if the remaining capacity is a substantial fraction of bin size, \n            # indicating it might be better to fill this one somewhat than leave it mostly empty\n            # Note: This is equivalent to trying best-fit from the bin that could accept it\n            priorities[i] += 0.1 * (1 - (cap - item)/bins_remain_cap.max())  # Normalize by max capacity for reasonable boost\n            \n    # Penalize bins that are too full and won't accommodate the item\n    # This part is implicitly taken care of as priorities array is initialized with zero. We only assign priority if bins can accept it.\n    \n    return priorities",
    "response_id": 24,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996610999915 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Assign high priority if item fits\n    fit_mask = remaining_after_add >= 0\n    priorities[fit_mask] = 1  # Base priority for fitting bins\n\n    # Prioritize bins that fit the item with less wasted space.\n    wasted_space = remaining_after_add[fit_mask]\n    priorities[fit_mask] += 1 / (wasted_space + 0.0001)  # Avoid division by zero\n\n    # Bonus to nearly full bins (minimize fragmentation)\n    nearly_full_mask = (bins_remain_cap > item) & (bins_remain_cap < 2 * item) #Bins that are nearly full\n    priorities[nearly_full_mask] += 0.5\n\n    # Negative priority if item doesn't fit\n    no_fit_mask = remaining_after_add < 0\n    priorities[no_fit_mask] = -1e9  # Very low priority for non-fitting bins\n\n    return priorities",
    "response_id": 25,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins that can fit the item exactly or with minimal waste.\n    # Also penalize bins where the item almost fills the bin but leaves a tiny gap.\n\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            waste = cap - item\n            if waste == 0:  # Perfect fit\n                priorities[i] = 1000  # Extremely high priority for perfect fit\n            else:\n                priorities[i] = 1 / (waste + 0.0001)  # Inverse of waste, prevents division by zero\n\n            # Penalize \"almost full\" bins (e.g., waste is very small, but not zero)\n            if 0 < waste < 0.1:\n                 priorities[i] *= 0.5  # Reduce priority\n\n        else:\n            priorities[i] = -100  # Very low priority if it doesn't fit\n\n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # If item fits, prioritize bins with tighter fit (minimize wasted space).\n            wasted_space = cap - item\n            priorities[i] = 1 / (wasted_space + 1e-9)  # Avoid division by zero\n            # Further prioritize bins that are already partially full, but not too full\n            if cap < 0.9:\n                priorities[i] += cap # the fuller it is the more prioritized it is.\n        else:\n            priorities[i] = -np.inf  # Item doesn't fit, lowest priority\n            \n    return priorities",
    "response_id": 27,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing inspired priority: Give preference to bins that can fit the item with minimal waste\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = (cap - item) / cap  # Smaller waste is higher priority\n\n    # Give a boost to bins that are almost full (to consolidate items) but can still fit\n    almost_full_threshold = 0.1  # Tune this parameter. Higher means stricter \"almost full\" definition.\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item and cap <= (item + almost_full_threshold):\n            priorities[i] += 0.5  # Add a constant boost if it's almost full\n\n    # Penalize bins that will become too empty after adding the item\n    too_empty_threshold = 0.6  # Tune this parameter\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item and (cap - item) > (too_empty_threshold * np.max(bins_remain_cap)):\n             priorities[i] -= 0.3\n\n    #Very small remaining caps (but large enough to accomodate item), give them higher priority\n    min_fill_threshold = 0.05 #Tune this parameter\n    for i, cap in enumerate(bins_remain_cap):\n        if cap>= item and cap < min_fill_threshold:\n            priorities[i]+= 0.7\n    return priorities",
    "response_id": 28,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997602000076 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First-Fit Decreasing inspired heuristic:\n    # High priority to bins that can fit the item almost perfectly\n    # Penalize bins that would waste too much space\n    \n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = cap - item\n            \n            # Priority is higher if waste is smaller (but not zero)\n            # and decreases as item size increases\n            if waste > 0:\n                priorities[i] = (1 / (waste + 0.0001)) # avoid zero division\n            else:\n                # Perfect fit gets very high priority\n                priorities[i] = 1000 #arbitrary high value\n\n            # If waste is too large, drastically reduce priority\n            if waste > 0.5 * cap:  # e.g., don't leave half the bin empty for a tiny item\n                priorities[i] *= 0.1  # Lower priority significantly\n\n        else:\n            priorities[i] = -1000 # Very low priority, can't fit\n\n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  }
]