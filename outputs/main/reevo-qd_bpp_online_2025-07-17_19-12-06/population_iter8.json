[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate how full the bin would be if the item was added\n            fill_ratio = item / cap\n            # Prioritize bins that would be filled to a higher degree\n            # but avoid filling them completely. A perfect fit is ideal\n            priorities[i] = 1 / abs(fill_ratio - 0.95) # close to 1 is better.\n            #If item exactly fits in the bin assign the highest priority\n            if abs(fill_ratio - 1) < 1e-6:\n                priorities[i] = 1000\n        else:\n            priorities[i] = -1 # negative priority since it can not be fit\n    return priorities",
    "response_id": 12,
    "obj": 4.038691663342641,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 110.44611534953322,
    "mi": 78.81492371877928,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate how full the bin would be if the item was added\n            fill_ratio = item / cap\n            # Prioritize bins that would be filled to a higher degree\n            # but avoid filling them completely. A perfect fit is ideal\n            priorities[i] = 1 / abs(fill_ratio - 0.95) # close to 1 is better.\n            #If item exactly fits in the bin assign the highest priority\n            if abs(fill_ratio - 1) < 1e-6:\n                priorities[i] = 1000\n            # Slightly penalize almost full bins to avoid creating tiny waste\n            elif fill_ratio > 0.98:\n                priorities[i] *= 0.9\n\n        else:\n            priorities[i] = -1 # negative priority since it can not be fit\n    return priorities",
    "response_id": 4,
    "obj": 4.038691663342641,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 187.48684196024655,
    "mi": 77.72637944918979,
    "token_count": 152.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = 1.0  # Assuming bins have a capacity of 1.0\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate remaining capacity after adding the item\n            remaining_cap = cap - item\n            utilization = (bin_size - remaining_cap) / bin_size\n\n            # Reward perfect fits strongly\n            if abs(remaining_cap) < 1e-6:\n                priorities[i] = 1000.0\n\n            # Reward near-perfect fits\n            elif remaining_cap < 0.1:\n                priorities[i] = 500.0 * (1 - remaining_cap / 0.1) # scales between 500 and 0 linearly\n\n            # Otherwise, prioritize higher utilization, but penalize waste\n            else:\n                waste_penalty = remaining_cap * 10  # Higher waste penalty\n                priorities[i] = 100 * utilization - waste_penalty # utilization is between 0 and 1\n        else:\n            # Huge penalty for infeasibility\n            priorities[i] = -1000.0\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 204.32967235008786,
    "mi": 82.96962549437403,
    "token_count": 176.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate how full the bin would be if the item was added\n            fill_ratio = item / cap\n            # Prioritize bins that would be filled to a higher degree\n            # but avoid filling them completely. A perfect fit is ideal\n            priorities[i] = 1 / abs(fill_ratio - 0.95)  # close to 1 is better.\n            \n            #If item exactly fits in the bin assign the highest priority\n            if abs(fill_ratio - 1) < 1e-6:\n                priorities[i] = 1000\n            # Slightly penalize almost full bins to avoid creating tiny waste\n            elif fill_ratio > 0.98:\n                priorities[i] *= 0.9\n            # Give some bonus for filling more than half.\n            elif fill_ratio > 0.5:\n                priorities[i] *= 1.1\n            \n        else:\n            priorities[i] = -1  # negative priority since it can not be fit\n    return priorities",
    "response_id": 2,
    "obj": 4.038691663342641,
    "SLOC": 19.0,
    "cyclomatic_complexity": 6.0,
    "halstead": 213.7511637856132,
    "mi": 80.87762242694808,
    "token_count": 194.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate how full the bin would be if the item was added\n            fill_ratio = item / cap\n\n            # Reward near-full bins (around 95%)\n            near_full_reward = 1 / abs(fill_ratio - 0.95)\n\n            # Heavily reward perfect fits\n            perfect_fit_reward = 0\n            if abs(item - cap) < 1e-6:\n                perfect_fit_reward = 1000\n\n            # Combine the rewards, weighting perfect fits higher\n            priorities[i] = near_full_reward + perfect_fit_reward\n\n            # Scale down if the bin will be overfilled by a small amount\n            if fill_ratio > 1.0:\n                priorities[i] = -1  # Infeasible\n        else:\n            priorities[i] = -1  # Infeasible\n\n    return priorities",
    "response_id": 1,
    "obj": 4.038691663342641,
    "SLOC": 18.0,
    "cyclomatic_complexity": 6.0,
    "halstead": 249.9824559469954,
    "mi": 82.79047538667952,
    "token_count": 179.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate how full the bin would be if the item was added\n            fill_ratio = item / cap\n            # Prioritize bins that would be filled to a higher degree\n            # but avoid filling them completely. A perfect fit is ideal\n            priorities[i] = 1 / abs(fill_ratio - 0.95) # close to 1 is better.\n            #If item exactly fits in the bin assign the highest priority\n            if abs(fill_ratio - 1) < 1e-6:\n                priorities[i] = 1000\n            # Slightly penalize bins that are too empty after adding the item.\n            remaining_ratio = (cap - item) / cap\n            priorities[i] -= max(0, 5 * (remaining_ratio - 0.2)) #trying to avoid too empty bins.\n\n        else:\n            priorities[i] = -1 # negative priority since it can not be fit\n    return priorities",
    "response_id": 3,
    "obj": 4.038691663342641,
    "SLOC": 15.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 123.18989788986397,
    "mi": 84.98809771344631,
    "token_count": 150.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response4.txt_stdout.txt",
    "code_path": "problem_iter7_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            remaining = cap - item\n            if remaining < 0.0001:  # Perfect fit\n                priorities[i] = 1000.0\n            elif remaining / cap < 0.05:  # Near perfect fit\n                priorities[i] = 500.0\n            elif remaining / cap > 0.95:  # Near overflow (very bad)\n                priorities[i] = -200.0\n            else:\n                fill_ratio = item / cap\n                priorities[i] = 100.0 * fill_ratio  # Reward filling, but not excessively\n        else:\n            priorities[i] = -1000.0  # Cannot fit\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 6.0,
    "halstead": 131.68575291675114,
    "mi": 85.78725800004004,
    "token_count": 155.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Calculate how full the bin would be if the item was added\n            fill_ratio = item / cap\n\n            # Reward near-full bins\n            near_full_reward = 0\n            if fill_ratio > 0.7 and fill_ratio <= 1.0:\n                near_full_reward = 10 * (fill_ratio - 0.7)  # Higher reward closer to 1\n\n            # Heavily reward perfect fits\n            perfect_fit_reward = 0\n            if abs(item - cap) < 1e-6:\n                perfect_fit_reward = 1000\n\n            # Combine the rewards\n            priorities[i] = near_full_reward + perfect_fit_reward\n\n\n        else:\n            priorities[i] = -1  # Infeasible\n\n    return priorities",
    "response_id": 8,
    "obj": 3.9888312724371757,
    "SLOC": 19.0,
    "cyclomatic_complexity": 6.0,
    "halstead": 272.4807970712782,
    "mi": 81.93824929792349,
    "token_count": 199.0,
    "exec_success": true
  }
]