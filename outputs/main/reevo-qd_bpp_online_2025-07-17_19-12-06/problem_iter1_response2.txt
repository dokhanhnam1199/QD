```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Feasibility check: Assign very low priority to bins that cannot fit the item.
    infeasible_mask = bins_remain_cap < item
    priorities[infeasible_mask] = -np.inf

    # Best Fit logic: Prioritize bins that have just enough space for the item.
    # Avoid creating too much wasted space.
    diff = bins_remain_cap - item
    
    #Bins can take items have more priority
    feasible_mask = bins_remain_cap >= item
    priorities[feasible_mask] = -diff[feasible_mask]
    
    # Use a small value to avoid division by zero when bins are filled
    epsilon = 1e-6

    # Reward bins that are relatively empty (more opportunity to pack other items) but can still take the current item
    normalized_remaining_cap = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)
    priorities[feasible_mask] += 0.5 * normalized_remaining_cap[feasible_mask]  # Scale the reward, don't overpower best-fit

    # Penalize bins with nearly full capacity
    nearly_full_threshold = 0.9  # Can be adjusted based on performance
    nearly_full_mask = (bins_remain_cap > item) & (normalized_remaining_cap > nearly_full_threshold) # only apply if bin can accomodate items
    priorities[nearly_full_mask] -= 0.2 * normalized_remaining_cap[nearly_full_mask] #Scale the penalty down
    
    return priorities
```
