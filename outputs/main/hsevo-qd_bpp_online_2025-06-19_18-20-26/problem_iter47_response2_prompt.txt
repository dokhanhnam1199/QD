{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n                 size_diff_epsilon: float = 0.0004973923711338349,\n                 waste_penalty_base: float = 5.468478104408493,\n                 waste_penalty_multiplier: float = 13.38944774829674,\n                 extreme_utilization_threshold_low: float = 0.33963284414439665,\n                 extreme_utilization_threshold_high: float = 0.8362854997802416,\n                 extreme_utilization_penalty_low_multiplier: float = 10.315888762295863,\n                 extreme_utilization_penalty_high_multiplier: float = 11.796404081271609,\n                 extreme_utilization_penalty_mid_multiplier: float = 13.98241267866572,\n                 fullness_bonus_exponent: float = 3.181974175037097,\n                 bonus_strength_base: float = 2.3328187802706704,\n                 bonus_strength_multiplier: float = 4.443975905618798) -> np.ndarray:\n    \"\"\"\n    Combines best-fit, waste minimization, bin balancing, and adaptive weights based on problem state.\n    Prioritizes bins dynamically for effective online bin packing.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    priorities[~valid_bins] = -np.inf\n\n    # Adaptive Best-Fit\n    size_diff = bins_remain_cap - item\n    capacity_ratio = bins_remain_cap / np.max(bins_remain_cap)\n    granularity_factor = np.mean(capacity_ratio)\n    priorities[valid_bins] += (1 / (size_diff[valid_bins] + size_diff_epsilon)**(granularity_factor + 1))\n\n    # Dynamic Waste Minimization\n    remaining_after_fit = bins_remain_cap[valid_bins] - item\n    waste_ratio = remaining_after_fit / bins_remain_cap[valid_bins]\n    item_size_factor = item / np.max(bins_remain_cap)\n    waste_penalty_strength = waste_penalty_base + waste_penalty_multiplier * item_size_factor\n    small_waste_penalty = np.exp(-waste_penalty_strength * remaining_after_fit * item)\n    priorities[valid_bins] -= small_waste_penalty\n\n    # Bin Balancing\n    utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    overall_utilization = np.mean(utilization)\n    if overall_utilization < extreme_utilization_threshold_low:\n        extreme_utilization_penalty = extreme_utilization_penalty_low_multiplier * np.abs(utilization - 0.2)\n    elif overall_utilization > extreme_utilization_threshold_high:\n        extreme_utilization_penalty = extreme_utilization_penalty_high_multiplier * np.abs(utilization - 0.8)\n    else:\n        extreme_utilization_penalty = extreme_utilization_penalty_mid_multiplier * np.abs(utilization - 0.5)\n    priorities[valid_bins] -= extreme_utilization_penalty[valid_bins]\n\n    # Adaptive Fullness Bonus\n    fullness_level = 1 - capacity_ratio\n    fullness_bonus = np.exp(-fullness_bonus_exponent * np.abs(fullness_level - 1))\n    bonus_strength = bonus_strength_base + bonus_strength_multiplier * item_size_factor\n    priorities[valid_bins] += bonus_strength * fullness_bonus[valid_bins] * (1 - np.mean(utilization))\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- *   Comparing (1st) vs (20th), we see that the best heuristic uses a combination of best-fit, waste minimization, bin balancing, and adaptive weights, while the worst uses only the ratio of item size to remaining bin capacity.\n*   Comparing (2nd) vs (19th), we see that the second-best heuristic incorporates adaptive adjustments and problem-state awareness. In contrast, the second-worst heuristic combines FFD approximation, waste minimization, and capacity ratio but lacks adaptive weighting.\n*   Comparing (1st) vs (2nd), we don't see any differences because they're exactly the same.\n*   Comparing (3rd) vs (4th), we don't see any differences because they're exactly the same.\n*   Comparing (second worst) vs (worst), we see that the second worst adds waste minimization. Overall: adaptive weights and dynamic adjustments based on problem state appear crucial for superior performance. Best-fit, waste minimization, and bin balancing are common components. Simpler heuristics that only consider capacity ratios tend to perform worse. Furthermore, edge case handling and diversification are also valuable. Normalizing the final priorities is important for stable and comparable results.\n- \nOkay, let's refine \"Current Self-Reflection\" to design better heuristics, focusing on actionability and avoiding the pitfalls of ineffective reflections. We'll structure this to be immediately useful for design.\n\n*   **Keywords:** Problem state awareness, dynamic adaptation, feedback integration, multi-faceted evaluation.\n\n*   **Advice:** Focus on creating heuristics that *actively monitor* the problem state (e.g., bin utilization distribution, item size statistics, solution progress) and *dynamically adjust* their behavior based on this information. Build in mechanisms for the heuristic to \"learn\" during its execution and modify its strategy accordingly. Use multi-faceted evaluation of solutions, not just single metrics.\n\n*   **Avoid:** Vague statements about \"considering multiple factors\" or \"handling edge cases\" without specifying *how* this will be achieved. Avoid simply reiterating known strategies without proposing novel adaptations or combinations. Avoid superficial mentions of \"dynamic adjustment\" without detailing the specific adaptation mechanisms.\n\n*   **Explanation:** The key to effective self-reflection for heuristic design is to move beyond general principles and focus on concrete mechanisms for observation, adaptation, and evaluation. Aim to design heuristics that are genuinely *responsive* to the evolving problem state, not just statically defined with a few adjustable parameters.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}