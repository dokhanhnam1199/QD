{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit, waste minimization, adaptive bin balancing, and fullness bonus.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    priorities[~valid_bins] = -np.inf\n\n    # Best-Fit\n    size_diff = bins_remain_cap - item\n    priorities[valid_bins] += 1.0 / (size_diff[valid_bins] + 0.0001)**2\n\n    # Waste Minimization\n    remaining_after_fit = bins_remain_cap[valid_bins] - item\n    small_waste_penalty = np.exp(-10 * remaining_after_fit * item)\n    priorities[valid_bins] -= small_waste_penalty\n\n    # Bin Balancing\n    utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    overall_utilization = np.mean(utilization)\n\n    if overall_utilization < 0.3:\n        extreme_utilization_penalty = 5 * np.abs(utilization - 0.2)\n    elif overall_utilization > 0.7:\n        extreme_utilization_penalty = 15 * np.abs(utilization - 0.8)\n    else:\n        extreme_utilization_penalty = 10 * np.abs(utilization - 0.5)\n\n    priorities[valid_bins] -= extreme_utilization_penalty[valid_bins]\n\n    # Adaptive Fullness Bonus\n    fullness_bonus = np.exp(-5 * np.abs(bins_remain_cap / np.max(bins_remain_cap) - 0))\n\n    if overall_utilization < 0.5:\n        priorities[valid_bins] += 2 * fullness_bonus[valid_bins] * (1 - overall_utilization)\n    elif overall_utilization < 0.8 :\n        priorities[valid_bins] +=  fullness_bonus[valid_bins] * (1 - overall_utilization)\n    else:\n        priorities[valid_bins] += 0.5 * fullness_bonus[valid_bins] *(1 - overall_utilization)\n    \n    # Adaptive Waste Penalty Adjustment\n    if item > 0.5: # large item\n        if overall_utilization > 0.6:\n            priorities[valid_bins] -= 2 * small_waste_penalty # penalize small waste more when bins are full\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    A priority function for online bin packing that dynamically adjusts\n    its behavior based on the item size relative to the average remaining\n    bin capacity, incorporating best-fit, waste minimization, bin balancing,\n    and dynamic adjustment of weights to promote robustness.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    priorities[~valid_bins] = -np.inf\n\n    # Adaptive weighting based on item size relative to average bin capacity\n    avg_bin_capacity = np.mean(bins_remain_cap)\n    item_ratio = item / avg_bin_capacity\n\n    # Best-Fit component, scaled dynamically.\n    size_diff = bins_remain_cap - item\n    priorities[valid_bins] += (1.0 / (size_diff[valid_bins] + 0.0001)**2) * (1 + item_ratio)\n\n    # Waste Minimization: Discourage very small waste, dynamically penalized.\n    remaining_after_fit = bins_remain_cap[valid_bins] - item\n    waste_penalty_factor = 10 + 5 * item_ratio  # Higher penalty for larger items\n    small_waste_penalty = np.exp(-waste_penalty_factor * remaining_after_fit * item)\n    priorities[valid_bins] -= small_waste_penalty\n\n    # Bin Balancing using utilization and overall utilization: Dynamically adjusted\n    utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    overall_utilization = np.mean(utilization)\n\n    # Dynamic Bin Balancing with sharper penalties\n    if overall_utilization < 0.3:\n        extreme_utilization_penalty = 8 * np.abs(utilization - 0.2) * (1 + item_ratio)  # Encourage filling more aggressively\n    elif overall_utilization > 0.7:\n        extreme_utilization_penalty = 20 * np.abs(utilization - 0.8) * (1 + item_ratio) #Discourage further filling more aggressively\n    else:\n        extreme_utilization_penalty = 12 * np.abs(utilization - 0.5) * (1 + item_ratio)  #Balance, more sensitive\n\n    priorities[valid_bins] -= extreme_utilization_penalty[valid_bins]\n\n    # Adaptive component: Bonus to bins close to full, dynamically adjusted.\n    fullness_bonus = np.exp(-5 * np.abs(bins_remain_cap / np.max(bins_remain_cap) - 0))\n    bonus_scaling = 2 * (1 - overall_utilization) * (1 + item_ratio)\n\n    if overall_utilization < 0.5:\n        priorities[valid_bins] += bonus_scaling * fullness_bonus[valid_bins]\n    elif overall_utilization < 0.8 :\n         priorities[valid_bins] +=  0.75 * bonus_scaling * fullness_bonus[valid_bins]  #Reduced bonus compared to v1\n    else:\n        priorities[valid_bins] += 0.25 * bonus_scaling * fullness_bonus[valid_bins] #further reduced bonus\n\n    # Edge Case Handling: Favor bins close to item size, but not too close to full capacity\n    close_to_item = np.abs(bins_remain_cap - item) / item\n    close_to_full = bins_remain_cap / np.max(bins_remain_cap)\n\n    edge_case_bonus = np.exp(-5 * close_to_item)  * (close_to_full > 0.1) # boost bins with remain capacity close to item and not close to full\n    priorities[valid_bins] += 0.5 * edge_case_bonus[valid_bins]\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic involves a complex combination of best-fit, waste minimization, bin balancing, and adaptive bonuses, while the worst is a simple logarithmic ratio. (2nd best) vs (second worst) shows a similar trend, with the adaptive components being absent in the second worst. Comparing (1st) vs (2nd), we see the docstrings are almost exactly identical, indicating that the difference lies within minor implementation details or parameter choices. (3rd) vs (4th) reveals a shift towards including item-size awareness, suggesting this is a key improvement. Comparing (second worst) vs (worst), we see the simple calculation based on log ratios struggles in performance due to lack of waste management and bin balancing. Overall: Better heuristics incorporate multiple factors and adapt their behavior based on the current state of the bins and the item being packed. Adaptive weighting, dynamic waste thresholding, and item-size awareness are recurring themes in the top-performing heuristics.\n- \nOkay, let's redefine self-reflection for better heuristic design, specifically avoiding the pitfalls outlined in \"Ineffective Self-Reflection\":\n\n*   **Keywords:** Problem State, Dynamic Adaptation, Granularity, Performance Evaluation, Edge Case Analysis.\n\n*   **Advice:** Prioritize fine-grained problem state analysis to inform dynamic parameter adjustments. Implement a robust performance evaluation framework with edge case testing and performance metrics.\n\n*   **Avoid:** Overly simplistic combinations of known strategies without problem-state awareness. Avoid fixed penalties or bonuses without dynamic adjustment.\n\n*   **Explanation:** Focus on designing heuristics that intelligently react to nuances in the problem instance. Test comprehensively and avoid pre-determined weights.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}