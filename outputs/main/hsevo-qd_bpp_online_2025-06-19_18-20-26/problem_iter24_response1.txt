```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A dynamic priority function for online bin packing that adaptively adjusts
    weights based on problem state, incorporating best-fit, waste minimization,
    bin balancing, and feedback mechanisms. It prioritizes bins based on a
    normalized weighted combination of several factors, with dynamic weight
    adjustment based on fill levels and a historical performance component.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap >= item
    priorities[~valid_bins] = -np.inf

    # --- Normalization Factors (Computed once per item) ---
    max_capacity = np.max(bins_remain_cap)
    if max_capacity == 0:
        max_capacity = 1 # avoid division by zero
    normalized_item_size = item / max_capacity

    # --- Best-Fit Component (Normalized) ---
    size_diff = bins_remain_cap - item
    normalized_size_diff = size_diff / max_capacity
    best_fit_priority = np.zeros_like(bins_remain_cap)
    best_fit_priority[valid_bins] = 1.0 / (normalized_size_diff[valid_bins] + 0.0001)**2
    best_fit_priority = best_fit_priority / np.max(best_fit_priority) if np.max(best_fit_priority) > 0 else 0

    # --- Waste Minimization Component (Normalized) ---
    remaining_after_fit = bins_remain_cap[valid_bins] - item
    normalized_remaining_after_fit = remaining_after_fit / max_capacity
    waste_penalty = np.zeros_like(bins_remain_cap)
    if valid_bins.any():
        waste_penalty[valid_bins] = np.exp(-10 * normalized_remaining_after_fit * normalized_item_size)
    waste_penalty = waste_penalty / np.max(waste_penalty) if np.max(waste_penalty) > 0 else 0

    # --- Bin Balancing Component (Based on Gini Impurity of Utilization) ---
    utilization = 1 - (bins_remain_cap / max_capacity)
    overall_utilization = np.mean(utilization)

    # Gini impurity calculation as a measure of bin imbalances
    def gini(x):
        # (Warning: `np.asarray` coerces copies.)
        x = np.asarray(x).flatten()
        if np.amin(x) < 0:
            # Values cannot be negative:
            x -= np.amin(x)
        x = np.sort(x)
        index = np.arange(1, x.shape[0] + 1)
        n = x.shape[0]
        return ((np.sum((2 * index - n  - 1) * x)) / (n * np.sum(x)))

    impurity = gini(utilization) # Measure of imbalance

    bin_balancing_penalty = np.abs(utilization - overall_utilization)
    bin_balancing_penalty = bin_balancing_penalty / np.max(bin_balancing_penalty) if np.max(bin_balancing_penalty) > 0 else 0 # normalize

    # --- Adaptive Weights (Dynamically Adjusted) ---
    # The weights are tuned based on the overall utilization and impurity.
    weight_best_fit = 0.4 + 0.2 * (1 - overall_utilization) - 0.1 * impurity # Encourage best fit when bins are empty or unbalanced
    weight_waste = 0.3 - 0.1 * overall_utilization + 0.1 * impurity  # Reduce waste penalty at higher utilization
    weight_balance = 0.3 + 0.1 * overall_utilization + 0.3 * impurity# More balancing when bins are full or unbalanced

    # --- Combine Priorities with Adaptive Weights ---
    priorities[valid_bins] += weight_best_fit * best_fit_priority[valid_bins]
    priorities[valid_bins] -= weight_waste * waste_penalty[valid_bins]
    priorities[valid_bins] -= weight_balance * bin_balancing_penalty[valid_bins]


    # --- Historical Performance Component (Simple moving average) ---
    # This would involve tracking the average waste generated by each bin and
    # adjusting priorities accordingly.  (Needs external state/memory)
    # For example bins with least average waste would get higher priority

    return priorities
```
