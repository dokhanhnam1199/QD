{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    An enhanced priority function for online bin packing that combines\n    best-fit considerations with dynamic waste management, bin balancing,\n    and a learning component.  It prioritizes bins based on a weighted\n    combination of several factors, including space utilization,\n    waste minimization, and bin balancing.  The weights are adjusted\n    dynamically based on the overall fill level of the bins.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    priorities[~valid_bins] = -np.inf\n\n    # Best-Fit component with a small bias towards more full bins.\n    size_diff = bins_remain_cap - item\n    priorities[valid_bins] += 1.0 / (size_diff[valid_bins] + 0.0001)**2\n\n    # Waste Minimization:  Discourage very small waste\n    remaining_after_fit = bins_remain_cap[valid_bins] - item\n    small_waste_penalty = np.exp(-10 * remaining_after_fit * item)\n    priorities[valid_bins] -= small_waste_penalty\n\n    # Bin Balancing using utilization and overall utilization:\n    utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    overall_utilization = np.mean(utilization)\n\n    # Dynamically adjust bin balancing based on fill level.\n    if overall_utilization < 0.3:\n        extreme_utilization_penalty = 5 * np.abs(utilization - 0.2)  # Encourage filling\n    elif overall_utilization > 0.7:\n        extreme_utilization_penalty = 15 * np.abs(utilization - 0.8) #Discourage further filling\n    else:\n        extreme_utilization_penalty = 10 * np.abs(utilization - 0.5) #Balance\n    priorities[valid_bins] -= extreme_utilization_penalty[valid_bins]\n\n\n    # Adaptive component:  Add a bonus to bins close to full\n    # Weight the bonus dynamically based on overall utilization\n\n    fullness_bonus = np.exp(-5 * np.abs(bins_remain_cap / np.max(bins_remain_cap) - 0))\n\n    if overall_utilization < 0.5:\n        priorities[valid_bins] += 2 * fullness_bonus[valid_bins] * (1 - overall_utilization) #more bonus to almost full bins\n    elif overall_utilization < 0.8 :\n         priorities[valid_bins] +=  fullness_bonus[valid_bins] * (1 - overall_utilization) #more bonus to almost full bins\n    else:\n        priorities[valid_bins] += 0.5 * fullness_bonus[valid_bins] *(1 - overall_utilization) #even lower bonus\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines FFD approximation, waste minimization, and capacity ratio.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    # FFD Approximation + Capacity Ratio\n    ratios = item / bins_remain_cap\n    priorities[valid_bins] = -np.log(ratios[valid_bins]) / (np.abs(bins_remain_cap[valid_bins] - item) + 0.0001) #Higher priority to close size\n\n    # Waste Minimization\n    remaining_after_fit = bins_remain_cap - item\n    small_waste_penalty = np.exp(-10 * remaining_after_fit)\n    priorities[valid_bins] -= small_waste_penalty[valid_bins]\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic incorporates best-fit, waste minimization, dynamic bin balancing, and an adaptive component that gives bonus to almost full bins, while the worst only considers the ratio of item size to remaining bin capacity. (2nd) to (4th) are identical to the best. Comparing (1st) vs (5th), the best includes an adaptive component based on overall utilization that adjust fullness bonus, (5th) only has  best-fit, waste minimization, bin balancing. Comparing (5th) vs (17th), (5th) includes best-fit, waste minimization, bin balancing, while (17th) only calculates log ratios. Comparing (8th) vs (17th), (8th) adds small constant to size_diff and uses more params.\n\nOverall:\n\n1.  **Multi-faceted Prioritization:** Top heuristics combine multiple factors like best-fit, waste minimization, and bin balancing.\n2.  **Adaptive Strategies:** Dynamic adjustment of parameters (e.g., utilization penalty, fullness bonus) based on overall bin fill levels improves performance.\n3. **Fine-grained Control**: Introduce params like `size_diff_epsilon`, `small_waste_penalty_factor`, `extreme_utilization_penalty_factor`, `target_utilization` to provide a fine-grained control to users.\n- \nHere's a refined perspective on \"Current Self-Reflection\" for designing better heuristics, focusing on actionable strategies:\n\n*   **Keywords:** Adaptive strategies, dynamic parameter tuning, factor integration, edge-case handling.\n\n*   **Advice:** Emphasize real-time adjustment of heuristic parameters based on ongoing performance feedback and problem-specific traits.\n\n*   **Avoid:** Static, pre-defined parameters and a sole reliance on existing strategies without adaptation.\n\n*   **Explanation:** Continuous monitoring and adaptation mechanisms are crucial. Design heuristics to learn and adjust during execution, refining their effectiveness.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}