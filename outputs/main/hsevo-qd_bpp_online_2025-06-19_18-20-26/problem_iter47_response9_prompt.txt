{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    A refined priority function that focuses on dynamically adjusting\n    the best-fit and waste minimization aspects based on overall\n    bin utilization. It also adds a mechanism to occasionally open new bins\n    even when existing ones have space, promoting exploration and potentially\n    avoiding local optima.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    priorities[~valid_bins] = -np.inf  # Invalidate bins that can't fit the item\n\n    # Best-Fit component: Prioritize bins with minimal remaining space\n    size_diff = bins_remain_cap - item\n    priorities[valid_bins] += 1.0 / (size_diff[valid_bins] + 0.0001) #avoid division by zero\n\n    # Waste Minimization: Penalize small waste, dynamically adjusted\n    remaining_after_fit = bins_remain_cap[valid_bins] - item\n    overall_utilization = np.mean(1 - (bins_remain_cap / np.max(bins_remain_cap))) if bins_remain_cap.size > 0 else 0\n    waste_penalty_factor = 5 + 10 * overall_utilization  # Adjust penalty based on fill level\n    small_waste_penalty = np.exp(-waste_penalty_factor * remaining_after_fit * item)\n    priorities[valid_bins] -= small_waste_penalty\n\n    # Dynamic Bin Balancing: Adjust encouragement/discouragement of filling\n    utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    bin_balancing_factor = 10  # Adjust the strength of bin balancing\n\n    if overall_utilization < 0.4:\n        extreme_utilization_penalty = bin_balancing_factor * np.abs(utilization - 0.2)\n    elif overall_utilization > 0.7:\n        extreme_utilization_penalty = bin_balancing_factor * np.abs(utilization - 0.8)\n    else:\n        extreme_utilization_penalty = bin_balancing_factor * np.abs(utilization - 0.5)\n    priorities[valid_bins] -= extreme_utilization_penalty[valid_bins]\n\n    # Exploration: Introduce a small probability of using a new bin\n    # even if existing bins have space.\n    exploration_probability = 0.01  #tune\n    if np.random.rand() < exploration_probability:\n        priorities[:] = -np.inf\n        #find the index of smallest remaining capacity.\n        smallest_cap_index = np.argmin(bins_remain_cap)\n        priorities[smallest_cap_index] = 1 #set only it to valid\n        valid_bins[smallest_cap_index] = True #need this to avoid runtime error\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines FFD approximation, waste minimization, and capacity ratio.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    # FFD Approximation + Capacity Ratio\n    ratios = item / bins_remain_cap\n    priorities[valid_bins] = -np.log(ratios[valid_bins]) / (np.abs(bins_remain_cap[valid_bins] - item) + 0.0001) #Higher priority to close size\n\n    # Waste Minimization\n    remaining_after_fit = bins_remain_cap - item\n    small_waste_penalty = np.exp(-10 * remaining_after_fit)\n    priorities[valid_bins] -= small_waste_penalty[valid_bins]\n\n    return priorities\n\n### Analyze & experience\n- *   Comparing (1st) vs (20th), we see that the best heuristic uses a combination of best-fit, waste minimization, bin balancing, and adaptive weights, while the worst uses only the ratio of item size to remaining bin capacity.\n*   Comparing (2nd) vs (19th), we see that the second-best heuristic incorporates adaptive adjustments and problem-state awareness. In contrast, the second-worst heuristic combines FFD approximation, waste minimization, and capacity ratio but lacks adaptive weighting.\n*   Comparing (1st) vs (2nd), we don't see any differences because they're exactly the same.\n*   Comparing (3rd) vs (4th), we don't see any differences because they're exactly the same.\n*   Comparing (second worst) vs (worst), we see that the second worst adds waste minimization. Overall: adaptive weights and dynamic adjustments based on problem state appear crucial for superior performance. Best-fit, waste minimization, and bin balancing are common components. Simpler heuristics that only consider capacity ratios tend to perform worse. Furthermore, edge case handling and diversification are also valuable. Normalizing the final priorities is important for stable and comparable results.\n- \nOkay, let's refine \"Current Self-Reflection\" to design better heuristics, focusing on actionability and avoiding the pitfalls of ineffective reflections. We'll structure this to be immediately useful for design.\n\n*   **Keywords:** Problem state awareness, dynamic adaptation, feedback integration, multi-faceted evaluation.\n\n*   **Advice:** Focus on creating heuristics that *actively monitor* the problem state (e.g., bin utilization distribution, item size statistics, solution progress) and *dynamically adjust* their behavior based on this information. Build in mechanisms for the heuristic to \"learn\" during its execution and modify its strategy accordingly. Use multi-faceted evaluation of solutions, not just single metrics.\n\n*   **Avoid:** Vague statements about \"considering multiple factors\" or \"handling edge cases\" without specifying *how* this will be achieved. Avoid simply reiterating known strategies without proposing novel adaptations or combinations. Avoid superficial mentions of \"dynamic adjustment\" without detailing the specific adaptation mechanisms.\n\n*   **Explanation:** The key to effective self-reflection for heuristic design is to move beyond general principles and focus on concrete mechanisms for observation, adaptation, and evaluation. Aim to design heuristics that are genuinely *responsive* to the evolving problem state, not just statically defined with a few adjustable parameters.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}