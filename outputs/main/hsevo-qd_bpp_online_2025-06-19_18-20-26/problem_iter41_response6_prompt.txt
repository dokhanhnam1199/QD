{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    A priority function for online bin packing that combines best-fit,\n    waste minimization, bin balancing, and an adaptive component.  It dynamically\n    adjusts the weights of different factors based on the fill level of the bins and\n    the size of the current item.  This version introduces a bin activation strategy.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    priorities[~valid_bins] = -np.inf\n\n    # Best-Fit component with a bias towards more full bins (tuned).\n    size_diff = bins_remain_cap - item\n    priorities[valid_bins] += 1.5 / (size_diff[valid_bins] + 0.0001)**1.8\n\n    # Waste Minimization: Discourage very small and very large waste.\n    remaining_after_fit = bins_remain_cap[valid_bins] - item\n    small_waste_penalty = np.exp(-8 * remaining_after_fit / item)  # Normalize by item size\n    large_waste_penalty = np.exp(-5 * item / remaining_after_fit) #Added to discourage very large waste\n    priorities[valid_bins] -= (small_waste_penalty + large_waste_penalty) * 0.75\n\n\n    # Bin Balancing using utilization and overall utilization:\n    utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    overall_utilization = np.mean(utilization)\n\n    # Dynamically adjust bin balancing based on fill level.\n    if overall_utilization < 0.3:\n        extreme_utilization_penalty = 6 * np.abs(utilization - 0.2)  # Encourage filling\n    elif overall_utilization > 0.7:\n        extreme_utilization_penalty = 13 * np.abs(utilization - 0.8)  # Discourage further filling\n    else:\n        extreme_utilization_penalty = 9 * np.abs(utilization - 0.5)  # Balance\n    priorities[valid_bins] -= extreme_utilization_penalty[valid_bins]\n\n    # Adaptive component: Add a bonus to bins close to full\n    # Weight the bonus dynamically based on overall utilization and item size.\n    fullness_bonus = np.exp(-4 * np.abs(bins_remain_cap / np.max(bins_remain_cap) - 0.1))\n\n    if overall_utilization < 0.5:\n        priorities[valid_bins] += 1.8 * fullness_bonus[valid_bins] * (1 - overall_utilization) * (item/ np.max(bins_remain_cap)) # Adjusted bonus\n    elif overall_utilization < 0.8:\n        priorities[valid_bins] += 0.9 * fullness_bonus[valid_bins] * (1 - overall_utilization) * (item/ np.max(bins_remain_cap)) # Adjusted bonus\n    else:\n        priorities[valid_bins] += 0.4 * fullness_bonus[valid_bins] * (1 - overall_utilization) * (item/ np.max(bins_remain_cap)) # Adjusted bonus\n\n\n    #Bin Activation Strategy:  Prioritize empty or near-empty bins for large items\n    if item > 0.6 * np.max(bins_remain_cap):\n        empty_bin_bonus = np.exp(-2 * utilization)  #High bonus for emptier bins\n        priorities[valid_bins] += 2 * empty_bin_bonus[valid_bins]\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    A refined priority function for online bin packing, incorporating dynamic\n    weighting based on fill levels, waste minimization, and bin balancing,\n    with enhancements for robustness and adaptability.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    priorities[~valid_bins] = -np.inf\n\n    # 1. Best-Fit with Adjusted Sensitivity:\n    size_diff = bins_remain_cap - item\n    priorities[valid_bins] += 1.0 / (size_diff[valid_bins] + 0.001)**1.5 # Reduced exponent sensitivity\n\n    # 2. Dynamic Waste Minimization:\n    remaining_after_fit = bins_remain_cap[valid_bins] - item\n    waste_ratio = remaining_after_fit / np.max(bins_remain_cap)\n    waste_penalty = np.exp(5 * (waste_ratio - 0.25))  # Peak penalty around 25% waste\n    priorities[valid_bins] -= waste_penalty\n\n    # 3. Enhanced Bin Balancing with Adaptive Targets:\n    utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    overall_utilization = np.mean(utilization)\n    target_utilization = 0.6  # Start with a moderate target\n\n    # Adjust the target utilization based on overall fill level:\n    if overall_utilization < 0.4:\n        target_utilization = 0.8  # Encourage higher filling if bins are sparse\n    elif overall_utilization > 0.8:\n        target_utilization = 0.3 # Keep adding new bins if we already have a lot of bins filled\n\n    balance_penalty = 10 * np.abs(utilization - target_utilization)\n    priorities[valid_bins] -= balance_penalty[valid_bins]\n    # 4. Adaptive Fullness Bonus with Sigmoid Weighting\n    fullness_level = 1 - bins_remain_cap / np.max(bins_remain_cap)\n    fullness_bonus = np.exp(-5 * np.abs(fullness_level - 1))  # Max bonus for nearly full bins\n\n    # Sigmoid function to dynamically scale the bonus\n    sigmoid_weight = 1 / (1 + np.exp(10 * (overall_utilization - 0.5))) #sharp transition around 0.5\n    priorities[valid_bins] += 2 * sigmoid_weight * fullness_bonus[valid_bins]\n\n    # 5. Add a small randomization to break ties\n    priorities[valid_bins] += np.random.normal(0, 0.001, size=np.sum(valid_bins))\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the 1st incorporates best-fit, waste minimization, bin balancing, and adaptive fullness, while the 20th only uses a ratio of item size to bin capacity. (2nd best) vs (19th), the second best uses best-fit, waste minimization, dynamic bin balancing, and adaptive fullness bonus, while the 19th only uses FFD approximation and waste minimization. Comparing (1st) vs (2nd), we see similar functionality but the comments are more descriptive in the second heuristic. Comparing (3rd) vs (4th), both combine best-fit considerations with dynamic waste management, bin balancing, and learning, however, the third makes small adjustments to the best-fit to encourage more full bins. Comparing (second worst) vs (worst), the second worst implements waste minimization, first fit approximation, and bin balancing, while the worst one just implements a ratio. Overall: the better heuristics include more components such as best-fit, waste minimization, bin balancing and fullness, while the worse heuristics only consider a few components. Better heuristics use adaptive methods to dynamically adjust their weighting and parameters. Better heuristics include comprehensive edge case handling.\n- \nOkay, I understand. To redefine \"Current self-reflection\" for designing better bin packing heuristics, focusing on *avoiding* the pitfalls illustrated in the \"Ineffective self-reflection\" examples, we need a more targeted and insightful approach. Here's a breakdown:\n\n*   **Keywords:** *Systematic Exploration*, *Quantitative Evaluation*, *Iterative Refinement*, *Problem-Specific Adaptation*, *Performance Bottleneck Analysis*.\n\n*   **Advice:** Focus on designing experiments to *quantitatively* measure the impact of each component of your heuristic. Then prioritize adapting components that most improve performance. Design explicit tests to identify weakness and improve that part.\n\n*   **Avoid:** Vague statements about \"combining factors,\" \"adaptive parameters,\" or \"handling edge cases\" without specific plans for implementation, evaluation, or iteration. Also, avoid focusing on \"multiple relevant factors\". Also, *avoid* intuitive judgements over empirical data.\n\n*   **Explanation:** Instead of generally saying \"use adaptive parameters,\" define *how* the parameters will be adapted (e.g., a specific formula based on bin fill ratios), *why* that specific adaptation is expected to improve performance (a hypothesis), and *how* you will measure whether the adaptation actually achieves its goal (a controlled experiment).\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}