{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function incorporates several heuristics, with refinements over v1:\n\n    1. **Best Fit Decreasing (BFD) Emphasis:**  Prioritizes bins that offer the *tightest* fit\n       for the current item, more aggressively than v1. Aims for optimal space utilization\n       in each bin, reducing fragmentation.\n\n    2.  **Waste Minimization (Adaptive):**  Penalizes small waste, but the penalty *scales*\n        with item size.  Large items creating small waste are penalized more heavily, as\n        that waste is harder to fill later.\n\n    3.  **Bin Balancing (Dynamic):**  Adjusts the utilization penalty based on the *overall*\n        fill level of all bins. If bins are generally empty, encourages filling them more;\n        if bins are generally full, focuses on avoiding small waste.\n\n    4. **Penalty for Over-Utilized Bins:** Add a bigger penalty if bins are almost full before placing the current item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Best Fit Decreasing Emphasis\n    size_diff = bins_remain_cap - item\n    valid_bins = bins_remain_cap >= item\n    priorities[~valid_bins] = -np.inf\n\n    # Prioritize tight fits *much* more strongly than v1.\n    priorities[valid_bins] = 1.0 / (size_diff[valid_bins] + 0.0001)**2  # Squaring makes the difference more pronounced\n\n    # 2. Waste Minimization (Adaptive)\n    remaining_after_fit = bins_remain_cap - item\n    # Penalty scales with item size. Larger item = greater waste penalty\n    small_waste_penalty = np.exp(-10 * remaining_after_fit * item)\n    priorities[valid_bins] -= small_waste_penalty[valid_bins]\n\n    # 3. Bin Balancing (Dynamic)\n    utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))  # Fraction full\n    overall_utilization = np.mean(utilization)  # Average fill level of all bins.\n\n    # Adjust penalty based on overall utilization.\n    if overall_utilization < 0.3: # If bins are generally empty.\n        extreme_utilization_penalty = 5 * np.abs(utilization - 0.2) # Aim for 20% utilization.\n    elif overall_utilization > 0.7: # If bins are generally full.\n        extreme_utilization_penalty = 15 * np.abs(utilization - 0.8) # Aim for 80% utilization and avoid small waste\n    else:\n        extreme_utilization_penalty = 10 * np.abs(utilization - 0.5)  # Default penalty, same as v1.\n\n    priorities[valid_bins] -= extreme_utilization_penalty[valid_bins]\n\n    # 4. Penalty for Over-Utilized Bins:\n    almost_full = (bins_remain_cap - item) < 0.1 * np.max(bins_remain_cap) # Remaining cap is less than 10% of max cap\n    priorities[almost_full & valid_bins] -= 20 # Large penalty for almost full bins.\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines FFD approximation, waste minimization, and capacity ratio.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    # FFD Approximation + Capacity Ratio\n    ratios = item / bins_remain_cap\n    priorities[valid_bins] = -np.log(ratios[valid_bins]) / (np.abs(bins_remain_cap[valid_bins] - item) + 0.0001) #Higher priority to close size\n\n    # Waste Minimization\n    remaining_after_fit = bins_remain_cap - item\n    small_waste_penalty = np.exp(-10 * remaining_after_fit)\n    priorities[valid_bins] -= small_waste_penalty[valid_bins]\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic uses a combination of best-fit, waste minimization, bin balancing, and fullness bonus, while the worst only considers the ratio of item size to bin capacity. The better heuristics incorporate adaptive components and dynamic adjustments based on overall bin utilization and item size.\n\nComparing (2nd best) vs (second worst), we see similar trends as (1st) vs (20th). The second-best heuristic also employs a combination of best-fit, waste minimization, bin balancing, and fullness bonus, and it includes adaptive weight adjustments. In contrast, the second worst (19th) only considers item size ratios and waste minimization, lacking bin balancing and dynamic adaptation.\n\nComparing (1st) vs (2nd), we see that they are identical. This suggests that the performance difference lies in other parts of the bin-packing algorithm, or that the test cases don't distinguish these two heuristics.\n\nComparing (3rd) vs (4th), they are identical. This could indicate code duplication, or simply that the changes between them have no effect on the test dataset.\n\nComparing (second worst) vs (worst), we see that the 19th includes waste minimization while the 20th does not.\n\nOverall:\n\nThe successful heuristics combine multiple factors (best-fit, waste minimization, bin balancing, fullness), and dynamically adjust weights based on bin utilization, item sizes, and/or capacity distribution. Less successful heuristics are simpler, focusing only on a subset of these factors, and without dynamic adjustments. Edge case handling is also important (handling nearly full bins or cases where no bin is suitable).\nThe ranking suggests that a good heuristic should aim for a balance between different objectives instead of focusing too much on a single criterion. Also, adaptability, and edge case handling are key.\n- \nOkay, let's refine \"Current Self-Reflection\" for designing better heuristics, focusing on avoiding pitfalls.\n\nHere's a redefined approach:\n\n*   **Keywords:** Adaptive, Dynamic, Multifaceted, Problem State, Edge Cases, Normalization, Performance Feedback, Exploration vs. Exploitation, Computational Cost.\n\n*   **Advice:** Develop heuristics that actively learn and adapt to the problem instance *during* execution. Experiment with diverse features (e.g., item size distributions, bin utilization). Integrate performance feedback loops to continuously refine parameter weights. Employ both exploration and exploitation for better results.\n\n*   **Avoid:** Static parameters, reliance solely on single strategies, ignoring edge cases, premature simplification, and neglecting computational cost.\n\n*   **Explanation:** Effective heuristic design is an iterative process. Start with a robust, multifaceted heuristic, and refine it using real-time feedback. Dynamic adaptation allows the heuristic to tailor its behavior to the specific problem instance, avoiding the limitations of static or overly simplistic approaches.\n\n**Step-by-step thought process summary**\n1.  **Start with Keywords:** Identify the most crucial elements: Adaptability, dynamism, and considering the problem state.\n2.  **Provide Specific Advice:** Go beyond general statements. Suggest active learning, feature experimentation, and feedback loops.\n3.  **List What to Avoid:** Explicitly state what hinders good heuristic design (static parameters, ignoring edge cases, etc.).\n4.  **Summarize with Explanation:** Concisely explain the rationale behind the advice. Emphasize the iterative and adaptive nature of the process.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}