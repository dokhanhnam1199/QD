{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    An enhanced priority function for online bin packing that combines\n    best-fit considerations with dynamic waste management, bin balancing,\n    and a learning component.  It prioritizes bins based on a weighted\n    combination of several factors, including space utilization,\n    waste minimization, and bin balancing.  The weights are adjusted\n    dynamically based on the overall fill level of the bins.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    priorities[~valid_bins] = -np.inf\n\n    # Best-Fit component with a small bias towards more full bins.\n    size_diff = bins_remain_cap - item\n    priorities[valid_bins] += 1.0 / (size_diff[valid_bins] + 0.0001)**2\n\n    # Waste Minimization:  Discourage very small waste\n    remaining_after_fit = bins_remain_cap[valid_bins] - item\n    small_waste_penalty = np.exp(-10 * remaining_after_fit * item)\n    priorities[valid_bins] -= small_waste_penalty\n\n    # Bin Balancing using utilization and overall utilization:\n    utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    overall_utilization = np.mean(utilization)\n\n    # Dynamically adjust bin balancing based on fill level.\n    if overall_utilization < 0.3:\n        extreme_utilization_penalty = 5 * np.abs(utilization - 0.2)  # Encourage filling\n    elif overall_utilization > 0.7:\n        extreme_utilization_penalty = 15 * np.abs(utilization - 0.8) #Discourage further filling\n    else:\n        extreme_utilization_penalty = 10 * np.abs(utilization - 0.5) #Balance\n    priorities[valid_bins] -= extreme_utilization_penalty[valid_bins]\n\n\n    # Adaptive component:  Add a bonus to bins close to full\n    # Weight the bonus dynamically based on overall utilization\n\n    fullness_bonus = np.exp(-5 * np.abs(bins_remain_cap / np.max(bins_remain_cap) - 0))\n\n    if overall_utilization < 0.5:\n        priorities[valid_bins] += 2 * fullness_bonus[valid_bins] * (1 - overall_utilization) #more bonus to almost full bins\n    elif overall_utilization < 0.8 :\n         priorities[valid_bins] +=  fullness_bonus[valid_bins] * (1 - overall_utilization) #more bonus to almost full bins\n    else:\n        priorities[valid_bins] += 0.5 * fullness_bonus[valid_bins] *(1 - overall_utilization) #even lower bonus\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines adaptive waste minimization and bin balancing with best fit.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    priorities[~valid_bins] = -np.inf\n\n    size_diff = bins_remain_cap - item\n    priorities[valid_bins] = 1.0 / (size_diff[valid_bins] + 0.0001)**2\n\n    remaining_after_fit = bins_remain_cap - item\n    small_waste_penalty = np.exp(-10 * remaining_after_fit * item)\n    priorities[valid_bins] -= small_waste_penalty[valid_bins]\n\n    utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    overall_utilization = np.mean(utilization)\n\n    if overall_utilization < 0.3:\n        extreme_utilization_penalty = 5 * np.abs(utilization - 0.2)\n    elif overall_utilization > 0.7:\n        extreme_utilization_penalty = 15 * np.abs(utilization - 0.8)\n    else:\n        extreme_utilization_penalty = 10 * np.abs(utilization - 0.5)\n\n    priorities[valid_bins] -= extreme_utilization_penalty[valid_bins]\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the top heuristic `priority_v2` is a complex function incorporating best-fit, waste minimization, bin balancing, and an adaptive fullness bonus, while the bottom heuristic only calculates the negative log of the item size to bin capacity ratio. Comparing (2nd best) vs (second worst) which are (2nd) and (19th), the differences are negligible, both share the complexity of the first. Comparing (1st) vs (2nd), we see the first and second heuristics in the list are virtually identical. (3rd) vs (4th) are the same. Comparing (second worst) vs (worst), we see nearly identical code, except for the parameters. Overall: the superior heuristics employ a combination of best-fit approximation, waste minimization, and bin utilization balancing, often with dynamic adjustments based on overall bin fill levels. The inferior heuristics focus on a single factor (e.g., capacity ratio) or lack adaptive mechanisms. The top heuristics prioritize tight fits and penalize small waste, especially when placing larger items, while balancing overall bin utilization.\n- \nOkay, let's refine \"current self-reflection\" to be more actionable and targeted for designing better bin packing heuristics, while specifically avoiding the pitfalls of \"ineffective self-reflection.\"\n\nHere's a redefinition focused on *actionable insights* derived from careful consideration of the *current state* and *learning from failures*.\n\n*   **Keywords:** Adaptive, dynamic, feedback-driven, state-dependent, multi-faceted, edge-case handling, normalization, penalty-adjustment, learning, failure-analysis.\n\n*   **Advice:** Design heuristics that react intelligently to the *specific* characteristics of the *current* bin state and incoming items. Use real-time feedback (e.g., waste metrics, bin fullness distribution) to *dynamically* adjust parameters (e.g., priorities of different fitting strategies, penalty weights for wasted space).\n\n*   **Avoid:** Vague statements about \"best-fit strategies\" or \"waste reduction\" *without specifying the precise conditions under which they are most effective and how those conditions are detected*. Avoid assuming \"fine-grained control\" inherently leads to better heuristics; focus on *purposeful* control driven by *measurable* improvements.\n\n*   **Explanation:** A good heuristic doesn't just *use* multiple factors; it *intelligently weighs and combines* them based on the *current context*. It learns from its failures (i.e., when does best-fit actually lead to more waste later?). This requires analyzing failures, identifying patterns, and incorporating rules to avoid repeating those failures in similar situations. Dynamic adjustments based on state allow for more robust performance across various input distributions.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}