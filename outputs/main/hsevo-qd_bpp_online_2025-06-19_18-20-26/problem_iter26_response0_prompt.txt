{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit, waste minimization, bin balancing, fullness bonus, and item-size-aware penalty adjustments.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    priorities[~valid_bins] = -np.inf\n\n    # Best-Fit component\n    size_diff = bins_remain_cap - item\n    priorities[valid_bins] += 1.0 / (size_diff[valid_bins] + 0.0001)**2\n\n    # Waste Minimization (adaptive)\n    remaining_after_fit = bins_remain_cap[valid_bins] - item\n    small_waste_penalty = np.exp(-10 * remaining_after_fit * item)\n    priorities[valid_bins] -= small_waste_penalty\n\n    # Bin Balancing (dynamic)\n    utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    overall_utilization = np.mean(utilization)\n\n    if overall_utilization < 0.3:\n        extreme_utilization_penalty = 5 * np.abs(utilization - 0.2)\n    elif overall_utilization > 0.7:\n        extreme_utilization_penalty = 15 * np.abs(utilization - 0.8)\n    else:\n        extreme_utilization_penalty = 10 * np.abs(utilization - 0.5)\n\n    priorities[valid_bins] -= extreme_utilization_penalty[valid_bins]\n\n    # Fullness Bonus (adaptive)\n    fullness_bonus = np.exp(-5 * np.abs(bins_remain_cap / np.max(bins_remain_cap) - 0))\n\n    if overall_utilization < 0.5:\n        priorities[valid_bins] += 2 * fullness_bonus[valid_bins] * (1 - overall_utilization)\n    elif overall_utilization < 0.8:\n        priorities[valid_bins] +=  fullness_bonus[valid_bins] * (1 - overall_utilization)\n    else:\n        priorities[valid_bins] += 0.5 * fullness_bonus[valid_bins] * (1 - overall_utilization)\n\n    # Item size aware waste penalty adjustment\n    if item > 0.5:\n        if overall_utilization > 0.6:\n            priorities[valid_bins] -= 2 * small_waste_penalty # penalize small waste more when bins are full\n\n    # Over-utilization Penalty (adaptive)\n    almost_full = (bins_remain_cap - item) < 0.1 * np.max(bins_remain_cap)\n    priorities[almost_full & valid_bins] -= 20\n\n    # Introduce a new adaptive parameter based on item size relative to bin capacity\n    item_ratio = item / np.max(bins_remain_cap)\n    if item_ratio > 0.6: # Item is relatively large\n        # Further discourage small waste in nearly full bins to avoid creating unusable bins\n        nearly_full = (bins_remain_cap < 0.2 * np.max(bins_remain_cap)) & valid_bins # less than 20% capacity\n        priorities[nearly_full] -= 10 * small_waste_penalty[bins_remain_cap[valid_bins] < 0.2 * np.max(bins_remain_cap)]\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    A dynamic priority function for online bin packing that combines best-fit,\n    waste management, bin balancing, and learning components with adaptive\n    weighting based on real-time feedback and historical performance.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    priorities[~valid_bins] = -np.inf\n\n    # 1. Best-Fit Component with adaptive granularity\n    size_diff = bins_remain_cap - item\n    priorities[valid_bins] += 1.0 / (size_diff[valid_bins] + 0.0001)**2\n\n    # 2. Waste Minimization with dynamic penalty adjustment\n    remaining_after_fit = bins_remain_cap[valid_bins] - item\n    waste_ratio = remaining_after_fit / item\n    small_waste_penalty = np.exp(-15 * remaining_after_fit * item) # Increased sensitivity\n\n    # Adaptive penalty based on waste ratio and item size\n    penalty_weight = 1.0\n    if item > 0.5:  # Penalize small waste more for large items\n        penalty_weight = 2.0\n    elif item < 0.2: # Relax the small waste penalty for small items\n        penalty_weight = 0.5\n\n    priorities[valid_bins] -= penalty_weight * small_waste_penalty\n\n    # 3. Bin Balancing using utilization and overall utilization with adaptive target\n    utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    overall_utilization = np.mean(utilization)\n\n    # Dynamic target utilization based on overall utilization\n    target_utilization = 0.5\n    if overall_utilization < 0.3:\n        target_utilization = 0.2\n    elif overall_utilization > 0.7:\n        target_utilization = 0.8\n\n    extreme_utilization_penalty = 10 * np.abs(utilization - target_utilization)\n    priorities[valid_bins] -= extreme_utilization_penalty[valid_bins]\n\n    # 4. Adaptive component with dynamic bonus based on remaining capacity\n    fullness_bonus = np.exp(-5 * np.abs(bins_remain_cap / np.max(bins_remain_cap) - 0))\n    bonus_weight = 1.0\n\n    # Adjust bonus weight based on overall utilization and item size\n    if overall_utilization < 0.5:\n        bonus_weight = 2 * (1 - overall_utilization)\n    elif overall_utilization < 0.8:\n        bonus_weight = (1 - overall_utilization)\n    else:\n        bonus_weight = 0.5 * (1 - overall_utilization)\n\n    priorities[valid_bins] += bonus_weight * fullness_bonus[valid_bins]\n\n\n    # 5. Item-Size-Aware Adjustment: Favor bins that tightly fit larger items\n    if item > 0.6:\n      tight_fit_bonus = np.exp(-20*(bins_remain_cap[valid_bins]-item)**2)\n      priorities[valid_bins] += 0.7 * tight_fit_bonus # Encourage tight fits\n\n    # 6. Normalize priorities to avoid domination by any single factor\n    max_priority = np.max(priorities[np.isfinite(priorities)])\n    min_priority = np.min(priorities[np.isfinite(priorities)])\n\n    if max_priority > min_priority:\n        priorities[np.isfinite(priorities)] = (priorities[np.isfinite(priorities)] - min_priority) / (max_priority - min_priority)\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the best heuristic incorporates best-fit, waste minimization, bin balancing, fullness bonus, and item-size awareness, along with adaptive parameter tuning and dynamic waste thresholding. The worst heuristic only considers the ratio of item size to bin capacity.\n\nComparing (2nd best) vs (second worst), the second-best heuristic combines best-fit, waste minimization, adaptive bin balancing, and fullness bonus, adding an adaptive waste penalty adjustment based on item size and overall utilization. The second-worst heuristic only combines FFD approximation, waste minimization, and capacity ratio.\n\nComparing (1st) vs (2nd), we observe that the best heuristic includes a more elaborate waste minimization strategy (adaptive threshold, dynamic penalty strength) and handles edge cases. The second-best heuristic uses a simpler, static waste minimization approach and lacks specific edge case handling but introduces item-size-aware waste penalty.\n\nComparing (3rd) vs (4th), there are no functional differences between the two.\n\nComparing (second worst) vs (worst), the second-worst heuristic, combines FFD approximation, waste minimization, and capacity ratio. The worst heuristic only calculates the negative log ratios of item size to bin capacity, which oversimplifies the problem and ignores waste and bin utilization.\n\nOverall: The better heuristics prioritize a combination of factors: best-fit, waste minimization, bin balancing, fullness bonuses, and adaptive parameter tuning based on item size and overall bin utilization. Simpler heuristics that only focus on a single aspect (e.g., capacity ratio) perform worse. Dynamically adapting parameters based on the current state of the bin packing process appears to be key to improved performance. Penalizing extreme scenarios, such as very small wastes or nearly full bins, also helps.\n- \nOkay, let's redefine \"Current Self-Reflection\" to focus on actionable advice for designing better heuristics, avoiding the pitfalls of the \"Ineffective Self-Reflection.\"\n\nHere's a refined approach:\n\n*   **Keywords:** Adaptive strategies, dynamic weighting, multi-factor integration, problem-state awareness, robustness, normalization, edge case handling, performance feedback, computational cost.\n\n*   **Advice:** Prioritize heuristics that adapt to the problem state by dynamically adjusting parameters, weights, and penalties. Combine multiple relevant factors (e.g., best-fit, waste minimization, bin balancing) thoughtfully. Explicitly address edge cases.\n\n*   **Avoid:** Oversimplification without justification, static parameter settings, neglecting computational cost, allowing single factors to dominate the heuristic's behavior, ignoring performance feedback.\n\n*   **Explanation:** Effective heuristics require balancing complexity and computational cost. Adaptive mechanisms are crucial, but normalization and performance monitoring are essential to ensure robustness and prevent unintended behavior.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}