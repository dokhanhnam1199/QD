```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit.

    In the Best Fit strategy, we aim to place the item in the bin that leaves
    the minimum remaining capacity after the item is placed, provided the bin
    has enough capacity. This minimizes wasted space in that specific bin.
    A higher priority score is given to bins that are a "tighter fit".

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate remaining capacity if the item is placed in each bin
    potential_remaining_caps = bins_remain_cap - item

    # Only consider bins that have enough capacity for the item
    valid_bins_mask = potential_remaining_caps >= 0

    # For valid bins, the priority is the negative of the remaining capacity.
    # We use negative because numpy.argmax finds the maximum, and we want the
    # smallest remaining capacity (closest to zero, or least positive).
    # This makes the "best fit" bin have the highest priority score.
    priorities[valid_bins_mask] = -potential_remaining_caps[valid_bins_mask]

    # Bins that are too small to fit the item will have a priority of 0,
    # meaning they will not be chosen unless no other bin can fit the item.
    # In a practical scenario, if all priorities are 0 and the item doesn't fit
    # anywhere, a new bin would be opened. This priority function focuses on
    # existing bins.

    return priorities
```
