```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a
    softmax-based approach that considers tight fits, bin scarcity, and tie-breaking.

    This heuristic prioritizes bins that offer a "tight fit" for an incoming item,
    minimizing wasted space. It also incorporates a preference for bins with less
    remaining capacity (i.e., scarcer bins) and uses a softmax function to convert
    these scores into probabilities, allowing for probabilistic exploration.

    The score for each bin is calculated as follows:
    1. For bins that cannot fit the item, the score is 0.
    2. For bins that can fit the item, the score is influenced by:
       a. Tightness: A score that is higher for smaller remaining capacities
          (after fitting the item). This is calculated using a sigmoid-like
          function `exp(-k * (remaining_capacity - item))`. A perfect fit
          (remaining_capacity - item = 0) gets a score of 1.
       b. Scarcity: A score that is higher for bins with less remaining capacity overall.
          This is calculated as `exp(-s * remaining_capacity)`.
       c. Tie-breaking: A small preference for earlier bins in the array. This is
          handled implicitly by the softmax or can be explicitly added as a small bonus.
          Here, we'll implicitly favor earlier bins in the softmax if scores are equal.

    The final priority for each bin is determined by applying a softmax function
    to a combined score. The combined score for a suitable bin `i` is:
    `combined_score_i = tightness_score_i + scarcity_score_i`

    Softmax function: `priority_i = exp(combined_score_i / temperature) / sum(exp(combined_score_j / temperature))`
    where the sum is over all suitable bins `j`.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A NumPy array representing the remaining capacity of each bin.

    Returns:
        A NumPy array of the same size as `bins_remain_cap`, where each element
        is the priority score (probability) for the corresponding bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item
    suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
    suitable_indices = np.where(suitable_bins_mask)[0]

    # If no bin can fit the item, return all zeros
    if suitable_bins_cap.size == 0:
        return priorities

    # --- Tunable Parameters ---
    # k: Controls the preference for tight fits. Higher k means stronger preference for exact fits.
    #    A small positive value is used so that `exp(-k * mismatch)` is high when mismatch is small.
    k_tightness = 10.0
    # s: Controls the preference for scarce bins (bins with less remaining capacity).
    #    Higher s means stronger preference for bins that are already more full.
    s_scarcity = 0.1
    # temperature: Controls the exploration vs. exploitation trade-off in softmax.
    #    Lower temperature means more exploitation (picking the highest scored bin).
    #    Higher temperature means more exploration (more uniform probability distribution).
    temperature = 1.0
    # -------------------------

    # Calculate scores for suitable bins
    # Score component 1: Tightness (prefer smaller remaining capacity after packing)
    # We want `remaining_capacity - item` to be small.
    # Using `exp(-k * (remaining_capacity - item))` means:
    # - Perfect fit (diff=0): exp(0) = 1 (highest tightness score)
    # - Larger diff: exp(-positive) < 1 (lower tightness score)
    mismatch = suitable_bins_cap - item
    # Cap mismatch to prevent extreme negative exponents if `k` is large and mismatch is very small
    # (though mismatch should be non-negative here by definition).
    # More importantly, cap the argument to `exp` to avoid potential issues if `k` is large.
    # A negative exponent in `exp` is generally safe.
    tightness_scores = np.exp(-k_tightness * mismatch)

    # Score component 2: Scarcity (prefer bins with less remaining capacity overall)
    # We want `remaining_capacity` to be small.
    # Using `exp(-s * remaining_capacity)` means:
    # - Smaller capacity: exp(-small_positive) closer to 1 (higher scarcity score)
    # - Larger capacity: exp(-large_positive) closer to 0 (lower scarcity score)
    scarcity_scores = np.exp(-s_scarcity * suitable_bins_cap)

    # Combined score: Sum of tightness and scarcity preferences
    combined_scores = tightness_scores + scarcity_scores

    # Apply softmax to get probabilities
    # Normalize scores by temperature to control exploration
    # Ensure scores are finite before applying softmax
    exp_scores = np.exp(combined_scores / temperature)

    # Handle potential infinities or NaNs if combined_scores are too large/small
    # Although unlikely with exp(-k*mismatch) and exp(-s*capacity) if k, s, cap are reasonable.
    # If exp_scores become inf, we might want to rescale or cap them.
    # For simplicity, assuming reasonable inputs for now.
    
    # Calculate probabilities using softmax
    softmax_probs = exp_scores / np.sum(exp_scores)

    # Place the calculated probabilities back into the main priorities array
    priorities[suitable_indices] = softmax_probs

    return priorities
```
