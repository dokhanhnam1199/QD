```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # We want to prioritize bins where the item fits perfectly or leaves the smallest remaining space.
    # Inverse Distance: closer remaining capacity to the item size is better.
    # A common approach for "proximity fit" is to aim for a tight fit,
    # minimizing the wasted space.
    # So, we can consider the difference between bin capacity and item size.
    # A smaller positive difference means a tighter fit.

    # Calculate the space left after placing the item in each bin
    space_left = bins_remain_cap - item

    # We only consider bins where the item actually fits
    # For bins where it doesn't fit, the priority should be very low (or zero).
    # We'll use a large negative number to signify "cannot fit".
    # A common heuristic is to give a small positive score to valid bins.
    # For Proximity Fit, we want to penalize bins that leave *too much* space.

    # The core idea is to maximize the "fit". A good measure for fit is
    # how close the `bins_remain_cap` is to `item`.
    # We want bins where `bins_remain_cap >= item`.
    # Among those, we prefer bins where `bins_remain_cap - item` is minimized (but non-negative).

    # Let's define priority as `1 / (1 + (bins_remain_cap - item))` for valid bins.
    # Adding 1 to the denominator prevents division by zero if remaining capacity is exactly the item size.
    # For bins where `bins_remain_cap < item`, this formula would produce values greater than 1,
    # which is not what we want. We want a low priority for invalid bins.

    # A better approach for proximity fit might be to maximize `item / bins_remain_cap` if we want to fill up faster.
    # However, for "Inverse Distance" and Proximity Fit in BPP, the goal is to find a bin that is *just big enough*.
    # This often means finding `bins_remain_cap` that is closest to `item`.

    # Let's rephrase: we want to select a bin such that `bins_remain_cap - item` is as close to 0 as possible,
    # but still non-negative.
    # So, a smaller non-negative difference is better.

    # If we take `1 / (bins_remain_cap - item + epsilon)` where epsilon is a small positive number,
    # this would favor bins with smaller remaining space after packing.
    # But we also need to handle the case where the item doesn't fit.

    # Let's construct a priority that is high for a tight fit and low otherwise.
    # A good way to represent "tightness" is by penalizing large remaining capacities.
    # We can map the available space *after* packing to a priority score.
    # We want small positive `bins_remain_cap - item` to have high priority.

    # Consider a function like `f(x) = 1 / (x + 1)` where `x = bins_remain_cap - item`.
    # This would give higher scores for smaller `x`.

    # For bins where `bins_remain_cap < item`, they are invalid. We can assign them a very low priority, say -1.
    priorities = np.full_like(bins_remain_cap, -1.0) # Initialize with a low priority for invalid bins

    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item

    # For bins where the item fits, calculate the priority based on proximity.
    # We want to prioritize bins that are "just right" â€“ leaving minimal waste.
    # The waste is `bins_remain_cap - item`.
    # A good priority function for proximity fit might be inversely proportional to the remaining capacity
    # *after* placing the item, but only for valid bins.

    # Calculate remaining space for valid bins
    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]
    space_left_valid = valid_bins_remain_cap - item

    # Calculate priorities for valid bins.
    # We want to give higher priority to bins with smaller `space_left_valid`.
    # Using `1.0 / (space_left_valid + 1e-6)` provides a high score for small positive `space_left_valid`
    # and a lower score as `space_left_valid` increases. Adding a small epsilon to prevent division by zero.
    priorities[can_fit_mask] = 1.0 / (space_left_valid + 1e-6)

    # Note: This heuristic prioritizes bins that leave the smallest positive remainder.
    # This aligns with the "Proximity Fit" strategy which aims for tight fits.
    # The specific form `1.0 / (space_left + epsilon)` makes the priority decrease as the waste increases.

    return priorities
```
