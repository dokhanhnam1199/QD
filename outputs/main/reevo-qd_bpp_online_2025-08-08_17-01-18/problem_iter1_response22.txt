```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Worst Fit strategy.

    The Worst Fit strategy prioritizes bins that have the most remaining capacity,
    as this strategy aims to leave smaller bins for potentially larger items later.
    A higher remaining capacity means a higher priority score.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # In Worst Fit, we want to put the item into the bin with the *most* remaining capacity.
    # So, the priority score should be directly proportional to the remaining capacity.
    # We consider only bins that can actually accommodate the item.
    # For bins that cannot accommodate the item, their priority is 0 (or a very low value).
    
    # Create a boolean mask for bins that can accommodate the item
    can_accommodate = bins_remain_cap >= item
    
    # Initialize priorities to 0
    priorities = np.zeros_like(bins_remain_cap)
    
    # For bins that can accommodate the item, set their priority to their remaining capacity
    priorities[can_accommodate] = bins_remain_cap[can_accommodate]
    
    return priorities
```
