```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority scores for packing an item into bins using an improved
    heuristic that balances tight fits with a controlled exploration strategy.

    This heuristic prioritizes bins that are closer to fitting the item exactly,
    using a hyperbolic ranking that favors tighter fits more strongly than
    linear approaches. It also incorporates a probability-based exploration
    mechanism to occasionally choose a random eligible bin, preventing
    getting stuck in local optima.

    The exploration probability can be seen as inversely related to the
    number of available suitable bins, encouraging exploration when options
    are plentiful and exploitation when options are limited.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A NumPy array representing the remaining capacity of each bin.

    Returns:
        A NumPy array of priority scores, same size as `bins_remain_cap`.
        Bins that cannot fit the item will have a score of 0.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate scores for bins that can fit the item
    if np.any(can_fit_mask):
        suitable_bins_cap = bins_remain_cap[can_fit_mask]

        # Hyperbolic scoring: Prioritize bins that leave minimal remaining capacity.
        # The score is inversely proportional to the remaining capacity after packing.
        # Adding a small constant (epsilon) to the denominator prevents division by zero
        # for perfect fits and ensures scores remain finite.
        # A higher "strength" parameter (e.g., 1.0 here) can control the steepness
        # of the preference for tighter fits.
        strength = 1.0
        epsilon = 1e-6
        scores = 1.0 / (suitable_bins_cap - item + epsilon) ** strength

        # Normalize scores to a [0, 1] range for consistency.
        min_score = np.min(scores)
        max_score = np.max(scores)

        if max_score > min_score:
            normalized_scores = (scores - min_score) / (max_score - min_score)
        else:
            # If all suitable bins yield the same score, assign uniform high scores.
            normalized_scores = np.ones(scores.shape)

        priorities[can_fit_mask] = normalized_scores

        # Controlled Exploration:
        # The probability of random exploration decreases with the number of
        # eligible bins. When there are many options, we are more likely to
        # pick a random one to explore different packing strategies.
        num_eligible_bins = np.sum(can_fit_mask)
        # A simple inverse relationship: exploration_prob = 1 / num_eligible_bins
        # but capped to prevent extremely high probabilities and ensure it's
        # not zero when there are many options.
        exploration_prob = 0.1 / np.sqrt(num_eligible_bins) if num_eligible_bins > 0 else 0.0
        exploration_prob = min(exploration_prob, 0.3) # Cap exploration probability

        if np.random.rand() < exploration_prob:
            possible_bins_indices = np.where(can_fit_mask)[0]
            if possible_bins_indices.size > 0:
                # Select a random bin among those that can fit.
                random_bin_index = np.random.choice(possible_bins_indices)

                # Assign the highest priority to the randomly chosen bin.
                priorities = np.zeros(num_bins, dtype=float)
                priorities[random_bin_index] = 1.0

    return priorities
```
