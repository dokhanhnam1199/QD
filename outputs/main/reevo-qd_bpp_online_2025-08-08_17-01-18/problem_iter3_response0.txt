```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin, favoring tighter fits.

    This heuristic prioritizes bins that can accommodate the item and are "tight fits"
    to minimize wasted space. It uses a softmax-like approach to assign higher
    priorities to bins with less remaining capacity (after placing the item).
    Bins too small for the item receive a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    temperature = 1.0  # Controls the "sharpness" of the priority distribution

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, calculate a score that favors tighter fits.
    # A smaller remaining capacity after placing the item means a tighter fit.
    # We use the difference (capacity - item) as the basis for the score.
    # Adding 1 to avoid issues with bins that become exactly full (difference is 0).
    # A small epsilon is added to prevent division by zero if the difference is 0
    # and to handle potential floating point inaccuracies.
    fit_diffs = bins_remain_cap[can_fit_mask] - item + 1e-9

    # Use a softmax-like transformation to turn differences into probabilities/priorities.
    # Higher scores for smaller differences.
    scores = np.exp(-fit_diffs / temperature)

    # Normalize scores so they sum to 1 within the "can_fit" group,
    # if you were to use them as probabilities for sampling.
    # For direct priority assignment, normalization might not be strictly necessary
    # but it helps keep the magnitudes consistent.
    if np.sum(scores) > 0:
        normalized_scores = scores / np.sum(scores)
    else:
        normalized_scores = np.zeros_like(scores)

    # Assign the calculated priorities to the bins that can fit the item
    priorities[can_fit_mask] = normalized_scores

    # Tie-breaking: Favor earlier bins if scores are identical.
    # This is implicitly handled by the order of calculation if scores are identical,
    # but explicit tie-breaking could be added if more complex sorting is needed.
    # For this implementation, NumPy's array indexing naturally handles this.

    return priorities
```
