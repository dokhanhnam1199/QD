```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit strategy.

    The Best Fit strategy aims to place the item into the bin that has the least remaining
    capacity after the item is placed, provided it fits. This helps in keeping larger
    bins available for larger items later.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a more desirable bin. Bins that cannot fit the item
        will have a priority of 0.
    """
    # Calculate the remaining capacity if the item were placed in each bin.
    # This is the difference between the bin's current remaining capacity and the item's size.
    potential_remaining_caps = bins_remain_cap - item

    # Initialize priorities to zero for all bins.
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can accommodate the item (where potential_remaining_caps is non-negative).
    suitable_bins_mask = potential_remaining_caps >= 0

    # For the bins that can fit the item, assign a priority score.
    # The "best fit" bin is the one that leaves the least remaining capacity after placing the item.
    # To maximize the priority score for the best fit, we can use the negative of the
    # potential remaining capacity. A smaller (more negative) value for potential_remaining_caps
    # means a better fit, and thus a higher priority when negated.
    priorities[suitable_bins_mask] = -potential_remaining_caps[suitable_bins_mask]

    # Bins that cannot fit the item will retain their initial priority of 0,
    # correctly indicating they are not suitable.
    return priorities
```
