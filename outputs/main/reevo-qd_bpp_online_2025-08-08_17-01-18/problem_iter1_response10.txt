```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using First Fit Decreasing-like heuristic.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # First Fit strategy: find the first bin that can accommodate the item.
    # For priority, we want to favor bins that are a "tight fit" but still fit.
    # This means we prefer bins where the remaining capacity is just enough for the item.
    # A bin with remaining capacity exactly equal to the item size is ideal.
    # Bins that are too small should have a priority of 0.

    # Create a mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Initialize priorities to a very low value (effectively zero for unusable bins)
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # For bins that can fit the item, calculate a priority score.
    # We want to prioritize bins where the remaining capacity is closest to the item size,
    # without going below the item size.
    # The difference (bins_remain_cap - item) represents the "slack".
    # We want to minimize slack, so a smaller difference is better.
    # However, we want the *first* such bin in the array to be prioritized in case of ties,
    # which is naturally handled by numpy's vectorized operations if we consider
    # negative of the slack as a priority. A smaller slack means a larger negative slack,
    # which translates to a higher priority in a max-priority queue sense.

    # Calculate slack for bins that can fit the item
    slack = bins_remain_cap[can_fit_mask] - item

    # The priority is the negative of the slack.
    # Smaller slack -> larger negative slack -> higher priority.
    # If multiple bins have the same slack, their relative order in the original
    # bins_remain_cap array will be preserved in terms of priority calculation.
    priorities[can_fit_mask] = -slack

    # In a true First Fit, we'd just take the first bin that fits.
    # To simulate this "first fit" behavior in a priority context,
    # we can add a small bonus to earlier bins with good fits, or more directly,
    # simply return priorities such that the first available bin with the "best" fit
    # (smallest slack) gets the highest priority. The `-slack` already achieves this.
    # If multiple bins have the same minimal slack, the one appearing first in the
    # `bins_remain_cap` array will naturally get the higher priority due to the way
    # numpy operations often preserve order in selection when values are equal.
    # For absolute certainty of 'first fit' logic within this priority framework,
    # we can make bins that are "exact fits" have a slightly higher priority
    # than slightly looser fits.

    # Refined priority: Exact fits (slack=0) get highest priority.
    # Then, among bins that fit, prioritize smaller slack (tighter fit).
    # The current -slack already prioritizes smaller slack.
    # To enforce the "first fit" aspect: consider the index.
    # A bin with smaller index is preferred if slack is equal.

    # Let's use a more explicit priority:
    # 1. Highest priority for exact fits.
    # 2. Then, prioritize bins with smaller slack.
    # 3. If slack is equal, prioritize the bin with the smaller index.

    # Initialize priorities for fitting bins
    fit_priorities = np.full_like(bins_remain_cap, -np.inf)

    # Calculate slack for fitting bins
    slack_values = bins_remain_cap[can_fit_mask] - item

    # Assign priorities:
    # For exact fits (slack_values == 0), assign a very high priority (e.g., 1e9)
    # For other fits, assign priority based on negative slack.
    # To break ties and enforce "first fit", we can penalize later bins.
    # Let's assign priority = 10000 - slack - (index * 0.1) for fitting bins.
    # This way, smaller slack is better, and smaller index is better for same slack.

    indices = np.where(can_fit_mask)[0]
    # Create a score: (ideal_fit - slack) + (bonus_for_early_bins)
    # We want to maximize this score.
    # Ideal fit = 0 (when remaining_capacity == item)
    # So, priority component from slack is -slack.
    # Bonus for early bins: -index * small_constant.
    # We want to maximize priority.
    # Maximize: (-slack) - (index * 0.01)
    
    # A simpler way is to use a very large number for exact fits, then -slack.
    # Let's consider the "best" fit for the priority.
    # The best fit is the one that minimizes `remaining_capacity - item`.
    # This is equivalent to maximizing `-(remaining_capacity - item)`.
    # So, `priority = -(remaining_capacity - item)` for fitting bins.
    # To ensure first-fit, if there are multiple bins with the same minimal slack,
    # the one with the lower index should be preferred.
    # We can achieve this by adding a very small penalty to the priority based on index.
    # `priority = -(remaining_capacity - item) - index * epsilon`
    # where epsilon is a very small positive number. This ensures that a bin at a
    # lower index with the same slack gets a slightly higher priority.

    epsilon = 1e-6  # Small value to break ties for first-fit
    fit_priorities[can_fit_mask] = -(slack_values) - (indices * epsilon)
    
    # We want the bin with the highest priority score to be selected.
    # The current calculation `-(slack_values) - (indices * epsilon)` will work.
    # A more direct "First Fit Decreasing-like" priority would be to assign
    # priorities such that the smallest slack is maximized.
    # And for ties in slack, the lowest index is maximized.
    # So, `priority = (some_large_number - slack) - index * epsilon`.
    # Or simply, `priority = -slack - index * epsilon`.
    # A higher value means higher priority.

    # Final check: The priority should reflect our preference.
    # We prefer bins that are a tight fit, and among tight fits, the earliest one.
    # This means a bin where `bins_remain_cap - item` is small is good.
    # And smaller index is good for ties.
    # So, the score should be high for small `bins_remain_cap - item` and small `index`.
    # Let's use a score that is large for best fits:
    # Priority = MAX_SCORE - (bins_remain_cap - item) - (index * penalty)
    # A large MAX_SCORE ensures any fitting bin is better than non-fitting.
    
    MAX_BENEFIT_SCORE = 1000000  # A large number to indicate a good fit
    INDEX_PENALTY_FACTOR = 1000  # Penalty for later bins

    # Prioritize bins that can fit the item.
    # For bins that fit, the score is determined by how "tight" the fit is
    # (smaller remaining capacity after placement is better) and by their index
    # (earlier bins are preferred for first-fit).

    # Calculate the "tightness" score: a larger value means a tighter fit (less waste).
    # We want to maximize `MAX_BENEFIT_SCORE - slack`.
    tightness_score = np.zeros_like(bins_remain_cap)
    tightness_score[can_fit_mask] = MAX_BENEFIT_SCORE - slack

    # Introduce a penalty for bins with higher indices to enforce the "first fit" logic.
    # Subtract a scaled index. Smaller index should have higher priority.
    index_penalty = indices * INDEX_PENALTY_FACTOR
    
    # Combine scores. We want to maximize the overall priority.
    # Prioritize based on tightness, then index.
    # This means higher tightness_score is better.
    # Lower index_penalty is better.
    # So, we want to MAXIMIZE: `tightness_score - index_penalty`
    
    priorities = np.full_like(bins_remain_cap, -np.inf) # Initialize with low priority

    if np.any(can_fit_mask):
        fitting_indices = np.where(can_fit_mask)[0]
        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
        
        # Calculate the "fit quality": how close the remaining capacity is to the item size.
        # A smaller difference (bins_remain_cap - item) is better.
        fit_quality = -(fitting_bins_remain_cap - item) # Maximize this (smaller difference is better)

        # To implement "First Fit", we prefer earlier bins when fit quality is the same.
        # We can achieve this by adding a small bonus for earlier indices.
        # This means we want to maximize `fit_quality + bonus_for_early_bins`.
        # The bonus should decrease with index. So, `bonus = constant - index * small_factor`.
        # Let's use a simple approach: a very high priority for the tightest fits,
        # and then penalize for looser fits and later indices.

        # Consider the inverse: we want to minimize waste (slack) and index.
        # So, we want to minimize `slack + index * epsilon`.
        # Priority should be inverse of this minimization.
        # Priority = - (slack + index * epsilon)

        epsilon_tiebreaker = 1e-6
        priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item) - (np.arange(len(bins_remain_cap))[can_fit_mask] * epsilon_tiebreaker)

    # The current priority definition maximizes (tight fit) + (early index).
    # This correctly aligns with First Fit logic.
    return priorities
```
