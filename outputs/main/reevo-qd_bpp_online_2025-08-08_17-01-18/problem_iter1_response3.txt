```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit strategy.

    The Almost Full Fit strategy prioritizes bins that, after placing the item,
    will have the least remaining capacity among bins that can still accommodate the item.
    This aims to fill bins as much as possible before opening new ones.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins that cannot accommodate the item will have a priority of 0.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Find bins that can accommodate the item
    possible_bins_mask = bins_remain_cap >= item

    # Calculate remaining capacity after placing the item in possible bins
    remaining_after_placement = bins_remain_cap[possible_bins_mask] - item

    # If there are no possible bins, return all zeros
    if remaining_after_placement.size == 0:
        return priorities

    # Calculate the "tightness" score for possible bins.
    # We want to minimize the remaining capacity, so a smaller remaining capacity
    # should result in a higher priority.
    # We use the inverse of the remaining capacity. To avoid division by zero
    # or extremely high priorities for bins that become exactly full, we can
    # add a small epsilon or use a scaled inverse.
    # A common approach is to consider bins that leave little to no space.
    # We want to maximize the chance of the bin becoming "almost full".

    # Let's aim for a score where smaller remaining capacity is better.
    # A simple approach is to use the negative of the remaining capacity.
    # However, to make it a "priority" score (higher is better), we can
    # invert it and potentially scale it.

    # To prioritize bins that leave minimal remaining space, we can take
    # the negative of the remaining capacity. The larger (less negative)
    # the value, the less space is left, thus higher priority.
    # Let's refine this: We want bins that, after placing the item, will have
    # the *least* remaining capacity. This means we want to *minimize*
    # `bins_remain_cap - item`.
    # If we want higher scores to be better, we can assign a score based on
    # the inverse of the remaining capacity.
    # However, the goal is to fill bins. So bins that will be closest to full
    # after placing the item are preferred.

    # Consider the difference: max_capacity - (remaining_after_placement)
    # This is effectively how much space is used. We want to maximize this.
    # So, `item` is constant. Maximizing `bins_remain_cap[i] - remaining_after_placement[i]`
    # means maximizing `bins_remain_cap[i] - (bins_remain_cap[i] - item)` which is just `item`.
    # This isn't quite right.

    # "Almost Full Fit" suggests bins that are ALMOST full.
    # After placing the item, a bin is "almost full" if its remaining capacity is small.
    # So, we want to minimize `bins_remain_cap[i] - item`.
    # To convert this to a priority score (higher is better), we can:
    # 1. Use `1 / (remaining_after_placement + epsilon)` where epsilon is a small number to avoid division by zero.
    # 2. Use `-(remaining_after_placement)`
    # 3. Use `max_possible_remaining - remaining_after_placement` for some large `max_possible_remaining`
    #    which is equivalent to `some_constant - remaining_capacity`.

    # Let's try option 2: higher priority for smaller remaining capacity.
    # So, `priority = -remaining_capacity`. This means a bin with remaining_capacity=1
    # gets priority -1, and a bin with remaining_capacity=0 gets priority 0.
    # This seems to fit the idea of "smallest remaining capacity".

    # To make it more "priority-like" (higher is better), we can use:
    # `priority = C - remaining_capacity`, where C is a large constant, or
    # `priority = 1 / (remaining_capacity + epsilon)`

    # Let's use the concept that the *difference* between what's remaining and what's desired (a full bin)
    # should be minimized. So, `remaining_capacity` should be small.
    # A score that reflects this: `max(0, C - remaining_capacity)`.
    # If we want to prioritize bins that become *most* full after the item,
    # this means the remaining capacity is minimized.

    # Consider the bin that would become "most full". This is the bin where
    # `bins_remain_cap[i] - item` is minimized.
    # So, higher priority for smaller `bins_remain_cap[i] - item`.
    # Let's transform `bins_remain_cap[i] - item` into a priority:
    # `priority = some_large_value - (bins_remain_cap[i] - item)`
    # This is equivalent to `some_large_value - bins_remain_cap[i] + item`.
    # Since `item` is constant for all bins, this is `constant - bins_remain_cap[i]`.
    # We want to maximize this, so we want to minimize `bins_remain_cap[i]`.

    # Another perspective on "almost full":
    # We want to pick the bin that, after placing the item, is closest to full.
    # This means `bins_remain_cap[i] - item` is minimal.
    # Let's assign a priority based on this minimum value.

    # A common heuristic for "Best Fit" or "Almost Full Fit" is to try to minimize
    # the remaining capacity of the bin *after* placing the item.
    # This means we want to select the bin `i` that minimizes `bins_remain_cap[i] - item`.
    # To convert this into a priority score (where higher means more desirable),
    # we can use `-(bins_remain_cap[i] - item)` or `1 / (bins_remain_cap[i] - item + epsilon)`.

    # Let's try using `1 / (remaining_after_placement + epsilon)` where epsilon is small.
    # This ensures that bins with very small remaining capacity get very high priorities.

    epsilon = 1e-6
    priorities[possible_bins_mask] = 1.0 / (remaining_after_placement + epsilon)

    # Alternatively, if we want to give a higher score to bins that leave *less*
    # remaining space, we can simply use the negative of the remaining space,
    # or a scaled version of it.

    # Let's consider the original "Almost Full Fit" idea: prioritize bins that are
    # already close to full. However, the problem statement for this function
    # implies prioritizing based on the *outcome* after placing the item.
    # "priority score for each bin ... bin with the highest priority score will be selected for the item."

    # If the goal is to fill bins, then after placing the item, we want the bin
    # with the *least* remaining capacity.
    # So, `priority = f(remaining_capacity)` where `f` is decreasing.
    # `f(x) = 1/(x + epsilon)` or `f(x) = -x`.
    # Let's use the `1/(x + epsilon)` approach for a strong preference towards tighter fits.

    return priorities
```
