```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Exact Fit First strategy.

    The Exact Fit First strategy prioritizes bins that have just enough remaining capacity
    to fit the current item. A higher priority is assigned to bins where the remaining
    capacity is exactly equal to the item size. Bins that can fit the item but have
    more remaining capacity than the item size receive a lower, but still positive,
    priority. Bins that cannot fit the item receive a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, assign priority
    # Highest priority for exact fit
    exact_fit_mask = bins_remain_cap == item
    priorities[exact_fit_mask] = 1.0

    # Lower priority for bins that can fit but are not an exact fit
    # The priority is inversely proportional to how much "slack" there is,
    # but we want exact fit to be the highest.
    # Let's assign a value between 0 and 1 for non-exact fits.
    # A simple approach is to assign 0.5 if it fits but not exactly.
    # Or we can make it more nuanced. For now, let's assign a high value,
    # but less than 1.0 for exact fit.
    # A good heuristic would be to prioritize bins that leave the least amount
    # of wasted space IF it's not an exact fit.
    # Let's prioritize bins where (remaining_capacity - item) is minimized,
    # but still positive, and then normalize this to give it a score.
    # However, the prompt implies a simpler "Exact Fit First".
    # So, let's stick to a binary approach for "exact fit" vs "can fit".
    # We'll assign a high priority to exact fits, and a slightly lower but still
    # significant priority to non-exact fits that can still accommodate the item.

    # Alternative nuanced approach for non-exact fits:
    # Prioritize those that leave the smallest remaining capacity after placement.
    # This means (bins_remain_cap[i] - item) should be minimized.
    # However, this leans towards Best Fit.
    # For Exact Fit First, we strictly want bins where remaining_capacity == item.

    # Let's refine the "Exact Fit First" interpretation:
    # Priority 1: Exact fit (remaining_capacity == item)
    # Priority 0.5: Can fit, but not exact fit (remaining_capacity > item)
    # Priority 0: Cannot fit (remaining_capacity < item)

    non_exact_fit_mask = can_fit_mask & ~exact_fit_mask
    priorities[non_exact_fit_mask] = 0.5

    return priorities
```
