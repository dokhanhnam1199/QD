```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Exact Fit First strategy.

    The Exact Fit First strategy prioritizes bins where the remaining capacity is exactly equal
    to the item size. Bins that can fit the item but not exactly are given a lower priority,
    with larger remaining capacities being less preferred. Bins that cannot fit the item
    receive zero priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Prioritize bins where remaining capacity is exactly the item size
    exact_fit_mask = (bins_remain_cap == item) & can_fit_mask
    priorities[exact_fit_mask] = 1.0

    # For bins that can fit but not exactly, give a lower priority
    # We want to penalize bins with a lot of leftover space after placing the item.
    # So, we assign a priority that decreases as (remaining_capacity - item_size) increases.
    # A simple way is to use 1 / (remaining_capacity - item_size + 1) to avoid division by zero
    # and ensure non-zero priorities for valid fits.
    partial_fit_mask = (~exact_fit_mask) & can_fit_mask
    remaining_space_after_fit = bins_remain_cap[partial_fit_mask] - item
    priorities[partial_fit_mask] = 1.0 / (remaining_space_after_fit + 1) # Adding 1 to avoid division by zero if remaining_space is 0, which is handled by exact_fit_mask anyway.

    # Ensure that exact fits have higher priority than partial fits.
    # Since we set exact fits to 1.0, and partial fits to values < 1.0 (as remaining_space_after_fit >= 0),
    # this condition is naturally met.

    return priorities
```
