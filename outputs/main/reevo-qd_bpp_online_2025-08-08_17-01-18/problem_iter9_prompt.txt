{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Prior reflection]\nCombine \"best fit\" with \"scarcity\" using a unified score. Tune weights and Softmax temperature for adaptive exploration/exploitation. Simplify for clarity and robustness.\n\n[Code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a refined Sigmoid Fit Score.\n\n    This heuristic prioritizes bins that offer the \"tightest fit\" for an incoming item.\n    A tight fit means the bin has just enough remaining capacity to accommodate the item,\n    minimizing wasted space. Bins that are too small are excluded, and among the\n    suitable bins, those with less remaining capacity (but still sufficient) are preferred.\n\n    The scoring is based on a sigmoid function applied to the difference between\n    the bin's remaining capacity and the item's size. Specifically, for bins where\n    `remaining_capacity >= item`, the score is calculated as:\n\n    `score = 1 / (1 + exp(k * (remaining_capacity - item)))`\n\n    Here:\n    - `k` is a sensitivity parameter that controls how quickly the priority drops\n      as the remaining capacity exceeds the item size. A higher `k` means a sharper\n      preference for tighter fits.\n    - `remaining_capacity - item` is the \"mismatch\" or wasted space.\n    - When `remaining_capacity == item` (perfect fit), the exponent is 0, `exp(0)=1`,\n      and the score is `1 / (1 + 1) = 0.5`.\n    - When `remaining_capacity > item` (mismatch > 0), the exponent is positive.\n      As `remaining_capacity` increases, the exponent `k * (remaining_capacity - item)`\n      increases, `exp(...)` increases, `1 + exp(...)` increases, and thus the score\n      decreases (approaching 0 for very large capacities). This correctly penalizes\n      bins with excessive remaining space.\n\n    This approach ensures that bins with smaller positive mismatches (tighter fits)\n    receive higher priority scores than bins with larger positive mismatches.\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A NumPy array representing the remaining capacity of each bin.\n\n    Returns:\n        A NumPy array of the same size as `bins_remain_cap`, where each element\n        is the priority score for the corresponding bin. Bins that cannot fit the item\n        will have a priority of 0.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item\n    suitable_bins_mask = bins_remain_cap >= item\n    suitable_bins_cap = bins_remain_cap[suitable_bins_mask]\n\n    # If no bin can fit the item, return all zeros\n    if suitable_bins_cap.size == 0:\n        return priorities\n\n    # Parameter for the sigmoid function's steepness.\n    # A higher value makes the function drop faster as capacity increases past the item size.\n    # This encourages selecting bins that are closer to the item size.\n    k = 5.0  # Tunable parameter\n\n    # Calculate the \"mismatch\" or wasted space for suitable bins\n    # mismatch = suitable_bins_cap - item\n    # We want to give higher priority when mismatch is small (close to 0).\n    # The function 1 / (1 + exp(k * mismatch)) achieves this:\n    # - If mismatch = 0, score = 1 / (1 + exp(0)) = 0.5\n    # - If mismatch > 0 (but small), exp(k*mismatch) is slightly > 1, score is slightly < 0.5\n    # - If mismatch is large positive, exp(k*mismatch) is very large, score approaches 0.\n\n    # Calculate the sigmoid scores for the suitable bins\n    # To avoid potential overflow with exp(k * mismatch) if mismatch is very large,\n    # we can consider the range of `suitable_bins_cap`. If `suitable_bins_cap`\n    # can be extremely large compared to `item`, `k * (suitable_bins_cap - item)`\n    # can be a very large positive number, leading to `exp()` overflowing.\n    # A robust way to handle this is to clip the argument to the exponential or\n    # use a more numerically stable sigmoid implementation if necessary.\n    # For typical BPP scenarios, direct calculation might be acceptable.\n    # If `suitable_bins_cap - item` becomes very large, `exp` might overflow.\n    # We can cap the argument to `exp` to prevent overflow.\n    # A practical upper bound for `k * (capacity - item)` can be set.\n    # For example, if `k=5`, `exp(35)` is already very large. Let's cap at 35.\n    mismatch = suitable_bins_cap - item\n    exponent_arg = k * mismatch\n    \n    # Cap the exponent argument to prevent overflow in np.exp\n    # A value of 700 is a common threshold for `exp` to return inf.\n    # If `k * mismatch` is, say, 40, `exp(40)` is large but manageable.\n    # If `k * mismatch` is 1000, `exp(1000)` is infinity.\n    # Let's cap the argument to a reasonable value, say 35, to keep `exp` within range,\n    # or handle `inf` gracefully. If `exp` becomes `inf`, the score becomes 0.\n    # A simpler approach is to ensure `k` and `mismatch` product doesn't exceed a threshold.\n    # Let's assume typical capacities and k are such that direct calculation is fine,\n    # but for robustness, we'll consider capping.\n    \n    # Let's use a threshold for `k * mismatch`. If `k * mismatch > threshold`,\n    # then `exp(k * mismatch)` will be very large, and the score will be close to 0.\n    # A threshold like 30-40 for the exponent is usually sufficient to make `exp` very large.\n    # Let's use a maximum argument to exp to prevent overflow.\n    max_exponent_arg = 35.0 # Corresponds to exp(35) which is ~3.4e15\n    \n    capped_exponent_arg = np.minimum(exponent_arg, max_exponent_arg)\n    \n    sigmoid_scores = 1 / (1 + np.exp(capped_exponent_arg))\n\n    # Place the calculated sigmoid scores back into the main priorities array\n    priorities[suitable_bins_mask] = sigmoid_scores\n\n    return priorities\n\n[Improved code]\nPlease write a mutated function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}