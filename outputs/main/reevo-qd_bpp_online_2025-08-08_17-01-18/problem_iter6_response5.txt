```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined strategy:
    Exact Fit First, then Best Fit (smallest positive remaining capacity), and finally First Fit.
    Incorporates an epsilon-greedy exploration.

    The strategy prioritizes bins where the remaining capacity is exactly equal to the item size.
    If no exact fit is found, it prioritizes bins that can fit the item with the smallest positive
    remaining capacity after placement (Best Fit).
    If no bins can fit exactly or with a small positive gap, it falls back to selecting the first
    available bin that can fit the item (First Fit principle applied through uniform probability).
    An epsilon-greedy component is integrated: with a small probability `epsilon`, a bin is chosen randomly
    from the *suitable* bins to encourage exploration.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.05  # Probability of exploring a random suitable bin

    n_bins = len(bins_remain_cap)
    priorities = np.zeros(n_bins)

    # Identify bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item
    suitable_bin_indices = np.where(suitable_bins_mask)[0]

    if len(suitable_bin_indices) == 0:
        # No bin can fit the item
        return priorities

    # Epsilon-greedy choice: With probability epsilon, pick a random suitable bin
    if np.random.rand() < epsilon:
        chosen_index = np.random.choice(suitable_bin_indices)
        # Assign a high priority to this randomly chosen bin
        priorities[chosen_index] = 1.0
        # For other suitable bins, assign a very low priority
        priorities[suitable_bin_indices] = 1e-9
        return priorities

    # Greedy strategy:
    # 1. Exact Fit: Prioritize bins where remaining capacity is exactly the item size.
    exact_fit_mask = (bins_remain_cap == item) & suitable_bins_mask
    exact_fit_indices = np.where(exact_fit_mask)[0]
    if len(exact_fit_indices) > 0:
        priorities[exact_fit_indices] = 1.0
        # If there are exact fits, we only consider them as the highest priority.
        # To ensure they are *strictly* higher, we can assign a very high value and then
        # normalize later if needed, or set other bins to very low values.
        # For simplicity, let's assign 1.0 to exact fits and focus on making them stand out.
        # If other strategies are used, ensure their scores are less than 1.0.
        # For now, we'll return here if exact fits are found, as they are the highest priority.
        return priorities # Or normalize if we want a distribution

    # 2. Best Fit: If no exact fit, prioritize bins with the smallest positive remaining capacity.
    # Calculate the remaining space *after* placing the item.
    remaining_space_after_fit = bins_remain_cap[suitable_bins_mask] - item
    
    # Find the minimum positive remaining space.
    positive_remaining_space = remaining_space_after_fit[remaining_space_after_fit >= 0]

    if len(positive_remaining_space) > 0:
        min_positive_space = np.min(positive_remaining_space)
        
        # Bins that result in exactly this minimum positive space get the highest priority among non-exact fits.
        # We can assign a score that decreases as the gap increases.
        # Score = 1 / (gap + 1) or similar. Let's use a score that is high for small gaps.
        # For bins that fit exactly (gap=0), this would be 1.0. For small positive gaps, it's < 1.0.
        
        # Calculate scores for suitable bins: higher score for smaller positive gap
        # Use a value that is less than 1.0 but still high.
        # A simple approach: 1.0 - (gap / (max_capacity - item + 1)) to keep it between [0, 1)
        # More direct: assign a score based on the inverse of the gap.
        
        # Let's assign a priority based on the inverse of the gap.
        # For a gap of 'g', priority = 1/(g + 1) to avoid division by zero.
        # This ensures smaller gaps get higher priorities.
        
        # Apply to suitable bins only
        best_fit_scores = np.zeros_like(bins_remain_cap)
        best_fit_scores[suitable_bins_mask] = 1.0 / (remaining_space_after_fit + 1.0)
        
        # To make these distinct from exact fits (which would have a score of 1.0),
        # we can scale them down or ensure they are less than the exact fit priority.
        # A simple way to differentiate: add a small offset to the exact fit priority.
        # Here, since we already returned for exact fits, we can just assign these scores.
        
        # To ensure Best Fit is preferred over others, we can set their priority to a
        # value slightly less than 1, e.g., 0.9. Or use a scaled value.
        # Let's use a scaled value that decreases with the gap.
        
        # A simple scaling: 1 - (gap / (average_gap + 1)) for suitable bins.
        # A more direct approach: assign a score that favors smaller positive gaps.
        # We can use the 'remaining_space_after_fit' directly for ranking.
        
        # Let's try a score that is inversely proportional to the gap, capped at a high value.
        # For example, score = 1 - (gap / (max_possible_gap + epsilon))
        # Or, simply rank them and assign priorities.
        
        # A practical approach: assign a rank-based score, or a continuous score.
        # Let's assign a continuous score: higher for smaller positive gaps.
        # We want to map `remaining_space_after_fit` (which is >= 0) to priorities.
        # A mapping like `exp(-remaining_space_after_fit)` could work, but needs scaling.
        # Let's stick to `1 / (gap + 1)` for simplicity and effectiveness.

        # We are prioritizing bins where `remaining_space_after_fit` is minimal and positive.
        # Let's re-evaluate the priority assignment for these bins.
        # We can assign priority `1 - (gap / (max_gap_for_suitable_bins + 1))`
        
        # A common heuristic for Best Fit is to assign a score that is highest for the smallest gap.
        # Let's assign a priority that is inversely proportional to the remaining capacity *after* fit.
        # This means `1 / (bins_remain_cap[i] - item + 1e-6)` for suitable bins.
        
        scores_best_fit = np.zeros_like(bins_remain_cap)
        # Ensure we only apply to suitable bins and avoid division by zero with a small epsilon.
        gaps = bins_remain_cap[suitable_bins_mask] - item
        
        # The smallest *positive* gap should get the highest priority.
        # We can assign scores that are higher for smaller positive gaps.
        # For a gap 'g', a score like `1 / (g + epsilon)` works.
        # Let's use a value that is clearly less than 1.0 (for exact fits).
        # Example: 0.8 - (gap / (max_gap + 1))
        
        # Let's use a simple penalty for waste. A smaller penalty is better.
        # Priority = 1 - (waste / max_waste)
        
        # For best fit, we want to prioritize the smallest *positive* gap.
        # We can assign a score like `1 / (gap + 1)` to suitable bins.
        # This will naturally give higher scores to smaller gaps.
        
        # Let's calculate these scores and assign them.
        # Note: The prior 'exact_fit' handling already returned. If we reach here, no exact fit.
        
        scores = np.zeros_like(bins_remain_cap)
        
        # Calculate the gap for all suitable bins
        gaps_for_suitable = bins_remain_cap[suitable_bins_mask] - item
        
        # For bins that have a positive gap, assign a priority based on the inverse of the gap.
        # This favors smaller gaps. We add 1 to avoid division by zero if gap is 0 (which is handled by exact fit).
        # To ensure these priorities are distinct and generally lower than a hypothetical exact fit priority,
        # we can scale them. Let's assign a score between (0, 1) where smaller gap is closer to 1.
        
        # We can use `1.0 / (gaps_for_suitable + 1.0)` and then scale these values if needed.
        # Let's try to create a priority distribution.
        
        # A pragmatic approach: rank the suitable bins by their gap and assign priorities.
        # Or, assign a score that is a decreasing function of the gap.
        
        # For Best Fit, we want `bins_remain_cap[i] - item` to be minimized and positive.
        # Let's use the reciprocal of the gap.
        # `scores[suitable_bins_mask] = 1.0 / (gaps_for_suitable + 1e-6)`
        # This would give very high scores for very small gaps.
        # To ensure these are less than 1.0 (for exact fit), we can scale.
        
        # Let's use a linear decay for the priority as the gap increases.
        # Max possible gap for a suitable bin: bin_capacity - item.
        # Assuming bin_capacity is fixed and known, or we use the max `bins_remain_cap`.
        
        # A simpler approach: Assign a high priority (e.g., 0.8) to bins with the smallest positive gap,
        # and then slightly lower priorities to others.
        
        # Let's assign priority based on the inverse of the gap, scaled.
        # `priority = max_priority_best_fit * (1 - (gap / (max_gap_possible + epsilon)))`
        # Let's try `priority = 0.8 * (1.0 / (gap + 1.0))`
        
        # Calculate scores for best fit: higher for smaller positive gaps.
        # Use a value that is less than 1.0.
        
        scores_for_best_fit = np.zeros_like(bins_remain_cap)
        positive_gaps_indices = np.where(gaps_for_suitable >= 0)[0] # Re-filter for non-negative gaps
        
        if len(positive_gaps_indices) > 0:
            # For all suitable bins, calculate a score based on the gap.
            # The score should be higher for smaller gaps.
            # Let's map the gap to a score in [0, 0.9].
            # `score = 0.9 * (1.0 - (gap / (max_gap_across_suitable_bins + 1e-6)))`
            
            # Let's use `1.0 / (gap + 1.0)` and then normalize or scale it.
            # `inverse_gap_scores = 1.0 / (gaps_for_suitable + 1.0)`
            
            # To make these priorities reasonable, let's scale them.
            # The maximum value of `1.0 / (gaps_for_suitable + 1.0)` occurs at the minimum gap.
            # Let `min_positive_gap` be the smallest non-negative gap.
            # Max score ~ `1.0 / (min_positive_gap + 1.0)`
            
            # Assign a base priority for best fit, e.g., 0.7. Then adjust based on gap.
            
            # Let's use a simpler method: Prioritize bins with smallest positive gap.
            # We can assign priorities directly to these bins.
            
            # Find the minimum positive gap among suitable bins
            min_positive_gap = np.min(gaps_for_suitable)
            
            # Assign a high priority to bins matching this minimum positive gap
            # We need to be careful if multiple bins have the same minimum gap.
            
            # Let's assign a score that is higher for smaller gaps.
            # A score like `1.0 - (gap / (max_suitable_gap + 1))` can work.
            
            # Calculate the gap for all suitable bins
            gaps_for_suitable = bins_remain_cap[suitable_bins_mask] - item
            
            # We want to prioritize bins with smaller gaps.
            # Create scores for suitable bins: higher for smaller gaps.
            # A simple heuristic: score = 1.0 / (gap + 1.0)
            # Let's scale these so they are distinctly less than 1.0.
            
            # Example: Map gaps to priorities in the range [0.5, 0.9].
            # Max gap among suitable bins for scaling:
            max_gap_suitable = np.max(gaps_for_suitable) if len(gaps_for_suitable) > 0 else 0
            
            # If max_gap_suitable is 0, all suitable bins are exact fits (already handled).
            # So, we assume max_gap_suitable > 0 if we reach here.
            
            # For bins with gap `g`: priority = 0.9 - (g / (max_gap_suitable + 1.0)) * 0.4
            # This maps 0 gap to 0.9 and max_gap_suitable to 0.5.
            
            priorities_for_best_fit = np.zeros_like(bins_remain_cap)
            
            # For each suitable bin
            for i, bin_idx in enumerate(suitable_bin_indices):
                gap = bins_remain_cap[bin_idx] - item
                
                if gap == 0: # This should not happen if exact fit is handled first
                    continue
                
                # Calculate a score that is higher for smaller positive gaps
                # Map the gap to a priority value.
                # Let's use `1.0 / (gap + 1.0)` and scale it to be below 1.0.
                # Example: score = 0.8 * (1.0 / (gap + 1.0))
                # This ensures smaller gaps get higher scores.
                
                # Consider the range of gaps for suitable bins
                # Let's use the difference from the minimum positive gap.
                
                # Simple approach: Assign priority 0.7 to all bins that fit.
                # Then, if we want to differentiate Best Fit, we can try to adjust.
                
                # Let's go back to the idea of inverse of gap.
                # `score = 1.0 / (gap + 1.0)`
                
                # Scale these scores to be in a range like [0.5, 0.9]
                # Find the minimum positive gap among these suitable bins.
                min_gap_among_suitable = np.min(gaps_for_suitable)
                
                # If `min_gap_among_suitable` is very small, `1.0 / (gap + 1.0)` can be large.
                # Let's consider the range of `gaps_for_suitable`.
                
                # Let's try a simpler priority assignment:
                # Prioritize bins with the smallest positive remaining capacity.
                
                # For all suitable bins, calculate their gap.
                gaps = bins_remain_cap[suitable_bins_mask] - item
                
                # Find the minimum positive gap.
                min_pos_gap = np.min(gaps[gaps >= 0]) # Find min non-negative gap
                
                # Assign a high priority to bins with this minimum positive gap.
                # These are the best fit candidates.
                best_fit_candidates_mask = (bins_remain_cap == item + min_pos_gap) & suitable_bins_mask
                priorities[best_fit_candidates_mask] = 0.9 # High priority for best fit
                
                # For other suitable bins (that are not exact fits and not best fits)
                # Assign a lower priority. This would be a form of "Worst Fit" if we wanted that,
                # but for First Fit we'd just pick the first one.
                # Here, we can assign a moderate priority to other suitable bins.
                
                other_suitable_mask = suitable_bins_mask & ~best_fit_candidates_mask
                priorities[other_suitable_mask] = 0.5 # Moderate priority for other fits
                
                return priorities # Return after Best Fit assignment.
            
    # 3. First Fit fallback: If no exact or best fit identified (e.g., only large gaps or no suitable bins),
    # this part ensures some priority is given if any suitable bins exist.
    # The above logic for best fit should cover all suitable bins.
    # If no suitable bins were found, we already returned zeros.
    # If suitable bins were found, the `priorities` array should have non-zero values.

    # If the logic above didn't assign any priorities (e.g., if only one suitable bin and it's not best/exact)
    # or if we want a fallback for "First Fit" where any fitting bin is okay.
    # If `np.sum(priorities) == 0` and `len(suitable_bin_indices) > 0`:
    # This means no exact fit, and perhaps no clear "best fit" was prioritized distinctly.
    # In such cases, we can assign uniform priorities to all suitable bins.
    if np.sum(priorities) == 0 and len(suitable_bin_indices) > 0:
        priorities[suitable_bin_indices] = 1.0 / len(suitable_bin_indices)

    return priorities
```
