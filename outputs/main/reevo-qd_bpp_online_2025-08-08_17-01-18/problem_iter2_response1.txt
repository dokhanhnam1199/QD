```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined Almost Full Fit strategy.

    This heuristic prioritizes bins that, after placing the item, will have the least
    remaining capacity among all bins that can accommodate the item. This encourages
    tighter packing by selecting bins that are filled as much as possible.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins that cannot accommodate the item will have a priority of 0.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Find bins that can accommodate the item
    possible_bins_mask = bins_remain_cap >= item

    # If no bins can fit the item, return all zeros
    if not np.any(possible_bins_mask):
        return priorities

    # Calculate the remaining capacity for bins that can fit the item
    remaining_after_placement = bins_remain_cap[possible_bins_mask] - item

    # To prioritize bins that leave the least remaining capacity (i.e., become "most full"),
    # we want to assign higher scores to smaller remaining capacities.
    # Using the inverse of the remaining capacity, plus a small epsilon to prevent
    # division by zero and to give a very high priority to bins that become exactly full.
    # A small positive value added to the denominator ensures that even if remaining_after_placement is 0,
    # the priority is finite and very large.
    epsilon = 1e-9
    scores = 1.0 / (remaining_after_placement + epsilon)

    # Assign these scores to the corresponding bins
    priorities[possible_bins_mask] = scores

    return priorities
```
