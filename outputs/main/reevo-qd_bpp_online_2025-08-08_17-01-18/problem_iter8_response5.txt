```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 0.2, decay_rate: float = 0.5) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a blended strategy.

    This strategy prioritizes exact fits, uses a smooth exponential decay for near-exact fits,
    and applies a Softmax normalization for a tunable probability distribution.
    It aims to favor bins where the remaining capacity is closest to the item size,
    with a strong preference for exact matches.

    The priority score for a bin `i` that can fit the item is calculated as:
    1. If `bins_remain_cap[i] == item`: score = 1.0 (exact fit)
    2. If `bins_remain_cap[i] > item`: score = exp(-decay_rate * (bins_remain_cap[i] - item))
    
    These scores are then converted into probabilities using the Softmax function:
    `P_i = exp(score_i / temperature) / sum(exp(score_j / temperature))`

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.
        temperature: Controls the Softmax exploration/exploitation balance.
                     Higher values lead to more exploration (more uniform probabilities).
                     Defaults to 0.2.
        decay_rate: Controls how quickly priority decreases as the residual
                    (remaining capacity - item) increases. Higher values mean
                    faster decay. Defaults to 0.5.

    Return:
        Array of same size as bins_remain_cap with priority score (probability) of each bin.
        Bins that cannot fit the item will have a priority of 0.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    eligible_bins_cap = bins_remain_cap[can_fit_mask]

    if not eligible_bins_cap.size:
        return priorities  # Return all zeros if no bin can fit the item

    # Calculate the "fit residual": how much space is left after placing the item.
    fit_residuals = eligible_bins_cap - item

    # Calculate base scores for eligible bins:
    # - Exact fits (residual == 0) get a score of 1.0.
    # - Near-exact fits get a score based on exponential decay of the residual.
    #   The term `fit_residuals + 1e-9` is used to prevent `exp(0)` for exact fits
    #   and to ensure numerical stability, slightly differentiating exact fits from
    #   very close fits if `decay_rate` is high, though the `np.where` handles exact fits explicitly.
    #   Using `np.where` directly for exact fits is cleaner.
    scores = np.where(fit_residuals == 0,
                      1.0,  # High priority for exact fits
                      np.exp(-decay_rate * fit_residuals)) # Decreasing priority for near-fits

    # Apply Softmax to convert scores into probabilities.
    # Subtracting the maximum score before exponentiation improves numerical stability.
    if scores.size > 0:
        try:
            max_score = np.max(scores)
            # Ensure temperature is not zero to avoid division by zero
            effective_temperature = max(temperature, 1e-9)
            
            shifted_scores = (scores - max_score) / effective_temperature
            exp_scores = np.exp(shifted_scores)
            sum_exp_scores = np.sum(exp_scores)

            if sum_exp_scores > 1e-9: # Avoid division by zero or near-zero sums
                softmax_priorities = exp_scores / sum_exp_scores
            else:
                # If sum is zero or near-zero (e.g., all scores were -inf or extremely negative),
                # fall back to uniform distribution over eligible bins.
                softmax_priorities = np.ones_like(scores) / scores.size

        except (OverflowError, FloatingPointError):
            # In case of extreme values leading to overflow or other numerical issues,
            # fall back to a uniform distribution over eligible bins.
            softmax_priorities = np.ones_like(scores) / scores.size
    else:
        softmax_priorities = np.array([], dtype=float)


    # Map the calculated priorities back to the original bin indices
    priorities[can_fit_mask] = softmax_priorities
    
    # Ensure probabilities sum to 1 (due to potential floating point inaccuracies)
    # and handle any NaN values that might arise from edge cases.
    priorities = np.nan_to_num(priorities)
    current_sum = np.sum(priorities)
    if current_sum > 1e-9:
        priorities /= current_sum
    elif not np.all(can_fit_mask): # If there are eligible bins but sum is ~0
        # This might happen if temperature is very high and all scores are very small
        # or if there's a numerical issue. Distribute uniformly among eligible bins.
        num_eligible = np.sum(can_fit_mask)
        if num_eligible > 0:
            priorities[can_fit_mask] = 1.0 / num_eligible

    return priorities
```
