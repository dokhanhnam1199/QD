{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First strategy.\n\n    The Exact Fit First strategy prioritizes bins where the remaining capacity is exactly equal\n    to the item size. Bins that can fit the item but not exactly are given a lower priority,\n    with larger remaining capacities being less preferred. Bins that cannot fit the item\n    receive zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Prioritize bins where remaining capacity is exactly the item size\n    exact_fit_mask = (bins_remain_cap == item) & can_fit_mask\n    priorities[exact_fit_mask] = 1.0\n\n    # For bins that can fit but not exactly, give a lower priority\n    # We want to penalize bins with a lot of leftover space after placing the item.\n    # So, we assign a priority that decreases as (remaining_capacity - item_size) increases.\n    # A simple way is to use 1 / (remaining_capacity - item_size + 1) to avoid division by zero\n    # and ensure non-zero priorities for valid fits.\n    partial_fit_mask = (~exact_fit_mask) & can_fit_mask\n    remaining_space_after_fit = bins_remain_cap[partial_fit_mask] - item\n    priorities[partial_fit_mask] = 1.0 / (remaining_space_after_fit + 1) # Adding 1 to avoid division by zero if remaining_space is 0, which is handled by exact_fit_mask anyway.\n\n    # Ensure that exact fits have higher priority than partial fits.\n    # Since we set exact fits to 1.0, and partial fits to values < 1.0 (as remaining_space_after_fit >= 0),\n    # this condition is naturally met.\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin, prioritizing tight fits.\n\n    This heuristic prioritizes bins that can accommodate the item, favoring \"tight fits\"\n    (smaller remaining capacity after packing) to minimize wasted space.\n    A softmax function is used to convert these preferences into probabilities,\n    allowing for some exploration. The temperature parameter controls the\n    aggressiveness of the selection. Bins that are too small for the item receive a priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    temperature = 1.0  # Tune this parameter: lower for more greedy, higher for more exploration\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit, calculate a score based on how tight the fit is.\n    # A smaller remaining capacity after packing means a tighter fit.\n    # We add a small epsilon to avoid division by zero if a bin has exactly the item's size.\n    tight_fit_scores = 1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)\n\n    # Apply softmax to convert scores into probabilities/priorities\n    # Ensure no division by zero if all scores are effectively zero (e.g., no bin fits)\n    if np.sum(tight_fit_scores) > 0:\n        # Softmax calculation: exp(score / temperature) / sum(exp(score / temperature))\n        # To avoid numerical instability with large scores, we can subtract the max score.\n        max_score = np.max(tight_fit_scores)\n        exp_scores = np.exp((tight_fit_scores - max_score) / temperature)\n        sum_exp_scores = np.sum(exp_scores)\n\n        if sum_exp_scores > 0:\n            priorities[can_fit_mask] = exp_scores / sum_exp_scores\n        else:\n            # Handle cases where sum of exp_scores might be zero due to extreme values or temperature\n            # In such rare cases, fall back to uniform distribution among fitting bins\n            num_fitting_bins = np.sum(can_fit_mask)\n            if num_fitting_bins > 0:\n                priorities[can_fit_mask] = 1.0 / num_fitting_bins\n    else:\n        # If no bins can fit, priorities remain zero.\n        pass\n\n    # Tie-breaking: Favor earlier bins (lower index) if priorities are very close.\n    # This can be implicitly handled by the order of processing or explicitly added\n    # by adding a small negative value based on index to the score before softmax,\n    # e.g., score - index * epsilon_tiebreaker. For simplicity here, we rely on\n    # the original order and potential floating point differences.\n\n    return priorities\n\n[Reflection]\nPrioritize tight fits; explore with softmax; consider bin scarcity.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}