```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a weighted combination of
    tightest fit and least full bin strategies, with an exploration component.

    The strategy favors bins that are a "good fit" (leaving small remaining capacity),
    but also considers bins that are less full overall. An exploration parameter
    introduces a chance to select less optimal bins to discover better packing
    opportunities.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.1  # Probability of exploring less optimal bins
    exploration_factor = 0.5 # How much weight to give to exploration vs. exploitation

    n_bins = len(bins_remain_cap)
    priorities = np.zeros(n_bins)

    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    eligible_bins_cap = bins_remain_cap[can_fit_mask]

    if not eligible_bins_cap.size:
        return np.zeros_like(bins_remain_cap)

    # Strategy 1: Prioritize tightest fit (similar to v1 but simpler)
    # Smaller remaining capacity after fitting is better.
    tight_fit_scores = eligible_bins_cap - item
    # We want higher scores for smaller values, so invert and add epsilon for stability.
    # Using a small power to make the difference more pronounced without being too extreme.
    tight_fit_priorities = 1.0 / (tight_fit_scores**1.5 + 1e-9)

    # Strategy 2: Prioritize least full bins (First Fit Decreasing like heuristic)
    # Larger remaining capacity is better, indicating the bin is less utilized.
    least_full_priorities = eligible_bins_cap

    # Combine strategies with a weighting (can be tuned)
    # Here, we give equal weight to both strategies
    combined_priorities = 0.5 * tight_fit_priorities + 0.5 * least_full_priorities

    # Add an exploration component: with probability epsilon, we add a random bonus
    # to a subset of bins to encourage exploration.
    if np.random.rand() < epsilon:
        # Select a subset of eligible bins to give an exploration bonus
        num_explore = max(1, int(len(eligible_bins_cap) * exploration_factor))
        explore_indices_in_eligible = np.random.choice(len(eligible_bins_cap), size=num_explore, replace=False)

        # Give these bins a significant bonus to make them more likely to be chosen
        exploration_bonus = np.max(combined_priorities) * 2.0  # A bonus larger than current best
        combined_priorities[explore_indices_in_eligible] += exploration_bonus

    # Normalize priorities to a [0, 1] range for interpretability or use in algorithms
    # that expect such ranges (like certain RL scenarios).
    # However, for direct selection (arg max), raw scores are fine.
    # For this function, we'll return the raw combined scores as they will be used
    # to find the max.

    # Map the priorities back to the original bin indices
    final_priorities = np.zeros_like(bins_remain_cap, dtype=float)
    final_priorities[can_fit_mask] = combined_priorities

    return final_priorities
```
