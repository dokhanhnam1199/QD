```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Epsilon-Greedy.

    This heuristic prioritizes bins that can fit the item and are "nearly full"
    (i.e., have little remaining capacity after fitting the item), as this
    encourages tighter packing. A small random exploration component is added
    to avoid getting stuck in local optima.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.1  # Probability of random exploration
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate scores for bins that can fit the item
    # We want to prioritize bins that leave little remaining capacity
    # "nearly full" bins are good candidates.
    # The score is the inverse of the remaining capacity after fitting the item.
    # A smaller remaining capacity results in a higher score.
    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item
    
    # Avoid division by zero or very small numbers which can lead to very large priorities.
    # A small epsilon is added to the denominator.
    # Alternatively, we could cap the priorities or use a different scoring mechanism.
    scores = 1.0 / (remaining_capacity_after_fit + 1e-9) 
    
    # Normalize scores to be between 0 and 1 for better epsilon-greedy application
    if scores.size > 0:
        min_score = np.min(scores)
        max_score = np.max(scores)
        if max_score > min_score:
            priorities[can_fit_mask] = (scores - min_score) / (max_score - min_score)
        else:
            # If all scores are the same, assign a neutral priority
            priorities[can_fit_mask] = 0.5
    
    # Epsilon-Greedy exploration: with probability epsilon, choose a random bin that fits
    if np.random.rand() < epsilon:
        possible_bins = np.where(can_fit_mask)[0]
        if possible_bins.size > 0:
            random_bin_index = np.random.choice(possible_bins)
            priorities = np.zeros_like(bins_remain_cap, dtype=float)
            priorities[random_bin_index] = 1.0 # Assign highest priority to the randomly chosen bin
    
    return priorities
```
