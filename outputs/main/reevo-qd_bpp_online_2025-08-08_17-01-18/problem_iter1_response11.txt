```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit.

    The Best Fit strategy prioritizes bins that have just enough capacity to fit the item.
    This is achieved by calculating the difference between the bin's remaining capacity
     and the item's size. Bins with a smaller non-negative difference are prioritized.
    If a bin cannot fit the item, its priority is set to a very low value (negative infinity).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)  # Initialize with low priority

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the "waste" (remaining capacity after fitting the item) for bins that can fit
    # We want to minimize this waste, so smaller positive values are better.
    # We add a small epsilon to prioritize bins with exactly the right fit first.
    waste = bins_remain_cap[can_fit_mask] - item

    # Assign priorities: higher priority for less waste.
    # We invert the waste to make larger numbers represent higher priority.
    # Adding a small constant and multiplying by -1 gives a preference to smaller waste values
    # after a threshold. A large negative value indicates the bin cannot fit the item.
    priorities[can_fit_mask] = -waste

    return priorities
```
