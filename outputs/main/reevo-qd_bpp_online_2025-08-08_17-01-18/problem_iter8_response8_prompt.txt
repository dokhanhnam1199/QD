{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority probabilities for packing an item into bins using a\n    combination of tight fit, bin scarcity, tie-breaking, and Softmax for exploration.\n\n    This heuristic prioritizes:\n    1.  **Tight Fits:** Bins that have just enough remaining capacity for the item.\n        This is handled by a sigmoid function on the \"mismatch\" (remaining_capacity - item).\n    2.  **Bin Scarcity:** Slightly favors bins that are less empty (have less remaining capacity),\n        as these are scarcer resources. A bonus is added inversely proportional to remaining capacity.\n    3.  **Earlier Bin Preference:** If multiple bins have similar scores, favors bins that\n        appear earlier in the `bins_remain_cap` array (i.e., were opened earlier).\n    4.  **Probabilistic Exploration (Softmax):** Converts the computed priority scores\n        into probabilities using the Softmax function. The `temperature` parameter\n        controls the exploration-exploitation trade-off:\n        - Low temperature (close to 0): Exploitation (favors the highest score).\n        - High temperature (large value): Exploration (probabilities are more uniform).\n\n    The final priority for each bin is calculated as:\n    `Score_i = SigmoidFit(bins_remain_cap[i], item, k) + gamma * (1 / (bins_remain_cap[i] + epsilon)) + delta * (1 / (i + 1))`\n    Then, probabilities are derived using Softmax:\n    `P_i = exp(Score_i / temperature) / sum(exp(Score_j / temperature))`\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A NumPy array representing the remaining capacity of each bin.\n        temperature: Controls the Softmax exploration/exploitation balance.\n                     Higher values lead to more exploration. Defaults to 1.0.\n        k: Sensitivity parameter for the sigmoid function (tightest fit preference).\n           Higher `k` increases preference for tighter fits. Defaults to 5.0.\n        gamma: Weight for the bin scarcity bonus. Higher `gamma` increases\n               preference for less empty bins. Defaults to 0.1.\n        delta: Weight for the earlier bin preference tie-breaker. Higher `delta`\n               increases preference for earlier bins. Defaults to 0.01.\n        epsilon: Small value to prevent division by zero in scarcity calculation.\n                 Defaults to 1e-6.\n\n    Returns:\n        A NumPy array of probabilities, same size as `bins_remain_cap`.\n        Bins that cannot fit the item will have a probability of 0.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    raw_scores = np.zeros(num_bins, dtype=float)\n\n    # Identify bins that can accommodate the item\n    suitable_bins_mask = bins_remain_cap >= item\n\n    # Calculate base sigmoid fit score for suitable bins\n    suitable_bins_cap = bins_remain_cap[suitable_bins_mask]\n    \n    if suitable_bins_cap.size > 0:\n        # Calculate the \"mismatch\" or wasted space\n        mismatch = suitable_bins_cap - item\n        \n        # Cap exponent argument to prevent overflow in np.exp\n        max_exponent_arg = 35.0\n        capped_exponent_arg = np.minimum(k * mismatch, max_exponent_arg)\n        \n        # Sigmoid score: Higher for tighter fits (smaller mismatch)\n        sigmoid_scores = 1 / (1 + np.exp(capped_exponent_arg))\n\n        # Apply scarcity bonus: Add bonus for bins with less remaining capacity\n        # Using 1 / (capacity + epsilon) as a proxy for \"fullness\"\n        scarcity_bonus = gamma * (1.0 / (suitable_bins_cap + epsilon))\n\n        # Apply tie-breaking bonus: Add bonus for earlier bins\n        # Find the indices of the suitable bins in the original array\n        suitable_bin_indices = np.where(suitable_bins_mask)[0]\n        tie_breaker_bonus = delta * (1.0 / (suitable_bin_indices + 1.0))\n\n        # Combine scores for suitable bins\n        combined_scores = sigmoid_scores + scarcity_bonus + tie_breaker_bonus\n        \n        # Assign combined scores back to the raw_scores array\n        raw_scores[suitable_bins_mask] = combined_scores\n\n    # If temperature is very low (close to 0), effectively select the max score bin.\n    # Avoid division by zero if temperature is 0.\n    if temperature <= epsilon:\n        if np.max(raw_scores) > -np.inf: # Check if there's at least one valid score\n             # Assign probability 1 to the bin(s) with the maximum score\n             max_score = np.max(raw_scores)\n             probabilities = np.where(raw_scores == max_score, 1.0, 0.0)\n             # Normalize to ensure sum is 1 if multiple max scores exist\n             num_max_scores = np.sum(probabilities)\n             if num_max_scores > 0:\n                 probabilities /= num_max_scores\n        else: # All scores are -inf (e.g., no suitable bins)\n             probabilities = np.zeros(num_bins)\n        return probabilities\n\n    # Apply Softmax to convert scores to probabilities\n    # Add a small constant to scores before exp to avoid issues with very small negative scores\n    # Or simply handle potential underflow/overflow.\n    # A common trick is to subtract the max score before exponentiation:\n    # exp(x_i / T) / sum(exp(x_j / T)) = exp((x_i - max(x)) / T) / sum(exp((x_j - max(x)) / T))\n    # This stabilizes calculations.\n    \n    # Find the maximum score to shift all scores down for numerical stability\n    max_raw_score = np.max(raw_scores)\n    \n    # Ensure we don't get NaN or inf if all scores are -inf (e.g., no suitable bins)\n    if max_raw_score == -np.inf:\n        return np.zeros(num_bins)\n\n    shifted_scores = (raw_scores - max_raw_score) / temperature\n    \n    # Calculate exponential of shifted scores\n    exp_scores = np.exp(shifted_scores)\n    \n    # Calculate sum of exponential scores for normalization\n    sum_exp_scores = np.sum(exp_scores)\n    \n    # Calculate probabilities\n    probabilities = exp_scores / sum_exp_scores\n    \n    # Ensure probabilities sum to 1 (due to potential floating point inaccuracies)\n    # And handle cases where sum_exp_scores might be 0 (e.g., all shifted scores were -inf)\n    if sum_exp_scores > 0:\n        probabilities /= np.sum(probabilities) # Re-normalize\n    else:\n        # This case should ideally not happen if max_raw_score was handled correctly,\n        # but as a fallback, if all exp_scores resulted in 0, distribute uniformly or zero out.\n        # Given our max_raw_score shift, this implies all shifted scores were extremely negative.\n        probabilities = np.zeros(num_bins)\n\n    # Ensure probabilities are not NaN\n    probabilities = np.nan_to_num(probabilities)\n\n    return probabilities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a softmax-based heuristic.\n\n    This heuristic prioritizes bins that can accommodate the item, with a stronger\n    preference for \"tight fits\" (bins with remaining capacity close to the item size).\n    The `temperature` parameter controls the exploration vs. exploitation trade-off.\n    Higher temperatures lead to more uniform probabilities (more exploration), while\n    lower temperatures focus on the best-fitting bins (more exploitation).\n    Bins that are too small for the item receive a priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        temperature: Controls the sharpness of the softmax distribution.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score (probability) of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit, calculate a \"goodness\" score.\n    # We want to prioritize bins where the remaining capacity is close to the item size.\n    # A common approach is to use the difference (remaining_capacity - item).\n    # To prioritize smaller differences (tighter fits), we can use the negative of this difference.\n    # We add a small epsilon to avoid issues when remaining_capacity == item.\n    # A larger negative value (more negative) indicates a worse fit, a value closer to zero is a better fit.\n    # To make better fits have higher scores for softmax, we can invert this or use a different metric.\n    # Let's try prioritizing based on how much capacity is LEFT OVER after packing.\n    # So, (remaining_capacity - item) is what we want to minimize.\n    # For softmax, higher values mean higher probability. So, we want a metric that is\n    # higher for better fits. A good metric would be the negative of the leftover capacity,\n    # or a Gaussian-like function centered at 0 difference.\n    # Let's use negative difference, then scale it to make it more sensitive to near fits.\n    # A simple transformation that boosts near-fits and reduces others:\n    # Consider -(bins_remain_cap[can_fit_mask] - item) which is (item - bins_remain_cap[can_fit_mask]).\n    # This value is negative or zero. Higher values (closer to zero) are better fits.\n    # To make it suitable for softmax where higher is better, we can use `-(bins_remain_cap[can_fit_mask] - item)`.\n    # However, this might still be too sensitive to very small items.\n    # Let's consider a score that is high when `bins_remain_cap[can_fit_mask] - item` is small and positive.\n    # The inverse `1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)` from v1 is good.\n    # Let's refine this. We want to reward bins where `bins_remain_cap - item` is small.\n    # A Gaussian-like kernel centered at 0 difference could work: exp(- (diff^2) / (2 * sigma^2))\n    # Or, a simpler approach: consider `1 / (1 + diff)` where diff is `bins_remain_cap - item`.\n    # If diff is small and positive, score is close to 1. If diff is large, score approaches 0.\n\n    # Let's try a score that emphasizes small positive differences.\n    # We want a high score when `bins_remain_cap[can_fit_mask] - item` is small and positive.\n    # Consider `1.0 / (1.0 + (bins_remain_cap[can_fit_mask] - item))`\n    # This gives scores between (0, 1] for valid fits. 1 for perfect fits.\n\n    # Alternative: Prioritize bins with minimum remaining capacity that can fit the item.\n    # This is essentially the \"Best Fit\" strategy. For a heuristic priority, we can\n    # use the inverse of the remaining capacity for fitting bins.\n    # `priorities[can_fit_mask] = 1.0 / bins_remain_cap[can_fit_mask]` - This prioritizes smallest bins.\n    # If we want to prioritize tight fits, we are looking for bins where `bins_remain_cap - item` is small.\n    # So, we want to maximize `- (bins_remain_cap[can_fit_mask] - item)`.\n    # Or, a score that is high for small positive `bins_remain_cap[can_fit_mask] - item`.\n    # Let's use `-(bins_remain_cap[can_fit_mask] - item)` directly, then rescale or apply softmax.\n    # The intuition of `1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)` was good.\n    # Let's enhance it for \"nearness\".\n\n    # Consider the \"wasted space\" after packing: `wasted_space = bins_remain_cap - item`.\n    # We want to minimize `wasted_space`. So, a higher priority should be given to bins with smaller `wasted_space`.\n    # Let's transform `wasted_space` into a score where smaller `wasted_space` yields a higher score.\n    # A simple transformation: `score = 1.0 / (1.0 + wasted_space)`.\n    # This gives scores in the range (0, 1]. Perfect fit -> score 1. Large wasted space -> score close to 0.\n    # This should provide a good signal for \"tight fits\".\n\n    wasted_space = bins_remain_cap[can_fit_mask] - item\n    # Using `1.0 / (1.0 + wasted_space)` maps small positive wasted space to values close to 1.\n    # For a perfect fit (wasted_space = 0), score is 1.\n    # For larger wasted_space, score decreases.\n    scores_for_softmax = 1.0 / (1.0 + wasted_space)\n\n    # Apply softmax to get probabilities.\n    # Ensure temperature is positive to avoid division by zero or invalid operations.\n    if temperature <= 0:\n        raise ValueError(\"Temperature must be positive.\")\n\n    # Calculate exponentiated scores, scaled by temperature\n    # Lower temperature means sharper distribution, higher temperature means flatter.\n    exp_scores = np.exp(scores_for_softmax / temperature)\n\n    # Normalize to get probabilities\n    probabilities = exp_scores / np.sum(exp_scores)\n\n    # Assign probabilities to the original priorities array\n    priorities[can_fit_mask] = probabilities\n\n    # Normalize priorities to sum to 1, ensuring valid probability distribution\n    # This is already handled by the softmax if there's at least one bin that can fit.\n    # If no bins can fit, priorities remains all zeros, which is correct.\n    if np.sum(priorities) > 0:\n        priorities /= np.sum(priorities)\n\n    return priorities\n\n[Reflection]\nSimplify. Focus on the core problem. Remove complex, less impactful features.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}