```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for online bin packing using a First Fit Decreasing-like heuristic.

    This heuristic prioritizes bins that are a "tight fit" for the item (minimize remaining capacity
    after packing) and, among bins with similar tightness, it favors those that appear earlier
     in the `bins_remain_cap` array (simulating First Fit behavior).

    The priority score is designed such that a higher score indicates a more preferred bin.
    Specifically, it aims to:
    1. Maximize the "tightness" of the fit: A bin where `bins_remain_cap - item` is small (close to 0)
       is preferred. This is achieved by using `-(bins_remain_cap - item)` as a component of the score.
    2. Break ties in tightness by favoring earlier bins: A bin with a smaller index is preferred if
       multiple bins offer the same tightness. This is achieved by subtracting a small penalty
       proportional to the bin's index.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array representing the remaining capacity of each bin.

    Returns:
        A numpy array of the same size as `bins_remain_cap`, where each element is the priority
        score for the corresponding bin. Bins that cannot accommodate the item will have a
        very low priority score (-infinity).
    """
    # A small epsilon to ensure that bins with smaller indices are prioritized when the fit is equally tight.
    # This value should be small enough not to override the tightness score, but large enough
    # to consistently break ties based on index.
    epsilon_tiebreaker = 1e-6

    # Initialize all priorities to a very low value, indicating that these bins are not suitable
    # or have the lowest possible priority.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins can accommodate the current item.
    can_fit_mask = bins_remain_cap >= item

    # If there are any bins that can fit the item:
    if np.any(can_fit_mask):
        # Get the indices of the bins that can fit the item.
        fitting_indices = np.where(can_fit_mask)[0]
        # Get the remaining capacities of these fitting bins.
        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]

        # Calculate the "tightness" score. We want to maximize the tightness,
        # which means minimizing the remaining capacity after placing the item.
        # The difference `fitting_bins_remain_cap - item` represents the slack or wasted space.
        # A smaller slack is better. So, we use `-(slack)` to convert minimization to maximization.
        # This ensures that bins with `fitting_bins_remain_cap` closest to `item` get higher scores.
        tightness_score = -(fitting_bins_remain_cap - item)

        # To implement the "First Fit" aspect, we need to prioritize bins with smaller indices
        # when the tightness scores are equal. We achieve this by subtracting a penalty
        # that increases with the index. The `epsilon_tiebreaker` scales this penalty.
        # The final priority for fitting bins is `tightness_score - (index * epsilon_tiebreaker)`.
        # This way, for the same `tightness_score`, a smaller `index` results in a higher priority.
        index_penalty = fitting_indices * epsilon_tiebreaker
        priorities[can_fit_mask] = tightness_score - index_penalty

    return priorities
```
