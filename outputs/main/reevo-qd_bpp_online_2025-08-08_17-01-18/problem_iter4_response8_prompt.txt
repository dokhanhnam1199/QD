{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n\n    The strategy favors bins that are a \"good fit\" for the item (i.e., leaving\n    a small remaining capacity), but with a probability epsilon, it assigns a\n    consistent exploration score to encourage trying less optimal bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 0.2  # Probability of exploration\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros(num_bins)\n\n    # Identify bins that can accommodate the item\n    suitable_bins_mask = bins_remain_cap >= item\n    suitable_bins_indices = np.where(suitable_bins_mask)[0]\n\n    if len(suitable_bins_indices) == 0:\n        return priorities  # No bin can fit the item\n\n    # --- Exploitation Component (Good Fit) ---\n    # Calculate a score based on how well the item fits.\n    # We want to prioritize bins that leave minimal remaining capacity.\n    # Score = 1 / (remaining_capacity - item + epsilon)\n    # A smaller difference means a higher score.\n    fit_scores = 1.0 / (bins_remain_cap[suitable_bins_indices] - item + 1e-6)\n\n    # Normalize fit_scores to a 0-1 range to represent the \"exploitation\" priority.\n    # Higher score means better fit.\n    if fit_scores.max() > fit_scores.min():\n        exploitation_priorities = (fit_scores - fit_scores.min()) / (fit_scores.max() - fit_scores.min())\n    else:\n        exploitation_priorities = np.ones(len(suitable_bins_indices)) # All fits are equally good\n\n    # Assign the exploitation priorities to the suitable bins\n    priorities[suitable_bins_indices] = exploitation_priorities\n\n    # --- Exploration Component ---\n    # With probability epsilon, overwrite the exploitation priority with a\n    # consistent, lower exploration score for a random subset of suitable bins.\n    # This encourages exploration of bins that might not be the immediate best fit.\n    exploration_score = 0.1 # A fixed low score for exploration\n\n    # Determine which suitable bins will be subject to exploration\n    num_suitable = len(suitable_bins_indices)\n    explore_indices_in_suitable = np.random.choice(\n        num_suitable,\n        size=int(np.ceil(epsilon * num_suitable)),\n        replace=False\n    )\n    \n    # Get the actual indices in the original bins_remain_cap array\n    bins_to_explore_indices = suitable_bins_indices[explore_indices_in_suitable]\n\n    # Assign the exploration score to these bins\n    priorities[bins_to_explore_indices] = exploration_score\n\n    # Ensure that bins that cannot fit the item have zero priority\n    priorities[~suitable_bins_mask] = 0\n\n    # Optional: Normalize final priorities if a specific range is required by downstream logic.\n    # For now, we return the scores as calculated, where higher means more preferred.\n    # A simple max-min normalization can be applied if needed:\n    # if priorities.max() > priorities.min():\n    #     final_priorities = (priorities - priorities.min()) / (priorities.max() - priorities.min())\n    # else:\n    #     final_priorities = np.ones(num_bins) * 0.5\n    # return final_priorities\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit strategy.\n\n    The Almost Full Fit strategy prioritizes bins that, after placing the item,\n    will have the least remaining capacity among bins that can still accommodate the item.\n    This aims to fill bins as much as possible before opening new ones.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot accommodate the item will have a priority of 0.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Find bins that can accommodate the item\n    possible_bins_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity after placing the item in possible bins\n    remaining_after_placement = bins_remain_cap[possible_bins_mask] - item\n\n    # If there are no possible bins, return all zeros\n    if remaining_after_placement.size == 0:\n        return priorities\n\n    # Calculate the \"tightness\" score for possible bins.\n    # We want to minimize the remaining capacity, so a smaller remaining capacity\n    # should result in a higher priority.\n    # We use the inverse of the remaining capacity. To avoid division by zero\n    # or extremely high priorities for bins that become exactly full, we can\n    # add a small epsilon or use a scaled inverse.\n    # A common approach is to consider bins that leave little to no space.\n    # We want to maximize the chance of the bin becoming \"almost full\".\n\n    # Let's aim for a score where smaller remaining capacity is better.\n    # A simple approach is to use the negative of the remaining capacity.\n    # However, to make it a \"priority\" score (higher is better), we can\n    # invert it and potentially scale it.\n\n    # To prioritize bins that leave minimal remaining space, we can take\n    # the negative of the remaining capacity. The larger (less negative)\n    # the value, the less space is left, thus higher priority.\n    # Let's refine this: We want bins that, after placing the item, will have\n    # the *least* remaining capacity. This means we want to *minimize*\n    # `bins_remain_cap - item`.\n    # If we want higher scores to be better, we can assign a score based on\n    # the inverse of the remaining capacity.\n    # However, the goal is to fill bins. So bins that will be closest to full\n    # after placing the item are preferred.\n\n    # Consider the difference: max_capacity - (remaining_after_placement)\n    # This is effectively how much space is used. We want to maximize this.\n    # So, `item` is constant. Maximizing `bins_remain_cap[i] - remaining_after_placement[i]`\n    # means maximizing `bins_remain_cap[i] - (bins_remain_cap[i] - item)` which is just `item`.\n    # This isn't quite right.\n\n    # \"Almost Full Fit\" suggests bins that are ALMOST full.\n    # After placing the item, a bin is \"almost full\" if its remaining capacity is small.\n    # So, we want to minimize `bins_remain_cap[i] - item`.\n    # To convert this to a priority score (higher is better), we can:\n    # 1. Use `1 / (remaining_after_placement + epsilon)` where epsilon is a small number to avoid division by zero.\n    # 2. Use `-(remaining_after_placement)`\n    # 3. Use `max_possible_remaining - remaining_after_placement` for some large `max_possible_remaining`\n    #    which is equivalent to `some_constant - remaining_capacity`.\n\n    # Let's try option 2: higher priority for smaller remaining capacity.\n    # So, `priority = -remaining_capacity`. This means a bin with remaining_capacity=1\n    # gets priority -1, and a bin with remaining_capacity=0 gets priority 0.\n    # This seems to fit the idea of \"smallest remaining capacity\".\n\n    # To make it more \"priority-like\" (higher is better), we can use:\n    # `priority = C - remaining_capacity`, where C is a large constant, or\n    # `priority = 1 / (remaining_capacity + epsilon)`\n\n    # Let's use the concept that the *difference* between what's remaining and what's desired (a full bin)\n    # should be minimized. So, `remaining_capacity` should be small.\n    # A score that reflects this: `max(0, C - remaining_capacity)`.\n    # If we want to prioritize bins that become *most* full after the item,\n    # this means the remaining capacity is minimized.\n\n    # Consider the bin that would become \"most full\". This is the bin where\n    # `bins_remain_cap[i] - item` is minimized.\n    # So, higher priority for smaller `bins_remain_cap[i] - item`.\n    # Let's transform `bins_remain_cap[i] - item` into a priority:\n    # `priority = some_large_value - (bins_remain_cap[i] - item)`\n    # This is equivalent to `some_large_value - bins_remain_cap[i] + item`.\n    # Since `item` is constant for all bins, this is `constant - bins_remain_cap[i]`.\n    # We want to maximize this, so we want to minimize `bins_remain_cap[i]`.\n\n    # Another perspective on \"almost full\":\n    # We want to pick the bin that, after placing the item, is closest to full.\n    # This means `bins_remain_cap[i] - item` is minimal.\n    # Let's assign a priority based on this minimum value.\n\n    # A common heuristic for \"Best Fit\" or \"Almost Full Fit\" is to try to minimize\n    # the remaining capacity of the bin *after* placing the item.\n    # This means we want to select the bin `i` that minimizes `bins_remain_cap[i] - item`.\n    # To convert this into a priority score (where higher means more desirable),\n    # we can use `-(bins_remain_cap[i] - item)` or `1 / (bins_remain_cap[i] - item + epsilon)`.\n\n    # Let's try using `1 / (remaining_after_placement + epsilon)` where epsilon is small.\n    # This ensures that bins with very small remaining capacity get very high priorities.\n\n    epsilon = 1e-6\n    priorities[possible_bins_mask] = 1.0 / (remaining_after_placement + epsilon)\n\n    # Alternatively, if we want to give a higher score to bins that leave *less*\n    # remaining space, we can simply use the negative of the remaining space,\n    # or a scaled version of it.\n\n    # Let's consider the original \"Almost Full Fit\" idea: prioritize bins that are\n    # already close to full. However, the problem statement for this function\n    # implies prioritizing based on the *outcome* after placing the item.\n    # \"priority score for each bin ... bin with the highest priority score will be selected for the item.\"\n\n    # If the goal is to fill bins, then after placing the item, we want the bin\n    # with the *least* remaining capacity.\n    # So, `priority = f(remaining_capacity)` where `f` is decreasing.\n    # `f(x) = 1/(x + epsilon)` or `f(x) = -x`.\n    # Let's use the `1/(x + epsilon)` approach for a strong preference towards tighter fits.\n\n    return priorities\n\n[Reflection]\nPrioritize minimal remaining capacity after placement; explore to avoid local optima.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}