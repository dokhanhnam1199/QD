```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 1.0) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a temperature-controlled heuristic.

    This heuristic aims to balance exploitation (fitting into bins that leave minimal
    remaining capacity) and exploration (trying bins that might not be the immediate
    best fit). It uses a score based on the "wasted space" after packing, transformed
    to favor tighter fits, and then applies a softmax function.

    The `temperature` parameter controls the exploration-exploitation trade-off:
    - Low temperature (e.g., close to 0): Exploitation-heavy, favors bins with the
      smallest `bins_remain_cap - item`.
    - High temperature (e.g., >> 1): Exploration-heavy, probabilities become more uniform,
      allowing less optimal bins to be chosen more frequently.

    Args:
        item: Size of the item to be packed.
        bins_remain_cap: A numpy array representing the remaining capacity of each bin.
        temperature: A float controlling the softmax sharpness. Must be positive.

    Returns:
        A numpy array of priority scores (probabilities) for each bin. Bins that cannot
        accommodate the item will have a priority of 0.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # If no bins can fit the item, return all zeros
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the "goodness" score for bins that can fit the item.
    # We want to prioritize bins where the remaining capacity is as close as possible
    # to the item size (i.e., minimize `remaining_capacity - item`).
    # A good score function should be higher for smaller non-negative differences.
    # Using `1.0 / (1.0 + (bins_remain_cap[can_fit_mask] - item))` achieves this:
    # - If `remaining_capacity - item` is 0 (perfect fit), score is 1.0.
    # - If `remaining_capacity - item` is small positive, score is close to 1.0.
    # - If `remaining_capacity - item` is large positive, score approaches 0.0.
    wasted_space = bins_remain_cap[can_fit_mask] - item
    goodness_scores = 1.0 / (1.0 + wasted_space)

    # Apply softmax to convert goodness scores into probabilities.
    # The temperature parameter controls the "flatness" of the probability distribution.
    # Higher temperature -> flatter distribution (more exploration).
    # Lower temperature -> sharper distribution (more exploitation).
    if temperature <= 0:
        raise ValueError("Temperature must be positive for softmax.")

    # Ensure scores are not excessively large before exponentiation, though 1.0 / (1.0 + wasted_space)
    # is bounded between (0, 1] so this is generally safe.
    scaled_scores = goodness_scores / temperature
    exp_scores = np.exp(scaled_scores)

    # Normalize the exponentiated scores to get probabilities
    sum_exp_scores = np.sum(exp_scores)
    if sum_exp_scores > 0:
        probabilities = exp_scores / sum_exp_scores
    else:
        # This case should ideally not happen if there's at least one bin that fits,
        # unless goodness_scores are all -inf (not possible here).
        # If it does, assign uniform probability among fitting bins.
        num_fitting_bins = np.sum(can_fit_mask)
        probabilities = np.ones(num_fitting_bins) / num_fitting_bins

    # Assign the calculated probabilities to the corresponding bins
    priorities[can_fit_mask] = probabilities

    return priorities
```
