```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Tight Fit strategy.

    The Tight Fit strategy prioritizes bins that, after placing the item,
    will have the least remaining capacity among bins that can still accommodate the item.
    This aims to fill bins as much as possible before opening new ones. Bins that cannot
    accommodate the item will have a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate remaining capacity after placing the item in possible bins
    remaining_after_placement = bins_remain_cap[can_fit_mask] - item

    # If no bins can fit the item, return all zeros
    if remaining_after_placement.size == 0:
        return priorities

    # To prioritize bins that leave the least remaining capacity, we want to
    # assign a higher score to smaller values of `remaining_after_placement`.
    # A common way to achieve this is by using the inverse. To avoid division by zero
    # for bins that become exactly full (remaining_after_placement = 0), we add a small epsilon.
    # A larger value of `1 / (remaining_after_placement + epsilon)` indicates a tighter fit.
    epsilon = 1e-6
    priorities[can_fit_mask] = 1.0 / (remaining_after_placement + epsilon)

    return priorities
```
