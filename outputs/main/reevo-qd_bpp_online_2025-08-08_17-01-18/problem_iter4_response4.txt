```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Softmax-based approach
    that also incorporates an epsilon-greedy exploration strategy.

    This heuristic first calculates a "fit score" for each bin. A better fit is defined as a bin
    where the remaining capacity is just enough for the item (i.e., `bins_remain_cap - item` is small and positive).
    The score is designed such that a smaller positive difference yields a higher score.
    These scores are then transformed using softmax to generate probabilities.
    An epsilon-greedy component is integrated: with a small probability `epsilon`, a bin is chosen randomly
    from the *suitable* bins to encourage exploration. Otherwise, the greedy (softmax-derived)
    priorities are used.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.1  # Probability of exploring a random suitable bin

    # Identify bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item
    suitable_bin_indices = np.where(suitable_bins_mask)[0]

    n_bins = len(bins_remain_cap)
    priorities = np.zeros(n_bins)

    if len(suitable_bin_indices) == 0:
        # No bin can fit the item, return all zeros
        return priorities

    # Epsilon-greedy choice: With probability epsilon, pick a random suitable bin
    if np.random.rand() < epsilon:
        # Choose one suitable bin randomly
        chosen_index = np.random.choice(suitable_bin_indices)
        # Assign a high priority to this randomly chosen bin
        priorities[chosen_index] = 1.0
        # For other suitable bins, assign a very low priority to make the chosen one stand out
        priorities[suitable_bin_indices] = 1e-9
        return priorities

    # If not exploring, use a greedy strategy based on how well the item fits.
    # We want bins where the remaining capacity is just enough for the item.
    # The score should be higher for bins with `bins_remain_cap - item` closer to 0 (but positive).
    # A good scoring function would be related to `1 / (bins_remain_cap - item + small_constant)`
    # or `-(bins_remain_cap - item)` which is `item - bins_remain_cap`.
    # Let's use `item - bins_remain_cap` to prioritize smaller positive differences.
    scores = item - bins_remain_cap

    # For bins that cannot fit the item, assign a very low score (effectively -infinity for softmax)
    # This ensures their softmax probability is negligible.
    scores[~suitable_bins_mask] = -np.inf

    # Calculate softmax probabilities
    # To prevent potential overflow with large positive scores, we shift scores
    # so that the maximum score becomes 0.
    # We only consider scores for suitable bins for the maximum calculation.
    max_score_for_suitable = np.max(scores[suitable_bins_mask]) if np.any(suitable_bins_mask) else 0
    
    shifted_scores = scores - max_score_for_suitable
    
    # Calculate exponentiated scores. Bins with -inf will result in 0.
    exp_scores = np.exp(shifted_scores)
    
    # Calculate the sum of exponentiated scores. Ensure it's not zero.
    sum_exp_scores = np.sum(exp_scores)
    
    if sum_exp_scores == 0:
        # This can happen if all suitable bins had scores that resulted in exp_scores close to zero
        # or if somehow all suitable bins were removed or became invalid.
        # As a fallback, assign uniform probability to all suitable bins.
        if np.any(suitable_bins_mask):
            priorities[suitable_bins_mask] = 1.0 / len(suitable_bin_indices)
        return priorities
    
    priorities = exp_scores / sum_exp_scores

    return priorities
```
