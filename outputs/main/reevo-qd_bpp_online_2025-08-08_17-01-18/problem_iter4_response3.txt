```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a hybrid approach.

    This heuristic combines the "Best Fit" (minimizing remaining capacity) with an
    element of exploration. It prioritizes bins that leave minimal remaining capacity
    after placing the item, but also assigns a small, non-zero priority to bins that
    are not perfect fits to encourage exploration of potentially better long-term solutions.

    The "goodness" of a fit is measured by the remaining capacity after placing the item.
    A smaller remaining capacity is considered a better fit. To convert this into a
    priority score, we use an exponential decay based on the slack.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins)

    # Identify bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item
    suitable_bins_indices = np.where(suitable_bins_mask)[0]

    if len(suitable_bins_indices) == 0:
        return priorities  # No bin can fit the item

    # --- Calculate "goodness of fit" score ---
    # We want to minimize (bins_remain_cap - item), which is the slack.
    # A smaller slack means a better fit.
    slack_values = bins_remain_cap[suitable_bins_indices] - item

    # Transform slack into an attractiveness score.
    # We use an exponential function: exp(-slack / T). A smaller slack leads to a higher score.
    # T (temperature) controls how strongly we favor the best fit. Smaller T = stronger preference.
    temperature = 0.3  # Hyperparameter to tune exploration vs. exploitation balance
    
    # Add a small epsilon to avoid potential issues with exp(0) if slack is exactly 0,
    # though exp(0) is 1, which is fine. The main goal is to have scores that
    # decrease as slack increases.
    fit_scores = np.exp(-slack_values / temperature)

    # --- Exploration component ---
    # Add a small base score to all suitable bins to ensure some level of exploration.
    # This prevents bins that are not the absolute best fit from having zero chance.
    exploration_bonus = 0.1  # A small constant added to all suitable bins

    # Combine fit scores with exploration bonus
    # We add the bonus to all suitable bins, so the relative preference of the best fits is maintained.
    combined_scores = fit_scores + exploration_bonus

    # Normalize scores to sum to 1 (or to be interpretable as probabilities)
    # This ensures that the priorities are on a consistent scale.
    # Using softmax-like normalization for the combined scores.
    # Add a small epsilon to the sum to prevent division by zero if all scores are very small.
    sum_of_scores = np.sum(combined_scores)
    if sum_of_scores > 1e-9:
        normalized_priorities = combined_scores / sum_of_scores
    else:
        # If all combined scores are near zero, distribute equally among suitable bins.
        normalized_priorities = np.ones_like(combined_scores) / len(combined_scores)

    # Assign the calculated priorities back to the original bins
    priorities[suitable_bins_indices] = normalized_priorities

    return priorities
```
