```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority scores for packing an item into bins using a simplified
    and adaptive heuristic.

    This heuristic prioritizes bins that have just enough remaining capacity
    for the item, aiming for tight fits. It uses a simple linear scoring
    mechanism for bins that can fit the item, preferring those with less
    remaining capacity after packing. A small random component is added
    to encourage exploration, with the probability of exploration decreasing
    as more items are packed (implicitly, as the number of bins grows or
    bins become more full).

    The scoring is designed to be interpretable and efficient.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A NumPy array representing the remaining capacity of each bin.

    Returns:
        A NumPy array of priority scores, same size as `bins_remain_cap`.
        Bins that cannot fit the item will have a score of 0.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate scores for bins that can fit the item
    if np.any(can_fit_mask):
        suitable_bins_cap = bins_remain_cap[can_fit_mask]

        # Score: Prioritize bins that leave minimal remaining capacity.
        # A simple inverse relationship with (remaining_capacity - item) works well.
        # Adding 1 to the denominator prevents division by zero for perfect fits
        # and dampens extremely high scores for perfect fits.
        scores = 1.0 / (suitable_bins_cap - item + 1.0)

        # Normalize scores to a [0, 1] range to make them comparable and stable.
        min_score = np.min(scores)
        max_score = np.max(scores)

        if max_score > min_score:
            normalized_scores = (scores - min_score) / (max_score - min_score)
        else:
            # If all suitable bins yield the same score (e.g., all have same remaining capacity after fit),
            # assign a uniform high score (e.g., 1.0) to all of them.
            normalized_scores = np.ones(scores.shape)

        priorities[can_fit_mask] = normalized_scores

    # Simple exploration: With a small, fixed probability, pick a random bin
    # among the ones that can fit. This is simpler than Softmax or complex
    # adaptive epsilon, balancing exploration and exploitation.
    exploration_prob = 0.05 # Fixed small probability for exploration
    if np.random.rand() < exploration_prob:
        possible_bins_indices = np.where(can_fit_mask)[0]
        if possible_bins_indices.size > 0:
            # Select a random bin among those that can fit.
            random_bin_index = np.random.choice(possible_bins_indices)
            
            # Assign the highest priority to the randomly chosen bin.
            # This effectively makes the random choice override the calculated priority.
            priorities = np.zeros(num_bins, dtype=float) # Reset all priorities
            priorities[random_bin_index] = 1.0         # Give highest priority to random bin

    return priorities
```
