```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Exact Fit First strategy: prioritize bins that the item fits perfectly into.
    If no exact fit is found, assign a low priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    # Assign a high priority (e.g., 1.0) to bins where the item fits exactly
    exact_fit_mask = (bins_remain_cap == item)
    priorities[exact_fit_mask] = 1.0
    # Assign a slightly lower priority to bins that can accommodate the item
    # This part is not strictly Exact Fit First, but could be a fallback
    # For pure Exact Fit First, only bins with exact fits would get priority.
    # If we want to strictly adhere to Exact Fit First and only prioritize
    # exact fits, we could stop here. However, in an online setting, if
    # no exact fit exists, we still need to pack the item.
    # For this version, let's assume we *only* care about exact fits.
    # If we wanted a fallback, we might assign priorities based on
    # remaining capacity if no exact fit is found.

    # To be strictly Exact Fit First, we'd only consider exact fits.
    # If an item can perfectly fit into multiple bins, any of them can be chosen.
    # For demonstration, if multiple exact fits, they all get the same highest priority.
    return priorities
```
