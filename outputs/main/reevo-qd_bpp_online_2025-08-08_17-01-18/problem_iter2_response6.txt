```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined First Fit-like heuristic.

    This heuristic prioritizes bins that are a "tight fit" for the item (i.e.,
    leaving minimal remaining capacity after placing the item), and among bins
    with the same "tightness", it prefers bins that appear earlier in the array
    (simulating the "first fit" behavior).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority. Bins that cannot fit the item
        will have a very low priority (-infinity).
    """
    # A mask to identify bins that can accommodate the item.
    can_fit_mask = bins_remain_cap >= item

    # Initialize priorities for all bins to a very low value,
    # effectively marking them as unselectable unless they can fit the item.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # If there are any bins that can fit the item:
    if np.any(can_fit_mask):
        # Get the indices of the bins that can fit the item.
        fitting_indices = np.where(can_fit_mask)[0]
        # Get the remaining capacities of these fitting bins.
        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]

        # Calculate the "slack" for each fitting bin. Slack is the remaining capacity
        # after placing the item (bins_remain_cap - item). A smaller slack means a
        # tighter fit, which is more desirable.
        slack = fitting_bins_remain_cap - item

        # To prioritize tighter fits, we want to maximize the "goodness" of the fit.
        # A direct way to do this is to use the negative of the slack: `-slack`.
        # Maximizing `-slack` is equivalent to minimizing `slack`.

        # To implement the "first fit" aspect (preferring earlier bins in case of
        # ties in slack), we can add a small penalty to bins with higher indices.
        # This ensures that if two bins have the same minimal slack, the one with
        # the lower index will have a slightly higher priority.
        # We subtract `index * epsilon` from the priority, where `epsilon` is a small
        # positive number. This makes the priority decrease slightly as the index increases.
        epsilon_tiebreaker = 1e-6  # A small value to ensure distinct priorities for tie-breaking.

        # The priority is calculated as: -slack - (index * epsilon_tiebreaker)
        # This means:
        # 1. Tighter fits (smaller slack) result in a larger negative slack, hence a higher priority.
        # 2. For equal slack, smaller indices result in a smaller penalty, hence a higher priority.
        priorities[can_fit_mask] = -slack - (fitting_indices * epsilon_tiebreaker)

    # The resulting `priorities` array contains high values for the best fitting bins
    # (tightest fit, earliest index) and -inf for bins that cannot fit the item.
    return priorities
```
