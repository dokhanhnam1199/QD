```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit strategy.

    The Almost Full Fit strategy prioritizes bins that are almost full and can still
    accommodate the item. It aims to fill bins as much as possible before opening
    a new one, while leaving just enough space for the current item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can accommodate the item
    valid_bins_mask = bins_remain_cap >= item

    # For valid bins, calculate the "closeness to full" after adding the item.
    # A higher "remaining capacity" (after adding the item) means it's less full.
    # We want to prioritize bins that will be *closer* to full *after* the item is placed.
    # This means bins with a smaller remaining capacity after the item is placed.
    # So, we calculate the remaining capacity if the item is placed, and then
    # we want to *minimize* this value. Inverting this and adding a small epsilon
    # for a higher score for smaller remaining capacity.

    # Calculate the remaining capacity if the item were placed in each valid bin
    remaining_cap_after_add = bins_remain_cap[valid_bins_mask] - item

    # The "almost full" heuristic means we prefer bins that will have a small
    # remaining capacity after adding the item.
    # Let's define priority as the inverse of the remaining capacity (plus a small constant to avoid division by zero and to ensure that bins with some remaining capacity get a positive score).
    # A higher priority means we prefer that bin more.
    # So, if remaining_cap_after_add is small, priority should be high.
    # We use 1 / (remaining_cap_after_add + epsilon) for this.
    epsilon = 1e-6
    priorities[valid_bins_mask] = 1.0 / (remaining_cap_after_add + epsilon)

    # To further emphasize the "almost full" aspect, we can boost bins that are
    # very close to being full. Let's say a bin is "almost full" if its remaining
    # capacity is less than a certain threshold *before* adding the item.
    # However, the requirement is to prioritize based on the state *after* adding.
    # So, the calculation above (1.0 / (remaining_cap_after_add + epsilon)) already
    # implicitly favors bins that will be more full.

    # An alternative interpretation of "Almost Full Fit" could be to prioritize
    # bins where placing the item results in the smallest *increase* in remaining space
    # for *other* items. This is already captured by minimizing `remaining_cap_after_add`.

    # If no bins can accommodate the item, all priorities remain 0.
    # If there are valid bins, we want to select the one that, after adding the item,
    # will have the *least* remaining capacity.

    return priorities
```
