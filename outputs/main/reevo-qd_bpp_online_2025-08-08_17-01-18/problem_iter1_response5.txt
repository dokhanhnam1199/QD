```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit) strategy.

    The Inverse Distance strategy prioritizes bins that are "closer" to accommodating the item,
    meaning bins with remaining capacity that is just slightly larger than the item size.
    This helps in leaving larger remaining capacities in other bins for potentially larger items later.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate the "distance" or "difference" between bin capacity and item size
    # Only consider bins where the item can actually fit
    for i, capacity in enumerate(bins_remain_cap):
        if capacity >= item:
            # The "proximity" is the remaining capacity after placing the item.
            # A smaller remaining capacity indicates a better "fit" or proximity.
            # We want to maximize priority for bins that are a good fit.
            # Inverse distance: 1 / (difference + epsilon)
            # To avoid division by zero and give a high priority to a perfect fit,
            # we can use the remaining capacity after placing the item.
            # A smaller remaining capacity is better (closer fit).
            # So, we want to prioritize bins where `capacity - item` is small.
            # A common heuristic is to use `1 / (remaining_capacity_after_fit + small_epsilon)`
            # to favor bins that leave less space, thus packing more tightly.

            # Let's use remaining_capacity = capacity - item
            remaining_capacity_after_fit = capacity - item

            # To avoid division by zero when remaining_capacity_after_fit is 0 (perfect fit)
            # and to ensure higher priority for smaller remaining capacities:
            # We can use `1 / (remaining_capacity_after_fit + 1)` to ensure non-zero denominators
            # and still rank smaller remaining capacities higher.
            # An alternative is to use a small epsilon, e.g., `1 / (remaining_capacity_after_fit + 1e-9)`
            # or simply to negate the remaining capacity if we want the LARGEST value
            # to correspond to the tightest fit.

            # For inverse distance (proximity), we want to maximize the priority for the bin
            # that has `capacity - item` as small as possible.
            # A smaller `capacity - item` means it's a "closer" fit.
            # So, we can simply use the negative of this difference as the priority,
            # or inversely related to it.
            # Let's aim for a higher priority for a tighter fit.
            # The tightest fit means `capacity - item` is close to 0.
            # A simple approach: `1.0 / (capacity - item + 1e-6)`
            # This gives a high score when `capacity - item` is small.
            # Another way is to think about it as prioritizing bins with `capacity`
            # that are closest to `item`.

            # Let's go with the direct interpretation of "inverse distance" from the capacity.
            # The "distance" of the bin's capacity from the item size is `capacity - item`.
            # We want bins where this distance is minimized.
            # Thus, priority is inversely proportional to this distance.
            # priority = 1 / (capacity - item + epsilon)

            # Adding 1 to the denominator to handle perfect fits (capacity == item)
            # and avoid division by zero, also makes smaller differences have higher priority.
            priorities[i] = 1.0 / (remaining_capacity_after_fit + 1.0)

    # It's crucial to ensure that bins that cannot fit the item have zero or very low priority,
    # which is handled by the initial zeros and the `if capacity >= item` check.

    return priorities
```
