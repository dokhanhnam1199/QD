```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Epsilon-Greedy.

    This heuristic prioritizes bins that can fit the item and are "nearly full"
    (i.e., have little remaining capacity after fitting the item), as this
    encourages tighter packing. A small random exploration component is added
    to avoid getting stuck in local optima. The exploration rate (epsilon) is
    reduced to favor greedy choices more. Scores are normalized to a [0, 1] range
    for a more stable epsilon-greedy behavior.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.05  # Reduced probability of random exploration for more greedy behavior
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate scores for bins that can fit the item
    # Prioritize bins that leave little remaining capacity after fitting the item.
    # Score is the inverse of the remaining capacity after fitting.
    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item
    
    # Add a small constant to the denominator to prevent division by zero and overly large scores
    # for bins that perfectly fit the item.
    scores = 1.0 / (remaining_capacity_after_fit + 1e-6) 
    
    # Normalize scores to be between 0 and 1.
    # This makes the epsilon-greedy selection more balanced.
    if scores.size > 0:
        min_score = np.min(scores)
        max_score = np.max(scores)
        if max_score > min_score:
            priorities[can_fit_mask] = (scores - min_score) / (max_score - min_score)
        else:
            # If all scores are the same (e.g., all bins have the same remaining capacity after fit),
            # assign a neutral priority, or simply a value representing the best fit.
            # Assigning 0.5 could be seen as neutral, but since they are all equally good,
            # a higher uniform value (like 1.0) might be more indicative of a good fit.
            # Let's stick to a normalized 1.0 for "equally best" fit.
            priorities[can_fit_mask] = 1.0
    
    # Epsilon-Greedy exploration: with probability epsilon, choose a random bin that fits.
    # This allows for exploration of less optimal (but still valid) bins.
    if np.random.rand() < epsilon:
        possible_bins_indices = np.where(can_fit_mask)[0]
        if possible_bins_indices.size > 0:
            # Select a random bin among those that can fit the item.
            random_bin_index = np.random.choice(possible_bins_indices)
            
            # Reset priorities and assign the highest priority to the randomly chosen bin.
            # This ensures that the exploration step effectively picks a random bin.
            priorities = np.zeros_like(bins_remain_cap, dtype=float)
            priorities[random_bin_index] = 1.0  # Highest priority

    return priorities
```
