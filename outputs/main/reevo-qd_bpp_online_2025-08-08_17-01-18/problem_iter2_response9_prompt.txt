{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using an epsilon-greedy strategy.\n\n    The strategy favors bins that are a \"good fit\" for the item (i.e., leaving\n    a small remaining capacity), but with a probability epsilon, it explores\n    other bins randomly.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 0.2  # Probability of exploring\n\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n\n    # Calculate a \"goodness of fit\" score for each bin\n    # A smaller remaining capacity after fitting the item is considered better.\n    # We use 1 / (remaining_capacity - item + 1e-9) to ensure division by zero is avoided\n    # and to give higher scores to bins with less remaining capacity.\n    # Only consider bins that can actually fit the item.\n    suitable_bins_mask = bins_remain_cap >= item\n    priorities[suitable_bins_mask] = 1.0 / (bins_remain_cap[suitable_bins_mask] - item + 1e-9)\n\n    # Epsilon-greedy part: with probability epsilon, choose a random suitable bin\n    if np.random.rand() < epsilon:\n        # Get indices of suitable bins\n        suitable_indices = np.where(suitable_bins_mask)[0]\n        if len(suitable_indices) > 0:\n            # Randomly pick one suitable bin\n            chosen_index = np.random.choice(suitable_indices)\n            # Assign a very high priority to the randomly chosen bin\n            priorities[chosen_index] = np.max(priorities) + 1.0 # Give it a slightly higher priority than the best greedy choice\n    else:\n        # Otherwise, follow the greedy approach (already calculated in `priorities`)\n        pass # priorities are already set to the greedy scores\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n\n    The Epsilon-Greedy strategy aims to balance exploration (trying less optimal bins)\n    and exploitation (choosing the best bin).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 0.2  # Probability of exploration\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros(num_bins)\n\n    # Identify bins that can accommodate the item\n    suitable_bins_mask = bins_remain_cap >= item\n    suitable_bins = np.where(suitable_bins_mask)[0]\n\n    if len(suitable_bins) == 0:\n        # If no bin can fit the item, return all zeros (or handle as an error)\n        return priorities\n\n    # --- Exploitation Component ---\n    # Calculate a \"goodness\" score for suitable bins.\n    # A common heuristic is the \"Best Fit\" approach: prioritize bins with\n    # the least remaining capacity after placing the item (minimizing waste).\n    # Here, we want the *highest* priority for the *best* fit, so we\n    # transform the remaining capacity difference into a positive score.\n    # A simple approach is (max_capacity - item) - remaining_capacity\n    # or more directly, prioritize smaller remaining capacities after fitting.\n    # We can use a value inversely related to remaining capacity, e.g., 1 / (remaining_capacity - item + 1e-6)\n    # to give higher priority to bins with less slack.\n\n    # Calculate the 'fit_score' for suitable bins: higher is better fit (less wasted space)\n    # This is 1 / (remaining_capacity - item + small_epsilon)\n    # A bin with remaining_capacity = item will have the highest score.\n    fit_scores = 1 / (bins_remain_cap[suitable_bins] - item + 1e-6)\n\n    # Normalize fit_scores to a 0-1 range (optional but can be helpful)\n    if fit_scores.max() > fit_scores.min():\n        exploitation_priorities = (fit_scores - fit_scores.min()) / (fit_scores.max() - fit_scores.min())\n    else:\n        exploitation_priorities = np.ones(len(suitable_bins)) # All are equally \"good\"\n\n    # Assign exploitation priorities to the suitable bins\n    priorities[suitable_bins] = exploitation_priorities\n\n    # --- Exploration Component ---\n    # Introduce randomness: with probability epsilon, choose a random suitable bin.\n    # Assign a small, uniform \"exploration\" priority to all suitable bins.\n    # This encourages trying out bins that might not be the immediate \"best fit\".\n    exploration_priority_value = 0.1 # A small constant value to represent exploration\n\n    # For the bins that are suitable, decide whether to explore\n    explore_mask = np.random.rand(len(suitable_bins)) < epsilon\n\n    # Update priorities for bins chosen for exploration\n    priorities[suitable_bins[explore_mask]] = exploration_priority_value\n\n    # Normalize the final priorities to ensure a meaningful range, e.g., 0 to 1\n    # (This step might be adjusted based on how the priority scores are used elsewhere)\n    if priorities.max() > priorities.min():\n        final_priorities = (priorities - priorities.min()) / (priorities.max() - priorities.min())\n    else:\n        final_priorities = np.ones(num_bins) * 0.5 # Default if all are same\n\n    # Ensure that bins that cannot fit the item have zero priority\n    final_priorities[~suitable_bins_mask] = 0\n\n    return final_priorities\n\n[Reflection]\nPrioritize good fits, but explore random suitable bins with a small, consistent exploration score.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}