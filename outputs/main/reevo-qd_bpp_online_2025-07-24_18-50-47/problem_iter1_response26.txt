```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.

    This priority function prefers bins that have enough remaining capacity 
    to hold the item and have the least remaining capacity, thus minimizing 
    waste and optimizing bin usage.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the remaining capacity after adding the item
    remaining_after_addition = bins_remain_cap - item
    
    # Masks for bins that can fit the item
    can_fit_mask = remaining_after_addition >= 0
    
    # Priorities for bins that can fit the item: higher priority for less remaining capacity
    priorities_can_fit = np.where(can_fit_mask, -remaining_after_addition, -np.inf)
    
    # Normalize priorities to avoid potential overflow
    max_priority = np.max(priorities_can_fit)
    if max_priority != -np.inf:  # Check if any bin can fit the item
        priorities_can_fit = priorities_can_fit - max_priority
    
    # Apply softmax to normalize and make priorities positive and sum to 1 (optional)
    # Here, we directly return the priorities as they are already indicative of preference
    return priorities_can_fit
```
