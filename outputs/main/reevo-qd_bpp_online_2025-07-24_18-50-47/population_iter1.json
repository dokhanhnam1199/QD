[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n    \n    # Bins that can't fit the item will have negative remaining capacity\n    # Assign a very low priority to such bins\n    priorities = np.where(remaining_after_add >= 0, -remaining_after_add, -np.inf)\n    \n    # Normalize the priorities to be between 0 and 1\n    max_priority = np.max(priorities)\n    if max_priority != -np.inf:  # Check if at least one bin can fit the item\n        priorities = priorities - max_priority\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_capacities >= 0, -remaining_capacities / bins_remain_cap, -1e6)\n    \n    # Add a small noise to the priorities to break ties randomly\n    priorities += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item should have higher priority\n    feasible_bins = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item (First-Fit Decreasing inspiration)\n    priorities = np.where(feasible_bins, -remaining_after_addition, -np.inf)\n    \n    # To avoid division by zero and to stabilize the computation, add a small epsilon\n    epsilon = 1e-6\n    \n    # Further differentiate among feasible bins by considering their relative fill level\n    relative_fill_level = (bins_remain_cap + epsilon) / (bins_remain_cap.max() + epsilon)\n    priorities = np.where(feasible_bins, priorities + relative_fill_level, priorities)\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask out bins that cannot hold the item\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Add some randomness to the priority to avoid deterministic tie-breaking\n    priorities += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_cap_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_cap_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two priorities\n    priorities = np.where(can_fit, priorities + np.log(1 + 1/ratios), priorities)\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins = remaining_after_add >= 0\n    \n    # Initialize priorities with negative infinity for bins that can't fit the item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For bins that can fit the item, calculate priority based on the remaining capacity\n    priorities[valid_bins] = remaining_after_add[valid_bins] / bins_remain_cap[valid_bins]\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          bins_remain_cap - item,  # Higher remaining capacity is better\n                          -np.inf)  # Bins that are too small get -inf priority\n    \n    # Normalize the priorities to ensure that the bin with the most remaining capacity after addition gets the highest priority\n    max_priority = np.max(priorities)\n    if max_priority == -np.inf:  # If no bin can accommodate the item\n        priorities = np.where(bins_remain_cap == np.max(bins_remain_cap), 1.0, 0.0)\n    else:\n        priorities = np.where(priorities > -np.inf, priorities - max_priority, priorities)\n    \n    return priorities",
    "response_id": 6,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e10)\n    \n    # For bins that can accommodate the item, prioritize the one with the least remaining capacity\n    priorities = np.where(remaining_capacities >= 0, -remaining_capacities, priorities)\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacities = bins_remain_cap - item\n    \n    # Bins that cannot accommodate the item get a priority of -inf\n    priorities = np.where(remaining_capacities >= 0, -remaining_capacities, -np.inf)\n    \n    # Normalize the priorities to be between 0 and 1 for valid bins\n    valid_bins = priorities != -np.inf\n    if np.any(valid_bins):\n        min_priority = np.min(priorities[valid_bins])\n        max_priority = np.max(priorities[valid_bins])\n        if max_priority != min_priority:\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority)\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item will have a non-negative remaining capacity\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, the priority is inversely proportional to the remaining capacity after addition\n    # This encourages filling bins as much as possible\n    priorities_valid = 1 / (1 + remaining_after_addition[valid_bins])\n    \n    # For bins that cannot fit the item, assign a very low priority\n    priorities_invalid = np.zeros_like(remaining_after_addition[~valid_bins]) - np.inf\n    \n    # Combine the priorities for valid and invalid bins\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf\n    priorities[valid_bins] = priorities_valid\n    priorities[~valid_bins] = priorities_invalid\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priorities = np.where(remain_cap_after_add >= 0, -np.abs(remain_cap_after_add), -1e6)\n    \n    # Prioritize bins with smaller remaining capacity after adding the item\n    # to minimize waste and encourage packing more items into the same bin\n    return priorities",
    "response_id": 10,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition < 0, -np.inf, \n                          # For bins that can accommodate the item, \n                          # higher remaining capacity gets lower priority\n                          -remaining_after_addition / bins_remain_cap)\n    \n    # Normalize the priorities to ensure they are within a comparable range\n    priorities = priorities - np.max(priorities)\n    \n    # Apply a softmax-like function to make the priorities more distinguishable\n    exp_priorities = np.exp(priorities)\n    return exp_priorities / np.sum(exp_priorities)",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(bins_remain_cap - item), -1e6)\n    \n    # Add a slight bias towards bins that are more empty to avoid overfilling bins that are almost full\n    priorities += np.where(remaining_capacities >= 0, bins_remain_cap / np.max(bins_remain_cap), 0)\n    \n    return priorities",
    "response_id": 12,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can accommodate the item, \n                          # prioritize those with the least remaining capacity\n                          -remaining_after_addition / bins_remain_cap, \n                          # For bins that cannot accommodate the item, assign a very low priority\n                          -np.inf)\n    \n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins_mask = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(valid_bins_mask, -np.abs(remaining_after_addition), -np.inf)\n    \n    # Add a small random noise to break ties\n    priorities += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e10)\n    \n    # Normalize the priorities to be between 0 and 1 for valid bins\n    valid_bins = priorities != -1e10\n    if np.any(valid_bins):\n        min_priority = np.min(priorities[valid_bins])\n        max_priority = np.max(priorities[valid_bins])\n        if max_priority != min_priority:\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority)\n    \n    return priorities",
    "response_id": 15,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # For bins with enough capacity, the priority is the remaining capacity after addition\n    # For bins without enough capacity, the priority is a very low value (to avoid selecting them)\n    priorities = np.where(valid_bins_mask, remaining_cap_after_addition, -1e6)\n    \n    # Normalize the priorities for valid bins to be between 0 and 1\n    min_remaining_cap = np.min(remaining_cap_after_addition[valid_bins_mask]) if np.any(valid_bins_mask) else 0\n    max_remaining_cap = np.max(remaining_cap_after_addition[valid_bins_mask]) if np.any(valid_bins_mask) else 1\n    priorities[valid_bins_mask] = (remaining_cap_after_addition[valid_bins_mask] - min_remaining_cap) / (max_remaining_cap - min_remaining_cap + 1e-9)\n    \n    return priorities",
    "response_id": 16,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a positive score, others get a very low score\n    priorities = np.where(remaining_after_addition >= 0, -remaining_after_addition, -1e6)\n    \n    # To avoid choosing bins that are too full, we add a term that prefers bins with more remaining capacity\n    priorities += np.log(bins_remain_cap + 1e-6)\n    \n    # Normalize the priorities to ensure they are on the same scale\n    priorities = priorities - np.max(priorities)\n    \n    return priorities",
    "response_id": 17,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priorities = np.where(remain_cap_after_add < 0, -np.inf, remain_cap_after_add)\n    \n    # For bins that can hold the item, prioritize the one with the least remaining capacity\n    # This is a \"Best Fit\" strategy, which tends to pack items tightly\n    return priorities",
    "response_id": 18,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins = remaining_after_add >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(valid_bins, -np.abs(remaining_after_add), -np.inf)\n    \n    # Add a small random noise to break ties\n    priorities += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins_mask = remaining_after_addition >= 0\n    \n    # For bins with enough capacity, priority is inversely proportional to the remaining capacity after addition\n    # For bins without enough capacity, priority is negatively large (effectively zero probability of being chosen)\n    priorities = np.where(valid_bins_mask, 1 / (remaining_after_addition + 1e-6), -1e6)\n    \n    # Normalize priorities for valid bins to ensure they are on the same scale\n    priorities_valid = priorities[valid_bins_mask]\n    if len(priorities_valid) > 0:\n        priorities_valid = (priorities_valid - np.min(priorities_valid)) / (np.max(priorities_valid) - np.min(priorities_valid) + 1e-6)\n        priorities[valid_bins_mask] = priorities_valid\n    \n    return priorities",
    "response_id": 20,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins_mask = remaining_after_addition >= 0\n    \n    # Initialize priorities with negative infinity for bins that cannot fit the item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For bins that can fit the item, calculate priority based on remaining capacity\n    priorities[valid_bins_mask] = remaining_after_addition[valid_bins_mask] / bins_remain_cap[valid_bins_mask]\n    \n    return priorities",
    "response_id": 21,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e10)\n    \n    # Normalize the priorities to be between 0 and 1 for valid bins\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority = np.min(priorities[valid_bins])\n        max_priority = np.max(priorities[valid_bins])\n        if max_priority != min_priority:\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority)\n    \n    return priorities",
    "response_id": 22,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # For bins that have enough capacity, the priority is inversely proportional to the remaining capacity\n    # For bins that don't have enough capacity, the priority is a very low value (negative infinity)\n    priorities = np.where(remaining_capacities >= 0, -remaining_capacities / bins_remain_cap, -np.inf)\n    \n    # Add a small random noise to break ties\n    priorities += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Create a mask to avoid division by zero and negative values\n    valid_bins = remaining_after_addition >= 0\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(valid_bins, bins_remain_cap - item, -1e6)\n    \n    # Add a bonus for bins that are nearly full to encourage packing items tightly\n    priorities += np.where(valid_bins, 1 / (bins_remain_cap + 1e-6), 0)\n    \n    return priorities",
    "response_id": 24,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that have enough capacity for the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate the priority for valid bins based on the remaining capacity after adding the item\n    priorities_valid = bins_remain_cap[valid_bins] - item\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[valid_bins] = priorities_valid\n    \n    # To avoid selecting a bin that has just enough capacity for the item (which might lead to fragmentation),\n    # we add a small penalty based on the ratio of item size to the bin's remaining capacity\n    ratios = item / bins_remain_cap[valid_bins]\n    priorities[valid_bins] -= 0.1 * ratios\n    \n    return priorities",
    "response_id": 25,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prefers bins that have enough remaining capacity \n    to hold the item and have the least remaining capacity, thus minimizing \n    waste and optimizing bin usage.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Masks for bins that can fit the item\n    can_fit_mask = remaining_after_addition >= 0\n    \n    # Priorities for bins that can fit the item: higher priority for less remaining capacity\n    priorities_can_fit = np.where(can_fit_mask, -remaining_after_addition, -np.inf)\n    \n    # Normalize priorities to avoid potential overflow\n    max_priority = np.max(priorities_can_fit)\n    if max_priority != -np.inf:  # Check if any bin can fit the item\n        priorities_can_fit = priorities_can_fit - max_priority\n    \n    # Apply softmax to normalize and make priorities positive and sum to 1 (optional)\n    # Here, we directly return the priorities as they are already indicative of preference\n    return priorities_can_fit",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item should have higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-8\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to bin capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios), priorities)\n    \n    return priorities",
    "response_id": 27,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item should have higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Priority is a combination of how well the item fits in the bin and whether the bin can fit the item\n    priorities = np.where(can_fit, np.exp(-remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero and to ensure numerical stability, we add a small epsilon to the denominator\n    epsilon = 1e-8\n    normalized_priorities = priorities / (np.max(priorities) + epsilon)\n    \n    return normalized_priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n    \n    # Mask out bins that cannot fit the item\n    valid_bins = remaining_after_add >= 0\n    \n    # For valid bins, the priority is inversely proportional to the remaining capacity after adding the item\n    # For invalid bins, the priority is negative infinity\n    priorities = np.where(valid_bins, 1 / (remaining_after_add + 1e-6), -np.inf)\n    \n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 72.87951656887496,
    "token_count": 72.0,
    "exec_success": true
  }
]