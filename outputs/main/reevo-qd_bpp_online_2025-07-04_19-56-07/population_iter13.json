[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # Give high priority to bins where item fits\n    fit_mask = waste >= 0\n    \n    # Prioritize bins with less waste (First Fit Decreasing-like)\n    priorities[fit_mask] = 1 / (waste[fit_mask] + 1e-9) #Adding small value to avoid division by zero.\n    \n    # Discourage placing item in bins that don't fit (but allow it if no other option)\n    # Penalize by amount of overflow\n    overflow = -waste[~fit_mask] # Positive value indicates overflow\n\n    # Prioritize bins to minimize overflow as a last resort if no bin is suitable\n    if not np.any(fit_mask):\n        priorities[~fit_mask] = 1 / (overflow + 1e-9) #Adding small value to avoid division by zero.\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 76.14709844115208,
    "mi": 87.79685397806284,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # Give high priority to bins where item fits\n    fit_mask = waste >= 0\n    \n    if np.any(fit_mask):\n        # Prioritize bins with less waste (First Fit Decreasing-like)\n        priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask] # Waste ratio\n        priorities[fit_mask] = 1 - priorities[fit_mask]  # Invert to prioritize smaller waste ratio\n        priorities[fit_mask] = np.clip(priorities[fit_mask], 0, 1) # Ensure value between 0 and 1\n        priorities[fit_mask] = 1/(1e-9 + (waste[fit_mask] + 1e-9)) # use the inverse of the waste\n\n    \n    # Discourage placing item in bins that don't fit (but allow it if no other option)\n    # Penalize by amount of overflow\n    else:\n        overflow = -waste # Positive value indicates overflow\n\n        # Prioritize bins to minimize overflow as a last resort if no bin is suitable\n        priorities = 1 / (overflow + 1e-9) #Adding small value to avoid division by zero.\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 127.37720526058406,
    "mi": 77.15928992985069,
    "token_count": 152.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # Give high priority to bins where item fits\n    fit_mask = waste >= 0\n    \n    # Prioritize bins with less waste (First Fit Decreasing-like)\n    #Prioritize bins with minimal waste\n    if np.any(fit_mask):\n        min_waste = np.min(waste[fit_mask])\n        best_fit_mask = (waste == min_waste) & fit_mask #Find the minimum waste\n        priorities[best_fit_mask] = 100  #Very high priority.\n        priorities[fit_mask & ~best_fit_mask] = 50 #High priority but less than perfect fit\n    \n    # Discourage placing item in bins that don't fit (but allow it if no other option)\n    # Penalize by amount of overflow\n    overflow = -waste[~fit_mask] # Positive value indicates overflow\n\n    # Prioritize bins to minimize overflow as a last resort if no bin is suitable\n    if not np.any(fit_mask):\n        min_overflow = np.min(overflow)\n        min_overflow_mask = overflow == min_overflow\n        priorities[~fit_mask] = -overflow # overflow penalty\n        priorities[~fit_mask][min_overflow_mask] = -overflow[min_overflow_mask] + 10 # give bins with least overflow some preference\n        \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 114.20025299224778,
    "mi": 74.322827021985,
    "token_count": 124.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # Give high priority to bins where item fits\n    fit_mask = waste >= 0\n    \n    # Prioritize bins with less waste (First Fit Decreasing-like)\n    if np.any(fit_mask):\n        min_waste = np.min(waste[fit_mask])\n        best_fit_mask = (waste == min_waste) & fit_mask #Find the minimum waste\n        priorities[best_fit_mask] = 100  #Very high priority.\n        priorities[fit_mask & ~best_fit_mask] = 50 #High priority but less than perfect fit\n    \n    # Discourage placing item in bins that don't fit (but allow it if no other option)\n    # Penalize by amount of overflow\n    overflow = -waste[~fit_mask] # Positive value indicates overflow\n\n    # Prioritize bins to minimize overflow as a last resort if no bin is suitable\n    if not np.any(fit_mask):\n        min_overflow = np.min(overflow)\n        min_overflow_mask = overflow == min_overflow\n        priorities[~fit_mask] = -overflow # overflow penalty, negative so bins with less overflow are prioritized\n        priorities[~fit_mask][min_overflow_mask] = -overflow[min_overflow_mask] + 5 # give bins with least overflow some preference\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 140.55415752892034,
    "mi": 82.41348225508199,
    "token_count": 172.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # Give high priority to bins where item fits\n    fit_mask = waste >= 0\n    \n    if np.any(fit_mask):\n        # Prioritize bins with less waste (First Fit Decreasing-like)\n        # Using inverse of waste with a small epsilon to avoid division by zero and give higher priority to smaller waste\n        priorities[fit_mask] = 1 / (waste[fit_mask] + 1e-9)\n\n        # Normalize priorities for fitting bins. This ensures that the priorities among fitting bins are relatively scaled.\n        max_fit_priority = np.max(priorities[fit_mask])\n        priorities[fit_mask] /= max_fit_priority\n\n    \n    # Discourage placing item in bins that don't fit (but allow it if no other option)\n    # Penalize by amount of overflow\n    else:\n        overflow = -waste # Positive value indicates overflow\n\n        # Prioritize bins to minimize overflow as a last resort if no bin is suitable\n        priorities = 1 / (overflow + 1e-9)\n\n        # Normalize priorities for overflowing bins. This ensures that the priorities among overflowing bins are relatively scaled.\n        max_overflow_priority = np.max(priorities)\n        priorities /= max_overflow_priority\n\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 162.53496664211536,
    "mi": 73.24956026405867,
    "token_count": 140.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n\n    # Give very high priority to bins where item fits\n    fit_mask = waste >= 0\n    if np.any(fit_mask):\n        # Prioritize based on minimizing *normalized* waste within fitting bins\n        normalized_waste = waste[fit_mask] / bins_remain_cap[fit_mask]\n        priorities[fit_mask] = 1000 / (normalized_waste + 0.001)  # Large priority boost, avoid div by zero\n    else:\n      # If no fit, penalize overflow, but prioritize minimal overflow\n      overflow = -waste\n      priorities = -100 * overflow # Large negative penalty to discourage overflow\n      priorities = priorities + 1/ (overflow + 0.001) # Reduce large overflow penalty by amount of overflow so that lesser overflow is prioritized.\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 246.20558481335837,
    "mi": 76.62921128115913,
    "token_count": 183.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # Give high priority to bins where item fits\n    fit_mask = waste >= 0\n    \n    if np.any(fit_mask):\n        # Prioritize bins with less waste (First Fit Decreasing-like)\n        waste_ratio = waste[fit_mask] / bins_remain_cap[fit_mask]\n        priorities[fit_mask] = 1 - waste_ratio  # Prioritize smaller waste ratio\n        priorities[fit_mask] = np.clip(priorities[fit_mask], 0, 1)  # Ensure value between 0 and 1\n\n        # Further prioritize almost full bins to consolidate items (optional)\n        almost_full_mask = (waste[fit_mask] / item) < 0.1  # e.g., waste is less than 10% of item size\n        priorities[fit_mask][almost_full_mask] += 0.2  # Add a bonus for almost full bins\n\n    # Discourage placing item in bins that don't fit (but allow it if no other option)\n    else:\n        overflow = -waste  # Positive value indicates overflow\n\n        # Prioritize bins to minimize overflow as a last resort if no bin is suitable\n        overflow_ratio = overflow / item\n        priorities = 1 - overflow_ratio\n        priorities = np.clip(priorities, -1, 0)  # clip values to negative range\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 116.69205856195879,
    "mi": 80.47817105746267,
    "token_count": 176.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # Give high priority to bins where item fits\n    fit_mask = waste >= 0\n    \n    # Prioritize bins with less waste (First Fit Decreasing-like)\n    priorities[fit_mask] = 1000 / (waste[fit_mask] + 0.001)  # Higher magnitude to prioritize fitting\n    \n    # Discourage placing item in bins that don't fit (but allow it if no other option)\n    overflow = -waste[~fit_mask]  # Positive value indicates overflow\n\n    # Heavily penalize overflow, but prioritize minimizing it if no bin fits\n    if not np.any(fit_mask):\n        priorities[~fit_mask] = 1 / (overflow**2 + 0.001) # Penalize square of overflow to avoid it\n    else:\n        priorities[~fit_mask] = -overflow*10  #Slight negative priority to overflows\n        \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 126.65973476959637,
    "mi": 77.00431808887322,
    "token_count": 149.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # Give high priority to bins where item fits\n    fit_mask = waste >= 0\n    \n    # Prioritize bins with less waste (First Fit Decreasing-like)\n    if np.any(fit_mask):\n      priorities[fit_mask] = 1000 / (waste[fit_mask] + 0.0001)  # Higher magnitude to prioritize fitting and avoid division by zero\n    \n    # Discourage placing item in bins that don't fit (but allow it if no other option)\n    overflow = -waste[~fit_mask]  # Positive value indicates overflow\n\n    # Heavily penalize overflow, but prioritize minimizing it if no bin fits\n    if not np.any(fit_mask):\n        priorities[~fit_mask] = 10 / (overflow + 0.0001) # Prioritize smallest overflow, significantly reduce magnitude\n    else:\n        priorities[~fit_mask] = -overflow # Slightly negative priority proportional to overflow\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 153.80110650593844,
    "mi": 80.43298264250767,
    "token_count": 205.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n\n    # Give high priority to bins where item fits\n    fit_mask = waste >= 0\n\n    # Prioritize bins with less waste (First Fit Decreasing-like), normalized by item size.\n    if np.any(fit_mask):\n        priorities[fit_mask] = (item - waste[fit_mask]) / (item + 1e-9) # Normalized fill ratio for bins that fit\n    else:\n        # If no bins fit, strongly penalize overflow, inversely proportional to overflow amount and number of bins available\n        overflow = -waste\n        priorities = -overflow / (np.sum(overflow) + 1e-9) # Normalized overflow penalty\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 91.73835003173087,
    "mi": 86.05280863050939,
    "token_count": 130.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # Give high priority to bins where item fits\n    fit_mask = waste >= 0\n    \n    # Prioritize bins with less waste (First Fit Decreasing-like), using a more sensitive scale for small waste\n    priorities[fit_mask] = np.exp(-waste[fit_mask] / (item + 1e-9))  # Exponential decay based on waste, normalized by item size\n\n    # If no bin fits, then minimize overflow, but significantly penalize it.\n    if not np.any(fit_mask):\n        overflow = -waste[~fit_mask]  # Positive value indicates overflow\n        priorities[~fit_mask] = np.exp(-overflow / (item + 1e-9)) * 0.1 # Heavily penalize overflows\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 114.20025299224778,
    "mi": 74.92436459412207,
    "token_count": 144.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate waste/overflow if item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # High priority to bins where item fits\n    fit_mask = waste >= 0\n    \n    # Prioritize bins with minimal waste (First Fit Decreasing-like). Normalize the waste\n    if np.any(fit_mask):\n        waste_fit = waste[fit_mask]\n        normalized_waste = waste_fit / bins_remain_cap[fit_mask] # waste as a ratio of bin size\n        priorities[fit_mask] = 1 - normalized_waste # Higher priority to lower waste ratios\n\n        # Further prioritize nearly full bins (consolidation strategy)\n        nearly_full_mask = (bins_remain_cap[fit_mask] > 0) & (bins_remain_cap[fit_mask] <= 2 * item)  #consider nearly full if space is <= 2 * item size\n        priorities[fit_mask][nearly_full_mask] += 0.5  # Adding a small bonus\n    else: #No bins fit\n        overflow = -waste\n        normalized_overflow = overflow / item #Overflow as a fraction of the item\n\n        priorities = -normalized_overflow #Negative values due to overflow\n        #If there is no fit, we want the least overflow. \n        #Therefore the best bin has the highest (least negative) value\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 106.19818783608963,
    "mi": 77.40561949168865,
    "token_count": 163.0,
    "exec_success": true
  }
]