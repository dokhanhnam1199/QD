{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    sigmoid_steepness: float = 9.227204138675623,\n    sigmoid_offset: float = 2.8153062240300635) -> np.ndarray:\n    \"\"\"Combines fit-check and minimized leftover space with a sigmoid penalty for larger remaining space.\"\"\"\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    penalty = 1 / (1 + np.exp(sigmoid_steepness * (space_left - sigmoid_offset)))  # Sigmoid penalty for leftover space\n    priority = can_fit * penalty\n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This design implements a heuristic based on the remaining capacity of the bins.\n    Is a priority score based on filling tighter bins first, aiming to close the \n    bins as much as possible to trigger first fit for new bins sooner.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Inverse of remaining capacity (sinusoidal function to prioritize the almost full bins)\n    return 1.0 / (bins_remain_cap + 1e-6) * np.sin(np.pi / 2 * (bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)))\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fit-check and minimized leftover space with a sigmoid penalty for larger remaining space.\"\"\"\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    penalty = 1 / (1 + np.exp(space_left))  # Sigmoid penalty for leftover space\n    priority = can_fit * penalty\n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins by balancing the remaining capacity and leftover space efficiency.\"\"\"\n    ifbinsfit = bins_remain_cap >= item\n    priority = np.where(ifbinsfit, 1.0 / (bins_remain_cap - item + 1e-6), -np.inf)\n    return priority * (bins_remain_cap / np.max(bins_remain_cap, initial=1.0))\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins by balancing the remaining capacity and leftover space efficiency.\"\"\"\n    ifbinsfit = bins_remain_cap >= item\n    priority = np.where(ifbinsfit, 1.0 / (bins_remain_cap - item + 1e-6), -np.inf)\n    relative_space_left_factor = bins_remain_cap / np.max(bins_remain_cap, initial=1.0)\n    return priority * relative_space_left_factor\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balances item fit and minimal leftover space using a penalized approach.\"\"\"\n    # Penalize bins with too much leftover space\n    leftover_penalty = (bins_remain_cap - item) ** 2\n    # Prioritize bins that can fit the item closely\n    close_fit_priority = np.clip(bins_remain_cap - item, 0, 1)\n    # Combine priorities: emphasize close fit while penalizing excessive leftover space\n    priority_score = close_fit_priority - leftover_penalty\n    return priority_score\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balances fit suitability and minimizes leftover space with adaptive bin prioritization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    # Encourage bins that can fit the item with penalty for leftover space\n    fit_priority = can_fit * (1 - (space_left / bins_remain_cap))\n    # Prioritize bins with remaining capacity close to the item size but not less\n    close_fit_priority = np.clip(bins_remain_cap - item, 0, 1)\n    # Combine priorities with adaptive weights\n    priority = 0.7 * fit_priority + 0.3 * close_fit_priority\n    return priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balances fit suitability and minimizes leftover space with adaptive bin prioritization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    # Encourage bins that can fit the item with penalty for leftover space\n    fit_priority = can_fit * (1 - (space_left / bins_remain_cap))\n    # Prioritize bins with remaining capacity close to the item size but not less\n    close_fit_priority = np.clip(bins_remain_cap - item, 0, 1)\n    # Combine priorities with adaptive weights\n    priority = 0.7 * fit_priority + 0.3 * close_fit_priority\n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balances fit and leftover space using a combination of fit criterion and space efficiency.\n    \n    Args:\n        item: Size of item to be added.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of priority scores for each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    fit_penalty = 1 - (space_left / bins_remain_cap)\n    close_fit_factor = np.clip(bins_remain_cap - item, 0, 1)\n    priority = can_fit * (fit_penalty + close_fit_factor)\n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balances fit and leftover space using a combination of fit criterion and space efficiency.\n    \n    Args:\n        item: Size of item to be added.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of priority scores for each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    fit_penalty = 1 - (space_left / bins_remain_cap)\n    close_fit_factor = np.clip(bins_remain_cap - item, 0, 1)\n    priority = can_fit * (fit_penalty + close_fit_factor)\n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balances fit and leftover space using a combination of fit criterion and space efficiency.\n    \n    Args:\n        item: Size of item to be added.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of priority scores for each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    fit_penalty = 1 - (space_left / bins_remain_cap)\n    close_fit_factor = np.clip(bins_remain_cap - item, 0, 1)\n    priority = can_fit * (fit_penalty + close_fit_factor)\n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This heuristic combines several modular sub-heuristics:\n    1. Scaled Remaining Capacity: Prioritizes bins with less remaining capacity.\n    2. Balance Factor: Encourages a more balanced distribution of items across bins.\n    3. Last Fit Decrease (LFD) Heuristic: Gives priority to bins where the last fit was larger.\n    4. Adaptive Learning: Weights the heuristics based on past performance.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Parameters for adaptive learning\n    alpha = 0.5  # Weight for Scaled Remaining Capacity\n    beta = 0.3   # Weight for Balance Factor\n    gamma = 0.2  # Weight for Last Fit Decrease\n\n    # Scaled Remaining Capacity: Lower capacity -> Higher priority\n    scaled_remaining_capacity = 1.0 / (bins_remain_cap + 1e-6)\n\n    # Balance Factor: Encourage a more balanced distribution\n    mean_cap = np.mean(bins_remain_cap)\n    balance_factor = np.abs(mean_cap - bins_remain_cap)\n\n    # Last Fit Decrease (LFD) Heuristic\n    last_fit_decrease = np.zeros_like(bins_remain_cap)\n    if len(bins_remain_cap) > 1:\n        last_fit_decrease[1:] = bins_remain_cap[:-1] - bins_remain_cap[1:]\n\n    # Combine heuristics with adaptive learning\n    priority_scores = (\n        alpha * scaled_remaining_capacity +\n        beta * (1 - balance_factor / np.max(balance_factor + 1e-6)) +\n        gamma * last_fit_decrease\n    )\n\n    return priority_scores\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This heuristic combines several modular sub-heuristics:\n    1. Scaled Remaining Capacity: Prioritizes bins with less remaining capacity.\n    2. Balance Factor: Encourages a more balanced distribution of items across bins.\n    3. Last Fit Decrease (LFD) Heuristic: Gives priority to bins where the last fit was larger.\n    4. Adaptive Learning: Weights the heuristics based on past performance.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Parameters for adaptive learning\n    alpha = 0.5  # Weight for Scaled Remaining Capacity\n    beta = 0.3   # Weight for Balance Factor\n    gamma = 0.2  # Weight for Last Fit Decrease\n\n    # Scaled Remaining Capacity: Lower capacity -> Higher priority\n    scaled_remaining_capacity = 1.0 / (bins_remain_cap + 1e-6)\n\n    # Balance Factor: Encourage a more balanced distribution\n    mean_cap = np.mean(bins_remain_cap)\n    balance_factor = np.abs(mean_cap - bins_remain_cap)\n\n    # Last Fit Decrease (LFD) Heuristic\n    last_fit_decrease = np.zeros_like(bins_remain_cap)\n    if len(bins_remain_cap) > 1:\n        last_fit_decrease[1:] = bins_remain_cap[:-1] - bins_remain_cap[1:]\n\n    # Combine heuristics with adaptive learning\n    priority_scores = (\n        alpha * scaled_remaining_capacity +\n        beta * (1 - balance_factor / np.max(balance_factor + 1e-6)) +\n        gamma * last_fit_decrease\n    )\n\n    return priority_scores\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This heuristic uses a modular approach with two main components:\n    1. Tightness Heuristic: Prioritizes bins that are almost full.\n    2. Balance Heuristic: Penalizes bins that are too full or too empty compared to others.\n\n    The heuristics are combined with weights that can be adjusted to emphasize one over the other.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Parameters for the heuristics\n    tightness_weight = 0.7\n    balance_weight = 0.3\n\n    # Tightness Heuristic: Prioritize bins that are almost full\n    tightness_score = 1.0 / (bins_remain_cap + 1e-6) * np.sin(np.pi / 2 * (bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)))\n\n    # Balance Heuristic: Penalize bins that are too full or too empty compared to others\n    average_remain_cap = np.mean(bins_remain_cap)\n    balance_score = np.exp(-((bins_remain_cap - average_remain_cap) ** 2) / (2 * (average_remain_cap / 4) ** 2))\n\n    # Combine both heuristics with weights\n    priority_score = (tightness_weight * tightness_score) + (balance_weight * balance_score)\n\n    return priority_score\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This heuristic uses a modular approach with two main components:\n    1. Tightness Heuristic: Prioritizes bins that are almost full.\n    2. Balance Heuristic: Penalizes bins that are too full or too empty compared to others.\n\n    The heuristics are combined with weights that can be adjusted to emphasize one over the other.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Parameters for the heuristics\n    tightness_weight = 0.7\n    balance_weight = 0.3\n\n    # Tightness Heuristic: Prioritize bins that are almost full\n    tightness_score = 1.0 / (bins_remain_cap + 1e-6) * np.sin(np.pi / 2 * (bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)))\n\n    # Balance Heuristic: Penalize bins that are too full or too empty compared to others\n    average_remain_cap = np.mean(bins_remain_cap)\n    balance_score = np.exp(-((bins_remain_cap - average_remain_cap) ** 2) / (2 * (average_remain_cap / 4) ** 2))\n\n    # Combine both heuristics with weights\n    priority_score = (tightness_weight * tightness_score) + (balance_weight * balance_score)\n\n    return priority_score\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This heuristic uses a modular approach with two main components:\n    1. Tightness Heuristic: Prioritizes bins that are almost full.\n    2. Balance Heuristic: Penalizes bins that are too full or too empty compared to others.\n\n    The priorities are combined with weights to balance their influence.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure no division by zero\n    bins_remain_cap_safe = bins_remain_cap + 1e-6\n    \n    # Tightness Heuristic: Prioritize bins that are almost full\n    tightness_score = 1.0 / bins_remain_cap_safe * np.sin(np.pi / 2 * (bins_remain_cap_safe / (np.max(bins_remain_cap_safe))))\n    \n    # Balance Heuristic: Encourage a balance between all bins\n    avg_remain_cap = np.mean(bins_remain_cap_safe)\n    balance_score = np.abs(bins_remain_cap_safe - avg_remain_cap)\n    \n    # Combine scores with weights\n    # You can adjust the weights to prioritize tightness or balance more\n    tightness_weight = 0.8\n    balance_weight = 0.2\n    \n    # Encourage bins that are tight but avoid extremely tight bins\n    priority_scores = tightness_weight * tightness_score - balance_weight * balance_score\n    \n    return priority_scores\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Balances fit and leftover space penalty with sigmoidal adjustment for better bin packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure item can fit into the bin\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    \n    # Base priority: more space left after adding item\n    base_priority = can_fit * (bins_remain_cap - item)\n    \n    # Sigmoidal penalty for larger remaining space to encourage tight packing\n    penalty = 1 / (1 + np.exp(-0.5 * (bins_remain_cap - np.median(bins_remain_cap))))\n    \n    # Combine base priority with penalty\n    priority = base_priority * (1 - penalty)\n    \n    # Normalize priority to 0-1 range\n    priority = (priority - np.min(priority)) / (np.max(priority) - np.min(priority))\n    \n    # Handle edge case where all priorities are zero due to same bin capacities\n    if np.isnan(priority).all() or np.isinf(priority).all():\n        return np.zeros_like(bins_remain_cap)\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines remaining capacity and balanced waste reduction to prioritize bins.\n    \n    Prioritizes bins that fit the item well while penalizing excessive leftover space.\"\"\"\n\n    # Calculate waste reduction if item is added to each bin\n    waste_reduction = bins_remain_cap - item\n    \n    # Items that cannot fit in the bin get a very low priority\n    priority_score = np.where(waste_reduction >= 0, waste_reduction, -1000)\n    \n    # Balance by reducing priority for bins with significantly more remaining capacity\n    balance_factor = 1.0 / (bins_remain_cap + 1e-6)\n    balanced_priority = priority_score * balance_factor\n    \n    return balanced_priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority score for each bin based on remaining capacity and avoiding new bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    penalty_for_new_bin = np.max(bins_remain_cap) / 2.0\n    priority_scores = bins_remain_cap - item - (bins_remain_cap < item) * penalty_for_new_bin\n    priority_scores = np.where(priority_scores < 0, -np.inf, priority_scores)\n    return priority_scores\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines remaining capacity and balanced waste reduction to prioritize bins.\n    \n    Prioritizes bins that fit the item well while penalizing excessive leftover space.\"\"\"\n\n    # Calculate waste reduction if item is added to each bin\n    waste_reduction = bins_remain_cap - item\n    \n    # Items that cannot fit in the bin get a very low priority\n    priority_score = np.where(waste_reduction >= 0, waste_reduction, -1000)\n    \n    # Balance by reducing priority for bins with significantly more remaining capacity\n    balance_factor = 1.0 / (bins_remain_cap + 1e-6)\n    balanced_priority = priority_score * balance_factor\n    \n    return balanced_priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}