{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    item: float, \n    bins_remain_cap: np.ndarray,\n    alpha: float = 0.6889072020207402,  # Weight for Scaled Remaining Capacity\n    beta: float = 0.27864877187020565,   # Weight for Balance Factor\n    gamma: float = 0.1859532598991715,  # Weight for Last Fit Decrease\n    sigmoid_penalty_threshold: float = 2.595177488362933e-06) -> np.ndarray:\n    \"\"\"\n    Combines adaptive learning with sigmoid penalties and balance factor for efficient bin placement.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        alpha: Weight for Scaled Remaining Capacity.\n        beta: Weight for Balance Factor.\n        gamma: Weight for Last Fit Decrease.\n        sigmoid_penalty_threshold: Threshold for sigmoid penalty.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Scaled Remaining Capacity with sigmoid penalty\n    scaled_remaining_capacity = np.where(\n        bins_remain_cap >= item, \n        1.0 / (bins_remain_cap - item + sigmoid_penalty_threshold), \n        -np.inf\n    )\n\n    # Balance Factor: Encourage a more balanced distribution\n    mean_cap = np.mean(bins_remain_cap)\n    balance_factor = np.abs(mean_cap - bins_remain_cap) / np.max(np.abs(mean_cap - bins_remain_cap) + 1e-6)\n\n    # Last Fit Decrease (LFD) Heuristic\n    last_fit_decrease = np.zeros_like(bins_remain_cap)\n    if len(bins_remain_cap) > 1:\n        last_fit_decrease[1:] = bins_remain_cap[:-1] - bins_remain_cap[1:]\n\n    # Combine heuristics with adaptive learning\n    priority_scores = (\n        alpha * scaled_remaining_capacity +\n        beta * (1 - balance_factor) +\n        gamma * last_fit_decrease\n    )\n\n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines adaptive learning with sigmoid penalties and balance factor for efficient bin placement.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    alpha = 0.5  # Weight for Scaled Remaining Capacity\n    beta = 0.3   # Weight for Balance Factor\n    gamma = 0.2  # Weight for Last Fit Decrease\n    sigmoid_penalty_threshold = 1e-6\n\n    # Scaled Remaining Capacity with sigmoid penalty\n    scaled_remaining_capacity = np.where(\n        bins_remain_cap >= item, \n        1.0 / (bins_remain_cap - item + sigmoid_penalty_threshold), \n        -np.inf\n    )\n\n    # Balance Factor: Encourage a more balanced distribution\n    mean_cap = np.mean(bins_remain_cap)\n    balance_factor = np.abs(mean_cap - bins_remain_cap) / np.max(np.abs(mean_cap - bins_remain_cap) + 1e-6)\n\n    # Last Fit Decrease (LFD) Heuristic\n    last_fit_decrease = np.zeros_like(bins_remain_cap)\n    if len(bins_remain_cap) > 1:\n        last_fit_decrease[1:] = bins_remain_cap[:-1] - bins_remain_cap[1:]\n\n    # Combine heuristics with adaptive learning\n    priority_scores = (\n        alpha * scaled_remaining_capacity +\n        beta * (1 - balance_factor) +\n        gamma * last_fit_decrease\n    )\n\n    return priority_scores\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristics dynamically adjusts weights based on system state, which allows for more intelligent adaptation to varying conditions. In contrast, the worst heuristics use fixed weights and thresholds, reducing their flexibility and optimization potential. (Second best) vs (second worst) highlights a significant improvement in adaptability and dynamic weighting, showing the benefit of responsive design. Comparing (1st) vs (2nd), we see that the first maintains the adaptive approach without unnecessary imports and parameters, streamlining the process. (3rd) vs (4th) also follows this pattern, emphasizing the importance of simplification while retaining adaptive features. Comparing (second worst) vs (worst), we see the latter lacks in adapting weights and thresholds, making it less effective under varying loads. Overall: Dynamic adjustment of weights and thresholds outperforms static configurations, and simpler implementations maintain efficiency.\n- \n- **Keywords**: Adaptive learning, dynamic adjustments, balanced penalties, domain-specific data, parameter tuning\n- **Advice**: Focus on integrating advanced learning techniques that adaptively adjust heuristics based on feedback. Ensure that the dynamic adjustments are informed by domain-specific data to optimize performance.\n- **Avoid**: Overly complex models or transformations that do not offer significant benefits. Steer clear of static coefficients and repetitive, unenhanced techniques.\n- **Explanation**: By leveraging adaptive learning and dynamic adjustments tailored to specific domains, heuristics can better balance placement efficiencies and penalize inefficiencies. This approach minimizes unnecessary complexity and maintains the effectiveness of the heuristic, leading to improved bin packing solutions.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}