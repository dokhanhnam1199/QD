{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Balances fit suitability and minimizes leftover space with adaptive bin prioritization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    # Encourage bins that can fit the item with penalty for leftover space\n    fit_priority = can_fit * (1 - (space_left / bins_remain_cap))\n    # Prioritize bins with remaining capacity close to the item size but not less\n    close_fit_priority = np.clip(bins_remain_cap - item, 0, 1)\n    # Combine priorities with adaptive weights\n    priority = 0.7 * fit_priority + 0.3 * close_fit_priority\n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This heuristic uses a modular approach with two main components:\n    1. Tightness Heuristic: Prioritizes bins that are almost full.\n    2. Balance Heuristic: Penalizes bins that are too full or too empty compared to others.\n\n    The priorities are combined with weights to balance their influence.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure no division by zero\n    bins_remain_cap_safe = bins_remain_cap + 1e-6\n    \n    # Tightness Heuristic: Prioritize bins that are almost full\n    tightness_score = 1.0 / bins_remain_cap_safe * np.sin(np.pi / 2 * (bins_remain_cap_safe / (np.max(bins_remain_cap_safe))))\n    \n    # Balance Heuristic: Encourage a balance between all bins\n    avg_remain_cap = np.mean(bins_remain_cap_safe)\n    balance_score = np.abs(bins_remain_cap_safe - avg_remain_cap)\n    \n    # Combine scores with weights\n    # You can adjust the weights to prioritize tightness or balance more\n    tightness_weight = 0.8\n    balance_weight = 0.2\n    \n    # Encourage bins that are tight but avoid extremely tight bins\n    priority_scores = tightness_weight * tightness_score - balance_weight * balance_score\n    \n    return priority_scores\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristic (1st) effectively combines a sigmoid penalty to minimize leftover space while fitting the item, balancing tight bins and avoiding overflow elegantly. The worst (20th) repeats logic seen in weaker heuristics, without proper adjustments or penalties for larger remaining spaces.\n(second best) vs (second worst) illustrates the superiority of using modular sub-heuristics with adaptive learning (12th) compared to simplistic waste reduction strategies (19th) without balancing factors or penalties.\nComparing (1st) vs (2nd), we see the first uses a sigmoid function with specific parameters for penalty, which is more flexible and performance-driven than the sinusoidal inverse capacity method in the second.\n(3rd) vs (4th) highlights the necessity of specific parameters for sigmoid functions to effectively penalize larger spaces, as the third achieves better tuning than the fourth\u2019s generic handling.\nComparing (second worst) vs (worst), we see repetitive wasteful strategies without penalty mechanisms, underscoring the value of advanced heuristics with balanced approaches and penalties.\nOverall: Advanced heuristics combining multiple factors like adaptive learning, balance penalties, and sigmoid functions outperform simpler strategies.\n- \n- **Keywords**: Adaptive learning, balanced penalties, sigmoid functions, bin packing efficiency, heuristic design.\n- **Advice**: Focus on refining and fine-tuning the parameters of the adaptive learning mechanism to better address specific bin packing patterns and scenarios. Continuously assess and adjust penalties for inefficiencies dynamically without introducing unnecessary complexity.\n- **Avoid**: Overly complex transformations that complicate the heuristic without providing significant benefits. Random elements or changes that lack a clear rationale for improving performance.\n- **Explanation**: Effective self-reflection involves understanding the strengths and limitations of current strategies while making informed adjustments. By concentrating on refining adaptive learning and penalties dynamically, we can enhance efficiency without adding unnecessary complexity or randomness, which could degrade performance.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}