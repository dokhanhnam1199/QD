{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    item: float, \n    bins_remain_cap: np.ndarray, \n    sigmoid_steepness: float = 9.227204138675623,\n    sigmoid_offset: float = 2.8153062240300635) -> np.ndarray:\n    \"\"\"Combines fit-check and minimized leftover space with a sigmoid penalty for larger remaining space.\"\"\"\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    penalty = 1 / (1 + np.exp(sigmoid_steepness * (space_left - sigmoid_offset)))  # Sigmoid penalty for leftover space\n    priority = can_fit * penalty\n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Balances fit and leftover space penalty with sigmoidal adjustment for better bin packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure item can fit into the bin\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    \n    # Base priority: more space left after adding item\n    base_priority = can_fit * (bins_remain_cap - item)\n    \n    # Sigmoidal penalty for larger remaining space to encourage tight packing\n    penalty = 1 / (1 + np.exp(-0.5 * (bins_remain_cap - np.median(bins_remain_cap))))\n    \n    # Combine base priority with penalty\n    priority = base_priority * (1 - penalty)\n    \n    # Normalize priority to 0-1 range\n    priority = (priority - np.min(priority)) / (np.max(priority) - np.min(priority))\n    \n    # Handle edge case where all priorities are zero due to same bin capacities\n    if np.isnan(priority).all() or np.isinf(priority).all():\n        return np.zeros_like(bins_remain_cap)\n    \n    return priority\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristic (1st) effectively combines a sigmoid penalty to minimize leftover space while fitting the item, balancing tight bins and avoiding overflow elegantly. The worst (20th) repeats logic seen in weaker heuristics, without proper adjustments or penalties for larger remaining spaces.\n(second best) vs (second worst) illustrates the superiority of using modular sub-heuristics with adaptive learning (12th) compared to simplistic waste reduction strategies (19th) without balancing factors or penalties.\nComparing (1st) vs (2nd), we see the first uses a sigmoid function with specific parameters for penalty, which is more flexible and performance-driven than the sinusoidal inverse capacity method in the second.\n(3rd) vs (4th) highlights the necessity of specific parameters for sigmoid functions to effectively penalize larger spaces, as the third achieves better tuning than the fourth\u2019s generic handling.\nComparing (second worst) vs (worst), we see repetitive wasteful strategies without penalty mechanisms, underscoring the value of advanced heuristics with balanced approaches and penalties.\nOverall: Advanced heuristics combining multiple factors like adaptive learning, balance penalties, and sigmoid functions outperform simpler strategies.\n- \n- **Keywords**: Adaptive learning, balanced penalties, sigmoid functions, bin packing efficiency, heuristic design.\n- **Advice**: Focus on refining and fine-tuning the parameters of the adaptive learning mechanism to better address specific bin packing patterns and scenarios. Continuously assess and adjust penalties for inefficiencies dynamically without introducing unnecessary complexity.\n- **Avoid**: Overly complex transformations that complicate the heuristic without providing significant benefits. Random elements or changes that lack a clear rationale for improving performance.\n- **Explanation**: Effective self-reflection involves understanding the strengths and limitations of current strategies while making informed adjustments. By concentrating on refining adaptive learning and penalties dynamically, we can enhance efficiency without adding unnecessary complexity or randomness, which could degrade performance.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}