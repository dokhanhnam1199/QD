{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Prioritize bins by dynamically adjusting weights based on real-time feedback and using\n    smooth sigmoid penalties to enhance bin packing efficiency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Dynamic weights based on current system state\n    system_load = np.mean(bins_remain_cap)\n    total_capacity = np.sum(bins_remain_cap)\n    num_bins = len(bins_remain_cap)\n    load_factor = system_load / (total_capacity / num_bins) if total_capacity > 0 else 1.0\n    \n    # Adaptive learning: adjust weights based on load factor\n    alpha = np.clip(0.5 + 0.5 * np.tanh((load_factor - 0.5) * 2), 0.0, 1.0)  # Scaled Remaining Capacity\n    beta = np.clip(0.5 - 0.4 * np.tanh((load_factor - 0.5) * 2), 0.0, 1.0)  # Balance Factor\n    gamma = np.clip(0.2 + 0.3 * np.tanh((load_factor - 0.5) * 3), 0.0, 1.0)  # Last Fit Decrease\n\n    # Scaled Remaining Capacity with sigmoid penalty\n    sigmoid_penalty_threshold = 1e-6\n    scaled_remaining_capacity = np.where(\n        bins_remain_cap >= item, \n        1.0 / (bins_remain_cap - item + sigmoid_penalty_threshold), \n        -np.inf\n    )\n\n    # Balance Factor: Encourage a more balanced distribution\n    mean_cap = np.mean(bins_remain_cap)\n    balance_factor = np.abs(mean_cap - bins_remain_cap) / np.max(np.abs(mean_cap - bins_remain_cap) + 1e-6)\n\n    # Last Fit Decrease (LFD) Heuristic\n    last_fit_decrease = np.zeros_like(bins_remain_cap)\n    if len(bins_remain_cap) > 1:\n        last_fit_decrease[1:] = bins_remain_cap[:-1] - bins_remain_cap[1:]\n\n    # Combine heuristics with adaptive learning\n    priority_scores = (\n        alpha * scaled_remaining_capacity +\n        beta * (1 - balance_factor) +\n        gamma * last_fit_decrease\n    )\n\n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines adaptive learning with sigmoid penalties and balance factor for efficient bin placement.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    alpha = 0.5  # Weight for Scaled Remaining Capacity\n    beta = 0.3   # Weight for Balance Factor\n    gamma = 0.2  # Weight for Last Fit Decrease\n    sigmoid_penalty_threshold = 1e-6\n\n    # Scaled Remaining Capacity with sigmoid penalty\n    scaled_remaining_capacity = np.where(\n        bins_remain_cap >= item, \n        1.0 / (bins_remain_cap - item + sigmoid_penalty_threshold), \n        -np.inf\n    )\n\n    # Balance Factor: Encourage a more balanced distribution\n    mean_cap = np.mean(bins_remain_cap)\n    balance_factor = np.abs(mean_cap - bins_remain_cap) / np.max(np.abs(mean_cap - bins_remain_cap) + 1e-6)\n\n    # Last Fit Decrease (LFD) Heuristic\n    last_fit_decrease = np.zeros_like(bins_remain_cap)\n    if len(bins_remain_cap) > 1:\n        last_fit_decrease[1:] = bins_remain_cap[:-1] - bins_remain_cap[1:]\n\n    # Combine heuristics with adaptive learning\n    priority_scores = (\n        alpha * scaled_remaining_capacity +\n        beta * (1 - balance_factor) +\n        gamma * last_fit_decrease\n    )\n\n    return priority_scores\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristics (1st) uses carefully tuned fixed weights and thresholds, achieving better performance through parameter optimization. The worst (20th) is essentially identical to the best, indicating that variability primarily comes from parameter tuning and adaptation.\nComparing (second best) vs (second worst), we see no difference, as both are duplicates of the best and worst heuristics, respectively. (3rd) vs (4th) also show the same identical code, differing only in the adaptive learning weights based on system load. Comparing (second worst) vs (worst), we see no variance as they are the same.\nComparing (1st) vs (2nd), (3rd), and (4th), we see no difference in code structure or approach, suggesting that the variation in performance could be due to the fixed parameters (alpha, beta, gamma) and thresholds. Overall, the heuristics do not vary significantly in design and implementation, with only the parameters differing across the better ones.\n- \n- **Keywords**: Adaptive learning, dynamic thresholds, refined balance factor, heuristic efficiency\n- **Advice**: Continuously evolve heuristics with adaptive learning mechanisms that adjust thresholds based on real-time feedback and environment changes. Utilize dynamic balance factors to optimize the trade-off between placing items efficiently and reducing leftover space.\n- **Avoid**: Static thresholds, random transformations, over-complex penalties, duplication without enhancement\n- **Explanation**: By incorporating adaptive learning and dynamic adjustments, heuristics can continuously improve without the pitfalls of static methods or unnecessary complexity, leading to more efficient bin packing strategies.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}