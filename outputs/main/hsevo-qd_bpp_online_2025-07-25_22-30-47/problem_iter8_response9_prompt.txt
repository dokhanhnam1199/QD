{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Balances fit-check with a sigmoid penalty for larger remaining space to optimize bin usage.\"\"\"\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    sigmoid_steepness = 5.0  # Adjusted for better performance\n    sigmoid_offset = 1.5     # Adjusted for better performance\n    penalty = 1 / (1 + np.exp(sigmoid_steepness * (space_left - sigmoid_offset)))\n    priority = can_fit * penalty\n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Balances fit and leftover space with a penalty for excessive waste and a sigmoid to fit items well.\"\"\"\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    fit_penalty = 1 - (space_left / bins_remain_cap)\n    close_fit_factor = np.clip(bins_remain_cap - item, 0, 1)\n    waste_reduction = space_left\n    balance_factor = 1.0 / (bins_remain_cap + 1e-6)\n    priority = can_fit * (fit_penalty + close_fit_factor) * balance_factor\n    return priority\n\n### Analyze & experience\n- Comparing (best) Heuristics 1st vs (worst) Heuristics 20th, we see that the best approach dynamically adjusts weights and penalties using adaptive learning and handles balance more effectively with a sigmoid penalty. The worst one lacks adaptive modification and relies on fixed coefficients.\nSecond best Heuristics 4th vs second worst Heuristics 19th, we see the second best uses a more nuanced approach with dynamically adjusted penalty and adaptive learning, whereas the second worst repeats similar penalization and balance factor calculation without improvements.\nComparing (1st) vs (2nd), we see minor differences in parameter tuning and similar structures, but the first one has slight advantages due to more refined parameter adjustments and enhanced sigmoid penalties.\n(3rd) vs (4th) shows the third one replicates the second with no changes, while the fourth introduces new enhancements like adjusted sigmoid penalties and better balance factors.\nComparing (second worst) vs (worst), we see the second worst uses enhanced but similar techniques to the worst, adding only minor new dynamic adjustments, while the worst remains static in its calculations.\nOverall: The best approaches incorporate dynamic adjustments, refined parameter settings, and improved balance factor calculations, whereas the worst lack these complexities.\n- \n- **Keywords**: Adaptive learning, dynamic adjustments, balanced penalties, sigmoid functions, bin packing efficiency\n- **Advice**: Focus on integrating real-time data feedback to dynamically adjust weights in balance factor calculations, incorporating sigmoid functions to adjust penalty scales smoothly based on current performance metrics.\n- **Avoid**: Statistically insignificant transformations, overly random element incorporations, and duplicate techniques without additional value.\n- **Explanation**: By continuously adapting based on feedback and using smooth, mathematically justified functions for adjustments, heuristics can evolve to perform optimally, mitigating inefficiencies and improving bin packing outcomes significantly.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}