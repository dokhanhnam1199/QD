```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined First Fit strategy.

    This strategy prioritizes bins that can accommodate the item. Among suitable bins,
    it prioritizes those that result in the smallest remaining capacity after placing the item
    (tightest fit). To break ties where multiple bins offer the same tightest fit,
    the bin with the lower index is preferred. Bins that cannot accommodate the item
    are assigned a priority of 0.

    The scoring aims to ensure that tighter fits get higher scores, and for equal fits,
    lower indexed bins get higher scores.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item

    # Calculate the remaining capacity if the item is placed in a suitable bin
    # These are the actual remaining capacities *after* placing the item.
    remaining_caps_after_placement = bins_remain_cap[suitable_bins_mask] - item

    # To prioritize the tightest fit (smallest remaining capacity after placement),
    # we can use the negative of these remaining capacities. Larger negative numbers
    # (i.e., smaller positive remaining capacities) will be preferred in a maximization context.
    # However, to avoid issues with exact zeros and to allow for tie-breaking,
    # we can use a score that is inversely proportional to `remaining_caps_after_placement + 1`.
    # This ensures that smaller remaining capacities get higher scores.
    # We also add a small epsilon to `remaining_caps_after_placement` to avoid division by zero
    # if an item perfectly fills a bin, and to ensure distinctness.

    epsilon = 1e-9
    # Score based on tightest fit: Higher score for smaller `remaining_caps_after_placement`.
    # We use `1.0 / (value + epsilon)` where `value` is `remaining_caps_after_placement`.
    # This maps smaller `remaining_caps_after_placement` to higher scores.
    fit_scores = 1.0 / (remaining_caps_after_placement + epsilon)

    # Tie-breaking using bin index: For bins with the same `fit_score`,
    # we want to prefer lower indices. We can achieve this by subtracting a small
    # value proportional to the bin index. A higher index should have a slightly
    # lower priority.
    bin_indices = np.arange(len(bins_remain_cap))
    # The penalty should be small enough not to dominate the fit score.
    # A multiplier of 1e-7 means that differences in remaining capacity of
    # 1e-7 would have a similar impact to a difference of 1 in index.
    index_penalty = bin_indices[suitable_bins_mask] * 1e-7

    # Combine scores: fit_scores - index_penalty.
    # Higher `fit_scores` are better. Lower `index_penalty` are better.
    # So subtracting the penalty from the fit score works.
    priorities[suitable_bins_mask] = fit_scores - index_penalty

    return priorities
```
