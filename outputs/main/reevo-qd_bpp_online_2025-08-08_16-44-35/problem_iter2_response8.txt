```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Sigmoid Best Fit Score.

    This heuristic prioritizes bins that have a remaining capacity just slightly larger
    than the item's size, aiming for minimal wasted space (Best Fit strategy).
    It uses a sigmoid function to assign higher priority to bins with less slack.
    Bins that cannot accommodate the item receive zero priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        # For bins that can fit, calculate the "slack" (excess capacity)
        slack = bins_remain_cap[can_fit_mask] - item

        # Use a sigmoid function to score bins based on slack.
        # We want to prioritize bins with minimal slack (close to 0).
        # The function 1 / (1 + exp(k * slack)) achieves this:
        # - If slack is 0 (perfect fit), score is 0.5.
        # - If slack > 0 (excess capacity), score < 0.5, decreasing as slack increases.
        # A higher sensitivity 'k' makes the score drop faster for larger slacks,
        # thus favoring bins closer to the item size more strongly.
        sensitivity = 1.0  # Controls how quickly priority drops with increasing slack

        # Calculate the argument for the sigmoid. Since slack >= 0, the argument is also >= 0.
        # Large values of 'slack' (i.e., large excess capacity) will lead to large arguments.
        exponent_argument = sensitivity * slack

        # Apply the sigmoid function.
        # `np.exp` can handle large positive arguments by returning `np.inf`.
        # `1 / (1 + np.inf)` correctly evaluates to 0, which is the desired low priority
        # for bins with very large excess capacity.
        # We can optionally clip `exponent_argument` to prevent potential overflow if very
        # large slack values are common and precision is critical, but for typical bin packing
        # scenarios, NumPy's handling of `inf` is usually sufficient.
        # Let's cap `exponent_argument` to a value that ensures `exp` doesn't overflow into NaN,
        # but still produces a score very close to zero. A value around 700 for `exp` argument is safe.
        # If `bins_remain_cap` can be extremely large relative to `item`, `slack` can be large.
        # Capping `slack` itself before multiplying by sensitivity is a more robust way to manage this.
        max_slack_for_sigmoid = 1000.0 # Arbitrary large value to prevent extreme exponents
        clipped_slack = np.clip(slack, 0, max_slack_for_sigmoid)
        capped_exponent_argument = sensitivity * clipped_slack

        priorities[can_fit_mask] = 1.0 / (1.0 + np.exp(capped_exponent_argument))

    return priorities
```
