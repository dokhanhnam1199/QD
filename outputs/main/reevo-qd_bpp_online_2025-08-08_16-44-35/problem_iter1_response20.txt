```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using First Fit.

    The First Fit strategy prioritizes bins that have just enough capacity to
    fit the current item. This is achieved by calculating a score that is
    high when the remaining capacity is close to the item size, and decreases
    as the remaining capacity becomes much larger than the item size.
    A small epsilon is used to avoid division by zero if an item perfectly fits.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # We want to prioritize bins where the remaining capacity is just enough
    # for the item. This means `bins_remain_cap - item` should be close to 0.
    # A higher score for smaller positive differences, and lower for larger ones.
    # We also want to penalize bins that are too small to fit the item.

    # Filter out bins that are too small to fit the item. These will have a priority of 0.
    # Add a small epsilon to avoid division by zero when item perfectly fits.
    # The formula `1.0 / (bins_remain_cap - item + epsilon)` gives higher priority
    # to bins where `bins_remain_cap - item` is smaller (closer to 0).
    epsilon = 1e-9
    possible_fits = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if np.any(possible_fits):
        # Calculate the "slack" after fitting the item.
        slack = bins_remain_cap[possible_fits] - item
        # The priority is inversely proportional to the slack. Smaller slack means higher priority.
        # Adding epsilon avoids division by zero if slack is exactly 0.
        priorities[possible_fits] = 1.0 / (slack + epsilon)

    return priorities
```
