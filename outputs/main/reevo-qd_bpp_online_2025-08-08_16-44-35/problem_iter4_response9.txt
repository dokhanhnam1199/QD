```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for bins using a Sigmoid Best Fit Score.

    This heuristic prioritizes bins that have the smallest remaining capacity
    that is still sufficient to hold the item. It uses a sigmoid function to
    smoothly assign higher scores to bins with less wasted space.

    The scoring function used is:
        priority = 1 / (1 + exp(sensitivity * (bins_remain_cap - item)))
    for bins where `bins_remain_cap >= item`.
    For bins where `bins_remain_cap < item`, the priority is 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        # Calculate the "slack" for bins that can fit the item.
        # Slack is the extra space in the bin after placing the item.
        slack = bins_remain_cap[can_fit_mask] - item

        # Sensitivity parameter for the sigmoid function.
        # A higher value makes the priority drop more sharply as slack increases.
        # A value around 1.0 is a common starting point.
        sensitivity = 1.0

        # Calculate the argument for the sigmoid function.
        # We want to prioritize bins with smaller slack.
        # The function 1 / (1 + exp(x)) decreases as x increases.
        # So, we use x = sensitivity * slack.
        # This means for perfect fit (slack=0), priority is 0.5.
        # For bins with more slack, slack > 0, the priority < 0.5 and decreases.
        exponent_argument = sensitivity * slack

        # Apply the sigmoid function.
        # To prevent potential overflow with np.exp for very large exponent arguments,
        # we can clip the argument. If the argument is very large, the exponent term
        # becomes very large, exp() becomes inf, and the priority becomes 0, which is desired.
        # We only care about non-negative slack, so the exponent_argument is non-negative.
        # We can cap the exponent argument to avoid `inf` in `np.exp` if desired,
        # but `np.exp` handles large positive values by returning `inf`, which leads to a score of 0.
        # This is the intended behavior for very large slack.

        # Let's limit the exponent argument to a reasonable upper bound to ensure stability
        # and to avoid `inf` calculations if possible, though `1/(1+inf)` correctly yields 0.
        # A value around 700 is where exp() might overflow. Let's cap slightly below.
        max_exponent_val = 100.0 # Arbitrary cap to ensure stability, adjust if needed
        capped_exponent_argument = np.minimum(exponent_argument, max_exponent_val)

        # Calculate priorities: 1 / (1 + exp(capped_exponent_argument))
        priorities[can_fit_mask] = 1.0 / (1.0 + np.exp(capped_exponent_argument))

    return priorities
```
