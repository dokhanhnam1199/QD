```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Sigmoid Best Fit.

    This heuristic prioritizes bins that have the smallest remaining capacity
    that is still sufficient to hold the item. It uses a sigmoid function to
    assign a score, aiming to penalize bins with significant excess capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        # For bins that can fit the item, calculate the 'slack' (excess capacity)
        # slack = remaining_capacity - item_size
        slack = bins_remain_cap[can_fit_mask] - item

        # We want to prioritize bins with minimal slack.
        # A common sigmoid-based approach for "best fit" is to use a function
        # that decreases as slack increases.
        # The function `1 / (1 + exp(k * slack))` where k > 0 fits this requirement:
        # - If slack = 0 (perfect fit), score = 1 / (1 + exp(0)) = 0.5
        # - If slack > 0, exp(k*slack) > 1, so score < 0.5. The score decreases as slack increases.
        # - A larger 'k' (sensitivity) makes the priority drop faster for increasing slack.

        sensitivity = 1.0  # Controls the steepness of the sigmoid curve. Higher means sharper drop for slack.

        # Calculate the exponent argument: sensitivity * slack
        # We need to be mindful of potential overflow if 'slack' is very large.
        # If slack is large, exp(sensitivity * slack) becomes very large, and the score approaches 0.
        # This is the desired behavior: bins with large excess capacity should have very low priority.
        # NumPy handles large exponents gracefully by returning inf, leading to a score of 0.
        # However, to be more robust and potentially avoid inf, we can cap the slack.
        # A slack beyond a certain threshold (e.g., 1000) will already result in a score very close to 0.
        clipped_slack = np.clip(slack, 0, 1000.0) # Cap slack to avoid extreme exp values

        exponent_argument = sensitivity * clipped_slack

        # Calculate the sigmoid score.
        # Use a small epsilon in the denominator to prevent division by zero if exp result is negative infinity (though not expected here).
        # The formula `1.0 / (1.0 + np.exp(exponent_argument))` implements the desired behavior.
        priorities[can_fit_mask] = 1.0 / (1.0 + np.exp(exponent_argument))

    return priorities
```
