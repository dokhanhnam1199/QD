```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a modified Best Fit strategy.

    This strategy prioritizes bins that have the smallest remaining capacity
    after accommodating the item, as long as the item fits. This aims to pack
    items into bins as tightly as possible, reducing wasted space and potentially
    the total number of bins used.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority. Bins that cannot fit the
        item will have a score of -infinity.
    """
    # Initialize priorities to negative infinity for all bins.
    # This ensures that bins unable to fit the item are not considered.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that have enough remaining capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity *after*
    # placing the item. The goal is to minimize this remaining capacity.
    # A smaller remaining capacity means a "better fit" or a "tighter pack".
    # We assign a priority score that is higher for smaller remaining capacities.
    # Therefore, we can use the negative of the remaining capacity after fitting,
    # as a higher negative number (e.g., -1 is greater than -5) implies a smaller
    # positive remaining capacity.
    #
    # If `bins_remain_cap[i] >= item`, the remaining capacity is `bins_remain_cap[i] - item`.
    # We want to prioritize bins where `bins_remain_cap[i] - item` is minimized.
    # So, the score should be proportional to `- (bins_remain_cap[i] - item)`.

    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)

    # In case of ties (multiple bins with the same minimum remaining capacity after fitting),
    # the current implementation will assign the same priority score. NumPy's
    # argmax will typically pick the first occurrence in case of ties, which is
    # a reasonable tie-breaking mechanism (e.g., preferring earlier bins).

    return priorities
```
