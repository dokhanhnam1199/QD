```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a softmax-based approach focused on tight fits.

    This strategy prioritizes bins that offer the tightest fit for the item.
    It calculates a "desirability" score for each bin:
    - If a bin can fit the item, its desirability is inversely proportional to the remaining capacity after fitting.
      This means bins that will have less space left after packing are more desirable (tighter fit).
    - Bins that cannot fit the item receive a desirability of 0.

    The desirability scores are then converted into probabilities (priorities) using the softmax function,
    ensuring that bins with tighter fits receive higher probabilities.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority. Probabilities sum to 1.0 (or 0 if no bin fits).
    """
    epsilon = 1e-6  # Small constant to avoid division by zero

    # Initialize desirability scores for all bins to 0.
    desirability = np.zeros_like(bins_remain_cap)

    # Identify bins that can accommodate the item.
    can_fit_mask = bins_remain_cap >= item

    # If there are any bins that can fit the item:
    if np.any(can_fit_mask):
        # Calculate the remaining capacity in bins that can fit the item, after placing the item.
        remaining_after_fit = bins_remain_cap[can_fit_mask] - item

        # Assign desirability scores: Higher desirability for bins with smaller remaining capacity after fitting.
        # We use 1 / (remaining_after_fit + epsilon) to map smaller remaining capacities to higher desirability.
        # A perfect fit (remaining_after_fit = 0) gets the highest desirability.
        desirability[can_fit_mask] = 1.0 / (remaining_after_fit + epsilon)

        # --- Softmax Calculation for Probabilities ---
        # To ensure numerical stability with np.exp, shift the desirability scores
        # so that the maximum score becomes 0. This is a standard softmax trick.
        max_desirability = np.max(desirability)
        shifted_desirability = desirability - max_desirability

        # Compute the exponentiated shifted desirability scores.
        exp_scores = np.exp(shifted_desirability)

        # Normalize the exponentiated scores by their sum to get probabilities.
        sum_exp_scores = np.sum(exp_scores)

        # If sum_exp_scores is zero (e.g., if all original desirability scores were -inf or similar issues),
        # it means no bin is viable or there was a numerical problem. In such cases, return zero probabilities.
        if sum_exp_scores == 0:
            priorities = np.zeros_like(bins_remain_cap)
        else:
            priorities = exp_scores / sum_exp_scores
    else:
        # If no bin can fit the item, all priorities are 0.
        priorities = np.zeros_like(bins_remain_cap)

    return priorities
```
