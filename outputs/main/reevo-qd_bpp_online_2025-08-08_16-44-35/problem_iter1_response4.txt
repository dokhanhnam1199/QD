```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Exact Fit First strategy.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # The Exact Fit First strategy aims to find a bin where the item fits exactly.
    # If multiple bins offer an exact fit, we can still prioritize them.
    # A higher priority should be given to bins that, after placing the item,
    # will have very little remaining capacity. This is a form of "tight fitting".

    # Calculate the remaining capacity after placing the item in each bin
    potential_remaining_caps = bins_remain_cap - item

    # We want to prioritize bins where the potential remaining capacity is exactly 0.
    # For bins where the item doesn't fit, we assign a low priority (e.g., -1 or a large negative number).
    # For bins that fit, we can further refine the priority by considering how "tight" the fit is.
    # A very small positive remaining capacity can be seen as a "better" fit than a larger one.

    priorities = np.full_like(bins_remain_cap, -float('inf')) # Initialize with a very low priority

    # Find indices where the item fits
    fit_indices = np.where(bins_remain_cap >= item)[0]

    # Assign priorities to bins where the item fits
    for idx in fit_indices:
        remaining_cap = bins_remain_cap[idx] - item
        # Exact fit (remaining_cap == 0) gets the highest priority.
        # Slightly larger remaining capacities get lower, but still positive, priorities.
        # We can use a negative exponential or a simple linear scaling for non-exact fits.
        # A simple approach: exact fit gets 1000, a near-perfect fit gets slightly less,
        # and a loose fit gets a small positive score.
        if remaining_cap == 0:
            priorities[idx] = 1000.0  # High priority for exact fit
        else:
            # For non-exact fits, we still want them to be better than not fitting.
            # The smaller the remaining capacity, the higher the priority among non-exact fits.
            # We can scale this by the size of the item to make it somewhat relative.
            # A common heuristic is to give higher priority to bins with less remaining space.
            # A simple way is to invert the remaining capacity (if positive) or use a penalty.
            # Let's assign a priority that decreases as remaining_cap increases.
            # For example, a linear penalty based on the excess capacity.
            # A reasonable range might be 0 to 999 for non-exact fits.
            # Let's use a decreasing function, e.g., 1000 - remaining_cap.
            # This prioritizes bins that are almost full.
            priorities[idx] = 1000.0 - remaining_cap
            # Ensure that even the best non-exact fit is still worse than an exact fit if we want to enforce "exactness" strictly.
            # However, Exact Fit First usually means prioritize exact fits, but if none exist, then a good fit.
            # For this problem, let's just make sure exact fits are strictly preferred.

    # If there are no exact fits, the heuristic should still pick the best possible fit.
    # The current assignment of priorities already handles this: exact fits get 1000,
    # others get less (1000 - remaining_cap).
    # If we want to strictly enforce 'exact fit first', we would only consider bins where remaining_cap is 0.
    # However, the prompt asks for a priority score for *each* bin, implying all bins should get a score.
    # Thus, a strategy that *prefers* exact fits but still assigns scores to others is more suitable.

    return priorities
```
