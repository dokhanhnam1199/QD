```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit approach,
    prioritizing bins that leave the least remaining capacity.

    The Best Fit heuristic aims to place the item into the bin where it fits
    most snugly, leaving the smallest non-negative remaining capacity. This strategy
    is effective at minimizing wasted space in each individual bin. Bins that cannot
    accommodate the item are assigned a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher priority indicates a better fit.
    """
    # Initialize priorities to 0 for all bins. Bins that cannot fit the item
    # will retain this priority.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the current item.
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity after placement.
    # We want to prioritize bins where this remaining capacity is minimized.
    # A common way to achieve this is to use the negative of the remaining capacity,
    # as higher values (closer to zero from the negative side) indicate a better fit.
    # For example, if remaining capacity is 0.1, the score is -0.1. If remaining capacity is 0.5, the score is -0.5.
    # -0.1 is greater than -0.5, thus prioritizing the bin with less remaining capacity.
    if np.any(can_fit_mask):
        remaining_capacities_after_fit = bins_remain_cap[can_fit_mask] - item
        priorities[can_fit_mask] = -remaining_capacities_after_fit

    return priorities
```
