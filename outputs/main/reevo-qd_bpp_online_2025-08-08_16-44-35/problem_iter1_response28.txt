```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using an Epsilon-Greedy strategy.

    This heuristic aims to balance exploiting good fits (bins with just enough capacity)
    with exploring other bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.
        epsilon: The probability of choosing a random bin instead of the best fit.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins)

    # Calculate potential remaining capacity if the item fits
    potential_remaining_cap = bins_remain_cap - item

    # Identify bins where the item can fit
    can_fit_mask = potential_remaining_cap >= 0

    if np.sum(can_fit_mask) == 0:
        # If item doesn't fit in any bin, return all zeros (or handle error)
        return priorities

    # Epsilon-Greedy logic:
    # With probability epsilon, pick a random bin from those that can fit the item.
    # With probability 1-epsilon, pick the "best" bin.

    if np.random.rand() < epsilon:
        # Explore: pick a random bin from the ones that can fit
        fitting_bins_indices = np.where(can_fit_mask)[0]
        chosen_bin_index = np.random.choice(fitting_bins_indices)
        priorities[chosen_bin_index] = 1.0 # Give high priority to the chosen random bin
    else:
        # Exploit: pick the bin that results in the minimum remaining capacity
        # (i.e., the "tightest" fit).
        fitting_remaining_capacities = potential_remaining_cap[can_fit_mask]
        min_remaining_cap = np.min(fitting_remaining_capacities)
        
        # Find all bins that achieve this minimum remaining capacity
        best_fit_bin_indices = np.where(potential_remaining_cap == min_remaining_cap)[0]
        
        # Assign a high priority to these best-fit bins
        priorities[best_fit_bin_indices] = 1.0
        
        # Optionally, add a small preference for bins that have more remaining capacity
        # if there are ties in the tightest fit, to avoid overly fragmented bins.
        # This can be adjusted based on desired behavior.
        # For now, we give equal high priority to all best fits.

    return priorities
```
