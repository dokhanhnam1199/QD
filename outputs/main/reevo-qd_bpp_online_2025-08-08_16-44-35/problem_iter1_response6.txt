```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Sigmoid Fit Score strategy.

    The Sigmoid Fit Score strategy prioritizes bins that can accommodate the item
    and have a remaining capacity close to the item's size, aiming to leave
    smaller, more usable remaining capacities in the bins. This is achieved
    by applying a sigmoid function to the difference between bin remaining
    capacity and the item size. A higher score means a better fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the difference between bin remaining capacity and the item size.
    # Only consider bins that can actually fit the item. For those that cannot,
    # assign a very low score.
    capacity_diff = bins_remain_cap - item
    
    # Apply a sigmoid function. We want to give a high score to bins where
    # capacity_diff is close to 0 (perfect fit) and a lower score for
    # larger positive differences (bins with more excess space).
    # A common sigmoid function is 1 / (1 + exp(-x)).
    # To tune sensitivity, we can scale the input. A negative scaling factor
    # will invert the sigmoid, so we want a positive scaling. Let's use a moderate scale.
    scale = 0.5  # Adjust this scale to tune sensitivity
    
    # Calculate sigmoid scores only for bins that can fit the item
    # We use a large negative number for bins that cannot fit the item to ensure they have very low priority
    priorities = np.full_like(bins_remain_cap, -1e9) # Initialize with a very low score

    can_fit_mask = bins_remain_cap >= item
    
    if np.any(can_fit_mask):
        priorities[can_fit_mask] = 1 / (1 + np.exp(-scale * capacity_diff[can_fit_mask]))
    
    return priorities

```
