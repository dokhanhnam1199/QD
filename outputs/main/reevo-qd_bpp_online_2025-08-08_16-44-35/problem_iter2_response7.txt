```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined Sigmoid Fit Score.

    This strategy aims to prioritize bins that offer a tight fit (small positive difference
    between remaining capacity and item size). It uses a sigmoid-like function to map
    this difference to a priority score, where smaller positive differences yield higher scores.
    Bins that cannot fit the item receive a score of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate the difference for bins that can fit
    differences = bins_remain_cap[can_fit_mask] - item
    
    if differences.size == 0:
        return priorities

    # We want to prioritize smaller positive differences.
    # A sigmoid-like function can be used. A common approach is to map the
    # difference to a score where smaller differences are closer to 1 and larger ones are closer to 0.
    # Using `exp(-k * difference)` directly prioritizes smaller differences.
    # Let's use a scaled inverse of the difference, shifted to be positive.
    # The idea is to make the score decrease as the difference increases.
    # `1 / (1 + difference)` would give higher scores for smaller differences, but the
    # "exact fit" (difference=0) might not get the absolute highest score.
    #
    # A better approach is to give a high fixed score for exact fits, and then
    # for non-exact fits, assign scores that are inversely related to the difference,
    # ensuring these scores are lower than the exact fit score.
    
    # Define a high priority for exact fits
    EXACT_FIT_PRIORITY = 1.0
    
    # Define a scaling factor for non-exact fits. This controls how quickly the priority
    # drops as the difference increases. Smaller values make the priority drop slower.
    # A value like 0.1 means the priority is roughly `1 / (1 + 0.1 * difference)`.
    SCALE_FACTOR = 0.5

    # Assign a high priority to exact fits
    exact_fit_indices_in_can_fit = (differences == 0)
    
    # Assign priorities for non-exact fits using a sigmoid-like function
    # We want to prioritize smaller differences.
    # `exp(-k * difference)` works well. Let k be `1/SCALE_FACTOR`.
    # A higher k (smaller SCALE_FACTOR) means faster drop in priority.
    # This will map differences to a range that is less than EXACT_FIT_PRIORITY.
    
    k = 1.0 / SCALE_FACTOR
    non_exact_fit_indices_in_can_fit = ~exact_fit_indices_in_can_fit
    
    # Calculate scores for non-exact fits
    if np.any(non_exact_fit_indices_in_can_fit):
        non_exact_differences = differences[non_exact_fit_indices_in_can_fit]
        # Using exp(-k * diff) maps smaller diffs to higher values (closer to 1)
        # and larger diffs to lower values (closer to 0).
        # We need to ensure these values are less than EXACT_FIT_PRIORITY.
        # exp(-k * 0) = 1, so if k is positive, exp(-k*diff) for diff>0 will be < 1.
        non_exact_scores = np.exp(-k * non_exact_differences)
        priorities[can_fit_mask][non_exact_fit_indices_in_can_fit] = non_exact_scores
        
    # Assign exact fit priority
    priorities[can_fit_mask][exact_fit_indices_in_can_fit] = EXACT_FIT_PRIORITY

    return priorities
```
