```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit heuristic.

    Best Fit prioritizes bins that have the smallest remaining capacity that can still
    accommodate the item. This aims to minimize wasted space after packing the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to a very low value (negative infinity) to indicate
    # that bins that cannot fit the item have zero or minimal priority.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that have enough remaining capacity to accommodate the item.
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the priority.
    # The Best Fit strategy seeks to minimize the "slack" or wasted space, which is
    # (bins_remain_cap - item).
    # To prioritize bins with minimal slack, we can maximize the negative slack:
    # Priority = -(bins_remain_cap - item) = item - bins_remain_cap.
    # This means a bin with `bins_remain_cap` exactly equal to `item` will have a priority of 0,
    # while bins with more remaining capacity will have increasingly negative priorities.
    # Thus, the highest priority score will correspond to the bin that is "closest" to fitting the item.
    priorities[can_fit_mask] = item - bins_remain_cap[can_fit_mask]

    # This heuristic implicitly favors bins that are "almost full" because it selects
    # the bin with the least amount of additional space needed to accommodate the item.
    # If multiple bins have the same minimal slack, the numpy array indexing will
    # pick the first one encountered, or subsequent logic can break ties if needed.

    return priorities
```
