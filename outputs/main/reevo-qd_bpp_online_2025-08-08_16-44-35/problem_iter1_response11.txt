```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit strategy.

    This heuristic aims to place the item in the bin that has the smallest remaining capacity
    but can still accommodate the item. This minimizes wasted space in the bins that are
    most full, preserving larger remaining capacities for potentially larger future items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate a more preferred bin.
    """
    # Initialize priorities to a very low value, so bins that cannot fit the item
    # will have the lowest priority.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, assign a priority based on the remaining capacity.
    # The smaller the remaining capacity (after placing the item), the higher the priority.
    # We want to find the bin with the minimum `bins_remain_cap - item`.
    # A common way to achieve "best fit" is to assign higher priority to bins
    # with smaller remaining capacity AFTER the item is placed.
    # This can be represented by - (bins_remain_cap - item).
    # We add a small epsilon to ensure that bins that would become exactly full
    # have a slightly higher priority than bins that would have a tiny bit of space left.
    # This is a common heuristic to break ties or slightly favor exact fits.
    if np.any(can_fit_mask):
        remaining_capacities_after_fit = bins_remain_cap[can_fit_mask] - item
        # We want smaller remaining capacities to have higher priority.
        # So we use the negative of the remaining capacity.
        # Adding a small amount can help to prefer bins that become exactly full
        # over those that have a little space left (if the remaining capacity is very close to 0).
        # A large negative value means it's a bad fit.
        # A value close to 0 or positive means it's a good fit.
        # To implement best fit, we want the LEAST positive value, or closest to 0 from below.
        # So, `-(remaining_capacity_after_fit)` would be the best fit if we wanted the *largest* negative number.
        # To make it simpler, let's assign a priority of 0 to perfect fits and
        # increasingly negative values for bins with more space left.
        # The smallest remaining capacity (after fitting) should get the highest priority.
        # Let's try maximizing the negative of the remaining space.
        priorities[can_fit_mask] = -remaining_capacities_after_fit

        # To further refine and ensure "best fit" is truly prioritized:
        # we want to maximize `bins_remain_cap - item`.
        # A bin that results in a remaining capacity of 0 after packing is the "best fit".
        # So, we can assign a score that is higher for smaller remaining capacities.
        # `priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)`
        # This makes smaller remaining capacities yield larger positive priorities.
        # Let's use this approach as it's more intuitive for "highest priority score".
        priorities[can_fit_mask] = 1.0 / (remaining_capacities_after_fit + 1e-9) # Add epsilon for division by zero

    return priorities
```
