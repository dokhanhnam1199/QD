```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Sigmoid Best Fit Score.

    This heuristic prioritizes bins that have the least remaining capacity
    that is still sufficient to fit the item (Best Fit strategy). A sigmoid
    function is used to smoothly assign priorities, penalizing bins with
    excessive remaining capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        # Calculate the 'slack' for bins that can fit the item.
        # Slack is the extra capacity remaining after fitting the item.
        slack = bins_remain_cap[can_fit_mask] - item

        # Use a sigmoid function to generate priority scores.
        # We want to prioritize bins with minimal slack.
        # The function `1 / (1 + exp(k * slack))` decreases as slack increases,
        # making bins with less slack (better fit) have higher priority.
        #
        # `k` is a sensitivity parameter. A higher `k` makes the priority drop
        # more sharply as slack increases. `k=1.0` is a common starting point.
        sensitivity = 1.0

        # Calculate the argument for the exponential function.
        # We ensure slack is non-negative due to the `can_fit_mask`.
        # To prevent potential overflow in `np
