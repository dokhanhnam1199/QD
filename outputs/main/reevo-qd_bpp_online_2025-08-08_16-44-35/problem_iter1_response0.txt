```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using First Fit strategy.

    In this First Fit strategy, we prioritize bins that can accommodate the item.
    Among those that can, we prefer bins that will have the least remaining capacity
    after placing the item (to try and fill bins as much as possible). If multiple
    bins offer the same "tightest fit", the one with the lower index is prioritized.
    Bins that cannot accommodate the item are given a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item

    # Calculate the remaining capacity if the item is placed in a suitable bin
    remaining_caps_if_placed = bins_remain_cap[suitable_bins_mask] - item

    # We want to prioritize bins that result in the smallest remaining capacity
    # This means we want the smallest (remaining_caps_if_placed) to have the highest priority.
    # To achieve this with maximization, we can use a negative of the remaining capacity,
    # or a large number minus the remaining capacity. Let's use a large number minus
    # the remaining capacity to ensure positive priorities for suitable bins.
    # We also need to ensure that bins that CANNOT fit the item get a priority of 0.

    # Assign a priority based on the "tightest fit" for suitable bins
    # A higher score indicates a better fit (less remaining capacity)
    # We can use 1 / (remaining_cap + 1) to give higher priority to smaller remaining caps,
    # ensuring that the denominator is not zero.
    # Adding a small epsilon to the remaining capacity before division avoids division by zero
    # and also ensures that bins with exactly 0 remaining capacity after placement are prioritized.
    epsilon = 1e-9
    priorities[suitable_bins_mask] = 1.0 / (remaining_caps_if_placed + epsilon)

    # To implement the "first fit" aspect (preferring lower index bins for ties),
    # we can introduce a small penalty based on the bin index.
    # A lower index should have a slightly higher priority if all else is equal.
    # We can subtract a small value proportional to the index from the priority.
    # Let's make this penalty small enough not to override the fit priority.
    bin_indices = np.arange(len(bins_remain_cap))
    priorities[suitable_bins_mask] -= bin_indices[suitable_bins_mask] * 1e-7 # Small penalty for higher index

    return priorities
```
