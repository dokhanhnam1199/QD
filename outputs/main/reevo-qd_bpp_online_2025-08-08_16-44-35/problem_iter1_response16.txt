```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Sigmoid Fit Score.

    The Sigmoid Fit Score strategy prioritizes bins based on how well an item fits.
    It uses a sigmoid function to map the ratio of remaining capacity to item size
    to a priority score. Higher scores indicate a better fit (less wasted space).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    # Consider only bins that can accommodate the item
    available_bins_mask = bins_remain_cap >= item

    # Calculate the "slack" or remaining capacity after placing the item
    slack = bins_remain_cap[available_bins_mask] - item

    # If there are no available bins, return all zeros
    if slack.size == 0:
        return priorities

    # Use the sigmoid function to convert slack to a priority score.
    # We want to minimize slack, so we want to maximize the negative slack.
    # A common approach is to use exp(-k * slack) where k controls the steepness.
    # A higher score means less slack (better fit).
    # Let's map slack to a score such that small slack (good fit) gets high priority.
    # We can use 1 / (1 + slack) or exp(-slack/scale). Let's use the exp approach for flexibility.
    # We'll use a "steepness" parameter (k) that can be tuned.
    # A higher k makes the sigmoid steeper, thus more sensitive to small differences in slack.
    # Let's assume a reasonable default for k.
    k = 10.0  # Steepness parameter

    # Calculate scores for available bins. A smaller slack should result in a higher priority.
    # The sigmoid function usually maps to [0, 1]. We want high priority for low slack.
    # So, we can use exp(-k * slack). This maps low slack to values closer to 1, high slack to values closer to 0.
    scores = np.exp(-k * slack)

    # Place these scores back into the priority array at the correct indices
    priorities[available_bins_mask] = scores

    return priorities
```
