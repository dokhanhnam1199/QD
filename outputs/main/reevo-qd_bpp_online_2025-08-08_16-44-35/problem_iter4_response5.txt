```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined Best Fit strategy.

    This strategy prioritizes bins that can accommodate the item. Among suitable bins,
    it prefers those that result in the smallest remaining capacity after placing the item
    (tightest fit). To break ties where multiple bins offer the same tightest fit,
    it favors bins with lower indices. Bins that cannot accommodate the item are assigned
    a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item

    # Calculate the remaining capacity if the item is placed in a suitable bin
    # For bins that cannot fit, this calculation is irrelevant as their priority remains 0.
    remaining_caps_if_placed = bins_remain_cap[suitable_bins_mask] - item

    # Assign priorities to suitable bins. Higher priority for smaller remaining capacity.
    # We can use a score that is inversely proportional to the remaining capacity.
    # Adding a small epsilon to the denominator prevents division by zero and ensures
    # that bins with exactly zero remaining capacity after placement are prioritized highest.
    epsilon = 1e-9
    priorities[suitable_bins_mask] = 1.0 / (remaining_caps_if_placed + epsilon)

    # To break ties (where remaining_caps_if_placed is the same), we prefer bins with lower indices.
    # This can be achieved by subtracting a small value proportional to the bin's index.
    # A larger index will result in a smaller priority score.
    # The multiplier (e.g., 1e-7) should be small enough not to interfere with the primary scoring
    # based on remaining capacity but significant enough to differentiate between bins with identical fits.
    bin_indices = np.arange(len(bins_remain_cap))
    priorities[suitable_bins_mask] -= bin_indices[suitable_bins_mask] * 1e-7

    return priorities
```
