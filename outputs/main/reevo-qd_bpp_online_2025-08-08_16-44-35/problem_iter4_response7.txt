```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a simplified Best Fit approach.

    This heuristic prioritizes bins that have the smallest remaining capacity
    greater than or equal to the item's size. This aims to minimize wasted
    space by finding the tightest fit among all available bins. Bins that cannot
    fit the item are given a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    # Initialize priorities to 0 (for bins that cannot fit the item)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity after placing the item in fitting bins
    remaining_capacities_if_fit = bins_remain_cap[can_fit_mask] - item

    # Prioritize bins with smaller remaining capacity (tighter fit).
    # We use the inverse of the remaining capacity + a small epsilon to avoid division by zero.
    # A smaller remaining capacity will result in a larger priority score.
    epsilon = 1e-9
    priorities[can_fit_mask] = 1.0 / (remaining_capacities_if_fit + epsilon)

    return priorities
```
