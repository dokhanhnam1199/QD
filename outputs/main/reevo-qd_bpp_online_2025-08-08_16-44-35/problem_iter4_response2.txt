```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Refined Almost Full Fit strategy.

    This strategy refines the 'Almost Full Fit' by directly using the remaining capacity
    after packing as a score. It prioritizes bins that will have the least remaining
    capacity after the item is placed, effectively aiming to fill bins as much as possible.
    Bins that cannot fit the item are given a very low priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority.
    """
    # Initialize priorities with a very low value to indicate unsuitability.
    # Using -infinity ensures that only bins capable of fitting the item get a chance.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that have enough capacity to fit the current item.
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate their priority.
    # The priority is determined by the remaining capacity *after* placing the item.
    # We want to minimize this remaining capacity to encourage fuller bins.
    # Therefore, a smaller remaining capacity should result in a higher priority.
    # The score `bins_remain_cap[can_fit_mask] - item` represents this remaining capacity.
    # To make smaller values have higher priority, we can simply use this value directly
    # as our priority score, since higher values mean less remaining space, thus higher priority.
    # For example, if remaining capacity after fit is 0, priority is 0 (highest possible among fits).
    # If remaining capacity is 5, priority is 5 (lower than 0).
    # This directly incentivizes picking the bin that gets "closest to full" without overflowing.

    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask] - item

    # Note: If `bins_remain_cap[i] - item` is 0, it means a perfect fit, giving a priority of 0.
    # Any other fitting bin will have a positive `bins_remain_cap[i] - item`,
    # which means their priority score will be > 0. This is counter-intuitive
    # if we want higher scores for better fits (closer to 0 remaining space).
    #
    # Correction: We want bins with *less* remaining capacity after fitting to have *higher* priority.
    # So, if `bins_remain_cap[i] - item` is small and positive, it's a good fit.
    # Example: item = 2
    # Bin A: remain_cap = 3 -> remaining_after_fit = 1. High priority.
    # Bin B: remain_cap = 5 -> remaining_after_fit = 3. Lower priority.
    #
    # Thus, we want to prioritize smaller values of `bins_remain_cap[i] - item`.
    # A simple way to achieve this is to use the *negative* of this difference.
    #
    # Example with negative difference:
    # item = 2
    # Bin A: remain_cap = 3 -> remaining_after_fit = 1. Priority = -1 (Higher)
    # Bin B: remain_cap = 5 -> remaining_after_fit = 3. Priority = -3 (Lower)
    # This aligns with the "Almost Full Fit" logic from v1 and prioritizes bins that are closer to full.

    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)

    return priorities
```
