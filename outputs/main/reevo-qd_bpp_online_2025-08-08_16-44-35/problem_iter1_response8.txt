```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Epsilon-Greedy.

    In the Epsilon-Greedy strategy, with probability epsilon, we choose a random bin.
    With probability 1-epsilon, we choose the bin that best fits the item.
    For the best fit, we consider bins that can accommodate the item.
    Among those, we prioritize bins that have the minimum remaining capacity
    after placing the item (i.e., the tightest fit).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.2  # Probability of choosing a random bin
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    fit_mask = bins_remain_cap >= item

    if np.any(fit_mask):
        # Greedy choice: find the best fitting bin
        candidate_bins_remain_cap = bins_remain_cap[fit_mask]
        # Calculate remaining capacity if item is placed, higher is worse for tightest fit
        # So we take the negative of remaining capacity after placement to maximize
        # the tightest fit score.
        remaining_after_fit = candidate_bins_remain_cap - item
        greedy_scores = -remaining_after_fit

        # Assign high priority to the best fitting bins
        best_fit_indices = np.where(fit_mask)[0][np.argsort(greedy_scores)]
        # Assign highest priority to the best fit, and slightly lower to others that fit
        # This is a simple way to encourage exploration within the 'fit' set
        max_greedy_score = np.max(greedy_scores) if len(greedy_scores) > 0 else 0
        for i, original_index in enumerate(np.where(fit_mask)[0]):
            if original_index in best_fit_indices:
                priorities[original_index] = max_greedy_score + (num_bins - i) * 0.1 # Slightly more priority for better fits

        # Introduce randomness with epsilon
        if np.random.rand() < epsilon:
            # Choose a random bin that can fit the item
            random_fit_index = np.random.choice(np.where(fit_mask)[0])
            priorities[random_fit_index] = 1.0  # Assign a fixed high priority for random selection
        else:
            # Ensure the best fit(s) have the highest priority (already done above)
            pass # Greedy selection already handled

    else:
        # No bin can fit the item, assign zero priority (or handle as an error case)
        pass

    # Normalize priorities if needed, though not strictly required for selection by max
    # Normalizing can be useful if priorities are used for sampling.
    # If all priorities are zero, avoid division by zero.
    if np.sum(priorities) > 0:
        priorities = priorities / np.max(priorities) # Scale to range [0, 1]

    return priorities
```
