```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined Almost Full Fit strategy.

    This version refines the Almost Full Fit (AFF) strategy by:
    1. Prioritizing bins with the smallest *positive* remaining capacity after placing the item.
    2. Using a sigmoid function to smooth the priority, ensuring a gradual preference.
    3. Breaking ties by preferring bins with lower indices.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority.
    """
    # Initialize priorities to negative infinity, so bins that cannot fit the item get no priority.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate remaining capacity after placing the item for bins that can fit it.
    remaining_after_item = bins_remain_cap[can_fit_mask] - item

    # To prioritize bins with the smallest *positive* remaining capacity, we want
    # to give higher scores to smaller positive values.
    # We can transform these values to have a higher score for smaller remaining capacities.
    # A simple approach is to use the negative of the remaining capacity, but to
    # ensure it's positive and smooth, we can use a transformation like exp(-x).
    # This way, smaller remaining capacities will result in higher values.
    #
    # We add a small epsilon to avoid issues with remaining capacity being exactly zero,
    # although with floating point numbers and the >= check, this is less likely to be a critical issue.
    # The core idea is to map small positive remaining capacities to high priority values.
    # Using `np.exp(-remaining_after_item)` will give higher values for smaller `remaining_after_item`.
    #
    # To make the priority scores more manageable and to avoid very large or small numbers,
    # we can scale and shift the sigmoid-like transformation.
    # A common approach is to use `sigmoid(a - b*x)`, where a and b are constants.
    # Here, we want to map smaller `remaining_after_item` to higher priorities.
    # Let's use a function that increases as `remaining_after_item` decreases.
    # `1 / (1 + remaining_after_item)` or `np.exp(-remaining_after_item)` are good candidates.
    # `np.exp(-remaining_after_item)` is chosen for its smooth, increasing nature.

    # Ensure we are only operating on positive remaining capacities.
    # The `can_fit_mask` already ensures `remaining_after_item >= 0`.
    # We want to prioritize smaller positive values.
    # A sigmoid-like function like exp(-x) will map smaller positive x to larger values.
    # We can also add a small constant to shift the preference.
    # Let's use `exp(-remaining_after_item)` for smooth preference.
    # To ensure tie-breaking by index, we can append the negative index to the priority.
    # However, numpy's `argmax` naturally picks the first index in case of ties.
    # To explicitly favor lower indices for tie-breaking in the priority calculation itself,
    # we can subtract a small value proportional to the index. This is a common trick.
    # For example, priority = f(remaining_capacity) - epsilon * index.
    # However, the reflection emphasizes "lower bin indices" as a tie-breaker, which
    # implies that if two bins have the same *best* priority score based on remaining capacity,
    # the one with the lower index is chosen. Numpy's argmax handles this by default.
    #
    # Let's refine the priority calculation for smallest positive remaining capacity.
    # We want `f(x)` such that `f(small_positive) > f(larger_positive)`.
    # A simple transform is `1.0 / (remaining_after_item + epsilon)` or `-remaining_after_item`.
    # Using `np.exp(-remaining_after_item)` provides a smooth, increasing function.

    # Calculate the scores. We want smaller remaining capacity to have higher score.
    # A simple inversion like `1 / (remaining_after_item + epsilon)` would work,
    # but `np.exp(-remaining_after_item)` offers a smoother transition.
    # To ensure higher priority for smaller remaining capacities, we can use
    # `np.exp(-remaining_after_item)`.
    # For instance, if remaining_after_item are [1, 5, 0.1]:
    # exp(-1) = 0.367, exp(-5) = 0.006, exp(-0.1) = 0.904. This correctly prioritizes 0.1.

    # Apply the scoring to the bins that can fit the item.
    # The priority score is designed so that smaller remaining capacities get higher scores.
    # We use `np.exp(-remaining_after_item)` which gives higher values for smaller arguments.
    scores = np.exp(-remaining_after_item)

    # To incorporate tie-breaking in favor of lower indices implicitly,
    # numpy's argmax function already selects the first occurrence of the maximum value.
    # If we want to *explicitly* bias towards lower indices in the score calculation,
    # we could subtract a small value related to the index.
    # For example, `score - index * small_epsilon`.
    # However, the reflection mentions "lower bin indices" as a tie-breaker,
    # which is naturally handled by argmax.

    priorities[can_fit_mask] = scores

    # Example of explicit tie-breaking if needed (though argmax handles it by default):
    # If we wanted to ensure the index itself contributes to the priority to break ties
    # *before* argmax, we could do something like:
    # `priorities[can_fit_mask] = scores - bin_indices_that_fit * 1e-9`
    # where `bin_indices_that_fit` are the original indices of the bins that fit.
    # But given the standard interpretation of tie-breaking with argmax, the current
    # `scores` approach is sufficient.

    return priorities
```
