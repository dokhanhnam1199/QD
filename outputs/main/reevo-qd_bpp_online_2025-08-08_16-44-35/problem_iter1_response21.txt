```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit strategy.

    The Best Fit strategy aims to place the item into the bin where it fits most snugly,
    leaving the smallest possible remaining capacity. This can help to keep larger
    bins available for larger items later.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins that can accommodate the item will have a negative score representing
        the remaining capacity after placement. Bins that cannot accommodate the item
        will have a very large positive score (effectively infinite) to ensure they
        are not chosen. The bin with the most negative score (i.e., smallest positive
        remaining capacity) is preferred.
    """
    priorities = np.full_like(bins_remain_cap, np.inf)  # Initialize with infinity
    
    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    # For bins that can fit, calculate the remaining capacity if the item is placed
    # The priority is the negative of this remaining capacity, so smaller remaining
    # capacity results in a larger (less negative) score. We want the largest score,
    # which corresponds to the smallest remaining capacity.
    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)
    
    return priorities
```
