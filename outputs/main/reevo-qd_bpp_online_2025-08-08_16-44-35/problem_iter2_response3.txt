```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a modified Best Fit strategy.

    This strategy prioritizes bins that can accommodate the item, aiming for the 'snuggest' fit.
    The priority is inversely proportional to the remaining capacity after the item is placed.
    Bins that cannot fit the item receive a priority of 0. This encourages filling bins more
    completely, which is a common goal in bin packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher priority means a better (snugger) fit.
    """
    # Initialize priorities to zero. Bins that cannot fit will keep this priority.
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that have enough remaining capacity to fit the item.
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, calculate the remaining capacity *after* placing the item.
    # We want to prioritize bins where this remaining capacity is minimal.
    remaining_after_fit = bins_remain_cap[can_fit_mask] - item

    # To prioritize smaller remaining capacities, we can use their inverse.
    # A small positive remaining capacity (snug fit) should have a high priority.
    # Adding a small epsilon to the denominator avoids division by zero if an item
    # perfectly fills a bin.
    epsilon = 1e-6
    priorities[can_fit_mask] = 1.0 / (remaining_after_fit + epsilon)

    return priorities
```
