```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Tightest Fit.

    Tightest Fit prioritizes bins that can accommodate the item and have the minimum
    remaining capacity after the item is placed. This strategy aims to leave larger
    remaining capacities in other bins for potentially larger items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher score indicates higher priority. Bins that cannot fit the item
        receive a very low priority score (-infinity).
    """
    # Initialize priorities to a very low value (-infinity) for bins that cannot fit the item.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Create a mask for bins that have enough remaining capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate their priority.
    # The goal of Tightest Fit is to minimize the remaining capacity after placing the item.
    # This is equivalent to minimizing (bins_remain_cap - item).
    # To translate this into a priority score where higher is better, we can maximize
    # the negative of this difference: -(bins_remain_cap - item), which simplifies to item - bins_remain_cap.
    #
    # Example:
    # item = 5
    # bins_remain_cap = [10, 7, 12, 5, 8]
    # can_fit_mask = [True, True, True, True, True]
    #
    # For fitting bins:
    # bin 0: remaining_cap = 10, priority = 5 - 10 = -5
    # bin 1: remaining_cap = 7,  priority = 5 - 7  = -2
    # bin 2: remaining_cap = 12, priority = 5 - 12 = -7
    # bin 3: remaining_cap = 5,  priority = 5 - 5  = 0
    # bin 4: remaining_cap = 8,  priority = 5 - 8  = -3
    #
    # The highest priority is 0 (for bin 3, perfect fit), then -2 (for bin 1, tight fit),
    # then -3 (for bin 4), and so on. This correctly prioritizes bins with less remaining capacity.
    priorities[can_fit_mask] = item - bins_remain_cap[can_fit_mask]

    return priorities
```
