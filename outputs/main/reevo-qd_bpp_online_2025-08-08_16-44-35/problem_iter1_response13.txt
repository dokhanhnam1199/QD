```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit.

    The "Almost Full Fit" strategy prioritizes bins that are almost full,
    but still have enough capacity for the current item. This aims to
    leave more space in bins that are less full for potentially larger
    future items. The priority is higher for bins with less remaining
    capacity that can still accommodate the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Find bins that can accommodate the item
    can_accommodate = bins_remain_cap >= item

    # Calculate a priority score for bins that can accommodate the item
    # We want bins that are "almost full", meaning their remaining capacity
    # is small but still sufficient for the item.
    # The priority is inversely related to the remaining capacity,
    # but only for bins that can fit the item.
    # A common way to achieve this is to use (1 / remaining_capacity) or similar.
    # To avoid division by zero or very small numbers leading to extreme priorities,
    # and to emphasize "almost full", we can use a transformation.
    # One approach is to assign a higher priority to bins with the *least*
    # remaining capacity that still fits the item.
    # This can be represented by prioritizing (bins_remain_cap - item),
    # but in reverse order (smaller is better).
    # So, we want to maximize a score that is high for small (bins_remain_cap - item).
    # A simple approach: (bins_remain_cap - item)
    # We want to penalize bins with too much space, so we can use
    # (max_capacity - item) / (bins_remain_cap - item) IF we knew max_capacity,
    # or more practically, assign a score based on the relative remaining space.

    # Let's consider the available space *after* placing the item: bins_remain_cap - item
    # We want to pick the bin where this remaining space is minimized (but non-negative).
    # So, bins_remain_cap - item is our key metric. We want the smallest value.
    # For priority, higher is better. So we can take the negative of this value
    # or (max_possible_remaining_space - (bins_remain_cap - item))

    # A common heuristic for "almost full" is to sort by remaining capacity.
    # We want the smallest remaining capacity *that still fits the item*.
    # This is equivalent to choosing the bin where (bins_remain_cap - item) is minimal.
    # Let's define priority as proportional to (some_large_value - (bins_remain_cap - item))
    # for the bins that can accommodate the item.

    # If we want to give the *highest* priority to the bin that becomes *least* full after placing the item,
    # we would sort bins_remain_cap - item ascendingly.
    # For a priority score (higher is better), we can use a large constant minus this difference.
    # Let's assume a typical bin capacity might be 1.0 for normalization.
    # A simpler way: Just use the inverse of the remaining capacity after placing the item,
    # for bins that can fit it. This prioritizes bins that are already quite full.

    # If we have bins_remain_cap = [0.3, 0.7, 0.1, 0.9] and item = 0.2
    # can_accommodate = [True, True, False, True]
    # Bins that can accommodate: 0.3, 0.7, 0.9
    # Remaining space after placing item: 0.3-0.2=0.1, 0.7-0.2=0.5, 0.9-0.2=0.7
    # We want to pick the bin with the smallest remaining space (0.1).
    # So, we want a priority function that gives the highest score to the bin with 0.1 remaining space.

    # Priority could be a large value minus (bins_remain_cap - item)
    # For example, if max possible remaining capacity is 1.0, then priority could be
    # 1.0 - (bins_remain_cap - item) = 1.0 - bins_remain_cap + item.
    # This would prioritize bins with higher original remaining capacity, which is NOT "almost full".

    # To prioritize "almost full", we want bins where bins_remain_cap is just slightly larger than item.
    # This means bins_remain_cap - item should be small and positive.
    # So, we want to prioritize bins with small positive (bins_remain_cap - item).
    # Let's use 1 / (bins_remain_cap - item + epsilon) for a small epsilon to avoid division by zero.
    # The epsilon ensures that even if remaining_capacity - item is 0, we get a finite high score.

    epsilon = 1e-6  # A small value to avoid division by zero or extreme values

    # Calculate remaining capacity after placing the item
    remaining_after_item = bins_remain_cap - item

    # Assign priority only to bins that can accommodate the item
    # For these bins, priority is inversely proportional to the remaining space after placing the item.
    # Higher priority means less remaining space.
    priorities[can_accommodate] = 1.0 / (remaining_after_item[can_accommodate] + epsilon)

    # Normalize priorities so that the sum is 1, if desired for certain algorithms,
    # or just return the scores directly as is common for greedy selection.
    # For simple greedy selection (pick highest priority), direct scores are fine.

    return priorities
```
