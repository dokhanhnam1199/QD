```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Random Fit.

    In Random Fit, we randomly select a bin and if the item fits, we place it there.
    If it doesn't fit, we try another random bin. This priority function simulates
    this by giving a high priority to randomly selected bins that can fit the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # Identify bins that can fit the item
    possible_bins_indices = np.where(bins_remain_cap >= item)[0]
    
    if len(possible_bins_indices) > 0:
        # Shuffle the indices of bins that can fit the item
        np.random.shuffle(possible_bins_indices)
        
        # Assign a high priority to these shuffled bins
        # We can assign a random high value to simulate the random selection process.
        # Here, we use a fixed high value for simplicity, as the randomness
        # is already introduced by shuffling.
        priorities[possible_bins_indices] = 1.0
        
        # Further refine the priority to slightly favor bins that have less remaining capacity
        # but still fit the item. This is a heuristic inspired by First Fit Decreasing or Best Fit,
        # to make the "random fit" slightly less naive by not just picking any random fitting bin.
        # We will invert the remaining capacity and scale it.
        fitting_capacities = bins_remain_cap[possible_bins_indices]
        
        # Calculate a "closeness" score: higher if remaining capacity is closer to item size
        # We want to prioritize bins where remaining_capacity - item is small.
        # So, (remaining_capacity - item) should be minimized.
        # A simple way to convert this to a higher priority is to use 1 / (1 + (remaining_capacity - item))
        # However, to keep it simple and in line with Random Fit's core idea of random selection
        # among fitting bins, we'll stick to a simpler priority, or perhaps a slight bias towards
        # bins that are a "tighter fit".

        # Let's assign a slightly higher priority to bins that are a tighter fit.
        # This means bins where `remaining_capacity - item` is smaller.
        # We can map `remaining_capacity - item` to a priority.
        # Lower `remaining_capacity - item` should result in higher priority.
        # Let's use `1.0 / (1.0 + (bins_remain_cap[possible_bins_indices] - item))` as a secondary factor.
        
        # Normalize these secondary priorities to avoid them dominating the initial 1.0
        # and also to ensure they are between 0 and 1.
        residuals = bins_remain_cap[possible_bins_indices] - item
        # Avoid division by zero or very small numbers if residuals are close to zero
        # Add a small epsilon to the denominator.
        epsilon = 1e-6
        secondary_priorities = 1.0 / (1.0 + residuals + epsilon)
        
        # Scale secondary priorities so they don't overpower the primary "fits" priority
        # A simple scaling could be to multiply by a small factor, e.g., 0.1
        # Or, we can combine them additively. Let's try additive for now, with a slight bias.
        # The total priority will be `base_priority + scaled_secondary_priority`.
        # Base priority is 1.0 for fitting bins.

        scaled_secondary_priorities = secondary_priorities * 0.5 # Scale down to add as a small bonus

        # Add the scaled secondary priorities to the primary priority.
        # We need to make sure the indices align.
        priorities[possible_bins_indices] += scaled_secondary_priorities

    return priorities
```
