[
     {
          "algorithm": "This algorithm constructs a heuristic matrix by assigning higher probabilities to shorter distances based on an inverse power law, adjusted by a global scaling factor.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by assigning higher probabilities to shorter distances based on an inverse power law, adjusted by a global scaling factor.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Apply inverse power law to the distances\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = distance_matrix[i, j]\n            # Inverse power law with exponent 2\n            if distance > 0:\n              heuristics_matrix[i, j] = 1.0 / (distance**2)\n              heuristics_matrix[j, i] = heuristics_matrix[i, j]\n            else:\n              heuristics_matrix[i, j] = np.inf\n              heuristics_matrix[j, i] = np.inf\n\n    # Scale the heuristics matrix to [0, 1]\n    max_heuristic = np.max(heuristics_matrix[np.isfinite(heuristics_matrix)])\n    heuristics_matrix[np.isfinite(heuristics_matrix)] /= max_heuristic\n\n    return heuristics_matrix",
          "objective": 5.90229,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines greedy nearest neighbor path construction with pheromone updates based on path quality to build a heuristic matrix favoring edges in good solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm combines greedy nearest neighbor path construction with pheromone updates based on path quality to build a heuristic matrix favoring edges in good solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix)\n    alpha = 0.5  # Pheromone influence (reduced)\n    beta = 2.0  # Distance influence (increased)\n    rho = 0.3  # Evaporation rate (increased)\n    Q = 50  # Pheromone deposit constant (reduced)\n    num_ants = int(n * 0.75)  # Reduced number of ants\n    num_iterations = 50  # Reduced number of iterations\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = ant % n\n            current_node = start_node\n            unvisited_nodes = set(range(n))\n            unvisited_nodes.remove(start_node)\n            path = [start_node]\n            path_length = 0\n\n            while unvisited_nodes:\n                # Nearest Neighbor biased by Pheromones\n                probabilities = []\n                candidates = list(unvisited_nodes)\n                for neighbor in candidates:\n                    pheromone = pheromone_matrix[current_node, neighbor]\n                    distance = distance_matrix[current_node, neighbor]\n                    probabilities.append((pheromone**alpha) / (distance**beta))\n                probabilities = np.array(probabilities)\n                probabilities /= np.sum(probabilities)\n                next_node = np.random.choice(candidates, p=probabilities)\n                \n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                unvisited_nodes.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            path_length += distance_matrix[current_node, start_node]\n            all_paths.append(path)\n            all_path_lengths.append(path_length)\n\n        # Update pheromone trails based on path quality\n        pheromone_matrix *= (1 - rho)  # Evaporation\n\n        # Deposit pheromone on edges of all paths, weighted by path length\n        for path, path_length in zip(all_paths, all_path_lengths):\n            for i in range(n):\n                node1 = path[i]\n                node2 = path[i+1]\n                pheromone_matrix[node1, node2] += Q / path_length\n                pheromone_matrix[node2, node1] += Q / path_length\n\n    # Aggregate pheromone information into the heuristics matrix\n    heuristics_matrix = pheromone_matrix\n    return heuristics_matrix",
          "objective": 5.9044,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a simplified ant colony optimization approach with adjusted parameters to emphasize distance over pheromone influence in path construction and increase pheromone evaporation.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a simplified ant colony optimization approach with adjusted parameters to emphasize distance over pheromone influence in path construction and increase pheromone evaporation.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix)\n    alpha = 0.5  # Pheromone influence (reduced)\n    beta = 3  # Distance influence (increased)\n    rho = 0.5  # Evaporation rate (increased)\n    Q = 100  # Pheromone deposit constant\n    num_ants = n\n    num_iterations = 50 #Reduced Iterations\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = ant % n\n            current_node = start_node\n            unvisited_nodes = set(range(n))\n            unvisited_nodes.remove(start_node)\n            path = [start_node]\n            path_length = 0\n\n            while unvisited_nodes:\n                probabilities = []\n                candidates = list(unvisited_nodes)\n                for neighbor in candidates:\n                    pheromone = pheromone_matrix[current_node, neighbor]\n                    distance = distance_matrix[current_node, neighbor]\n                    probabilities.append((pheromone**alpha) / (distance**beta))\n                probabilities = np.array(probabilities)\n                probabilities /= np.sum(probabilities)\n\n                next_node = np.random.choice(candidates, p=probabilities)\n\n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                unvisited_nodes.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            path_length += distance_matrix[current_node, start_node]\n            all_paths.append(path)\n            all_path_lengths.append(path_length)\n\n        # Update pheromone trails\n        pheromone_matrix *= (1 - rho)  # Evaporation\n\n        best_path = all_paths[np.argmin(all_path_lengths)]\n        best_path_length = min(all_path_lengths)\n\n        for i in range(n):\n            node1 = best_path[i]\n            node2 = best_path[i+1]\n            pheromone_matrix[node1, node2] += Q / best_path_length\n            pheromone_matrix[node2, node1] += Q / best_path_length\n\n    # Aggregate pheromone information into the heuristics matrix\n    heuristics_matrix = pheromone_matrix\n    return heuristics_matrix",
          "objective": 5.91972,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines greedy nearest neighbor path construction with pheromone updates based on path quality to build a heuristic matrix favoring edges in good solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm combines greedy nearest neighbor path construction with pheromone updates based on path quality to build a heuristic matrix favoring edges in good solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix)\n    alpha = 0.8  # Pheromone influence\n    beta = 1.2  # Distance influence\n    rho = 0.2  # Evaporation rate\n    Q = 100  # Pheromone deposit constant\n    num_ants = n\n    num_iterations = 80\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = ant % n\n            current_node = start_node\n            unvisited_nodes = set(range(n))\n            unvisited_nodes.remove(start_node)\n            path = [start_node]\n            path_length = 0\n\n            while unvisited_nodes:\n                # Nearest Neighbor biased by Pheromones\n                probabilities = []\n                candidates = list(unvisited_nodes)\n                for neighbor in candidates:\n                    pheromone = pheromone_matrix[current_node, neighbor]\n                    distance = distance_matrix[current_node, neighbor]\n                    probabilities.append((pheromone**alpha) / (distance**beta))\n                probabilities = np.array(probabilities)\n                probabilities /= np.sum(probabilities)\n                next_node = np.random.choice(candidates, p=probabilities)\n                \n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                unvisited_nodes.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            path_length += distance_matrix[current_node, start_node]\n            all_paths.append(path)\n            all_path_lengths.append(path_length)\n\n        # Update pheromone trails based on path quality\n        pheromone_matrix *= (1 - rho)  # Evaporation\n\n        # Deposit pheromone on edges of all paths, weighted by path length\n        for path, path_length in zip(all_paths, all_path_lengths):\n            for i in range(n):\n                node1 = path[i]\n                node2 = path[i+1]\n                pheromone_matrix[node1, node2] += Q / path_length\n                pheromone_matrix[node2, node1] += Q / path_length\n\n    # Aggregate pheromone information into the heuristics matrix\n    heuristics_matrix = pheromone_matrix\n    return heuristics_matrix",
          "objective": 5.93414,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses ant colony optimization principles to probabilistically construct solutions and update pheromone trails based on edge usage in shorter tours, creating a heuristic matrix that reflects edge desirability.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses ant colony optimization principles to probabilistically construct solutions and update pheromone trails based on edge usage in shorter tours, creating a heuristic matrix that reflects edge desirability.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix)\n    alpha = 1  # Pheromone influence\n    beta = 2  # Distance influence\n    rho = 0.1  # Evaporation rate\n    Q = 100  # Pheromone deposit constant\n    num_ants = n\n    num_iterations = 100\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = ant % n\n            current_node = start_node\n            unvisited_nodes = set(range(n))\n            unvisited_nodes.remove(start_node)\n            path = [start_node]\n            path_length = 0\n\n            while unvisited_nodes:\n                probabilities = []\n                candidates = list(unvisited_nodes)\n                for neighbor in candidates:\n                    pheromone = pheromone_matrix[current_node, neighbor]\n                    distance = distance_matrix[current_node, neighbor]\n                    probabilities.append((pheromone**alpha) / (distance**beta))\n                probabilities = np.array(probabilities)\n                probabilities /= np.sum(probabilities)\n\n                next_node = np.random.choice(candidates, p=probabilities)\n\n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                unvisited_nodes.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            path_length += distance_matrix[current_node, start_node]\n            all_paths.append(path)\n            all_path_lengths.append(path_length)\n\n        # Update pheromone trails\n        pheromone_matrix *= (1 - rho)  # Evaporation\n\n        best_path = all_paths[np.argmin(all_path_lengths)]\n        best_path_length = min(all_path_lengths)\n\n        for i in range(n):\n            node1 = best_path[i]\n            node2 = best_path[i+1]\n            pheromone_matrix[node1, node2] += Q / best_path_length\n            pheromone_matrix[node2, node1] += Q / best_path_length\n\n    # Aggregate pheromone information into the heuristics matrix\n    heuristics_matrix = pheromone_matrix\n    return heuristics_matrix",
          "objective": 5.96859,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple near-optimal TSP solutions using a nearest neighbor heuristic with stochastic restarts and edge perturbation, then averages the edge usage across these samples to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple near-optimal TSP solutions using a nearest neighbor heuristic with stochastic restarts and edge perturbation, then averages the edge usage across these samples to create a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited = set(range(n))\n        unvisited.remove(current_node)\n        tour = [current_node]\n        total_distance = 0\n\n        while unvisited:\n            nearest_neighbor = None\n            min_distance = float('inf')\n\n            #Perturb the distances to introduce stochasticity\n            perturbed_distances = distance_matrix[current_node, :].copy() + np.random.normal(0, np.std(distance_matrix) / 10, size=n)\n            perturbed_distances[current_node] = float('inf') #Ensure not to revisit current node\n            \n            for neighbor in unvisited:\n                if perturbed_distances[neighbor] < min_distance:\n                    min_distance = perturbed_distances[neighbor]\n                    nearest_neighbor = neighbor\n\n            tour.append(nearest_neighbor)\n            total_distance += distance_matrix[current_node, nearest_neighbor]\n            current_node = nearest_neighbor\n            unvisited.remove(current_node)\n\n        total_distance += distance_matrix[current_node, start_node]\n        tour.append(start_node) # Complete the cycle\n\n        # Update heuristics matrix\n        for i in range(n):\n            heuristics_matrix[tour[i], tour[(i + 1) % n]] += 1\n            heuristics_matrix[tour[(i + 1) % n], tour[i]] += 1 #Ensure symmetry\n\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 5.98524,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple near-optimal TSP solutions using a nearest neighbor heuristic with stochastic restarts and edge perturbation, then biases the edge usage count based on the tour length (shorter tours contribute more).",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple near-optimal TSP solutions using a nearest neighbor heuristic with stochastic restarts and edge perturbation, then biases the edge usage count based on the tour length (shorter tours contribute more).}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited = set(range(n))\n        unvisited.remove(current_node)\n        tour = [current_node]\n        total_distance = 0\n\n        while unvisited:\n            nearest_neighbor = None\n            min_distance = float('inf')\n\n            #Perturb the distances to introduce stochasticity\n            perturbed_distances = distance_matrix[current_node, :].copy() + np.random.normal(0, np.std(distance_matrix) / 10, size=n)\n            perturbed_distances[current_node] = float('inf') #Ensure not to revisit current node\n            \n            for neighbor in unvisited:\n                if perturbed_distances[neighbor] < min_distance:\n                    min_distance = perturbed_distances[neighbor]\n                    nearest_neighbor = neighbor\n\n            tour.append(nearest_neighbor)\n            total_distance += distance_matrix[current_node, nearest_neighbor]\n            current_node = nearest_neighbor\n            unvisited.remove(current_node)\n\n        total_distance += distance_matrix[current_node, start_node]\n        tour.append(start_node) # Complete the cycle\n\n        # Weight the contribution of this tour based on its total distance\n        weight = max(0, 1 - (total_distance / (np.mean(distance_matrix) * n * 2)))\n\n        # Update heuristics matrix\n        for i in range(n):\n            heuristics_matrix[tour[i], tour[(i + 1) % n]] += weight\n            heuristics_matrix[tour[(i + 1) % n], tour[i]] += weight #Ensure symmetry\n\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 6.00664,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a combination of inverse distance and shortest-edge inclusion frequency from sampled greedy tours to guide edge selection.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm uses a combination of inverse distance and shortest-edge inclusion frequency from sampled greedy tours to guide edge selection.}\"\"\"\n  n = distance_matrix.shape[0]\n  num_samples = 1000\n  edge_counts = np.zeros_like(distance_matrix)\n\n  for _ in range(num_samples):\n    start_node = np.random.randint(n)\n    tour = [start_node]\n    unvisited = list(range(n))\n    unvisited.remove(start_node)\n\n    while unvisited:\n      current_node = tour[-1]\n      #Greedy approach: select the edge with the shortest distance\n      nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])\n      tour.append(nearest_neighbor)\n      unvisited.remove(nearest_neighbor)\n    \n    for i in range(n):\n      u = tour[i]\n      v = tour[(i + 1) % n]\n      edge_counts[u, v] += 1\n      edge_counts[v, u] += 1\n\n  edge_frequencies = edge_counts / num_samples\n  inverse_distances = 1.0 / (distance_matrix + 1e-9)  # Avoid division by zero\n  heuristics_matrix = edge_frequencies * inverse_distances\n  return heuristics_matrix",
          "objective": 6.03981,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines greedy nearest neighbor path construction with pheromone updates based on path quality to build a heuristic matrix favoring edges in good solutions, but with adjusted parameters for exploration and exploitation.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm combines greedy nearest neighbor path construction with pheromone updates based on path quality to build a heuristic matrix favoring edges in good solutions, but with adjusted parameters for exploration and exploitation.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix)\n    alpha = 0.5  # Reduced pheromone influence\n    beta = 2.0  # Increased distance influence\n    rho = 0.4  # Increased evaporation rate\n    Q = 50  # Reduced pheromone deposit constant\n    num_ants = n\n    num_iterations = 50\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = ant % n\n            current_node = start_node\n            unvisited_nodes = set(range(n))\n            unvisited_nodes.remove(start_node)\n            path = [start_node]\n            path_length = 0\n\n            while unvisited_nodes:\n                # Nearest Neighbor biased by Pheromones\n                probabilities = []\n                candidates = list(unvisited_nodes)\n                for neighbor in candidates:\n                    pheromone = pheromone_matrix[current_node, neighbor]\n                    distance = distance_matrix[current_node, neighbor]\n                    probabilities.append((pheromone**alpha) / (distance**beta))\n                probabilities = np.array(probabilities)\n                probabilities /= np.sum(probabilities)\n                next_node = np.random.choice(candidates, p=probabilities)\n                \n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                unvisited_nodes.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            path_length += distance_matrix[current_node, start_node]\n            all_paths.append(path)\n            all_path_lengths.append(path_length)\n\n        # Update pheromone trails based on path quality\n        pheromone_matrix *= (1 - rho)  # Evaporation\n\n        # Deposit pheromone on edges of all paths, weighted by path length\n        for path, path_length in zip(all_paths, all_path_lengths):\n            for i in range(n):\n                node1 = path[i]\n                node2 = path[i+1]\n                pheromone_matrix[node1, node2] += Q / path_length\n                pheromone_matrix[node2, node1] += Q / path_length\n\n    # Aggregate pheromone information into the heuristics matrix\n    heuristics_matrix = pheromone_matrix\n    return heuristics_matrix",
          "objective": 6.0461,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by applying a kernel density estimation (KDE) on the distances, favoring shorter distances with higher density estimates as promising edge indicators.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by applying a kernel density estimation (KDE) on the distances, favoring shorter distances with higher density estimates as promising edge indicators.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Apply kernel density estimation to the distances\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = distance_matrix[i, j]\n            # Gaussian kernel with bandwidth proportional to the mean distance\n            bandwidth = np.mean(distance_matrix) / 5 #Adjusted bandwidth \n            kde_value = np.exp(-0.5 * (distance / bandwidth)**2)\n            heuristics_matrix[i, j] = kde_value\n            heuristics_matrix[j, i] = kde_value\n\n    return heuristics_matrix",
          "objective": 6.06887,
          "other_inf": null
     }
]