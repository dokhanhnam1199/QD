[
     {
          "algorithm": "This algorithm prioritizes edges that appear in shorter tours found by a simplified local search, weighting edges inversely proportional to the tour length and directly proportional to their frequency.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm prioritizes edges that appear in shorter tours found by a simplified local search, weighting edges inversely proportional to the tour length and directly proportional to their frequency.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    edge_weights = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 50\n    neighborhood_size = 10\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        nodes = list(range(n))\n        np.random.shuffle(nodes)\n        tour = nodes + [nodes[0]]\n\n        # Simplified 2-opt local search\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for j in range(i + 2, n + 1):\n                    if j - i == 1: continue # ensures edges are distinct\n                    current_distance = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[j-1], tour[j]]\n                    new_distance = distance_matrix[tour[i-1], tour[j-1]] + distance_matrix[tour[i], tour[j]]\n                    if new_distance < current_distance:\n                        tour[i:j] = reversed(tour[i:j])\n                        improved = True\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n\n        # Update edge weights based on tour length and edge frequency\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            edge_weights[node1, node2] += 1 / tour_length\n            edge_weights[node2, node1] += 1 / tour_length\n\n    # Normalize edge weights to create the heuristics matrix\n    max_weight = np.max(edge_weights)\n    if max_weight > 0:\n        heuristics_matrix = edge_weights / max_weight\n    else:\n        heuristics_matrix = np.ones_like(distance_matrix) / n # Avoid division by zero\n\n    return heuristics_matrix",
          "objective": 5.75163,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm adaptively adjusts edge weights based on the frequency of their appearance in short paths found by a simplified local search, emphasizing edges that consistently contribute to good solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm adaptively adjusts edge weights based on the frequency of their appearance in short paths found by a simplified local search, emphasizing edges that consistently contribute to good solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    edge_counts = np.zeros_like(distance_matrix, dtype=int)\n    num_samples = 50\n    neighborhood_size = 10\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        nodes = list(range(n))\n        np.random.shuffle(nodes)\n        tour = nodes + [nodes[0]]\n\n        # Simplified 2-opt local search\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for j in range(i + 2, n + 1):\n                    if j - i == 1: continue # ensures edges are distinct\n                    current_distance = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[j-1], tour[j]]\n                    new_distance = distance_matrix[tour[i-1], tour[j-1]] + distance_matrix[tour[i], tour[j]]\n                    if new_distance < current_distance:\n                        tour[i:j] = reversed(tour[i:j])\n                        improved = True\n\n        # Update edge counts based on the improved tour\n        tour_length = 0\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            edge_counts[node1, node2] += 1\n            edge_counts[node2, node1] += 1\n            tour_length += distance_matrix[node1, node2]\n\n    # Normalize edge counts to create the heuristics matrix\n    max_count = np.max(edge_counts)\n    if max_count > 0:\n        heuristics_matrix = edge_counts / max_count\n    else:\n        heuristics_matrix = np.ones_like(distance_matrix) / n # Avoid division by zero\n\n    return heuristics_matrix",
          "objective": 5.77473,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple near-optimal TSP solutions using a greedy approach with a dynamically adjusted subset size for stochastic node selection, path refinement with 2-opt swaps, and weighted edge usage averaging based on tour length to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple near-optimal TSP solutions using a greedy approach with a dynamically adjusted subset size for stochastic node selection, path refinement with 2-opt swaps, and weighted edge usage averaging based on tour length to create a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Initialize tour with a random starting node\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n\n        # Greedy construction with stochastic node selection and dynamic subset size\n        subset_size = 5  # Initial subset size\n        while unvisited:\n            # Adjust subset size based on remaining unvisited nodes\n            subset_size = min(len(unvisited), subset_size)\n            subset = np.random.choice(list(unvisited), size=subset_size, replace=False)\n\n            # Find the nearest neighbor within the subset\n            nearest_neighbor = None\n            min_distance = float('inf')\n            for neighbor in subset:\n                distance = distance_matrix[tour[-1], neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            # Add the nearest neighbor to the tour\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n\n            # Decrease subset size\n            subset_size = max(1, subset_size -1 )\n\n\n        # Path refinement: 2-opt swap\n        improved = True\n        while improved:\n            improved = False\n            for i in range(n):\n                for j in range(i + 2, n):\n                    if distance_matrix[tour[i], tour[i + 1]] + distance_matrix[tour[j], tour[(j + 1) % n]] > \\\n                       distance_matrix[tour[i], tour[j]] + distance_matrix[tour[i + 1], tour[(j + 1) % n]]:\n                        tour[i + 1:j + 1] = reversed(tour[i + 1:j + 1])\n                        improved = True\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[(i + 1) % n]]\n\n        # Weighting factor based on tour length (shorter tours get higher weights)\n        weight = 1.0 / (tour_length + 1e-6)  # Add a small constant to avoid division by zero\n\n        # Update heuristics matrix\n        for i in range(n):\n            heuristics_matrix[tour[i], tour[(i + 1) % n]] += weight\n            heuristics_matrix[tour[(i + 1) % n], tour[i]] += weight  # Ensure symmetry\n\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 5.80707,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a simplified ant colony optimization approach with adjusted parameters to emphasize distance over pheromone and a different pheromone update rule based on rank.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a simplified ant colony optimization approach with adjusted parameters to emphasize distance over pheromone and a different pheromone update rule based on rank.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix)\n    alpha = 0.5  # Pheromone influence (reduced)\n    beta = 3  # Distance influence (increased)\n    rho = 0.2  # Evaporation rate\n    Q = 10  # Pheromone deposit constant (reduced)\n    num_ants = n\n    num_iterations = 50 #Reduced iteration\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = ant % n\n            current_node = start_node\n            unvisited_nodes = set(range(n))\n            unvisited_nodes.remove(start_node)\n            path = [start_node]\n            path_length = 0\n\n            while unvisited_nodes:\n                probabilities = []\n                candidates = list(unvisited_nodes)\n                for neighbor in candidates:\n                    pheromone = pheromone_matrix[current_node, neighbor]\n                    distance = distance_matrix[current_node, neighbor]\n                    probabilities.append((pheromone**alpha) / (distance**beta))\n                probabilities = np.array(probabilities)\n                probabilities /= np.sum(probabilities)\n\n                next_node = np.random.choice(candidates, p=probabilities)\n\n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                unvisited_nodes.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            path_length += distance_matrix[current_node, start_node]\n            all_paths.append(path)\n            all_path_lengths.append(path_length)\n\n        # Rank-based pheromone update\n        ranked_paths = np.argsort(all_path_lengths)\n        pheromone_matrix *= (1 - rho)  # Evaporation\n\n        for rank in range(min(5, num_ants)):  # Top 5 ants deposit pheromone\n            best_path = all_paths[ranked_paths[rank]]\n            best_path_length = all_path_lengths[ranked_paths[rank]]\n            for i in range(n):\n                node1 = best_path[i]\n                node2 = best_path[i+1]\n                pheromone_matrix[node1, node2] += (Q / best_path_length) * (5 - rank)  # Higher rank = more pheromone\n                pheromone_matrix[node2, node1] += (Q / best_path_length) * (5 - rank)\n\n    # Aggregate pheromone information into the heuristics matrix\n    heuristics_matrix = pheromone_matrix\n    return heuristics_matrix",
          "objective": 5.80735,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple near-optimal TSP solutions using a greedy approach with stochastic node selection and path refinement, then averages the edge usage across these samples, weighting edges based on their distance in the averaging process.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple near-optimal TSP solutions using a greedy approach with stochastic node selection and path refinement, then averages the edge usage across these samples, weighting edges based on their distance in the averaging process.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Initialize tour with a random starting node\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n\n        # Greedy construction with stochastic node selection\n        while unvisited:\n            # Select a random subset of unvisited nodes to consider\n            subset_size = min(len(unvisited), 5)  # Limit subset size for efficiency\n            subset = np.random.choice(list(unvisited), size=subset_size, replace=False)\n\n            # Find the nearest neighbor within the subset\n            nearest_neighbor = None\n            min_distance = float('inf')\n            for neighbor in subset:\n                distance = distance_matrix[tour[-1], neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            # Add the nearest neighbor to the tour\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n\n        # Path refinement: 2-opt swap (optional, but improves quality)\n        for i in range(n):\n            for j in range(i + 2, n):\n                if distance_matrix[tour[i], tour[i + 1]] + distance_matrix[tour[j], tour[(j + 1) % n]] > \\\n                   distance_matrix[tour[i], tour[j]] + distance_matrix[tour[i + 1], tour[(j + 1) % n]]:\n                    tour[i + 1:j + 1] = reversed(tour[i + 1:j + 1])\n\n\n        # Update heuristics matrix\n        for i in range(n):\n            dist = distance_matrix[tour[i], tour[(i + 1) % n]]\n            heuristics_matrix[tour[i], tour[(i + 1) % n]] += 1.0 / (dist + 1e-6)\n            heuristics_matrix[tour[(i + 1) % n], tour[i]] += 1.0 / (dist + 1e-6)  # Ensure symmetry\n\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 5.83102,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple near-optimal TSP solutions using a greedy approach with stochastic node selection and path refinement, then averages the edge usage across these samples, weighting edges based on their distance and angle in the averaging process.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple near-optimal TSP solutions using a greedy approach with stochastic node selection and path refinement, then averages the edge usage across these samples, weighting edges based on their distance and angle in the averaging process.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Initialize tour with a random starting node\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n\n        # Greedy construction with stochastic node selection\n        while unvisited:\n            # Select a random subset of unvisited nodes to consider\n            subset_size = min(len(unvisited), 5)  # Limit subset size for efficiency\n            subset = np.random.choice(list(unvisited), size=subset_size, replace=False)\n\n            # Find the nearest neighbor within the subset\n            nearest_neighbor = None\n            min_distance = float('inf')\n            for neighbor in subset:\n                distance = distance_matrix[tour[-1], neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            # Add the nearest neighbor to the tour\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n\n        # Path refinement: 2-opt swap (optional, but improves quality)\n        for i in range(n):\n            for j in range(i + 2, n):\n                if distance_matrix[tour[i], tour[i + 1]] + distance_matrix[tour[j], tour[(j + 1) % n]] > \\\n                   distance_matrix[tour[i], tour[j]] + distance_matrix[tour[i + 1], tour[(j + 1) % n]]:\n                    tour[i + 1:j + 1] = reversed(tour[i + 1:j + 1])\n\n        # Update heuristics matrix\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[(i + 1) % n]\n            dist = distance_matrix[node1, node2]\n\n            # Calculate angle at the connecting node\n            prev_node = tour[(i - 1 + n) % n]\n            next_node = tour[(i + 2) % n]\n\n            # Calculate vectors for angle calculation. Add a small offset to avoid zero vectors.\n            vector1 = distance_matrix[node1, prev_node] + 1e-6\n            vector2 = distance_matrix[node1, next_node] + 1e-6\n            \n            angle_weight = 1\n\n            heuristics_matrix[node1, node2] += angle_weight / (dist + 1e-6)\n            heuristics_matrix[node2, node1] += angle_weight / (dist + 1e-6)  # Ensure symmetry\n\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 5.84042,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses edge frequency within sampled tours, weighted by an exponentially decaying function of tour length, to prioritize edges in shorter tours more strongly.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses edge frequency within sampled tours, weighted by an exponentially decaying function of tour length, to prioritize edges in shorter tours more strongly.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    edge_weights = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 50\n    decay_factor = 0.9\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        nodes = list(range(n))\n        np.random.shuffle(nodes)\n        tour = nodes + [nodes[0]]\n\n        # Simplified 2-opt local search\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for j in range(i + 2, n + 1):\n                    if j - i == 1: continue # ensures edges are distinct\n                    current_distance = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[j-1], tour[j]]\n                    new_distance = distance_matrix[tour[i-1], tour[j-1]] + distance_matrix[tour[i], tour[j]]\n                    if new_distance < current_distance:\n                        tour[i:j] = reversed(tour[i:j])\n                        improved = True\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n\n        # Update edge weights based on tour length and edge frequency\n        weight = decay_factor ** tour_length\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            edge_weights[node1, node2] += weight\n            edge_weights[node2, node1] += weight\n\n    # Normalize edge weights to create the heuristics matrix\n    max_weight = np.max(edge_weights)\n    if max_weight > 0:\n        heuristics_matrix = edge_weights / max_weight\n    else:\n        heuristics_matrix = np.ones_like(distance_matrix) / n # Avoid division by zero\n\n    return heuristics_matrix",
          "objective": 5.85863,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple near-optimal TSP solutions using a greedy approach with stochastic node selection and path refinement, then averages the edge usage across these samples to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple near-optimal TSP solutions using a greedy approach with stochastic node selection and path refinement, then averages the edge usage across these samples to create a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Initialize tour with a random starting node\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n\n        # Greedy construction with stochastic node selection\n        while unvisited:\n            # Select a random subset of unvisited nodes to consider\n            subset_size = min(len(unvisited), 5)  # Limit subset size for efficiency\n            subset = np.random.choice(list(unvisited), size=subset_size, replace=False)\n\n            # Find the nearest neighbor within the subset\n            nearest_neighbor = None\n            min_distance = float('inf')\n            for neighbor in subset:\n                distance = distance_matrix[tour[-1], neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            # Add the nearest neighbor to the tour\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n\n        # Path refinement: 2-opt swap (optional, but improves quality)\n        for i in range(n):\n            for j in range(i + 2, n):\n                if distance_matrix[tour[i], tour[i + 1]] + distance_matrix[tour[j], tour[(j + 1) % n]] > \\\n                   distance_matrix[tour[i], tour[j]] + distance_matrix[tour[i + 1], tour[(j + 1) % n]]:\n                    tour[i + 1:j + 1] = reversed(tour[i + 1:j + 1])\n\n\n        # Update heuristics matrix\n        for i in range(n):\n            heuristics_matrix[tour[i], tour[(i + 1) % n]] += 1\n            heuristics_matrix[tour[(i + 1) % n], tour[i]] += 1  # Ensure symmetry\n\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 5.86102,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple near-optimal TSP solutions using a greedy approach with stochastic node selection and path refinement, then biases edge selection during the greedy construction based on edge lengths, favoring shorter edges.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple near-optimal TSP solutions using a greedy approach with stochastic node selection and path refinement, then biases edge selection during the greedy construction based on edge lengths, favoring shorter edges.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Initialize tour with a random starting node\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n\n        # Greedy construction with stochastic node selection and biased edge selection\n        while unvisited:\n            # Select a random subset of unvisited nodes to consider\n            subset_size = min(len(unvisited), 5)  # Limit subset size for efficiency\n            subset = np.random.choice(list(unvisited), size=subset_size, replace=False)\n\n            # Bias the selection probability based on edge lengths\n            probabilities = np.zeros(len(subset))\n            for i, neighbor in enumerate(subset):\n                distance = distance_matrix[tour[-1], neighbor]\n                probabilities[i] = 1 / (distance + 1e-6)  # Avoid division by zero\n\n            probabilities /= np.sum(probabilities)  # Normalize to a probability distribution\n\n            # Select the next node based on the biased probabilities\n            nearest_neighbor = np.random.choice(subset, p=probabilities)\n\n\n            # Add the nearest neighbor to the tour\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n\n        # Path refinement: 2-opt swap (optional, but improves quality)\n        for i in range(n):\n            for j in range(i + 2, n):\n                if distance_matrix[tour[i], tour[i + 1]] + distance_matrix[tour[j], tour[(j + 1) % n]] > \\\n                   distance_matrix[tour[i], tour[j]] + distance_matrix[tour[i + 1], tour[(j + 1) % n]]:\n                    tour[i + 1:j + 1] = reversed(tour[i + 1:j + 1])\n\n\n        # Update heuristics matrix\n        for i in range(n):\n            heuristics_matrix[tour[i], tour[(i + 1) % n]] += 1\n            heuristics_matrix[tour[(i + 1) % n], tour[i]] += 1  # Ensure symmetry\n\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 5.88279,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm employs ant colony optimization (ACO) principles by simulating ants constructing tours based on pheromone trails and heuristic information derived from edge lengths, iteratively updating pheromone levels to converge towards promising solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm employs ant colony optimization (ACO) principles by simulating ants constructing tours based on pheromone trails and heuristic information derived from edge lengths, iteratively updating pheromone levels to converge towards promising solutions.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_ants = 50\n    pheromone = np.ones_like(distance_matrix)\n    alpha = 1\n    beta = 2\n    rho = 0.5\n    Q = 100\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for iteration in range(100):\n        tours = []\n        for ant in range(num_ants):\n            start_node = np.random.randint(n)\n            tour = [start_node]\n            unvisited = set(range(n))\n            unvisited.remove(start_node)\n\n            while unvisited:\n                current_node = tour[-1]\n                probabilities = np.zeros(n)\n                for neighbor in unvisited:\n                    probabilities[neighbor] = (pheromone[current_node, neighbor]**alpha) * ((1 / (distance_matrix[current_node, neighbor] + 1e-6))**beta)\n                \n                if np.sum(probabilities) == 0:\n                    next_node = np.random.choice(list(unvisited))\n                else:\n                    probabilities = probabilities / np.sum(probabilities)\n                    next_node = np.random.choice(list(range(n)), p=probabilities)\n                \n                if next_node in unvisited:\n                    tour.append(next_node)\n                    unvisited.remove(next_node)\n                else:\n                   next_node = np.random.choice(list(unvisited))\n\n            tour.append(tour[0])\n            tours.append(tour)\n            \n        # Update pheromone trails\n        pheromone *= (1 - rho)\n        for tour in tours:\n            tour_length = 0\n            for i in range(n):\n                tour_length += distance_matrix[tour[i], tour[i+1]]\n            \n            for i in range(n):\n                pheromone[tour[i], tour[i+1]] += Q / tour_length\n                pheromone[tour[i+1], tour[i]] += Q / tour_length\n\n        #Update heuristic_matrix\n        best_tour = min(tours, key=lambda tour: sum(distance_matrix[tour[i], tour[i+1]] for i in range(n)))\n        for i in range(n):\n            heuristics_matrix[best_tour[i], best_tour[i+1]] += 1\n            heuristics_matrix[best_tour[i+1], best_tour[i]] += 1\n\n    heuristics_matrix /= 100\n    return heuristics_matrix",
          "objective": 5.89478,
          "other_inf": null
     }
]