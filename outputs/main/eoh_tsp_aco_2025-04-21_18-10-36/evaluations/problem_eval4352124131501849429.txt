import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm employs a biased random walk to construct tours, favoring edges with shorter distances, and updates edge weights based on their frequency in the sampled tours, normalizing the weights to generate a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    edge_weights = np.ones_like(distance_matrix, dtype=float)
    num_samples = 50

    for _ in range(num_samples):
        # Biased random walk to construct a tour
        current_node = np.random.randint(n)
        tour = [current_node]
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)

        while unvisited_nodes:
            probabilities = np.zeros(n)
            for neighbor in unvisited_nodes:
                probabilities[neighbor] = edge_weights[current_node, neighbor] / distance_matrix[current_node, neighbor] if distance_matrix[current_node, neighbor] > 0 else edge_weights[current_node, neighbor]
            
            if np.sum(probabilities) == 0:
                next_node = unvisited_nodes.pop()
            else:
                probabilities /= np.sum(probabilities)
                next_node = np.random.choice(n, p=probabilities)
                while next_node not in unvisited_nodes:
                    probabilities[next_node] = 0
                    if np.sum(probabilities) == 0:
                        next_node = unvisited_nodes.pop()
                        break
                    probabilities /= np.sum(probabilities)
                    next_node = np.random.choice(n, p=probabilities)

            tour.append(next_node)
            unvisited_nodes.remove(next_node)
            current_node = next_node

        tour.append(tour[0])

        # Update edge weights based on tour
        for i in range(n):
            node1 = tour[i]
            node2 = tour[i+1]
            edge_weights[node1, node2] += 1
            edge_weights[node2, node1] += 1

    # Normalize edge weights to create heuristics matrix
    max_weight = np.max(edge_weights)
    if max_weight > 0:
        heuristics_matrix = edge_weights / max_weight
    else:
        heuristics_matrix = np.ones_like(distance_matrix) / n

    return heuristics_matrix
