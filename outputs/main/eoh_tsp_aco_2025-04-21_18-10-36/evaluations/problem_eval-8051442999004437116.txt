import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines edge frequency analysis from multiple random tours with a reinforcement learning approach to iteratively refine edge weights based on tour quality.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    edge_rewards = np.zeros_like(distance_matrix, dtype=float)
    learning_rate = 0.1
    discount_factor = 0.9
    num_episodes = 50
    exploration_rate = 0.2

    for episode in range(num_episodes):
        # Generate a random initial tour
        nodes = list(range(n))
        np.random.shuffle(nodes)
        tour = nodes + [nodes[0]]

        tour_length = 0
        for i in range(n):
            tour_length += distance_matrix[tour[i], tour[i+1]]

        # Update edge rewards based on tour length
        for i in range(n):
            node1 = tour[i]
            node2 = tour[i+1]
            reward = -tour_length # Negative reward for tour length
            edge_rewards[node1, node2] = (1 - learning_rate) * edge_rewards[node1, node2] + learning_rate * reward
            edge_rewards[node2, node1] = (1 - learning_rate) * edge_rewards[node2, node1] + learning_rate * reward
        
        # Explore or Exploit based on exploration rate
        if np.random.rand() < exploration_rate:
            # Explore : Randomly swap two edges
            i = np.random.randint(1, n - 1)
            j = np.random.randint(i + 2, n + 1)
            if j - i == 1:
                j = (j + 1) % (n + 1)  # Ensure distinct edges
            tour[i:j] = reversed(tour[i:j])  
        else:
            # Exploit : Based on current heuristics (edge_rewards)
            # Find best 2-opt swap
            best_i, best_j = None, None
            best_improvement = 0

            for i in range(1, n - 1):
                for j in range(i + 2, n + 1):
                    if j - i == 1: continue
                    current_distance = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[j-1], tour[j]]
                    new_distance = distance_matrix[tour[i-1], tour[j-1]] + distance_matrix[tour[i], tour[j]]
                    improvement = current_distance - new_distance
                    if improvement > best_improvement:
                        best_improvement = improvement
                        best_i, best_j = i, j
            
            if best_i is not None and best_j is not None:
                tour[best_i:best_j] = reversed(tour[best_i:best_j])
                
        # Update heuristics matrix after the tour refinement
        for i in range(n):
            heuristics_matrix[tour[i], tour[i+1]] += 1
            heuristics_matrix[tour[i+1], tour[i]] += 1

    # Normalize heuristics matrix
    max_val = np.max(heuristics_matrix)
    if max_val > 0:
        heuristics_matrix = heuristics_matrix / max_val
    else:
        heuristics_matrix = np.ones_like(distance_matrix) / n

    return heuristics_matrix
