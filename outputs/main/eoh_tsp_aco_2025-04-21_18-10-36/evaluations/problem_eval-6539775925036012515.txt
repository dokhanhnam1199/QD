import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a combination of shortest edge selection and cycle breaking to iteratively build a set of promising edges for the TSP.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    edges = []

    # Create a list of all possible edges with their distances
    for i in range(n):
        for j in range(i + 1, n):
            edges.append((i, j, distance_matrix[i, j]))

    # Sort edges by distance in ascending order
    edges.sort(key=lambda x: x[2])

    selected_edges = []
    degrees = [0] * n

    # Iteratively add edges, avoiding cycles and nodes with degree > 2
    for i, j, distance in edges:
        if degrees[i] < 2 and degrees[j] < 2:
            # Check for cycle creation
            creates_cycle = False
            if len(selected_edges) > 0:
                # Simple cycle detection: inefficient for large n, but sufficient for demonstration
                graph = {}
                for u, v in selected_edges:
                    if u not in graph:
                        graph[u] = []
                    if v not in graph:
                        graph[v] = []
                    graph[u].append(v)
                    graph[v].append(u)

                def has_path(start, end, visited):
                    if start == end:
                        return True
                    visited[start] = True
                    if start not in graph:
                        return False
                    for neighbor in graph[start]:
                        if not visited[neighbor]:
                            if has_path(neighbor, end, visited.copy()):
                                return True
                    return False
                
                if i in graph and j in graph:
                    visited = [False] * n
                    if has_path(i, j, visited):
                        creates_cycle = True

            if not creates_cycle:
                selected_edges.append((i, j))
                degrees[i] += 1
                degrees[j] += 1
                heuristics_matrix[i, j] = 1.0
                heuristics_matrix[j, i] = 1.0

    return heuristics_matrix
