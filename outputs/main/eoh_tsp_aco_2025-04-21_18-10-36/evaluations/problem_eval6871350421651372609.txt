import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines edge recombination from multiple initial tours with local search to generate a heuristic matrix reflecting edge frequency in improved solutions.}"""
    n = distance_matrix.shape[0]
    num_tours = 50
    num_iterations = 30
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    def generate_initial_tour(seed):
        np.random.seed(seed)
        tour = np.random.permutation(n)
        return tour

    def tour_length(tour):
        length = 0
        for i in range(n):
            length += distance_matrix[tour[i], tour[(i + 1) % n]]
        return length

    def two_opt_swap(tour, i, k):
        new_tour = tour[:i] + list(reversed(tour[i:k+1])) + tour[k+1:]
        return np.array(new_tour)
    
    def local_search(tour):
        best_tour = tour
        best_length = tour_length(tour)
        improved = True
        while improved:
            improved = False
            for i in range(n):
                for k in range(i + 2, n):
                    new_tour = two_opt_swap(best_tour, i, k)
                    new_length = tour_length(new_tour)
                    if new_length < best_length:
                        best_tour = new_tour
                        best_length = new_length
                        improved = True
                        break
                if improved:
                    break
        return best_tour

    tours = [generate_initial_tour(i) for i in range(num_tours)]
    
    for _ in range(num_iterations):
        for i in range(num_tours):
            tours[i] = local_search(tours[i])

    for tour in tours:
        for i in range(n):
            heuristics_matrix[tour[i], tour[(i + 1) % n]] += 1
            heuristics_matrix[tour[(i + 1) % n], tour[i]] += 1

    heuristics_matrix /= (num_tours * num_iterations)
    return heuristics_matrix
