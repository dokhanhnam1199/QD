import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines edge weights by probabilistically selecting edges based on their current weights and distance, reinforcing edges present in shorter tours.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix, dtype=float)
    alpha = 0.1
    num_iterations = 50
    num_neighbors = 10

    for _ in range(num_iterations):
        # Generate a set of tours using a probabilistic approach
        tours = []
        tour_lengths = []
        for _ in range(num_neighbors):
            tour = [np.random.choice(n, replace=False)]
            while len(tour) < n:
                current_node = tour[-1]
                probabilities = np.zeros(n)
                for neighbor in range(n):
                    if neighbor not in tour:
                        probabilities[neighbor] = heuristics_matrix[current_node, neighbor] / distance_matrix[current_node, neighbor]
                if np.sum(probabilities) > 0:
                    probabilities /= np.sum(probabilities)
                    next_node = np.random.choice(n, p=probabilities)
                    tour.append(next_node)
                else:
                     tour = []
                     break
            if tour:
              tour.append(tour[0])
              tour_length = 0
              for i in range(n):
                  tour_length += distance_matrix[tour[i], tour[i+1]]
              tours.append(tour)
              tour_lengths.append(tour_length)
        
        # Find the best tour in the current set
        if tours:
          best_tour_index = np.argmin(tour_lengths)
          best_tour = tours[best_tour_index]

          # Update the heuristics matrix based on the best tour
          for i in range(n):
              node1 = best_tour[i]
              node2 = best_tour[i+1]
              heuristics_matrix[node1, node2] = (1 - alpha) * heuristics_matrix[node1, node2] + alpha
              heuristics_matrix[node2, node1] = (1 - alpha) * heuristics_matrix[node2, node1] + alpha
        else:
            heuristics_matrix = np.ones_like(distance_matrix)
            break

    return heuristics_matrix
