import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a simulated annealing approach to iteratively improve a random tour, probabilistically accepting moves that worsen the solution to escape local optima, and constructs a heuristic matrix based on the frequency of edge appearances in accepted tours.}"""
    n = distance_matrix.shape[0]
    num_iterations = 10000
    initial_temperature = 100
    cooling_rate = 0.999
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Initialize a random tour
    tour = np.random.permutation(n)

    def calculate_tour_length(tour):
        length = 0
        for i in range(n):
            length += distance_matrix[tour[i], tour[(i + 1) % n]]
        return length

    current_length = calculate_tour_length(tour)
    temperature = initial_temperature

    for iteration in range(num_iterations):
        # Generate a neighbor by swapping two random cities
        i, j = np.random.choice(n, 2, replace=False)
        new_tour = tour.copy()
        new_tour[i], new_tour[j] = new_tour[j], new_tour[i]
        new_length = calculate_tour_length(new_tour)

        # Acceptance probability based on Metropolis criterion
        if new_length < current_length:
            acceptance_probability = 1.0
        else:
            acceptance_probability = np.exp((current_length - new_length) / temperature)

        # Accept the new tour with a certain probability
        if np.random.rand() < acceptance_probability:
            tour = new_tour
            current_length = new_length

            # Update heuristics matrix if new tour is accepted
            for k in range(n):
                heuristics_matrix[tour[k], tour[(k + 1) % n]] += 1
                heuristics_matrix[tour[(k + 1) % n], tour[k]] += 1

        # Cool down the temperature
        temperature *= cooling_rate

    heuristics_matrix /= num_iterations
    return heuristics_matrix
