import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm constructs a heuristic matrix by combining inverse distance with a node centrality measure based on shortest path lengths, emphasizing edges connected to central nodes.}"""
  n = distance_matrix.shape[0]
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  
  # Calculate shortest path lengths between all pairs of nodes
  shortest_paths = np.zeros_like(distance_matrix, dtype=float)
  for i in range(n):
    for j in range(n):
      if i == j:
        shortest_paths[i, j] = 0
      else:
        unvisited = list(range(n))
        distances = np.full(n, np.inf)
        distances[i] = 0
        
        while unvisited:
          current_node = min(unvisited, key=lambda node: distances[node])
          unvisited.remove(current_node)
          
          for neighbor in range(n):
            if distance_matrix[current_node, neighbor] > 0:
              new_distance = distances[current_node] + distance_matrix[current_node, neighbor]
              if new_distance < distances[neighbor]:
                distances[neighbor] = new_distance
        shortest_paths[i,j] = distances[j]
        

  # Calculate node centrality based on average shortest path length
  node_centrality = np.zeros(n)
  for i in range(n):
    node_centrality[i] = np.mean(shortest_paths[i,:])

  # Combine inverse distance with node centrality
  for i in range(n):
    for j in range(i + 1, n):
      distance = distance_matrix[i, j]
      if distance > 0:
        heuristics_matrix[i, j] = (1.0 / distance) * (1.0 / (node_centrality[i] + node_centrality[j]))
        heuristics_matrix[j, i] = heuristics_matrix[i, j]
      else:
        heuristics_matrix[i, j] = 0.0
        heuristics_matrix[j, i] = 0.0

  # Normalize the heuristics matrix
  max_heuristic = np.max(heuristics_matrix)
  if max_heuristic > 0:
      heuristics_matrix /= max_heuristic

  return heuristics_matrix
