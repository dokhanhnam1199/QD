import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm employs a genetic algorithm approach, iteratively evolving a population of candidate tours through selection, crossover, and mutation to converge towards optimal solutions.}
    """
    n = distance_matrix.shape[0]
    population_size = 50
    mutation_rate = 0.01
    num_generations = 100

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Initialize population
    population = []
    for _ in range(population_size):
        tour = np.random.permutation(n)
        population.append(tour)

    for generation in range(num_generations):
        # Evaluate fitness
        fitness_scores = np.zeros(population_size)
        for i, tour in enumerate(population):
            tour_length = 0
            for j in range(n - 1):
                tour_length += distance_matrix[tour[j], tour[j+1]]
            tour_length += distance_matrix[tour[n-1], tour[0]]
            fitness_scores[i] = 1 / (tour_length + 1e-6)

        # Selection (Roulette wheel selection)
        probabilities = fitness_scores / np.sum(fitness_scores)
        selected_indices = np.random.choice(population_size, size=population_size, p=probabilities)
        selected_population = [population[i] for i in selected_indices]

        # Crossover (Order Crossover)
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_population[i]
            if i + 1 < population_size:
                parent2 = selected_population[i+1]
            else:
                parent2 = selected_population[0]

            start = np.random.randint(n)
            length = np.random.randint(1, n // 2)
            end = (start + length) % n

            child1 = np.zeros(n, dtype=int) - 1
            child2 = np.zeros(n, dtype=int) - 1

            if start < end:
                child1[start:end] = parent1[start:end]
                child2[start:end] = parent2[start:end]
            else:
                child1[start:] = parent1[start:]
                child1[:end] = parent1[:end]
                child2[start:] = parent2[start:]
                child2[:end] = parent2[:end]
            
            p1_idx = 0
            p2_idx = 0
            c1_idx = 0
            c2_idx = 0
            while -1 in child1:
                if parent2[p2_idx] not in child1:
                    child1[c1_idx] = parent2[p2_idx]
                    c1_idx += 1
                    if c1_idx == n:
                        break
                    if child1[c1_idx] != -1:
                       while child1[c1_idx] != -1:
                           c1_idx += 1
                           if c1_idx == n:
                                break

                p2_idx += 1
                if p2_idx == n:
                    p2_idx = 0
            
            while -1 in child2:
                if parent1[p1_idx] not in child2:
                    child2[c2_idx] = parent1[p1_idx]
                    c2_idx += 1
                    if c2_idx == n:
                        break
                    if child2[c2_idx] != -1:
                       while child2[c2_idx] != -1:
                           c2_idx += 1
                           if c2_idx == n:
                                break

                p1_idx += 1
                if p1_idx == n:
                    p1_idx = 0

            new_population.append(child1)
            new_population.append(child2)

        # Mutation (Swap Mutation)
        for tour in new_population:
            if np.random.rand() < mutation_rate:
                i, j = np.random.choice(n, 2, replace=False)
                tour[i], tour[j] = tour[j], tour[i]

        population = new_population

        #Update heuristics matrix with best tour in the generation
        best_tour_index = np.argmax(fitness_scores)
        best_tour = population[best_tour_index]
        for i in range(n):
            heuristics_matrix[best_tour[i], best_tour[(i+1)%n]] += 1
            heuristics_matrix[best_tour[(i+1)%n], best_tour[i]] += 1

    heuristics_matrix /= num_generations
    return heuristics_matrix
