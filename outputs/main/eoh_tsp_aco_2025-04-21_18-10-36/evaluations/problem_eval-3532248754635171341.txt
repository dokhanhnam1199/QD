import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm constructs a heuristic matrix by iteratively building tours with a focus on incorporating edges that appear frequently in short paths between randomly selected node pairs.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 1000

    for _ in range(num_iterations):
        # Randomly select two nodes
        node1 = np.random.randint(n)
        node2 = np.random.randint(n)

        # Find shortest path between the two nodes using Dijkstra's algorithm
        dist = np.full(n, float('inf'))
        dist[node1] = 0
        unvisited = set(range(n))
        previous = {node: None for node in range(n)}

        while unvisited:
            current_node = None
            min_dist = float('inf')
            for node in unvisited:
                if dist[node] < min_dist:
                    min_dist = dist[node]
                    current_node = node

            if current_node is None:
                break

            unvisited.remove(current_node)

            for neighbor in range(n):
                if distance_matrix[current_node, neighbor] != 0:
                    alt_path = dist[current_node] + distance_matrix[current_node, neighbor]
                    if alt_path < dist[neighbor]:
                        dist[neighbor] = alt_path
                        previous[neighbor] = current_node

        # Reconstruct the path from node2 to node1
        path = []
        current = node2
        while current is not None:
            path.insert(0, current)
            current = previous[current]

        # If a path exists, increment the heuristic matrix for each edge in the path
        if len(path) > 1 and path[0] == node1:
            for i in range(len(path) - 1):
                heuristics_matrix[path[i], path[i+1]] += 1
                heuristics_matrix[path[i+1], path[i]] += 1 # ensure symmetry

    # Normalize the heuristics matrix
    max_value = np.max(heuristics_matrix)
    if max_value > 0:
        heuristics_matrix /= max_value

    return heuristics_matrix
