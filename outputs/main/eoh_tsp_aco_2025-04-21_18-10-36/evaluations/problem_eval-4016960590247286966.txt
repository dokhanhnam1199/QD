import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a weighted combination of inverse distance, shortest path participation, and minimum spanning tree participation to generate a heuristics matrix for the TSP.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Inverse Distance Heuristic
    inverse_distance = 1 / (distance_matrix + np.eye(n))  # Add identity to avoid division by zero
    
    # Shortest Path Heuristic (approximate participation)
    shortest_path_counts = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                path = find_shortest_path(distance_matrix, i, j)
                for k in range(len(path) - 1):
                    u, v = sorted((path[k], path[k+1]))
                    shortest_path_counts[u, v] += 1
                    shortest_path_counts[v, u] += 1

    # Minimum Spanning Tree Heuristic (approximate participation)
    mst_counts = np.zeros((n, n))
    mst = prim(distance_matrix)  # Adjacency matrix representing the MST
    for i in range(n):
        for j in range(i + 1, n):  # Only iterate over upper triangle
            if mst[i, j] > 0:
                mst_counts[i, j] = 1
                mst_counts[j, i] = 1
    
    # Normalize participation counts
    max_sp_count = np.max(shortest_path_counts)
    if max_sp_count > 0:
        shortest_path_counts = shortest_path_counts / max_sp_count

    max_mst_count = np.max(mst_counts)
    if max_mst_count > 0:
        mst_counts = mst_counts / max_mst_count

    # Combine heuristics with weights
    w_inverse_distance = 0.5
    w_shortest_path = 0.3
    w_mst = 0.2

    heuristics_matrix = (w_inverse_distance * inverse_distance +
                         w_shortest_path * shortest_path_counts +
                         w_mst * mst_counts)

    return heuristics_matrix


def find_shortest_path(distance_matrix, start_node, end_node):
    """Simple Dijkstra-like approach for finding shortest path"""
    n = distance_matrix.shape[0]
    distances = np.full(n, np.inf)
    distances[start_node] = 0
    visited = np.zeros(n, dtype=bool)
    previous = np.full(n, -1, dtype=int)  # Store previous node in shortest path

    for _ in range(n):
        # Find node with minimum distance among unvisited nodes
        min_dist = np.inf
        min_index = -1
        for v in range(n):
            if not visited[v] and distances[v] < min_dist:
                min_dist = distances[v]
                min_index = v

        if min_index == -1:
            break

        visited[min_index] = True

        for v in range(n):
            if distance_matrix[min_index, v] > 0 and distances[min_index] + distance_matrix[min_index, v] < distances[v]:
                distances[v] = distances[min_index] + distance_matrix[min_index, v]
                previous[v] = min_index

    # Reconstruct path
    path = []
    current = end_node
    while current != -1:
        path.insert(0, current)
        current = previous[current]

    return path

def prim(distance_matrix):
    """Prim's algorithm to find Minimum Spanning Tree (MST)"""
    n = distance_matrix.shape[0]
    mst = np.zeros((n, n))  # Adjacency matrix representing MST

    visited = [False] * n
    key = [np.inf] * n
    parent = [None] * n

    key[0] = 0  # Start from node 0
    
    for _ in range(n):
        # Find the vertex with minimum key value
        min_key = np.inf
        u = -1
        for v in range(n):
            if not visited[v] and key[v] < min_key:
                min_key = key[v]
                u = v

        if u == -1:
            break

        visited[u] = True

        for v in range(n):
            if distance_matrix[u, v] > 0 and not visited[v] and distance_matrix[u, v] < key[v]:
                key[v] = distance_matrix[u, v]
                parent[v] = u

    # Build the MST adjacency matrix
    for v in range(1, n):
        u = parent[v]
        mst[u, v] = distance_matrix[u, v]
        mst[v, u] = distance_matrix[v, u]
        
    return heuristics_matrix
