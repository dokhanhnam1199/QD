import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining shortest path distances with a penalty for path overlap, encouraging diverse exploration of edges.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    shortest_path_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Floyd-Warshall algorithm to compute all-pairs shortest paths
    for k in range(n):
        for i in range(n):
            for j in range(n):
                distance_matrix[i, j] = min(distance_matrix[i, j], distance_matrix[i, k] + distance_matrix[k, j])
    shortest_path_matrix = distance_matrix.copy()

    # Normalize shortest path distances
    max_distance = np.max(shortest_path_matrix)
    shortest_path_matrix = (max_distance - shortest_path_matrix) / max_distance

    # Add a penalty for edges that are part of many short paths
    overlap_penalty = np.zeros((n,n))
    for i in range(n):
      for j in range(n):
        if i!=j:
            count = 0
            for start in range(n):
                for end in range(n):
                    if start!=end:
                        path = find_path(distance_matrix, start, end)
                        if path and i in path and j in path:
                            count+=1

            overlap_penalty[i,j] = count
    max_overlap = np.max(overlap_penalty)
    if max_overlap >0 :
        overlap_penalty = overlap_penalty/max_overlap
    else:
        overlap_penalty = np.zeros_like(overlap_penalty)

    heuristics_matrix = shortest_path_matrix - 0.5*overlap_penalty #weight the importance 
    return heuristics_matrix

def find_path(distance_matrix, start_node, end_node):
    n = distance_matrix.shape[0]
    dist = {node: float('inf') for node in range(n)}
    prev = {node: None for node in range(n)}
    dist[start_node] = 0

    unvisited = set(range(n))

    while unvisited:
        current_node = min(unvisited, key=dist.get)
        if dist[current_node] == float('inf'):
            break

        unvisited.remove(current_node)

        for neighbor in range(n):
            if distance_matrix[current_node, neighbor] > 0 and neighbor != current_node:
                alt_path = dist[current_node] + distance_matrix[current_node, neighbor]
                if alt_path < dist[neighbor]:
                    dist[neighbor] = alt_path
                    prev[neighbor] = current_node

    path = []
    current = end_node
    while current is not None:
        path.insert(0, current)
        current = prev[current]

    if path[0] == start_node:
        return path
    else:
        return heuristics_matrix
