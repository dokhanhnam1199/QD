import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines a heuristics matrix by prioritizing edges that connect nodes with high centrality and short distances.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix, dtype=float)

    # Node centrality based on inverse distance to other nodes
    node_centrality = np.zeros(n)
    for i in range(n):
        node_centrality[i] = np.sum(1.0 / (distance_matrix[i, :] + 1e-9))  # Avoid division by zero

    # Iteratively refine the heuristics matrix
    num_iterations = 10
    for _ in range(num_iterations):
        for i in range(n):
            for j in range(n):
                if i != j:
                    # Heuristic based on distance and centrality of connected nodes
                    heuristics_matrix[i, j] = (node_centrality[i] + node_centrality[j]) / (distance_matrix[i, j] + 1e-9)
                else:
                    heuristics_matrix[i, j] = 0  # No self-loops

        # Normalize heuristics matrix
        heuristics_matrix = heuristics_matrix / np.max(heuristics_matrix)

    return heuristics_matrix
