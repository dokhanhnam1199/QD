import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristics matrix by combining shortest path information with a measure of node centrality to prioritize edges connecting central nodes via short paths.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate shortest path lengths between all pairs of nodes
    shortest_paths = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i == j:
                shortest_paths[i, j] = 0
            else:
                unvisited = list(range(n))
                distances = np.full(n, np.inf)
                distances[i] = 0
                while unvisited:
                    current_node = min(unvisited, key=lambda node: distances[node])
                    if distances[current_node] == np.inf:
                        break
                    unvisited.remove(current_node)

                    for neighbor in range(n):
                        if distance_matrix[current_node, neighbor] != 0:
                            alt_path = distances[current_node] + distance_matrix[current_node, neighbor]
                            if alt_path < distances[neighbor]:
                                distances[neighbor] = alt_path
                shortest_paths[i, j] = distances[j]
                
    # Calculate node centrality (degree centrality as an example)
    node_centrality = np.sum(distance_matrix != 0, axis=0) / (n - 1)

    # Combine shortest path information and node centrality
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] = (1 / (1 + shortest_paths[i, j])) * (node_centrality[i] + node_centrality[j])
            else:
                heuristics_matrix[i, j] = 0  # No self-loops

    # Normalize the heuristics matrix
    max_heuristic = np.max(heuristics_matrix)
    if max_heuristic > 0:
        heuristics_matrix /= max_heuristic
    else:
        heuristics_matrix = np.ones_like(distance_matrix) / n

    return heuristics_matrix
