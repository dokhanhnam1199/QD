import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by iteratively perturbing random tours and updating edge weights based on tour length improvements, combined with a bias towards shorter edges.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 100
    perturbation_size = int(np.sqrt(n))
    alpha = 0.9

    for _ in range(num_iterations):
        # Generate a random initial tour
        tour = np.random.permutation(n)

        # Calculate initial tour length
        tour_length = 0
        for i in range(n):
            tour_length += distance_matrix[tour[i], tour[(i + 1) % n]]

        # Perturb the tour
        for _ in range(perturbation_size):
            i, j = np.random.choice(n, 2, replace=False)
            tour[i], tour[j] = tour[j], tour[i]

        # Calculate new tour length
        new_tour_length = 0
        for i in range(n):
            new_tour_length += distance_matrix[tour[i], tour[(i + 1) % n]]

        # Update heuristics matrix if the new tour is better
        if new_tour_length < tour_length:
            improvement = tour_length - new_tour_length
            for i in range(n):
                node1 = tour[i]
                node2 = tour[(i + 1) % n]
                heuristics_matrix[node1, node2] += alpha * improvement
                heuristics_matrix[node2, node1] += alpha * improvement

        # Bias towards shorter edges
        for i in range(n):
            for j in range(n):
                if i != j:
                    heuristics_matrix[i, j] += (1 / (distance_matrix[i, j] + 1e-6))

    return heuristics_matrix
