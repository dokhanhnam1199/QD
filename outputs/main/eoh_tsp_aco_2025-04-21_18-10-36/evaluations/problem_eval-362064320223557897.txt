import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm prioritizes edges connecting nodes with high degree in short random tours, and then refines heuristics based on tour length.}"""
  n = distance_matrix.shape[0]
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  num_random_tours = 50
  tour_length_threshold = np.mean(distance_matrix) * n
  degree = np.zeros(n)

  for _ in range(num_random_tours):
      start_node = np.random.randint(n)
      tour = [start_node]
      unvisited = set(range(n))
      unvisited.remove(start_node)
      current_node = start_node

      while unvisited:
          next_node = np.random.choice(list(unvisited))
          tour.append(next_node)
          unvisited.remove(next_node)
          current_node = next_node

      tour.append(start_node)
      tour_length = 0
      for i in range(n):
          tour_length += distance_matrix[tour[i], tour[i+1]]
      
      if tour_length < tour_length_threshold:
          for i in range(n):
              u = tour[i]
              v = tour[i+1]
              heuristics_matrix[u, v] += 1/tour_length
              heuristics_matrix[v, u] += 1/tour_length
              degree[u] += 1
              degree[v] += 1

  for i in range(n):
      for j in range(n):
          if i != j:
              heuristics_matrix[i, j] += (degree[i] + degree[j]) / distance_matrix[i, j]

  heuristics_matrix /= np.sum(heuristics_matrix)
  return heuristics_matrix
