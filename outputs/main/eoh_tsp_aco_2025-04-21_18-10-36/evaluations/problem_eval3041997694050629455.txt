import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm refines a heuristics matrix by combining distance information with a measure of node "reach," iteratively emphasizing edges connecting nodes with high reach and short distances.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix, dtype=float)

    # Calculate node reach based on average distance to other nodes
    node_reach = np.zeros(n)
    for i in range(n):
        node_reach[i] = np.mean(distance_matrix[i, :])

    # Iteratively refine the heuristics matrix
    num_iterations = 5
    alpha = 0.7  # Weight for reach vs. distance
    for _ in range(num_iterations):
        for i in range(n):
            for j in range(n):
                if i != j:
                    # Heuristic based on distance and reach of connected nodes
                    heuristics_matrix[i, j] = (alpha * (1 / (distance_matrix[i, j] + 1e-9)) + (1 - alpha) * (1 / (node_reach[i] + node_reach[j] + 1e-9)))
                else:
                    heuristics_matrix[i, j] = 0  # No self-loops

        # Normalize heuristics matrix
        heuristics_matrix = heuristics_matrix / np.max(heuristics_matrix)

    return heuristics_matrix
