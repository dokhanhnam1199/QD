import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple random tours, and for each edge, the heuristic value is the inverse of the average tour length containing that edge.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    heuristics_matrix = np.zeros((n, n))
    edge_counts = np.zeros((n, n))

    for _ in range(num_samples):
        # Generate a random tour
        permutation = np.random.permutation(n)
        tour = np.append(permutation, permutation[0])  # Return to starting city
        
        tour_length = 0
        for i in range(n):
            city1 = tour[i]
            city2 = tour[i+1]
            tour_length += distance_matrix[city1, city2]
            
        # Update edge counts
        for i in range(n):
            city1 = tour[i]
            city2 = tour[i+1]
            edge_counts[city1, city2] += 1
            edge_counts[city2, city1] += 1  # Assuming symmetric TSP

        #Update heuristics_matrix
        for i in range(n):
            city1 = tour[i]
            city2 = tour[i+1]
            heuristics_matrix[city1, city2] += 1/tour_length
            heuristics_matrix[city2, city1] += 1/tour_length
            
    return heuristics_matrix
