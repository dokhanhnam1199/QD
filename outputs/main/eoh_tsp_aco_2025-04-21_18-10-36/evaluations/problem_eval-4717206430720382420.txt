import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristics matrix by iteratively refining edge probabilities based on shortest path computations, prioritizing edges frequently used in short paths.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix)
    alpha = 0.1
    num_iterations = 20

    for _ in range(num_iterations):
        for i in range(n):
            for j in range(n):
                if i != j:
                    # Compute shortest path between i and j using current heuristics
                    path = shortest_path(distance_matrix, heuristics_matrix, i, j)

                    # Update heuristics based on path usage
                    path_length = 0
                    for k in range(len(path) - 1):
                        path_length += distance_matrix[path[k], path[k+1]]

                    for k in range(len(path) - 1):
                        u = path[k]
                        v = path[k+1]
                        heuristics_matrix[u, v] += alpha * (1 / (1 + path_length))
                        heuristics_matrix[v, u] += alpha * (1 / (1 + path_length))

    return heuristics_matrix

def shortest_path(distance_matrix, heuristics_matrix, start_node, end_node):
    n = distance_matrix.shape[0]
    dist = {node: float('inf') for node in range(n)}
    dist[start_node] = 0
    prev = {node: None for node in range(n)}
    unvisited = set(range(n))

    while unvisited:
        current_node = min(unvisited, key=dist.get)
        if dist[current_node] == float('inf'):
            break
        unvisited.remove(current_node)

        for neighbor in range(n):
            if neighbor != current_node:
                alt_path = dist[current_node] + distance_matrix[current_node, neighbor] / (heuristics_matrix[current_node, neighbor] + 1e-9)
                if alt_path < dist[neighbor]:
                    dist[neighbor] = alt_path
                    prev[neighbor] = current_node

    path = []
    current = end_node
    while current is not None:
        path.insert(0, current)
        current = prev[current]

    return heuristics_matrix
