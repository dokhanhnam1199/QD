import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm uses a shortest path algorithm (Dijkstra's) from each node to all other nodes to create a matrix reflecting the shortest path distances between each pair, then inverts these distances to form a heuristic matrix favoring edges on short paths.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for start_node in range(n):
        distances = np.full(n, np.inf)
        distances[start_node] = 0
        visited = np.zeros(n, dtype=bool)

        for _ in range(n):
            # Find the unvisited node with the smallest distance
            min_dist = np.inf
            min_index = -1
            for v in range(n):
                if not visited[v] and distances[v] < min_dist:
                    min_dist = distances[v]
                    min_index = v

            if min_index == -1:
                break

            visited[min_index] = True

            # Update distances to neighbors
            for neighbor in range(n):
                if distance_matrix[min_index, neighbor] > 0:  # Assuming 0 means no connection
                    new_dist = distances[min_index] + distance_matrix[min_index, neighbor]
                    if new_dist < distances[neighbor]:
                        distances[neighbor] = new_dist

        # Invert the distances to create a heuristic value
        for i in range(n):
            if distances[i] != 0 and distances[i] != np.inf:
                heuristics_matrix[start_node, i] = 1 / distances[i]
                heuristics_matrix[i, start_node] = 1 / distances[i]
            elif i == start_node:
                 heuristics_matrix[start_node, i] = 0
            else:
                heuristics_matrix[start_node, i] = 0
                heuristics_matrix[i, start_node] = 0


    return heuristics_matrix
