import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs tours incrementally using a greedy approach, biased by edge appearance in short sampled tours, and updates a heuristic matrix favoring frequently used edges.}"""
    n = distance_matrix.shape[0]
    num_samples = 500
    sampled_tour_lengths = np.zeros(num_samples)
    sampled_tours = np.zeros((num_samples, n), dtype=int)

    for i in range(num_samples):
        tour = np.random.permutation(n)
        sampled_tours[i, :] = tour
        tour_length = 0
        for j in range(n - 1):
            tour_length += distance_matrix[tour[j], tour[j+1]]
        tour_length += distance_matrix[tour[-1], tour[0]]
        sampled_tour_lengths[i] = tour_length

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    for start_node in range(n):
        for _ in range(5): # Multiple attempts from each start node.
            current_node = start_node
            unvisited_nodes = set(range(n))
            unvisited_nodes.remove(current_node)
            current_tour = [current_node]
            
            while unvisited_nodes:
                best_next_node = None
                best_heuristic_value = -np.inf
                
                for next_node in unvisited_nodes:
                    heuristic_value = 0
                    # Bias towards shorter distances, but also consider frequency in sampled tours
                    heuristic_value = -distance_matrix[current_node, next_node]
                    
                    #check edges in sampled tour
                    for i in range(num_samples):
                        tour = sampled_tours[i, :]
                        if (current_node in tour) and (next_node in tour):
                            
                            idx_current = np.where(tour == current_node)[0][0]
                            idx_next = np.where(tour == next_node)[0][0]
                            
                            if abs(idx_current - idx_next) == 1 or \
                                ((idx_current == 0 and idx_next == n-1) or (idx_next == 0 and idx_current == n-1)):
                                tour_length = sampled_tour_lengths[i]
                                heuristic_value += (np.max(sampled_tour_lengths) - tour_length)
                                
                                

                    if heuristic_value > best_heuristic_value:
                        best_heuristic_value = heuristic_value
                        best_next_node = next_node
                
                current_tour.append(best_next_node)
                unvisited_nodes.remove(best_next_node)
                current_node = best_next_node
            
            #Complete the tour back to the start
            current_tour.append(start_node)

            #Update heuristics matrix based on the tour found
            for j in range(n):
                heuristics_matrix[current_tour[j], current_tour[j+1]] += 1
                heuristics_matrix[current_tour[j+1], current_tour[j]] += 1
    
    return heuristics_matrix
