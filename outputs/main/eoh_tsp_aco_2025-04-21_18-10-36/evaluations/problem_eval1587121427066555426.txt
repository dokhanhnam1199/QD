import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by assigning probabilities based on an exponential decay of the distances, adjusted by a local scaling factor.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for i in range(n):
        # Calculate local scaling factor based on average distance from node i
        avg_distance = np.mean(distance_matrix[i][distance_matrix[i] > 0]) if np.any(distance_matrix[i] > 0) else 1
        
        for j in range(i + 1, n):
            distance = distance_matrix[i, j]
            if distance > 0:
                # Exponential decay based on the distance and scaled by the average distance from node i
                heuristics_matrix[i, j] = np.exp(-distance / avg_distance)
                heuristics_matrix[j, i] = heuristics_matrix[i, j]
            else:
                heuristics_matrix[i, j] = np.inf
                heuristics_matrix[j, i] = np.inf

    # Scale the heuristics matrix to [0, 1]
    max_heuristic = np.max(heuristics_matrix[np.isfinite(heuristics_matrix)])
    heuristics_matrix[np.isfinite(heuristics_matrix)] /= max_heuristic

    return heuristics_matrix
