import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm refines the heuristic matrix by iteratively adjusting edge desirability based on the frequency with which edges appear in relatively short paths constructed using a nearest neighbor approach, while also incorporating a penalty for longer edges.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 100
    num_paths = n

    for _ in range(num_iterations):
        all_paths = []
        all_path_lengths = []

        for _ in range(num_paths):
            start_node = np.random.randint(n)
            current_node = start_node
            unvisited_nodes = set(range(n))
            unvisited_nodes.remove(start_node)
            path = [start_node]
            path_length = 0

            while unvisited_nodes:
                nearest_neighbor = None
                min_distance = float('inf')
                for neighbor in unvisited_nodes:
                    distance = distance_matrix[current_node, neighbor]
                    if distance < min_distance:
                        min_distance = distance
                        nearest_neighbor = neighbor

                path.append(nearest_neighbor)
                path_length += distance_matrix[current_node, nearest_neighbor]
                unvisited_nodes.remove(nearest_neighbor)
                current_node = nearest_neighbor

            path.append(start_node)
            path_length += distance_matrix[current_node, start_node]
            all_paths.append(path)
            all_path_lengths.append(path_length)

        # Normalize path lengths to a 0-1 scale (lower is better).
        max_path_length = max(all_path_lengths)
        normalized_path_lengths = [(max_path_length - length) / max_path_length for length in all_path_lengths]

        # Update heuristics matrix based on path quality and edge usage
        for path_index, path in enumerate(all_paths):
            path_quality = normalized_path_lengths[path_index]
            for i in range(n):
                node1 = path[i]
                node2 = path[i + 1]
                edge_distance = distance_matrix[node1, node2]
                heuristics_matrix[node1, node2] += path_quality / (1 + edge_distance)  # Penalize longer edges
                heuristics_matrix[node2, node1] += path_quality / (1 + edge_distance)

    # Normalize the heuristics matrix
    max_heuristic = np.max(heuristics_matrix)
    if max_heuristic > 0:
        heuristics_matrix /= max_heuristic

    return heuristics_matrix
