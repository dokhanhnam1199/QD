import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm adaptively adjusts edge weights based on the frequency with which they appear in near-optimal solutions generated by iteratively perturbing existing tours.}"""
    n = distance_matrix.shape[0]
    
    # Initialize heuristics matrix
    heuristics_matrix = np.ones_like(distance_matrix)

    # Number of iterations
    num_iterations = 100

    # Number of tours to generate per iteration
    num_tours = 50

    # Perturbation factor (how much to change the tour)
    perturbation_factor = 0.1

    # Initial tour (e.g., nearest neighbor)
    def initial_tour(distance_matrix):
      n = distance_matrix.shape[0]
      start_node = 0
      unvisited_nodes = set(range(1,n))
      tour = [start_node]
      current_node = start_node
      while unvisited_nodes:
          nearest_node = min(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])
          tour.append(nearest_node)
          unvisited_nodes.remove(nearest_node)
          current_node = nearest_node
      tour.append(start_node)
      return tour

    best_tour = initial_tour(distance_matrix)

    def tour_length(tour, distance_matrix):
        length = 0
        for i in range(len(tour) - 1):
            length += distance_matrix[tour[i], tour[i+1]]
        return length
    
    best_tour_length = tour_length(best_tour, distance_matrix)


    for iteration in range(num_iterations):
        tours = []
        tour_lengths = []

        for _ in range(num_tours):
            # Perturb the current best tour
            perturbed_tour = best_tour[:]
            num_swaps = int(n * perturbation_factor)
            for _ in range(num_swaps):
                i, j = np.random.choice(range(1, n), 2, replace=False)  # Avoid swapping the start node
                perturbed_tour[i], perturbed_tour[j] = perturbed_tour[j], perturbed_tour[i]

            # Calculate the length of the perturbed tour
            perturbed_tour_length = tour_length(perturbed_tour, distance_matrix)

            tours.append(perturbed_tour)
            tour_lengths.append(perturbed_tour_length)

        # Update the best tour if a shorter tour is found
        for i in range(num_tours):
            if tour_lengths[i] < best_tour_length:
                best_tour = tours[i]
                best_tour_length = tour_lengths[i]

        # Update the heuristics matrix based on the frequency of edges in near-optimal tours
        threshold = best_tour_length * (1 + 0.1) # Consider tours within 10% of best tour length

        for i in range(num_tours):
            if tour_lengths[i] <= threshold:
                tour = tours[i]
                for j in range(n):
                    node1 = tour[j]
                    node2 = tour[j+1]
                    heuristics_matrix[node1, node2] += 1
                    heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
