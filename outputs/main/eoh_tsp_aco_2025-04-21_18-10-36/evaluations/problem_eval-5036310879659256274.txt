import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining inverse distance with a simulated annealing approach to iteratively refine edge weights based on improving local path segments.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = 1.0 / (distance_matrix + np.eye(n))  # Avoid division by zero

    temperature = 1.0
    cooling_rate = 0.005
    num_iterations = 1000

    for _ in range(num_iterations):
        i = np.random.randint(0, n)
        j = np.random.randint(0, n)
        if i == j:
            continue

        k = np.random.randint(0, n)
        if k == i or k == j:
            continue
        
        current_cost = distance_matrix[i, j] + distance_matrix[j, k]
        new_cost = distance_matrix[i, k] + distance_matrix[k, j]
        
        if new_cost < current_cost:
            delta = current_cost - new_cost
            heuristics_matrix[i, j] += delta * temperature
            heuristics_matrix[j, i] = heuristics_matrix[i, j]
            heuristics_matrix[i, k] += delta * temperature
            heuristics_matrix[k, i] = heuristics_matrix[i, k]
            heuristics_matrix[j, k] += delta * temperature
            heuristics_matrix[k, j] = heuristics_matrix[j, k]

        else:
            probability = np.exp((current_cost - new_cost) / temperature)
            if np.random.rand() < probability:
                delta = current_cost - new_cost
                heuristics_matrix[i, j] += delta * temperature
                heuristics_matrix[j, i] = heuristics_matrix[i, j]
                heuristics_matrix[i, k] += delta * temperature
                heuristics_matrix[k, i] = heuristics_matrix[i, k]
                heuristics_matrix[j, k] += delta * temperature
                heuristics_matrix[k, j] = heuristics_matrix[j, k]
        
        temperature *= (1 - cooling_rate)

    return heuristics_matrix
