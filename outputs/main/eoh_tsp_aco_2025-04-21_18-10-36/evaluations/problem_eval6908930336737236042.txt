import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines random tour generation with iterative refinement using a weighted combination of distance and edge frequency from successful paths to construct a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    edge_success = np.zeros_like(distance_matrix, dtype=float)
    alpha = 0.7  # Weight for edge frequency
    beta = 0.3   # Weight for inverse distance
    num_iterations = 60
    num_tours = 40
    local_search_iterations = 5

    for _ in range(num_iterations):
        all_tours = []
        all_tour_lengths = []

        for _ in range(num_tours):
            # Generate a random initial tour
            nodes = list(range(n))
            np.random.shuffle(nodes)
            tour = nodes + [nodes[0]]
            
            #Iterative Refinement with Edge Success Weighting
            for _ in range(local_search_iterations):
                improved = True
                while improved:
                    improved = False
                    for i in range(1, n - 1):
                        for j in range(i + 2, n + 1):
                            if j - i == 1: continue
                            node1, node2 = tour[i-1], tour[i]
                            node3, node4 = tour[j-1], tour[j]
                            current_distance = distance_matrix[node1, node2] + distance_matrix[node3, node4]
                            new_node1, new_node2 = tour[i-1], tour[j-1]
                            new_node3, new_node4 = tour[i], tour[j]
                            new_distance = distance_matrix[new_node1, new_node2] + distance_matrix[new_node3, new_node4]
                            if new_distance < current_distance:
                                tour[i:j] = reversed(tour[i:j])
                                improved = True

            tour_length = 0
            for i in range(n):
                tour_length += distance_matrix[tour[i], tour[i+1]]
            all_tours.append(tour)
            all_tour_lengths.append(tour_length)
        
        # Find the best tour in this iteration
        best_tour_index = np.argmin(all_tour_lengths)
        best_tour = all_tours[best_tour_index]
        
        # Update edge success based on the best tour
        for i in range(n):
            node1 = best_tour[i]
            node2 = best_tour[i+1]
            edge_success[node1, node2] += 1
            edge_success[node2, node1] += 1

    # Create the heuristics matrix based on edge success and inverse distance
    for i in range(n):
        for j in range(i + 1, n):
            heuristics_matrix[i, j] = (alpha * (edge_success[i, j] / num_iterations)) + (beta / distance_matrix[i, j])
            heuristics_matrix[j, i] = heuristics_matrix[i, j]

    return heuristics_matrix
