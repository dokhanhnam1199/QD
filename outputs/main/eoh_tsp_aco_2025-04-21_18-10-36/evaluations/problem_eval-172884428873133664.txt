import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses simulated annealing to explore the solution space and biases the heuristic matrix based on the frequency with which each edge appears in accepted solutions during the annealing process.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 1000
    initial_temperature = 100
    cooling_rate = 0.95

    # Initialize a random tour
    current_tour = np.random.permutation(n)
    current_cost = calculate_tour_cost(current_tour, distance_matrix)
    temperature = initial_temperature

    for iteration in range(num_iterations):
        # Generate a neighbor tour by swapping two cities
        neighbor_tour = current_tour.copy()
        i, j = np.random.choice(n, 2, replace=False)
        neighbor_tour[i], neighbor_tour[j] = neighbor_tour[j], neighbor_tour[i]
        neighbor_cost = calculate_tour_cost(neighbor_tour, distance_matrix)

        # Acceptance probability
        delta_cost = neighbor_cost - current_cost
        if delta_cost < 0 or np.random.rand() < np.exp(-delta_cost / temperature):
            current_tour = neighbor_tour
            current_cost = neighbor_cost

        # Update heuristics matrix based on the current tour
        for i in range(n):
            city1 = current_tour[i]
            city2 = current_tour[(i + 1) % n]
            heuristics_matrix[city1, city2] += 1
            heuristics_matrix[city2, city1] += 1  # Ensure symmetry

        # Cool the temperature
        temperature *= cooling_rate

    # Normalize the heuristics matrix
    heuristics_matrix /= num_iterations
    return heuristics_matrix

def calculate_tour_cost(tour, distance_matrix):
    cost = 0
    n = len(tour)
    for i in range(n):
        cost += distance_matrix[tour[i], tour[(i + 1) % n]]
    return heuristics_matrix
