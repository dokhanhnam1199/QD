import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by averaging shortest path distances between all node pairs and then normalizing the result.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Calculate shortest path distance between node i and j using Dijkstra's algorithm
                unvisited = list(range(n))
                distances = {node: float('inf') for node in unvisited}
                distances[i] = 0
                
                while unvisited:
                    current_node = min(unvisited, key=distances.get)
                    
                    if distances[current_node] == float('inf'):
                        break

                    for neighbor in range(n):
                        if distance_matrix[current_node, neighbor] != 0 and neighbor in unvisited:
                            new_distance = distances[current_node] + distance_matrix[current_node, neighbor]
                            if new_distance < distances[neighbor]:
                                distances[neighbor] = new_distance
                    
                    unvisited.remove(current_node)

                heuristics_matrix[i, j] = distances[j]
            else:
                heuristics_matrix[i, j] = 0

    # Normalize the heuristics matrix
    max_distance = np.max(heuristics_matrix)
    if max_distance > 0:
        heuristics_matrix = (max_distance - heuristics_matrix) / max_distance # Higher values indicate more promising edges
    else:
        heuristics_matrix = np.ones_like(distance_matrix) / n # Avoid division by zero and handle the case where all distances are zero

    return heuristics_matrix
