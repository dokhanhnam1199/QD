import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm employs ant colony optimization (ACO) principles by simulating ants constructing tours based on pheromone trails and heuristic information derived from edge lengths, iteratively updating pheromone levels to converge towards promising solutions.}
    """
    n = distance_matrix.shape[0]
    num_ants = 50
    pheromone = np.ones_like(distance_matrix)
    alpha = 1
    beta = 2
    rho = 0.5
    Q = 100

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for iteration in range(100):
        tours = []
        for ant in range(num_ants):
            start_node = np.random.randint(n)
            tour = [start_node]
            unvisited = set(range(n))
            unvisited.remove(start_node)

            while unvisited:
                current_node = tour[-1]
                probabilities = np.zeros(n)
                for neighbor in unvisited:
                    probabilities[neighbor] = (pheromone[current_node, neighbor]**alpha) * ((1 / (distance_matrix[current_node, neighbor] + 1e-6))**beta)
                
                if np.sum(probabilities) == 0:
                    next_node = np.random.choice(list(unvisited))
                else:
                    probabilities = probabilities / np.sum(probabilities)
                    next_node = np.random.choice(list(range(n)), p=probabilities)
                
                if next_node in unvisited:
                    tour.append(next_node)
                    unvisited.remove(next_node)
                else:
                   next_node = np.random.choice(list(unvisited))

            tour.append(tour[0])
            tours.append(tour)
            
        # Update pheromone trails
        pheromone *= (1 - rho)
        for tour in tours:
            tour_length = 0
            for i in range(n):
                tour_length += distance_matrix[tour[i], tour[i+1]]
            
            for i in range(n):
                pheromone[tour[i], tour[i+1]] += Q / tour_length
                pheromone[tour[i+1], tour[i]] += Q / tour_length

        #Update heuristic_matrix
        best_tour = min(tours, key=lambda tour: sum(distance_matrix[tour[i], tour[i+1]] for i in range(n)))
        for i in range(n):
            heuristics_matrix[best_tour[i], best_tour[i+1]] += 1
            heuristics_matrix[best_tour[i+1], best_tour[i]] += 1

    heuristics_matrix /= 100
    return heuristics_matrix
