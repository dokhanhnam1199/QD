import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm combines shortest edge ranking with a penalty for edges connecting nodes that are already highly connected in terms of short distances.}"""
  n = distance_matrix.shape[0]
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

  # Rank edges by length
  edge_ranks = np.zeros_like(distance_matrix, dtype=float)
  edges = []
  for i in range(n):
    for j in range(i + 1, n):
      edges.append((i, j, distance_matrix[i, j]))
  
  edges.sort(key=lambda x: x[2])

  rank = 1
  for i, j, dist in edges:
    edge_ranks[i, j] = rank
    edge_ranks[j, i] = rank
    rank += 1
  
  # Node connectivity penalty
  node_connectivity = np.sum(1.0 / (distance_matrix + 1e-9), axis=0) # Sum of inverse distance to each node

  for i in range(n):
    for j in range(i + 1, n):
      heuristics_matrix[i, j] = edge_ranks[i, j] / (node_connectivity[i] + node_connectivity[j])
      heuristics_matrix[j, i] = heuristics_matrix[i, j]

  # Normalize the heuristics matrix
  max_heuristic = np.max(heuristics_matrix[np.isfinite(heuristics_matrix)])
  heuristics_matrix[np.isfinite(heuristics_matrix)] /= max_heuristic

  return heuristics_matrix
