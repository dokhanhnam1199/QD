import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm employs a modified ant colony optimization (ACO) approach, prioritizing exploration by adjusting pheromone influence and introducing a dynamic exploration factor to diversify tour construction and refine heuristic information.}
    """
    n = distance_matrix.shape[0]
    num_ants = 30
    pheromone = np.ones_like(distance_matrix)
    alpha = 0.5
    beta = 3
    rho = 0.7
    Q = 50
    exploration_factor = 0.1

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for iteration in range(100):
        tours = []
        for ant in range(num_ants):
            start_node = np.random.randint(n)
            tour = [start_node]
            unvisited = set(range(n))
            unvisited.remove(start_node)

            while unvisited:
                current_node = tour[-1]
                probabilities = np.zeros(n)
                for neighbor in unvisited:
                    probabilities[neighbor] = (pheromone[current_node, neighbor]**alpha) * ((1 / (distance_matrix[current_node, neighbor] + 1e-6))**beta)

                if np.sum(probabilities) == 0:
                    next_node = np.random.choice(list(unvisited))
                else:
                    probabilities = probabilities / np.sum(probabilities)
                    
                    # Introduce exploration
                    exploration_probs = np.array([exploration_factor / len(unvisited) if i in unvisited else 0 for i in range(n)])
                    probabilities = (1 - exploration_factor) * probabilities + exploration_probs
                    
                    next_node = np.random.choice(list(range(n)), p=probabilities)

                if next_node in unvisited:
                    tour.append(next_node)
                    unvisited.remove(next_node)
                else:
                    next_node = np.random.choice(list(unvisited))

            tour.append(tour[0])
            tours.append(tour)

        # Update pheromone trails
        pheromone *= (1 - rho)
        for tour in tours:
            tour_length = 0
            for i in range(n):
                tour_length += distance_matrix[tour[i], tour[i+1]]

            for i in range(n):
                pheromone[tour[i], tour[i+1]] += Q / tour_length
                pheromone[tour[i+1], tour[i]] += Q / tour_length
                
        #Update heuristic_matrix
        best_tour = min(tours, key=lambda tour: sum(distance_matrix[tour[i], tour[i+1]] for i in range(n)))
        for i in range(n):
            heuristics_matrix[best_tour[i], best_tour[i+1]] += 1
            heuristics_matrix[best_tour[i+1], best_tour[i]] += 1

    heuristics_matrix /= 100
    return heuristics_matrix
