import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm samples multiple near-optimal TSP solutions using a randomized greedy approach with regret-based node selection and edge-weight updating based on tour length and edge distance.}
    """
    n = distance_matrix.shape[0]
    num_samples = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # Initialize tour with a random starting node
        start_node = np.random.randint(n)
        tour = [start_node]
        unvisited = set(range(n))
        unvisited.remove(start_node)

        # Randomized greedy construction with regret-based node selection
        while unvisited:
            # Calculate regret values for each unvisited node
            regrets = {}
            for node in unvisited:
                distances_to_tour = [distance_matrix[tour[-1], node]]
                regrets[node] = min(distances_to_tour)

            # Select node with highest regret (normalized)
            if regrets:
                total_regret = sum(regrets.values())
                if total_regret > 0:
                    probabilities = {node: regret / total_regret for node, regret in regrets.items()}
                else:
                    probabilities = {node: 1 / len(regrets) for node in regrets}  # Uniform if total regret is zero
                
                selected_node = np.random.choice(list(probabilities.keys()), p=list(probabilities.values()))
            else:
                break

            # Add the selected node to the tour
            tour.append(selected_node)
            unvisited.remove(selected_node)

        # Calculate the total tour length
        tour_length = 0
        for i in range(n):
            tour_length += distance_matrix[tour[i], tour[(i + 1) % n]]

        # Update heuristics matrix based on tour length and edge distance
        for i in range(n):
            dist = distance_matrix[tour[i], tour[(i + 1) % n]]
            heuristics_matrix[tour[i], tour[(i + 1) % n]] += (1.0 / (dist + 1e-6)) * (1.0 / (tour_length + 1e-6))
            heuristics_matrix[tour[(i + 1) % n], tour[i]] += (1.0 / (dist + 1e-6)) * (1.0 / (tour_length + 1e-6))

    heuristics_matrix /= num_samples

    return heuristics_matrix
