import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines aspects of both KDE-based and greedy approaches by using KDE to guide a biased random walk, favoring edges with higher KDE values but allowing for exploration.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # KDE as in the first algorithm
    bandwidth = np.mean(distance_matrix) / 5
    kde_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(i + 1, n):
            distance = distance_matrix[i, j]
            kde_value = np.exp(-0.5 * (distance / bandwidth)**2)
            kde_matrix[i, j] = kde_value
            kde_matrix[j, i] = kde_value

    # Biased random walk
    num_walks = 100
    for _ in range(num_walks):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(start_node)
        tour = [start_node]

        while unvisited_nodes:
            # Probability proportional to KDE value, but add a small exploration factor.
            probabilities = np.array([kde_matrix[current_node, neighbor] + 0.001 for neighbor in unvisited_nodes]) #Small adjustment
            probabilities /= np.sum(probabilities)

            # Sample the next node based on the probabilities
            next_node = np.random.choice(list(unvisited_nodes), p=probabilities)

            tour.append(next_node)
            unvisited_nodes.remove(next_node)
            current_node = next_node
        
        # Complete the tour
        tour.append(start_node)

        # Update heuristics matrix
        for i in range(n):
            heuristics_matrix[tour[i], tour[i+1]] += 1
            heuristics_matrix[tour[i+1], tour[i]] += 1
    
    heuristics_matrix /= np.sum(heuristics_matrix)
    return heuristics_matrix
