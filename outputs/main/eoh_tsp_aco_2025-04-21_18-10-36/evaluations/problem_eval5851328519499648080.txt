import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm creates a heuristic matrix by combining the inverse distance with a measure of node centrality, favoring shorter edges connected to more central nodes.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate node centrality based on inverse distance to all other nodes
    node_centrality = np.zeros(n)
    for i in range(n):
        for j in range(n):
            if i != j and distance_matrix[i, j] > 0:
                node_centrality[i] += 1.0 / distance_matrix[i, j]

    # Combine inverse distance with node centrality
    for i in range(n):
        for j in range(i + 1, n):
            distance = distance_matrix[i, j]
            if distance > 0:
                heuristics_matrix[i, j] = (1.0 / distance) * (node_centrality[i] + node_centrality[j])
                heuristics_matrix[j, i] = heuristics_matrix[i, j]
            else:
                heuristics_matrix[i, j] = 0
                heuristics_matrix[j, i] = 0

    # Normalize the heuristics matrix to [0, 1]
    max_heuristic = np.max(heuristics_matrix)
    if max_heuristic > 0:
        heuristics_matrix /= max_heuristic

    return heuristics_matrix
