import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines distance-based probabilities with a local search-inspired perturbation to enhance exploration and refine promising edge selections.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    # Initial distance-based heuristic
    for i in range(n):
        for j in range(i + 1, n):
            distance = distance_matrix[i, j]
            if distance > 0:
                heuristics_matrix[i, j] = 1.0 / distance
                heuristics_matrix[j, i] = heuristics_matrix[i, j]
            else:
                heuristics_matrix[i, j] = np.inf
                heuristics_matrix[j, i] = np.inf

    # Normalize the heuristic matrix
    max_heuristic = np.max(heuristics_matrix[np.isfinite(heuristics_matrix)])
    heuristics_matrix[np.isfinite(heuristics_matrix)] /= max_heuristic

    # Perturb the heuristic matrix based on local neighborhood (inspired by local search)
    perturbation_factor = 0.1
    for i in range(n):
        for j in range(n):
            if i != j:
                # Examine neighbors of i and j
                neighbor_heuristics = []
                for k in range(n):
                    if k != i and k != j:
                        neighbor_heuristics.append(heuristics_matrix[i, k] + heuristics_matrix[j, k])
                
                if neighbor_heuristics:
                    avg_neighbor_heuristic = np.mean(neighbor_heuristics)
                    # Adjust heuristic value based on neighbors
                    heuristics_matrix[i, j] += perturbation_factor * (heuristics_matrix[i, j] - avg_neighbor_heuristic)
                    heuristics_matrix[i, j] = np.clip(heuristics_matrix[i, j], 0, 1)  # Clip to [0, 1]

    return heuristics_matrix
