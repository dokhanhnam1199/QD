[
     {
          "algorithm": "This algorithm samples multiple near-optimal TSP solutions using a nearest neighbor heuristic with stochastic restarts and edge perturbation, then averages the edge usage across these samples to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple near-optimal TSP solutions using a nearest neighbor heuristic with stochastic restarts and edge perturbation, then averages the edge usage across these samples to create a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited = set(range(n))\n        unvisited.remove(current_node)\n        tour = [current_node]\n        total_distance = 0\n\n        while unvisited:\n            nearest_neighbor = None\n            min_distance = float('inf')\n\n            #Perturb the distances to introduce stochasticity\n            perturbed_distances = distance_matrix[current_node, :].copy() + np.random.normal(0, np.std(distance_matrix) / 10, size=n)\n            perturbed_distances[current_node] = float('inf') #Ensure not to revisit current node\n            \n            for neighbor in unvisited:\n                if perturbed_distances[neighbor] < min_distance:\n                    min_distance = perturbed_distances[neighbor]\n                    nearest_neighbor = neighbor\n\n            tour.append(nearest_neighbor)\n            total_distance += distance_matrix[current_node, nearest_neighbor]\n            current_node = nearest_neighbor\n            unvisited.remove(current_node)\n\n        total_distance += distance_matrix[current_node, start_node]\n        tour.append(start_node) # Complete the cycle\n\n        # Update heuristics matrix\n        for i in range(n):\n            heuristics_matrix[tour[i], tour[(i + 1) % n]] += 1\n            heuristics_matrix[tour[(i + 1) % n], tour[i]] += 1 #Ensure symmetry\n\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 5.98524,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples random tours, calculates edge frequencies, and combines this with inverse distance to provide edge selection heuristics.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm samples random tours, calculates edge frequencies, and combines this with inverse distance to provide edge selection heuristics.}\"\"\"\n  n = distance_matrix.shape[0]\n  num_samples = 1000\n  edge_counts = np.zeros_like(distance_matrix)\n\n  for _ in range(num_samples):\n    permutation = np.random.permutation(n)\n    for i in range(n):\n      u = permutation[i]\n      v = permutation[(i + 1) % n]\n      edge_counts[u, v] += 1\n      edge_counts[v, u] += 1\n\n  edge_probabilities = edge_counts / num_samples\n\n  heuristics_matrix = edge_probabilities / (distance_matrix + 1e-9)\n  return heuristics_matrix",
          "objective": 6.80714,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple near-greedy solutions to the TSP, and averages the edge usage across these solutions to produce a heuristic matrix favoring frequently used edges.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple near-greedy solutions to the TSP, and averages the edge usage across these solutions to produce a heuristic matrix favoring frequently used edges.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n\n    for _ in range(num_samples):\n        current_node = np.random.randint(n)\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        path = [current_node]\n\n        while unvisited_nodes:\n            nearest_neighbor = None\n            min_distance = float('inf')\n            \n            # Limit the search to a subset of nodes to avoid truly greedy solutions\n            candidate_nodes = np.random.choice(list(unvisited_nodes), size=min(5, len(unvisited_nodes)), replace=False)\n\n            for neighbor in candidate_nodes:\n                distance = distance_matrix[current_node, neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            \n            path.append(nearest_neighbor)\n            unvisited_nodes.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n\n        path.append(path[0])  # Return to starting node\n\n        # Update heuristics matrix based on edge usage in this path\n        for i in range(n):\n            node1 = path[i]\n            node2 = path[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 7.57307,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple TSP solutions using a nearest neighbor heuristic with randomized starting nodes and edge selection probabilities biased towards shorter distances, then aggregates the edge frequencies across these samples to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple TSP solutions using a nearest neighbor heuristic with randomized starting nodes and edge selection probabilities biased towards shorter distances, then aggregates the edge frequencies across these samples to create a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(start_node)\n        path = [start_node]\n\n        while unvisited_nodes:\n            # Probabilistically choose the next node based on distance\n            probabilities = []\n            candidates = list(unvisited_nodes)\n            for neighbor in candidates:\n                probabilities.append(1 / distance_matrix[current_node, neighbor])\n            probabilities = np.array(probabilities)\n            probabilities /= np.sum(probabilities)\n            \n            next_node = np.random.choice(candidates, p=probabilities)\n\n            path.append(next_node)\n            unvisited_nodes.remove(next_node)\n            current_node = next_node\n\n        path.append(start_node)  # Return to the starting node\n\n        # Update heuristics matrix: increment counts for edges in the path\n        for i in range(n):\n            node1 = path[i]\n            node2 = path[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples  # Normalize to get frequencies\n\n    return heuristics_matrix",
          "objective": 7.9836,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples many random tours, and then scores each edge by how often it appears in the shortest sampled tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples many random tours, and then scores each edge by how often it appears in the shortest sampled tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    sampled_tour_lengths = np.zeros(num_samples)\n    sampled_tours = np.zeros((num_samples, n), dtype=int)\n\n    for i in range(num_samples):\n        tour = np.random.permutation(n)\n        sampled_tours[i, :] = tour\n        tour_length = 0\n        for j in range(n - 1):\n            tour_length += distance_matrix[tour[j], tour[j+1]]\n        tour_length += distance_matrix[tour[n-1], tour[0]]\n        sampled_tour_lengths[i] = tour_length\n\n    # Find the indices of the shortest tours\n    num_best = int(num_samples * 0.1) # Consider the top 10% as \"best\"\n    best_tour_indices = np.argsort(sampled_tour_lengths)[:num_best]\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Score edges based on their frequency in the best tours\n    for i in best_tour_indices:\n        tour = sampled_tours[i, :]\n        for j in range(n - 1):\n            heuristics_matrix[tour[j], tour[j+1]] += 1\n            heuristics_matrix[tour[j+1], tour[j]] += 1  # Ensure symmetry\n        heuristics_matrix[tour[n-1], tour[0]] += 1\n        heuristics_matrix[tour[0], tour[n-1]] += 1\n\n    # Normalize to get probabilities/indicators\n    heuristics_matrix = heuristics_matrix / num_best\n    \n    return heuristics_matrix",
          "objective": 13.7726,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples a large number of random tours, selects the best tours based on length, and then averages the frequency with which each edge appears in these best tours to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples a large number of random tours, selects the best tours based on length, and then averages the frequency with which each edge appears in these best tours to create a heuristic matrix.}\"\"\"\n    num_nodes = distance_matrix.shape[0]\n    num_samples = 1000  # Number of random tours to generate\n    num_best = 100  # Number of best tours to keep\n\n    all_tours = []\n    all_tour_lengths = []\n\n    for _ in range(num_samples):\n        tour = np.random.permutation(num_nodes)\n        tour_length = 0\n        for i in range(num_nodes - 1):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n        tour_length += distance_matrix[tour[-1], tour[0]]  # Return to starting node\n\n        all_tours.append(tour)\n        all_tour_lengths.append(tour_length)\n\n    # Select the best tours\n    sorted_indices = np.argsort(all_tour_lengths)\n    best_tours = [all_tours[i] for i in sorted_indices[:num_best]]\n\n    # Create heuristic matrix\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    for tour in best_tours:\n        for i in range(num_nodes - 1):\n            heuristics_matrix[tour[i], tour[i+1]] += 1\n            heuristics_matrix[tour[i+1], tour[i]] += 1 #Symmetric Matrix\n        heuristics_matrix[tour[-1], tour[0]] += 1\n        heuristics_matrix[tour[0], tour[-1]] += 1  #Symmetric Matrix\n\n    heuristics_matrix /= num_best\n    \n    return heuristics_matrix",
          "objective": 14.15358,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples random tours, and updates a heuristic matrix based on the frequency with which each edge appears in the sampled tours that fall within a percentile of shortest tour lengths.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples random tours, and updates a heuristic matrix based on the frequency with which each edge appears in the sampled tours that fall within a percentile of shortest tour lengths.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    sampled_tour_lengths = np.zeros(num_samples)\n    sampled_tours = np.zeros((num_samples, n), dtype=int)\n    \n    for i in range(num_samples):\n        tour = np.random.permutation(n)\n        sampled_tours[i, :] = tour\n        tour_length = 0\n        for j in range(n - 1):\n            tour_length += distance_matrix[tour[j], tour[j+1]]\n        tour_length += distance_matrix[tour[-1], tour[0]]\n        sampled_tour_lengths[i] = tour_length\n\n    percentile = 25\n    threshold_length = np.percentile(sampled_tour_lengths, percentile)\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(num_samples):\n        if sampled_tour_lengths[i] <= threshold_length:\n            tour = sampled_tours[i, :]\n            for j in range(n - 1):\n                heuristics_matrix[tour[j], tour[j+1]] += 1\n                heuristics_matrix[tour[j+1], tour[j]] += 1\n            heuristics_matrix[tour[-1], tour[0]] += 1\n            heuristics_matrix[tour[0], tour[-1]] += 1\n\n    return heuristics_matrix",
          "objective": 14.34129,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples many random tours, and then populates a matrix representing the frequency with which each edge appears in the shortest tours from the sample.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples many random tours, and then populates a matrix representing the frequency with which each edge appears in the shortest tours from the sample.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        permutation = np.random.permutation(n)\n        tour_length = 0\n        for i in range(n - 1):\n            tour_length += distance_matrix[permutation[i], permutation[i+1]]\n        tour_length += distance_matrix[permutation[-1], permutation[0]]\n\n        # Store the best tour found so far (for comparison)\n        if 'best_tour_length' not in locals() or tour_length < best_tour_length:\n            best_tour_length = tour_length\n            best_permutation = permutation\n\n    # Iterate again through the best permutations and update the heuristics_matrix\n    for _ in range(num_samples):\n        permutation = np.random.permutation(n)\n        tour_length = 0\n        for i in range(n - 1):\n            tour_length += distance_matrix[permutation[i], permutation[i+1]]\n        tour_length += distance_matrix[permutation[-1], permutation[0]]\n\n        if tour_length <= best_tour_length * 1.1: # Consider only close to optimal tours.\n            for i in range(n - 1):\n                heuristics_matrix[permutation[i], permutation[i+1]] += 1\n                heuristics_matrix[permutation[i+1], permutation[i]] += 1\n            heuristics_matrix[permutation[-1], permutation[0]] += 1\n            heuristics_matrix[permutation[0], permutation[-1]] += 1\n\n\n    # Normalize the matrix so that the entries are probabilities\n    heuristics_matrix /= np.sum(heuristics_matrix)\n    return heuristics_matrix",
          "objective": 14.52003,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random tours, evaluates their lengths, and assigns higher probabilities to edges that appear in shorter tours, ultimately creating a heuristics matrix representing the likelihood of each edge being part of an optimal solution.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm generates multiple random tours, evaluates their lengths, and assigns higher probabilities to edges that appear in shorter tours, ultimately creating a heuristics matrix representing the likelihood of each edge being part of an optimal solution.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        tour_length = 0\n        for i in range(n - 1):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n        tour_length += distance_matrix[tour[n-1], tour[0]]\n\n        # Assign higher probabilities to edges in shorter tours\n        if tour_length > 0:  # Avoid division by zero\n            weight = 1.0 / tour_length\n        else:\n            weight = 1.0\n        for i in range(n - 1):\n            heuristics_matrix[tour[i], tour[i+1]] += weight\n            heuristics_matrix[tour[i+1], tour[i]] += weight\n        heuristics_matrix[tour[n-1], tour[0]] += weight\n        heuristics_matrix[tour[0], tour[n-1]] += weight\n\n    # Normalize the heuristics matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 19.64324,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively samples random tours, evaluates their lengths, and updates a heuristic matrix that favors edges frequently present in short tours, normalized by their length.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm iteratively samples random tours, evaluates their lengths, and updates a heuristic matrix that favors edges frequently present in short tours, normalized by their length.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_iterations = 1000  # Number of tour samples\n\n    for _ in range(num_iterations):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])  # Return to starting node\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i + 1]]\n\n        # Update heuristic matrix based on tour quality\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i + 1]\n            heuristics_matrix[node1, node2] += (1 / tour_length)\n            heuristics_matrix[node2, node1] += (1 / tour_length) # Ensure symmetry\n\n    return heuristics_matrix",
          "objective": 20.12492,
          "other_inf": null
     }
]