[
     {
          "algorithm": "This algorithm prioritizes edges that appear in shorter tours found by a simplified local search, weighting edges inversely proportional to the tour length and directly proportional to their frequency.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm prioritizes edges that appear in shorter tours found by a simplified local search, weighting edges inversely proportional to the tour length and directly proportional to their frequency.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    edge_weights = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 50\n    neighborhood_size = 10\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        nodes = list(range(n))\n        np.random.shuffle(nodes)\n        tour = nodes + [nodes[0]]\n\n        # Simplified 2-opt local search\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for j in range(i + 2, n + 1):\n                    if j - i == 1: continue # ensures edges are distinct\n                    current_distance = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[j-1], tour[j]]\n                    new_distance = distance_matrix[tour[i-1], tour[j-1]] + distance_matrix[tour[i], tour[j]]\n                    if new_distance < current_distance:\n                        tour[i:j] = reversed(tour[i:j])\n                        improved = True\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n\n        # Update edge weights based on tour length and edge frequency\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            edge_weights[node1, node2] += 1 / tour_length\n            edge_weights[node2, node1] += 1 / tour_length\n\n    # Normalize edge weights to create the heuristics matrix\n    max_weight = np.max(edge_weights)\n    if max_weight > 0:\n        heuristics_matrix = edge_weights / max_weight\n    else:\n        heuristics_matrix = np.ones_like(distance_matrix) / n # Avoid division by zero\n\n    return heuristics_matrix",
          "objective": 5.75163,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm adaptively adjusts edge weights based on the frequency of their appearance in short paths found by a simplified local search, emphasizing edges that consistently contribute to good solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm adaptively adjusts edge weights based on the frequency of their appearance in short paths found by a simplified local search, emphasizing edges that consistently contribute to good solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    edge_counts = np.zeros_like(distance_matrix, dtype=int)\n    num_samples = 50\n    neighborhood_size = 10\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        nodes = list(range(n))\n        np.random.shuffle(nodes)\n        tour = nodes + [nodes[0]]\n\n        # Simplified 2-opt local search\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n - 1):\n                for j in range(i + 2, n + 1):\n                    if j - i == 1: continue # ensures edges are distinct\n                    current_distance = distance_matrix[tour[i-1], tour[i]] + distance_matrix[tour[j-1], tour[j]]\n                    new_distance = distance_matrix[tour[i-1], tour[j-1]] + distance_matrix[tour[i], tour[j]]\n                    if new_distance < current_distance:\n                        tour[i:j] = reversed(tour[i:j])\n                        improved = True\n\n        # Update edge counts based on the improved tour\n        tour_length = 0\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            edge_counts[node1, node2] += 1\n            edge_counts[node2, node1] += 1\n            tour_length += distance_matrix[node1, node2]\n\n    # Normalize edge counts to create the heuristics matrix\n    max_count = np.max(edge_counts)\n    if max_count > 0:\n        heuristics_matrix = edge_counts / max_count\n    else:\n        heuristics_matrix = np.ones_like(distance_matrix) / n # Avoid division by zero\n\n    return heuristics_matrix",
          "objective": 5.77473,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a simplified ant colony optimization approach with adjusted parameters to emphasize distance over pheromone and a different pheromone update rule based on rank.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a simplified ant colony optimization approach with adjusted parameters to emphasize distance over pheromone and a different pheromone update rule based on rank.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix)\n    alpha = 0.5  # Pheromone influence (reduced)\n    beta = 3  # Distance influence (increased)\n    rho = 0.2  # Evaporation rate\n    Q = 10  # Pheromone deposit constant (reduced)\n    num_ants = n\n    num_iterations = 50 #Reduced iteration\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = ant % n\n            current_node = start_node\n            unvisited_nodes = set(range(n))\n            unvisited_nodes.remove(start_node)\n            path = [start_node]\n            path_length = 0\n\n            while unvisited_nodes:\n                probabilities = []\n                candidates = list(unvisited_nodes)\n                for neighbor in candidates:\n                    pheromone = pheromone_matrix[current_node, neighbor]\n                    distance = distance_matrix[current_node, neighbor]\n                    probabilities.append((pheromone**alpha) / (distance**beta))\n                probabilities = np.array(probabilities)\n                probabilities /= np.sum(probabilities)\n\n                next_node = np.random.choice(candidates, p=probabilities)\n\n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                unvisited_nodes.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            path_length += distance_matrix[current_node, start_node]\n            all_paths.append(path)\n            all_path_lengths.append(path_length)\n\n        # Rank-based pheromone update\n        ranked_paths = np.argsort(all_path_lengths)\n        pheromone_matrix *= (1 - rho)  # Evaporation\n\n        for rank in range(min(5, num_ants)):  # Top 5 ants deposit pheromone\n            best_path = all_paths[ranked_paths[rank]]\n            best_path_length = all_path_lengths[ranked_paths[rank]]\n            for i in range(n):\n                node1 = best_path[i]\n                node2 = best_path[i+1]\n                pheromone_matrix[node1, node2] += (Q / best_path_length) * (5 - rank)  # Higher rank = more pheromone\n                pheromone_matrix[node2, node1] += (Q / best_path_length) * (5 - rank)\n\n    # Aggregate pheromone information into the heuristics matrix\n    heuristics_matrix = pheromone_matrix\n    return heuristics_matrix",
          "objective": 5.80735,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple near-optimal TSP solutions using a greedy approach with stochastic node selection and path refinement, then averages the edge usage across these samples, weighting edges based on their distance in the averaging process.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple near-optimal TSP solutions using a greedy approach with stochastic node selection and path refinement, then averages the edge usage across these samples, weighting edges based on their distance in the averaging process.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Initialize tour with a random starting node\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n\n        # Greedy construction with stochastic node selection\n        while unvisited:\n            # Select a random subset of unvisited nodes to consider\n            subset_size = min(len(unvisited), 5)  # Limit subset size for efficiency\n            subset = np.random.choice(list(unvisited), size=subset_size, replace=False)\n\n            # Find the nearest neighbor within the subset\n            nearest_neighbor = None\n            min_distance = float('inf')\n            for neighbor in subset:\n                distance = distance_matrix[tour[-1], neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            # Add the nearest neighbor to the tour\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n\n        # Path refinement: 2-opt swap (optional, but improves quality)\n        for i in range(n):\n            for j in range(i + 2, n):\n                if distance_matrix[tour[i], tour[i + 1]] + distance_matrix[tour[j], tour[(j + 1) % n]] > \\\n                   distance_matrix[tour[i], tour[j]] + distance_matrix[tour[i + 1], tour[(j + 1) % n]]:\n                    tour[i + 1:j + 1] = reversed(tour[i + 1:j + 1])\n\n\n        # Update heuristics matrix\n        for i in range(n):\n            dist = distance_matrix[tour[i], tour[(i + 1) % n]]\n            heuristics_matrix[tour[i], tour[(i + 1) % n]] += 1.0 / (dist + 1e-6)\n            heuristics_matrix[tour[(i + 1) % n], tour[i]] += 1.0 / (dist + 1e-6)  # Ensure symmetry\n\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 5.83102,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple near-optimal TSP solutions using a greedy approach with stochastic node selection and path refinement, then averages the edge usage across these samples to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple near-optimal TSP solutions using a greedy approach with stochastic node selection and path refinement, then averages the edge usage across these samples to create a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Initialize tour with a random starting node\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n\n        # Greedy construction with stochastic node selection\n        while unvisited:\n            # Select a random subset of unvisited nodes to consider\n            subset_size = min(len(unvisited), 5)  # Limit subset size for efficiency\n            subset = np.random.choice(list(unvisited), size=subset_size, replace=False)\n\n            # Find the nearest neighbor within the subset\n            nearest_neighbor = None\n            min_distance = float('inf')\n            for neighbor in subset:\n                distance = distance_matrix[tour[-1], neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            # Add the nearest neighbor to the tour\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n\n        # Path refinement: 2-opt swap (optional, but improves quality)\n        for i in range(n):\n            for j in range(i + 2, n):\n                if distance_matrix[tour[i], tour[i + 1]] + distance_matrix[tour[j], tour[(j + 1) % n]] > \\\n                   distance_matrix[tour[i], tour[j]] + distance_matrix[tour[i + 1], tour[(j + 1) % n]]:\n                    tour[i + 1:j + 1] = reversed(tour[i + 1:j + 1])\n\n\n        # Update heuristics matrix\n        for i in range(n):\n            heuristics_matrix[tour[i], tour[(i + 1) % n]] += 1\n            heuristics_matrix[tour[(i + 1) % n], tour[i]] += 1  # Ensure symmetry\n\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 5.86102,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple near-optimal TSP solutions using a greedy approach with stochastic node selection and path refinement, then biases edge selection during the greedy construction based on edge lengths, favoring shorter edges.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple near-optimal TSP solutions using a greedy approach with stochastic node selection and path refinement, then biases edge selection during the greedy construction based on edge lengths, favoring shorter edges.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Initialize tour with a random starting node\n        start_node = np.random.randint(n)\n        tour = [start_node]\n        unvisited = set(range(n))\n        unvisited.remove(start_node)\n\n        # Greedy construction with stochastic node selection and biased edge selection\n        while unvisited:\n            # Select a random subset of unvisited nodes to consider\n            subset_size = min(len(unvisited), 5)  # Limit subset size for efficiency\n            subset = np.random.choice(list(unvisited), size=subset_size, replace=False)\n\n            # Bias the selection probability based on edge lengths\n            probabilities = np.zeros(len(subset))\n            for i, neighbor in enumerate(subset):\n                distance = distance_matrix[tour[-1], neighbor]\n                probabilities[i] = 1 / (distance + 1e-6)  # Avoid division by zero\n\n            probabilities /= np.sum(probabilities)  # Normalize to a probability distribution\n\n            # Select the next node based on the biased probabilities\n            nearest_neighbor = np.random.choice(subset, p=probabilities)\n\n\n            # Add the nearest neighbor to the tour\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n\n        # Path refinement: 2-opt swap (optional, but improves quality)\n        for i in range(n):\n            for j in range(i + 2, n):\n                if distance_matrix[tour[i], tour[i + 1]] + distance_matrix[tour[j], tour[(j + 1) % n]] > \\\n                   distance_matrix[tour[i], tour[j]] + distance_matrix[tour[i + 1], tour[(j + 1) % n]]:\n                    tour[i + 1:j + 1] = reversed(tour[i + 1:j + 1])\n\n\n        # Update heuristics matrix\n        for i in range(n):\n            heuristics_matrix[tour[i], tour[(i + 1) % n]] += 1\n            heuristics_matrix[tour[(i + 1) % n], tour[i]] += 1  # Ensure symmetry\n\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 5.88279,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by assigning higher probabilities to shorter distances based on an inverse power law, adjusted by a global scaling factor.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by assigning higher probabilities to shorter distances based on an inverse power law, adjusted by a global scaling factor.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Apply inverse power law to the distances\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = distance_matrix[i, j]\n            # Inverse power law with exponent 2\n            if distance > 0:\n              heuristics_matrix[i, j] = 1.0 / (distance**2)\n              heuristics_matrix[j, i] = heuristics_matrix[i, j]\n            else:\n              heuristics_matrix[i, j] = np.inf\n              heuristics_matrix[j, i] = np.inf\n\n    # Scale the heuristics matrix to [0, 1]\n    max_heuristic = np.max(heuristics_matrix[np.isfinite(heuristics_matrix)])\n    heuristics_matrix[np.isfinite(heuristics_matrix)] /= max_heuristic\n\n    return heuristics_matrix",
          "objective": 5.90229,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines greedy nearest neighbor path construction with pheromone updates based on path quality to build a heuristic matrix favoring edges in good solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm combines greedy nearest neighbor path construction with pheromone updates based on path quality to build a heuristic matrix favoring edges in good solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix)\n    alpha = 0.5  # Pheromone influence (reduced)\n    beta = 2.0  # Distance influence (increased)\n    rho = 0.3  # Evaporation rate (increased)\n    Q = 50  # Pheromone deposit constant (reduced)\n    num_ants = int(n * 0.75)  # Reduced number of ants\n    num_iterations = 50  # Reduced number of iterations\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = ant % n\n            current_node = start_node\n            unvisited_nodes = set(range(n))\n            unvisited_nodes.remove(start_node)\n            path = [start_node]\n            path_length = 0\n\n            while unvisited_nodes:\n                # Nearest Neighbor biased by Pheromones\n                probabilities = []\n                candidates = list(unvisited_nodes)\n                for neighbor in candidates:\n                    pheromone = pheromone_matrix[current_node, neighbor]\n                    distance = distance_matrix[current_node, neighbor]\n                    probabilities.append((pheromone**alpha) / (distance**beta))\n                probabilities = np.array(probabilities)\n                probabilities /= np.sum(probabilities)\n                next_node = np.random.choice(candidates, p=probabilities)\n                \n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                unvisited_nodes.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            path_length += distance_matrix[current_node, start_node]\n            all_paths.append(path)\n            all_path_lengths.append(path_length)\n\n        # Update pheromone trails based on path quality\n        pheromone_matrix *= (1 - rho)  # Evaporation\n\n        # Deposit pheromone on edges of all paths, weighted by path length\n        for path, path_length in zip(all_paths, all_path_lengths):\n            for i in range(n):\n                node1 = path[i]\n                node2 = path[i+1]\n                pheromone_matrix[node1, node2] += Q / path_length\n                pheromone_matrix[node2, node1] += Q / path_length\n\n    # Aggregate pheromone information into the heuristics matrix\n    heuristics_matrix = pheromone_matrix\n    return heuristics_matrix",
          "objective": 5.9044,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a simplified ant colony optimization approach with adjusted parameters to emphasize distance over pheromone influence in path construction and increase pheromone evaporation.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a simplified ant colony optimization approach with adjusted parameters to emphasize distance over pheromone influence in path construction and increase pheromone evaporation.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix)\n    alpha = 0.5  # Pheromone influence (reduced)\n    beta = 3  # Distance influence (increased)\n    rho = 0.5  # Evaporation rate (increased)\n    Q = 100  # Pheromone deposit constant\n    num_ants = n\n    num_iterations = 50 #Reduced Iterations\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = ant % n\n            current_node = start_node\n            unvisited_nodes = set(range(n))\n            unvisited_nodes.remove(start_node)\n            path = [start_node]\n            path_length = 0\n\n            while unvisited_nodes:\n                probabilities = []\n                candidates = list(unvisited_nodes)\n                for neighbor in candidates:\n                    pheromone = pheromone_matrix[current_node, neighbor]\n                    distance = distance_matrix[current_node, neighbor]\n                    probabilities.append((pheromone**alpha) / (distance**beta))\n                probabilities = np.array(probabilities)\n                probabilities /= np.sum(probabilities)\n\n                next_node = np.random.choice(candidates, p=probabilities)\n\n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                unvisited_nodes.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            path_length += distance_matrix[current_node, start_node]\n            all_paths.append(path)\n            all_path_lengths.append(path_length)\n\n        # Update pheromone trails\n        pheromone_matrix *= (1 - rho)  # Evaporation\n\n        best_path = all_paths[np.argmin(all_path_lengths)]\n        best_path_length = min(all_path_lengths)\n\n        for i in range(n):\n            node1 = best_path[i]\n            node2 = best_path[i+1]\n            pheromone_matrix[node1, node2] += Q / best_path_length\n            pheromone_matrix[node2, node1] += Q / best_path_length\n\n    # Aggregate pheromone information into the heuristics matrix\n    heuristics_matrix = pheromone_matrix\n    return heuristics_matrix",
          "objective": 5.91972,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm combines greedy nearest neighbor path construction with pheromone updates based on path quality to build a heuristic matrix favoring edges in good solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm combines greedy nearest neighbor path construction with pheromone updates based on path quality to build a heuristic matrix favoring edges in good solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix)\n    alpha = 0.8  # Pheromone influence\n    beta = 1.2  # Distance influence\n    rho = 0.2  # Evaporation rate\n    Q = 100  # Pheromone deposit constant\n    num_ants = n\n    num_iterations = 80\n\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for iteration in range(num_iterations):\n        all_paths = []\n        all_path_lengths = []\n\n        for ant in range(num_ants):\n            start_node = ant % n\n            current_node = start_node\n            unvisited_nodes = set(range(n))\n            unvisited_nodes.remove(start_node)\n            path = [start_node]\n            path_length = 0\n\n            while unvisited_nodes:\n                # Nearest Neighbor biased by Pheromones\n                probabilities = []\n                candidates = list(unvisited_nodes)\n                for neighbor in candidates:\n                    pheromone = pheromone_matrix[current_node, neighbor]\n                    distance = distance_matrix[current_node, neighbor]\n                    probabilities.append((pheromone**alpha) / (distance**beta))\n                probabilities = np.array(probabilities)\n                probabilities /= np.sum(probabilities)\n                next_node = np.random.choice(candidates, p=probabilities)\n                \n                path.append(next_node)\n                path_length += distance_matrix[current_node, next_node]\n                unvisited_nodes.remove(next_node)\n                current_node = next_node\n\n            path.append(start_node)\n            path_length += distance_matrix[current_node, start_node]\n            all_paths.append(path)\n            all_path_lengths.append(path_length)\n\n        # Update pheromone trails based on path quality\n        pheromone_matrix *= (1 - rho)  # Evaporation\n\n        # Deposit pheromone on edges of all paths, weighted by path length\n        for path, path_length in zip(all_paths, all_path_lengths):\n            for i in range(n):\n                node1 = path[i]\n                node2 = path[i+1]\n                pheromone_matrix[node1, node2] += Q / path_length\n                pheromone_matrix[node2, node1] += Q / path_length\n\n    # Aggregate pheromone information into the heuristics matrix\n    heuristics_matrix = pheromone_matrix\n    return heuristics_matrix",
          "objective": 5.93414,
          "other_inf": null
     }
]