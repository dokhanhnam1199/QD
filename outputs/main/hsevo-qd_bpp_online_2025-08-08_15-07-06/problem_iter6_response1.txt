```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    This heuristic aims to improve upon priority_v1 by introducing a multi-criteria approach
    and a more nuanced scoring for bins that are not perfectly fitting but are still viable.

    The strategy is to prioritize bins based on two main factors:
    1. How well the item fits the remaining capacity (tightest fit).
    2. How "full" the bin is after the item is placed (to encourage fuller bins).

    Scoring logic:
    - For bins that can fit the item:
        - Calculate the "tightness" of the fit: `item - bins_remain_cap`. A smaller (less negative) value is better,
          meaning the remaining capacity is closer to the item size.
        - Calculate a "fullness score" which is a measure of how much capacity is left *after* placing the item.
          We want to penalize leaving too much space, so we can use `-(bins_remain_cap - item)`.
          A higher value here means less space is left, which is good.
        - Combine these two scores. A simple weighted sum can be used.
          Let `tightness_score = item - bins_remain_cap`.
          Let `fullness_score = -(bins_remain_cap - item)`.
          The combined score could be `w1 * tightness_score + w2 * fullness_score`.
          Here, we want to prioritize bins where `bins_remain_cap - item` is minimized (closest to 0).
          This means `item - bins_remain_cap` is maximized (closest to 0 from the negative side).
          Let's consider `bins_remain_cap - item`. We want to minimize this for fitting bins.
          To convert minimization to maximization for a priority score, we can use `- (bins_remain_cap - item)`.
          So, `priority_component_1 = bins_remain_cap - item`. We want to maximize this.
          If `bins_remain_cap = 1.0` and `item = 0.5`, `priority_component_1 = 0.5`.
          If `bins_remain_cap = 0.6` and `item = 0.5`, `priority_component_1 = 0.1`.
          This `priority_component_1` directly represents how much *extra* space is left. We want to minimize this extra space.
          So, to maximize, we use `-(bins_remain_cap - item)`.

        - Let's reconsider the goal: Find a bin where `bins_remain_cap >= item`.
          We want the `bins_remain_cap` to be as close to `item` as possible.
          This means minimizing `bins_remain_cap - item`.
          So, a good score component is `-(bins_remain_cap - item)`.

        - Let's also consider the "wasted space" after placing the item. This is `bins_remain_cap - item`.
          We want to minimize this. So, `-(bins_remain_cap - item)` is a good candidate.

        - Consider the *absolute* difference: `abs(bins_remain_cap - item)`. We want to minimize this.
          So, `-abs(bins_remain_cap - item)` is a good score.

        - What if we want to prioritize bins that are generally fuller, even if they aren't the *tightest* fit?
          A bin with `bins_remain_cap = 0.9` and `item = 0.1` leaves `0.8` space.
          A bin with `bins_remain_cap = 0.5` and `item = 0.4` leaves `0.1` space.
          The second is a tighter fit and leaves less wasted space.

        - Let's introduce a parameter `alpha` to balance two criteria:
            1. Minimizing the "slack" or remaining space: `bins_remain_cap - item`. We want to maximize `-(bins_remain_cap - item)`.
            2. Maximizing the overall remaining capacity of the bin *before* packing, as a secondary factor to encourage using generally fuller bins. This is `bins_remain_cap`.

        - So, for bins that fit:
            Score = `alpha * (bins_remain_cap - item) + (1 - alpha) * bins_remain_cap`
            To maximize this score, we want `bins_remain_cap - item` to be small and `bins_remain_cap` to be large.
            Let's try a different combination: Prioritize bins that leave the *least* amount of space.
            This means minimizing `bins_remain_cap - item`.
            So, a primary score component is `-(bins_remain_cap - item)`.

            A secondary consideration could be the overall fullness of the bin.
            Perhaps we can use the remaining capacity `bins_remain_cap` itself as a secondary score.
            If `bins_remain_cap = 0.9` and `item = 0.5`, the difference is `0.4`.
            If `bins_remain_cap = 0.55` and `item = 0.5`, the difference is `0.05`.
            The second case is a tighter fit. `-(0.4)` vs `-(0.05)`. The second is higher.

            What if we want to combine the tightness with a penalty for being *too* empty?
            Consider `bins_remain_cap >= item`.
            Score = `-(bins_remain_cap - item)` for tightness.
            We could add a small bonus for `bins_remain_cap` itself, weighted.
            Score = `-(bins_remain_cap - item) + beta * bins_remain_cap`
            Let `beta = 0.1`.
            Bin 1: `bins_remain_cap = 0.9`, `item = 0.5`. Score = `-(0.4) + 0.1 * 0.9 = -0.4 + 0.09 = -0.31`
            Bin 2: `bins_remain_cap = 0.55`, `item = 0.5`. Score = `-(0.05) + 0.1 * 0.55 = -0.05 + 0.055 = 0.005`
            Bin 2 has higher priority.

            Let's try maximizing `bins_remain_cap - item` for fitting bins. This represents the smallest positive slack.
            To turn it into a higher-is-better score, we can use `-(bins_remain_cap - item)`.
            For bins that don't fit, we assign a very low score.

            Let's refine the scoring:
            For bins where `bins_remain_cap >= item`:
            We want to prioritize bins that minimize `bins_remain_cap - item`.
            This is equivalent to maximizing `item - bins_remain_cap`.
            This is the same as `priority_v1`.

            Let's think about "granular scoring" and "multi-criteria fusion".
            We can create two components:
            1. Tightness: `score_tight = -(bins_remain_cap - item)` for fitting bins, `-inf` otherwise.
               This favors bins that are almost full.
            2. Fillness: `score_fill = bins_remain_cap` for fitting bins, `-inf` otherwise.
               This favors bins that have more capacity in general (potentially leading to fewer bins overall if items are small).

            We can fuse these: `priority = w_tight * score_tight + w_fill * score_fill`.
            Let's choose weights. If we want to primarily prioritize tightness, `w_tight` should be larger.
            Let `w_tight = 1.0` and `w_fill = 0.5`.

            So, for fitting bins:
            `score = -(bins_remain_cap - item) + 0.5 * bins_remain_cap`
            `score = -bins_remain_cap + item + 0.5 * bins_remain_cap`
            `score = item - 0.5 * bins_remain_cap`

            Example:
            `item = 0.5`
            Bin A: `bins_remain_cap = 0.9`. Fits.
                `score_tight = -(0.9 - 0.5) = -0.4`
                `score_fill = 0.9`
                `score_A = -0.4 + 0.5 * 0.9 = -0.4 + 0.45 = 0.05`
            Bin B: `bins_remain_cap = 0.55`. Fits.
                `score_tight = -(0.55 - 0.5) = -0.05`
                `score_fill = 0.55`
                `score_B = -0.05 + 0.5 * 0.55 = -0.05 + 0.275 = 0.225`
            Bin C: `bins_remain_cap = 0.5`. Fits.
                `score_tight = -(0.5 - 0.5) = 0.0`
                `score_fill = 0.5`
                `score_C = 0.0 + 0.5 * 0.5 = 0.25`

            In this example, Bin C has the highest priority, followed by Bin B, then Bin A.
            This prioritizes the tightest fit, but also gives a boost to bins that have more capacity overall if the tightness is similar.

            Let's adjust the weights. If we want to more strongly favor overall fullness, increase `w_fill`.
            Let `w_tight = 1.0`, `w_fill = 1.0`.
            `score = item - bins_remain_cap`
            This is exactly `priority_v1`.

            The goal is to be *better* than `priority_v1`.
            `priority_v1` maximizes `item - bins_remain_cap`. This strongly favors the tightest fit.

            Let's reconsider the advice: "finely-grained, multi-dimensional scoring mechanisms that integrate diverse criteria (e.g., fit, fullness, strategic placement) through weighted sums or more complex fusion methods."

            What if we use a non-linear function for tightness? Or a different way to combine?
            A common strategy is "Best Fit Decreasing" (BFD), which sorts items first. Here it's online.
            For online, "First Fit" (FF), "Best Fit" (BF), "Worst Fit" (WF), "Most Full" are common.
            BF priority is `-(bins_remain_cap - item)`. This is what `priority_v1` does.

            Let's try to explicitly penalize bins that are *too large* but still fit.
            Suppose `item = 0.3`.
            Bin X: `bins_remain_cap = 0.3`. `score_v1 = 0.3 - 0.3 = 0`.
            Bin Y: `bins_remain_cap = 0.8`. `score_v1 = 0.3 - 0.8 = -0.5`.
            `priority_v1` would pick Bin X.

            What if we also want to consider the *current* fullness of the bin, not just how much space is left *after* packing?
            Consider the ratio `item / bins_remain_cap`. High ratio means it's a good fit for a nearly full bin.
            But this can lead to division by zero or very small numbers.

            Let's try a score that is sensitive to both:
            1. The gap: `gap = bins_remain_cap - item`. We want to minimize this gap.
            2. The current bin fullness: `current_fill_ratio = (BIN_CAPACITY - bins_remain_cap) / BIN_CAPACITY`. We want this to be high.

            If we assume `BIN_CAPACITY` is a constant, let's say `C`.
            We want to minimize `bins_remain_cap - item`.
            We want to maximize `(C - bins_remain_cap) / C`. This is equivalent to minimizing `bins_remain_cap`.

            So, for fitting bins:
            We want to prioritize bins with small `bins_remain_cap - item`.
            And among those, prioritize bins with smaller `bins_remain_cap`.

            This suggests a lexicographical ordering or a weighted sum.
            Let's use a weighted sum:
            `score = w1 * -(bins_remain_cap - item) + w2 * -(bins_remain_cap)`
            Where `w1 > 0` and `w2 > 0`.
            `score = w1 * (item - bins_remain_cap) - w2 * bins_remain_cap`

            If `w1=1`, `w2=1`: `score = item - bins_remain_cap - bins_remain_cap = item - 2 * bins_remain_cap`.
                `item = 0.5`
                Bin X: `bins_remain_cap = 0.5`. `score = 0.5 - 2 * 0.5 = -0.5`.
                Bin Y: `bins_remain_cap = 0.8`. `score = 0.5 - 2 * 0.8 = 0.5 - 1.6 = -1.1`.
                Bin Z: `bins_remain_cap = 0.55`. `score = 0.5 - 2 * 0.55 = 0.5 - 1.1 = -0.6`.
                Here, Bin X (tightest fit) is still best.

            Let's try `w1=1`, `w2=0.5`: `score = item - bins_remain_cap - 0.5 * bins_remain_cap = item - 1.5 * bins_remain_cap`.
                `item = 0.5`
                Bin X: `bins_remain_cap = 0.5`. `score = 0.5 - 1.5 * 0.5 = 0.5 - 0.75 = -0.25`.
                Bin Y: `bins_remain_cap = 0.8`. `score = 0.5 - 1.5 * 0.8 = 0.5 - 1.2 = -0.7`.
                Bin Z: `bins_remain_cap = 0.55`. `score = 0.5 - 1.5 * 0.55 = 0.5 - 0.825 = -0.325`.
                Bin X (tightest fit) is still best.

            The current heuristic `priority_v1` already focuses on the tightest fit.
            To be *better*, we might need to consider scenarios where the tightest fit is not optimal, or introduce a more robust scoring.

            Let's introduce a factor that penalizes leaving *too much* excess space, but less severely than `priority_v1` does implicitly.

            Consider the "waste" `bins_remain_cap - item`.
            `priority_v1` is `- (bins_remain_cap - item)`.
            This gives a score of 0 for a perfect fit, and increasingly negative scores as the excess space increases.

            What if we use a score that is higher for a perfect fit, and then drops, but not as steeply?
            For example, a function like `max(0, item - bins_remain_cap)` is what we want to maximize.
            This is `priority_v1`.

            Let's try to make the score more "granular".
            Instead of just penalizing negative differences, let's reward positive differences (slack) up to a certain point.

            For bins that can fit (`bins_remain_cap >= item`):
            Primary goal: Minimize `bins_remain_cap - item`.
            Secondary goal: If two bins have similar small gaps, pick the one that is fuller (smaller `bins_remain_cap`).

            Let's define a score function for fitting bins:
            `score = -(bins_remain_cap - item)**2 + lambda * bins_remain_cap`
            The `-(bins_remain_cap - item)**2` term penalizes larger gaps quadratically.
            The `lambda * bins_remain_cap` term favors fuller bins.

            Let `lambda = 0.1`.
            `item = 0.5`
            Bin X: `bins_remain_cap = 0.5`. Gap = 0. Score = `-0**2 + 0.1 * 0.5 = 0.05`.
            Bin Y: `bins_remain_cap = 0.55`. Gap = 0.05. Score = `-(0.05)**2 + 0.1 * 0.55 = -0.0025 + 0.055 = 0.0525`.
            Bin Z: `bins_remain_cap = 0.8`. Gap = 0.3. Score = `-(0.3)**2 + 0.1 * 0.8 = -0.09 + 0.08 = -0.01`.

            Here, Bin Y is preferred, then Bin X, then Bin Z.
            This might be an improvement over `priority_v1` which would strongly prefer X over Y and Z.
            This new heuristic prioritizes a small positive gap (like Bin Y) slightly over a perfect fit (Bin X),
            while still penalizing larger gaps (Bin Z).
            The parameter `lambda` controls how much we care about overall fullness.

            Let's refine the functional form. We want to maximize the score.
            The `-(bins_remain_cap - item)**2` term aims to keep `bins_remain_cap - item` close to zero.
            To maximize this term, we want `bins_remain_cap - item` to be as close to 0 as possible.
            The `lambda * bins_remain_cap` term favors smaller `bins_remain_cap`.

            So, the combined score: `-(bins_remain_cap - item)**2 + lambda * bins_remain_cap`
            We want to maximize this.
            Let's set `lambda = 0.1`.

            We need to handle the `bins_remain_cap < item` case. Assign a very low score (e.g., -infinity).
    """
    
    fit_mask = bins_remain_cap >= item
    
    
    priorities = np.full_like(bins_remain_cap, -np.inf)
    
    
    fitting_bins_remain_cap = bins_remain_cap[fit_mask]
    
    
    gap = fitting_bins_remain_cap - item
    
    
    lambda_param = 0.1 # Parameter to balance tightness and overall bin fullness
    
    
    scores = -(gap**2) + lambda_param * fitting_bins_remain_cap
    
    
    priorities[fit_mask] = scores
    
    
    return priorities
```
