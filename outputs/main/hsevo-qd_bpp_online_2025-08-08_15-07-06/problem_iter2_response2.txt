```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Inverse Proximity with a penalty for non-fitting bins for robust BPP packing.

    This heuristic prioritizes bins that can fit the item, favoring those with
    less remaining capacity (closer to a perfect fit). Non-fitting bins are penalized.
    """
    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    # Initialize priorities to a very low value for bins that cannot fit the item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    # For bins that can fit, calculate priority based on inverse remaining capacity
    # Smaller remaining capacity (after placing the item) means a higher priority (better fit)
    # Add a small epsilon to prevent division by zero if remaining capacity is exactly the item size
    bins_to_consider = bins_remain_cap[can_fit_mask]
    
    # Calculate the difference after fitting the item. A smaller difference is better.
    # Inverse of this difference gives higher priority to tighter fits.
    # Adding 1e-9 to denominator for numerical stability if diff is 0.
    diffs = bins_remain_cap[can_fit_mask] - item
    
    # Calculate priorities: Higher value means better fit.
    # The inverse of the difference (after item is placed) is used.
    priorities[can_fit_mask] = 1.0 / (diffs + 1e-9)

    return priorities
```
