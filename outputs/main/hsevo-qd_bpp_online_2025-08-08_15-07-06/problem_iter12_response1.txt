```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    This heuristic aims to improve upon previous versions by introducing a more sophisticated
    multi-criteria scoring mechanism that adapts to the "pressure" of packing.
    It combines a measure of how well an item fits (tightness) with a consideration
    for the bin's current overall fullness. It also incorporates a "pressure-sensitive"
    adjustment to favor tighter fits when bins are generally scarce.

    Scoring logic for bins where `bins_remain_cap >= item`:
    1.  **Tightness Score (TS):** Penalizes excess space more severely as the gap decreases.
        We use `-(bins_remain_cap - item)**2` to reward fits that are close to perfect,
        but also give a good score to slightly larger gaps. This term encourages minimizing waste.
        A perfect fit (`gap = 0`) yields a score of 0.

    2.  **Fullness Score (FS):** Rewards bins that are already fuller, using `bins_remain_cap`.
        This encourages using bins that have more capacity already, potentially leading to fewer bins.

    3.  **Pressure-Sensitive Factor (PSF):** This factor modifies the overall score based on
        how many bins are *nearly* full (i.e., have small remaining capacity).
        If many bins have little remaining capacity, we might want to be more conservative
        and favor tighter fits (higher TS weight).
        We can estimate "pressure" by looking at the count of bins with remaining capacity
        below a certain threshold (e.g., `item * 2`).
        A simple way to implement this is to use a dynamic weight `w_ts` that increases
        with pressure.

    Let's define the pressure:
    `pressure_threshold = item * 1.5`  # Bins with less than 1.5x item size capacity might indicate pressure
    `num_pressured_bins = np.sum(bins_remain_cap < pressure_threshold)`
    `total_fitting_bins = np.sum(bins_remain_cap >= item)`

    If `total_fitting_bins` is small or zero, pressure is high.
    We can use a sigmoid-like function or a simple linear scaling.
    Let's use a score that inversely relates to the *number of available fitting bins*.
    If few bins fit, we apply a higher weight to tightness.
    `availability_factor = 1.0 / max(1, total_fitting_bins)` # Penalize scenarios with many options

    Combined Score:
    `score = w_ts * TS + w_fs * FS`
    Where `w_ts` and `w_fs` are tunable weights, potentially influenced by `availability_factor`.

    Let's try a score that emphasizes tight fits and then current fullness:
    `score = -(bins_remain_cap - item)**2 + lambda_fullness * bins_remain_cap`

    To make it adaptive to "pressure":
    Let `pressure_score = (np.sum(bins_remain_cap < item * 2.0) / len(bins_remain_cap))` if len(bins_remain_cap) > 0 else 0
    The pressure score is a fraction between 0 and 1. Higher means more bins are somewhat full.

    We want to increase the weight of the tightness score (`-(gap**2)`) when pressure is high.
    `weight_tightness = 1.0 + pressure_score * 1.0` # Scale weight of tightness by pressure
    `weight_fullness = 1.0`

    `final_score = weight_tightness * (-(bins_remain_cap - item)**2) + weight_fullness * bins_remain_cap`

    This formulation aims to:
    - Prioritize bins that leave minimal waste (`-(gap**2)`).
    - Favor bins that are already generally fuller (`bins_remain_cap`).
    - Increase the preference for tightness when the overall availability of fitting bins is low (indicated by `pressure_score`).

    We will assign -np.inf to bins that cannot fit the item.
    """
    
    # Identify bins that can fit the item
    fit_mask = bins_remain_cap >= item
    
    # Initialize priorities with a very low value for bins that don't fit
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    # Consider only bins that can fit the item
    fitting_bins_remain_cap = bins_remain_cap[fit_mask]
    
    # If no bins can fit, return the initial -np.inf array
    if not fitting_bins_remain_cap.size:
        return priorities
    
    # Calculate the gap for fitting bins: remaining capacity - item size
    gap = fitting_bins_remain_cap - item
    
    # --- Scoring Components ---
    
    # 1. Tightness Score (TS): Penalizes larger gaps quadratically.
    #    Maximizing this term means minimizing the gap.
    tightness_score = -(gap**2)
    
    # 2. Fullness Score (FS): Rewards bins that have more remaining capacity.
    #    Maximizing this term means maximizing current remaining capacity.
    fullness_score = fitting_bins_remain_cap
    
    # --- Pressure Calculation ---
    # Estimate "pressure" by the fraction of bins that are less than twice the item size.
    # This is a heuristic: if many bins are mostly full, we are under "pressure" to pack efficiently.
    if len(bins_remain_cap) > 0:
        pressure_indicator = (bins_remain_cap < item * 2.0).astype(float)
        # Average pressure across all bins, normalized.
        pressure_factor = np.mean(pressure_indicator)
    else:
        pressure_factor = 0.0

    # --- Dynamic Weights ---
    # Adjust the weight of the tightness score based on pressure.
    # When pressure is high (pressure_factor is high), we want to increase the importance of a tight fit.
    # When pressure is low (pressure_factor is low), we can afford to be less strict about tightness.
    weight_tightness = 1.0 + pressure_factor * 1.0  # Scale: Tighter fit preference increases with pressure
    weight_fullness = 1.0                      # Constant weight for overall fullness

    # --- Combined Score ---
    # Combine the scores with dynamic weights
    combined_scores = (weight_tightness * tightness_score) + (weight_fullness * fullness_score)
    
    # Assign the calculated scores to the priorities array for the fitting bins
    priorities[fit_mask] = combined_scores
    
    return priorities
```
