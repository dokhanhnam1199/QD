```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Calculates priority for bins. Prioritizes bins with minimal remaining capacity
    that fit the item, using an exponential scaling on the inverse difference.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    differences = suitable_bins_caps - item

    # Prioritize bins that fit the item snugly (minimal difference)
    # Use inverse of difference as a base score: higher score for smaller difference.
    # Add epsilon to avoid division by zero for perfect fits.
    base_scores = 1.0 / (differences + 1e-9)

    # Use exponential scaling to provide graded priorities.
    # A temperature parameter controls the "sharpness" of the distribution.
    # Lower temperature means higher priority for the best fits.
    temperature = 0.1  # Tunable parameter
    graded_scores = np.exp(base_scores / temperature)

    # Normalize scores to create a probability-like distribution (optional but good practice)
    # This step is more relevant if using Softmax for probabilistic selection,
    # but can also help in scaling for direct comparison.
    if graded_scores.size > 0:
        max_score = np.max(graded_scores)
        if max_score > 0:
            normalized_scores = graded_scores / max_score
            priorities[suitable_bins_mask] = normalized_scores
        else:
            # If all scores are zero or non-positive (unlikely with exp), assign neutral scores
            priorities[suitable_bins_mask] = 0.5

    return priorities
```
