```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    This heuristic aims to improve upon previous versions by employing a multi-criteria,
    non-linearly scaled scoring mechanism that balances tight fits with overall bin utilization,
    incorporating a tunable parameter for flexibility.

    The strategy is to prioritize bins based on a composite score that considers:
    1. Proximity to a perfect fit: Penalizes deviation from a perfect fit using a quadratic function.
       This encourages minimizing the 'slack' (remaining_capacity - item).
    2. Overall bin fullness: Rewards bins that are generally more full, even if not the absolute tightest fit.
       This is achieved by a linear term based on the remaining capacity.
    3. Smoothness and adaptability: Uses a carefully constructed score that is less abrupt than purely linear combinations
       and includes a tunable parameter.

    Scoring logic for bins that can fit the item (bins_remain_cap >= item):
    - `tightness_score = -(bins_remain_cap - item)**2`: This component is maximized when `bins_remain_cap - item` is zero (perfect fit),
      and decreases quadratically as the gap increases. This provides a smoother penalty than a linear term.
    - `fillness_score = alpha * bins_remain_cap`: This component rewards bins that have more remaining capacity. A higher `bins_remain_cap`
      suggests the bin is less full, but this term encourages distributing items to bins that *could* accommodate more,
      potentially leading to better overall packing density. The `alpha` parameter controls the influence of this factor.

    - Combined Score for fitting bins: `score = tightness_score + fillness_score`
      `score = -(bins_remain_cap - item)**2 + alpha * bins_remain_cap`

    - Parameter `alpha`: A tunable parameter controlling the trade-off between favoring the tightest fit
      and favoring bins that are generally fuller (i.e., have more remaining capacity).
      A higher `alpha` gives more weight to the overall fullness of the bin.
      A value of 0.1 is used here as a starting point, aiming to slightly favor more full bins among close fits.

    - For bins that cannot fit the item (bins_remain_cap < item), a very low score (-infinity) is assigned to ensure they are not selected.
    """
    
    # Create a mask to identify bins that can accommodate the item.
    fit_mask = bins_remain_cap >= item
    
    # Initialize priorities with a very low value for bins that cannot fit the item.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    # Calculate scores only for bins that can fit the item.
    fitting_bins_remain_cap = bins_remain_cap[fit_mask]
    
    # Calculate the 'gap' or 'slack' for fitting bins. This is the remaining capacity after placing the item.
    # We want to minimize this gap.
    gap = fitting_bins_remain_cap - item
    
    # Define a tunable parameter to balance the influence of gap minimization and overall bin fullness.
    # A higher alpha gives more weight to the overall fullness of the bin.
    alpha = 0.1 
    
    # Calculate the composite score for each fitting bin:
    # 1. Quadratic penalty for the gap: `-(gap**2)` maximizes when gap is 0.
    # 2. Linear reward for the bin's current remaining capacity: `alpha * fitting_bins_remain_cap` favors generally fuller bins.
    scores = -(gap**2) + alpha * fitting_bins_remain_cap
    
    # Assign the calculated scores to the corresponding positions in the priorities array.
    priorities[fit_mask] = scores
    
    # Return the array of priority scores. The bin with the highest score will be selected.
    return priorities
```
