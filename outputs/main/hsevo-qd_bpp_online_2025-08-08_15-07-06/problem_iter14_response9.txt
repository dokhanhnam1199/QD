```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tight-fitting preference with a graded penalty for larger gaps.
    Favors bins with minimal remaining capacity after placement using a
    temperature-controlled exponential function for graded priorities.
    """
    eligible_bins_mask = bins_remain_cap >= item
    eligible_capacities = bins_remain_cap[eligible_bins_mask]

    if eligible_capacities.size == 0:
        return np.zeros_like(bins_remain_cap)

    # Calculate the "gap" for eligible bins, prioritizing smaller gaps.
    # Use negative gaps for higher scores for tighter fits.
    gaps = eligible_capacities - item
    
    # Use a temperature-controlled exponential function for graded priorities.
    # This is inspired by Heuristic 13/14/16. A smaller temperature gives
    # sharper prioritization towards the tightest fit.
    temperature = 0.1 
    scores = np.exp(-gaps / temperature)

    # Normalize scores to create a probability-like distribution.
    # This ensures that scores are relative and avoids issues with
    # very large or small score magnitudes.
    if np.sum(scores) > 1e-9:
        priorities = scores / np.sum(scores)
    else:
        priorities = np.ones_like(scores) / scores.size # Uniform if all scores are near zero

    # Map priorities back to the original bin structure
    full_priorities = np.zeros_like(bins_remain_cap, dtype=float)
    full_priorities[eligible_bins_mask] = priorities

    return full_priorities
```
