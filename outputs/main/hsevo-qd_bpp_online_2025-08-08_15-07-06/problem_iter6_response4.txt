```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    This heuristic aims to improve upon priority_v1 by incorporating a more nuanced
    scoring system that considers both the immediate fit and the potential future
    impact of placing the item in a bin.

    The priority is calculated as follows:
    1. For bins that can fit the item:
       - Calculate the remaining capacity after placing the item: `remaining_capacity - item`.
       - To prioritize bins that leave minimal remaining space (aiming for fuller bins),
         we use `item - remaining_capacity` as a base score. A smaller non-negative
         difference (i.e., `remaining_capacity` is just slightly larger than `item`)
         results in a higher score (closer to 0).
       - Additionally, we consider the "fullness" of the bin *before* placing the item.
         A bin that is already quite full (high initial remaining capacity) but can
         still fit the item might be a better candidate to keep smaller remaining
         capacities for smaller items later. This is somewhat counter-intuitive
         to just minimizing leftover space.
       - Let's try to capture this by adding a term related to the initial remaining capacity.
         A higher initial remaining capacity could be slightly penalized if it means
         leaving a large gap. However, we want to favor bins that *are* mostly full.

       - A more robust approach could be to consider the *ratio* of remaining capacity
         to the item size. `bins_remain_cap[fit_mask] / item`. A ratio close to 1 indicates
         a tight fit. We want to maximize this ratio, but only for bins that fit.
         `np.inf` if `item` is 0.0, handle that.

       - Let's try a combined approach:
         - Base score for tight fit: `-(bins_remain_cap[fit_mask] - item)` which is `item - bins_remain_cap[fit_mask]`.
         - Bonus for bins that are "efficiently" utilized: Consider the reciprocal of the
           remaining capacity *after* placing the item. `1 / (bins_remain_cap[fit_mask] - item)`.
           This would heavily favor bins with very little space left.
           However, this can explode if `bins_remain_cap[fit_mask] - item` is close to zero.
           A more stable approach: `bins_remain_cap[fit_mask] / (bins_remain_cap[fit_mask] - item + epsilon)`
           where epsilon is a small constant to avoid division by zero.
           This term rewards bins that have a lot of remaining capacity compared to the gap left.

       - Let's refine the criteria:
         1. Minimize the leftover space: `bins_remain_cap[fit_mask] - item`. To maximize this as a priority, we use `item - bins_remain_cap[fit_mask]`.
         2. Prioritize bins that are already "full" relative to their capacity (which we don't know directly, only remaining capacity).
            We can infer "fullness" by how much space is *left* for the item.
            If `bins_remain_cap` is large, and `item` is small, the gap `bins_remain_cap - item` is large.
            If `bins_remain_cap` is just slightly larger than `item`, the gap is small.

       - Let's consider the "waste" caused by fitting the item in a bin: `bins_remain_cap[fit_mask] - item`.
         We want to minimize this waste. So, we want to maximize `-(bins_remain_cap[fit_mask] - item)`.
         This is `item - bins_remain_cap[fit_mask]`.

       - To introduce a secondary criterion that favors bins that are already somewhat full,
         we can add a term that is higher for bins with smaller remaining capacity *before*
         placing the item, provided they can fit the item.
         This can be `1.0 / (bins_remain_cap[fit_mask] + epsilon)`. The `+ epsilon` avoids division by zero if a bin has 0 remaining capacity (though such bins wouldn't fit any item > 0).

       - Let's try a weighted sum: `w1 * (item - bins_remain_cap[fit_mask]) + w2 * (1.0 / (bins_remain_cap[fit_mask] + epsilon))`.
         A bin that has `bins_remain_cap = 0.9` and `item = 0.8`.
         Fit: `0.9 - 0.8 = 0.1`. Priority component 1: `0.8 - 0.9 = -0.1`.
         Fullness component: `1.0 / (0.9 + epsilon)`.
         If another bin has `bins_remain_cap = 0.2` and `item = 0.1`.
         Fit: `0.2 - 0.1 = 0.1`. Priority component 1: `0.1 - 0.2 = -0.1`.
         Fullness component: `1.0 / (0.2 + epsilon)`.

         This approach seems to favor bins with higher remaining capacity in the fullness component.
         We want to favor bins that are *already* more full, meaning they have *less* remaining capacity.
         So, the fullness component should be higher for *smaller* `bins_remain_cap[fit_mask]`.
         This means `1.0 / (bins_remain_cap[fit_mask] + epsilon)` is correct.

       - Let's consider the ratio of remaining capacity to item size again.
         `bins_remain_cap[fit_mask] / item`. Higher is better if it's close to 1.
         If `bins_remain_cap = 0.9`, `item = 0.8`, ratio is `1.125`.
         If `bins_remain_cap = 0.2`, `item = 0.1`, ratio is `2.0`.
         This favors the second bin more. We want to favor the first bin (tighter fit).
         So, we want to maximize `item / bins_remain_cap[fit_mask]` (inverted ratio) *only for those that fit*.
         No, we want to maximize `bins_remain_cap[fit_mask] - item` but with preference for smaller values.
         The original `item - bins_remain_cap[fit_mask]` is good for minimizing gap.

       - Let's try to penalize bins that are excessively large for the item.
         The penalty should be higher for bins with much larger remaining capacity than needed.
         Consider `-(bins_remain_cap[fit_mask] - item)**2`. This penalizes larger gaps quadratically.
         So, `item - bins_remain_cap[fit_mask] - (bins_remain_cap[fit_mask] - item)**2`.
         Or simply, `item - bins_remain_cap[fit_mask]` as the primary score and maybe add a bonus for bins that are "close" to full.

       - Let's revisit the idea of "closest to item" but with a bias.
         If `bins_remain_cap[fit_mask] - item` is the gap. We want to minimize this.
         So, we want to maximize `-(bins_remain_cap[fit_mask] - item)`.
         Consider the *absolute difference* and then transform it to a priority:
         `abs_diff = np.abs(bins_remain_cap[fit_mask] - item)`
         We want to prioritize bins with smaller `abs_diff`.
         So, `-abs_diff` could be a score.
         `-(bins_remain_cap[fit_mask] - item)` is equivalent if `bins_remain_cap[fit_mask] >= item`.

       - Let's incorporate "granularity". Instead of just a single score, let's
         consider the potential for future packing.
         If we place an item into a bin with `rem_cap = 0.8` and `item = 0.7`, the new `rem_cap` is `0.1`.
         If we place into `rem_cap = 1.0` and `item = 0.7`, the new `rem_cap` is `0.3`.
         The first option leaves less space, which might be good.

       - Alternative: Prioritize bins that, *after* placing the item, have a remaining capacity
         that is "just right" for some common future item sizes, or leave a capacity that is
         "hard to fill". This requires knowledge of item distribution, which we don't have in pure online.

       - Let's focus on a metric that rewards "tight fits" but also considers
         the "quality" of the remaining space.
         The value `bins_remain_cap[fit_mask] - item` is the "slack".
         We want to minimize slack. So, maximize `-(slack)`.
         Let's also add a term that rewards bins that have a significant amount of remaining
         capacity *before* packing, because these might be more versatile for future items.
         This means we prefer bins with higher `bins_remain_cap[fit_mask]` if the slack is similar.
         This is contradictory to minimizing slack.

       - Let's consider the "Best Fit" strategy. This tries to minimize `bins_remain_cap - item`.
         The priority for Best Fit would be `-(bins_remain_cap - item)` for bins that fit.

       - Let's try to modify Best Fit. Instead of just minimizing the leftover space,
         let's consider the ratio of item size to remaining capacity.
         `item / bins_remain_cap[fit_mask]`. We want this ratio to be close to 1.
         If `bins_remain_cap = 0.9`, `item = 0.8`, ratio = `0.8 / 0.9 = 0.888...`
         If `bins_remain_cap = 0.2`, `item = 0.1`, ratio = `0.1 / 0.2 = 0.5`
         We want to maximize this ratio, as it means the item is a larger proportion of the bin's remaining capacity.
         This encourages filling bins more effectively.

       - So, for bins that fit: `priority = item / bins_remain_cap[fit_mask]`.
         This will be <= 1. Higher is better.
         If `bins_remain_cap[fit_mask] == item`, ratio is 1.
         If `bins_remain_cap[fit_mask] > item`, ratio < 1.
         This correctly prioritizes bins where the item "almost fills" it.

    2. For bins that cannot fit the item:
       - Assign a very low priority (e.g., `-np.inf`).

    Let's consider `epsilon` for division by zero if `bins_remain_cap` could be zero.
    However, `bins_remain_cap >= item` already handles cases where `bins_remain_cap` is too small.
    If `item` can be 0, and `bins_remain_cap` is 0, then `0/0` is `NaN`. We should handle this.
    If `item` is 0, any bin can fit it. The priority should be high.
    Let's assume `item > 0`.

    Refined `priority_v2`:
    Prioritize bins that can fit the item, and among those, pick the one where the
    item's size relative to the bin's remaining capacity is maximized.
    This ratio `item / bins_remain_cap[fit_mask]` indicates how "full" the bin
    becomes with this item.
    """
    
    # Ensure item is not zero to avoid division by zero for the ratio
    # If item is zero, it fits anywhere and doesn't consume capacity.
    # In such a case, any bin is equally good, or perhaps the one with least capacity
    # to keep larger ones free. For simplicity, we'll assign a high priority.
    if item == 0:
        # Assign a high priority to all bins, maybe favoring the fullest ones.
        # A simple high value for all fitting bins.
        return np.ones_like(bins_remain_cap) * 1e9
        
    fit_mask = bins_remain_cap >= item
    
    # Initialize priorities to a very low value
    priorities = np.full_like(bins_remain_cap, -np.inf)
    
    # Calculate priorities for bins that can fit the item
    # The priority is the ratio of item size to remaining capacity.
    # A higher ratio means the item occupies a larger proportion of the remaining space,
    # indicating a tighter fit.
    # We add a small epsilon to the denominator to prevent division by zero
    # if bins_remain_cap is exactly equal to item and extremely close to zero itself,
    # though fit_mask should prevent `bins_remain_cap < item`.
    # If `bins_remain_cap[fit_mask]` is exactly `item`, the ratio is 1.
    # If `bins_remain_cap[fit_mask]` is slightly larger than `item`, the ratio is < 1.
    # So, we want to maximize this ratio, favoring `bins_remain_cap[fit_mask]` closest to `item`.
    
    epsilon = 1e-9  # Small value to prevent division by zero or issues with floating point precision
    
    # We want to maximize the ratio `item / bins_remain_cap[fit_mask]`
    # This encourages `bins_remain_cap[fit_mask]` to be as close to `item` as possible.
    # Example:
    # Bin1: rem_cap=0.9, item=0.8 => ratio = 0.8/0.9 = 0.888...
    # Bin2: rem_cap=0.2, item=0.1 => ratio = 0.1/0.2 = 0.5
    # Bin1 has higher priority. This is a form of "Best Fit" where we consider the ratio.
    
    priorities[fit_mask] = item / (bins_remain_cap[fit_mask] + epsilon)
    
    return priorities
```
