```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap)
    
    # First Fit strategy: Prioritize bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    # Among bins that can fit, prioritize those with less remaining capacity (tightest fit)
    # This is a common heuristic to avoid leaving large gaps that are hard to fill later.
    # We invert the remaining capacity so that smaller remaining capacity gets a higher priority.
    # Add a small epsilon to avoid division by zero if remaining capacity is exactly the item size
    epsilon = 1e-9
    priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] - item + epsilon)
    
    # Ensure bins that cannot fit the item have a priority of 0
    priorities[~can_fit_mask] = 0.0
    
    # Further refine by making bins with very little remaining capacity (close to item size)
    # have even higher priority. This is a secondary heuristic to exploit tight fits.
    # We can use a penalty for being too large.
    too_large_penalty = 1000.0
    large_remaining_capacity_mask = bins_remain_cap > item * 1.5 # Heuristic threshold
    priorities[can_fit_mask & large_remaining_capacity_mask] -= too_large_penalty

    return priorities
```
