```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins using a combined metric of inverse proximity and bin fullness,
    favoring tighter fits and more utilized bins with a smooth scaling.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if np.any(suitable_bins_mask):
        suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
        
        differences = suitable_bins_caps - item
        
        # Inverse proximity for tightness, scaled to avoid extreme values
        tightness_score = 1.0 / (differences + 1e-9)
        
        # Score based on how full the bin will be after packing
        # Larger remaining capacity means it's less full, so we invert it.
        fullness_score = item / suitable_bins_caps

        # Combine scores: Give more weight to tightness, but also consider fullness
        # A simple weighted sum can be effective. Tuning lambda_param is key.
        lambda_param = 0.5 
        combined_score = tightness_score + lambda_param * fullness_score
        
        # Apply a sigmoid-like transformation to smooth priorities and normalize them somewhat.
        # This helps avoid extremely high priorities and distributes preference.
        # The scaling factor (e.g., 0.1) can be adjusted to control the steepness.
        priorities[suitable_bins_mask] = 1 / (1 + np.exp(-0.1 * combined_score))

    return priorities
```
