```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    This is a heuristic for the online bin packing problem.
    We want to prioritize bins that are "almost full" but can still fit the item.
    This strategy aims to fill bins as much as possible before opening new ones.

    The priority is calculated as follows:
    1. For bins that can fit the item:
       - Calculate how much "space" is left after fitting the item.
       - We want to *minimize* this leftover space, but we also don't want to penalize bins that are already very full.
       - A good measure might be `(bin_capacity - item) / bin_capacity` if we're talking about proportions,
         but we have remaining capacities. So, `remaining_capacity - item`.
       - To get a "priority" where higher is better, we can take the negative of this difference: `item - remaining_capacity`.
         This means a bin with `remaining_capacity = 0.9` and `item = 0.8` gives `-0.7` (higher is better than -0.2 for a bin with `remaining_capacity = 0.3`).
       - To avoid very large negative numbers for bins that are too small, we can set the priority to a very low number (or zero) if the item doesn't fit.

    2. For bins that cannot fit the item:
       - Assign a very low priority (e.g., 0 or negative infinity effectively, but we'll use 0).

    Let's refine this:
    We want to put the item into a bin where the remaining capacity is *just enough* or slightly more than the item.
    If remaining_capacity >= item:
        Priority = some_function(remaining_capacity - item)
    Else:
        Priority = -infinity (effectively 0 for practical purposes if others are positive)

    Consider the difference: `bins_remain_cap - item`.
    If this difference is negative, the item doesn't fit. We'll assign a very low priority.
    If this difference is non-negative, we want to prioritize bins where this difference is *smallest* (closest to zero).
    So, we want to maximize `-(bins_remain_cap - item) = item - bins_remain_cap`.
    This means if a bin has `rem_cap = 1.0` and `item = 0.5`, priority is `-0.5`.
    If a bin has `rem_cap = 0.6` and `item = 0.5`, priority is `-0.1`. The latter is higher priority.

    Let's make it simpler. We want the bin where `bins_remain_cap` is *closest to `item`*, but greater than or equal to `item`.
    This is like finding the minimum of `bins_remain_cap - item` for all `bins_remain_cap >= item`.
    To turn this into a "priority" (higher is better), we can use `-abs(bins_remain_cap - item)` or `item - bins_remain_cap`.
    Let's stick with `item - bins_remain_cap`.

    Priorities will be negative. Higher values mean a better fit.
    We need to handle the case where `bins_remain_cap < item`.
    """
    
    fit_mask = bins_remain_cap >= item
    
    
    priorities = np.full_like(bins_remain_cap, -np.inf)
    
    
    priorities[fit_mask] = item - bins_remain_cap[fit_mask]
    
    
    return priorities
```
