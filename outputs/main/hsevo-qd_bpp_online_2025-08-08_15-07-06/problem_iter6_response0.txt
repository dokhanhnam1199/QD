```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    This heuristic aims to find a bin that not only fits the item but also leaves
    a minimal amount of "wasted" space. It also prioritizes bins that are already
    relatively full, as this can lead to better overall packing density.

    The priority is calculated as follows:
    1. For bins that can fit the item (bins_remain_cap >= item):
       - Calculate the remaining capacity after placing the item: `remaining_after_fit = bins_remain_cap - item`.
       - We want to minimize `remaining_after_fit`.
       - To make this a higher-is-better score, we can use the negative of this difference: `-(bins_remain_cap - item) = item - bins_remain_cap`.
       - To further favor bins that are already fuller (i.e., have smaller initial `bins_remain_cap`), we can add a term that is inversely related to the initial `bins_remain_cap`.
       - A simple way to do this is to add `1 / bins_remain_cap` (or a scaled version). However, `bins_remain_cap` can be close to zero.
       - A more robust approach might be to use the ratio `item / bins_remain_cap`. This term is larger when the bin is fuller and the item takes up a larger proportion of the remaining space.
       - Combining these, we can use a weighted sum: `alpha * (item - bins_remain_cap) + beta * (item / bins_remain_cap)`.
       - For simplicity and to avoid division by zero or very small numbers, we can use `item - bins_remain_cap` and add a bonus for bins that are "tight fits". A tight fit means `bins_remain_cap` is close to `item`.
       - Let's define a score that prioritizes tight fits and also rewards fuller bins.
       - Priority for fitting bins: `(item - bins_remain_cap) + penalty_for_empty_space`.
       - A good penalty for empty space is `remaining_after_fit`. So, `(item - bins_remain_cap) - (bins_remain_cap - item)`. This simplifies to `2 * (item - bins_remain_cap)`. This still prioritizes smaller remaining space.
       - Another way: We want to minimize `bins_remain_cap - item`. So, maximize `-(bins_remain_cap - item)`.
       - Let's consider two criteria: 1) minimizing leftover space (`bins_remain_cap - item`) and 2) maximizing the fullness of the bin (`bins_remain_cap`).
       - A score like `(item - bins_remain_cap)` penalizes bins with large remaining capacity.
       - To favor fuller bins, we can add a term that increases with the fullness. `bins_remain_cap` itself could be used, but it might be too dominant.
       - How about prioritizing bins where `bins_remain_cap` is just slightly larger than `item`? This means `bins_remain_cap - item` is small and positive.
       - We can use `1 / (bins_remain_cap - item + epsilon)` for bins that fit, where epsilon prevents division by zero. To make it higher is better, we can negate this or use `-(bins_remain_cap - item)`.
       - A more robust approach is to assign a score that reflects both how well the item fits and how full the bin is.
       - Consider the leftover space: `leftover = bins_remain_cap - item`. We want to minimize `leftover`.
       - A possible score for fitting bins: `-(leftover)^2`. This heavily penalizes large leftover spaces.
       - To also consider the initial fullness, we can add a term proportional to `bins_remain_cap`.
       - Let's try a score that rewards tight fits and also considers the initial fullness.
       - `priority = - (bins_remain_cap - item) + k * bins_remain_cap`
       - If `bins_remain_cap - item` is small, the first term is large (good).
       - If `bins_remain_cap` is large, the second term is large (good, for fuller bins).
       - We need to be careful with the scaling.
       - A common strategy is to use a penalty for wasted space. The wasted space is `bins_remain_cap - item`. We want to minimize this.
       - To make it higher is better, we can use `-(bins_remain_cap - item)`.
       - To prioritize fuller bins, we can add a bonus related to `bins_remain_cap`.
       - `priority = -(bins_remain_cap - item) + C * bins_remain_cap`
       - The constant `C` controls the trade-off.
       - A simpler approach, focusing on "tight fit" and "fullness":
         - Score = (how much space is left after fitting) + (bonus for fullness)
         - Let `leftover = bins_remain_cap - item`. We want to minimize `leftover`.
         - For fuller bins, `bins_remain_cap` is smaller.
         - Consider the score: `-(bins_remain_cap - item)`. This favors bins where `bins_remain_cap` is close to `item`.
         - To incorporate fullness, we can add `bins_remain_cap` itself, but scaled.
         - `score = -(bins_remain_cap - item) + scale * bins_remain_cap`
         - Let's use a simpler multi-criteria approach:
           - Criterion 1: Minimize `bins_remain_cap - item`. (Maximize `item - bins_remain_cap`)
           - Criterion 2: Maximize `bins_remain_cap`.
           - A combined score could be a weighted sum, but let's try a more direct approach: prioritize bins that are "almost full" and can still fit the item.
           - This means `bins_remain_cap` should be just slightly larger than `item`.
           - We can define a "tightness" score.
           - `tightness = bins_remain_cap - item`. We want to minimize `tightness`.
           - To make it higher is better, we can use `-tightness = item - bins_remain_cap`.
           - To reward fuller bins, we can add a term related to `bins_remain_cap`.
           - Let's consider the reciprocal of the leftover space: `1 / (bins_remain_cap - item + epsilon)`. Higher means less leftover.
           - Combine this with a bonus for initial fullness.
           - `priority = (item - bins_remain_cap) + k * bins_remain_cap`
           - A refined idea: prioritize bins where `bins_remain_cap` is close to `item`.
           - This means `bins_remain_cap - item` is minimized.
           - We can assign a score that is inversely proportional to `bins_remain_cap - item`.
           - `priority = - (bins_remain_cap - item)` for fitting bins.
           - To prefer fuller bins, we can add a bonus that is proportional to `bins_remain_cap`.
           - `priority = - (bins_remain_cap - item) + weight * bins_remain_cap`
           - Let's try a different angle. We want bins that are "just right".
           - A bin that is too empty is not ideal. A bin that is too full (doesn't fit) is also not ideal.
           - For bins that fit, we want `bins_remain_cap` to be as close to `item` as possible.
           - Let's consider a score: `-(bins_remain_cap - item)**2`. This emphasizes minimizing the difference.
           - To also incorporate the initial fullness, we can add a term related to `bins_remain_cap`.
           - `priority = -(bins_remain_cap - item)**2 + k * bins_remain_cap`
           - The `k` parameter balances minimizing waste vs. using fuller bins.
           - If `bins_remain_cap` is very large, `-(bins_remain_cap - item)**2` becomes very small (large negative).
           - If `bins_remain_cap` is very close to `item`, `-(bins_remain_cap - item)**2` is close to 0.
           - Consider the ratio: `item / bins_remain_cap`. This is higher for fuller bins.
           - Let's try a score that combines minimal leftover space with a penalty for being too empty.
           - `priority = -(bins_remain_cap - item)` for fitting bins.
           - To reward fuller bins, we can add a term like `bins_remain_cap`.
           - `priority = -(bins_remain_cap - item) + alpha * bins_remain_cap`
           - Let's make the priority score more sensitive to "tight fits".
           - For bins that fit: `bins_remain_cap >= item`.
           - Score component 1: Minimize `bins_remain_cap - item`.
           - Score component 2: Maximize `bins_remain_cap`.
           - A simple fusion: `-(bins_remain_cap - item) + alpha * bins_remain_cap`.
           - Let's choose `alpha = 0.5` as a starting point, balancing minimal waste with fuller bins.
           - For bins that do not fit, assign a very low priority.
    """
    
    fit_mask = bins_remain_cap >= item
    
    
    priorities = np.full_like(bins_remain_cap, -np.inf)
    
    
    fitting_bins_remain_cap = bins_remain_cap[fit_mask]
    
    
    leftover_space = fitting_bins_remain_cap - item
    
    
    alpha = 0.5  # Weight for initial bin fullness
    
    
    priorities[fit_mask] = -leftover_space + alpha * fitting_bins_remain_cap
    
    
    return priorities
```
