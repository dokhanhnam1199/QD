```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins based on a combination of inverse proximity to perfect fit
    and the inverse of remaining capacity for a graded preference.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if np.any(suitable_bins_mask):
        suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
        
        # Calculate inverse proximity to perfect fit (similar to v0)
        differences = suitable_bins_caps - item
        inverse_proximity = 1.0 / (differences + 1e-9)
        
        # Assign very high priority to perfect fits
        perfect_fit_mask = (differences == 0)
        inverse_proximity[perfect_fit_mask] = 1e9 
        
        # Calculate inverse of remaining capacity as a secondary criterion
        # Favors bins that will have less remaining space after packing
        inverse_remaining_capacity = 1.0 / (suitable_bins_caps + 1e-9)
        
        # Combine criteria: emphasize perfect fit, then tightest fit, then less remaining capacity
        # Using a weighted sum where inverse_proximity has a higher weight
        combined_scores = 1.5 * inverse_proximity + 0.5 * inverse_remaining_capacity
        
        priorities[suitable_bins_mask] = combined_scores
            
    return priorities
```
