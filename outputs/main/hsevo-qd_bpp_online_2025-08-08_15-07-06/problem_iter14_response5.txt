```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins based on a combination of tightest fit and overall remaining capacity,
    using a softened maximum approach for graded priorities.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if np.any(suitable_bins_mask):
        suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
        differences = suitable_bins_caps - item

        # Heuristic: Prioritize tight fits with a penalty for larger gaps,
        # inspired by 1/(diff + eps) but with exponential softening.
        # Also considers overall remaining capacity as a secondary factor.
        # This combines the "tight fit" focus of v0/v8 with a more graded approach.
        tight_fit_score = np.exp(-differences / 0.5) # Softens tight fit preference, 0.5 is a tunable param

        # Consider overall remaining capacity. Bins with more capacity might be
        # better for future items, but we want to avoid very large gaps for the current item.
        # Here, we use the remaining capacity directly, potentially scaled.
        # For simplicity, we'll use remaining capacity directly and let the tight_fit_score dominate.
        overall_capacity_score = suitable_bins_caps

        # Combine scores. A weighted sum is common. Here, tight fit is primary.
        # We normalize overall_capacity_score to prevent it from dominating the tight_fit_score
        # unless it provides a significant advantage.
        normalized_capacity_score = overall_capacity_score / (np.max(overall_capacity_score) + 1e-9)

        # Combine scores: heavily favor tight fit, but give some boost for higher capacity.
        # The factor 0.1 is a tunable parameter to balance the two criteria.
        combined_score = tight_fit_score + 0.1 * normalized_capacity_score
        
        # Assign infinite priority to perfect fits for strong consolidation.
        perfect_fit_mask = (differences == 0)
        if np.any(perfect_fit_mask):
            priorities[suitable_bins_mask][perfect_fit_mask] = float('inf')
        else:
            priorities[suitable_bins_mask] = combined_score
            
    return priorities
```
