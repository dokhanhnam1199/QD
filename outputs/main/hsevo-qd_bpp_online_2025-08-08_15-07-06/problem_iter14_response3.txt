```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit preference with a smooth penalty for larger gaps.
    Uses an exponential decay for differences, favoring bins with smaller
    remaining capacity after placement.
    """
    eligible_bins_mask = bins_remain_cap >= item
    
    if not np.any(eligible_bins_mask):
        return np.zeros_like(bins_remain_cap)

    eligible_capacities = bins_remain_cap[eligible_bins_mask]

    # Calculate the difference between bin capacity and item size.
    # Smaller differences (tighter fits) are preferred.
    differences = eligible_capacities - item

    # Use an exponential decay function to assign scores.
    # This creates a graded priority, strongly favoring tighter fits
    # while still assigning non-zero scores to bins with larger gaps.
    # A positive exponent means smaller differences yield higher scores.
    scores = np.exp(-differences)

    # Normalize scores to create a probability-like distribution.
    # This ensures that the relative priorities are maintained.
    # Softmax-like scaling for numerical stability.
    max_score = np.max(scores)
    normalized_scores = np.exp(scores - max_score)
    priorities = normalized_scores / np.sum(normalized_scores)

    # Map the computed priorities back to the original bin array structure.
    full_priorities = np.zeros_like(bins_remain_cap, dtype=float)
    full_priorities[eligible_bins_mask] = priorities

    return full_priorities
```
