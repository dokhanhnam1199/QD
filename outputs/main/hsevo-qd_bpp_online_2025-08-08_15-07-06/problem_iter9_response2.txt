```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    This heuristic aims to improve upon previous versions by incorporating a more
    sophisticated multi-criteria scoring mechanism. It prioritizes bins that are
    a good fit for the item while also considering the overall fullness of the bin
    and using a smooth, non-linear function to avoid abrupt scoring changes.

    The strategy is to prioritize bins based on three main factors:
    1.  Minimizing the 'gap' (remaining capacity - item size).
    2.  Maximizing the current fullness of the bin (represented by remaining capacity).
    3.  Providing a score that is sensitive to the magnitude of the gap, rewarding
        smaller gaps more significantly.

    Scoring logic for bins that can fit the item:
    -   A primary score component focusing on the gap: We want to minimize `bins_remain_cap - item`.
        To make this a high-score-is-better metric, we can use `-(bins_remain_cap - item)`.
        To make the scoring more granular and sensitive to smaller gaps, we can use a
        transformed version, like `- (bins_remain_cap - item)**2`. This heavily penalizes
        larger gaps.
    -   A secondary score component for overall bin fullness: We can use `bins_remain_cap` itself.
        A higher `bins_remain_cap` might indicate a bin that is generally more utilized,
        which could be strategically beneficial.
    -   A tunable parameter `alpha` to balance the importance of minimizing the gap
        versus utilizing generally fuller bins.

    The combined score for fitting bins is:
    `score = alpha * -(bins_remain_cap - item)**2 + (1 - alpha) * bins_remain_cap`

    This formulation aims to:
    -   Heavily favor bins with small positive gaps (`bins_remain_cap - item` close to zero).
    -   Slightly favor bins with more remaining capacity if the gap is similar.
    -   Assign a very low score to bins that cannot fit the item.
    """
    
    fit_mask = bins_remain_cap >= item
    
    
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    
    fitting_bins_remain_cap = bins_remain_cap[fit_mask]
    
    
    gap = fitting_bins_remain_cap - item
    
    
    alpha = 0.7  # Weight for the gap-minimization term. Higher alpha means prioritizing tighter fits.
                 # Value between 0 and 1.
    
    
    # Score component 1: Penalizes larger gaps quadratically.
    # Maximizing this means minimizing the gap.
    score_gap_centric = -(gap**2)
    
    
    # Score component 2: Rewards bins that are generally fuller.
    score_fullness_centric = fitting_bins_remain_cap
    
    
    # Combine scores using alpha for a nuanced preference.
    # The combination aims to select bins that are a good fit AND are reasonably full.
    combined_scores = alpha * score_gap_centric + (1 - alpha) * score_fullness_centric
    
    
    priorities[fit_mask] = combined_scores
    
    
    return priorities
```
