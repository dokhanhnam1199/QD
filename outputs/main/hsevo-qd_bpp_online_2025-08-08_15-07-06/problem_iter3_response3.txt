```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    This heuristic aims to improve upon priority_v1 by considering the "waste"
    of a bin after placing the item, and also giving a slight preference
    to bins that are already relatively full.

    The priority is calculated as follows:
    1. For bins that can fit the item (bins_remain_cap >= item):
       - Calculate the remaining capacity after placing the item: `remaining_capacity - item`.
       - To prioritize bins with less remaining capacity (i.e., more full), we want to minimize this difference.
         A good way to convert minimization to maximization (for priority) is to use the negative of the difference: `item - remaining_capacity`.
       - Additionally, we can add a small bonus for bins that are already quite full. A bin with `remaining_capacity` closer to 0 (but still >= item) is generally preferred.
         We can achieve this by adding a term that increases as `remaining_capacity` decreases. For example, we can use `1 / (bins_remain_cap + epsilon)` where epsilon is a small constant to avoid division by zero.
         A simpler approach might be to add a term like `(bin_capacity - bins_remain_cap)`. Since we don't have bin_capacity, we can approximate this by considering how "full" the bin is relative to the item itself.
         Let's consider the relative "fullness" of the bin *after* placing the item. A bin that becomes `0.1` full is better than one that becomes `0.5` full, if the item is the same.
         So, we want to maximize `-(remaining_capacity - item)`. This is `item - remaining_capacity`.
         To also favor bins that are already more full, we can add a term related to how much space is *left* relative to the item's size. A bin with `remaining_capacity = 0.5` and `item = 0.4` has `0.1` space left. A bin with `remaining_capacity = 0.9` and `item = 0.4` has `0.5` space left. We prefer the former.
         So `item - remaining_capacity` seems good.
         To incorporate the "already full" aspect, we can consider the *inverse* of the remaining capacity *after* packing. A bin with very little capacity left is good.
         Let's try `(item - bins_remain_cap) + C * (1 / (bins_remain_cap - item + epsilon))` where C is a small constant.
         A simpler heuristic that balances fitting tightly and preferring fuller bins could be:
         Maximize `(item - bins_remain_cap)` (tight fit) + `(1 / (bins_remain_cap + epsilon))` (already full).
         Let's use `epsilon = 1e-6` to avoid division by zero.

    2. For bins that cannot fit the item:
       - Assign a very low priority (e.g., -np.inf).
    """
    
    fit_mask = bins_remain_cap >= item
    
    
    priorities = np.full_like(bins_remain_cap, -np.inf)
    
    
    epsilon = 1e-6
    
    
    bins_that_fit_cap = bins_remain_cap[fit_mask]
    
    
    tight_fit_score = item - bins_that_fit_cap
    
    
    fullness_score = 1.0 / (bins_that_fit_cap - item + epsilon)
    
    
    priorities[fit_mask] = tight_fit_score + fullness_score
    
    
    return priorities
```
