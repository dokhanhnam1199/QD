```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with a penalty for remaining capacity, favoring bins
    that are nearly full after packing, using a smooth, exponential function.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if np.any(suitable_bins_mask):
        suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
        differences = suitable_bins_caps - item
        
        # Prioritize tight fits (small differences) using inverse proximity.
        # Also, penalize bins that will have large remaining capacity after packing
        # by using an exponential decay on the negative remaining capacity.
        # A small epsilon avoids division by zero for perfect fits.
        # The combination aims to pick the tightest fit that also results in minimal waste.
        remaining_capacity = suitable_bins_caps
        scores = (1.0 / (differences + 1e-9)) + np.exp(-remaining_capacity / 10.0)
        
        priorities[suitable_bins_mask] = scores
        
        # Ensure perfect fits (zero difference) receive a very high priority.
        perfect_fit_mask = (differences == 0)
        if np.any(perfect_fit_mask):
            priorities[suitable_bins_mask][perfect_fit_mask] = np.finfo(float).max

    return priorities
```
