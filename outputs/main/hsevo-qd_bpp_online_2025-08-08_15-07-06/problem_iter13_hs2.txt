import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 5.060603578543982e-06, sigmoid_steepness: float = 1.5271506536610624, neutral_priority: float = 0.45433877652466914) -> np.ndarray:
    """
    Combines inverse proximity for tight fits with a sigmoid for smooth preference.
    Favors bins with minimal remaining capacity after packing, scaled smoothly.

    Args:
        item (float): The size of the item to be packed.
        bins_remain_cap (np.ndarray): A numpy array representing the remaining capacity of each bin.
        epsilon (float): A small value to prevent division by zero. Defaults to 1e-9.
        sigmoid_steepness (float): Controls the steepness of the sigmoid function. Higher values make the transition sharper. Defaults to 10.0.
        neutral_priority (float): The priority assigned to bins that are equidistant in terms of fit. Defaults to 0.5.

    Returns:
        np.ndarray: A numpy array of priorities for each bin.
    """
    eligible_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if np.any(eligible_bins_mask):
        eligible_capacities = bins_remain_cap[eligible_bins_mask]
        
        # Inverse proximity: smaller gap is better (higher score)
        # Adding a small epsilon to avoid division by zero
        inverse_proximity = 1.0 / (eligible_capacities - item + epsilon)

        # Normalize inverse proximity to a range where sigmoid is effective
        # Aims to map smaller gaps (higher inverse_proximity) to values around 0.5
        # and larger gaps to values further from 0.5.
        # This normalization is heuristic and can be tuned.
        min_inv_proximity = np.min(inverse_proximity)
        max_inv_proximity = np.max(inverse_proximity)
        
        if max_inv_proximity > min_inv_proximity:
            normalized_scores = (inverse_proximity - min_inv_proximity) / (max_inv_proximity - min_inv_proximity)
        else: # All eligible bins have the same inverse proximity
            normalized_scores = np.ones_like(inverse_proximity) * neutral_priority

        # Sigmoid function to create a smooth priority distribution
        # The steepness parameter (e.g., 10) can be tuned.
        # We want bins with smaller gaps (higher normalized_scores) to have higher sigmoid outputs.
        # So, we invert the normalized_scores for the sigmoid input to favor smaller gaps.
        # The input to sigmoid is centered around 0 for the neutral_priority.
        sigmoid_input = sigmoid_steepness * (normalized_scores - neutral_priority)
        sigmoid_priorities = 1 / (1 + np.exp(-sigmoid_input))

        priorities[eligible_bins_mask] = sigmoid_priorities
        
        # Ensure that if all eligible bins are identical in terms of fit, they get a neutral priority
        if np.all(priorities[eligible_bins_mask] == neutral_priority) and len(eligible_bins_mask) > 0:
            priorities[eligible_bins_mask] = neutral_priority

    return priorities
