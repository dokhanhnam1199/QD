```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tight fit (inverse proximity) with an exponential penalty for excess capacity,
    normalizing for robustness and giving infinite priority to perfect fits.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if np.any(suitable_bins_mask):
        suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
        differences = suitable_bins_caps - item

        # Normalized inverse proximity for tight fit, with infinite for perfect fit
        normalized_inverse_proximity = 1.0 / (differences + 1e-9)
        perfect_fit_mask = (differences == 0)
        normalized_inverse_proximity[perfect_fit_mask] = float('inf')

        # Exponential penalty for excess capacity to avoid very large bins
        # Using a small temperature to emphasize tight fits
        temperature = 0.1
        excess_capacity_penalty = np.exp(-differences / (temperature + 1e-9))

        # Combine criteria: favor tight fits, penalize large excess capacities
        priorities[suitable_bins_mask] = normalized_inverse_proximity * excess_capacity_penalty
        
        # Normalize priorities to a [0, 1] range to make them comparable across items
        valid_priorities = priorities[suitable_bins_mask]
        if np.any(valid_priorities):
            min_p, max_p = np.min(valid_priorities), np.max(valid_priorities)
            if max_p > min_p:
                priorities[suitable_bins_mask] = (valid_priorities - min_p) / (max_p - min_p)
            else: # All valid priorities are the same (e.g., all inf or all same value)
                priorities[suitable_bins_mask] = 1.0

    return priorities
```
