```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins with the tightest fit, using inverse difference,
    and smooths priorities using an exponential function for graded preference.
    """
    eligible_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if np.any(eligible_bins_mask):
        eligible_capacities = bins_remain_cap[eligible_bins_mask]
        
        # Calculate the difference between remaining capacity and item size
        # Smaller difference means a tighter fit, which is preferred.
        fit_differences = eligible_capacities - item
        
        # Use exponential scaling for graded preference: higher score for smaller differences.
        # A temperature parameter can tune the distribution's steepness.
        # Lower temperature = stronger preference for the absolute best fit.
        temperature = 0.5  # Tunable parameter
        
        # Add a small epsilon to avoid division by zero if fit_differences are zero.
        # Invert the differences to prioritize smaller gaps, then scale with exp.
        # Using exp(-difference/temperature) where smaller difference yields larger value.
        # Adding a small constant to difference before inversion to prevent infinite scores for perfect fits.
        scaled_priorities = np.exp(-fit_differences / temperature)
        
        priorities[eligible_bins_mask] = scaled_priorities

    return priorities
```
