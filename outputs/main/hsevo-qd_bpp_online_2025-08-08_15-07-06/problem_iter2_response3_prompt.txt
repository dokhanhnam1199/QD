{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    A Softmax-based priority function for the online Bin Packing Problem.\n\n    This function calculates the priority of placing an item into each available bin.\n    It considers the remaining capacity of each bin relative to the item size.\n    Bins that can accommodate the item without exceeding their capacity are favored.\n    Among the bins that can accommodate the item, those with less remaining capacity\n    (i.e., tighter fits) are given a higher priority, encouraging fuller bins first.\n    The Softmax function is used to convert these relative preferences into a\n    probability distribution, ensuring that higher priority bins have a greater chance\n    of being selected.\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A numpy array where each element represents the remaining\n                         capacity of a bin.\n\n    Returns:\n        A numpy array of the same shape as bins_remain_cap, where each element\n        is the priority score for placing the item into the corresponding bin.\n    \"\"\"\n    eligible_bins_mask = bins_remain_cap >= item\n    eligible_capacities = bins_remain_cap[eligible_bins_mask]\n\n    if eligible_capacities.size == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    # Calculate the \"fit\" score for eligible bins. A smaller remaining capacity\n    # (tighter fit) results in a higher score. We use the negative difference\n    # to make larger remaining capacities (less good fits) have smaller scores.\n    fit_scores = -(eligible_capacities - item)\n\n    # Apply Softmax to get probabilities (priorities).\n    # Adding a small epsilon to avoid log(0) issues if fit_scores can be zero.\n    epsilon = 1e-9\n    exp_scores = np.exp(fit_scores - np.max(fit_scores)) # Stability trick for softmax\n    priorities = exp_scores / np.sum(exp_scores)\n\n    # Map priorities back to the original bin structure\n    full_priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    full_priorities[eligible_bins_mask] = priorities\n\n    return full_priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    suitable_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    if np.any(suitable_bins):\n        remaining_capacities_of_suitable_bins = bins_remain_cap[suitable_bins]\n        \n        gaps = remaining_capacities_of_suitable_bins - item\n        \n        normalized_gaps = gaps / np.max(remaining_capacities_of_suitable_bins)\n        \n        sigmoid_scores = 1 / (1 + np.exp(-10 * (normalized_gaps - 0.5)))\n        \n        priorities[suitable_bins] = sigmoid_scores\n        \n        \n        if np.all(priorities == 0):\n             priorities[suitable_bins] = 0.5\n    \n    return priorities\n\n### Analyze & experience\n- Comparing Heuristic 1 and Heuristic 4 (which are identical): They use a Softmax-based approach, prioritizing tighter fits. This is a sophisticated method that balances preferences well.\n\nComparing Heuristic 2 and Heuristic 8 (which are identical): These use an inverse proximity (1/proximity) strategy. This is a good heuristic that directly favors bins with less remaining space after fitting. The handling of `proximity == 0` with `float('inf')` is a strong indicator of a good fit.\n\nComparing Heuristic 3 and Heuristic 11, 14, 16 (which are similar): These use an inverse difference `1.0 / (np.abs(diffs) + 1e-9)`. This is similar to the inverse proximity, but the `np.abs()` is not strictly necessary if we filter for `bins_remain_cap >= item` first. The explicit masking to zero for ineligible bins is good.\n\nComparing Heuristic 5 and Heuristic 12, 13, 15 (which are very similar): Heuristic 5 uses `-differences + 1.0` for priority. This also favors tighter fits. The use of `-1.0` for ineligible bins is a clear indicator. The more complex versions (12, 13, 15) attempt to incorporate Softmax-like behavior or scaling with temperature, which can be beneficial but also adds complexity.\n\nComparing Heuristic 6 and Heuristic 7 (identical): These implement a \"best fit\" strategy by assigning a priority of 1.0 only to bins that achieve the minimum difference. This is a greedy approach that focuses on a single best option.\n\nComparing Heuristic 9 and Heuristic 10 (identical): These use an Epsilon-Greedy strategy. They exploit the best fit most of the time but explore randomly with a small probability. This can help escape local optima but adds a stochastic element.\n\nComparing Heuristic 19 and Heuristic 20 (identical): These use a sigmoid function based on normalized gaps. This is an interesting approach that attempts to create a smooth priority distribution but might be overly complex for a simple priority score.\n\nOverall: Heuristics 1 and 4 (Softmax) and 2 and 8 (Inverse Proximity with infinity for perfect fit) appear to be the most robust and well-designed. Heuristics 3, 11, 14, 16 are good inverse difference strategies. Heuristic 5 is a clear and simple \"best fit\" variant. The Epsilon-Greedy (9, 10) offers exploration. The sigmoid-based ones (19, 20) and the strict \"best fit\" ones (6, 7, 17, 18) are less versatile or potentially over-engineered for a simple priority function. The complexity in 12, 13, 15 without clear justification for temperature scaling makes them less preferable than simpler inverse methods.\n- \nHere's a redefined approach to self-reflection for heuristic design:\n\n*   **Keywords:** Simplicity, Transparency, Empirical Validation, Targeted Exploration.\n*   **Advice:** Focus on constructing heuristics with easily understandable mechanics and clear justifications for their components. Prioritize simple rules that can be incrementally enhanced.\n*   **Avoid:** Overly complex, opaque mathematical functions without demonstrable performance gains. Avoid \"black box\" heuristic components.\n*   **Explanation:** The goal is to build heuristics that are debuggable and adaptable. Understanding *why* a heuristic makes a choice is crucial for identifying limitations and designing targeted improvements, rather than relying on blind experimentation with complex mechanisms.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}