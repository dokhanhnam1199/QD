```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins by favoring those with the smallest remaining capacity that can fit the item,
    using an inverse proximity score for refinement.
    """
    # Identify bins that can accommodate the item
    possible_bins_mask = bins_remain_cap >= item

    if not np.any(possible_bins_mask):
        return np.zeros_like(bins_remain_cap)

    # Get remaining capacities of only the possible bins
    valid_capacities = bins_remain_cap[possible_bins_mask]

    # Calculate the difference between remaining capacity and item size.
    # Smaller difference indicates a tighter fit, which is generally preferred
    # to minimize wasted space and encourage filling bins.
    differences = valid_capacities - item

    # Assign priority scores: higher score for smaller differences (tighter fits).
    # Using the inverse of the difference (plus a small epsilon for stability)
    # makes smaller differences result in larger scores.
    # If difference is 0 (perfect fit), score becomes very high.
    epsilon = 1e-9
    priorities = 1.0 / (differences + epsilon)

    # Create a result array initialized with zeros
    final_priorities = np.zeros_like(bins_remain_cap)
    # Place the calculated priorities into the correct positions corresponding to possible bins
    final_priorities[possible_bins_mask] = priorities

    return final_priorities
```
