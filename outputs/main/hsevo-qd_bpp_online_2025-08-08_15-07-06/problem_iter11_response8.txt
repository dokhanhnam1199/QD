```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines normalized inverse proximity with a linear penalty on excess capacity.

    Favors tighter fits using inverse proximity, tempered by a penalty
    for bins with significantly more remaining capacity than needed.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if np.any(suitable_bins_mask):
        suitable_bins_caps = bins_remain_cap[suitable_bins_mask]

        # Inverse proximity for tight fits, normalized
        proximity = suitable_bins_caps - item
        inverse_proximity_scores = 1.0 / (proximity + 1e-9)

        if np.max(inverse_proximity_scores) > 0:
            normalized_inverse_proximity = inverse_proximity_scores / np.max(inverse_proximity_scores)
        else:
            normalized_inverse_proximity = np.zeros_like(inverse_proximity_scores)

        # Linear penalty on excess capacity, normalized
        excess_capacity = suitable_bins_caps - item
        if np.max(excess_capacity) > 0:
            normalized_excess_capacity = excess_capacity / np.max(excess_capacity)
        else:
            normalized_excess_capacity = np.zeros_like(excess_capacity)

        # Combine normalized inverse proximity with a penalty for excess capacity
        # A higher score is better. We want tight fits (high normalized_inverse_proximity)
        # and we penalize bins with more excess capacity (lower normalized_excess_capacity).
        # A simple combination: normalized_inverse_proximity - normalized_excess_capacity
        # This prioritizes tight fits, but slightly de-prioritizes bins with large excess.
        combined_scores = normalized_inverse_proximity - normalized_excess_capacity

        # Ensure perfect fits (where proximity is 0) get maximum priority if they exist
        # This also ensures their score isn't penalized by the excess capacity term.
        perfect_fit_mask = (proximity == 0)
        combined_scores[perfect_fit_mask] = np.max(normalized_inverse_proximity) + 1 # Give a slight boost

        # Normalize the combined scores to be in a reasonable range for priority
        if np.ptp(combined_scores) > 0: # ptp is peak-to-peak range
            priorities[suitable_bins_mask] = (combined_scores - np.min(combined_scores)) / np.ptp(combined_scores)
        else:
            priorities[suitable_bins_mask] = np.zeros_like(combined_scores) # All scores are the same

        # Ensure perfect fits still have the absolute highest priority after normalization
        priorities[suitable_bins_mask][perfect_fit_mask] = 1.0


    return priorities
```
