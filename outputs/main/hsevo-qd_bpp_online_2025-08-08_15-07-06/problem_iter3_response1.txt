```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    This heuristic aims to prioritize bins that are "just large enough" to fit the item,
    but also considers bins that have a significant amount of space left if no "tight fit"
    is available. This is a hybrid approach combining elements of "best fit" and "first fit"
    with a bias towards utilizing existing bins efficiently.

    The priority is calculated as follows:
    1. For bins that can fit the item (bins_remain_cap >= item):
       - Calculate the "tightness" score: `item / bins_remain_cap`. A score closer to 1
         indicates a tighter fit. We want to maximize this.
       - To avoid division by zero or very small capacities leading to extremely high scores,
         we can cap the remaining capacity or use a small epsilon. However, assuming
         capacities are positive and reasonably sized, `item / bins_remain_cap` is a good start.
       - We want to maximize this value.

    2. For bins that cannot fit the item:
       - Assign a very low priority (effectively -infinity, represented by a very small negative number).

    3. Improvement over v1: v1 focused purely on minimizing leftover space `item - bins_remain_cap`.
       This could lead to picking a bin that is very full but still fits the item, potentially
       leaving very little room for future items. v2's `item / bins_remain_cap` prioritizes
       bins where the item takes up a larger *proportion* of the remaining space,
       which is a more robust indicator of a "good fit" in terms of utilization.

    Consider the difference: `bins_remain_cap - item`.
    v1 maximizes `item - bins_remain_cap`.

    v2 maximizes `item / bins_remain_cap`.
    If `rem_cap = 1.0` and `item = 0.5`, priority is `0.5`.
    If `rem_cap = 0.6` and `item = 0.5`, priority is `0.5 / 0.6 = 0.833`. The latter is higher priority.

    This means v2 prefers the bin that is more utilized by the current item.
    """
    fit_mask = bins_remain_cap >= item
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Calculate priority for bins that can fit the item
    # We want to maximize the ratio item / bins_remain_cap, which means
    # prioritizing bins where the item takes up a larger proportion of the space.
    # Using a small epsilon to avoid division by zero if bins_remain_cap can be 0
    # (though typically remaining capacity should be non-negative and potentially positive).
    epsilon = 1e-9
    priorities[fit_mask] = item / (bins_remain_cap[fit_mask] + epsilon)

    return priorities
```
