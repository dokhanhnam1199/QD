```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    This heuristic aims to improve upon previous versions by introducing a more sophisticated
    multi-criteria scoring mechanism that is sensitive to both the tightness of the fit and
    the overall "strategic value" of a bin. It uses a non-linear scoring function and
    explicitly handles edge cases for robustness.

    The strategy is to prioritize bins based on:
    1.  **Tightness of Fit (Primary):** How closely the item fits the remaining capacity.
        We want to minimize the "waste" or slack, i.e., `bins_remain_cap - item`.
        A quadratic penalty `-(bins_remain_cap - item)**2` is used, which heavily penalizes
        larger gaps but is more forgiving for very small gaps, allowing for a nuanced
        selection among good fits.
    2.  **Bin Fullness (Secondary):** Encouraging the use of generally fuller bins to
        potentially consolidate items more effectively. This is captured by `bins_remain_cap`.
        A linear term `lambda_param * bins_remain_cap` is added.

    The scoring function for a fitting bin is:
    `score = -(bins_remain_cap - item)**2 + lambda_param * bins_remain_cap`

    For bins that cannot fit the item, a very low score (`-np.inf`) is assigned to ensure
    they are never chosen.

    An additional factor, `alpha_param`, is introduced to modulate the overall sensitivity
    to the secondary criterion (bin fullness). A higher `alpha_param` means the heuristic
    is more inclined to pick a bin that is generally fuller, even if the fit isn't as tight.
    This allows for adaptability to different packing scenarios.

    The `lambda_param` controls the trade-off between minimizing the gap and maximizing
    the existing bin capacity. A higher `lambda_param` favors bins with more remaining
    capacity before the item is placed.

    Edge Case Handling:
    - Bins that do not fit the item (`bins_remain_cap < item`) are explicitly assigned
      a score of `-np.inf`.
    - For bins that fit, the quadratic term `-(gap**2)` ensures that bins with zero gap
      (perfect fit) receive a score of 0 for this component.

    Vectorization:
    - The operations are designed to be vectorized using NumPy for efficiency.
    """
    
    # Identify bins that can accommodate the item
    fit_mask = bins_remain_cap >= item
    
    # Initialize priorities for all bins to a very low value (-infinity)
    # This ensures that bins that cannot fit are never selected.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    # Select only the bins that can fit the item
    fitting_bins_remain_cap = bins_remain_cap[fit_mask]
    
    # Calculate the 'gap' or slack for fitting bins: remaining capacity - item size
    # This represents the excess space left after placing the item.
    gap = fitting_bins_remain_cap - item
    
    # --- Parameters for tuning the heuristic ---
    # lambda_param: Controls the weight given to the overall fullness of the bin.
    # A higher lambda_param means we are more inclined to pick a fuller bin.
    # It helps balance the primary goal of tight fit with the secondary goal of
    # using bins that are already substantially filled.
    lambda_param = 0.25  # Tunable parameter (e.g., 0.1, 0.25, 0.5)

    # alpha_param: Modulates the quadratic penalty for the gap.
    # A higher alpha_param makes the quadratic term more aggressive in penalizing
    # larger gaps, thereby increasing focus on very tight fits.
    # A lower alpha_param makes the penalty less severe, allowing for more
    # consideration of bins with slightly larger gaps but better overall fullness.
    alpha_param = 1.0 # Tunable parameter (e.g., 0.5, 1.0, 1.5)

    # --- Scoring Calculation ---
    # Primary component: Penalize the gap quadratically. This term is maximized
    # when the gap is closest to zero. The negative sign converts minimization
    # of gap to maximization of score. The squaring makes the penalty non-linear.
    # We multiply by alpha_param to adjust the strength of this primary criterion.
    tightness_score = -alpha_param * (gap**2)
    
    # Secondary component: Reward bins that are fuller. This is represented by
    # the remaining capacity itself. We multiply by lambda_param to control
    # its influence relative to the tightness score.
    fullness_score = lambda_param * fitting_bins_remain_cap
    
    # Combine the scores for the fitting bins. The bin with the highest combined
    # score will be selected.
    combined_scores = tightness_score + fullness_score
    
    # Assign the calculated scores to the corresponding positions in the priorities array
    priorities[fit_mask] = combined_scores
    
    return priorities
```
