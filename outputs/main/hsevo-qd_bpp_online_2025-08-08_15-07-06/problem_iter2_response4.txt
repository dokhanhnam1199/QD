```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines 'Best Fit' with a 'Softness' factor for adaptive priority.

    Prioritizes bins with minimal remaining capacity after fitting the item (Best Fit),
    but also assigns a declining priority to bins with larger remaining capacities
    to encourage filling up partially filled bins.
    """
    priorities = np.zeros_like(bins_remain_cap)
    can_fit_mask = bins_remain_cap >= item

    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]

    if fitting_bins_remain_cap.size > 0:
        # Calculate the difference between remaining capacity and item size.
        # Smaller differences indicate a tighter fit.
        differences = fitting_bins_remain_cap - item

        # Create a score that is high for small differences (tight fit)
        # and decreases as the difference increases.
        # Using 1.0 / (difference + epsilon) gives higher scores to tighter fits.
        # Adding 1.0 to the denominator ensures that even perfect fits (difference=0)
        # get a positive score, and also slightly penalizes perfect fits relative to
        # very tight but not perfect fits, encouraging exploration.
        epsilon = 1e-9
        tight_fit_scores = 1.0 / (differences + epsilon)

        # To encourage filling up bins rather than always choosing the absolute tightest fit,
        # we can slightly boost bins that have more remaining capacity but still fit the item.
        # A simple way is to add a small value proportional to the remaining capacity itself.
        # This biases towards using bins that are more "available" while still valuing tightness.
        # We can scale the remaining capacity to control its influence.
        # Let's use a scaled version of the remaining capacity as a secondary factor.
        # A smaller remaining capacity is generally preferred for filling up, so we use it directly.
        # Using a small constant factor for the secondary priority to avoid overpowering the primary "tight fit" score.
        secondary_priority_factor = 0.1
        secondary_priorities = fitting_bins_remain_cap * secondary_priority_factor

        # Combine the two scores. The tight fit score is primary.
        combined_scores = tight_fit_scores + secondary_priorities

        # Assign the calculated scores to the bins that can fit the item.
        priorities[can_fit_mask] = combined_scores

    return priorities
```
