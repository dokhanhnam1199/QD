```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    This heuristic aims to improve upon priority_v1 by introducing a multi-criteria approach
    that prioritizes bins based on a nuanced scoring function. It considers both how well
    an item fits (tightness) and the overall "emptiness" of the bin after packing.
    The scoring function is designed to be smooth and tunable.

    Scoring logic for bins that can fit the item (`bins_remain_cap >= item`):
    1.  **Tightness Score Component:** Penalize the remaining space (`bins_remain_cap - item`)
        quadratically. This means bins with a small positive gap (closer to zero) are
        significantly preferred over bins with larger gaps. The score is `-(gap**2)`.
        This encourages minimizing wasted space.

    2.  **Fullness Score Component:** Reward bins that have more remaining capacity *before*
        packing. This is represented by `bins_remain_cap`. This component aims to
        leverage bins that are already relatively full, potentially leading to better
        overall packing density by avoiding leaving bins too empty. This score is
        `lambda_param * bins_remain_cap`.

    3.  **Combined Score:** The final score for a fitting bin is the sum of these two components:
        `score = -(bins_remain_cap - item)**2 + lambda_param * bins_remain_cap`.
        The `lambda_param` is a tunable hyperparameter that balances the importance of
        minimizing the gap versus maximizing the initial bin fullness. A higher `lambda_param`
        gives more weight to the initial fullness.

    For bins that cannot fit the item (`bins_remain_cap < item`), a very low score (-inf)
    is assigned, ensuring they are never selected.
    """
    
    fit_mask = bins_remain_cap >= item
    
    
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    
    fitting_bins_remain_cap = bins_remain_cap[fit_mask]
    
    
    gap = fitting_bins_remain_cap - item
    
    
    lambda_param = 0.5 # Tunable parameter: balances tightness vs. initial bin fullness.
                       # Higher values prioritize bins that are fuller initially.
                       # A value of 0 makes it purely based on minimizing squared gap.
                       # A very large value would prioritize fuller bins even with larger gaps.
    
    
    scores = -(gap**2) + lambda_param * fitting_bins_remain_cap
    
    
    priorities[fit_mask] = scores
    
    
    return priorities
```
