```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit (inverse proximity) with a penalty for large gaps,
    favoring bins that minimize waste but are not excessively large.
    """
    
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    
    suitable_bins_mask = bins_remain_cap >= item
    
    
    if np.any(suitable_bins_mask):
        suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
        
        
        differences = suitable_bins_caps - item
        
        
        # Assign high priority for tight fits (small differences)
        # Use inverse proximity, adding a small epsilon to avoid division by zero
        # and a term to penalize larger differences more heavily (e.g., quadratic)
        # Combining 1/(diff + eps) and -(diff^2) to balance tight fit and gap penalty.
        # Weights can be tuned; here, the inverse proximity is primary.
        scores = (1.0 / (differences + 1e-9)) - (differences**2) 
        
        priorities[suitable_bins_mask] = scores
        
        # Ensure perfect fits get the highest possible finite priority if the formula doesn't naturally yield it.
        # This is a safeguard and usually covered by the 1/(diff+eps) term if diff is 0.
        perfect_fit_mask = (differences == 0)
        if np.any(perfect_fit_mask):
            priorities[suitable_bins_mask][perfect_fit_mask] = np.finfo(float).max

    return priorities
```
