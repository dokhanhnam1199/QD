{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines tight-fitting preference with a Softmax-based distribution.\n    Favors bins with minimal remaining capacity after placement, using Softmax\n    to create a graded priority, encouraging exploration of good fits.\n    \"\"\"\n    eligible_bins_mask = bins_remain_cap >= item\n    eligible_capacities = bins_remain_cap[eligible_bins_mask]\n\n    if eligible_capacities.size == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    # Prioritize tighter fits: smaller (capacity - item) is better.\n    # We use the negative difference for Softmax, so smaller differences\n    # lead to larger (more positive) exponents.\n    # This is inspired by Heuristic 7 (Softmax on negative differences).\n    differences = eligible_capacities - item\n    scores = -differences\n\n    # Use Softmax to generate a probability distribution over eligible bins.\n    # This creates graded priorities, favoring tighter fits more strongly.\n    # Stability trick: subtract max score before exponentiating.\n    # This is the core of Heuristic 7.\n    if np.max(scores) - np.min(scores) > 1e6: # Heuristic for numerical stability if scores vary extremely\n        scaled_scores = (scores - np.min(scores)) / (np.max(scores) - np.min(scores) + 1e-9)\n    else:\n        scaled_scores = scores\n\n    exp_scores = np.exp(scaled_scores - np.max(scaled_scores))\n    priorities = exp_scores / np.sum(exp_scores)\n\n    # Map priorities back to the original bin structure\n    full_priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    full_priorities[eligible_bins_mask] = priorities\n\n    return full_priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = 1 / (cap - item + 1e-9)\n    return priorities\n\n### Analyze & experience\n- *   **Comparing (1st) vs (2nd):** Heuristic 1st introduces a quadratic penalty `-(gap**2)` and a linear term `lambda_param * fitting_bins_remain_cap`, aiming for a more nuanced score that balances tight fit with overall bin fullness. Heuristic 2nd also aims for multi-criteria but its explanation is more exploratory and less concrete in its final scoring logic within the docstring. The implementation of 1st seems to better reflect a specific, refined scoring strategy.\n\n*   **Comparing (3rd) vs (4th):** Heuristic 3rd implements a simple binary \"best fit\" logic (1.0 for minimum difference, 0.0 otherwise), failing to provide graded priorities or consider overall bin fullness. Heuristic 4th attempts a multi-criteria approach with normalization and sigmoid activation, aiming for smoother, graded priorities, but its normalization and weighting logic can be complex and might not always yield the most intuitive results.\n\n*   **Comparing (5th) vs (6th):** Heuristic 5th uses an exponential score based on the difference from the minimum difference, with a temperature parameter. Heuristic 6th uses Softmax on the negative differences, creating a probability distribution, which is a more standard approach for graded priorities in similar contexts. Heuristic 6th's Softmax implementation is generally more robust for generating graded priorities.\n\n*   **Comparing (7th) vs (8th):** Heuristic 7th uses a simple `item - bins_remain_cap` score, which is a direct representation of tightest fit but can lead to large negative values. Heuristic 8th uses `1.0 / (differences + 1e-9)` and explicitly assigns `inf` to perfect fits, offering a clearer \"best fit\" prioritization.\n\n*   **Comparing (9th) vs (10th):** Heuristic 9th uses a simple `1.0 / proximity` for fitting bins, prioritizing the tightest fit. Heuristic 10th attempts to combine this with a quadratic penalty `-(differences**2)`, aiming to penalize larger gaps more heavily while still favoring tight fits. Heuristic 10th's multi-faceted scoring is more sophisticated.\n\n*   **Comparing (11th) vs (12th):** Heuristic 11th is identical to Heuristic 10th. Heuristic 12th is identical to Heuristic 6th.\n\n*   **Comparing (13th) vs (14th):** Heuristic 13th and 14th are identical. They use `exp(-diffs / temperature)` which is a Softmax-like approach focused on the tightest fit, controlled by temperature.\n\n*   **Comparing (15th) vs (16th):** Heuristic 15th, 17th, 18th, 19th, 20th are all identical implementations of a simple \"best fit\" heuristic (`1 / (cap - item + 1e-9)`). Heuristic 16th (and its identical counterparts 13th/14th) uses a temperature-controlled exponential function on negative differences, which provides a smoother, graded priority distribution compared to the simple inverse of the difference.\n\n*   **Overall:** Heuristics 1st, 10th/11th, and 13th/14th/16th/17th/18th/19th/20th show a progression. Heuristic 1st offers a good balance of tight fit and bin fullness. Heuristics 10th/11th attempt to penalize gaps quadratically. Heuristics 13th/14th/16th/etc. use a Softmax-like approach for graded priorities based on tightness. The simplest (and thus arguably worst for nuanced optimization) are the basic \"best fit\" heuristics (15th onwards). Heuristic 4th tries complex normalization and sigmoid, which might be overly complicated. Heuristic 3rd is too simplistic.\n- \nHere's a redefined approach to self-reflection for designing better heuristics:\n\n*   **Keywords:** Multi-criteria, graded scoring, tunable parameters, nuanced penalties, vectorized operations.\n*   **Advice:** Focus on composite scoring functions that blend multiple criteria (fit, fullness, etc.) using smooth, non-linear mappings (e.g., exponentials, sigmoid). Tune parameters to adapt to problem characteristics. Leverage vectorized operations for performance.\n*   **Avoid:** Overtly simple binary or linear scoring. Unjustified complex transformations without empirical evidence. Ignoring edge cases or bin eligibility.\n*   **Explanation:** Nuanced scoring and tunable parameters allow heuristics to capture subtle trade-offs and adapt to diverse problem instances, leading to more effective and robust solutions than blunt, oversimplified approaches.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}