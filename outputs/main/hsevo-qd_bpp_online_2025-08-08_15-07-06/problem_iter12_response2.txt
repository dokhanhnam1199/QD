```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    This heuristic aims to improve upon priority_v1 by introducing a more robust
    multi-criteria approach with non-linear scoring and explicit handling of edge cases.

    The strategy is to prioritize bins based on a refined combination of:
    1.  Tightness of fit: Penalizing deviations from a perfect fit quadratically.
    2.  Bin fullness: Encouraging the use of bins that are already substantially full.
    3.  Adaptability: Introducing a parameter that can tune the heuristic's behavior.

    Scoring logic:
    - For bins that can fit the item (`bins_remain_cap >= item`):
        - Calculate the "gap": `gap = bins_remain_cap - item`. We want to minimize this gap.
        - Use a quadratic penalty for the gap: `-(gap**2)`. This heavily favors minimizing the gap,
          but allows for slightly larger gaps if other factors compensate.
        - Incorporate bin fullness: `bins_remain_cap`. We want to favor bins with higher remaining capacity
          as a secondary objective to encourage packing into generally fuller bins.
        - Combine these with a tunable parameter `alpha` that controls the trade-off between minimizing
          the gap and maximizing bin fullness.
          `score = -(gap**2) + alpha * bins_remain_cap`
        - A very small positive `alpha` (e.g., 0.01) will prioritize tightness almost exclusively.
          A larger `alpha` will give more weight to the overall fullness of the bin.
        - To make the heuristic more adaptable, consider a parameter `beta` that influences the
          non-linearity of the gap penalty. `-(gap**beta)` where `beta > 1` would increase the penalty
          for larger gaps. For `beta = 2`, we get a quadratic penalty.
          Let's try `score = -(gap**2) + alpha * bins_remain_cap`.

    - For bins that cannot fit the item (`bins_remain_cap < item`):
        - Assign a very low priority score (e.g., -infinity) to ensure they are never chosen.

    The chosen parameters:
    - `alpha = 0.05`: A moderate weight for bin fullness.
    - `gap_penalty_power = 2.0`: Quadratic penalty for the gap.

    This heuristic aims to be more nuanced than simply picking the tightest fit.
    It might select a bin that has a slightly larger gap but is significantly fuller,
    potentially leading to better overall packing in the long run.
    """

    fit_mask = bins_remain_cap >= item

    # Initialize priorities with a very low value for bins that cannot fit the item.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Filter for bins that can accommodate the item.
    fitting_bins_remain_cap = bins_remain_cap[fit_mask]

    # Calculate the gap for fitting bins.
    gap = fitting_bins_remain_cap - item

    # Tunable parameters:
    # alpha: Controls the weight given to the current fullness of the bin.
    # gap_penalty_power: Controls the steepness of the penalty for larger gaps.
    alpha = 0.05
    gap_penalty_power = 2.0

    # Calculate the score for fitting bins.
    # The score is a combination of a non-linear penalty for the gap and a linear bonus for bin fullness.
    # The `-np.power(gap, gap_penalty_power)` term ensures that larger gaps are penalized more severely.
    # The `alpha * fitting_bins_remain_cap` term provides a bonus for bins that are already more full.
    scores = -np.power(gap, gap_penalty_power) + alpha * fitting_bins_remain_cap

    # Assign the calculated scores to the corresponding bins in the priorities array.
    priorities[fit_mask] = scores

    return priorities
```
