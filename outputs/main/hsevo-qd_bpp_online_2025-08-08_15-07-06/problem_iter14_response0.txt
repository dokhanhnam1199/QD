```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins based on a combination of tightness of fit and remaining capacity.
    Favors bins that fit the item snugly, with a secondary preference for bins that are not excessively empty.
    """
    priorities = np.zeros_like(bins_remain_cap)
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    differences = suitable_bins_caps - item
    
    # Higher priority for bins with smaller differences (tighter fit).
    # Use exponential scaling with a temperature parameter to create graded priorities.
    # Lower temperature makes the priority for the tightest fit much higher.
    # Add a small penalty based on the remaining capacity to slightly disfavor very empty bins.
    temperature = 0.5 
    
    # Score based on tightness: exp(-(difference) / temperature)
    tightness_scores = np.exp(-differences / temperature)
    
    # Score based on remaining capacity: inversely proportional to capacity (smaller capacity is better if it fits)
    # This term is designed to slightly penalize very large remaining capacities.
    capacity_penalty = 1.0 / (suitable_bins_caps + 1e-9)
    
    # Combine scores. A simple multiplication can work, or a weighted sum.
    # Here, we'll multiply, so bins that are both tight and not excessively empty get higher scores.
    # We scale the capacity penalty to be in a similar range as tightness_scores.
    # A simple scaling could be dividing by the average capacity or a fraction of it.
    # Let's try adding a scaled version of the inverse capacity.
    
    # To combine, let's use a simple approach: prioritize based on tightness primarily,
    # and use the inverse capacity as a secondary factor if tightness is similar.
    # A composite score: f(tightness) * g(capacity_penalty)
    # Let's try: tightness_scores * (1 + alpha * capacity_penalty)
    # Where alpha controls the influence of remaining capacity.
    alpha = 0.1 # Tune this parameter
    
    combined_scores = tightness_scores * (1.0 + alpha * capacity_penalty)

    # Assign the computed scores to the priorities array
    priorities[suitable_bins_mask] = combined_scores
    
    return priorities
```
