```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:

    fit_mask = bins_remain_cap >= item
    
    priorities = np.full_like(bins_remain_cap, -np.inf)
    
    fitting_bins_remain_cap = bins_remain_cap[fit_mask]
    
    gap = fitting_bins_remain_cap - item
    
    # Penalty for excessive slack: quadratic penalty on the gap
    # This encourages minimizing the remaining space without being overly sensitive to tiny gaps
    slack_penalty = -np.square(gap)
    
    # Bonus for bin fullness: higher remaining capacity means a "fuller" bin in a relative sense
    # This encourages using bins that are already somewhat populated
    fullness_bonus_weight = 0.2
    fullness_bonus = fullness_bonus_weight * fitting_bins_remain_cap
    
    # Combine scores. Prioritize bins with minimal slack, with a bonus for fuller bins.
    # The goal is to maximize the score.
    scores = slack_penalty + fullness_bonus
    
    priorities[fit_mask] = scores
    
    return priorities
```
