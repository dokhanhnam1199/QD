```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    This heuristic aims to find a balance between fitting the item snugly and
    leaving sufficient space for future items. It prioritizes bins that can
    accommodate the item and, among those, favors bins that are not overly full,
    leaving more residual capacity for subsequent items.

    The priority is calculated as follows:
    1. For bins that can fit the item (bins_remain_cap >= item):
       - Calculate the remaining capacity *after* placing the item: `bins_remain_cap - item`.
       - To prioritize bins that leave *more* residual space (promoting future flexibility),
         we want to maximize `bins_remain_cap - item`.
       - However, we also want to avoid penalizing bins that are already quite full,
         as they might still be good candidates.
       - A simple and transparent approach is to directly use the remaining capacity
         after placement as the priority score: `bins_remain_cap - item`.
         A higher score indicates more remaining space, which is generally good.

    2. For bins that cannot fit the item:
       - Assign a very low priority (e.g., -infinity).
    """
    
    fit_mask = bins_remain_cap >= item
    
    
    priorities = np.full_like(bins_remain_cap, -np.inf)
    
    
    priorities[fit_mask] = bins_remain_cap[fit_mask] - item
    
    
    return priorities
```
