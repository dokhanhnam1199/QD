import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 8.583641912703321, sigmoid_center_offset: float = 0.7053760804126432, epsilon: float = 1.4826815365097128e-06) -> np.ndarray:
    """Combines inverse proximity with a sigmoid for smoother prioritization.

    Favors bins with tight fits, but also provides non-zero priority for
    less tight fits to encourage exploration.

    Args:
        item: The item to be placed.
        bins_remain_cap: A numpy array representing the remaining capacity of each bin.
        alpha: Scaling factor for the sigmoid, controlling its steepness.
        sigmoid_center_offset: Offset for the sigmoid's center, tuning the point of steepest change.
        epsilon: A small value to avoid division by zero for perfect fits.

    Returns:
        A numpy array of priorities for each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if np.any(suitable_bins_mask):
        suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
        
        # Inverse proximity for tight fits (similar to priority_v0)
        proximity = suitable_bins_caps - item
        
        # Use a scaled sigmoid on proximity to create a smoother distribution
        # Scaling factor `alpha` controls steepness. Higher alpha means steeper curve.
        # Add a small epsilon to avoid division by zero for perfect fits
        inverse_proximity_scores = 1.0 / (proximity + epsilon)
        
        # Normalize inverse proximity scores to be between 0 and 1
        max_inverse_proximity = np.max(inverse_proximity_scores)
        if max_inverse_proximity > 0:
            normalized_inverse_proximity = inverse_proximity_scores / max_inverse_proximity
        else:
            normalized_inverse_proximity = np.zeros_like(inverse_proximity_scores)

        # Sigmoid transformation to map scores to a [0, 1] range, emphasizing tighter fits
        # Adjusting the sigmoid's center and steepness can tune behavior.
        # Here, we center it around a value that would correspond to a "good" proximity.
        # For simplicity, we'll use a sigmoid on the normalized inverse proximity.
        # A higher score from inverse proximity should map to a higher sigmoid output.
        sigmoid_scores = 1 / (1 + np.exp(-alpha * (normalized_inverse_proximity - sigmoid_center_offset))) # Adjusted sigmoid

        priorities[suitable_bins_mask] = sigmoid_scores
        
        # Ensure perfect fits still get a high priority, potentially capped by sigmoid
        perfect_fit_mask = (proximity == 0)
        if np.any(perfect_fit_mask):
            priorities[suitable_bins_mask][perfect_fit_mask] = 1.0 # Assign max priority for perfect fit

    return priorities
