```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    This heuristic aims to improve upon priority_v1 by introducing a multi-criteria approach
    with a more nuanced scoring for bins that are not perfectly fitting but are still viable.

    The strategy is to prioritize bins based on two main factors:
    1. How well the item fits the remaining capacity (tightness).
    2. How "full" the bin is after the item is placed (to encourage fuller bins).

    Scoring logic:
    - For bins that can fit the item (`bins_remain_cap >= item`):
        - We want to minimize the `gap = bins_remain_cap - item`. A smaller gap is better.
          To convert this minimization to a maximization score, we can use `-(gap)`.
          However, a simple linear penalty for the gap might be too harsh.
          Let's use a function that penalizes larger gaps quadratically but is less sensitive to small gaps.
          The term `-(gap**2)` achieves this: it's 0 for a perfect fit, negative and decreasing quadratically as the gap increases.

        - As a secondary criterion, we want to favor bins that are already fuller.
          This can be represented by `bins_remain_cap`. A higher `bins_remain_cap` means the bin was fuller before packing.
          We can add this linearly: `lambda_param * bins_remain_cap`.

        - Combining these, the score for fitting bins is: `-(gap**2) + lambda_param * bins_remain_cap`.
          The `lambda_param` is a tunable parameter that balances the tightness of the fit against the overall fullness of the bin.
          A higher `lambda_param` will give more weight to already fuller bins.

    - For bins that cannot fit the item (`bins_remain_cap < item`):
        - Assign a very low priority score (e.g., negative infinity) to ensure they are never chosen.
    """
    
    fit_mask = bins_remain_cap >= item
    
    
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    
    fitting_bins_remain_cap = bins_remain_cap[fit_mask]
    
    
    gap = fitting_bins_remain_cap - item
    
    
    lambda_param = 0.5 # Tunable parameter: balances tightness (via -gap^2) and overall bin fullness (via bins_remain_cap)
                       # A value of 0.5 provides a moderate preference for fuller bins when gaps are similar.
    
    
    scores = -(gap**2) + lambda_param * fitting_bins_remain_cap
    
    
    priorities[fit_mask] = scores
    
    
    return priorities
```
