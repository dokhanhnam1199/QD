```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:
    """
    This heuristic aims to improve upon priority_v1 by considering multiple criteria
    and using a more granular scoring system.

    Criteria considered:
    1.  **Tightest Fit (Minimizing Waste):** Prioritize bins where the remaining capacity
        is just enough to fit the item. This is measured by `item - bins_remain_cap`
        for bins that can fit the item. A smaller (less negative) value indicates a tighter fit.
    2.  **Bin Fullness (Encouraging Full Bins):** Prioritize bins that are already relatively full.
        This is measured by `bins_remain_cap / bin_capacity`. Higher values indicate fuller bins.
    3.  **Strategic Placement (Avoiding Small Gaps):** Prioritize bins where fitting the item
        leaves a very small remaining capacity. This encourages using up small remaining spaces.
        This is measured by `1.0 - (bins_remain_cap - item) / bin_capacity` for bins that fit.
        A higher value means the resulting gap is smaller.

    The final priority is a weighted sum of these criteria. The weights can be tuned.
    For now, we assign equal weights.

    The calculation is as follows:
    - For bins that *cannot* fit the item (`bins_remain_cap < item`), assign a very low priority (-inf).
    - For bins that *can* fit the item (`bins_remain_cap >= item`):
        - `tight_fit_score = item - bins_remain_cap` (higher is better, closer to 0)
        - `fullness_score = bins_remain_cap / bin_capacity` (higher is better)
        - `gap_score = 1.0 - (bins_remain_cap - item) / bin_capacity` (higher is better, closer to 1.0 for tight fits)

        - We normalize these scores to a common range (e.g., [0, 1]) or ensure they are
          meaningful relative to each other. Since `tight_fit_score` can be negative,
          we can shift it: `shifted_tight_fit_score = (tight_fit_score - min_tight_fit) / (max_tight_fit - min_tight_fit)`
          or simply use its negative to make it positive. For simplicity, let's aim to maximize
          `-(bins_remain_cap - item)` as in v1 and combine it with other positive scores.

        Let's redefine scores for maximization:
        - `score1 = -(bins_remain_cap - item)`: Maximizing this means `bins_remain_cap` is close to `item`.
        - `score2 = bins_remain_cap / bin_capacity`: Maximizing this means the bin is fuller.
        - `score3 = 1.0 - (bins_remain_cap - item) / bin_capacity`: Maximizing this means the leftover gap after placing the item is small.

        Combining these: `priority = w1 * score1 + w2 * score2 + w3 * score3`.
        Let's use equal weights for demonstration.
    """
    
    fit_mask = bins_remain_cap >= item
    
    
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    
    fitting_bins_remain_cap = bins_remain_cap[fit_mask]
    
    
    if fitting_bins_remain_cap.size > 0:
        
        
        score1 = -(fitting_bins_remain_cap - item)  # Maximizes tight fit
        
        
        score2 = fitting_bins_remain_cap / bin_capacity  # Maximizes bin fullness
        
        
        score3 = 1.0 - (fitting_bins_remain_cap - item) / bin_capacity  # Maximizes small resulting gap
        
        
        # Simple weighted sum, assuming scores are somewhat comparable or we want
        # to emphasize certain aspects. Weights can be tuned.
        # For now, let's normalize scores to be in a similar range if possible, or
        # just combine them directly if the relative scale is reasonable.
        # A common approach is to rescale.
        
        # Let's rescale score1 to be positive and bounded, e.g., by the maximum possible
        # negative difference. The range is roughly from 0 (perfect fit) to -(bin_capacity - item).
        # A simpler approach is to just add a large constant if we expect negative values.
        # Or, we can define the priority as the negative of the "badness" of the fit.
        
        # Let's try a pragmatic approach: combine closeness to item, fullness, and resulting gap.
        # We want `bins_remain_cap` to be close to `item`.
        # We want `bins_remain_cap` to be high (full bin).
        # We want `bins_remain_cap - item` to be low (small waste).
        
        # Let's define priority as maximizing:
        # (1) `item - bins_remain_cap`: gives higher value for tighter fits.
        # (2) `bins_remain_cap / bin_capacity`: gives higher value for fuller bins.
        # (3) `-(bins_remain_cap - item)`: same as (1)
        
        # Let's try to maximize a combination that favors tight fits AND full bins.
        # A bin that is almost full AND has just enough space is ideal.
        
        # Consider priority as a penalty function and we want to minimize it.
        # Penalty = (bins_remain_cap - item)  # Waste
        # Penalty_fullness = 1 - (bins_remain_cap / bin_capacity) # Lack of fullness
        
        # To convert to priority (higher is better):
        # Priority_fit = -(bins_remain_cap - item)  (higher is better, closer to 0)
        # Priority_fullness = bins_remain_cap / bin_capacity (higher is better)
        
        # Let's try a convex combination.
        # A bin is good if it's almost full AND it fits the item snugly.
        # Tightest fit score (closer to 0 is better): `bins_remain_cap - item`
        # Fullness score (higher is better): `bins_remain_cap / bin_capacity`
        
        # To combine them for maximization:
        # Option A: Maximize `(item - bins_remain_cap) + alpha * (bins_remain_cap / bin_capacity)`
        # Option B: Maximize `-(bins_remain_cap - item) + alpha * (bins_remain_cap / bin_capacity)`
        
        # Let's use Option B and make alpha tunable. A higher alpha emphasizes fullness.
        # Let's set alpha = 0.5 for now.
        
        alpha = 0.5  # Weight for fullness
        
        
        priority_values = -(fitting_bins_remain_cap - item) + alpha * (fitting_bins_remain_cap / bin_capacity)
        
        
        priorities[fit_mask] = priority_values
    
    
    return priorities
```
