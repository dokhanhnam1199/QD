```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with a penalty for large residual capacity,
    using an exponential scaling for granular preference.
    """
    fit_mask = bins_remain_cap >= item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    if np.any(fit_mask):
        fitting_capacities = bins_remain_cap[fit_mask]
        
        # Primary goal: Minimize the gap (tightest fit)
        # Use inverse difference for granular preference, higher score for smaller gaps.
        # Add epsilon for numerical stability and to avoid division by zero.
        inverse_difference_scores = 1.0 / (fitting_capacities - item + 1e-9)
        
        # Secondary goal: Penalize large residual capacity after fit.
        # Use a scaled version of the remaining capacity to reduce its influence.
        # A small positive lambda encourages using bins that still have some capacity left.
        # We use a negative weight to penalize larger remaining capacities.
        lambda_param = 0.1 # Controls the penalty for leftover space
        residual_penalty = -lambda_param * fitting_capacities

        # Combine scores: Prioritize tight fits, with a small penalty for leaving too much space.
        combined_scores = inverse_difference_scores + residual_penalty
        
        # Apply exponential scaling to create a smoother distribution of priorities
        # and amplify differences between scores. Adjusting 'temperature' affects distribution.
        temperature = 1.0
        scaled_scores = np.exp(combined_scores / temperature)
        
        # Ensure the highest score is normalized to 1 for easier interpretation if needed,
        # or simply use the scaled scores as relative priorities.
        # For a priority function, the absolute values matter for ranking, not necessarily normalization to 1.
        # However, to make scores comparable across different runs or items, normalization might be useful.
        # Here, we directly use the scaled scores as priorities.

        priorities[fit_mask] = scaled_scores

    return priorities
```
