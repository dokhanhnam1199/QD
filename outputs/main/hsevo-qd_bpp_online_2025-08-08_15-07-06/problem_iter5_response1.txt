```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines inverse proximity with exponential decay for nuanced bin selection.

    Favors tighter fits while allowing some preference for less tight bins,
    tuned by an exponential decay parameter.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if np.any(suitable_bins_mask):
        suitable_bins_caps = bins_remain_cap[suitable_bins_mask]

        # Inverse proximity for tight fits
        proximity = suitable_bins_caps - item
        inverse_proximity_scores = 1.0 / (proximity + 1e-9)

        # Normalize inverse proximity scores to a [0, 1] range
        if np.max(inverse_proximity_scores) > 0:
            normalized_inverse_proximity = inverse_proximity_scores / np.max(inverse_proximity_scores)
        else:
            normalized_inverse_proximity = np.zeros_like(inverse_proximity_scores)

        # Use exponential decay on normalized inverse proximity.
        # A higher normalized inverse proximity (tighter fit) results in a score closer to 1.
        # The temperature parameter controls the decay rate. Smaller temperature -> steeper decay.
        temperature = 0.5
        exponential_scores = np.exp(normalized_inverse_proximity / temperature)

        # Normalize exponential scores to a [0, 1] range.
        if np.max(exponential_scores) > 0:
            final_scores = exponential_scores / np.max(exponential_scores)
        else:
            final_scores = np.zeros_like(exponential_scores)

        priorities[suitable_bins_mask] = final_scores

        # Ensure perfect fits receive the maximum priority (1.0)
        perfect_fit_mask = (proximity == 0)
        if np.any(perfect_fit_mask):
            priorities[suitable_bins_mask][perfect_fit_mask] = 1.0

    return priorities
```
