```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tight fit (inverse proximity) and bin fullness (inverse remaining capacity)
    using normalized weighted sum with a sigmoid transformation for smooth prioritization.
    Prioritizes bins that minimize remaining capacity after packing and are already fuller.
    """
    eligible_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if np.any(eligible_bins_mask):
        eligible_capacities = bins_remain_cap[eligible_bins_mask]

        # Score 1: Tight fit (inverse proximity). Smaller gap = higher score.
        tight_fit_scores = 1.0 / (eligible_capacities - item + 1e-9)

        # Score 2: Bin fullness (inverse of remaining capacity). Fuller bin = higher score.
        fullness_scores = 1.0 / (eligible_capacities + 1e-9)

        # Normalize scores to range [0, 1] for stable combination
        normalized_tight_fit = (tight_fit_scores - np.min(tight_fit_scores)) / (np.max(tight_fit_scores) - np.min(tight_fit_scores) + 1e-9)
        normalized_fullness = (fullness_scores - np.min(fullness_scores)) / (np.max(fullness_scores) - np.min(fullness_scores) + 1e-9)

        # Combine normalized scores with weights
        weight_tight_fit = 0.7  # Emphasize tighter fits
        weight_fullness = 0.3   # Consider overall fullness
        combined_scores = (weight_tight_fit * normalized_tight_fit) + (weight_fullness * normalized_fullness)

        # Apply sigmoid to smoothen priorities and map to [0, 1] range
        # Steepness parameter (15) makes the sigmoid more sensitive to score differences.
        priorities[eligible_bins_mask] = 1 / (1 + np.exp(-15 * (combined_scores - 0.5)))

    return priorities
```
