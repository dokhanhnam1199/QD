```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines a graded 'best fit' score with a penalty for excessive remaining space,
    weighted to prioritize tighter fits while penalizing significant waste.
    """
    fit_mask = bins_remain_cap >= item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    if np.any(fit_mask):
        eligible_capacities = bins_remain_cap[fit_mask]

        # Score component 1: Graded Best Fit (inverse difference)
        # Prioritize bins where the remaining capacity is closest to the item size.
        # Add a small epsilon to avoid division by zero for perfect fits.
        # The inverse of the gap `(capacity - item)` gives a higher score to smaller gaps.
        diff = eligible_capacities - item
        best_fit_score = 1.0 / (diff + 1e-9)

        # Score component 2: Penalty for excessive remaining space (quadratic penalty)
        # Penalize bins that have a large positive gap (bins_remain_cap - item) more heavily.
        # This discourages placing an item in a bin that becomes very "loose" afterward.
        # The negative quadratic term ensures higher scores for smaller gaps.
        gap_penalty = -(diff ** 2)

        # Combine scores with weights.
        # We want to primarily favor best fit, so give it a higher weight.
        # The gap penalty acts as a secondary factor to refine choices among similar best fits
        # or to discourage very large gaps even if they are technically the "best fit".
        weight_best_fit = 0.8
        weight_gap_penalty = 0.2

        combined_score = weight_best_fit * best_fit_score + weight_gap_penalty * gap_penalty

        priorities[fit_mask] = combined_score

    return priorities
```
