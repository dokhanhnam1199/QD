{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines inverse proximity with exponential decay for nuanced bin selection.\n\n    Favors tighter fits while allowing some preference for less tight bins,\n    tuned by an exponential decay parameter.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_mask = bins_remain_cap >= item\n\n    if np.any(suitable_bins_mask):\n        suitable_bins_caps = bins_remain_cap[suitable_bins_mask]\n\n        # Inverse proximity for tight fits\n        proximity = suitable_bins_caps - item\n        inverse_proximity_scores = 1.0 / (proximity + 1e-9)\n\n        # Normalize inverse proximity scores to a [0, 1] range\n        if np.max(inverse_proximity_scores) > 0:\n            normalized_inverse_proximity = inverse_proximity_scores / np.max(inverse_proximity_scores)\n        else:\n            normalized_inverse_proximity = np.zeros_like(inverse_proximity_scores)\n\n        # Use exponential decay on normalized inverse proximity.\n        # A higher normalized inverse proximity (tighter fit) results in a score closer to 1.\n        # The temperature parameter controls the decay rate. Smaller temperature -> steeper decay.\n        temperature = 0.5\n        exponential_scores = np.exp(normalized_inverse_proximity / temperature)\n\n        # Normalize exponential scores to a [0, 1] range.\n        if np.max(exponential_scores) > 0:\n            final_scores = exponential_scores / np.max(exponential_scores)\n        else:\n            final_scores = np.zeros_like(exponential_scores)\n\n        priorities[suitable_bins_mask] = final_scores\n\n        # Ensure perfect fits receive the maximum priority (1.0)\n        perfect_fit_mask = (proximity == 0)\n        if np.any(perfect_fit_mask):\n            priorities[suitable_bins_mask][perfect_fit_mask] = 1.0\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = 1 / (cap - item + 1e-9)\n    return priorities\n\n### Analyze & experience\n- Comparing Heuristic 1 (multi-criteria with quadratic penalty and linear fullness term) with Heuristic 8 (simple `item - bins_remain_cap`), we see that Heuristic 1 attempts a more nuanced approach by penalizing larger gaps quadratically and considering overall bin fullness, which is a richer scoring mechanism than the linear best-fit of Heuristic 8.\n\nComparing Heuristic 2 (multi-criteria fusion with weights) with Heuristic 5 (normalized multi-criteria fusion with sigmoid), Heuristic 2 uses a direct weighted sum (`item - 0.5 * bins_remain_cap`), while Heuristic 5 normalizes components and applies a sigmoid, aiming for smoother, graded priorities. Heuristic 5's normalization and sigmoid might offer more stable behavior across different input scales than Heuristic 2's direct weighting.\n\nComparing Heuristic 6 (normalized proximity and fullness with sigmoid) with Heuristic 12 (normalized inverse proximity with exponential decay), both use normalization and transformations. Heuristic 6 combines normalized proximity and fullness, whereas Heuristic 12 uses exponential decay on normalized proximity, potentially offering finer control over priority gradients.\n\nComparing Heuristic 11 (simple inverse proximity, infinite for perfect fit) with Heuristic 14 (simple inverse proximity, no special handling for perfect fit), Heuristic 11 explicitly rewards perfect fits with infinite priority, which is a stronger signal than Heuristic 14's consistent inverse proportionality.\n\nComparing Heuristic 13 (combined best-fit and excess capacity penalty via exp and multiplication) with Heuristic 18 (similar logic with `exp(-diffs/temp) * excess_capacity_scores`), both attempt to balance tight fit and penalizing large capacities. Heuristic 18's use of exponential scaling with temperature offers a potentially more controlled way to adjust the sensitivity to these factors compared to the multiplicative approach in Heuristic 13.\n\nOverall: Higher ranked heuristics tend to incorporate multiple criteria (tight fit, bin fullness) and use more sophisticated scoring mechanisms (quadratic penalties, normalization, sigmoid/exponential transformations) for finer-grained control and robustness.\n- \nHere's a refined approach to self-reflection for designing better heuristics:\n\n*   **Keywords:** Multi-criteria, Non-linear scoring, Edge cases, Adaptability, Vectorization.\n*   **Advice:** Focus on how multi-criteria scoring can be made *adaptive* through tunable parameters (like temperature) and robust to edge cases.\n*   **Avoid:** Overly simplistic heuristics that fail to capture nuanced trade-offs or are brittle to variations.\n*   **Explanation:** Aim for heuristics that are both computationally efficient (vectorized) and capable of nuanced, adaptable decision-making by leveraging non-linear transformations and explicitly managing extreme scenarios.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}