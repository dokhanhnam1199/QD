```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Heuristic 1: Prefer bins where the item fits (First Fit Decreasing variant)
    fit_mask = bins_remain_cap >= item
    priorities[fit_mask] += 1.0

    # Heuristic 2: Prioritize bins with smaller remaining capacity among the ones that fit.
    # Avoid leaving large empty spaces unnecessarily. Inverse to emphasize smaller remaining capacity.
    priorities[fit_mask] += 1.0 / (bins_remain_cap[fit_mask] + 0.0001)  # Adding small value to avoid division by zero

    # Heuristic 3: Consider wasted space if the item is placed. Penalize bins where there is significant wasted space.
    wasted_space = bins_remain_cap - item
    wasted_space[wasted_space < 0] = 0 # Ensure wasted space is non-negative

    # Prioritize bins such that the amount of wasted space is minimized.
    priorities[fit_mask] -= 0.1 * (wasted_space[fit_mask])

    # Heuristic 4: If no bin can fit, assign priorities based on proximity to fitting (Next Fit strategy when no bin fits).
    no_fit_mask = ~fit_mask
    if np.any(no_fit_mask):
        priorities[no_fit_mask] = -item / (bins_remain_cap[no_fit_mask] + 0.0001)  # Penalize less the bins closer to fitting. Negative to differentiate from fitting bins.

    return priorities
```
