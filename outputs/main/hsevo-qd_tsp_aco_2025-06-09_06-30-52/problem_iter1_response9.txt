```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improved heuristics for the Traveling Salesman Problem (TSP).

    This version incorporates a combination of inverse distance,
    node degree consideration, and a randomized element to escape local optima.
    It aims to balance exploration (trying new edges) and exploitation
    (favoring short distances and ensuring all nodes are connected).

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix
                                      between cities. distance_matrix[i][j] is the distance
                                      between city i and city j.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as the distance matrix,
                    representing the heuristic values for each edge. Higher values
                    indicate more promising edges.  Zero indicates that edge is invalid.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance: Shorter distances are more desirable
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Avoid division by zero

    # Node degree:  Penalize connecting to nodes with many connections.
    # Helps to encourage tour construction rather than just clustering around popular cities
    node_degree_penalty = np.zeros((n, n))
    for i in range(n):
        # Simple approach - assume maximum is fully connected graph
        node_degree_penalty[i, :] = (np.sum(inverse_distance[i, :]) / (np.sum(inverse_distance))) if (np.sum(inverse_distance)) !=0 else 0

    # Random noise:  Introduce randomness to explore the search space
    random_noise = np.random.rand(n, n) * 0.1  # Adjust the multiplier for noise level.

    heuristics = inverse_distance / (node_degree_penalty + 0.0001) + random_noise #The 0.0001 is to ensure no div-by-zero

    # Make diagonals zero and no negative edges to ensure proper paths are sampled
    for i in range(n):
        heuristics[i, i] = 0.0  # No self-loops
        for j in range(n):
            if distance_matrix[i, j] == 0:
                heuristics[i, j] = 0.0 #If there is no valid connection, then heuristics = 0

    return heuristics
```
