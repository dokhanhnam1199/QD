```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A heuristics function for the Traveling Salesman Problem (TSP) that combines
    inverse distance, node degree, local edge density, and a dynamic sparsification
    strategy.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance
                                        matrix between nodes.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix,
                    representing the prior indicators of how promising it is to
                    include each edge in a solution. Higher values indicate more
                    promising edges.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    avg_distance = np.mean(distance_matrix[distance_matrix != 0])
    small_constant = 1e-6

    # Node degree penalty
    node_degrees = np.sum(distance_matrix < (avg_distance * 1.5), axis=1)
    degree_penalty_exponent = 1.2
    
    # Local edge density calculation
    local_neighborhood_size = 5  # Consider the closest 5 neighbors
    local_edge_density = np.zeros((n, n))
    for i in range(n):
        # Get indices of neighbors sorted by distance, excluding self-loop
        neighbor_indices = np.argsort(distance_matrix[i, :])[1:local_neighborhood_size + 1]
        
        # Count edges between these neighbors
        for j in range(n):
            if i != j:
                neighbors_i = np.argsort(distance_matrix[i,:])[1:local_neighborhood_size+1]
                neighbors_j = np.argsort(distance_matrix[j,:])[1:local_neighborhood_size+1]
                common_neighbors = np.intersect1d(neighbors_i, neighbors_j).size
                local_edge_density[i,j] = common_neighbors / local_neighborhood_size

    for i in range(n):
        for j in range(n):
            if i != j:
                # Inverse distance
                inverse_distance = 1 / (distance_matrix[i, j] + small_constant)

                # Degree penalty
                degree_penalty = (node_degrees[i] + node_degrees[j]) ** degree_penalty_exponent

                # Combined heuristic value
                heuristics[i, j] = inverse_distance / (1 + (degree_penalty * (distance_matrix[i, j] / avg_distance)))

                # Incorporate local edge density
                heuristics[i, j] *= (1 + local_edge_density[i, j])

            else:
                heuristics[i, j] = 0

    # Dynamic sparsification: Remove edges with low heuristic values relative to local context
    for i in range(n):
        row = heuristics[i, :]
        threshold = np.percentile(row[row > 0], 60)  # Adjusted percentile
        heuristics[i, row < threshold] = 0

    # Further sparsification based on distance threshold
    distance_threshold = np.percentile(distance_matrix[distance_matrix != 0], 25) #Reduced distance threshold
    for i in range(n):
        for j in range(n):
            if distance_matrix[i, j] > distance_threshold and heuristics[i, j] > 0:
                heuristics[i, j] *= 0.3

    return heuristics
```
