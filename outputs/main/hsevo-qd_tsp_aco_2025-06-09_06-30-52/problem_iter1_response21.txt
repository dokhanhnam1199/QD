```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improves upon heuristics_v1 by incorporating a measure of node centrality.
    Nodes that are centrally located are likely to be part of a good tour.
    Uses stochastic solution sampling, which is analogous to how light samples
    various spacetime paths.  We consider a simple temperature parameter for
    exploration.

    Args:
        distance_matrix: A numpy ndarray representing the distance matrix.

    Returns:
        A numpy ndarray representing the heuristic values for each edge.
    """
    n = distance_matrix.shape[0]
    temperature = 1.0  # Adjust this for more or less exploration. Lower values mean more exploitation.

    # 1. Inverse distance heuristic
    heuristic = 1 / (distance_matrix + 1e-9) # adding small value to prevent divide by zero

    # 2. Node centrality heuristic (closeness centrality approximation)
    # A node is central if it's close to all other nodes.
    total_distances = np.sum(distance_matrix, axis=0)
    centrality = 1 / (total_distances + 1e-9)
    centrality_matrix = np.tile(centrality, (n, 1)) + np.tile(centrality.reshape(-1, 1), (1, n))

    # 3. Combine heuristics
    combined_heuristic = heuristic * centrality_matrix

    # 4. "Temperature" application: Introduce stochasticity
    #   Higher temperatures broaden exploration
    random_noise = np.random.rand(n, n) * temperature
    combined_heuristic = combined_heuristic + random_noise

    # 5. Normalize (optional, but can help with numerical stability downstream)
    combined_heuristic = combined_heuristic / np.max(combined_heuristic)

    return combined_heuristic
```
