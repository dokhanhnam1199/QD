```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A heuristic function for the Traveling Salesman Problem (TSP) using a combination of
    inverse distance, simulated annealing-inspired edge weighting, and shortest path considerations.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix
                                         between cities. distance_matrix[i, j] is the distance
                                         between city i and city j.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix, representing
                    the heuristic values for each edge. Higher values indicate more promising
                    edges to include in a solution.

    Based on Feynman's principles, let's embrace randomness and multiple paths!  We'll use
    a probabilistic approach, inspired by quantum mechanics, to guide the search.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance:  Shorter distances are generally better.
    inverse_distance = 1.0 / (distance_matrix + 1e-6)  # Avoid division by zero

    # 2. Simulated Annealing-inspired Weighting:  Encourage exploration of diverse edges
    #    early on and gradually focus on better edges as the "temperature" decreases.
    temperature = 10.0  # Initial temperature (can be tuned)
    annealing_rate = 0.95 # Rate at which the temperature decreases
    edge_probabilities = np.exp(-distance_matrix / temperature)

    # 3. Shortest Path Consideration: Favor edges that lie on shortest paths between nodes.
    #    This encourages building longer paths.
    shortest_paths = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                 # Approximate shortest path influence. A better TSP solution
                 # is very likely to use an edge on a short path, so boost
                 # such edge probabilities
                 # Here, we take the average of the distances between two end nodes and other nodes.
                shortest_paths[i,j] = np.mean(distance_matrix[[i, j]])
    shortest_paths = 1 / (shortest_paths + 1e-6)
    # Normalize edge_probabilities for each row to sum up to one
    row_sums = edge_probabilities.sum(axis=1, keepdims=True)
    normalized_edge_probabilities = edge_probabilities / row_sums


    # Combine the heuristics (weighted sum)
    alpha = 0.5  # Weight for inverse distance
    beta = 0.3   # Weight for annealing-inspired probabilities
    gamma = 0.2  # Weight for shortest path considerations

    heuristic_matrix = alpha * inverse_distance + beta * normalized_edge_probabilities + gamma* shortest_paths


    # Ensure no NaN values
    heuristic_matrix = np.nan_to_num(heuristic_matrix)


    #Cool down for exploration vs. exploitation (mimicking Simulated Annealing)
    temperature *= annealing_rate

    return heuristic_matrix
```
