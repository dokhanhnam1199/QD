```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Tesla's Heuristic for TSP Edge Prioritization - Version 2: Electromagnetically Inspired

    This heuristic leverages inverse distance, node degree preference, and clustering tendencies
    to generate a prior indicator matrix for edges in the Traveling Salesperson Problem.
    Inspired by electromagnetic principles, shorter distances attract (higher probability),
    nodes with more connections initially receive higher probability, and local clusters are encouraged.

    Args:
        distance_matrix (np.ndarray): A square matrix representing distances between nodes.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing the prior
                      probability of including each edge in the TSP tour.  Higher values
                      indicate a higher likelihood of inclusion.
    """
    n = distance_matrix.shape[0]

    # 1. Inverse Distance Component (like electrostatic force)
    inverse_distance = 1.0 / (distance_matrix + np.eye(n))  # Add identity to avoid division by zero

    # 2. Node Degree Preference (nodes with slightly more options may lead to better global tours, avoid getting stuck)
    degree_preference = np.ones((n, n)) # initialize to 1 to avoid mult by zero issues.
    for i in range(n):
        #Give degree preference to edges associated with nodes that have a high degree using inverse_distance
        degrees = np.sum(inverse_distance[i,:])
        degree_preference[i,:] = degrees
        degree_preference[:,i] = degrees

    degree_preference = degree_preference / np.max(degree_preference)

    # 3. Clustering Tendency (encourage local connections - higher current flow)
    clustering_tendency = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                # Check common neighbors to estimate clustering
                common_neighbors = 0
                for k in range(n):
                    if k != i and k != j:
                        common_neighbors += (inverse_distance[i, k] > 0 and inverse_distance[j, k] > 0)
                clustering_tendency[i, j] = common_neighbors


    # 4. Combined Heuristic
    heuristic_matrix = inverse_distance * degree_preference * (1 + 0.1*clustering_tendency) #Weighting terms carefully


    # Normalize for better stochastic sampling
    heuristic_matrix = heuristic_matrix / np.max(heuristic_matrix)

    return heuristic_matrix
```
