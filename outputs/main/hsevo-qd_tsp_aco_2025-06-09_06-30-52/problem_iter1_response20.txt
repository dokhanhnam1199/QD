```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Generates heuristics for the Traveling Salesman Problem based on distance matrix.

    This version incorporates a combination of inverse distance, node degree,
    and a randomized smoothing factor to guide the search process.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Calculate inverse distance with handling for zero distances
    inverse_distance = np.where(distance_matrix > 0, 1 / distance_matrix, 0)

    # Node degree component - penalize nodes that are too close to too many others.
    node_degrees = np.sum(inverse_distance, axis=0)

    # Normalize node degrees
    normalized_degrees = (node_degrees - np.min(node_degrees)) / (np.max(node_degrees) - np.min(node_degrees) + 1e-9)  # Avoid division by zero
    
    # Heuristic is high when the edge is short, and the degrees of connected nodes are low
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics[i, j] = inverse_distance[i, j] * (1 - normalized_degrees[i]) * (1 - normalized_degrees[j])

    # Add a small random component to avoid getting stuck in local optima
    random_component = np.random.rand(n, n) * 0.01
    heuristics = heuristics + random_component

    return heuristics
```
