```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Implements a more sophisticated heuristic for the Traveling Salesman Problem (TSP)
    based on a combination of distance, node degree (implicitly), and a randomized exploration factor.

    The heuristic aims to prioritize shorter edges while also encouraging exploration
    of less-connected nodes, and adding some stochasticity to prevent premature convergence
    to local optima.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix
                                      between the nodes. distance_matrix[i][j] is the
                                      distance between node i and node j.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix, where each
                    element represents a heuristic score for the corresponding edge.
                    Higher scores indicate a more promising edge.

    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Heuristic based on inverse distance and some randomness.
    for i in range(n):
        for j in range(n):
            if i != j:  # Avoid self-loops
                # Inverse distance term - prioritize shorter edges
                distance_heuristic = 1.0 / (distance_matrix[i, j] + 1e-9)  # add a small constant to prevent division by zero

                # Random exploration term - adding stochasticity, higher range of values with higher randomness
                random_exploration = np.random.rand() * 0.5  # Add small randomness

                # combine them together, weighting might need to be adjusted.
                heuristic_matrix[i, j] = distance_heuristic + random_exploration

            else:
                heuristic_matrix[i, j] = 0  # Do not consider self-loops

    return heuristic_matrix
```
