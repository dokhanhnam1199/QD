```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines inverse distance, degree penalty, sparsification, and local structure analysis.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    avg_distance = np.mean(distance_matrix[distance_matrix != 0])
    small_constant = 1e-6
    avg_distance_weight = 0.5

    node_degrees = np.sum(distance_matrix < (avg_distance * 1.5), axis=1)

    for i in range(n):
        for j in range(n):
            if i != j:
                degree_penalty = (node_degrees[i] + node_degrees[j])**1.5
                heuristics[i, j] = (1 / (distance_matrix[i, j] + small_constant)) / (1 + (degree_penalty * (distance_matrix[i, j]/avg_distance) * avg_distance_weight))

                # Local structure analysis: Encourage edges connecting to diverse neighborhoods
                neighbor_similarity = 0
                neighbors_i = np.where(distance_matrix[i, :] < avg_distance * 1.2)[0]
                neighbors_j = np.where(distance_matrix[j, :] < avg_distance * 1.2)[0]

                if len(neighbors_i) > 0 and len(neighbors_j) > 0:
                    # Calculate the Jaccard index to measure neighborhood similarity
                    intersection = len(np.intersect1d(neighbors_i, neighbors_j))
                    union = len(np.union1d(neighbors_i, neighbors_j))
                    if union > 0:
                        neighbor_similarity = intersection / union
                    heuristics[i, j] *= (1 - 0.5 * neighbor_similarity)  # Penalize edges connecting similar neighborhoods

                #Edge Importance
                edge_importance = 0
                closest_nodes_i = np.argsort(distance_matrix[i,:])[1:4]
                closest_nodes_j = np.argsort(distance_matrix[j,:])[1:4]
                edge_importance = np.mean(distance_matrix[i, closest_nodes_i]) + np.mean(distance_matrix[j, closest_nodes_j])
                heuristics[i,j] /= (distance_matrix[i, j]/ (edge_importance + small_constant))

            else:
                heuristics[i, j] = 0

    # Adaptive Sparsification based on degree
    for i in range(n):
        row = heuristics[i, :]
        threshold = np.percentile(row[row > 0], max(50, 85 - node_degrees[i])) #Sparsify less for high degree nodes
        heuristics[i, row < threshold] = 0

    # Further penalize long edges with high degree nodes
    distance_threshold = np.percentile(distance_matrix[distance_matrix != 0], 25)
    for i in range(n):
        for j in range(n):
          if distance_matrix[i,j] > distance_threshold and heuristics[i,j] > 0:
             heuristics[i,j] *= (0.25 + 0.75 * (1 - (node_degrees[i] + node_degrees[j])/(2*n)))

    return heuristics
```
