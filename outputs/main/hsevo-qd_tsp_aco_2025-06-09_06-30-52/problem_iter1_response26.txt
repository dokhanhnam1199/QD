```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Hawking's heuristics for TSP edge selection.
    Combines inverse distance with a simulated "gravitational lensing" effect
    to bias towards edges that are likely to be part of good solutions.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i, j] is the distance
                                     between city i and city j. Should be non-negative.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, containing heuristics values.
                    Higher values indicate a more promising edge.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance (short distances are good)
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add small value to avoid division by zero

    # "Gravitational Lensing" - edges that "connect" nearby regions are favored.
    # We compute a centrality measure for each node, and then bias edges connecting nodes
    # with higher centrality values.  Nodes are central if they have shorter distances
    # to many other nodes.

    node_centrality = np.sum(inverse_distance, axis=1) # Sum of inverse distances to each node

    # Bias heuristics by node centrality. Higher values here imply closer distances to other nodes.
    for i in range(n):
        for j in range(n):
            heuristics[i, j] = inverse_distance[i, j] * (node_centrality[i] + node_centrality[j])
    
    #Further enhance good edges with inverse of 2nd nearest neighbour distance * centrality difference

    neighbor_distances = np.sort(distance_matrix, axis=1)[:,1]  #2nd nearest distance to any other node

    for i in range(n):
      for j in range(n):

        heuristics[i, j] = heuristics[i, j] + (1.0 / (neighbor_distances[i] + 1e-9) * (abs(node_centrality[i]- node_centrality[j]))) /1000.0  #Adding an insignificant part of 2nd nearest to enhance good values more

    # Ensure symmetry and zero out the diagonal
    heuristics = (heuristics + heuristics.T) / 2.0  # Ensure symmetry
    np.fill_diagonal(heuristics, 0)  # No self-loops

    return heuristics
```
