```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Galileo's Heuristic for TSP edge selection.

    Prioritizes short distances, penalizes edges connecting to far-away nodes,
    and encourages diversity by favoring edges between nodes with dissimilar total distances.

    Args:
        distance_matrix: A numpy array representing the distance matrix between cities.

    Returns:
        A numpy array of the same shape as distance_matrix, representing edge selection heuristics.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Calculate total distances for each city
    total_distances = np.sum(distance_matrix, axis=1)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # Avoid self-loops
            else:
                distance = distance_matrix[i, j]
                if distance == 0:  # Handle zero distance to avoid division by zero.
                    heuristics[i, j] = 1e12 # Set to a huge value to prioritize connecting
                else:

                    # Base heuristic: Inverse of distance
                    h = 1.0 / distance

                    # Penalty for connecting to far-away nodes
                    h /= (total_distances[i] + total_distances[j]) / (2 * np.mean(total_distances)) #Normalize

                    # Encouraging edges between diverse nodes (different total distance)
                    h *= (1 + np.abs(total_distances[i] - total_distances[j]) / np.mean(total_distances)) #Scale the differences, normalized

                    heuristics[i, j] = h
    return heuristics
```
