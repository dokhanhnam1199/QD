```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Einstein's heuristics for TSP, version 2: A symphony of inverse distances,
    node degrees, and a touch of gravitational potential.

    This heuristic combines several factors to estimate the desirability of each edge:

    1. Inverse Distance:  Shorter distances are more desirable.
    2. Node Degree Penalty:  Penalizes edges connected to nodes with a high "degree"
        (number of nearby nodes). This discourages premature closing of subtours.  We're
        analogizing this to a high "gravitational potential" - nodes with too many
        connections are avoided until absolutely necessary.
    3. Global Average Distance: Uses the average distance in the matrix to normalize
       the effect of very short and very long distances, making it scale-invariant.
    4.  Add a small constant to avoid division by zero

    Args:
        distance_matrix (np.ndarray):  A square matrix where distance_matrix[i, j]
            is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element
            represents the desirability score of including the corresponding edge
            in the TSP tour. Higher values indicate more desirable edges.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    avg_distance = np.mean(distance_matrix[distance_matrix != 0]) #Avoid including self-loops when computing the mean
    small_constant = 1e-9  # Add to the denominator for stability

    # Calculate "node degree" based on proximity. Number of other cities within
    # certain threshold distance. The intuition here is nodes which are very central
    # should not be immediately visited to prevent early sub-cycles.
    node_degrees = np.sum(distance_matrix < avg_distance, axis=1)

    for i in range(n):
        for j in range(n):
            if i != j:  # Avoid self-loops
                # Node degree penalty is computed to suppress visiting very central nodes before necessary.
                degree_penalty = (node_degrees[i] + node_degrees[j])  # Total degree of the two nodes
                # Combine inverse distance with node degree penalty. The degree penalty is scaled with avg distance so that when average distance is large
                # the suppression due to degree penalty is also large.
                heuristics[i, j] = (1 / (distance_matrix[i, j] + small_constant)) / (1 + (degree_penalty * (distance_matrix[i, j]/avg_distance)))
            else:
                heuristics[i, j] = 0  # Self-loops are undesirable

    return heuristics
```
