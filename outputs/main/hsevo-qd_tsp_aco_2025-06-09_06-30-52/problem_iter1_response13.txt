```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A more sophisticated heuristic for the Traveling Salesman Problem (TSP).
    This heuristic combines several factors to estimate the desirability of including each edge in a solution.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                       distance_matrix[i, j] is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element
                    represents the heuristic value of including the corresponding edge in the TSP tour.
                    Higher values indicate a more promising edge.

    Heuristic Factors:
    1. Inverse Distance: Shorter edges are generally more desirable.  1 / distance.
    2. Nearest Neighbor Consideration: For each node, edges connecting to its nearest neighbors
       are prioritized.  We compute the average rank among the neighbors
    3. Global Connectivity: We use a simple clustering concept, penalizing edges that connect
        nodes that are "too far" apart from a more global connectivity perspective.

    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Inverse distance
    inverse_distance = 1 / (distance_matrix + 1e-9) # Adding a small constant to avoid division by zero.

    # Nearest Neighbor Consideration: rank neighbors in increasing order of distance
    nearest_neighbors = np.argsort(distance_matrix, axis=1)

    neighbor_rank = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            neighbor_rank[i, nearest_neighbors[i,j]] = j

    avg_rank = (neighbor_rank + neighbor_rank.T) / 2 #Symmetrize rank, useful when we want the two nodes to have the same heuristic
    rank_score = np.clip(1 - (avg_rank / n), 0, 1)  #Rank score closer to 1 is preferred.

    # Global Connectivity
    mean_distance = np.mean(distance_matrix)
    connectivity_score = np.exp(-distance_matrix / mean_distance) #Exponential penalty, where distance exceeding the average is penalized

    # Combine factors
    heuristic_matrix = (inverse_distance + rank_score + connectivity_score) / 3 #average them.  Can also be weighted by different factors if needed.
    #zero out diagnal elements

    np.fill_diagonal(heuristic_matrix,0)

    return heuristic_matrix
```
