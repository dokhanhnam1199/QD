```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Hawking's Heuristic for TSP: A blend of gravitational attraction (inverse distance),
    Hawking radiation (stochasticity), and the Bekenstein-Hawking entropy (distance-dependent noise).

    The core idea: shorter distances are more attractive (higher probability), but with a
    'Hawking radiation' effect that allows for exploration of less obvious edges. The
    magnitude of this 'radiation' scales with the typical distance.

    Args:
        distance_matrix: A numpy array representing the distances between cities.
                         distance_matrix[i, j] is the distance between city i and city j.
                         Assume it is a symmetric matrix with zeros on the diagonal.

    Returns:
        A numpy array of the same shape as distance_matrix, representing the heuristic
        values for each edge. Higher values indicate a more promising edge.
    """
    n = distance_matrix.shape[0]

    # 1. Gravitational Attraction (Inverse Distance)
    attraction = 1.0 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # 2. Hawking Radiation (Stochasticity)
    #   - Calculate the average distance as a measure of "temperature." Higher temperature means
    #     more exploration/radiation.
    avg_distance = np.mean(distance_matrix[np.triu_indices_from(distance_matrix, k=1)])  # Avoids double counting and diagonals

    #   - Introduce a random perturbation scaled by the average distance. This acts like the
    #     "Hawking radiation" â€“ random fluctuations that allow the solution to escape local minima.
    radiation = np.random.normal(0, avg_distance * 0.1, size=(n, n))  # Standard deviation is 10% of avg distance

    # 3. Bekenstein-Hawking Entropy (Distance-Dependent Noise)
    #   - Add a small amount of noise that is proportional to the distance. Longer distances
    #     have more inherent uncertainty (entropy).  This discourages very long jumps early on but allow exploration
    #      later.
    entropy_noise = np.random.normal(0, distance_matrix * 0.05, size=(n, n)) # 5% noise based on distance.

    # 4. Combine the effects
    heuristics = attraction + radiation + entropy_noise

    # 5. Normalize the heuristics to ensure that they are probabilities, and zero on the diagonal.
    heuristics = (heuristics - np.min(heuristics)) / (np.max(heuristics) - np.min(heuristics) + 1e-9)  #Scale to between 0 and 1
    np.fill_diagonal(heuristics, 0) # No loops

    return heuristics
```
