```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Hawking-inspired heuristics for the Traveling Salesman Problem (TSP).

    This version incorporates several ideas:

    1.  **Inverse Distance:**  Shorter distances are inherently more desirable.  We start with the reciprocal of the distance.

    2.  **Node Degree Preference:**  Nodes with higher average proximity to other nodes might be good hubs.  We estimate a 'node potential' based on the average inverse distance to other nodes.  Edges connecting to high-potential nodes get a boost.

    3.  **Diversity Encouragement:** To avoid getting stuck in local optima (a deep gravitational well, if you will), penalize edges between nodes that are already strongly connected to many others. This encourages exploration of less-traveled regions.

    4.  **Zero Distance Handling:** Ensure that zero distance cases are handled robustly by assigning maximum heuristic value

    Args:
        distance_matrix: A NumPy ndarray representing the distance matrix between cities.

    Returns:
        A NumPy ndarray of the same shape as distance_matrix, representing the heuristic values for each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance with handling for zero distances
    inverse_distance = np.where(distance_matrix > 0, 1 / distance_matrix, np.inf)  # Use np.inf for zero distances

    # Node potential (average inverse distance to other nodes)
    node_potential = np.sum(inverse_distance, axis=1) / (n - 1)  # Avoid division by zero

    # Encourage connections to nodes with high potential. Note, adding a small number to np.sum(heuristic_matrix[i,:]) can avoid zero division, in edge_penalty computation
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] = inverse_distance[i, j] * (node_potential[i] + node_potential[j]) / 2

    # Edge penalty based on the connectivity of the adjacent nodes
    for i in range(n):
      for j in range(n):
        if i!=j:
            edge_penalty = np.sum(heuristic_matrix[i,:]) + np.sum(heuristic_matrix[:,j])  #Total strength connected to node i and j
            # Normalize the value such that the magnitude can be controlled
            heuristic_matrix[i,j] = heuristic_matrix[i,j]/(1+ edge_penalty)


    # Handle any infinite heuristic values (due to zero distances) by setting to max possible finite float number
    heuristic_matrix[np.isinf(heuristic_matrix)] = np.finfo(np.float64).max


    return heuristic_matrix
```
