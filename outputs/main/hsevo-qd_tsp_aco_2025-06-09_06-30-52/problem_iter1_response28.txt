```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics function for the Traveling Salesman Problem (TSP) based on distance and node degree considerations.

    This heuristic combines inverse distance with a node degree bias.  Edges connected to nodes with lower
    degree (i.e., fewer connections to other nearby nodes) are considered more promising.  This encourages
    exploration of less-connected regions of the graph, hopefully avoiding early convergence to poor local optima.

    Args:
        distance_matrix (np.ndarray): A square, symmetric NumPy array representing the distance matrix.
                                       distance_matrix[i, j] is the distance between city i and city j.

    Returns:
        np.ndarray: A NumPy array of the same shape as distance_matrix, representing the prior indicators
                      of how promising it is to include each edge in a solution.  Higher values indicate
                      more promising edges.  Returns 0 if the distance is 0 to avoid division by zero errors.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Calculate a degree-like measure for each node (sum of inverse distances)
    node_degrees = np.zeros(n)
    for i in range(n):
        for j in range(n):
            if i != j and distance_matrix[i, j] > 0:
                node_degrees[i] += 1 / distance_matrix[i, j] #Smaller distances contribute more.

    # Normalize node degrees (optional, but often helps)
    if np.any(node_degrees > 0): #handle disconnected nodes by not dividing by zero.
      min_degree = np.min(node_degrees[node_degrees > 0])
      max_degree = np.max(node_degrees)
      if max_degree > min_degree:  #Avoid division by zero again
          normalized_node_degrees = (node_degrees - min_degree) / (max_degree - min_degree)
      else:
          normalized_node_degrees = np.zeros(n)


      for i in range(n):
          for j in range(n):
              if distance_matrix[i, j] > 0:
                  # Combine inverse distance with a degree penalty (lower degree = more promising)
                  # The penalty is higher if nodes are more connected to discourage connection
                  # between highly connected nodes
                  # heuristics[i, j] = (1 / distance_matrix[i, j]) * (1 - (normalized_node_degrees[i] + normalized_node_degrees[j]) / 2)  # original attempt
                  heuristics[i, j] = (1 / distance_matrix[i, j]) * (1 + (1- normalized_node_degrees[i]) + (1 - normalized_node_degrees[j]) / 2) #higher if smaller degree

              else:
                  heuristics[i, j] = 0  # Avoid division by zero
    else:  #All distances are 0. Impossible case.
      return np.ones_like(distance_matrix) #return equal weight
    return heuristics
```
