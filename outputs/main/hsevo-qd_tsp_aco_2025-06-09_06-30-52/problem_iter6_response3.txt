```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improved heuristics combining distance, node degree, global connectivity, and adaptive sparsification.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)
    avg_distance = np.mean(distance_matrix[distance_matrix != 0])
    small_constant = 1e-6
    degree_weight = 0.7
    connectivity_weight = 0.3

    # Node degree penalty
    node_degrees = np.sum(distance_matrix < (avg_distance * 1.5), axis=1)

    # Global connectivity estimate (crude approximation)
    total_distance = np.sum(distance_matrix)
    connectivity_factor = n * avg_distance / total_distance  # Higher value indicates better global connectivity

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor
                distance_factor = 1 / (distance_matrix[i, j] + small_constant)

                # Degree penalty (normalized)
                degree_penalty = (node_degrees[i] + node_degrees[j]) / (2 * n)

                # Combined heuristic value
                heuristics[i, j] = distance_factor / (1 + degree_weight * degree_penalty - connectivity_weight * connectivity_factor)

            else:
                heuristics[i, j] = 0

    # Adaptive Sparsification: Remove edges based on their relative importance within the graph
    for i in range(n):
        row = heuristics[i, :]
        # Calculate percentile dynamically, ensuring at least some edges are retained
        threshold_percentile = min(95, max(50, 75 + 10 * connectivity_factor)) #Adjust percentile dynamically
        threshold = np.percentile(row[row > 0], threshold_percentile)
        heuristics[i, row < threshold] = 0

    return heuristics
```
