```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improves on the basic 1/distance heuristic for the TSP. This version
    incorporates a few more considerations:

    1.  **Inverse Distance Squared:** Gives more weight to very short edges.
    2.  **Node Degree Bias:**  Penalizes connecting to nodes that already have
        a high "attraction" based on short edge connections to others.
        The intuition is to encourage more even distribution of connections.

    Args:
        distance_matrix: An NxN numpy array representing the distances
                         between N nodes.  distance_matrix[i, j] is the
                         distance from node i to node j.

    Returns:
        An NxN numpy array of heuristics.  Higher values indicate edges that
        are more promising to include in a TSP solution.  The output array
        has the same shape as the input distance matrix.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Inverse Distance Squared
    heuristics = 1 / (distance_matrix**2 + 1e-9)  # Avoid division by zero

    # Node Degree Bias (approximate/soft penalty)
    node_attraction = np.sum(heuristics, axis=0)  # Attractiveness of each node

    for i in range(n):
        for j in range(n):
            if i != j:  # Avoid self-loops
                # Penalize edges connecting to high-attraction nodes
                heuristics[i, j] /= (node_attraction[i] * node_attraction[j] + 1e-9)**0.25 # softer penalty
                heuristics[i, j] /= distance_matrix[i,j]**0.25 #softer bias for short edges in distance_matrix

    return heuristics
```
