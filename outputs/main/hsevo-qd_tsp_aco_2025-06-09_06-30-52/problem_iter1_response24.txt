```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Tesla's Lightning-Guided Heuristic for TSP.

    This heuristic combines several intuitions to estimate the desirability
    of including each edge in a Traveling Salesman Problem (TSP) solution.

    It considers:
    1.  **Inverse Distance:** Shorter distances are generally better (like v1).
    2.  **Node Degree Penalty:** Nodes connected to many nearby nodes should
        have lower edge desirability to avoid getting trapped in dense regions.
    3.  **Global Minimum Connection Cost:** Encourages connection to nodes
        with the globally lowest connection cost
    """

    num_nodes = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Inverse Distance
    inverse_distance = 1 / (distance_matrix + 1e-9) # Avoid division by zero
    heuristics = inverse_distance

    # Node Degree Penalty
    node_degrees = np.sum(inverse_distance, axis=0) - np.diag(inverse_distance)
    degree_penalty = np.outer(node_degrees, node_degrees)
    heuristics = heuristics / (degree_penalty + 1) # +1 to avoid division by zero and scale

    # Global Minimum Connection Cost. Favors connecting to generally cheap nodes.
    min_costs = np.min(distance_matrix, axis=1, keepdims=True)  # Find the closest node for each node
    cost_factor = 1/(min_costs + 1e-9)
    #Heuristics of linking to cost factors, where cost factor of one node is broadcasted as preference to link.
    connection_cost_incentive = np.outer(cost_factor, cost_factor.T)
    heuristics = heuristics * connection_cost_incentive
    
    # Ensure diagonal elements are zero (no self-loops)
    np.fill_diagonal(heuristics, 0)
    return heuristics
```
