```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics function for the Traveling Salesman Problem (TSP).
    This version incorporates:
        1. Inverse distance: Shorter distances are more desirable.
        2. Edge Centrality:  Edges connecting to more central nodes are generally better.
        3. Distance variance: Prioritize edges that have relatively more similar length
        4. Edge Consistency: Edges that can likely be part of a 'smooth' tour are better. This is a weak consistency

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between nodes.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing the desirability
                     of including each edge in a TSP solution.  Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]

    # 1. Inverse distance (basic heuristic)
    heuristic_matrix = 1 / (distance_matrix + 1e-9)  # Add a small value to avoid division by zero


    # 2. Node Centrality based on Shortest Average Path Distance
    avg_distances = np.mean(distance_matrix, axis=1)
    node_centrality = 1 / (avg_distances + 1e-9)
    for i in range(n):
      for j in range(n):
        heuristic_matrix[i,j] *= (node_centrality[i] + node_centrality[j])

    #3. Distance Variance: Normalize the distances to a consistent distribution, thus variance can be calculated.
    #    Smaller variance edges are preferred as these are 'consistent'
    min_dist = np.min(distance_matrix[distance_matrix > 0])
    variance = np.var(distance_matrix[distance_matrix > 0])
    heuristic_matrix *= np.exp(- (distance_matrix - min_dist)**2 / (2 * variance))

    #4 Edge consistency: penalize large jumps: this requires normalizing each row and column, 
    row_sums = distance_matrix.sum(axis=1, keepdims=True)
    col_sums = distance_matrix.sum(axis=0, keepdims=True)
    normalized_matrix_row = distance_matrix / (row_sums + 1e-9)
    normalized_matrix_col = distance_matrix / (col_sums.T + 1e-9)

    consistency = 1 - (normalized_matrix_row + normalized_matrix_col)

    heuristic_matrix *= np.clip(consistency, a_min = 0, a_max = 1)


    # Set diagonal elements to 0 (no self-loops)
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
