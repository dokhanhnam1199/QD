```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    TSP heuristics based on a combination of inverse distance,
    nearest neighbor information, and a penalty for long edges
    that might cut across the middle of the tour.

    Args:
        distance_matrix: A numpy array representing the distance matrix.

    Returns:
        A numpy array of the same shape as distance_matrix,
        representing the heuristic scores for each edge.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance component
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small value to avoid division by zero

    # Nearest neighbor component
    nearest_neighbors = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        sorted_indices = np.argsort(distance_matrix[i, :])
        # Consider the k nearest neighbors (excluding itself)
        k = min(5, n - 1)  # Ensure k is not larger than available neighbors
        for j in sorted_indices[1:k + 1]:
            nearest_neighbors[i, j] = 1
    # Make symmetric
    nearest_neighbors = np.maximum(nearest_neighbors, nearest_neighbors.T)

    # Edge "crossing" penalty (encourages local connections)
    # Penalizes long edges by considering the average distance
    # from each node to all other nodes
    avg_distances = np.mean(distance_matrix, axis=1, keepdims=True) + np.mean(distance_matrix, axis=0, keepdims=True)
    crossing_penalty = np.exp(-distance_matrix / (avg_distances * 0.5 + 1e-9)) # Ensure no division by zero


    # Combine the components with weights
    heuristics = 0.6 * inverse_distance + 0.3 * nearest_neighbors + 0.1 * crossing_penalty

    return heuristics
```
