```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for TSP based on distance, node degree, and a bit of randomness.

    Args:
        distance_matrix (np.ndarray): Distance matrix representing the distances between cities.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix,
                      representing the prior indicators for each edge.
                      Higher values indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance (shorter edges are better)
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # Node degree preference: avoid high-degree nodes early on
    degree_preference = np.ones_like(distance_matrix, dtype=float)

    for i in range(n):
        # Calculate the sum of inverse distances for each node
        node_strength = np.sum(inverse_distance[i,:]) + np.sum(inverse_distance[:,i]) - inverse_distance[i,i]

        # Penalize edges connected to nodes with high strength(i.e. likely to be high degree)
        degree_preference[i, :] /= (node_strength + 1e-9)
        degree_preference[:, i] /= (node_strength + 1e-9)

    # Combine the heuristics: inverse distance * degree penalty
    heuristics = inverse_distance * degree_preference

    # Add a small amount of noise to diversify the search
    noise = np.random.rand(n, n) * 0.1
    heuristics += noise

    # Ensure symmetry (TSP is undirected) and zero diagonal.
    heuristics = (heuristics + heuristics.T) / 2
    np.fill_diagonal(heuristics, 0)

    return heuristics
```
