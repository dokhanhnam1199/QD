```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A heuristic for the Traveling Salesman Problem (TSP).

    This heuristic combines several ideas:

    1.  **Inverse Distance:** Closer cities are generally preferred.
    2.  **Minimum Spanning Tree Influence:** Edges that are likely to be in a
        Minimum Spanning Tree (MST) are more promising as they connect components
        and help maintain connectivity.  This is approximated by rewarding edges
        that connect nodes that are far apart from the *average* distance to their
        neighbors. This promotes bridging disparate clusters.
    3.  **Penalty for isolated edges**. Avoids premature edge connections for nodes that otherwise have large distances to other neighbours.

    Args:
        distance_matrix: A numpy array representing the distance matrix between cities.

    Returns:
        A numpy array of the same shape as distance_matrix, representing the
        heuristic values for each edge. Higher values indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance (closer is better)
    heuristic_matrix = 1 / (distance_matrix + 1e-9)  # Add a small value to avoid division by zero

    # MST Influence (edges connecting far-apart cities are better)
    avg_neighbor_distances = np.zeros(n)
    for i in range(n):
        # Calculate the average distance to the nearest neighbors (excluding self)
        neighbors = np.argsort(distance_matrix[i])[1:]
        avg_neighbor_distances[i] = np.mean(distance_matrix[i][neighbors[:min(3,n-1)]]) #average with top 3 neighbours to avoid a single point having large effect

    for i in range(n):
        for j in range(n):
            if i != j:
                # Reward edges that connect cities that are "far" from their average neighbors
                heuristic_matrix[i, j] += (avg_neighbor_distances[i] + avg_neighbor_distances[j]) / (2 * np.mean(avg_neighbor_distances) + 1e-9)
                # Penalize nodes that already have large neighbour distance
                heuristic_matrix[i, j] -= (distance_matrix[i,j]>avg_neighbor_distances[i])*0.5
                heuristic_matrix[i, j] -= (distance_matrix[i,j]>avg_neighbor_distances[j])*0.5


    return heuristic_matrix
```
