{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\nCurrent heuristics:\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines inverse distance with node degree penalty to avoid subtours.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix)\n    avg_distance = np.mean(distance_matrix[distance_matrix != 0])\n    small_constant = 1e-9\n\n    node_degrees = np.sum(distance_matrix < avg_distance, axis=1)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                degree_penalty = (node_degrees[i] + node_degrees[j])\n                heuristics[i, j] = (1 / (distance_matrix[i, j] + small_constant)) / (1 + (degree_penalty * (distance_matrix[i, j]/avg_distance)))\n            else:\n                heuristics[i, j] = 0\n\n    return heuristics\n\nNow, think outside the box write a mutated function `heuristics_v2` better than current version.\nYou can use some hints below:\n- - Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\nOkay, let's refine self-reflection for better heuristic design, avoiding common pitfalls and focusing on actionable insights.\n\nHere's a breakdown:\n\n*   **Keywords:** Iterative refinement, problem-specific knowledge, solution context, evaluation metrics, adaptive adjustment.\n*   **Advice:** After establishing a baseline heuristic, rigorously analyze its weaknesses by understanding where the algorithm makes wrong calls. Then, inject problem-specific information related to these areas. Quantify improvements with pre-defined metrics.\n*   **Avoid:** \"Blind\" refinement without analyzing current heuristic performance. Overfitting to limited training instances. Neglecting evaluation metrics.\n*   **Explanation:** Current heuristic's decision patterns and weaknesses are thoroughly examined and addressed using tailored problem-specific knowledge. Evaluate performance based on defined metrics.\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}