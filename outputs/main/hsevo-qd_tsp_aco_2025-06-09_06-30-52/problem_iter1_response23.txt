```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Enhanced heuristics for the Traveling Salesman Problem (TSP) based on stochastic solution sampling principles.
    This version incorporates edge reciprocity, distance scaling, and perturbation to improve solution diversity and quality.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between cities.
                                      distance_matrix[i][j] is the distance from city i to city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each entry indicates
                     the desirability of including that edge in the TSP tour. Higher values indicate
                     more promising edges.
    """

    n = distance_matrix.shape[0]

    # Avoid division by zero and self-loops.
    safe_distance_matrix = distance_matrix.copy()
    safe_distance_matrix[safe_distance_matrix == 0] = np.inf
    np.fill_diagonal(safe_distance_matrix, np.inf)

    # 1. Inverse distance: Shorter distances are generally better.
    inverse_distance = 1 / safe_distance_matrix

    # 2. Reciprocity:  Edges that are short in both directions are highly desirable.
    reciprocity = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            reciprocity[i, j] = inverse_distance[i, j] * inverse_distance[j, i]

    # 3. Scale distances by the average distance to help distinguish near and far cities.
    avg_distance = np.mean(distance_matrix[distance_matrix != np.inf]) #consider only valid edges
    scaled_distance = distance_matrix / avg_distance
    scaled_inverse_distance = 1 / (1 + scaled_distance) # Use 1+scaled distance to avoid infinities and limit high values

    # 4. Perturbation:  Add a small random element to break symmetry and explore diverse solutions.
    perturbation = np.random.normal(0, 0.1, size=(n, n))  # Gaussian noise, adjust stddev as needed

    # Combine heuristics. Weigh their relative importance based on experimental observations.
    heuristic_matrix = 0.5 * inverse_distance + 0.3 * reciprocity + 0.2 * scaled_inverse_distance + 0.01 * perturbation
    # Ensure no infinities or nans are returned (can happen due to divisions)
    heuristic_matrix[np.isinf(heuristic_matrix)] = 0
    heuristic_matrix[np.isnan(heuristic_matrix)] = 0

    return heuristic_matrix
```
