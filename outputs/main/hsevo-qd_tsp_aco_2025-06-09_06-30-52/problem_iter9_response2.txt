```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combines inverse distance, degree penalty, local search encouragement, and dynamic sparsification.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)
    avg_distance = np.mean(distance_matrix[distance_matrix != 0])
    small_constant = 1e-6
    
    # Degree penalty: penalize high-degree nodes to encourage exploration
    node_degrees = np.sum(distance_matrix < (avg_distance * 1.5), axis=1)
    degree_penalty_exponent = 1.5 # Adjusted exponent
    
    # Local search encouragement: prioritize edges that connect to nodes with few close neighbors
    neighbor_radius_factor = 1.2 # Adjusted factor

    for i in range(n):
        for j in range(n):
            if i != j:
                # Base heuristic: inverse distance
                heuristics[i, j] = 1 / (distance_matrix[i, j] + small_constant)

                # Degree penalty
                degree_penalty = (node_degrees[i] + node_degrees[j])**degree_penalty_exponent
                heuristics[i, j] /= (1 + 0.2 * degree_penalty * (distance_matrix[i, j] / avg_distance))  # Tuned weight

                # Local search encouragement
                local_neighbors_i = np.sum(distance_matrix[i, :] < (distance_matrix[i, j] * neighbor_radius_factor))
                local_neighbors_j = np.sum(distance_matrix[j, :] < (distance_matrix[j, i] * neighbor_radius_factor))
                heuristics[i, j] *= (1 / (1 + 0.1 * (local_neighbors_i + local_neighbors_j))) #Tuned weight

            else:
                heuristics[i, j] = 0

    # Dynamic sparsification: remove edges with low heuristic values, focusing on promising edges
    for i in range(n):
        row = heuristics[i, :]
        threshold = np.percentile(row[row > 0], 70) # Adjusted percentile
        heuristics[i, row < threshold] = 0

    # Distance-based sparsification: further reduce unpromising edges
    distance_threshold = np.percentile(distance_matrix[distance_matrix != 0], 30) #Adjusted percentile
    for i in range(n):
        for j in range(n):
            if distance_matrix[i, j] > distance_threshold and heuristics[i, j] > 0:
                heuristics[i, j] *= 0.3 # Tuned weight

    return heuristics
```
