```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    A more sophisticated heuristics function for the Traveling Salesman Problem (TSP).
    This version considers both distance and a crude measure of node centrality.
    It favors shorter edges but also edges connecting to nodes that, on average, are 
    relatively far away from other nodes (higher potential for large savings).

    Args:
        distance_matrix (np.ndarray): A square matrix representing the distances between nodes.
                                      distance_matrix[i, j] is the distance between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element
                    indicates the prior promise of including the corresponding edge
                    in the TSP solution. Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Calculate node "centrality" (inverse of average distance to other nodes)
    node_centrality = np.zeros(n)
    for i in range(n):
        node_centrality[i] = 1 / (np.sum(distance_matrix[i, :]) / (n - 1) + 1e-9) # Add a small epsilon to avoid division by zero

    # Combine distance and centrality
    for i in range(n):
        for j in range(n):
            if i != j:
                # Favor shorter distances but weight by centrality of both endpoints
                heuristics[i, j] = (node_centrality[i] + node_centrality[j]) / (distance_matrix[i, j] + 1e-9) #Small epsilon avoids div by zero
            else:
                heuristics[i, j] = 0  # Exclude self-loops

    return heuristics
```
