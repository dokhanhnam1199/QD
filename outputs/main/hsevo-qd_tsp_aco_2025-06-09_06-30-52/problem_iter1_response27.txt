```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improves the basic inverse distance heuristic for TSP.
    Incorporates ideas inspired by physics:

    1.  Inverse distance, modified by a "temperature" parameter, simulating
        annealing.  At high temperature, explore more; at low temperature,
        exploit known good edges.
    2.  A "gravitational" attraction towards the centroid of all nodes,
        favoring edges that move towards the center of the problem.
    3.  Random noise, ensuring that we don't get stuck in local minima.
    """
    n = distance_matrix.shape[0]
    
    # Avoid division by zero and infinite values that can occur when two nodes
    # are in the exact same location.
    safe_distance_matrix = distance_matrix + np.eye(n) * 1e-6
    
    # Temperature annealing parameter.  Starts high, decreases over time
    # in an actual simulated annealing implementation, but we just set a fixed value here.
    temperature = 10.0
    
    # Heuristic based on inverse distance and temperature
    heuristic = 1.0 / (safe_distance_matrix**temperature)

    # Calculate centroid (average x, y coordinate)
    centroid = np.array([np.mean(range(n)), np.mean(range(n))])  # Assuming nodes are indexed from 0 to n-1

    # "Gravitational" attraction
    gravitational_attraction = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance from node i and j to the centroid
                dist_i_to_centroid = np.linalg.norm(i - centroid)
                dist_j_to_centroid = np.linalg.norm(j - centroid)

                # Encourage edges moving closer to the center
                gravitational_attraction[i, j] = max(0, dist_i_to_centroid - dist_j_to_centroid) + max(0, dist_j_to_centroid - dist_i_to_centroid)

    # Scale gravitational attraction
    gravitational_attraction = gravitational_attraction / np.max(gravitational_attraction) if np.max(gravitational_attraction) > 0 else 0

    # Add a bit of random noise.
    noise = np.random.rand(n, n) * 0.1
    
    # Combine heuristics
    heuristic = heuristic + 0.5 * gravitational_attraction + noise

    # Normalize
    heuristic = heuristic / np.max(heuristic)

    return heuristic
```
