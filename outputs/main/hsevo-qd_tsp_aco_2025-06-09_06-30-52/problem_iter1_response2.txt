```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Improves upon the basic inverse distance heuristic for the Traveling Salesman Problem (TSP).

    This version incorporates ideas inspired by gravitational forces and edge attractiveness to guide stochastic solution sampling.
    Edges connecting to nodes with high "potential" (based on their proximity to other nodes) are favored.
    Also, shorter edges are still preferred but the effect is softened and the 'gravitational' aspect becomes more relevant in deciding the next edge.

    Args:
        distance_matrix: A NumPy array representing the distance matrix for the TSP.
                         distance_matrix[i, j] gives the distance between city i and city j.
                         Diagonal elements (distance from a city to itself) should be 0 or very small.

    Returns:
        A NumPy array of the same shape as distance_matrix, where each element represents a prior indicator
        of how promising it is to include that edge in a TSP solution. Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]  # Number of cities
    heuristics = np.zeros_like(distance_matrix)

    # Avoid division by zero and self-loops
    epsilon = 1e-9  # Small constant to prevent division by zero.
    safe_distance_matrix = distance_matrix + np.eye(n) * epsilon # Prevent self-loop div-by-zero.
    safe_distance_matrix[safe_distance_matrix==0] = epsilon # Replace 0 with a small value.


    # Calculate "potential" for each city based on inverse distance to other cities.
    # Cities closer to many other cities are considered to have higher "potential."
    city_potentials = np.sum(1 / safe_distance_matrix, axis=1)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Edge attractiveness is a combination of inverse distance and the "potential"
                # of the connected cities. So shorter edges are better, but also if cities
                # are in areas close to other cities.
                heuristics[i, j] = (city_potentials[i] + city_potentials[j]) / (safe_distance_matrix[i, j] + epsilon) # added epsilon to both prevent division by zero

                # An alternative weighing that may give improved stability, by ensuring values don't become too large.
                # heuristics[i, j] = (city_potentials[i] + city_potentials[j]) * np.exp(-safe_distance_matrix[i, j]) # exponential
            else:
                heuristics[i, j] = 0  # No self-loops

    return heuristics
```
