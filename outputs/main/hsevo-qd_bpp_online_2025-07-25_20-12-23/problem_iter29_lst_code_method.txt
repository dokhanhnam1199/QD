{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines adaptive scaling with exact fit prioritization and sigmoid rewards for balanced online bin packing.\n    \"\"\"\n    # Constants for tuning the heuristic\n    SCALE_FACTOR = 100.0\n    EXACT_FIT_BONUS = 1000.0\n    SIGMOID_SLOPE = 1.1\n    SIGMOID_OFFSET = 0.2788\n    INEFFICIENCY_PENALTY = -1000.0\n\n    # Calculate the exact fit indicator\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores = exact_fit_mask * EXACT_FIT_BONUS\n\n    # Adaptive scaling based on remaining capacity for non-exact fits\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        remaining_cap = bins_remain_cap[non_exact_fit_mask] - item\n        adaptive_scale = SCALE_FACTOR * np.exp(-((remaining_cap - item) ** 2) / (2 * (item ** 2)))\n        priority_scores[non_exact_fit_mask] = adaptive_scale\n\n    # Sigmoid reward for non-exact fits\n    if np.any(non_exact_fit_mask):\n        reward = 1 / (1 + np.exp(-SIGMOID_SLOPE * (remaining_cap - SIGMOID_OFFSET)))\n        priority_scores[non_exact_fit_mask] *= reward\n\n    # Penalize bins that cannot fit the item\n    priority_scores[bins_remain_cap < item] = INEFFICIENCY_PENALTY\n\n    return priority_scores\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines adaptive scaling with exact fit prioritization and sigmoid rewards for balanced online bin packing.\n    \"\"\"\n    # Constants for tuning the heuristic\n    SCALE_FACTOR = 100.0\n    EXACT_FIT_BONUS = 1000.0\n    SIGMOID_SLOPE = 1.1\n    SIGMOID_OFFSET = 0.2788\n    INEFFICIENCY_PENALTY = -1000.0\n\n    # Calculate the exact fit indicator\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores = exact_fit_mask * EXACT_FIT_BONUS\n\n    # Adaptive scaling based on remaining capacity for non-exact fits\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        remaining_cap = bins_remain_cap[non_exact_fit_mask] - item\n        adaptive_scale = SCALE_FACTOR * np.exp(-((remaining_cap - item) ** 2) / (2 * (item ** 2)))\n        priority_scores[non_exact_fit_mask] = adaptive_scale\n\n    # Sigmoid reward for non-exact fits\n    if np.any(non_exact_fit_mask):\n        reward = 1 / (1 + np.exp(-SIGMOID_SLOPE * (remaining_cap - SIGMOID_OFFSET)))\n        priority_scores[non_exact_fit_mask] *= reward\n\n    # Penalize bins that cannot fit the item\n    priority_scores[bins_remain_cap < item] = INEFFICIENCY_PENALTY\n\n    return priority_scores\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines adaptive scaling with exact fit prioritization and sigmoid rewards for balanced and efficient bin packing.\n    \"\"\"\n    # Constants for tuning the heuristic\n    SCALE_FACTOR = 100.0\n    EXACT_FIT_BONUS = 1000.0\n    SIGMOID_THRESHOLD_MIN = 0.6896808736373103\n    SIGMOID_THRESHOLD_MAX = 0.08876173133481396\n    SIGMOID_SLOPE = 1.1169141074890545\n    SIGMOID_OFFSET = 0.278808023854411\n    PENALTY = -9459.645242722696\n\n    # Calculate the exact fit indicator\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores = exact_fit_mask * EXACT_FIT_BONUS\n\n    # Adaptive scaling based on remaining capacity for non-exact fits\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        remaining_cap = bins_remain_cap[non_exact_fit_mask] - item\n        adaptive_scale = SCALE_FACTOR * np.exp(-((remaining_cap - item) ** 2) / (2 * (item ** 2)))\n        priority_scores[non_exact_fit_mask] = adaptive_scale\n\n    # Sigmoid reward for non-exact fits\n    if np.any(non_exact_fit_mask):\n        reward = 1 / (1 + np.exp(-SIGMOID_SLOPE * (remaining_cap - SIGMOID_OFFSET)))\n        reward = np.clip(reward, SIGMOID_THRESHOLD_MIN, SIGMOID_THRESHOLD_MAX)\n        priority_scores[non_exact_fit_mask] *= reward\n\n    # Penalize bins that cannot fit the item\n    priority_scores[bins_remain_cap < item] = PENALTY\n\n    return priority_scores\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function for Online Bin Packing Problem (BPP) using adaptive scaling,\n    exact fit rewards, penalties for inefficiencies, and continuous multifactor design tuning.\n    \"\"\"\n    # Constants for tuning the heuristic\n    SCALE_FACTOR = 100.0\n    EXACT_FIT_BONUS = 2000.0\n    INEFFICIENCY_PENALTY = -5000.0\n    SIGMOID_SLOPE = 1.2\n    SIGMOID_OFFSET = 0.3\n    SIGMOID_THRESHOLD_MIN = 0.6\n    SIGMOID_THRESHOLD_MAX = 0.1\n    UNDERUTILIZATION_THRESHOLD = 0.2\n    UNDERUTILIZATION_PENALTY = -1000.0\n\n    # Calculate the exact fit indicator\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores = exact_fit_mask * EXACT_FIT_BONUS\n\n    # Adaptive scaling based on remaining capacity for non-exact fits\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        remaining_cap = bins_remain_cap[non_exact_fit_mask] - item\n        adaptive_scale = SCALE_FACTOR * np.exp(-((remaining_cap - item) ** 2) / (2 * (item ** 2)))\n        priority_scores[non_exact_fit_mask] = adaptive_scale\n\n    # Sigmoid reward for non-exact fits\n    if np.any(non_exact_fit_mask):\n        reward = 1 / (1 + np.exp(-SIGMOID_SLOPE * (remaining_cap - SIGMOID_OFFSET)))\n        reward = np.clip(reward, SIGMOID_THRESHOLD_MIN, SIGMOID_THRESHOLD_MAX)\n        priority_scores[non_exact_fit_mask] *= reward\n\n    # Penalize inefficient placements\n    priority_scores[bins_remain_cap < item] = INEFFICIENCY_PENALTY\n\n    # Penalize underutilized bins (bins with very low remaining capacity)\n    underutilized_mask = np.logical_and(bins_remain_cap > item, bins_remain_cap / item < UNDERUTILIZATION_THRESHOLD)\n    priority_scores[underutilized_mask] += UNDERUTILIZATION_PENALTY\n\n    return priority_scores\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function for Online Bin Packing Problem (BPP) using adaptive scaling,\n    exact fit rewards, penalties for inefficiencies, and continuous multifactor design tuning.\n    \"\"\"\n    # Constants for tuning the heuristic\n    SCALE_FACTOR = 100.0\n    EXACT_FIT_BONUS = 2000.0\n    INEFFICIENCY_PENALTY = -5000.0\n    SIGMOID_SLOPE = 1.2\n    SIGMOID_OFFSET = 0.3\n    SIGMOID_THRESHOLD_MIN = 0.6\n    SIGMOID_THRESHOLD_MAX = 0.1\n    UNDERUTILIZATION_THRESHOLD = 0.2\n    UNDERUTILIZATION_PENALTY = -1000.0\n\n    # Calculate the exact fit indicator\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores = exact_fit_mask * EXACT_FIT_BONUS\n\n    # Adaptive scaling based on remaining capacity for non-exact fits\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        remaining_cap = bins_remain_cap[non_exact_fit_mask] - item\n        adaptive_scale = SCALE_FACTOR * np.exp(-((remaining_cap - item) ** 2) / (2 * (item ** 2)))\n        priority_scores[non_exact_fit_mask] = adaptive_scale\n\n    # Sigmoid reward for non-exact fits\n    if np.any(non_exact_fit_mask):\n        reward = 1 / (1 + np.exp(-SIGMOID_SLOPE * (remaining_cap - SIGMOID_OFFSET)))\n        reward = np.clip(reward, SIGMOID_THRESHOLD_MIN, SIGMOID_THRESHOLD_MAX)\n        priority_scores[non_exact_fit_mask] *= reward\n\n    # Penalize inefficient placements\n    priority_scores[bins_remain_cap < item] = INEFFICIENCY_PENALTY\n\n    # Penalize underutilized bins (bins with very low remaining capacity)\n    underutilized_mask = np.logical_and(bins_remain_cap > item, bins_remain_cap / item < UNDERUTILIZATION_THRESHOLD)\n    priority_scores[underutilized_mask] += UNDERUTILIZATION_PENALTY\n\n    return priority_scores\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function for Online Bin Packing Problem (BPP) using adaptive scaling,\n    exact fit rewards, penalties for inefficiencies, and continuous multifactor design tuning.\n    \"\"\"\n    # Constants for tuning the heuristic\n    SCALE_FACTOR = 100.0\n    EXACT_FIT_BONUS = 2000.0\n    INEFFICIENCY_PENALTY = -5000.0\n    SIGMOID_SLOPE = 1.2\n    SIGMOID_OFFSET = 0.3\n    SIGMOID_THRESHOLD_MIN = 0.6\n    SIGMOID_THRESHOLD_MAX = 0.1\n    UNDERUTILIZATION_THRESHOLD = 0.2\n    UNDERUTILIZATION_PENALTY = -1000.0\n\n    # Calculate the exact fit indicator\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores = exact_fit_mask * EXACT_FIT_BONUS\n\n    # Adaptive scaling based on remaining capacity for non-exact fits\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        remaining_cap = bins_remain_cap[non_exact_fit_mask] - item\n        adaptive_scale = SCALE_FACTOR * np.exp(-((remaining_cap - item) ** 2) / (2 * (item ** 2)))\n        priority_scores[non_exact_fit_mask] = adaptive_scale\n\n    # Sigmoid reward for non-exact fits\n    if np.any(non_exact_fit_mask):\n        reward = 1 / (1 + np.exp(-SIGMOID_SLOPE * (remaining_cap - SIGMOID_OFFSET)))\n        reward = np.clip(reward, SIGMOID_THRESHOLD_MIN, SIGMOID_THRESHOLD_MAX)\n        priority_scores[non_exact_fit_mask] *= reward\n\n    # Penalize inefficient placements\n    priority_scores[bins_remain_cap < item] = INEFFICIENCY_PENALTY\n\n    # Penalize underutilized bins (bins with very low remaining capacity)\n    underutilized_mask = np.logical_and(bins_remain_cap > item, bins_remain_cap / item < UNDERUTILIZATION_THRESHOLD)\n    priority_scores[underutilized_mask] += UNDERUTILIZATION_PENALTY\n\n    return priority_scores\n\n[Heuristics 7th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    SCALE_FACTOR: float = 85.0779267363746,\n    EXACT_FIT_BONUS: float = 1451.8507099005294,\n    SIGMOID_THRESHOLD_MIN: float = 0.8082647207215781,\n    SIGMOID_THRESHOLD_MAX: float = 0.10157444785080894,\n    SIGMOID_SLOPE: float = 1.3322345010377983,\n    SIGMOID_OFFSET: float = 0.16237484159918142,\n    PENALTY: float = -9990.794546281068) -> np.ndarray:\n    \"\"\"\n    Combines adaptive scaling with exact fit prioritization and sigmoid rewards for balanced and efficient bin packing.\n    \"\"\"\n    \n    # Calculate the exact fit indicator\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores = exact_fit_mask * EXACT_FIT_BONUS\n\n    # Adaptive scaling based on remaining capacity for non-exact fits\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        remaining_cap = bins_remain_cap[non_exact_fit_mask] - item\n        adaptive_scale = SCALE_FACTOR * np.exp(-((remaining_cap - item) ** 2) / (2 * (item ** 2)))\n        priority_scores[non_exact_fit_mask] = adaptive_scale\n\n    # Sigmoid reward for non-exact fits\n    if np.any(non_exact_fit_mask):\n        reward = 1 / (1 + np.exp(-SIGMOID_SLOPE * (remaining_cap - SIGMOID_OFFSET)))\n        reward = np.clip(reward, SIGMOID_THRESHOLD_MIN, SIGMOID_THRESHOLD_MAX)\n        priority_scores[non_exact_fit_mask] *= reward\n\n    # Penalize bins that cannot fit the item\n    priority_scores[bins_remain_cap < item] = PENALTY\n\n    return priority_scores\n\n[Heuristics 8th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    SCALE_FACTOR: float = 85.0779267363746,\n    EXACT_FIT_BONUS: float = 1451.8507099005294,\n    SIGMOID_THRESHOLD_MIN: float = 0.8082647207215781,\n    SIGMOID_THRESHOLD_MAX: float = 0.10157444785080894,\n    SIGMOID_SLOPE: float = 1.3322345010377983,\n    SIGMOID_OFFSET: float = 0.16237484159918142,\n    PENALTY: float = -9990.794546281068) -> np.ndarray:\n    \"\"\"\n    Combines adaptive scaling with exact fit prioritization and sigmoid rewards for balanced and efficient bin packing.\n    \"\"\"\n    \n    # Calculate the exact fit indicator\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores = exact_fit_mask * EXACT_FIT_BONUS\n\n    # Adaptive scaling based on remaining capacity for non-exact fits\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        remaining_cap = bins_remain_cap[non_exact_fit_mask] - item\n        adaptive_scale = SCALE_FACTOR * np.exp(-((remaining_cap - item) ** 2) / (2 * (item ** 2)))\n        priority_scores[non_exact_fit_mask] = adaptive_scale\n\n    # Sigmoid reward for non-exact fits\n    if np.any(non_exact_fit_mask):\n        reward = 1 / (1 + np.exp(-SIGMOID_SLOPE * (remaining_cap - SIGMOID_OFFSET)))\n        reward = np.clip(reward, SIGMOID_THRESHOLD_MIN, SIGMOID_THRESHOLD_MAX)\n        priority_scores[non_exact_fit_mask] *= reward\n\n    # Penalize bins that cannot fit the item\n    priority_scores[bins_remain_cap < item] = PENALTY\n\n    return priority_scores\n\n[Heuristics 9th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    penalty: float = -9459.645242722696,\n    sigmoid_threshold_min: float = 0.6896808736373103,\n    sigmoid_threshold_max: float = 0.08876173133481396,\n    sigmoid_slope: float = 1.1169141074890545,\n    sigmoid_offset: float = 0.278808023854411) -> np.ndarray:\n    \"\"\"\n    Combines exact fit prioritization with adaptive sigmoid reward to balance filling bins effectively.\n    \"\"\"\n    priority_scores = np.zeros_like(bins_remain_cap)\n    \n    # Exact fit gets highest priority\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores[exact_fit_mask] = 1.0\n    \n    # Non-exact fits are rewarded based on a sigmoid function for capacity utilization\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        new_remain_cap = bins_remain_cap[non_exact_fit_mask] - item\n        reward = 1 / (1 + np.exp(-sigmoid_slope * (new_remain_cap - sigmoid_offset)))\n        priority_scores[non_exact_fit_mask] = reward\n    \n    # Penalize bins that cannot fit the item\n    priority_scores = np.where(bins_remain_cap < item, penalty, priority_scores)\n    \n    return priority_scores\n\n[Heuristics 10th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    penalty: float = -9459.645242722696,\n    sigmoid_threshold_min: float = 0.6896808736373103,\n    sigmoid_threshold_max: float = 0.08876173133481396,\n    sigmoid_slope: float = 1.1169141074890545,\n    sigmoid_offset: float = 0.278808023854411) -> np.ndarray:\n    \"\"\"\n    Combines exact fit prioritization with adaptive sigmoid reward to balance filling bins effectively.\n    \"\"\"\n    priority_scores = np.zeros_like(bins_remain_cap)\n    \n    # Exact fit gets highest priority\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores[exact_fit_mask] = 1.0\n    \n    # Non-exact fits are rewarded based on a sigmoid function for capacity utilization\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        new_remain_cap = bins_remain_cap[non_exact_fit_mask] - item\n        reward = 1 / (1 + np.exp(-sigmoid_slope * (new_remain_cap - sigmoid_offset)))\n        priority_scores[non_exact_fit_mask] = reward\n    \n    # Penalize bins that cannot fit the item\n    priority_scores = np.where(bins_remain_cap < item, penalty, priority_scores)\n    \n    return priority_scores\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines exact fit rewards, adaptive sigmoid scaling, and penalties for inefficiencies.\n    \"\"\"\n    priority_scores = np.zeros_like(bins_remain_cap)\n    \n    # Exact fit gets highest priority\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores[exact_fit_mask] = 1.0\n    \n    # Non-exact fits are rewarded based on a sigmoid function for capacity utilization\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        new_remain_cap = bins_remain_cap[non_exact_fit_mask] - item\n        sigmoid_slope = 1.1169141074890545\n        sigmoid_offset = 0.278808023854411\n        reward = 1 / (1 + np.exp(-sigmoid_slope * (new_remain_cap - sigmoid_offset)))\n        priority_scores[non_exact_fit_mask] = reward\n    \n    # Penalize bins that cannot fit the item\n    penalty = -9459.645242722696\n    priority_scores = np.where(bins_remain_cap < item, penalty, priority_scores)\n    \n    return priority_scores\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines exact fit rewards, adaptive sigmoid scaling, and penalties for inefficiencies.\n    \"\"\"\n    priority_scores = np.zeros_like(bins_remain_cap)\n    \n    # Exact fit gets highest priority\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores[exact_fit_mask] = 1.0\n    \n    # Non-exact fits are rewarded based on a sigmoid function for capacity utilization\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        new_remain_cap = bins_remain_cap[non_exact_fit_mask] - item\n        sigmoid_slope = 1.1169141074890545\n        sigmoid_offset = 0.278808023854411\n        reward = 1 / (1 + np.exp(-sigmoid_slope * (new_remain_cap - sigmoid_offset)))\n        priority_scores[non_exact_fit_mask] = reward\n    \n    # Penalize bins that cannot fit the item\n    penalty = -9459.645242722696\n    priority_scores = np.where(bins_remain_cap < item, penalty, priority_scores)\n    \n    return priority_scores\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    penalty: float = -9459.645242722696,\n    sigmoid_threshold_min: float = 0.6896808736373103,\n    sigmoid_threshold_max: float = 0.08876173133481396,\n    sigmoid_slope: float = 1.1169141074890545,\n    sigmoid_offset: float = 0.278808023854411) -> np.ndarray:\n    \"\"\"\n    Combines exact fit prioritization with adaptive sigmoid reward to balance filling bins effectively.\n    \"\"\"\n    priority_scores = np.zeros_like(bins_remain_cap)\n    \n    # Exact fit gets highest priority\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores[exact_fit_mask] = 1.0\n    \n    # Non-exact fits are rewarded based on a sigmoid function for capacity utilization\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        new_remain_cap = bins_remain_cap[non_exact_fit_mask] - item\n        reward = 1 / (1 + np.exp(-sigmoid_slope * (new_remain_cap - sigmoid_offset)))\n        priority_scores[non_exact_fit_mask] = reward\n    \n    # Penalize bins that cannot fit the item\n    priority_scores = np.where(bins_remain_cap < item, penalty, priority_scores)\n    \n    return priority_scores\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin using a combination of penalty and reward,\n    balancing leftover space and efficiency with adaptive scaling.\n    \"\"\"\n    ifbinsfit = bins_remain_cap >= item\n    penalty = np.where(ifbinsfit, 0, -np.inf)\n    reward = np.where(ifbinsfit, 1.0 / (bins_remain_cap - item + 0.1), 0)\n    priority_score = penalty + reward\n    return priority_score\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin using a combination of penalty and reward,\n    balancing leftover space and efficiency with adaptive scaling.\n    \"\"\"\n    ifbinsfit = bins_remain_cap >= item\n    penalty = np.where(ifbinsfit, 0, -np.inf)\n    reward = np.where(ifbinsfit, 1.0 / (bins_remain_cap - item + 0.1), 0)\n    priority_score = penalty + reward\n    return priority_score\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version uses adaptive scaling and a reward/penalty system to prioritize bins that are more likely to close, promoting efficient use of space.\n    \n    Adaptive scaling adjusts the priority based on the ratio of item size to remaining capacity, encouraging filling of bins to a similar extent.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Base priority: Adaptive scaling based on the item size relative to the remaining capacity\n    base_priority = item / (bins_remain_cap + 0.1)  # adding a small epsilon to avoid division by zero\n    \n    # Specific reward for bins that would be filled to capacity by this item\n    exact_fill_reward = np.where(bins_remain_cap == item, 1.0, 0.0)\n    \n    # Penalty for very small remaining capacities to avoid precision issues with very small numbers\n    small_capacity_penalty = np.where((bins_remain_cap < item) & (bins_remain_cap > 0.1), 0.1, 0.0)\n    \n    # Combined priority score\n    priority_score = base_priority + exact_fill_reward - small_capacity_penalty\n    \n    return priority_score\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic for online bin packing problem that dynamically adjusts scaling and rewards/penalties.\n    \"\"\"\n    # Constants for tuning the heuristic\n    INITIAL_SCALE_FACTOR = 100.0\n    EXACT_FIT_BONUS = 1000.0\n    INEFFICIENCY_PENALTY = -1000.0\n    UNDERUTILIZATION_PENALTY = -500.0\n    ADAPTIVE_SCALING_DECAY = 0.95\n    EFFICIENCY_THRESHOLD = 0.9\n    SIGMOID_SLOPE = 1.2\n    SIGMOID_OFFSET = 0.5\n\n    # Calculate the exact fit indicator\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores = exact_fit_mask * EXACT_FIT_BONUS\n\n    # Adaptive scaling based on remaining capacity for non-exact fits\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        remaining_cap = bins_remain_cap[non_exact_fit_mask]\n        adaptive_scale_factor = INITIAL_SCALE_FACTOR * np.exp(-np.abs(remaining_cap - item) / item)\n        priority_scores[non_exact_fit_mask] = adaptive_scale_factor\n\n    # Dynamically adjust scaling factor based on current bin utilization\n    utilization = bins_remain_cap / bins_remain_cap.max()\n    dynamic_scale = np.mean(utilization) * ADAPTIVE_SCALING_DECAY\n    priority_scores *= dynamic_scale\n\n    # Reward for efficient usage of bin capacity\n    efficient_usage_mask = utilization >= EFFICIENCY_THRESHOLD\n    efficiency_reward = efficient_usage_mask * (bins_remain_cap - item) * 10.\n    priority_scores += efficiency_reward\n\n    # Penalties for inefficiencies and underutilization\n    inefficiency_penalty_mask = utilization < EFFICIENCY_THRESHOLD\n    inefficiency_penalty = inefficiency_penalty_mask * INEFFICIENCY_PENALTY\n    underutilization_penalty_mask = (bins_remain_cap - item) / bins_remain_cap.max() > 0.8\n    underutilization_penalty = underutilization_penalty_mask * UNDERUTILIZATION_PENALTY\n    priority_scores += inefficiency_penalty + underutilization_penalty\n\n    # Sigmoid reward for non-exact fits with nuanced control\n    if np.any(non_exact_fit_mask):\n        reward = 1 / (1 + np.exp(-SIGMOID_SLOPE * (remaining_cap - SIGMOID_OFFSET)))\n        priority_scores[non_exact_fit_mask] *= reward\n\n    # Penalize bins that cannot fit the item\n    priority_scores[bins_remain_cap < item] = INEFFICIENCY_PENALTY\n\n    return priority_scores\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristic for online bin packing problem that dynamically adjusts scaling and rewards/penalties.\n    \"\"\"\n    # Constants for tuning the heuristic\n    INITIAL_SCALE_FACTOR = 100.0\n    EXACT_FIT_BONUS = 1000.0\n    INEFFICIENCY_PENALTY = -1000.0\n    UNDERUTILIZATION_PENALTY = -500.0\n    ADAPTIVE_SCALING_DECAY = 0.95\n    EFFICIENCY_THRESHOLD = 0.9\n    SIGMOID_SLOPE = 1.2\n    SIGMOID_OFFSET = 0.5\n\n    # Calculate the exact fit indicator\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores = exact_fit_mask * EXACT_FIT_BONUS\n\n    # Adaptive scaling based on remaining capacity for non-exact fits\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        remaining_cap = bins_remain_cap[non_exact_fit_mask]\n        adaptive_scale_factor = INITIAL_SCALE_FACTOR * np.exp(-np.abs(remaining_cap - item) / item)\n        priority_scores[non_exact_fit_mask] = adaptive_scale_factor\n\n    # Dynamically adjust scaling factor based on current bin utilization\n    utilization = bins_remain_cap / bins_remain_cap.max()\n    dynamic_scale = np.mean(utilization) * ADAPTIVE_SCALING_DECAY\n    priority_scores *= dynamic_scale\n\n    # Reward for efficient usage of bin capacity\n    efficient_usage_mask = utilization >= EFFICIENCY_THRESHOLD\n    efficiency_reward = efficient_usage_mask * (bins_remain_cap - item) * 10.\n    priority_scores += efficiency_reward\n\n    # Penalties for inefficiencies and underutilization\n    inefficiency_penalty_mask = utilization < EFFICIENCY_THRESHOLD\n    inefficiency_penalty = inefficiency_penalty_mask * INEFFICIENCY_PENALTY\n    underutilization_penalty_mask = (bins_remain_cap - item) / bins_remain_cap.max() > 0.8\n    underutilization_penalty = underutilization_penalty_mask * UNDERUTILIZATION_PENALTY\n    priority_scores += inefficiency_penalty + underutilization_penalty\n\n    # Sigmoid reward for non-exact fits with nuanced control\n    if np.any(non_exact_fit_mask):\n        reward = 1 / (1 + np.exp(-SIGMOID_SLOPE * (remaining_cap - SIGMOID_OFFSET)))\n        priority_scores[non_exact_fit_mask] *= reward\n\n    # Penalize bins that cannot fit the item\n    priority_scores[bins_remain_cap < item] = INEFFICIENCY_PENALTY\n\n    return priority_scores\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic emphasizes adaptability and simplicity by prioritizing bins that \n    can immediately accommodate the item while still considering how full the bins are.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Priority score based on whether the bin can fit the item and remaining capacity\n    can_fit = (bins_remain_cap >= item).astype(float)\n    return can_fit * (bins_remain_cap / item)\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic emphasizes adaptability and simplicity by prioritizing bins that \n    can immediately accommodate the item while still considering how full the bins are.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Priority score based on whether the bin can fit the item and remaining capacity\n    can_fit = (bins_remain_cap >= item).astype(float)\n    return can_fit * (bins_remain_cap / item)\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}