{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    item: float, \n    bins_remain_cap: np.ndarray, \n    penalty: float = -9459.645242722696,\n    sigmoid_threshold_min: float = 0.6896808736373103,\n    sigmoid_threshold_max: float = 0.08876173133481396,\n    sigmoid_slope: float = 1.1169141074890545,\n    sigmoid_offset: float = 0.278808023854411) -> np.ndarray:\n    \"\"\"\n    Combines exact fit prioritization with adaptive sigmoid reward to balance filling bins effectively.\n    \"\"\"\n    priority_scores = np.zeros_like(bins_remain_cap)\n    \n    # Exact fit gets highest priority\n    exact_fit_mask = bins_remain_cap == item\n    priority_scores[exact_fit_mask] = 1.0\n    \n    # Non-exact fits are rewarded based on a sigmoid function for capacity utilization\n    non_exact_fit_mask = np.logical_and(bins_remain_cap >= item, ~exact_fit_mask)\n    if np.any(non_exact_fit_mask):\n        new_remain_cap = bins_remain_cap[non_exact_fit_mask] - item\n        reward = 1 / (1 + np.exp(-sigmoid_slope * (new_remain_cap - sigmoid_offset)))\n        priority_scores[non_exact_fit_mask] = reward\n    \n    # Penalize bins that cannot fit the item\n    priority_scores = np.where(bins_remain_cap < item, penalty, priority_scores)\n    \n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic emphasizes adaptability and simplicity by prioritizing bins that \n    can immediately accommodate the item while still considering how full the bins are.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Priority score based on whether the bin can fit the item and remaining capacity\n    can_fit = (bins_remain_cap >= item).astype(float)\n    return can_fit * (bins_remain_cap / item)\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristic (1st) uses a complex multi-factorial design with adaptive scaling, exact fit rewards, penalties for inefficiencies, underutilization, and sigmoid rewards, which are meticulously tuned with specific hyperparameters. The worst heuristic (20th) simply multiplies the boolean mask of whether the item can fit into the bin by the remaining capacity divided by the item size, lacking depth in policy components. \nComparing (2nd) vs (19th), we see that the second-best uses adaptive scaling, exact fit prioritization, and sigmoid rewards, while the 19th uses a much simpler heuristic that emphasizes immediate fitting capability and remaining capacity proportionally.\nComparing (3rd) vs (18th), we see identical code except for comments, suggesting no differences in functionality.\nComparing (1st) vs (2nd), we see additional penalties and rewards in the 1st heuristic, improving the balance between efficiency and effective placement.\nComparing (second worst) vs (worst), we see that the second-worst also emphasizes immediate fitting capability but adds sophistication through rewards and penalties for remaining capacity usage, distinguishing it from the simplest approach of the worst.\nComparing the most complex (1st, 2nd) heuristics with the simpler (19th, 20th) heuristics, we observe that complexity leads to potentially better adaptability and fine-grained control over bin usage, at the cost of higher computational overhead.\nOverall, the most effective heuristics are those with adaptive scaling, exact fit rewards, penalties for inefficiencies, and proportionate sigmoid rewards, indicating a balance between efficiency and adaptability.\n- \n- **Keywords**: Adaptive scaling, exact fit rewards, penalties, fine-tuning, balance, tailored policy.\n- **Advice**: Focus on dynamic balancing through adaptive scaling and apply specific rewards for exact fits along with penalties for underutilization. Tailor policy components to improve solution effectiveness.\n- **Avoid**: Overly complex systems that introduce unnecessary functions or fail to maintain simplicity. Avoid simplistic priority measures that do not account for nuanced control.\n- **Explanation**: By balancing adaptive mechanisms with tailored penalties and rewards, heuristics can achieve higher efficiency. Fine-tuning these elements ensures they are responsive to the specific needs of the bin packing problem, avoiding both overcomplication and oversimplification.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}