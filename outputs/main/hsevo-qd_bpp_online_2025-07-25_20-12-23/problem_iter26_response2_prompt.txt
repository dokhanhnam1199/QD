{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version of the priority function implements a heuristic that uses adaptive scaling,\n    strategic rewards for exact fits, and penalties for inefficient placements. It aims to \n    balance bin usage precisely to avoid large leftovers while encouraging efficient packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Constants for tuning the heuristic\n    SCALE_FACTOR = 100.0\n    EXACT_FIT_BONUS = 1000.0\n    UNDERUTILIZATION_PENALTY_FACTOR = 0.5\n\n    # Calculate the exact fit indicator\n    exact_fit = (bins_remain_cap == item).astype(float) * EXACT_FIT_BONUS\n\n    # Calculate the penalty for underutilization\n    underutilization_penalty = (bins_remain_cap < 0.5 * bins_remain_cap.max()).astype(float) * UNDERUTILIZATION_PENALTY_FACTOR\n\n    # Adaptive scaling based on the remaining capacity\n    adaptive_scale = SCALE_FACTOR * np.exp(-((bins_remain_cap - item) ** 2) / (2 * (item ** 2)))\n\n    # Combine the components to get the priority score\n    priority_score = adaptive_scale + exact_fit - underutilization_penalty\n\n    return priority_score\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version uses adaptive scaling and a reward/penalty system to prioritize bins that are more likely to close, promoting efficient use of space.\n    \n    Adaptive scaling adjusts the priority based on the ratio of item size to remaining capacity, encouraging filling of bins to a similar extent.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Base priority: Adaptive scaling based on the item size relative to the remaining capacity\n    base_priority = item / (bins_remain_cap + 0.1)  # adding a small epsilon to avoid division by zero\n    \n    # Specific reward for bins that would be filled to capacity by this item\n    exact_fill_reward = np.where(bins_remain_cap == item, 1.0, 0.0)\n    \n    # Penalty for very small remaining capacities to avoid precision issues with very small numbers\n    small_capacity_penalty = np.where((bins_remain_cap < item) & (bins_remain_cap > 0.1), 0.1, 0.0)\n    \n    # Combined priority score\n    priority_score = base_priority + exact_fill_reward - small_capacity_penalty\n    \n    return priority_score\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristic (1st) uses a complex multi-factorial design with adaptive scaling, exact fit rewards, penalties for inefficiencies, underutilization, and sigmoid rewards, which are meticulously tuned with specific hyperparameters. The worst heuristic (20th) simply multiplies the boolean mask of whether the item can fit into the bin by the remaining capacity divided by the item size, lacking depth in policy components. \nComparing (2nd) vs (19th), we see that the second-best uses adaptive scaling, exact fit prioritization, and sigmoid rewards, while the 19th uses a much simpler heuristic that emphasizes immediate fitting capability and remaining capacity proportionally.\nComparing (3rd) vs (18th), we see identical code except for comments, suggesting no differences in functionality.\nComparing (1st) vs (2nd), we see additional penalties and rewards in the 1st heuristic, improving the balance between efficiency and effective placement.\nComparing (second worst) vs (worst), we see that the second-worst also emphasizes immediate fitting capability but adds sophistication through rewards and penalties for remaining capacity usage, distinguishing it from the simplest approach of the worst.\nComparing the most complex (1st, 2nd) heuristics with the simpler (19th, 20th) heuristics, we observe that complexity leads to potentially better adaptability and fine-grained control over bin usage, at the cost of higher computational overhead.\nOverall, the most effective heuristics are those with adaptive scaling, exact fit rewards, penalties for inefficiencies, and proportionate sigmoid rewards, indicating a balance between efficiency and adaptability.\n- \n- **Keywords**: Adaptive scaling, exact fit rewards, penalties, fine-tuning, balance, tailored policy.\n- **Advice**: Focus on dynamic balancing through adaptive scaling and apply specific rewards for exact fits along with penalties for underutilization. Tailor policy components to improve solution effectiveness.\n- **Avoid**: Overly complex systems that introduce unnecessary functions or fail to maintain simplicity. Avoid simplistic priority measures that do not account for nuanced control.\n- **Explanation**: By balancing adaptive mechanisms with tailored penalties and rewards, heuristics can achieve higher efficiency. Fine-tuning these elements ensures they are responsive to the specific needs of the bin packing problem, avoiding both overcomplication and oversimplification.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}