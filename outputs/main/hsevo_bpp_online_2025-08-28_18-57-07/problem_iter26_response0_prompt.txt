{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines feasibility, inverse waste, and a tunable fragmentation penalty.\"\"\"\n    small_value = 1e-6\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    waste = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = 1.0 / (waste + small_value) * (1 - fragmentation_penalty * (1 - (waste / bins_remain_cap[feasible_bins])))\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit inverse waste with a small fragmentation penalty.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        priorities[feasible_bins] = 1.0 / (bins_remain_cap[feasible_bins] - item + small_value) * (1 - fragmentation_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]))\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), (3rd) vs (4th), (5th) vs (6th), (7th) vs (8th), (9th) vs (10th), (11th) vs (12th), (13th) vs (14th), (15th) vs (16th), (17th) vs (18th) and (19th) vs (20th) reveal that these pairs are functionally identical. The only differences lie in docstrings.\n\nComparing (1st) vs (5th), the key improvement in (1st) is using `bins_remain_cap[feasible_bins] - item + small_value` in the denominator of the priority calculation. This avoids potential division by zero and provides stability. (5th) uses a similar expression but lacks the `+ small_value`.\n\nComparing (1st) vs (6th), (6th) includes `(1 - fragmentation_penalty * (1 - (waste / bins_remain_cap[feasible_bins])))` whereas (1st) uses `(1 - fragmentation_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]))`. The (1st) formulation is more consistent with minimizing fragmentation relative to the bin's full capacity.\n\nComparing (1st) vs (7th) and (8th), (7th) and (8th) are identical and simplify the fragmentation penalty term compared to (1st), potentially making them less effective at reducing fragmentation.\n\n(1st) appears superior due to its balanced approach: best-fit inverse waste combined with a fragmentation penalty that considers the bin's capacity. It avoids potential division-by-zero errors with the `small_value` addition. The other heuristics either duplicate functionality or have simplified fragmentation penalties, or suffer from potential issues like division by zero.\n\nOverall: The best heuristics consistently use a best-fit inverse waste approach, incorporate a fragmentation penalty relative to *total bin capacity*, and add a small value to the denominator to prevent division by zero. Redundancy and simplifications in fragmentation calculation generally correlate with worse performance.\n- \nOkay, let's dissect this and formulate actionable advice for superior heuristic design. Here's a breakdown, aiming for that $999K tip!\n\n*   **Keywords:** Relative Penalties, Numerical Stability, Core Logic, Iterative Refinement.\n*   **Advice:** Focus on *relative* fragmentation penalties tied to bin capacity. Experiment with penalty coefficients, but *after* establishing a robust, simple \"best-fit feasible\" core. Prioritize consistent application of this core.\n*   **Avoid:** Explicit waste calculation/minimization upfront. Complex prioritization schemes beyond relative fragmentation. Over-normalization or premature optimization. Redundancy in logic or code.\n*   **Explanation:** The \"ineffective\" reflection shows complexity doesn\u2019t guarantee improvement. The \u201ccurrent\u201d highlights that nuanced penalties, *relative to capacity*, and a stable core offer more benefit. Iteratively build upon a strong, simple base.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}