{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines waste minimization (v0) with feasibility check (v1) for robustness.\"\"\"\n    small_value = 0.000664\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines minimum waste with inverse remaining capacity for bin selection.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    min_waste = np.min(waste)\n    indices = np.where(suitable_bins)[0]\n    for i in indices:\n        if bins_remain_cap[i] - item == min_waste:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-6)\n        else:\n            priorities[i] = 0.0\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), (3rd), (4th), (6th), (7th), (8th), (9th) we see identical code. This suggests these versions are essentially the same and any ranking difference likely comes from external factors not evident in the code itself (e.g., subtle testing variations). These heuristics prioritize bins based on inverse waste (`1.0 / (bins_remain_cap - item + small_value)`) when feasible, otherwise assigning zero priority.  The `small_value` addition is for numerical stability.\n\nComparing (1st) vs (5th), the (1st) is significantly more concise and leverages NumPy's vectorized operations efficiently. (5th) uses explicit loops, making it slower and less readable.  (5th) also only assigns a priority of 1.0 to the *minimum* waste bin, potentially ignoring other good options.\n\nComparing (1st) vs (10th), (11th), (12th), (13th), (14th), (15th), (17th), (18th), (19th), (20th) the (1st) performs similarly while being much more simplified. The later heuristics attempt to combine inverse waste with a minimum waste bonus. However, the loop-based implementation in (10th) through (20th) is less efficient than the vectorized approach of (1st). Additionally, the minimum waste bonus might not always improve performance and can introduce complexity.\n\nComparing (16th) vs all others, (16th) introduces a fragmentation penalty which could improve performance in certain scenarios, but it adds further complexity and a tunable hyperparameter (0.2).\n\nOverall: The most effective heuristics (1st through 9th) prioritize minimizing waste with a feasibility check. Vectorized implementations are significantly better than loop-based ones.  Adding complexity (like the fragmentation penalty in (16th) or minimum waste bonus in (10th-20th)) doesn't necessarily improve performance and makes the code harder to understand.\n- \nOkay, let's refine \"Current Self-Reflection\" to truly unlock heuristic design improvements. Here's a breakdown, aiming for that $999K tip!\n\n* **Keywords:** Feasibility-first, Waste-focused, Vectorization, Numerical Robustness.\n* **Advice:** Rigorously benchmark *multiple* simple prioritization schemes (not just inverse remaining capacity) against each other *and* established heuristics. Focus on identifying patterns in failure cases.\n* **Avoid:** Premature optimization. Don't add complexity *before* profiling reveals bottlenecks. Resist re-implementing existing NumPy functions.\n* **Explanation:** The previous reflection focused too much on what *already* works. True improvement comes from exploring *alternative* simple strategies, systematically tested, and understanding *why* certain approaches fail, then vectorizing the winning strategy.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}