{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit (waste minimization) with feasibility check.\"\"\"\n    small_value = 0.000664\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines feasibility with inverse waste and a small fragmentation penalty.\"\"\"\n    small_value = 1e-6\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    fragmentation_penalty = 1.0 / (bins_remain_cap[suitable_bins] + small_value)\n    priorities[suitable_bins] = fit_score * (1.0 - 0.1 * fragmentation_penalty)\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), (3rd), (4th), (5th), (6th), (7th), (8th), (9th), (10th), (11th), (12th), (13th), (14th), (15th), (16th), (17th), (18th), (19th), (20th) the core logic is remarkably consistent \u2013 focusing on feasibility (bins_remain_cap >= item) and then prioritizing based on minimizing waste (1.0 / (bins_remain_cap - item + small_value)).  The key differentiators are the addition of `small_value` (for numerical stability), minimum waste bonuses, and fragmentation penalties. Heuristics 1st and 7th are identical.  Heuristics 2nd, 5th, 6th, 8th, 9th and 10th are identical. Heuristics 13th and 15th are identical. Heuristics 16th and 18th are identical. The 3rd heuristic is notably different. It explicitly finds the minimum waste *after* identifying suitable bins and assigns priority only to those with minimum waste \u2013 this adds computational overhead and might prematurely restrict exploration.  The 4th heuristic introduces a 0.5 bonus, which is somewhat arbitrary. The 11th, 12th, and 20th versions refine the waste calculation slightly using `1e-9` or `1e-6`. The 14th, 17th, and 19th prioritize minimal waste.  The 16th and 18th introduce a fragmentation penalty which appears logical, but the 0.1 coefficient is a hyperparameter needing tuning.\n\nComparing (17th) vs (16th), the inclusion of a fragmentation penalty (16th) seems a valuable addition to prevent overly fragmented bins, giving it an edge. Comparing (16th) vs (14th), the penalty in (16th) offers a slight improvement over solely focusing on minimal waste (14th). \nOverall: The core 'best-fit with feasibility' strategy is strong. Small improvements come from careful numerical stabilization (`small_value`), and adding a controlled fragmentation penalty. The 3rd version is a significant outlier, unnecessarily complex and potentially restrictive.\n- \nOkay, let's refine \"Current self-reflection\" into actionable design principles for superior heuristics, aiming for that $999K! Here's a breakdown:\n\n* **Keywords:** Feasibility-first, Tunable penalty, Consistent logic, Numerical stability.\n* **Advice:** Embrace a core \"best-fit feasible\" approach *always*. Experiment with a *small*, tunable penalty for fragmentation \u2013 treat it as a regularization term, not a core objective.\n* **Avoid:** Overly targeted early optimization (waste *before* feasibility). Complex scoring functions. Prematurely dismissing simpler approaches.\n* **Explanation:** The original reflection correctly identifies simplicity & stability. By prioritizing *consistent* feasible placement and using fragmentation as a subtle guide, we encourage exploration and avoid getting stuck in local optima.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}