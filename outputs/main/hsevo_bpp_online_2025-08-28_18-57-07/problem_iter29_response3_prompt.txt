{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit with a fragmentation penalty, relative to bin capacity.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.1\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    priorities[suitable_bins] = fit_score - fragmentation_penalty * (1 - (waste / bins_remain_cap[suitable_bins]))\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    small_value = 0.000664\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    \n    remaining_capacities = bins_remain_cap[feasible_bins]\n    bin_capacities = np.full_like(remaining_capacities, bins_remain_cap.max())\n    \n    fragmentation_penalty = 0.1 * (1 - (remaining_capacities - item) / bin_capacities)\n    \n    priorities[feasible_bins] = 1.0 / (remaining_capacities - item + small_value) - fragmentation_penalty\n    priorities[~feasible_bins] = 0.0\n    \n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), (3rd), (4th), (5th), (6th), (7th) the code is identical, suggesting no discernible difference in implementation. This is likely due to copy-pasting with no changes. Comparing (1st) vs (8th), (9th), (10th), (11th), (12th), (13th), (14th), (15th), (16th), (17th), (18th), (19th), (20th) we see a gradual simplification of the fragmentation penalty calculation and initialization of variables. (1st) & (2nd) are more verbose in initializing variables while (8th) and following attempt to condense it. (19th) & (20th) calculates `bin_capacities` which is redundant as it's always the maximum bin capacity and doesn't affect functionality. The core logic of best-fit inverse waste with fragmentation penalty remains constant across all versions. The key differences lie in code readability and minor variations in variable assignment.  The difference between the versions appears to be in the order and some intermediate variable calculations, but the final result is equivalent. (1st) appears slightly better due to its clear variable assignments.  \n\nComparing (19th) vs (20th), the code is identical. Overall, the main variance is in stylistic choices and slightly different orderings of operations. There is minimal functional difference.  The fragmentation penalty implementation appears consistent across all. A `small_value` is added to the denominator to ensure numerical stability, which is consistent across all.\n- \nOkay, let's distill those reflections into actionable heuristic design principles. Here's a breakdown, aiming for that $999K performance boost:\n\n* **Keywords:** Feasibility, Waste Minimization, Fragmentation, Numerical Stability.\n* **Advice:** Prioritize \u201cbest-fit feasible\u201d \u2013 directly minimize waste *within* viable bins. Use inverse remaining capacity as a tie-breaker. Carefully tune a *relative* fragmentation penalty (bin capacity based). Leverage NumPy.\n* **Avoid:** Explicit waste calculations (unless demonstrably superior), redundant code, unnecessary normalization, premature optimization, and complex formulations without rigorous testing.\n* **Explanation:** Simplicity & robustness win. Numerical stability (small epsilon values) prevents errors. Fragmentation penalties address packing efficiency, but require careful coefficient selection via experimentation \u2013 multiplicative penalties are preferred.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}