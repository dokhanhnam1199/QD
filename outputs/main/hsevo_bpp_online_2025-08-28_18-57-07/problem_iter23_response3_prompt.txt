{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines feasibility and waste minimization with a fragmentation penalty.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.1\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + small_value) - fragmentation_penalty * (1 - (bins_remain_cap - item) / bins_remain_cap), 0.0)\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on feasibility and remaining capacity, with a small fragmentation penalty to encourage better space utilization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        priorities[feasible_bins] = 1.0 / (bins_remain_cap[feasible_bins] - item + small_value) * (1 - fragmentation_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]))\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see identical code. This suggests a redundancy in the ranking, as they should have distinct performance. (3rd) vs (4th) are also identical. (1st/2nd) vs (3rd/4th) differ only in the `fragmentation_penalty` value (0.1 vs 0.05), which likely impacts performance. (5th) vs (6th), (7th), (8th), (9th), (10th), (11th) and (12th) show variations in how the `fragmentation_penalty` is applied, and how `small_value` is defined, and bin selection handled.  Heuristics (5th) - (12th) explicitly calculate `waste` and use it in the priority score, while others directly use remaining capacity. (13th) - (20th) are highly similar to (1st) and (2nd), with minor variations in parameter values or initialization but maintain the core logic. Notice the repeated code blocks in many heuristics, indicating an opportunity for refactoring. The presence of unnecessary imports like `random`, `math`, `scipy`, and `torch` in some heuristics (6th, 11th) without being used suggests bloated code, that may hinder performance or understanding. Overall, the ranking seems to be somewhat sensitive to small variations in parameters (`fragmentation_penalty`, `small_value`) and the way the fragmentation penalty is applied, but the core logic of prioritizing by inverse waste/remaining capacity remains consistent across the better-performing heuristics.\n- \nOkay, let's refine \"Current Self-Reflection\" into actionable heuristic design principles, aiming for that $999K reward! Here's a breakdown:\n\n* **Keywords:** Feasibility, Waste, Fragmentation, Simplicity, Stability.\n* **Advice:** Prioritize a core \"best-fit feasible\" logic. Experiment with *small*, tunable fragmentation penalties (multiplicative is preferred). Explicitly calculate waste *only* if testing demonstrates consistent improvement.\n* **Avoid:** Premature optimization, complex prioritization schemes (beyond waste/fragmentation), redundant code, and over-reliance on normalization.\n* **Explanation:** Robustness (handling edge cases/division-by-zero) is *foundational*, but core performance hinges on a simple, well-tuned prioritization of feasibility, minimizing waste, and managing fragmentation\u2014not intricate calculations.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}