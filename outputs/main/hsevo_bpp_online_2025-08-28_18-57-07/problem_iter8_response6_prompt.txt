{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines feasibility with inverse remaining capacity, avoiding division by zero.\"\"\"\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines inverse remaining capacity with feasibility check and handles cases with no suitable bins.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if np.any(suitable_bins):\n        priorities[suitable_bins] = 1.0 / (bins_remain_cap[suitable_bins] - item + 1e-9)\n    return priorities\n\n### Analyze & experience\n- Comparing the 1st (best) and 6th (worst) heuristics, we observe the 1st prioritizes bins based on minimum waste, aiming for efficient space utilization. The 6th, in its initial `priority_v1` function, simply returns zeros, effectively disabling prioritization. The 2nd (best) and 7th (worse) are identical: a common pattern. Comparing 1st vs 2nd, the 1st focuses on minimizing waste *specifically*, while the 2nd uses inverse remaining capacity, which can be less targeted.\n\nThe heuristics primarily differ in how they calculate priority. The top-ranked heuristics (1st, 10th, 13th, 14th, 16th, 17th, 19th) consider waste directly or use inverse remaining capacity with a small value to avoid division by zero. Heuristics 2nd, 3rd, 4th, 7th, 8th, 9th are almost identical \u2013 relying solely on inverse remaining capacity. The bottom-ranked heuristics (6th, 8th) are either non-functional or very basic, lacking any meaningful prioritization scheme. The repeated `small_value` constant (0.000664...) is a defensive programming technique against division by zero, found in the middle-ranked solutions.  The slightly different values used for the small value (1e-6 vs 1e-9) seem insignificant.\n\nOverall: The most effective heuristics prioritize minimizing waste *after* establishing feasibility. Utilizing inverse remaining capacity provides a reasonable alternative, but explicitly considering waste proves superior. Empty or zero-based priority functions are demonstrably ineffective.\n- \nOkay, let's dissect this and redefine \"Current self-reflection\" for superior heuristic design, aiming for that $999K! Here's a breakdown:\n\n* **Keywords:** Exploration, Targeted Prioritization, Robustness, Efficiency.\n* **Advice:** Focus on *diverse* prioritization signals *beyond* simple remaining capacity. Experiment with combinations (e.g., fit + future impact). Systematically explore the search space, not just greedy improvements.\n* **Avoid:** Premature simplicity. Dismissing complexity *before* rigorous testing. Over-reliance on normalization. Treating robustness as the primary goal.\n* **Explanation:** The prior reflection favored quick wins. This one advocates for **strategic complexity** \u2013 investing in mechanisms that unlock better solutions, accepting initial overhead for potentially exponential gains. Robustness is maintained, but *serves* the core logic, not defines it.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}