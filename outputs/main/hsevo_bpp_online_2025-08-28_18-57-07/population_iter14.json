[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines feasibility, waste minimization, and a fragmentation penalty.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.1\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    priorities = priorities - fragmentation_penalty * (bins_remain_cap < item)\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 84.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a small fragmentation penalty for improved bin packing.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.1\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    priorities[suitable_bins] = 1.0 / (waste + small_value) - fragmentation_penalty * (1 - waste / bins_remain_cap[suitable_bins])\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a small fragmentation penalty for improved bin packing.\"\"\"\n    small_value = 1e-6\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    min_waste = np.min(waste)\n    indices = np.where(suitable_bins)[0]\n    for i in indices:\n        if bins_remain_cap[i] - item == min_waste:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + small_value) + 0.1\n        else:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + small_value)\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997044000065 seconds"
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines feasibility with inverse waste and a small fragmentation penalty.\"\"\"\n    small_value = 1e-6\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    min_waste = np.min(waste)\n    indices = np.where(suitable_bins)[0]\n    for i in indices:\n        if bins_remain_cap[i] - item == min_waste:\n            priorities[i] += 0.1 * (1.0 / (min_waste + small_value))\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 171.8953543301665,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a tunable fragmentation penalty.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.1\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    min_waste = np.min(waste)\n    indices = np.where(suitable_bins)[0]\n    for i in indices:\n        if bins_remain_cap[i] - item == min_waste:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + small_value) + fragmentation_penalty\n        else:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + small_value)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 16.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 158.32466846199546,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a small fragmentation penalty for improved bin packing.\"\"\"\n    small_value = 1e-6\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    fragmentation_penalty = 1.0 / (bins_remain_cap[suitable_bins] + small_value)\n    priorities[suitable_bins] = fit_score * (1.0 - 0.05 * fragmentation_penalty)\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 127.37720526058406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines feasibility and waste minimization with a fragmentation penalty.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.1\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + small_value) - fragmentation_penalty * (1 - (bins_remain_cap - item) / bins_remain_cap), 0.0)\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 110.36149671375918,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a small fragmentation penalty for better bin packing.\"\"\"\n    small_value = 1e-6\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    fragmentation_penalty = 1.0 / (bins_remain_cap[suitable_bins] + small_value)\n    priorities[suitable_bins] = fit_score * (1.0 - 0.05 * fragmentation_penalty)\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 127.37720526058406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a small fragmentation penalty for improved bin packing.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.1\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    priorities[suitable_bins] = 1.0 / (bins_remain_cap[suitable_bins] - item + small_value) - fragmentation_penalty / bins_remain_cap[suitable_bins]\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 81.7492568250068,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with a small fragmentation penalty for improved packing.\"\"\"\n    small_value = 1e-6\n    fragmentation_penalty = 0.1\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    priorities[suitable_bins] = 1.0 / (waste + small_value) - fragmentation_penalty * (1 - (waste / bins_remain_cap[suitable_bins]))\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  }
]