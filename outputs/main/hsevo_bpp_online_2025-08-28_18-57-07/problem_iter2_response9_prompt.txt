{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if np.sum(suitable_bins) > 0:\n        priorities[suitable_bins] = (bins_remain_cap[suitable_bins] - item) / bins_remain_cap[suitable_bins]\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        priorities[valid_bins] = bins_remain_cap[valid_bins] - item\n    return priorities\n\n### Analyze & experience\n- Comparing `priority_v1` (1st) vs `priority_v1` (2nd), the first offers no prioritization whatsoever, while the second attempts a fit-based sigmoid scoring. `priority_v2` (1st) uses a sigmoid function to squash the fit score, preventing extremely high priorities. `priority_v2` (2nd) directly calculates the inverse of remaining capacity, offering a simple yet effective prioritization.\n\nComparing `priority_v2` (1st) and `priority_v2` (3rd), both use inverse remaining capacity. However, the 1st version includes a more robust check `capacities[capacities < item] = 0` to avoid issues with negative capacity, while the 3rd uses `np.where`.\n\nComparing `priority_v2` (4th) vs `priority_v2` (5th), both calculate inverse remaining capacity. The 5th normalizes the priorities, ensuring a probability distribution, which can be beneficial, but potentially washes out distinctions.\n\nComparing `priority_v2` (6th) vs `priority_v2` (7th), both are functionally equivalent.\n\n`priority_v2` (8th), (9th), (10th) and (11th) all use similar logic to calculate a priority based on remaining capacity, some with slight variations in variable names or checks. The 10th calculates a ratio of remaining capacity to item size which could be helpful.\n\n`priority_v2` (12th) and (13th) apply an exponential function to the remaining capacity. This can emphasize bins with more capacity, but the exponential might be overly sensitive.\n\n`priority_v2` (14th), (15th), (16th), (17th), (18th) and (19th) all calculate `bins_remain_cap - item`. The 16th and 17th normalize using `np.sum(priorities)`. The exponential in 16th and 17th introduces non-linearity but adds computational cost.\n\n`priority_v1` in all versions is universally useless, providing a baseline for comparison.\n\nOverall: The most effective heuristics prioritize bins based on the inverse of remaining capacity after accommodating the current item (`priority_v2` in versions 2, 3, 4, 6, 7, 8, 9). Normalization (as in 5th, 16th and 17th) can be helpful but must be balanced against potentially losing priority signal.  The sigmoid and exponential functions attempt to add non-linearity, but their impact needs careful tuning. The initial versions using the sigmoid, aren't that helpful.\n- \nOkay, let's refine \"Current self-reflection\" into actionable heuristic design advice, aiming for that $999K! Here's a breakdown, focusing on maximizing bin-packing performance:\n\n* **Keywords:** Simplicity, Capacity-Driven, Stability, Validation.\n* **Advice:** Prioritize heuristics *directly* minimizing wasted bin capacity. Leverage inverse remaining capacity \u2013 it\u2019s a strong signal. Explore slight variations (e.g., weighted inverse capacity) but keep them minimal.\n* **Avoid:** Complex scoring functions, aggressive normalization (can obscure capacity differences), and any logic that sacrifices guaranteed feasibility.\n* **Explanation:** Bin packing benefits from *stable*, easily-understood placement rules.  Overly intricate heuristics introduce noise & risk invalid solutions. Focus on efficiently utilizing available space.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}