[
  {
    "stdout_filepath": "problem_iter41_response0.txt_stdout.txt",
    "code_path": "problem_iter41_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a relative fragmentation penalty, prioritizing numerical robustness.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    priorities[suitable_bins] = fit_score - fragmentation_penalty * (1 - (waste / bins_remain_cap[suitable_bins]))\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter41_response1.txt_stdout.txt",
    "code_path": "problem_iter41_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit and first-fit with a fragmentation penalty.\"\"\"\n    small_value = 0.0001\n    fragmentation_penalty = 0.05\n    best_fit_weight = 0.6\n    first_fit_weight = 0.4\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return np.zeros_like(bins_remain_cap)\n    best_fit_priorities = np.where(feasible_bins, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    first_fit_priorities = np.where(feasible_bins, 1.0, 0.0)\n    priorities = best_fit_weight * best_fit_priorities + first_fit_weight * first_fit_priorities\n    priorities = priorities - fragmentation_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins])\n    priorities[~feasible_bins] = 0.0\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 3.9788591942560925,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 194.3192398051029,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter41_response2.txt_stdout.txt",
    "code_path": "problem_iter41_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a relative fragmentation penalty and first-fit.\"\"\"\n    small_value = 0.0001\n    fragmentation_penalty = 0.05\n    best_fit_weight = 0.6\n    first_fit_weight = 0.4\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return np.zeros_like(bins_remain_cap)\n    best_fit_priorities = np.where(feasible_bins, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    first_fit_priorities = np.where(feasible_bins, 1.0, 0.0)\n    priorities = best_fit_weight * best_fit_priorities + first_fit_weight * first_fit_priorities\n    priorities = priorities - fragmentation_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins])\n    priorities[~feasible_bins] = 0.0\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 3.9788591942560925,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 194.3192398051029,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter41_response3.txt_stdout.txt",
    "code_path": "problem_iter41_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a fragmentation penalty for improved bin selection.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return np.zeros_like(bins_remain_cap)\n    priorities = np.where(feasible_bins, 1.0 / (bins_remain_cap - item + small_value) - fragmentation_penalty * (1 - (bins_remain_cap - item) / bins_remain_cap), 0.0)\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 123.18989788986397,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter41_response4.txt_stdout.txt",
    "code_path": "problem_iter41_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a fragmentation penalty and numerical stability.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.1\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    priorities[suitable_bins] = fit_score - fragmentation_penalty * (1 - (waste / bins_remain_cap[suitable_bins]))\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter41_response5.txt_stdout.txt",
    "code_path": "problem_iter41_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a refined fragmentation penalty.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    priorities[suitable_bins] = fit_score - fragmentation_penalty * (1 - (waste / bins_remain_cap[suitable_bins]))\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter41_response6.txt_stdout.txt",
    "code_path": "problem_iter41_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with fragmentation penalty and first-fit consideration.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.1\n    best_fit_weight = 0.6\n    first_fit_weight = 0.4\n\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    waste = bins_remain_cap[feasible_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    fragmentation_term = (1 - (waste / bins_remain_cap[feasible_bins]))\n    priorities = best_fit_weight * (fit_score - fragmentation_penalty * fragmentation_term) + \\\n                 first_fit_weight * (1.0 / (np.arange(len(bins_remain_cap))[feasible_bins] + 1))\n    priorities[~feasible_bins] = 0.0\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.098524132429212,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 210.99629561116632,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter41_response7.txt_stdout.txt",
    "code_path": "problem_iter41_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a fragmentation penalty, focusing on numerical robustness and relative penalty.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    priorities[suitable_bins] = fit_score - fragmentation_penalty * (1 - (waste / bins_remain_cap[suitable_bins]))\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter41_response8.txt_stdout.txt",
    "code_path": "problem_iter41_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a relative fragmentation penalty for robustness.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    priorities[suitable_bins] = fit_score - fragmentation_penalty * (1 - (waste / bins_remain_cap[suitable_bins]))\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter41_response9.txt_stdout.txt",
    "code_path": "problem_iter41_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a fragmentation penalty for bin selection.\"\"\"\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    if np.any(feasible_bins):\n        waste = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] = 1.0 / (waste + 0.0001)\n        fragmentation_penalty = 0.05 * (1 - (waste) / bins_remain_cap[feasible_bins])\n        priorities[feasible_bins] -= fragmentation_penalty\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 100.07820003461549,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter42_response0.txt_stdout.txt",
    "code_path": "problem_iter42_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    small_value = 0.0001\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    best_fit_weight = 0.7\n    first_fit_weight = 0.3\n    \n    best_fit_priorities = np.where(feasible_bins, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    first_fit_priorities = np.where(feasible_bins, 1.0, 0.0)\n    \n    priorities = best_fit_weight * best_fit_priorities + first_fit_weight * first_fit_priorities\n    \n    waste_penalty = 0.1\n    \n    priorities = priorities - waste_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins])\n\n    priorities[~feasible_bins] = 0.0\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 37.25568408456324,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 194.3192398051029,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter42_response1.txt_stdout.txt",
    "code_path": "problem_iter42_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    small_value = 0.0001\n    best_fit_weight = 0.7\n    first_fit_weight = 0.3\n    fragmentation_penalty = 0.1\n\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    best_fit_priorities = np.where(feasible_bins, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    first_fit_priorities = np.where(feasible_bins, 1.0, 0.0)\n\n    priorities = best_fit_weight * best_fit_priorities + first_fit_weight * first_fit_priorities\n\n    waste_ratio = (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] -= fragmentation_penalty * (1 - waste_ratio)\n\n    priorities[~feasible_bins] = 0.0\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 37.25568408456324,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 194.3192398051029,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter42_response2.txt_stdout.txt",
    "code_path": "problem_iter42_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    small_value = 1e-6\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    best_fit_weight = 0.7\n    first_fit_weight = 0.3\n    \n    best_fit_priorities = np.where(feasible_bins, 1.0 / (bins_remain_cap[feasible_bins] - item + small_value), 0.0)\n    first_fit_priorities = np.where(feasible_bins, 1.0, 0.0)\n    \n    priorities = best_fit_weight * best_fit_priorities + first_fit_weight * first_fit_priorities\n    \n    waste_penalty = 0.1\n    priorities[feasible_bins] -= waste_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins])\n\n    priorities[~feasible_bins] = 0.0\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 37.25568408456324,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 196.27562382434076,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter42_response3.txt_stdout.txt",
    "code_path": "problem_iter42_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    small_value = 0.0001\n    best_fit_weight = 0.7\n    first_fit_weight = 0.3\n    \n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    best_fit_priorities = np.where(feasible_bins, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    first_fit_priorities = np.where(feasible_bins, 1.0, 0.0)\n    \n    priorities = best_fit_weight * best_fit_priorities + first_fit_weight * first_fit_priorities\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 97.70233280920246,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter42_response4.txt_stdout.txt",
    "code_path": "problem_iter42_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    small_value = 0.0001\n    best_fit_weight = 0.7\n    first_fit_weight = 0.3\n    fragmentation_penalty = 0.02\n\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    best_fit_priorities = np.where(feasible_bins, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    first_fit_priorities = np.where(feasible_bins, 1.0, 0.0)\n\n    priorities = best_fit_weight * best_fit_priorities + first_fit_weight * first_fit_priorities\n    \n    waste_ratio = (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] -= fragmentation_penalty * (1 - waste_ratio)\n\n    priorities[~feasible_bins] = 0.0\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 194.3192398051029,
    "exec_success": true
  }
]