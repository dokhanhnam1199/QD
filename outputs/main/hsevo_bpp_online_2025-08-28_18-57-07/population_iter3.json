[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse remaining capacity with a check for valid bins.\n    Prioritizes bins with less remaining capacity after placing the item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    priorities[valid_bins] = 1.0 / (bins_remain_cap[valid_bins] - item + 1e-9)\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a check for valid bins.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        distances = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (distances + 1e-6)\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a check for feasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if np.sum(feasible_bins) > 0:\n        remaining_capacities = bins_remain_cap[feasible_bins]\n        waste = remaining_capacities - item\n        priorities[feasible_bins] = 1.0 / (waste + 1e-6)\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a capacity check for stability.\"\"\"\n    capacities = np.copy(bins_remain_cap)\n    capacities[capacities < item] = 0\n    valid_bins = capacities > 0\n    priorities = np.zeros_like(bins_remain_cap)\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1.0 / (capacities[valid_bins] - item + 1e-6)\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a feasibility check.\"\"\"\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + 1e-6), 0.0)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 39.863137138648355,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a check for feasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n    priorities[valid_bins] = bins_remain_cap[valid_bins] / (item + 1e-6)\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 35.690067810131644,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a check for feasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return priorities\n    remaining_capacities = bins_remain_cap[possible_bins]\n    waste = remaining_capacities - item\n    priorities[possible_bins] = 1.0 / (waste + 1e-6)\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a feasibility check.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if np.sum(feasible_bins) > 0:\n        priorities[feasible_bins] = 1.0 / (bins_remain_cap[feasible_bins] - item + 1e-6)\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a feasibility check.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) > 0:\n        remaining_capacities = bins_remain_cap[possible_bins]\n        waste = remaining_capacities - item\n        priorities[possible_bins] = 1.0 / (waste + 1e-6)\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a check for feasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if np.sum(suitable_bins) > 0:\n        priorities[suitable_bins] = 1.0 / (bins_remain_cap[suitable_bins] - item + 1e-9)\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if np.any(suitable_bins):\n        inverse_remain_cap = 1.0 / (bins_remain_cap[suitable_bins] - item + 1e-6)\n        max_priority = np.max(inverse_remain_cap)\n        indices = np.where(suitable_bins)[0]\n        for i in indices:\n            priorities[i] = inverse_remain_cap[np.where(indices == i)[0][0]] / max_priority\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996844999987 seconds"
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if np.any(suitable_bins):\n        inverse_waste = 1.0 / (bins_remain_cap[suitable_bins] - item + 1e-6)\n        max_inverse_waste = np.max(inverse_waste)\n        indices = np.where(suitable_bins)[0]\n        for i in indices:\n            if abs(inverse_waste[np.where(indices == i)[0][0]] - max_inverse_waste) < 1e-6:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = inverse_waste[np.where(indices == i)[0][0]] / max_inverse_waste\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996451000061 seconds"
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if np.any(suitable_bins):\n        inverse_waste = 1.0 / (bins_remain_cap[suitable_bins] - item + 1e-6)\n        max_inverse_waste = np.max(inverse_waste)\n        indices = np.where(bins_remain_cap >= item)[0]\n        for i in indices:\n            if abs(inverse_waste[np.where(indices == i)[0][0]] - max_inverse_waste) < 1e-6:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 0.0\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997108000025 seconds"
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if np.any(suitable_bins):\n        inverse_waste = 1.0 / (bins_remain_cap[suitable_bins] - item + 1e-6)\n        max_inverse_waste = np.max(inverse_waste)\n        indices = np.where(suitable_bins)[0]\n        for i in indices:\n            if abs(inverse_waste[np.where(indices == i)[0][0]] - max_inverse_waste) < 1e-6:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = inverse_waste[np.where(indices == i)[0][0]] / max_inverse_waste\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996699000076 seconds"
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if np.any(suitable_bins):\n        inverse_waste = 1.0 / (bins_remain_cap[suitable_bins] - item + 1e-6)\n        max_inverse_waste = np.max(inverse_waste)\n        indices = np.where(suitable_bins)[0]\n        for i in indices:\n            if abs(inverse_waste[np.where(indices == i)[0][0]] - max_inverse_waste) < 1e-6:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = inverse_waste[np.where(indices == i)[0][0]] / max_inverse_waste\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997339999936 seconds"
  }
]