[
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on feasibility and remaining capacity,\n    with a small fragmentation penalty to encourage better space utilization.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        priorities[feasible_bins] = 1.0 / (bins_remain_cap[feasible_bins] - item + small_value) * (1 - fragmentation_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]))\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 131.76952268336282,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes feasible bins with minimal waste and a small fragmentation penalty.\"\"\"\n    small_value = 1e-6\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        waste = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] = 1.0 / (waste + small_value) * (1 - fragmentation_penalty * (1 - (waste / bins_remain_cap[feasible_bins])))\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 114.6940428629768,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on feasibility, inverse waste, and a small fragmentation penalty.\"\"\"\n    small_value = 1e-6\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    fragmentation_penalty = 0.05 * (1.0 / (bins_remain_cap[suitable_bins] + small_value))\n    priorities[suitable_bins] = fit_score * (1.0 - fragmentation_penalty)\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 127.37720526058406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response3.txt_stdout.txt",
    "code_path": "problem_iter20_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes feasible bins by inverse waste with a fragmentation penalty.\"\"\"\n    small_value = 1e-6\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    fragmentation_penalty = 0.05 * (1.0 / (bins_remain_cap[suitable_bins] + small_value))\n    priorities[suitable_bins] = fit_score * (1.0 - fragmentation_penalty)\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 127.37720526058406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes feasible bins by inverse waste, with a small fragmentation penalty.\"\"\"\n    small_value = 1e-6\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    fragmentation_penalty = 0.05 * (1.0 / (bins_remain_cap[suitable_bins] + small_value))\n    priorities[suitable_bins] = fit_score * (1.0 - fragmentation_penalty)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 127.37720526058406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes feasible bins with minimal waste and a small fragmentation penalty.\"\"\"\n    small_value = 1e-6\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    waste = bins_remain_cap[feasible_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    fragmentation_penalty = 0.05 * (1.0 / (bins_remain_cap[feasible_bins] + small_value))\n    priorities[feasible_bins] = fit_score * (1.0 - fragmentation_penalty)\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 127.37720526058406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines feasibility, inverse waste, and a small fragmentation penalty.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.1\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        priorities[feasible_bins] = 1.0 / (bins_remain_cap[feasible_bins] - item + small_value) - fragmentation_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins])\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response7.txt_stdout.txt",
    "code_path": "problem_iter20_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by minimizing waste and applying a fragmentation penalty.\"\"\"\n    small_value = 1e-6\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        waste = bins_remain_cap[feasible_bins] - item\n        priorities[feasible_bins] = 1.0 / (waste + small_value) * (1 - fragmentation_penalty * (1 - (waste / bins_remain_cap[feasible_bins])))\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 114.6940428629768,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins based on feasibility, inverse waste,\n    and a small fragmentation penalty.\n    \"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if np.any(feasible_bins):\n        priorities[feasible_bins] = 1.0 / (bins_remain_cap[feasible_bins] - item + small_value) * \\\n                                   (1 - fragmentation_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]))\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 131.76952268336282,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines feasibility, inverse waste, and a small fragmentation penalty.\"\"\"\n    small_value = 1e-6\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n    waste = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = 1.0 / (waste + small_value) * (1 - fragmentation_penalty * (1 - (waste / bins_remain_cap[feasible_bins])))\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 127.37720526058406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response0.txt_stdout.txt",
    "code_path": "problem_iter21_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + small_value) * (1 - fragmentation_penalty * (1 - (bins_remain_cap - item) / bins_remain_cap)), 0.0)\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 125.09775004326937,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response1.txt_stdout.txt",
    "code_path": "problem_iter21_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    priorities = np.where(bins_remain_cap >= item,\n                          1.0 / (bins_remain_cap - item + small_value) * (1 - fragmentation_penalty * (1 - (bins_remain_cap - item) / bins_remain_cap)),\n                          0.0)\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 125.09775004326937,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response2.txt_stdout.txt",
    "code_path": "problem_iter21_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    \n    feasible_bins = bins_remain_cap >= item\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    \n    priorities[feasible_bins] = 1.0 / (bins_remain_cap[feasible_bins] - item + small_value) - fragmentation_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins])\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response3.txt_stdout.txt",
    "code_path": "problem_iter21_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + small_value) * (1 - fragmentation_penalty * (1 - (bins_remain_cap - item) / bins_remain_cap)), 0.0)\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 125.09775004326937,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response4.txt_stdout.txt",
    "code_path": "problem_iter21_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + small_value) * (1 - fragmentation_penalty * (1 - (bins_remain_cap - item) / bins_remain_cap)), 0.0)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 125.09775004326937,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response0.txt_stdout.txt",
    "code_path": "problem_iter22_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, small_value: float = 0.0009138264564659453, fragmentation_penalty: float = 0.07587540403053734) -> np.ndarray:\n    \"\"\"Prioritizes bins based on feasibility and remaining capacity, with a small fragmentation penalty to encourage better space utilization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        priorities[feasible_bins] = 1.0 / (bins_remain_cap[feasible_bins] - item + small_value) * (1 - fragmentation_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins]))\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 131.76952268336282,
    "exec_success": true
  }
]