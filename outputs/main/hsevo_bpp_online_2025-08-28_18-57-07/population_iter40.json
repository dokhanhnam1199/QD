[
  {
    "stdout_filepath": "problem_iter38_response0.txt_stdout.txt",
    "code_path": "problem_iter38_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a relative fragmentation penalty, ensuring feasibility.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    priorities[suitable_bins] = fit_score - fragmentation_penalty * (1 - (waste / bins_remain_cap[suitable_bins]))\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response1.txt_stdout.txt",
    "code_path": "problem_iter38_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a fragmentation penalty, focusing on numerical robustness.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.1\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    priorities[suitable_bins] = fit_score - fragmentation_penalty * (1 - (waste / bins_remain_cap[suitable_bins]))\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response2.txt_stdout.txt",
    "code_path": "problem_iter38_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a relative fragmentation penalty.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    priorities[suitable_bins] = fit_score - fragmentation_penalty * (1 - (waste / bins_remain_cap[suitable_bins]))\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response3.txt_stdout.txt",
    "code_path": "problem_iter38_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a relative fragmentation penalty, \n    prioritizing feasibility and numerical robustness.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    priorities[suitable_bins] = fit_score - fragmentation_penalty * (1 - (waste / bins_remain_cap[suitable_bins]))\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response4.txt_stdout.txt",
    "code_path": "problem_iter38_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste (v0) with simplified fragmentation (v1).\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.1\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    priorities[suitable_bins] = fit_score - fragmentation_penalty * (1 - (waste / bins_remain_cap[suitable_bins]))\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response5.txt_stdout.txt",
    "code_path": "problem_iter38_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a relative fragmentation penalty.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fragmentation_penalty = 0.05 * (1 - waste / bins_remain_cap[suitable_bins])\n    priorities[suitable_bins] = 1.0 / (waste + 1e-6) - fragmentation_penalty\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response6.txt_stdout.txt",
    "code_path": "problem_iter38_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a relative fragmentation penalty, prioritizing feasibility.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.1\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    priorities[suitable_bins] = fit_score - fragmentation_penalty * (1 - (waste / bins_remain_cap[suitable_bins]))\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response7.txt_stdout.txt",
    "code_path": "problem_iter38_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a relative fragmentation penalty for improved bin packing.\"\"\"\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n    if np.any(feasible_bins):\n        waste = bins_remain_cap[feasible_bins] - item\n        fragmentation_penalty = 0.05 * (1 - waste / bins_remain_cap[feasible_bins])\n        priorities[feasible_bins] = 1.0 / (waste + 1e-6) - fragmentation_penalty\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 100.07820003461549,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response8.txt_stdout.txt",
    "code_path": "problem_iter38_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines feasibility, inverse waste, and fragmentation penalty.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.1\n    priorities = np.where(bins_remain_cap >= item,\n                           1.0 / (bins_remain_cap - item + small_value) -\n                           fragmentation_penalty * (1 - (bins_remain_cap - item) / bins_remain_cap),\n                           0.0)\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 110.36149671375918,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter38_response9.txt_stdout.txt",
    "code_path": "problem_iter38_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit inverse waste with a relative fragmentation penalty,\n    focusing on numerical robustness.\"\"\"\n    small_value = 0.000664\n    fragmentation_penalty = 0.1\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    fit_score = 1.0 / (waste + small_value)\n    priorities[suitable_bins] = fit_score - fragmentation_penalty * (1 - (waste / bins_remain_cap[suitable_bins]))\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter39_response0.txt_stdout.txt",
    "code_path": "problem_iter39_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    small_value = 0.0001\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        priorities[feasible_bins] = 1.0 / (bins_remain_cap[feasible_bins] - item + small_value)\n        priorities[feasible_bins] -= fragmentation_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins])\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 10, in priority_v2\n    \nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'subtract' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n9\n2\n116.69205856195879\n"
  },
  {
    "stdout_filepath": "problem_iter39_response1.txt_stdout.txt",
    "code_path": "problem_iter39_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    small_value = 0.0001\n    fragmentation_penalty = 0.05\n    best_fit_weight = 0.6\n    first_fit_weight = 0.4\n    \n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    best_fit_priorities = np.where(feasible_bins, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    first_fit_priorities = np.where(feasible_bins, 1.0, 0.0)\n    \n    priorities = best_fit_weight * best_fit_priorities + first_fit_weight * first_fit_priorities\n    \n    priorities = priorities - fragmentation_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins])\n    \n    priorities[~feasible_bins] = 0.0\n    \n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 3.9788591942560925,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 194.3192398051029,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter39_response2.txt_stdout.txt",
    "code_path": "problem_iter39_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    small_value = 0.0001\n    frag_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        priorities[feasible_bins] = 1.0 / (bins_remain_cap[feasible_bins] - item + small_value)\n        priorities[feasible_bins] -= frag_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins])\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter39_response3.txt_stdout.txt",
    "code_path": "problem_iter39_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    small_value = 0.0001\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        priorities[feasible_bins] = 1.0 / (bins_remain_cap[feasible_bins] - item + small_value)\n        priorities[feasible_bins] -= fragmentation_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins])\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 116.69205856195879,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter39_response4.txt_stdout.txt",
    "code_path": "problem_iter39_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    small_value = 0.0001\n    fragmentation_penalty = 0.05\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        priorities[feasible_bins] = 1.0 / (bins_remain_cap[feasible_bins] - item + small_value)\n        priorities[feasible_bins] -= fragmentation_penalty * (1.0 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins])\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 10, in priority_v2\n    priorities[feasible_bins] -= fragmentation_penalty * (1 - (bins_remain_cap[feasible_bins] - item) / bins_remain_cap[feasible_bins])\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'subtract' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n9\n2\n116.69205856195879\n"
  },
  {
    "stdout_filepath": "problem_iter40_response0.txt_stdout.txt",
    "code_path": "problem_iter40_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, small_value: float = 0.0002979016150342,\n                fragmentation_penalty: float = 0.06876889105796839, best_fit_weight: float = 0.1269509077176042,\n                first_fit_weight: float = 0.10417962921319557) -> np.ndarray:\n    \"\"\"\n    Calculates priorities for bin selection based on best-fit and first-fit strategies.\n\n    Args:\n        item: The size of the item to be placed.\n        bins_remain_cap: An array representing the remaining capacity of each bin.\n        small_value: A small value to avoid division by zero. Defaults to 0.0001.\n        fragmentation_penalty: A penalty for fragmentation. Defaults to 0.05.\n        best_fit_weight: The weight given to the best-fit priority. Defaults to 0.6.\n        first_fit_weight: The weight given to the first-fit priority. Defaults to 0.4.\n\n    Returns:\n        An array of priorities for each bin.\n    \"\"\"\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  }
]