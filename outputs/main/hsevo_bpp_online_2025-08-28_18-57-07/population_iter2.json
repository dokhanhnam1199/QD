[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse remaining capacity with a check for valid bins.\n    Prioritizes bins with less remaining capacity after placing the item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    priorities[valid_bins] = 1.0 / (bins_remain_cap[valid_bins] - item + 1e-9)\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a check for valid bins.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        distances = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (distances + 1e-6)\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a check for feasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if np.sum(feasible_bins) > 0:\n        remaining_capacities = bins_remain_cap[feasible_bins]\n        waste = remaining_capacities - item\n        priorities[feasible_bins] = 1.0 / (waste + 1e-6)\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a capacity check for stability.\"\"\"\n    capacities = np.copy(bins_remain_cap)\n    capacities[capacities < item] = 0\n    valid_bins = capacities > 0\n    priorities = np.zeros_like(bins_remain_cap)\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1.0 / (capacities[valid_bins] - item + 1e-6)\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a feasibility check.\"\"\"\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + 1e-6), 0.0)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 39.863137138648355,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a check for feasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n    priorities[valid_bins] = bins_remain_cap[valid_bins] / (item + 1e-6)\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 35.690067810131644,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a check for feasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return priorities\n    remaining_capacities = bins_remain_cap[possible_bins]\n    waste = remaining_capacities - item\n    priorities[possible_bins] = 1.0 / (waste + 1e-6)\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a feasibility check.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if np.sum(feasible_bins) > 0:\n        priorities[feasible_bins] = 1.0 / (bins_remain_cap[feasible_bins] - item + 1e-6)\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a feasibility check.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) > 0:\n        remaining_capacities = bins_remain_cap[possible_bins]\n        waste = remaining_capacities - item\n        priorities[possible_bins] = 1.0 / (waste + 1e-6)\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse remaining capacity with a check for feasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if np.sum(suitable_bins) > 0:\n        priorities[suitable_bins] = 1.0 / (bins_remain_cap[suitable_bins] - item + 1e-9)\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  }
]