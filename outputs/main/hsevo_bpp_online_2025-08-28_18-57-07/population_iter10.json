[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines minimum waste and inverse waste for better bin selection.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    min_waste = np.min(waste)\n    indices = np.where(suitable_bins)[0]\n    for i in indices:\n        if bins_remain_cap[i] - item == min_waste:\n            priorities[i] = 1.0\n        else:\n            priorities[i] = 1.0 / (waste[np.where(indices == i)[0][0]] + 1e-6)\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999963760000355 seconds"
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best of v0 & v1: Feasibility + inverse waste, with a small value for robustness.\"\"\"\n    small_value = 1e-6\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 39.863137138648355,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best of v0 & v1: feasibility check with waste minimization.\"\"\"\n    small_value = 0.000664\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 39.863137138648355,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines feasibility with inverse remaining capacity and a waste factor.\"\"\"\n    small_value = 1e-9\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    \n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = (1.0 / (waste + small_value)) * (1.0 - (waste / (bins_remain_cap[valid_bins] + small_value)))\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 110.44611534953322,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines minimum waste with inverse remaining capacity for prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    min_waste = np.min(waste)\n    indices = np.where(suitable_bins)[0]\n    for i in indices:\n        if bins_remain_cap[i] - item == min_waste:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-6)\n        else:\n            priorities[i] = 0.0\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 14.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 95.90827503317318,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines minimum waste with inverse remaining capacity for better prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n\n    min_waste = np.min(bins_remain_cap[suitable_bins] - item)\n    indices = np.where(bins_remain_cap >= item)[0]\n\n    for i in indices:\n        if bins_remain_cap[i] - item == min_waste:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-9)\n        else:\n            priorities[i] = 0.0\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 13.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 108.41805003750011,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization (v0) with feasibility check (v1) for robustness.\"\"\"\n    small_value = 0.000664\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 39.863137138648355,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines minimum waste with inverse remaining capacity for robust prioritization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        distances = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (distances + 1e-6)\n        min_waste = np.min(distances)\n        indices = np.where(bins_remain_cap >= item)[0]\n        for i in indices:\n            if bins_remain_cap[i] - item == min_waste:\n                priorities[i] += 1.0\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines feasibility check with inverse remaining capacity and a small value to avoid division by zero.\"\"\"\n    small_value = 1e-9\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 39.863137138648355,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines minimum waste with inverse remaining capacity for bin selection.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n    waste = bins_remain_cap[suitable_bins] - item\n    min_waste = np.min(waste)\n    indices = np.where(suitable_bins)[0]\n    for i in indices:\n        if bins_remain_cap[i] - item == min_waste:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-6)\n        else:\n            priorities[i] = 0.0\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 14.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 95.90827503317318,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n\n    waste = bins_remain_cap[suitable_bins] - item\n    min_waste = np.min(waste)\n    best_bins = np.where(waste == min_waste)[0]\n    \n    for i in best_bins:\n        bin_index = suitable_bins.nonzero()[0][i]\n        priorities[bin_index] = 1.0\n\n    remaining_capacities = bins_remain_cap[suitable_bins]\n    avg_remaining = np.mean(remaining_capacities)\n\n    for i in range(len(bins_remain_cap)):\n        if suitable_bins[i]:\n            if bins_remain_cap[i] > avg_remaining:\n                priorities[i] += 0.5\n            elif bins_remain_cap[i] < avg_remaining:\n                priorities[i] -= 0.2\n            \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996620000002 seconds"
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n\n    if not np.any(suitable_bins):\n        return priorities\n\n    waste = bins_remain_cap[suitable_bins] - item\n    \n    priorities[suitable_bins] = 1.0 / (waste + 1e-6) \n    \n    avg_cap = np.mean(bins_remain_cap)\n    \n    for i in np.where(suitable_bins)[0]:\n        if bins_remain_cap[i] <= avg_cap:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 0.2\n\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996998000006 seconds"
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n\n    if not np.any(suitable_bins):\n        return priorities\n\n    bin_indices = np.where(suitable_bins)[0]\n    waste = bins_remain_cap[suitable_bins] - item\n    \n    priorities[suitable_bins] = 1.0 / (waste + 1e-6) \n\n    \n    mean_cap = np.mean(bins_remain_cap)\n    for i in bin_indices:\n      if bins_remain_cap[i] > mean_cap:\n        priorities[i] += 0.1\n      else:\n        priorities[i] -= 0.05\n\n    \n    first_fit_index = np.where(bins_remain_cap >= item)[0][0]\n    priorities[first_fit_index] += 0.2\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999969970000166 seconds"
  },
  {
    "stdout_filepath": "problem_iter9_response3.txt_stdout.txt",
    "code_path": "problem_iter9_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n    if not np.any(suitable_bins):\n        return priorities\n\n    waste = bins_remain_cap[suitable_bins] - item\n    \n    fit_score = 1.0 / (waste + 1e-6)\n    \n    fragmentation_penalty = 1.0 / (bins_remain_cap[suitable_bins] + 1e-6)\n    \n    priorities[suitable_bins] = fit_score * (1.0 - 0.2 * fragmentation_penalty)\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 127.37720526058406,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response4.txt_stdout.txt",
    "code_path": "problem_iter9_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins = bins_remain_cap >= item\n\n    if not np.any(suitable_bins):\n        return priorities\n\n    waste = bins_remain_cap[suitable_bins] - item\n    \n    best_bin_index = np.argmin(waste)\n    best_bin_priority = 1.0\n    \n    for i in range(n_bins):\n        if suitable_bins[i]:\n            if i == np.where(suitable_bins)[0][best_bin_index]:\n                priorities[i] = best_bin_priority\n            else:\n                priorities[i] = 0.5\n    \n    \n    \n    avg_remaining_cap = np.mean(bins_remain_cap[suitable_bins])\n    \n    \n    for i in range(n_bins):\n        if suitable_bins[i]:\n            if bins_remain_cap[i] > avg_remaining_cap:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.1\n    \n    \n    \n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997474999964 seconds"
  },
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, small_value: float = 0.00014194373954601908) -> np.ndarray:\n    \"\"\"Combines best of v0 & v1: Feasibility + inverse waste, with a small value for robustness.\"\"\"\n    priorities = np.where(bins_remain_cap >= item, 1.0 / (bins_remain_cap - item + small_value), 0.0)\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 39.863137138648355,
    "exec_success": true
  }
]