```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins by combining Best Fit with a penalty for very large remaining capacities.
    Favors bins that are a tight fit and discourages using bins that are excessively underfilled.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if np.any(suitable_bins_mask):
        suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
        
        # Best Fit component: Smaller difference is better
        best_fit_diff = suitable_bins_cap - item
        
        # Normalize the Best Fit scores to be between 0 and 1, higher is better
        # Add a small epsilon to avoid division by zero if an item perfectly fills a bin.
        # Invert and normalize: smaller diff -> higher score
        if np.max(best_fit_diff) > np.min(best_fit_diff):
            best_fit_scores = 1.0 - (best_fit_diff - np.min(best_fit_diff)) / (np.max(best_fit_diff) - np.min(best_fit_diff) + 1e-9)
        else:
            best_fit_scores = np.ones_like(best_fit_diff) # All gaps are the same

        # Penalty for "too much" remaining capacity (inspired by Heuristics 11-13)
        # Penalize bins where remaining capacity is much larger than the item size.
        # Use a sigmoid-like penalty that is close to 0 for small differences and approaches 1 for large ones.
        # This is subtracted from the best_fit_score. A high penalty means low priority.
        # Threshold and steepness can be tuned. Here, penalty increases significantly when remaining capacity > 2*item.
        penalty_threshold_ratio = 2.0 
        penalty_steepness = 0.5
        
        large_capacity_penalty = 1.0 / (1.0 + np.exp(-penalty_steepness * (suitable_bins_cap - item * penalty_threshold_ratio)))
        
        # Combine scores: Additive combination, where penalty is subtracted.
        # This means higher best_fit_score is good, higher penalty is bad.
        combined_priorities = best_fit_scores - large_capacity_penalty

        # Assign the calculated priorities to the original indices
        original_indices = np.where(suitable_bins_mask)[0]
        priorities[original_indices] = combined_priorities

    return priorities
```
