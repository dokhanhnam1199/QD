import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1.8490497063175138e-06, best_fit_weight: float = 1.1875132346022212, capacity_penalty_weight: float = 4.109046245776195) -> np.ndarray:
    """
    Combines Best Fit with a penalty for bins that are too large,
    prioritizing tighter fits while avoiding extremely large remaining capacities.

    Args:
        item: The size of the item to be placed.
        bins_remain_cap: A numpy array representing the remaining capacity of each bin.
        epsilon: A small constant to prevent division by zero in the best fit calculation.
        best_fit_weight: Weight for the best fit component.
        capacity_penalty_weight: Weight for the penalty of large remaining capacities.

    Returns:
        A numpy array representing the priority score for each bin.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)
    can_fit_mask = bins_remain_cap >= item
    
    bins_that_can_fit_caps = bins_remain_cap[can_fit_mask]
    
    if bins_that_can_fit_caps.size > 0:
        gaps = bins_that_can_fit_caps - item
        
        # Best Fit component: prioritize bins with the smallest gap.
        best_fit_scores = best_fit_weight / (gaps + epsilon)
        
        # Penalty for bins that have large remaining capacity.
        # We use negative of the capacity to make larger capacities result in lower scores.
        # This is effectively penalizing larger remaining capacities.
        capacity_penalty = -capacity_penalty_weight * bins_that_can_fit_caps
        
        # Combine best fit score with capacity penalty.
        # The original logic `(1.0 / (gaps + 1e-9)) - bins_that_can_fit_caps`
        # can be represented as:
        # best_fit_weight * (1.0 / (gaps + epsilon)) + (-capacity_penalty_weight * bins_that_can_fit_caps)
        priorities[can_fit_mask] = best_fit_scores + capacity_penalty
        
    return priorities
