```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a normalized logarithmic penalty for remaining capacity.
    Prioritizes bins with minimal leftover space, penalizing larger gaps logarithmically.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
    
    best_fit_diff = suitable_bins_cap - item
    
    # Use a normalized logarithmic penalty for remaining capacity
    # Add a small epsilon to avoid log(0) and ensure positive values
    epsilon = 1e-9
    
    # Normalize the differences to be between 0 and 1 (approximately)
    # This helps in creating a more balanced penalty across different scales of remaining capacity
    normalized_diff = best_fit_diff / (suitable_bins_cap + epsilon) 

    # Logarithmic penalty: smaller differences get higher scores
    # Use log1p for better numerical stability when normalized_diff is close to 0
    penalty = -np.log1p(normalized_diff)

    # Apply the penalty to the priorities. Higher penalty means lower priority.
    # We want to invert this, so we can use the penalty itself as a higher score for better fits.
    # A simple way is to use the negative of the penalty.
    priorities[suitable_bins_mask] = -penalty

    # Ensure that bins that exactly fit the item (diff=0) get a high priority
    # This can be handled by the log1p(0) = 0, so -0 = 0, which might be lower than others.
    # We can adjust this by ensuring a base score or by modifying the penalty.
    # For now, let's rely on the fact that smaller diffs lead to higher (less negative) penalty.

    return priorities
```
