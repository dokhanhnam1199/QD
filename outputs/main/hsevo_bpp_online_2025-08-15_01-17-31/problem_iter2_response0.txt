```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for bins that are too large,
    prioritizing tighter fits while avoiding extremely large remaining capacities.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)
    can_fit_mask = bins_remain_cap >= item
    
    bins_that_can_fit_caps = bins_remain_cap[can_fit_mask]
    
    if bins_that_can_fit_caps.size > 0:
        gaps = bins_that_can_fit_caps - item
        
        # Best Fit component: prioritize bins with the smallest gap.
        # We use 1/(gap + epsilon) which gives higher scores to smaller gaps.
        best_fit_scores = 1.0 / (gaps + 1e-9)
        
        # Additional component: Penalize bins that leave very large remaining capacity.
        # This can be done by considering the capacity relative to the item size or bin capacity.
        # Let's penalize bins where `bins_remain_cap` is significantly larger than `item`.
        # A simple penalty could be based on the reciprocal of the remaining capacity after fitting.
        # Or, inversely related to the capacity AFTER fitting. Smaller post-fit capacity is better.
        # Let's use a function that increases with smaller `bins_that_can_fit_caps - item`.
        # The `best_fit_scores` already do this.

        # Let's try to combine a "Best Fit" aspect with a "First Fit Decreasing" like preference
        # for using up existing bins first.
        # The 1/(gap + epsilon) is a strong "Best Fit".
        
        # A potential improvement: If multiple bins offer a very tight fit (small gap),
        # we might prefer the one that has been used more or has less absolute capacity
        # to keep larger bins available for larger items.
        
        # Let's modify the score slightly to favor bins that are "more full" among the best fits.
        # This can be achieved by adding a term that increases with `bins_remain_cap`.
        # However, this might conflict with "Best Fit" if a slightly larger bin is a slightly worse fit.
        
        # Let's stick to a refined Best Fit. The core idea is to minimize the leftover space.
        # The previous `best_fit_scores` are good.
        # To make it more "adaptive" or "robust", we can consider a secondary criterion if multiple
        # bins have very similar small gaps.
        
        # Example:
        # Bins capacities: [10, 10, 10, 10]
        # Item: 3
        # Bins remain cap: [2, 5, 8, 9]
        # Item fits in all. Gaps: [2-3, 5-3, 8-3, 9-3] = [-1, 2, 5, 6] - This is wrong, it's `bins_remain_cap - item`.
        # Bins remain cap: [2, 5, 8, 9]
        # Item: 3
        # Bins remaining capacity: [2, 5, 8, 9]
        # Gaps: [2-3, 5-3, 8-3, 9-3] -> these are only for bins that fit.
        # Assume bins_remain_cap = [2, 5, 8, 9], item = 3.
        # can_fit_mask = [False, True, True, True]
        # bins_that_can_fit_caps = [5, 8, 9]
        # gaps = [5-3, 8-3, 9-3] = [2, 5, 6]
        # best_fit_scores = [1/(2+eps), 1/(5+eps), 1/(6+eps)] = [~0.5, ~0.2, ~0.16]
        # This prioritizes the bin with remaining capacity 5.

        # Consider the case where `item` itself is very large.
        # If `item` is close to bin capacity, the gap will be small.
        # The current `1.0 / (gaps + epsilon)` prioritizes these.
        
        # Let's try a slight modification to the priority to encourage using bins
        # that are "closer" to fitting the item without being too small.
        # This is essentially what Best Fit does.
        
        # We can also incorporate a slight bias towards bins that are *not* completely empty,
        # to encourage filling up partially used bins before starting new ones.
        # This is more of a "First Fit" idea, but can be combined.
        
        # Let's try prioritizing bins by their remaining capacity AFTER fitting the item.
        # We want to MINIMIZE this remaining capacity.
        # Priority = - (bins_remain_cap - item)
        # This directly makes smaller positive gaps have higher priority.
        # Example: gaps = [2, 5, 6] -> priorities = [-2, -5, -6]. Max is -2.
        # This means the bin with the smallest gap is prioritized.

        # Let's combine the "tight fit" with a "less empty" preference.
        # A simple way is to add a term that is inversely related to the remaining capacity.
        # Priority = (1.0 / (gaps + epsilon)) + log(bins_that_can_fit_caps)
        # This might be too complex.
        
        # A simpler combination: Best Fit score with a small bonus for bins that have
        # less *total* capacity (to use up partially filled bins first).
        # So, the priority for fitting bins will be:
        # score = (1.0 / (gaps + epsilon)) + (1.0 / (bins_that_can_fit_caps + epsilon))
        # This adds a preference for smaller capacity bins among those with similar gaps.
        
        # Let's normalize `bins_that_can_fit_caps` to avoid large values dominating.
        # Or, let's focus on the `gaps` and add a term that penalizes very large `bins_that_can_fit_caps`
        # when the gap is also not very small.
        
        # Revisit the core goal: pick the bin `j` that minimizes `bins_remain_cap[j] - item`.
        # The `best_fit_scores = 1.0 / (gaps + 1e-9)` achieves this by giving higher scores
        # to smaller positive gaps.
        
        # Let's try to slightly "flatten" the advantage of extremely small gaps,
        # and give a slight boost to bins that are "mediumly" sized and fit well.
        # This can be done by squaring the gap or using a different function.
        
        # Let's use a combination of "Best Fit" and "Worst Fit" (to keep options open).
        # No, the goal is best fit.
        
        # Consider a heuristic that looks at `bins_remain_cap - item` and `bins_remain_cap`.
        # We want to minimize `bins_remain_cap - item`.
        # We also implicitly want to use bins that are not excessively large if the fit is similar.
        
        # Let's propose a heuristic that prioritizes bins that have a small gap,
        # AND among those with small gaps, prefers bins that have less total capacity.
        # The score for a bin that fits:
        # priority_score = (1.0 / (bins_that_can_fit_caps - item + 1e-9))  # Best Fit part
        # Let's add a term that rewards using bins with smaller remaining capacity.
        # This could be `-(bins_that_can_fit_caps)`.
        # So, priority = (1.0 / (gaps + 1e-9)) - bins_that_can_fit_caps
        # This would favor smaller gaps, and among equal gaps, it favors smaller `bins_that_can_fit_caps`.
        
        priorities[can_fit_mask] = (1.0 / (gaps + 1e-9)) - bins_that_can_fit_caps
        
    return priorities
```
