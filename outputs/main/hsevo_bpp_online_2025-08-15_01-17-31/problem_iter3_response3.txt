```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if np.any(suitable_bins_mask):
        suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
        
        # Calculate the "wasted space" for each suitable bin
        wasted_space = suitable_bins_cap - item
        
        # Calculate the inverse of wasted space to prioritize bins with less wasted space
        # Add a small epsilon to avoid division by zero if wasted_space is 0
        inverse_wasted_space = 1.0 / (wasted_space + 1e-9)
        
        # Normalize these scores to be between 0 and 1
        if np.max(inverse_wasted_space) > 0:
            normalized_scores = inverse_wasted_space / np.max(inverse_wasted_space)
        else:
            normalized_scores = np.zeros_like(inverse_wasted_space)
            
        # Assign these normalized scores to the corresponding original indices
        original_indices = np.where(suitable_bins_mask)[0]
        priorities[original_indices] = normalized_scores
        
        # Additionally, give a slight bonus to bins that are almost full (closer to bin capacity)
        # This encourages fuller bins, which can be beneficial in some scenarios
        fullness_score = (suitable_bins_cap - item) / suitable_bins_cap if np.any(suitable_bins_cap > 0) else np.zeros_like(suitable_bins_cap)
        fullness_score = 1.0 - fullness_score # Higher score for fuller bins
        
        # Combine the two scores (e.g., weighted average)
        # For simplicity, we'll just add them, giving more weight to the inverse_wasted_space score
        # You might want to tune these weights or use a more sophisticated combination
        combined_scores = normalized_scores + 0.2 * fullness_score
        
        # Re-normalize the combined scores
        if np.max(combined_scores) > 0:
            final_priorities = combined_scores / np.max(combined_scores)
        else:
            final_priorities = np.zeros_like(combined_scores)
            
        priorities[original_indices] = final_priorities

    return priorities
```
