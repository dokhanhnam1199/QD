```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if np.any(suitable_bins_mask):
        suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
        
        # Calculate difference for best fit
        best_fit_diff = suitable_bins_cap - item
        
        # Calculate a "waste reduction" score, prioritizing bins with less remaining capacity after packing
        # This encourages filling bins more completely
        waste_reduction_score = 1.0 / (suitable_bins_cap - item + 1e-9) # Add epsilon to avoid division by zero
        
        # Calculate a "capacity utilization" score, prioritizing bins that are already relatively full
        # This is inversely proportional to remaining capacity
        capacity_utilization_score = 1.0 / (bins_remain_cap[suitable_bins_mask] + 1e-9) # Add epsilon to avoid division by zero
        
        # Combine scores, giving more weight to waste reduction
        # The weights can be tuned
        combined_score = 0.7 * waste_reduction_score + 0.3 * capacity_utilization_score
        
        # Normalize scores to be between 0 and 1
        if np.max(combined_score) > 0:
            normalized_scores = combined_score / np.max(combined_score)
        else:
            normalized_scores = np.zeros_like(combined_score)

        # Assign higher priorities to bins with better combined scores
        priorities[suitable_bins_mask] = normalized_scores
    
    return priorities
```
