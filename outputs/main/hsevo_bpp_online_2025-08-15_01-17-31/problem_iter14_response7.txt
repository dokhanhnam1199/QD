```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with an adaptive logarithmic penalty, prioritizing bins
    that minimize wasted space while avoiding overly full bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
    original_indices = np.where(suitable_bins_mask)[0]
    
    # Best Fit Component: Minimize remaining capacity after packing
    remaining_after_fit = suitable_bins_cap - item
    
    # Adaptive Logarithmic Penalty: Penalize larger gaps logarithmically.
    # Add 1 to the denominator to prevent division by zero and scale penalty.
    penalty = np.log1p(remaining_after_fit / (item + 1e-9))
    
    # Normalize penalties to range [0, 1] where higher penalty means lower priority
    if np.max(penalty) > 0:
        normalized_penalty = penalty / np.max(penalty)
    else:
        normalized_penalty = np.zeros_like(penalty)
    
    # Combined Score: Prioritize bins with lower normalized penalties (better fit)
    # A higher score indicates higher priority.
    scores = 1.0 - normalized_penalty
    
    # Assign priorities to the original indices
    priorities[original_indices] = scores
    
    return priorities
```
