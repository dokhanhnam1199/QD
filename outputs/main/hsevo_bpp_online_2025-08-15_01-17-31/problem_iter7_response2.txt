import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, penalty_strength: float = 0.007919842571399105, epsilon: float = 3.5732087865907558e-09) -> np.ndarray:
    """
    Combines Best Fit with a penalty for excessively large remaining capacities,
    prioritizing bins that fit the item tightly and are not overly empty.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities
    
    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # Best Fit component: inverse of the remaining gap after placing the item.
    # Higher score for smaller gaps (tighter fits).
    best_fit_scores = 1.0 / (valid_bins_remain_cap - item + epsilon)
    
    # Penalty for "too much" remaining capacity.
    # This penalizes bins that will be left significantly empty after the item is placed.
    # We use a logarithmic penalty to be less aggressive than exponential.
    # The penalty is higher for larger remaining capacities.
    # We subtract 1 to make the penalty focus on capacity substantially larger than the item.
    # If remaining capacity is close to item size, penalty is small.
    # If remaining capacity is much larger, penalty is significant.
    # penalty_factor = 0.5 # Tunable parameter for penalty strength
    # Avoid log(0) or log(negative) by ensuring argument is > 1
    # penalty_arg = (valid_bins_remain_cap / item) if item > 0 else np.inf
    # We only want to penalize if remaining capacity is significantly larger than the item
    # Let's define "significantly larger" as > 2 * item for instance.
    # A simpler approach is to penalize based on the absolute remaining capacity if it's large.
    # Or penalize based on the *proportion* of capacity left.
    # Let's try penalizing remaining capacity relative to bin's original capacity (if known, but it's not).
    # Instead, let's penalize based on the *remaining_cap_after_fit - item*.
    # If remaining_cap_after_fit - item is large, we want a larger penalty.
    # Using log((valid_bins_remain_cap - item) + epsilon) can work, but a simpler penalty might be better.
    # Let's consider the "slack" as in priority_v0 but inverted, penalizing large slack.
    # A linear penalty on slack: -(valid_bins_remain_cap - item)
    # A better penalty based on "over-emptiness":
    # Penalty is higher if (valid_bins_remain_cap - item) is large compared to 'item'.
    # Let's adapt Heuristics 11-13 logic but make it simpler.
    # Penalty is proportional to the remaining capacity AFTER the item is placed, if it's "too much".
    # A threshold could be 'item', meaning if remaining capacity > item, penalize.
    # Or if remaining capacity > some fraction of bin capacity (unknown).
    # Let's try to penalize bins where `valid_bins_remain_cap - item` is large.
    # We want to reduce priority for bins that will be left very empty.
    # A simple penalty could be proportional to `valid_bins_remain_cap`.
    # Or `valid_bins_remain_cap / item`.
    # Let's use a penalty that decreases priority if remaining capacity is large.
    # The inverse of remaining capacity was used in v0 for "fullness". Let's use that in reverse.
    # Penalize if `valid_bins_remain_cap` is large.
    # Penalty = f(valid_bins_remain_cap). We want f to be decreasing.
    # Let's use a simple negative linear term on the remaining capacity itself.
    # This is related to the 'slack_scores' in v0 but as a penalty.
    # penalty = penalty_factor * valid_bins_remain_cap
    
    # Alternative penalty idea: penalize bins that are "too empty" in terms of how much
    # larger their remaining capacity is compared to the item size.
    # For example, if remaining_cap - item > item, then it's "too empty".
    # Let's create a penalty term that is larger for larger remaining capacities.
    # Using the inverse of remaining capacity from v0's slack_scores, but subtracting it.
    # This prioritizes bins that will be fuller.
    # `slack_scores` from v0: 1.0 / (valid_bins_remain_cap + epsilon)
    # If we subtract this, we penalize fuller bins. This is not what we want.
    # We want to penalize *emptier* bins.
    # Let's try: penalty is proportional to the *amount of wasted space* in the bin *after* fitting.
    # Wasted space = valid_bins_remain_cap - item
    # Penalty = penalty_factor * (valid_bins_remain_cap - item)
    # This would reduce priority for bins with larger remaining space.
    
    # Combine Best Fit with a penalty for bins that are likely to be left very empty.
    # The penalty is stronger for bins with a larger remaining capacity after placing the item.
    # We want to reduce the score if `valid_bins_remain_cap - item` is large.
    # Let's use the score `(valid_bins_remain_cap - item)` directly as a penalty.
    # This is effectively saying: `best_fit_score - penalty_factor * (remaining_capacity_after_fit)`.
    
    # Let's refine the penalty to be based on the "emptiness ratio" of the bin after packing.
    # If a bin has capacity C and we place item I, remaining is C-I.
    # If C-I is large, we penalize.
    # Consider the capacity ratio of the *remaining space* to the *item size*.
    # If `(valid_bins_remain_cap - item) / item` is large, we penalize.
    # `penalty_term = penalty_factor * ((valid_bins_remain_cap - item) / item)`
    # This handles cases where `item` is small, leading to large penalties if remaining is large.
    # Let's clip this ratio to avoid extreme values, perhaps by limiting how much larger the remaining space can be.
    # A simpler approach: penalize if `valid_bins_remain_cap` itself is large.
    # Let's use the `slack_scores` from v0 but adjust the combination.
    # `best_fit_scores` are good. We want to *decrease* priority if `valid_bins_remain_cap` is large.
    # So, we can subtract a term that increases with `valid_bins_remain_cap`.
    
    # Let's combine Best Fit with a penalty for remaining capacity that's much larger than the item size.
    # This aims to select bins that are "almost full" but can still accommodate the item.
    # The "gap" is `valid_bins_remain_cap - item`. Best Fit prioritizes small gaps.
    # The "slack" is `valid_bins_remain_cap`. We want to penalize large slack.
    # Let's define a penalty that is larger for larger slack.
    # A simple linear penalty: `penalty_amount = penalty_factor * valid_bins_remain_cap`
    # This could be too aggressive.
    
    # Consider Heuristic 10's approach: `best_fit_score * (1 - penalty_weight * (remaining_capacity / bin_capacity))`
    # Since bin_capacity is unknown, we can use `item` or a scaled `valid_bins_remain_cap`.
    # Let's try: `best_fit_score * (1 - penalty_factor * (valid_bins_remain_cap / (item + epsilon)))`
    # This would penalize bins where remaining capacity is large relative to item size.
    # If `valid_bins_remain_cap < item`, the term `(valid_bins_remain_cap / (item + epsilon))` is < 1.
    # `1 - penalty_factor * (...)` would be greater than `1 - penalty_factor`.
    # This boosts bins that leave less space *relative to item size*.
    # This is similar to boosting bins that are "almost full" when scaled by item size.
    
    # Let's combine the Best Fit score with a penalty that reduces priority for bins
    # with a large amount of remaining capacity *after* the item is placed.
    # We can use a term that is proportional to the remaining capacity itself.
    # Penalty = `penalty_factor * (valid_bins_remain_cap - item)`
    # This makes the priority: `best_fit_score - penalty_factor * (valid_bins_remain_cap - item)`
    # This is equivalent to prioritizing bins with `1 / (gap) - penalty_factor * (gap)`.
    
    # Let's adopt a penalty based on the "emptiness" of the bin *after* placement.
    # We want to penalize bins where `valid_bins_remain_cap` is large.
    # A simple way is to subtract a fraction of `valid_bins_remain_cap`.
    # The "gap" is `valid_bins_remain_cap - item`.
    # Let's combine the inverse gap (best fit) with the inverse of remaining capacity (fullness).
    # v0 used (best_fit + slack)/2.
    # v1 uses normalized best_fit - penalty.
    # Let's try a weighted sum of best_fit_scores and a penalty for slack.
    # Penalty for slack: `penalty_factor * (valid_bins_remain_cap / (item + epsilon))`
    # This penalizes bins where remaining capacity is large relative to item size.
    # If `valid_bins_remain_cap = item`, penalty is `penalty_factor`.
    # If `valid_bins_remain_cap = 2 * item`, penalty is `2 * penalty_factor`.
    
    # Final approach: combine the 'best fit' score (inverse gap) with a penalty
    # that reduces priority for bins that will have a lot of remaining capacity.
    # This aims to select bins that are a tight fit and do not leave excessive empty space.
    # Penalty is applied if `valid_bins_remain_cap` is significantly larger than `item`.
    
    # Let's use the `best_fit_scores` and subtract a penalty proportional to the
    # `valid_bins_remain_cap` to favor fuller bins.
    # penalty_strength = 0.2 # Tunable parameter for penalty
    
    # Calculate combined priorities: Best fit score minus a penalty for remaining capacity.
    # This prioritizes bins that fit the item snugly (high best_fit_scores)
    # and de-prioritizes bins that will have a lot of remaining space.
    combined_priorities = best_fit_scores - penalty_strength * (valid_bins_remain_cap - item)
    
    # Assign the calculated priorities to the original indices
    original_indices = np.where(can_fit_mask)[0]
    priorities[original_indices] = combined_priorities

    return priorities
