```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a dynamic penalty for remaining capacity,
    prioritizing tight fits and bins that are not excessively empty,
    adapting the penalty based on the item size relative to bin capacity.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities
    
    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # Best Fit component: inverse of the remaining gap after placing the item.
    # Higher score for smaller gaps (tighter fits).
    epsilon = 1e-9
    best_fit_scores = 1.0 / (valid_bins_remain_cap - item + epsilon)
    
    # Penalty for "too much" remaining capacity.
    # This penalty is designed to de-prioritize bins that will be left very empty.
    # We use a term that scales with the remaining capacity relative to the item size,
    # but also considers the absolute remaining capacity to avoid overly penalizing
    # small items in large bins.
    # The penalty should be higher when `valid_bins_remain_cap` is large and `item` is small.
    # A simpler approach is to penalize based on `valid_bins_remain_cap` directly,
    # but scaled to be relative to the item's size.
    # Consider the "emptiness" after packing: `valid_bins_remain_cap - item`.
    # A penalty proportional to this emptiness, possibly dampened by a log, could work.
    # Let's try to combine Best Fit with a penalty that is stronger for larger remaining capacities,
    # but also considers that a larger bin might *inherently* have more remaining capacity.
    # A penalty based on the ratio of remaining capacity to the item size might be too aggressive for small items.
    # Instead, let's use a penalty that is primarily based on the absolute remaining capacity,
    # but modulated by the item size.
    # The idea is to favor bins that have *just enough* space.
    
    # Based on analysis, a combination of Best Fit score and a subtractive penalty
    # that is linear with the remaining capacity after fitting, but with a tunable strength,
    # seems effective. This is similar to priority_v0, but we'll try to refine the penalty term.
    # Let's use a penalty that is proportional to the *slack* (`valid_bins_remain_cap - item`)
    # but also influenced by the *item size* itself to avoid over-penalizing small items in large bins.
    
    # Penalty = penalty_strength * (remaining_capacity_after_fit / item)
    # However, if item is very small, this penalty can be excessive.
    # Let's try a penalty that combines the absolute slack with a relative slack.
    
    # A common strategy is to combine a "goodness" score (like Best Fit) with a "badness" penalty.
    # Goodness: 1 / (gap)
    # Badness: related to remaining capacity.
    # Let's use a penalty that increases with the remaining capacity after fitting,
    # but ensure it's not overly aggressive by bounding its influence.
    
    # Inspired by `priority_v0` and `priority_v1`'s idea of combining BF with a penalty.
    # Let's take the Best Fit score and subtract a penalty proportional to the
    # remaining capacity *after* the item is placed. This rewards tighter fits
    # and discourages bins that will be left with a large amount of unused space.
    
    penalty_strength = 0.3 # Tunable parameter: Controls how much we penalize remaining capacity.
    
    # The penalty term: proportional to the remaining capacity after the item is placed.
    # We subtract this penalty from the best_fit_scores.
    # This means bins that fit the item tightly (high best_fit_scores) and will have
    # less remaining capacity (lower penalty) will get higher priority.
    penalty_value = penalty_strength * (valid_bins_remain_cap - item)
    
    # Combine the best fit score with the penalty.
    combined_priorities = best_fit_scores - penalty_value
    
    # Assign the calculated priorities to the original indices
    original_indices = np.where(can_fit_mask)[0]
    priorities[original_indices] = combined_priorities

    return priorities
```
