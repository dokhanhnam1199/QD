```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if np.any(suitable_bins_mask):
        suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
        
        best_fit_metric = suitable_bins_cap - item
        
        # Normalize the best fit metric to be between 0 and 1
        # Add a small epsilon to avoid division by zero if all suitable bins are perfectly filled
        normalized_best_fit = best_fit_metric / (np.max(best_fit_metric) + 1e-9)
        
        # Introduce a penalty for bins that are too empty relative to the item size
        # This encourages using bins that are "almost full" to minimize waste
        # Normalize this penalty too
        # Larger remaining capacity means a higher penalty score (less desirable)
        max_remaining_cap = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1e-9
        empty_bin_penalty = (bins_remain_cap[suitable_bins_mask] - item) / max_remaining_cap
        
        # Combine metrics: Prioritize smaller differences (better fit) and penalize larger remaining capacities
        # We want to minimize normalized_best_fit and minimize empty_bin_penalty
        # So, a lower combined score is better. We'll invert it for higher priority.
        
        # Assign a base priority (e.g., 1.0 for all suitable bins) and then adjust
        base_priority = np.ones_like(suitable_bins_cap)
        
        # Lower score in normalized_best_fit is better, so we subtract it from base priority
        # Lower score in empty_bin_penalty is better, so we subtract it from base priority
        # Add a small factor to emphasize the best fit
        combined_score = base_priority - (0.7 * normalized_best_fit + 0.3 * empty_bin_penalty)
        
        # Now, assign these scores to the priorities array at the appropriate indices
        original_indices = np.where(suitable_bins_mask)[0]
        priorities[original_indices] = combined_score

    return priorities
```
