```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a smooth, adaptive penalty for large remaining capacities.
    Prioritizes tight fits while penalizing significantly underfilled bins gracefully.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)
    can_fit_mask = bins_remain_cap >= item
    
    suitable_bins_caps = bins_remain_cap[can_fit_mask]
    
    if suitable_bins_caps.size > 0:
        gaps = suitable_bins_caps - item
        
        # Best Fit component: prioritize smaller gaps (higher score for smaller gaps)
        # Using 1/(gap + epsilon) provides a good base score.
        best_fit_scores = 1.0 / (gaps + 1e-9)
        
        # Adaptive penalty for large remaining capacity:
        # Penalize bins where remaining capacity is much larger than the item size.
        # Using a sigmoid-like function centered around a ratio (e.g., 2.0)
        # to smoothly increase penalty as capacity exceeds item size significantly.
        # A steepness factor controls how quickly the penalty ramps up.
        penalty_threshold_ratio = 2.0 
        penalty_steepness = 0.7 # Slightly steeper than v1 for more pronounced penalty
        
        # Penalty is high when capacity is much larger than item * ratio, approaches 0 otherwise.
        # This encourages using bins that are not excessively empty relative to the item.
        large_capacity_penalty = 1.0 / (1.0 + np.exp(-penalty_steepness * (suitable_bins_caps / (item + 1e-9) - penalty_threshold_ratio)))
        
        # Combine scores: Subtract the penalty from the best-fit score.
        # This means a bin with a good fit (high best_fit_score) but also a large
        # remaining capacity (high penalty) will have its priority reduced.
        combined_scores = best_fit_scores - large_capacity_penalty
        
        priorities[can_fit_mask] = combined_scores
        
    return priorities
```
