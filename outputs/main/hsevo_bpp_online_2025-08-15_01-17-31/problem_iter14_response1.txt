```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with an adaptive penalty for overfilled bins,
    prioritizing tight fits while smoothly penalizing bins with excess capacity.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if np.any(suitable_bins_mask):
        suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
        
        gaps = suitable_bins_cap - item
        
        # Best Fit component: higher score for smaller gaps (tighter fits)
        # Adding a small epsilon for numerical stability.
        best_fit_scores = 1.0 / (gaps + 1e-9)
        
        # Adaptive penalty for excess capacity:
        # Penalizes bins where remaining capacity is significantly larger than the item size.
        # Uses a sigmoid-like function to smoothly increase the penalty.
        # The penalty is applied if the bin's remaining capacity is more than twice the item size.
        penalty_threshold_ratio = 2.0 
        penalty_steepness = 1.0  # Adjusted for potentially stronger penalization
        
        # Calculate penalty: lower values for capacities closer to threshold, higher for much larger capacities.
        # The penalty is subtracted from the best_fit_score.
        excess_capacity_penalty = 1.0 / (1.0 + np.exp(penalty_steepness * (suitable_bins_cap / (item + 1e-9) - penalty_threshold_ratio)))
        
        combined_scores = best_fit_scores - excess_capacity_penalty
        
        priorities[suitable_bins_mask] = combined_scores
            
    return priorities
```
