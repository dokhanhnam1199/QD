```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for leaving excessive space,
    prioritizing tight fits while discouraging overly sparse bin utilization.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if np.any(suitable_bins_mask):
        suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
        
        # Best Fit component: minimize remaining capacity after packing
        remaining_after_fit = suitable_bins_cap - item
        
        # Score based on inverse of remaining space (higher is better)
        # Add epsilon to avoid division by zero for perfect fits
        epsilon = 1e-9
        best_fit_scores = 1.0 / (remaining_after_fit + epsilon)
        
        # Penalty component: Discourage bins that leave a large amount of space
        # This is a simplified approach inspired by (11th/12th/13th) and (10th) heuristics.
        # We penalize if the remaining space is significantly larger than the item size.
        # Let's use a threshold: if remaining_after_fit > factor * item, apply a reduction.
        penalty_factor = 0.5  # Reduce priority by 50% if condition met
        penalty_threshold_ratio = 1.5 # Apply penalty if remaining space > 1.5 * item size

        penalty_mask = remaining_after_fit > (penalty_threshold_ratio * item)
        
        # Combine scores: Apply penalty multiplicatively
        combined_scores = best_fit_scores.copy()
        combined_scores[penalty_mask] *= penalty_factor
        
        # Normalize scores to be between 0 and 1 for better weighting/interpretation
        # This normalization is inspired by (14th-20th) and (5th) heuristics.
        if np.max(combined_scores) > 0:
            normalized_scores = combined_scores / np.max(combined_scores)
        else:
            normalized_scores = np.zeros_like(combined_scores) # Should not happen if any suitable bin exists

        # Assign priorities: use normalized scores for bins that can fit the item
        original_indices = np.where(suitable_bins_mask)[0]
        priorities[original_indices] = normalized_scores
        
    return priorities
```
