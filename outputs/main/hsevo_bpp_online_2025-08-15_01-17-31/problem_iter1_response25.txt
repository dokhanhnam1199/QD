```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Inverse Distance strategy.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Prioritize bins that are "closer" to fitting the item,
    # meaning their remaining capacity is just enough or slightly larger than the item.
    # We use the inverse of (remaining_capacity - item_size + epsilon) to avoid division by zero
    # and to give higher priority to bins where the difference is smaller.
    # Adding a small constant to the denominator ensures that bins with exactly enough capacity
    # (difference = 0) get a very high priority, but still a finite one.
    # We also ensure that we only consider bins that can actually fit the item.
    epsilon = 1e-6
    suitable_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap)
    
    # Calculate priorities only for bins that can fit the item
    diff = bins_remain_cap[suitable_bins_mask] - item
    priorities[suitable_bins_mask] = 1.0 / (diff + epsilon)
    
    # Normalize priorities to be between 0 and 1 (optional but can be helpful for some algorithms)
    if np.any(priorities):
        min_p = np.min(priorities[suitable_bins_mask])
        max_p = np.max(priorities[suitable_bins_mask])
        if max_p - min_p > 0:
            priorities[suitable_bins_mask] = (priorities[suitable_bins_mask] - min_p) / (max_p - min_p)
        else:
            priorities[suitable_bins_mask] = 0.5 # All suitable bins have same priority

    return priorities
```
