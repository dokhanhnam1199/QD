```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
    
    # Metric 1: Fit Tightness (Best Fit - closer to 0 is better)
    fit_tightness = suitable_bins_cap - item
    
    # Metric 2: Bin Fullness (Inverse of remaining capacity - higher is better)
    # Add a small epsilon to avoid division by zero if a bin is exactly full and item fits.
    bin_fullness = 1.0 / (suitable_bins_cap - item + 1e-9) 

    # Metric 3: Remaining Capacity (Lower is better, but we want to prioritize bins that are *less* full for future items)
    # This is less directly about fitting the current item, more about future packing.
    # We'll give this a lower weight or consider its inverse.
    # For now, let's focus on the immediate packing.

    # Normalize metrics to be in a similar range and direction (higher priority is better)
    # For fit_tightness, smaller is better, so we invert it and potentially normalize.
    # Let's normalize by the range of the suitable bins' capacities to get a relative sense.
    
    # Handle cases where all suitable bins have the same capacity.
    if np.all(suitable_bins_cap == suitable_bins_cap[0]):
        normalized_fit_tightness = np.ones_like(fit_tightness) * 0.5 # Neutral if all are same
    else:
        min_cap_suitable = np.min(suitable_bins_cap)
        max_cap_suitable = np.max(suitable_bins_cap)
        range_cap_suitable = max_cap_suitable - min_cap_suitable
        if range_cap_suitable == 0:
            normalized_fit_tightness = np.ones_like(fit_tightness) * 0.5
        else:
            # Invert and scale: smaller gap -> higher score
            normalized_fit_tightness = 1.0 - (fit_tightness - np.min(fit_tightness)) / (np.max(fit_tightness) - np.min(fit_tightness) + 1e-9)
    
    # Normalize bin_fullness. Higher fullness is better.
    if np.all(bin_fullness == bin_fullness[0]):
        normalized_bin_fullness = np.ones_like(bin_fullness) * 0.5
    else:
        normalized_bin_fullness = (bin_fullness - np.min(bin_fullness)) / (np.max(bin_fullness) - np.min(bin_fullness) + 1e-9)

    # Combine metrics with weights. Weights can be tuned.
    # Weighting:
    # - Fit Tightness: High priority (e.g., 0.6) - want to fill bins efficiently
    # - Bin Fullness: Medium priority (e.g., 0.4) - contributes to filling bins
    
    w_fit = 0.6
    w_full = 0.4
    
    composite_priority = (w_fit * normalized_fit_tightness) + (w_full * normalized_bin_fullness)
    
    # Assign the composite priorities to the original indices
    original_indices = np.where(suitable_bins_mask)[0]
    priorities[original_indices] = composite_priority

    return priorities
```
