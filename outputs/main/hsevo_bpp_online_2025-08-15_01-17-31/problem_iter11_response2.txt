```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a normalized, sigmoid-based penalty for remaining capacity.
    Prioritizes tight fits while smoothly penalizing bins with excessive empty space.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9
    penalty_strength = 5.0 # Tune this parameter to control penalty intensity

    can_fit_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    if valid_bins_remain_cap.size > 0:
        remaining_after_fit = valid_bins_remain_cap - item
        
        # Best Fit score: inverse of the remaining space for tighter fits
        best_fit_scores = 1.0 / (remaining_after_fit + epsilon)
        
        # Sigmoid-based penalty: Penalizes large remaining capacities smoothly.
        # Scales the remaining capacity relative to the item size and bin capacity (implicitly)
        # The sigmoid function ensures the penalty grows but saturates.
        normalized_remaining = remaining_after_fit / np.maximum(bins_remain_cap[can_fit_mask], epsilon)
        penalty_scores = 1.0 / (1.0 + np.exp(penalty_strength * (1.0 - normalized_remaining))) # Penalizes larger remaining space
        
        # Combine Best Fit with penalty: subtract penalty from the score
        combined_priorities = best_fit_scores - penalty_scores
        
        # Normalize combined priorities to [0, 1] for consistent comparison
        min_p, max_p = np.min(combined_priorities), np.max(combined_priorities)
        if max_p > min_p:
            normalized_priorities = (combined_priorities - min_p) / (max_p - min_p)
        else:
            normalized_priorities = np.ones_like(combined_priorities) * 0.5 # All scores are same
            
        original_indices = np.where(can_fit_mask)[0]
        priorities[original_indices] = normalized_priorities

    return priorities
```
