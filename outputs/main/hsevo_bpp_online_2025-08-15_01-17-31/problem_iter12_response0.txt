```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if np.any(suitable_bins_mask):
        suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
        
        # Best Fit heuristic component
        best_fit_diff = suitable_bins_cap - item
        min_diff = np.min(best_fit_diff)
        best_fit_scores = np.exp(-best_fit_diff / np.mean(suitable_bins_cap)) 
        
        # First Fit Decreasing like component (prioritize fuller bins among suitable ones)
        # Normalize remaining capacities to give higher scores to bins with less remaining capacity
        normalized_remain_cap = (suitable_bins_cap - item) / np.max(suitable_bins_cap - item + 1e-9) # Avoid division by zero
        
        # Combine heuristics with a weighting mechanism that can be tuned
        # Here, we'll use a simple additive combination with a focus on Best Fit
        combined_scores = 0.7 * best_fit_scores + 0.3 * (1 - normalized_remain_cap)
        
        # Normalize combined scores to be between 0 and 1
        if np.max(combined_scores) > 0:
            normalized_combined_scores = combined_scores / np.max(combined_scores)
        else:
            normalized_combined_scores = np.zeros_like(combined_scores)
            
        original_indices = np.where(suitable_bins_mask)[0]
        
        for i, original_idx in enumerate(original_indices):
            priorities[original_idx] = normalized_combined_scores[i]
            
    return priorities
```
