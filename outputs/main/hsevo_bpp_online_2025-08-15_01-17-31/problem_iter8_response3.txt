```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a scaled penalty for remaining capacity,
    prioritizing tight fits and moderately penalizing under-filled bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities
    
    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # Best Fit component: inverse of the gap. Higher score for smaller gaps.
    epsilon = 1e-9
    best_fit_scores = 1.0 / (valid_bins_remain_cap - item + epsilon)
    
    # Penalty component: Penalize bins with large remaining capacity after packing.
    # This penalty is relative to the item size to adapt to different item magnitudes.
    # We use a simple linear penalty that increases with the remaining capacity
    # scaled by the item size. This is a refinement from simpler additive penalties.
    # Penalty = penalty_strength * (remaining_capacity / item_size)
    # We add 1 to the denominator to avoid division by zero if item is 0 and
    # to ensure a base penalty for any remaining capacity.
    penalty_strength = 0.2  # Tunable parameter for penalty aggression
    
    # Calculate the "excess" capacity relative to the item size.
    # We are penalizing if this excess is large.
    excess_capacity_ratio = (valid_bins_remain_cap - item) / (item + epsilon)
    
    # We want to reduce the priority if excess_capacity_ratio is high.
    # A simple penalty is to subtract this ratio, scaled by penalty_strength.
    # This is similar to priority_v0's linear penalty but scaled by item size.
    penalty = penalty_strength * excess_capacity_ratio
    
    # Combine the best fit score with the penalty.
    # The score is essentially `best_fit_score - penalty`.
    # A higher score means a better bin choice.
    combined_priorities = best_fit_scores - penalty
    
    # Assign priorities back to the original array structure
    original_indices = np.where(can_fit_mask)[0]
    priorities[original_indices] = combined_priorities

    return priorities
```
