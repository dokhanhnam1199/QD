```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if np.any(suitable_bins_mask):
        suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
        
        # Best Fit: Minimize remaining capacity after packing
        best_fit_diff = suitable_bins_cap - item
        min_diff_score = 1.0 / (1.0 + best_fit_diff) # Higher score for smaller diff
        
        # First Fit: Prioritize bins that have been used longer (lower index)
        first_fit_score = 1.0 / (1.0 + np.arange(len(suitable_bins_cap)))
        
        # Consider bin fullness: prioritize bins that are more full (less remaining capacity)
        # This is inverse of remaining capacity, normalized by bin capacity (assuming fixed bin capacity, e.g., 1.0)
        # If bin capacity varies, you would need that information. Assuming bin capacity is 1.0 for simplicity here.
        # A more robust approach would involve knowing the original bin capacity.
        # For now, we can use the reciprocal of remaining capacity if it's not too close to zero.
        fullness_score = np.zeros_like(suitable_bins_cap)
        non_zero_remain_cap_mask = suitable_bins_cap > 1e-9 # Avoid division by zero
        fullness_score[non_zero_remain_cap_mask] = 1.0 / suitable_bins_cap[non_zero_remain_cap_mask]
        
        # Combine objectives with adaptive weights. For demonstration, let's use fixed weights,
        # but in a real adaptive system, these would be learned or adjusted.
        # For now, let's slightly favor best-fit, then first-fit, then fullness.
        # These weights could be tuned.
        weight_best_fit = 0.5
        weight_first_fit = 0.3
        weight_fullness = 0.2
        
        combined_scores = (weight_best_fit * min_diff_score +
                           weight_first_fit * first_fit_score +
                           weight_fullness * fullness_score)
        
        # Normalize scores to be between 0 and 1
        if np.max(combined_scores) > 0:
            normalized_scores = combined_scores / np.max(combined_scores)
        else:
            normalized_scores = combined_scores
        
        # Assign priorities to the original indices
        original_indices = np.where(suitable_bins_mask)[0]
        priorities[original_indices] = normalized_scores
        
    return priorities
```
