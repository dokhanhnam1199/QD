```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with an adaptive sigmoid penalty for remaining capacity.
    Prioritizes tight fits and penalizes bins with excessive empty space smoothly.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9
    penalty_strength = 7.0  # Increased penalty strength for stronger bias towards tighter fits

    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]
    remaining_after_fit = valid_bins_remain_cap - item

    # Best Fit score: inverse of the remaining space for tighter fits
    best_fit_scores = 1.0 / (remaining_after_fit + epsilon)

    # Adaptive Sigmoid Penalty: Penalizes large remaining capacities smoothly.
    # Scales remaining capacity relative to the *item's* size to adapt penalty.
    normalized_remaining_ratio = remaining_after_fit / np.maximum(item, epsilon)
    penalty_scores = 1.0 / (1.0 + np.exp(penalty_strength * (1.0 - normalized_remaining_ratio)))

    # Combine scores: subtract penalty from best fit score
    combined_priorities = best_fit_scores - penalty_scores

    # Normalize combined priorities to [0, 1]
    min_p, max_p = np.min(combined_priorities), np.max(combined_priorities)
    if max_p > min_p:
        normalized_priorities = (combined_priorities - min_p) / (max_p - min_p)
    else:
        normalized_priorities = np.ones_like(combined_priorities) * 0.5 

    original_indices = np.where(can_fit_mask)[0]
    priorities[original_indices] = normalized_priorities

    return priorities
```
