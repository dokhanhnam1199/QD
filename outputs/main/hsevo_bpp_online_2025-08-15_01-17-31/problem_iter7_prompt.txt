{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a penalty for excessively large remaining capacities,\n    prioritizing bins that fit the item tightly and are not overly empty.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities\n    \n    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    # Best Fit component: inverse of the remaining gap after placing the item.\n    # Higher score for smaller gaps (tighter fits).\n    epsilon = 1e-9\n    best_fit_scores = 1.0 / (valid_bins_remain_cap - item + epsilon)\n    \n    # Penalty for \"too much\" remaining capacity.\n    # This penalizes bins that will be left significantly empty after the item is placed.\n    # We use a logarithmic penalty to be less aggressive than exponential.\n    # The penalty is higher for larger remaining capacities.\n    # We subtract 1 to make the penalty focus on capacity substantially larger than the item.\n    # If remaining capacity is close to item size, penalty is small.\n    # If remaining capacity is much larger, penalty is significant.\n    penalty_factor = 0.5 # Tunable parameter for penalty strength\n    # Avoid log(0) or log(negative) by ensuring argument is > 1\n    penalty_arg = (valid_bins_remain_cap / item) if item > 0 else np.inf\n    # We only want to penalize if remaining capacity is significantly larger than the item\n    # Let's define \"significantly larger\" as > 2 * item for instance.\n    # A simpler approach is to penalize based on the absolute remaining capacity if it's large.\n    # Or penalize based on the *proportion* of capacity left.\n    # Let's try penalizing remaining capacity relative to bin's original capacity (if known, but it's not).\n    # Instead, let's penalize based on (remaining_cap_after_fit - item).\n    # If remaining_cap_after_fit - item is large, we want a larger penalty.\n    # Using log((valid_bins_remain_cap - item) + epsilon) can work, but a simpler penalty might be better.\n    # Let's consider the \"slack\" as in priority_v0 but inverted, penalizing large slack.\n    # A linear penalty on slack: -(valid_bins_remain_cap - item)\n    # A better penalty based on \"over-emptiness\":\n    # Penalty is higher if (valid_bins_remain_cap - item) is large compared to 'item'.\n    # Let's adapt Heuristics 11-13 logic but make it simpler.\n    # Penalty is proportional to the remaining capacity AFTER the item is placed, if it's \"too much\".\n    # A threshold could be 'item', meaning if remaining capacity > item, penalize.\n    # Or if remaining capacity > some fraction of bin capacity (unknown).\n    # Let's try to penalize bins where `valid_bins_remain_cap - item` is large.\n    # We want to reduce priority for bins that will be left very empty.\n    # A simple penalty could be proportional to `valid_bins_remain_cap`.\n    # Or `valid_bins_remain_cap / item`.\n    # Let's use a penalty that decreases priority if remaining capacity is large.\n    # The inverse of remaining capacity was used in v0 for \"fullness\". Let's use that in reverse.\n    # Penalize if `valid_bins_remain_cap` is large.\n    # Penalty = f(valid_bins_remain_cap). We want f to be decreasing.\n    # Let's use a simple negative linear term on the remaining capacity itself.\n    # This is related to the 'slack_scores' in v0 but as a penalty.\n    # penalty = penalty_factor * valid_bins_remain_cap\n    \n    # Alternative penalty idea: penalize bins that are \"too empty\" in terms of how much\n    # larger their remaining capacity is compared to the item being packed.\n    # For example, if remaining_cap - item > item, then it's \"too empty\".\n    # Let's create a penalty term that is larger for larger remaining capacities.\n    # Using the inverse of remaining capacity from v0's slack_scores, but subtracting it.\n    # This prioritizes bins that will be fuller.\n    # `slack_scores` from v0: 1.0 / (valid_bins_remain_cap + epsilon)\n    # If we subtract this, we penalize fuller bins. This is not what we want.\n    # We want to penalize *emptier* bins.\n    # Let's try: penalty is proportional to the *amount of wasted space* in the bin *after* fitting.\n    # Wasted space = valid_bins_remain_cap - item\n    # Penalty = penalty_factor * (valid_bins_remain_cap - item)\n    # This would reduce priority for bins with larger remaining space.\n    \n    # Combine Best Fit with a penalty for bins that are likely to be left very empty.\n    # The penalty is stronger for bins with a larger remaining capacity after placing the item.\n    # We want to reduce the score if `valid_bins_remain_cap - item` is large.\n    # Let's use the score `(valid_bins_remain_cap - item)` directly as a penalty.\n    # This is effectively saying: `best_fit_score - penalty_factor * (remaining_capacity_after_fit)`\n    # Where `remaining_capacity_after_fit = valid_bins_remain_cap - item`.\n    \n    # Let's refine the penalty to be based on the \"emptiness ratio\" of the bin after packing.\n    # If a bin has capacity C and we place item I, remaining is C-I.\n    # If C-I is large, we penalize.\n    # Consider the capacity ratio of the *remaining space* to the *item size*.\n    # If `(valid_bins_remain_cap - item) / item` is large, we penalize.\n    # `penalty_term = penalty_factor * ((valid_bins_remain_cap - item) / item)`\n    # This handles cases where `item` is small, leading to large penalties if remaining is large.\n    # Let's clip this ratio to avoid extreme values, perhaps by limiting how much larger the remaining space can be.\n    # A simpler approach: penalize if `valid_bins_remain_cap` itself is large.\n    # Let's use the `slack_scores` from v0 but adjust the combination.\n    # `best_fit_scores` are good. We want to *decrease* priority if `valid_bins_remain_cap` is large.\n    # So, we can subtract a term that increases with `valid_bins_remain_cap`.\n    \n    # Let's combine Best Fit with a penalty for remaining capacity that's much larger than the item size.\n    # This aims to select bins that are \"almost full\" but can still accommodate the item.\n    # The \"gap\" is `valid_bins_remain_cap - item`. Best Fit prioritizes small gaps.\n    # The \"slack\" is `valid_bins_remain_cap`. We want to penalize large slack.\n    # Let's define a penalty that is larger for larger slack.\n    # A simple linear penalty: `penalty_amount = penalty_factor * valid_bins_remain_cap`\n    # This could be too aggressive.\n    \n    # Consider Heuristic 10's approach: `best_fit_score * (1 - penalty_weight * (remaining_capacity / bin_capacity))`\n    # Since bin_capacity is unknown, we can use `item` or a scaled `valid_bins_remain_cap`.\n    # Let's try: `best_fit_score * (1 - penalty_factor * (valid_bins_remain_cap / (item + epsilon)))`\n    # This would penalize bins where remaining capacity is large relative to item size.\n    # If `valid_bins_remain_cap < item`, the term `(valid_bins_remain_cap / (item + epsilon))` is < 1.\n    # `1 - penalty_factor * (...)` would be greater than `1 - penalty_factor`.\n    # This boosts bins that leave less space *relative to item size*.\n    # This is similar to boosting bins that are \"almost full\" when scaled by item size.\n    \n    # Let's combine the Best Fit score with a penalty that reduces priority for bins\n    # with a large amount of remaining capacity *after* the item is placed.\n    # We can use a term that is proportional to the remaining capacity itself.\n    # Penalty = `penalty_factor * (valid_bins_remain_cap - item)`\n    # This makes the priority: `best_fit_score - penalty_factor * (valid_bins_remain_cap - item)`\n    # This is equivalent to prioritizing bins with `1 / (gap) - penalty_factor * (gap)`.\n    \n    # Let's adopt a penalty based on the \"emptiness\" of the bin *after* placement.\n    # We want to penalize bins where `valid_bins_remain_cap` is large.\n    # A simple way is to subtract a fraction of `valid_bins_remain_cap`.\n    # The \"gap\" is `valid_bins_remain_cap - item`.\n    # Let's combine the inverse gap (best fit) with the inverse of remaining capacity (fullness).\n    # v0 used (best_fit + slack)/2.\n    # v1 uses normalized best_fit - penalty.\n    # Let's try a weighted sum of best_fit_scores and a penalty for slack.\n    # Penalty for slack: `penalty_factor * (valid_bins_remain_cap / (item + epsilon))`\n    # This penalizes bins where remaining capacity is large relative to item size.\n    # If `valid_bins_remain_cap = item`, penalty is `penalty_factor`.\n    # If `valid_bins_remain_cap = 2 * item`, penalty is `2 * penalty_factor`.\n    \n    # Final approach: combine the 'best fit' score (inverse gap) with a penalty\n    # that reduces priority for bins that will have a lot of remaining capacity.\n    # The penalty is linear with the remaining capacity `valid_bins_remain_cap`.\n    # This is a balance between tight packing and not leaving bins excessively empty.\n    \n    # Score = BestFit_Score - Penalty_for_Slack\n    # BestFit_Score = 1.0 / (valid_bins_remain_cap - item + epsilon)\n    # Penalty_for_Slack = penalty_factor * valid_bins_remain_cap\n    \n    # Let's try to boost bins that have a small remaining capacity after fitting,\n    # but also consider the \"tightness\" of the fit.\n    # Heuristic 14-20 approach: normalized_best_fit + penalty for empty bins.\n    # Let's simplify it: Best Fit score, but penalize if remaining capacity is very large.\n    \n    # Combining Best Fit (inverse gap) with a penalty for large remaining capacity.\n    # This aims to select bins that are a tight fit and do not leave excessive empty space.\n    # Penalty is applied if `valid_bins_remain_cap` is significantly larger than `item`.\n    \n    # Let's use the `best_fit_scores` and subtract a penalty proportional to the\n    # `valid_bins_remain_cap` to favor fuller bins.\n    penalty_strength = 0.2 # Tunable parameter for penalty\n    \n    # Calculate combined priorities: Best fit score minus a penalty for remaining capacity.\n    # This prioritizes bins that fit the item snugly (high best_fit_scores)\n    # and de-prioritizes bins that will have a lot of remaining space.\n    combined_priorities = best_fit_scores - penalty_strength * (valid_bins_remain_cap - item)\n    \n    # Assign the calculated priorities to the original indices\n    original_indices = np.where(can_fit_mask)[0]\n    priorities[original_indices] = combined_priorities\n\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}