```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements a priority function for the online Bin Packing Problem using a
    sigmoid-based strategy, favoring bins that are nearly full after placing the item,
    while penalizing bins that would become too full.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A NumPy array where each element is the remaining capacity of a bin.

    Returns:
        A NumPy array of the same size as bins_remain_cap, containing the
        priority score for packing the item into each respective bin. Higher scores
        indicate a more desirable bin.
    """
    large_capacity_threshold = 0.8  # Threshold for "nearly full"
    small_capacity_threshold = 0.2  # Threshold for "too empty"
    steepness = 10.0                # Controls the steepness of the sigmoid

    # Calculate the remaining capacity after placing the item
    potential_remain_cap = bins_remain_cap - item

    # Initialize priorities to a very low value
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify valid bins (those that can actually hold the item)
    valid_bins_mask = potential_remain_cap >= 0

    # For valid bins, calculate the normalized remaining capacity to apply sigmoid
    # Avoid division by zero if a bin has exactly zero remaining capacity (edge case)
    valid_potential_remain_cap = potential_remain_cap[valid_bins_mask]
    valid_bins_current_cap = bins_remain_cap[valid_bins_mask]

    # Use sigmoid to prioritize bins that result in a near-full state, but not overfull.
    # We want to push items to bins that are almost full, minimizing wasted space.
    # The sigmoid maps values around 0 (representing a good fit after item placement)
    # to values near 0.5. Values far from 0 (too much or too little space remaining)
    # will be pushed towards 0 or 1.
    # A bin where potential_remain_cap is close to 0 (i.e., the item almost fills it)
    # should have a high priority.

    # Calculate a "fill score" which is high when the remaining capacity is small
    fill_score = np.ones_like(valid_bins_current_cap) - (valid_potential_remain_cap / valid_bins_current_cap)
    # Handle cases where current capacity is zero or item is zero
    fill_score[valid_bins_current_cap == 0] = 0
    fill_score[valid_bins_current_cap == item] = 1 # Perfect fit

    # Apply sigmoid to push values towards 0 or 1 based on how close to "full" it gets
    # We want to reward bins that become *nearly full*, so we center the sigmoid
    # around a "good fit" state (where remaining capacity is small).
    # A bin becoming completely full is good, but slightly less than completely full is also good.
    # If remaining capacity is exactly 0, the score should be high.

    # Let's define a target remaining capacity. A small positive value is ideal.
    # Or, more directly, a low "waste" score. Waste score = remaining_capacity / bin_capacity
    # High priority for low waste.
    # Let's aim for a state where remaining capacity is very small, but not negative.
    # The sigmoid function helps here: we want to reward states where `potential_remain_cap` is small.
    # Let's map `potential_remain_cap` to a value that is high when it's near 0.

    # A simple sigmoid where input `x` maps to `1 / (1 + exp(-k * (x - x0)))`
    # We want high priority when `potential_remain_cap` is small.
    # So, let's transform `potential_remain_cap` into a metric that's high when small.
    # For example, `max_capacity - potential_remain_cap` gives a measure of fullness.
    # Or even better, use `potential_remain_cap` directly but invert the sigmoid's effect.

    # Consider `f(x) = 1 / (1 + exp(-k * (x - threshold)))`
    # If threshold is small, x near threshold gives 0.5.
    # If we want small `potential_remain_cap` to be high priority,
    # we can use `-potential_remain_cap` as input to sigmoid.
    # Let threshold be a small positive value, say 0.1 * bin_capacity

    # Calculate a normalized "ideal fill" state for each valid bin.
    # We want to maximize the case where remaining capacity is just above 0.
    normalized_remain_cap = valid_potential_remain_cap / bins_remain_cap[valid_bins_mask]

    # Sigmoid centered around a state of 'almost full' (e.g., normalized_remain_cap close to 0)
    # The input to sigmoid is `steepness * (normalized_remain_cap - target_norm_remain_cap)`
    # If `target_norm_remain_cap` is small (e.g., 0.05), then bins with small normalized remaining capacity
    # will have input close to 0, yielding scores near 0.5.
    # We want higher priority for lower `normalized_remain_cap`.
    # Let's use `priorities = 1 - sigmoid(normalized_remain_cap)`
    # Or more directly, `priorities = sigmoid(-normalized_remain_cap)`
    # This will give higher scores for smaller `normalized_remain_cap`.

    target_norm_remain_cap = 0.05 # Aim for ~5% remaining capacity

    # Calculate the sigmoid score: higher score for smaller remaining capacity
    sigmoid_input = steepness * (normalized_remain_cap - target_norm_remain_cap)
    scores = 1 / (1 + np.exp(-sigmoid_input))

    # Invert scores: we want to prioritize bins that result in SMALLER remaining capacity.
    # So, a state where `normalized_remain_cap` is low should get a HIGH priority.
    # Our sigmoid `scores` are high when `sigmoid_input` is high, meaning
    # `normalized_remain_cap` is high. We need the opposite.
    # So, let's use `1 - scores` or `sigmoid(-sigmoid_input)`.

    final_scores = 1 / (1 + np.exp(-steepness * (target_norm_remain_cap - normalized_remain_cap)))

    priorities[valid_bins_mask] = final_scores

    # Ensure that bins that cannot fit the item have a very low priority.
    # This is already handled by initializing to -inf and only updating valid bins.

    # Return priorities, ensuring no NaNs or Infs in the final output if any edge cases slipped through.
    # Using a very small number for impossible fits would be safer than -inf for some algorithms.
    priorities[~valid_bins_mask] = 0 # Assign zero priority to invalid bins
    return priorities
```
