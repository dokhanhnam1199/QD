```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a calibrated logarithmic penalty for excessive remaining capacity,
    favoring bins that offer a tight fit while moderately penalizing large unused space.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    gaps = suitable_bins_caps - item

    # Best Fit Score: Higher for smaller gaps (tighter fit). Add epsilon for stability.
    best_fit_score = 1.0 / (gaps + 1e-6)

    # Calibrated Logarithmic Penalty: Penalizes large gaps more significantly but smoothly.
    # The penalty increases logarithmically with the gap size.
    # Using np.log1p(gaps) is numerically stable for small gaps and avoids log(0).
    # A scaling factor (0.1) controls the penalty's impact.
    penalty_factor = 0.1
    excess_capacity_penalty = penalty_factor * np.log1p(gaps)

    # Combine scores: Subtract the penalty from the best-fit score.
    # Higher combined score indicates a preferred bin.
    combined_priorities = best_fit_score - excess_capacity_penalty

    # Normalize priorities to be between 0 and 1 for consistent behavior
    min_priority = np.min(combined_priorities)
    max_priority = np.max(combined_priorities)
    if max_priority > min_priority:
        normalized_priorities = (combined_priorities - min_priority) / (max_priority - min_priority)
    else:
        normalized_priorities = np.ones_like(combined_priorities) * 0.5 # Default if all scores are same

    priorities[suitable_bins_mask] = normalized_priorities

    return priorities
```
