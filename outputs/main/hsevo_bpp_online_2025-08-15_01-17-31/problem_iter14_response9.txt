```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a smooth, adaptive penalty for large remaining capacities,
    enhanced by normalization for stable multi-bin selection.

    This heuristic balances fitting an item tightly (Best Fit) with a penalty
    for bins that have excessive remaining capacity, aiming for better overall
    bin utilization. Normalization ensures scores are comparable across different
    bin states.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    can_fit_mask = bins_remain_cap >= item
    
    suitable_bins_caps = bins_remain_cap[can_fit_mask]
    
    if suitable_bins_caps.size > 0:
        gaps = suitable_bins_caps - item
        
        # Best Fit component: prioritize smaller gaps. Inverse for higher score.
        best_fit_scores = 1.0 / (gaps + 1e-9)
        
        # Adaptive penalty for large remaining capacity using a sigmoid-like function.
        # Penalizes bins with capacity significantly larger than the item.
        penalty_threshold_ratio = 2.0  # Threshold for when penalty starts becoming significant
        penalty_steepness = 0.7      # Controls how quickly penalty increases
        
        # Calculate penalty: high when capacity >> item * ratio, approaches 0 otherwise.
        # The `+ 1e-9` in the denominator prevents division by zero for item sizes close to zero.
        large_capacity_penalty = 1.0 / (1.0 + np.exp(-penalty_steepness * (suitable_bins_caps / (item + 1e-9) - penalty_threshold_ratio)))
        
        # Combine scores: Subtract penalty from Best Fit score.
        combined_scores = best_fit_scores - large_capacity_penalty
        
        # Normalize scores to [0, 1] for stable comparison across different item sizes.
        if combined_scores.size > 0:
            min_score = np.min(combined_scores)
            max_score = np.max(combined_scores)
            if max_score - min_score > 1e-9: # Avoid division by zero if all scores are the same
                normalized_scores = (combined_scores - min_score) / (max_score - min_score)
            else:
                normalized_scores = np.ones_like(combined_scores) * 0.5 # Neutral score if all are identical
        else:
            normalized_scores = np.array([])

        priorities[can_fit_mask] = normalized_scores
        
    return priorities
```
