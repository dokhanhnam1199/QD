```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for leaving excessive remaining capacity.
    Prioritizes bins with minimal remaining space after packing, but penalizes
    bins that would leave too much space, promoting balanced utilization.
    This heuristic aims to provide a more balanced approach than pure Best Fit.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Mask for bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    # Consider only bins that can fit the item
    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    if valid_bins_remain_cap.size > 0:
        # Calculate the remaining capacity after placing the item
        remaining_after_fit = valid_bins_remain_cap - item
        
        # Best Fit component: prioritize bins with minimal remaining space.
        # Use inverse of remaining space for higher scores for tighter fits.
        # Add a small epsilon to avoid division by zero.
        epsilon = 1e-9
        best_fit_scores = 1.0 / (remaining_after_fit + epsilon)
        
        # Penalty component: penalize bins that leave a large amount of remaining space.
        # This discourages selecting very large bins for small items if other options exist.
        # We use a threshold based on the item size. If remaining_after_fit is larger than
        # a multiple of the item size, apply a penalty.
        penalty_threshold_factor = 1.0  # Penalize if remaining space > item size
        penalty_factor = 0.5            # Reduce priority by 50%
        
        penalty_mask = remaining_after_fit > (penalty_threshold_factor * item)
        
        # Apply the penalty to the best_fit_scores
        combined_priorities = best_fit_scores.copy()
        combined_priorities[penalty_mask] *= penalty_factor
        
        # Normalize the combined scores to be between 0 and 1
        # This ensures scores are comparable across different sets of bins.
        max_priority = np.max(combined_priorities)
        if max_priority > 0:
            final_priorities = combined_priorities / max_priority
        else:
            final_priorities = np.zeros_like(combined_priorities)
            
        # Assign the calculated priorities back to the original indices
        original_indices = np.where(can_fit_mask)[0]
        priorities[original_indices] = final_priorities

    return priorities
```
