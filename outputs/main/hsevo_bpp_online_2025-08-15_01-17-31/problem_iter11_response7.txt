```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a calibrated logarithmic penalty for excessive remaining capacity,
    favoring bins that offer a tight fit while moderately penalizing large unused space.
    Also incorporates a slight bias towards bins with less remaining capacity overall.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_caps = bins_remain_cap[suitable_bins_mask]
    gaps = suitable_bins_caps - item

    # Best Fit Score: Higher for smaller gaps (tighter fit). Add epsilon for stability.
    best_fit_score = 1.0 / (gaps + 1e-6)

    # Calibrated Logarithmic Penalty: Penalizes large gaps more significantly but smoothly.
    # The penalty increases logarithmically with the gap size.
    penalty_factor = 0.1
    excess_capacity_penalty = penalty_factor * np.log1p(gaps)

    # Additional heuristic: Favor bins with less remaining capacity overall (less waste)
    # This is a simple additive term that slightly boosts bins with less overall capacity.
    # Normalizing this to be on a similar scale as the best_fit_score.
    # We subtract it to prefer smaller remaining capacities.
    # Avoid division by zero by adding a small epsilon.
    overall_capacity_bias = 1.0 / (suitable_bins_caps + 1e-6)
    normalized_capacity_bias = (overall_capacity_bias - np.min(overall_capacity_bias)) / (np.max(overall_capacity_bias) - np.min(overall_capacity_bias) + 1e-9)


    # Combine scores: Subtract the penalty from the best-fit score, and also subtract the bias for larger capacities.
    combined_priorities = best_fit_score - excess_capacity_penalty - normalized_capacity_bias * 0.2 # Adjust weight for bias

    # Normalize priorities to be between 0 and 1 for consistent behavior
    min_priority = np.min(combined_priorities)
    max_priority = np.max(combined_priorities)
    if max_priority > min_priority:
        normalized_priorities = (combined_priorities - min_priority) / (max_priority - min_priority)
    else:
        normalized_priorities = np.ones_like(combined_priorities) * 0.5 # Default if all scores are same

    priorities[suitable_bins_mask] = normalized_priorities

    return priorities
```
