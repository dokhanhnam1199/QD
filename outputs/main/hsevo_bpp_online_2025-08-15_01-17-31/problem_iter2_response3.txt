```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins using a hybrid approach: Best Fit for immediate fit,
    and a penalty for remaining capacity to encourage fuller bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    # If no bins can fit, return all zeros
    if not np.any(can_fit_mask):
        return priorities
    
    # Get remaining capacities for bins that can fit the item
    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # Calculate 'Best Fit' score: inverse of remaining gap
    # This prioritizes bins with minimal wasted space (smallest gap)
    epsilon = 1e-9
    best_fit_scores = 1.0 / (valid_bins_remain_cap - item + epsilon)
    
    # Calculate a 'slack' score: inverse of remaining capacity after fit
    # This aims to penalize bins that will have a lot of remaining space,
    # encouraging fuller bins overall.
    slack_scores = 1.0 / (valid_bins_remain_cap + epsilon)
    
    # Combine scores. A simple average can work, or a weighted sum.
    # Here, we'll use a simple average as a starting point.
    # This combines the immediate "tightest fit" with a tendency towards fuller bins.
    combined_scores = (best_fit_scores + slack_scores) / 2.0
    
    # Assign the combined scores to the priorities array for valid bins
    priorities[can_fit_mask] = combined_scores
    
    return priorities
```
