```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if np.any(suitable_bins_mask):
        suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
        
        # Primary objective: minimize remaining capacity (Best Fit like)
        best_fit_diff = suitable_bins_cap - item
        
        # Secondary objective: prioritize bins with more remaining capacity if diff is the same (to keep fuller bins for later)
        # This adds a bit of "Worst Fit" behavior for tie-breaking to potentially leave smaller gaps
        # We invert the capacity to maximize it, so smaller inverted capacity means larger original capacity
        inverted_suitable_bins_cap = -suitable_bins_cap 
        
        # Combine objectives: Penalize larger gaps more, reward larger remaining capacity for same gap
        # We want to minimize best_fit_diff and maximize suitable_bins_cap.
        # A simple way is to use a weighted sum, but to make it adaptive, we can make weights depend on the distribution.
        # For now, let's create a score that prioritizes smaller gaps first, then larger remaining capacity.
        # Score = -(remaining_capacity - item) + alpha * remaining_capacity
        # To make it simple, let's aim to minimize (remaining_capacity - item) and maximize remaining_capacity.
        # We can score by: a large negative number for larger (remaining_capacity - item) and a smaller positive number for remaining_capacity.
        # To combine: we want small (best_fit_diff) and large (suitable_bins_cap)
        # A score that prioritizes minimum diff and then maximum capacity for tie-breaking:
        # Score = -(best_fit_diff) + (suitable_bins_cap / max_possible_capacity)
        # Let's use a simple combination that balances these two:
        
        # Normalize the remaining capacities for consistent scoring
        max_cap = np.max(bins_remain_cap)
        if max_cap > 0:
            normalized_suitable_bins_cap = suitable_bins_cap / max_cap
        else:
            normalized_suitable_bins_cap = np.zeros_like(suitable_bins_cap)

        # Score = -best_fit_diff + normalized_suitable_bins_cap
        # This rewards bins that have small remaining capacity after packing (low diff)
        # and among those, rewards bins that had more initial capacity (high normalized_suitable_bins_cap)
        scores = -best_fit_diff + normalized_suitable_bins_cap
        
        # Set priority to 1 for the bin(s) with the highest score
        max_score = np.max(scores)
        best_fit_indices_in_suitable = np.where(scores == max_score)[0]
        
        original_indices = np.where(suitable_bins_mask)[0]
        
        for idx in best_fit_indices_in_suitable:
            priorities[original_indices[idx]] = 1.0
            
    return priorities
```
