{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a penalty for bins that are too large,\n    prioritizing tighter fits while avoiding extremely large remaining capacities.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    can_fit_mask = bins_remain_cap >= item\n    \n    bins_that_can_fit_caps = bins_remain_cap[can_fit_mask]\n    \n    if bins_that_can_fit_caps.size > 0:\n        gaps = bins_that_can_fit_caps - item\n        \n        # Best Fit component: prioritize bins with the smallest gap.\n        # We use 1/(gap + epsilon) which gives higher scores to smaller gaps.\n        best_fit_scores = 1.0 / (gaps + 1e-9)\n        \n        # Additional component: Penalize bins that leave very large remaining capacity.\n        # This can be done by considering the capacity relative to the item size or bin capacity.\n        # Let's penalize bins where `bins_remain_cap` is significantly larger than `item`.\n        # A simple penalty could be based on the reciprocal of the remaining capacity after fitting.\n        # Or, inversely related to the capacity AFTER fitting. Smaller post-fit capacity is better.\n        # Let's use a function that increases with smaller `bins_that_can_fit_caps - item`.\n        # The `best_fit_scores` already do this.\n\n        # Let's try to combine a \"Best Fit\" aspect with a \"First Fit Decreasing\" like preference\n        # for using up existing bins first.\n        # The 1/(gap + epsilon) is a strong \"Best Fit\".\n        \n        # A potential improvement: If multiple bins offer a very tight fit (small gap),\n        # we might prefer the one that has been used more or has less absolute capacity\n        # to keep larger bins available for larger items.\n        \n        # Let's modify the score slightly to favor bins that are \"more full\" among the best fits.\n        # This can be achieved by adding a term that increases with `bins_remain_cap`.\n        # However, this might conflict with \"Best Fit\" if a slightly larger bin is a slightly worse fit.\n        \n        # Let's stick to a refined Best Fit. The core idea is to minimize the leftover space.\n        # The previous `best_fit_scores` are good.\n        # To make it more \"adaptive\" or \"robust\", we can consider a secondary criterion if multiple\n        # bins have very similar small gaps.\n        \n        # Example:\n        # Bins capacities: [10, 10, 10, 10]\n        # Item: 3\n        # Bins remain cap: [2, 5, 8, 9]\n        # Item fits in all. Gaps: [2-3, 5-3, 8-3, 9-3] = [-1, 2, 5, 6] - This is wrong, it's `bins_remain_cap - item`.\n        # Bins remain cap: [2, 5, 8, 9]\n        # Item: 3\n        # Bins remaining capacity: [2, 5, 8, 9]\n        # Gaps: [2-3, 5-3, 8-3, 9-3] -> these are only for bins that fit.\n        # Assume bins_remain_cap = [2, 5, 8, 9], item = 3.\n        # can_fit_mask = [False, True, True, True]\n        # bins_that_can_fit_caps = [5, 8, 9]\n        # gaps = [5-3, 8-3, 9-3] = [2, 5, 6]\n        # best_fit_scores = [1/(2+eps), 1/(5+eps), 1/(6+eps)] = [~0.5, ~0.2, ~0.16]\n        # This prioritizes the bin with remaining capacity 5.\n\n        # Consider the case where `item` itself is very large.\n        # If `item` is close to bin capacity, the gap will be small.\n        # The current `1.0 / (gaps + epsilon)` prioritizes these.\n        \n        # Let's try a slight modification to the priority to encourage using bins\n        # that are \"closer\" to fitting the item without being too small.\n        # This is essentially what Best Fit does.\n        \n        # We can also incorporate a slight bias towards bins that are *not* completely empty,\n        # to encourage filling up partially used bins before starting new ones.\n        # This is more of a \"First Fit\" idea, but can be combined.\n        \n        # Let's try prioritizing bins by their remaining capacity AFTER fitting the item.\n        # We want to MINIMIZE this remaining capacity.\n        # Priority = - (bins_remain_cap - item)\n        # This directly makes smaller positive gaps have higher priority.\n        # Example: gaps = [2, 5, 6] -> priorities = [-2, -5, -6]. Max is -2.\n        # This means the bin with the smallest gap is prioritized.\n\n        # Let's combine the \"tight fit\" with a \"less empty\" preference.\n        # A simple way is to add a term that is inversely related to the remaining capacity.\n        # Priority = (1.0 / (gaps + epsilon)) + log(bins_that_can_fit_caps)\n        # This might be too complex.\n        \n        # A simpler combination: Best Fit score with a small bonus for bins that have\n        # less *total* capacity (to use up partially filled bins first).\n        # So, the priority for fitting bins will be:\n        # score = (1.0 / (gaps + epsilon)) + (1.0 / (bins_that_can_fit_caps + epsilon))\n        # This adds a preference for smaller capacity bins among those with similar gaps.\n        \n        # Let's normalize `bins_that_can_fit_caps` to avoid large values dominating.\n        # Or, let's focus on the `gaps` and add a term that penalizes very large `bins_that_can_fit_caps`\n        # when the gap is also not very small.\n        \n        # Revisit the core goal: pick the bin `j` that minimizes `bins_remain_cap[j] - item`.\n        # The `best_fit_scores = 1.0 / (gaps + 1e-9)` achieves this by giving higher scores\n        # to smaller positive gaps.\n        \n        # Let's try to slightly \"flatten\" the advantage of extremely small gaps,\n        # and give a slight boost to bins that are \"mediumly\" sized and fit well.\n        # This can be done by squaring the gap or using a different function.\n        \n        # Let's use a combination of \"Best Fit\" and \"Worst Fit\" (to keep options open).\n        # No, the goal is best fit.\n        \n        # Consider a heuristic that looks at `bins_remain_cap - item` and `bins_remain_cap`.\n        # We want to minimize `bins_remain_cap - item`.\n        # We also implicitly want to use bins that are not excessively large if the fit is similar.\n        \n        # Let's propose a heuristic that prioritizes bins that have a small gap,\n        # AND among those with small gaps, prefers bins that have less total capacity.\n        # The score for a bin that fits:\n        # priority_score = (1.0 / (bins_that_can_fit_caps - item + 1e-9))  # Best Fit part\n        # Let's add a term that rewards using bins with smaller remaining capacity.\n        # This could be `-(bins_that_can_fit_caps)`.\n        # So, priority = (1.0 / (gaps + 1e-9)) - bins_that_can_fit_caps\n        # This would favor smaller gaps, and among equal gaps, it favors smaller `bins_that_can_fit_caps`.\n        \n        priorities[can_fit_mask] = (1.0 / (gaps + 1e-9)) - bins_that_can_fit_caps\n        \n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}