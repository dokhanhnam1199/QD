```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for overly large remaining capacity.
    Prioritizes bins with minimal remaining space after packing, but penalizes
    bins that would leave excessive space, promoting balanced utilization.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)
    can_fit_mask = bins_remain_cap >= item
    
    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    if valid_bins_remain_cap.size > 0:
        # Calculate the remaining capacity after placing the item
        remaining_after_fit = valid_bins_remain_cap - item
        
        # Best Fit component: prioritize smaller remaining space
        # Use inverse of remaining space for higher scores for tighter fits.
        epsilon = 1e-9
        best_fit_scores = 1.0 / (remaining_after_fit + epsilon)
        
        # Introduce a penalty for leaving too much space (less than "good enough" fit)
        # This component aims to avoid "overly empty" bins, promoting better overall distribution.
        # We can use a sigmoid-like penalty: larger remaining_after_fit leads to a smaller score.
        # Let's define a threshold for "too much" space, e.g., 30% of item size, or a fixed value.
        # A simple approach is to scale the best_fit_scores down if remaining_after_fit is large.
        
        # Let's use a penalty that reduces the priority if remaining_after_fit is large.
        # A linear penalty might be simple: score = best_fit_score * (1 - alpha * remaining_after_fit)
        # Or, a capping mechanism: if remaining_after_fit > threshold, reduce score significantly.
        
        # Consider a strategy where we want bins that leave very little space,
        # but also don't want bins that are *almost* empty after packing.
        # The previous '1 / (remaining_after_fit + epsilon)' strongly favors very small gaps.
        
        # Let's refine the 'Best Fit' idea by adding a secondary objective:
        # prefer bins that become 'moderately' full rather than 'almost completely' full
        # IF there's a choice between a perfect fit and a slightly less perfect fit that still leaves
        # a reasonable amount of space. This is tricky in online BPP.
        
        # A common strategy is to favor bins that are "nearly full" without being *too* full.
        # The 'Best Fit' strategy by itself already does this by minimizing residual space.
        
        # Let's enhance the 'Best Fit' by considering the *original* bin capacity.
        # Prioritize bins where (remaining_after_fit / original_bin_capacity) is minimized.
        # This is essentially Best Fit Normalized.
        
        # Let's try a hybrid:
        # 1. Base priority: 1.0 / (remaining_after_fit + epsilon) (Best Fit)
        # 2. Add a penalty if remaining_after_fit is *too large* relative to the item size.
        #    This prevents selecting a large bin for a small item just because it's the smallest available.
        
        # Let's define a "good fit" target, which is a small positive remaining capacity.
        # We want to reward bins where remaining_after_fit is close to zero.
        # Let's cap the penalty.
        
        # Example:
        # Item = 0.4, Bins: [0.5, 0.6, 1.0]
        # Remaining after fit: [0.1, 0.2, 0.6]
        # Best fit scores: [10, 5, 1.67]
        
        # If we want to penalize leaving a lot of space (e.g., 0.6), we could do:
        # If remaining_after_fit > K * item:
        #   priority *= penalty_factor (e.g., 0.5)
        
        penalty_threshold_factor = 0.5 # Penalize if remaining space is more than 50% of item size
        penalty_factor = 0.7 # Reduce priority by 30%
        
        penalty_mask = remaining_after_fit > (penalty_threshold_factor * item)
        
        # Apply the base best fit scores
        combined_priorities = best_fit_scores.copy()
        
        # Apply penalty to bins that leave too much space
        combined_priorities[penalty_mask] *= penalty_factor
        
        priorities[can_fit_mask] = combined_priorities
    
    return priorities
```
