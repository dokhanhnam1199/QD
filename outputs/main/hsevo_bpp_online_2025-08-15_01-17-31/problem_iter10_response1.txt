import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.00042286684893775927, penalty_factor: float = 0.5686040001790706) -> np.ndarray:
    """
    Combines Best Fit with a dynamic penalty based on the ratio of remaining capacity to item size.
    Prioritizes tight fits while penalizing bins that leave disproportionately large empty space.
    
    Args:
        item: The size of the item to be placed.
        bins_remain_cap: A numpy array representing the remaining capacity of each bin.
        epsilon: A small float to avoid division by zero or log of non-positive values.
        penalty_factor: Controls the strength of the penalty.
    
    Returns:
        A numpy array of priorities for each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Mask for bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    # Consider only bins that can fit the item
    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    if valid_bins_remain_cap.size > 0:
        # Calculate the remaining capacity after placing the item
        remaining_after_fit = valid_bins_remain_cap - item
        
        # Best Fit component: inverse of remaining space for tighter fits.
        best_fit_scores = 1.0 / (remaining_after_fit + epsilon)
        
        # Dynamic Penalty component: Penalize based on the ratio of remaining space to the item size.
        # A higher ratio (more wasted space relative to the item) gets a higher penalty (lower priority).
        # Using log to dampen the effect of very large remaining spaces.
        # The penalty factor is tuned to be significant but not overwhelming.
        
        # Avoid division by zero or log of non-positive values for penalty calculation
        penalty_terms = np.maximum(remaining_after_fit, epsilon) / np.maximum(item, epsilon)
        penalty = penalty_factor * np.log1p(penalty_terms) # Use log1p for better numerical stability near 0

        # Combine Best Fit score with penalty (subtract penalty from score)
        # This effectively reduces the priority of bins with large relative remaining capacity.
        combined_priorities = best_fit_scores - penalty
        
        # Normalize the combined scores to be between 0 and 1
        # This makes scores comparable across different item/bin configurations.
        min_priority = np.min(combined_priorities)
        max_priority = np.max(combined_priorities)
        
        if max_priority > min_priority:
            normalized_priorities = (combined_priorities - min_priority) / (max_priority - min_priority)
        else:
            # If all valid bins have the same combined score, assign a uniform priority
            normalized_priorities = np.ones_like(combined_priorities) * 0.5
            
        # Assign the calculated priorities back to the original indices
        original_indices = np.where(can_fit_mask)[0]
        priorities[original_indices] = normalized_priorities

    return priorities
