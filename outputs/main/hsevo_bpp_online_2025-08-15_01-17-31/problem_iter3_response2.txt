```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if np.any(suitable_bins_mask):
        suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
        
        best_fit_diff = suitable_bins_cap - item
        
        # Adaptive prioritization: Higher priority for bins that are almost full,
        # but can still fit the item. This aims to "fill up" bins more efficiently.
        # We can achieve this by giving a higher score to smaller remaining capacities
        # after placing the item.
        
        # Calculate a "fit score" which is inversely related to the remaining capacity after placement.
        # Add a small epsilon to avoid division by zero if an item perfectly fills a bin.
        fit_scores = 1.0 / (best_fit_diff + 1e-9)
        
        # Normalize scores to prevent extreme values from dominating
        if np.max(fit_scores) > 0:
            normalized_fit_scores = fit_scores / np.max(fit_scores)
        else:
            normalized_fit_scores = np.zeros_like(fit_scores)

        # Introduce a small penalty for bins that are very empty.
        # This encourages packing into partially filled bins before opening new ones.
        # The penalty is higher for bins with much more remaining capacity than the item size.
        capacity_ratio = suitable_bins_cap / item if item > 0 else np.inf
        empty_bin_penalty = np.exp(-0.5 * (capacity_ratio - 1)) * 0.2 # Exponential decay penalty
        
        # Combine fit score and penalty. Higher values are better.
        combined_priorities = normalized_fit_scores - empty_bin_penalty
        
        # Assign the calculated priorities to the original indices
        original_indices = np.where(suitable_bins_mask)[0]
        priorities[original_indices] = combined_priorities

    return priorities
```
