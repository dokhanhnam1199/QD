```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for bins that are too large,
    prioritizing tighter fits while avoiding extremely large remaining capacities.
    This heuristic balances minimizing leftover space with not opening excessively large bins.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)
    can_fit_mask = bins_remain_cap >= item
    
    bins_that_can_fit_caps = bins_remain_cap[can_fit_mask]
    
    if bins_that_can_fit_caps.size > 0:
        gaps = bins_that_can_fit_caps - item
        
        # Best Fit component: prioritize bins with the smallest gap.
        # Using 1/(gap + epsilon) gives higher scores to smaller gaps.
        best_fit_scores = 1.0 / (gaps + 1e-9)
        
        # Additional component: Penalize bins that leave very large remaining capacity.
        # This is achieved by subtracting a value that increases with the remaining capacity.
        # A simple linear penalty is used here: -(bins_that_can_fit_caps).
        # This favors using bins that are less empty among those that provide a good fit.
        combined_scores = best_fit_scores - bins_that_can_fit_caps
        
        priorities[can_fit_mask] = combined_scores
        
    return priorities
```
