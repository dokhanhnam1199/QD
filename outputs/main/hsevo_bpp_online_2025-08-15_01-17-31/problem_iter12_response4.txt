```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if np.any(suitable_bins_mask):
        suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
        
        # Best Fit Component: Prioritize bins that leave the least remaining space
        best_fit_diff = suitable_bins_cap - item
        min_diff = np.min(best_fit_diff)
        best_fit_scores = np.exp(-best_fit_diff / (np.mean(bins_remain_cap) + 1e-6)) # Exponential decay, scaled by average remaining capacity
        
        # First Fit Component (implicitly handled by order but can be boosted): Prioritize bins that are used earlier
        # For online, earlier bins are those with lower indices. We can use inverse index for priority.
        original_indices = np.where(suitable_bins_mask)[0]
        first_fit_scores = 1.0 / (original_indices + 1.0) 
        
        # Combine components with adaptive weighting
        # Weighting can be adaptive based on the distribution of remaining capacities.
        # If capacities are very spread out, Best Fit might be more important.
        # If capacities are similar, First Fit might help with fragmentation.
        
        capacity_std = np.std(bins_remain_cap)
        capacity_mean = np.mean(bins_remain_cap)
        
        # Heuristic weighting: more weight to first fit if std is low (bins are similar)
        # more weight to best fit if std is high (bins are diverse)
        ff_weight = np.exp(-capacity_std / (capacity_mean + 1e-6)) 
        bf_weight = 1.0 - ff_weight
        
        combined_scores = bf_weight * best_fit_scores + ff_weight * first_fit_scores
        
        # Normalize scores to be between 0 and 1
        if np.max(combined_scores) > 0:
            normalized_scores = combined_scores / np.max(combined_scores)
        else:
            normalized_scores = combined_scores # Should not happen if suitable bins exist

        # Assign priorities to the original indices
        priorities[original_indices] = normalized_scores
        
    return priorities
```
