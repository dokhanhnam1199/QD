```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a First Fit Decreasing inspired strategy.

    The priority is higher for bins that have just enough capacity to fit the item
    or bins that have a larger remaining capacity but are still good candidates.
    A small penalty is applied if fitting the item would leave a very small remaining capacity,
    encouraging a tighter fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_cap = bins_remain_cap[suitable_bins_cap]

    # Calculate potential remaining capacities
    potential_remain_cap = suitable_bins_cap - item

    # Priority 1: Bins where the item fits exactly (or very closely) are highly prioritized.
    # Using a small tolerance for "exact" fit.
    exact_fit_tolerance = 1e-6
    exact_fit_priorities = np.where(np.abs(potential_remain_cap) < exact_fit_tolerance, 100.0, 0.0)

    # Priority 2: Bins with a reasonable amount of remaining capacity after fitting.
    # We want to avoid leaving tiny gaps if possible, so we give slightly less priority
    # to bins that leave a very small remaining capacity (but still larger than tolerance).
    # Bins that leave a moderate amount of space get a moderate priority.
    # Bins that leave a lot of space get a lower but still positive priority.

    # Normalize remaining capacities for prioritization (higher is better here)
    # Avoid division by zero if potential_remain_cap is all zero
    max_remain_cap = np.max(potential_remain_cap)
    if max_remain_cap > 0:
        normalized_remain_cap = potential_remain_cap / max_remain_cap
    else:
        normalized_remain_cap = np.zeros_like(potential_remain_cap)

    # Create a general priority based on how much space is left.
    # If remaining space is small (but > tolerance), give a moderate priority.
    # If remaining space is larger, give a lower priority.
    # We want to favor bins that are "just enough", but not excessively so.
    # This heuristic aims to be "less wasteful" by preferring closer fits,
    # but still considers larger bins as alternatives.

    # Apply a slight penalty for very small remaining capacities (e.g., < 0.1 of the max remaining capacity)
    # to discourage leaving small unusable gaps.
    small_gap_threshold = 0.1
    penalty = np.where(potential_remain_cap < max_remain_cap * small_gap_threshold, 0.5, 1.0)

    general_priorities = normalized_remain_cap * penalty

    # Combine priorities: Exact fits get highest priority, followed by general suitability.
    combined_priorities = exact_fit_priorities + general_priorities

    # Ensure that the priority is non-negative
    priorities[suitable_bins_mask] = np.maximum(0, combined_priorities)

    return priorities
```
