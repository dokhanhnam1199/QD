```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for excessive remaining capacity.
    Prioritizes bins that fit the item tightly while penalizing those that
    would leave a very large amount of empty space, encouraging fuller bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    # If no bins can fit, return all zeros
    if not np.any(can_fit_mask):
        return priorities
    
    # Get remaining capacities for bins that can fit the item
    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # Calculate 'Best Fit' score: inverse of the gap (remaining capacity - item)
    # This prioritizes bins with minimal wasted space immediately after placement.
    epsilon = 1e-9
    gaps = valid_bins_remain_cap - item
    best_fit_scores = 1.0 / (gaps + epsilon)
    
    # Calculate a penalty for bins that would have a large remaining capacity after fitting the item.
    # This encourages using bins that become more "full" rather than those that remain very "empty".
    # We use a logarithmic penalty to dampen extreme values and create a smoother penalty.
    # A smaller remaining capacity after fitting is better.
    slack_after_fit = valid_bins_remain_cap - item
    # Penalize slack that is significantly larger than the item size itself.
    # This encourages using bins where the remaining space is somewhat proportional to the item.
    # We use log to reduce the impact of very large slacks. Add 1 to avoid log(0) or log(small_positive).
    slack_penalty = np.log(slack_after_fit + 1 + epsilon) 
    
    # Combine scores: Higher best_fit_scores are good. Higher slack_penalty is bad (subtract it).
    # We normalize the best_fit_scores to prevent them from dominating the penalty.
    if np.max(best_fit_scores) > 0:
        normalized_best_fit = best_fit_scores / np.max(best_fit_scores)
    else:
        normalized_best_fit = np.zeros_like(best_fit_scores)

    # Combine normalized best fit with the slack penalty.
    # Higher priority means a tighter fit and less remaining space after fitting.
    combined_scores = normalized_best_fit - slack_penalty
    
    # Assign the combined scores to the priorities array for valid bins
    priorities[can_fit_mask] = combined_scores
    
    return priorities
```
