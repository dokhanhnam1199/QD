```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins by combining a normalized 'best fit' score with a penalty
    for bins with excessively large remaining capacities, encouraging fuller bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if np.any(suitable_bins_mask):
        suitable_bins_cap = bins_remain_cap[suitable_bins_mask]
        
        # Calculate the difference for best fit
        best_fit_diff = suitable_bins_cap - item
        
        # Normalized 'best fit' score: Higher for smaller gaps
        # Add epsilon to avoid division by zero
        fit_scores = 1.0 / (best_fit_diff + 1e-9)
        
        if np.max(fit_scores) > 0:
            normalized_fit_scores = fit_scores / np.max(fit_scores)
        else:
            normalized_fit_scores = np.zeros_like(fit_scores)
        
        # Penalty for bins with significantly more capacity than needed (similar to Heuristic 11-13 idea)
        # This discourages using very large bins for small items if other partially filled bins exist
        # We use a threshold based on item size to avoid penalizing all bins that aren't a perfect fit
        # A small constant is added to capacity to prevent division by zero and handle cases where item is 0.
        # The penalty increases exponentially as remaining capacity grows beyond a certain point relative to the item.
        # Penalty is capped to avoid extreme negative values.
        capacity_penalty_factor = 0.5 # Tunable parameter for penalty strength
        capacity_threshold_ratio = 3.0 # Tunable parameter: penalize bins with capacity > ratio * item
        
        # Calculate penalty: higher for larger remaining capacity relative to item size
        # Only apply penalty if remaining capacity is significantly larger than the item
        large_capacity_mask = suitable_bins_cap > capacity_threshold_ratio * item
        
        # Calculate a penalty score for bins that are too large
        # The penalty is based on the excess capacity relative to the item size, scaled exponentially.
        # Add 1 to the denominator to ensure the penalty is applied correctly and doesn't become 0 for minimal excess.
        penalty_values = np.zeros_like(suitable_bins_cap)
        if np.any(large_capacity_mask):
            excess_capacity = suitable_bins_cap[large_capacity_mask] - item
            # Exponential penalty: higher penalty for more excess capacity
            penalty_values[large_capacity_mask] = np.exp(capacity_penalty_factor * (excess_capacity / (item + 1e-9))) - 1.0
            
        # Combine normalized fit scores with the penalty. Lower penalty values are better.
        # We subtract the penalty to give higher priority to bins with low penalty.
        combined_priorities = normalized_fit_scores - penalty_values
        
        # Assign the calculated priorities to the original indices
        priorities[suitable_bins_mask] = combined_priorities
    
    return priorities
```
