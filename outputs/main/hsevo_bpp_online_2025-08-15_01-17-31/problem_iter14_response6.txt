```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines adaptive sigmoid penalty with a modified Best Fit to balance tightness and space utilization.
    Prioritizes bins that offer a good fit and penalizes bins with excessive remaining capacity.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    # Mask for bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    # Consider only bins that can fit the item
    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    if valid_bins_remain_cap.size > 0:
        # Calculate the remaining capacity after placing the item (tightness metric)
        remaining_after_fit = valid_bins_remain_cap - item
        
        # Modified Best Fit: Smaller remaining capacity is better, use inverse for higher score.
        # Add epsilon for numerical stability and to avoid division by zero.
        best_fit_scores = 1.0 / (remaining_after_fit + 1e-9)
        
        # Adaptive Penalty component: Penalize bins with significantly more space than needed.
        # Use a sigmoid function on the ratio of bin capacity to item size.
        # Threshold controls when penalty becomes significant; steepness controls the transition speed.
        penalty_threshold_ratio = 1.5  # Ratio where penalty starts to increase
        penalty_steepness = 0.8  # Controls the steepness of the penalty
        
        # Calculate the capacity-to-item ratio, ensuring item is not zero for division.
        capacity_ratio = valid_bins_remain_cap / (item + 1e-9)
        
        # Sigmoid function for penalty: penalizes bins with capacity_ratio > penalty_threshold_ratio
        # Penalty is 0 when ratio is small, approaches 1 when ratio is large.
        penalty = 1.0 / (1.0 + np.exp(-penalty_steepness * (capacity_ratio - penalty_threshold_ratio)))
        
        # Combine Best Fit score with penalty: subtract penalty to lower priority for over-spacious bins.
        combined_scores = best_fit_scores - penalty
        
        # Normalize the combined scores to be between 0 and 1 for consistent priority values.
        min_score = np.min(combined_scores)
        max_score = np.max(combined_scores)
        
        if max_score > min_score:
            normalized_scores = (combined_scores - min_score) / (max_score - min_score)
        else:
            # If all valid bins have the same score, assign a neutral priority.
            normalized_scores = np.full_like(combined_scores, 0.5)
            
        # Assign the calculated priorities back to the original indices.
        original_indices = np.where(can_fit_mask)[0]
        priorities[original_indices] = normalized_scores

    return priorities
```
