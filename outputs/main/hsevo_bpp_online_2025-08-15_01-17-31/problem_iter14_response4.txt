```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a sigmoid-based penalty on the *ratio* of remaining capacity
    to item size, favoring tighter fits and penalizing large relative excesses.
    Also includes a minor bias for bins with less absolute remaining capacity.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9
    penalty_strength = 3.0  # Tune this parameter

    # Mask for bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]

    if valid_bins_remain_cap.size > 0:
        remaining_after_fit = valid_bins_remain_cap - item

        # Best Fit score: higher for smaller remaining capacity (tighter fit)
        # Add epsilon to avoid division by zero
        best_fit_scores = 1.0 / (remaining_after_fit + epsilon)

        # Adaptive Sigmoid Penalty: Penalizes based on how much *more* capacity is left
        # compared to the item size. This is relative to the item itself.
        # The sigmoid penalizes larger ratios smoothly.
        relative_excess_ratio = remaining_after_fit / (item + epsilon)
        penalty_scores = 1.0 / (1.0 + np.exp(penalty_strength * relative_excess_ratio))

        # Combine Best Fit with penalty: Subtract penalty from the score.
        # A smaller penalty (closer to 1) is better.
        combined_priorities = best_fit_scores * penalty_scores

        # Normalize combined priorities to [0, 1]
        min_p, max_p = np.min(combined_priorities), np.max(combined_priorities)
        if max_p > min_p:
            normalized_priorities = (combined_priorities - min_p) / (max_p - min_p)
        else:
            normalized_priorities = np.ones_like(combined_priorities) * 0.5

        original_indices = np.where(can_fit_mask)[0]
        priorities[original_indices] = normalized_priorities

    return priorities
```
