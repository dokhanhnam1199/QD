{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n                fit_reward: float = 1.8606401153475742,\n                overflow_penalty: float = 0.23311623299493256,\n                fullness_bonus: float = 0.24692029962156997,\n                close_fit_boost: float = 0.755929203444544,\n                close_fit_threshold: float = 0.31756747877776315,\n                empty_bin_penalty: float = 0.18111007569931253,\n                large_item_threshold: float = 0.6365035670064028,\n                reduced_empty_bin_penalty_factor: float = 0.09119484752969076,\n                diversity_bonus_factor: float = 0.004873566384835245,\n                near_empty_threshold: float = 0.8819279417449031) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins considering waste, overflow, fullness, and adaptive strategies.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    waste = bins_remain_cap - item\n    max_cap = np.max(bins_remain_cap) if len(bins_remain_cap) > 0 else 1.0\n    avg_cap = np.mean(bins_remain_cap) if len(bins_remain_cap) > 0 else 1.0\n    \n    # Reward bins where the item fits\n    fit_mask = waste >= 0\n    priorities[fit_mask] += fit_reward / (waste[fit_mask] + 0.000001)\n\n    # Penalize overflow, relative to the maximum bin capacity\n    overflow_mask = ~fit_mask\n    overflow = item - bins_remain_cap[overflow_mask]\n    priorities[overflow_mask] -= overflow_penalty * overflow / (max_cap + 0.000001)\n\n    # Bonus for bins that are already relatively full\n    fullness = 1 - bins_remain_cap / (max_cap+0.000001)\n    priorities += fullness_bonus * fullness\n\n    # Further boost bins with small waste, using a ratio-based approach\n    close_fit_mask = fit_mask & (waste <= (close_fit_threshold * max_cap))\n    if np.any(close_fit_mask):\n        ratios = item / bins_remain_cap[close_fit_mask]\n        priorities[close_fit_mask] += close_fit_boost * np.log(ratios)\n\n    # Adaptive Empty Bin Handling: Penalize near-empty bins less if item is large\n    empty_bin_threshold = 0.1 * max_cap\n    near_empty_mask = bins_remain_cap > (near_empty_threshold * max_cap) # or > (max_cap - empty_bin_threshold)\n    if item > large_item_threshold * max_cap:  # If item is relatively large\n          priorities[near_empty_mask] -= reduced_empty_bin_penalty_factor * empty_bin_penalty #Reduced penalty\n    else:\n          priorities[near_empty_mask] -= empty_bin_penalty  #Standard penalty\n          \n    #Bin Diversity Consideration\n    cap_diff = np.abs(bins_remain_cap - avg_cap)\n    diversity_bonus = diversity_bonus_factor * (max_cap - cap_diff) # Bias toward bins that have capacities closer to the average\n    priorities += diversity_bonus\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic uses a combination of factors like fit reward, overflow penalty, fullness bonus, close fit boost, empty bin penalty, diversity bonus and item size penalty and adaptively adjusts the weights of these factors based on the item size, while the worst heuristic simply calculates the log of the ratio of item size to bin capacity. Comparing (2nd best) vs (second worst), we see more sophisticated hyperparameters, adaptively adjusted based on item size relative to bin capacities. Comparing (1st) vs (2nd), we see the second heuristic adds consideration of `min_cap` and `fragmentation_penalty` along with adaptive adjustments based on ratios `item_ratio_max`, `item_ratio_avg`, and `item_ratio_min`, while the top heuristic focuses on raw item size relative to `max_cap`. (3rd) vs (4th) are functionally identical. Comparing (second worst) vs (worst), we see the second worst attempts to create a priority based on a negative log ratios. Overall: The better heuristics involve more nuanced combinations of factors and adaptive weighting schemes. They consider the interplay between item size and bin capacities and have multiple tunable hyperparameters. Simpler heuristics rely on only one or two factors. Also, using constants as hyperparameters and tuning them carefully can lead to better performance than hardcoding the values.\n- \nOkay, I'll help you redefine \"Current self-reflection\" to design better heuristics, avoiding ineffective approaches. Here's a revised approach:\n\n*   **Keywords:** Problem understanding, incremental complexity, factor interactions, adaptive weighting, hyperparameter optimization, performance evaluation, robustness, generalizability.\n*   **Advice:** Ground heuristics in a thorough problem understanding. Systematically introduce complexity, analyze factor interactions, and use adaptive weighting. Rigorously test performance and optimize hyperparameters.\n*   **Avoid:** Over-reliance on simple ratios or single factors. Neglecting factor interactions. Insufficiently addressing edge cases. Prematurely optimizing without solid understanding.\n*   **Explanation:** Effective heuristics require a deep understanding of the problem, are built incrementally, are tested in a variety of scenarios, and are fine-tuned with hyperparameters. Avoid simplistic approaches and focus on adaptive strategies.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}