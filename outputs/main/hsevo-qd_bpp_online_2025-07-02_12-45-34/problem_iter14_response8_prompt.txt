{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # Give high priority to bins where item fits and waste is minimized\n    fit_mask = waste >= 0\n    \n    # Prioritize bins with smaller waste, but also consider the fill ratio\n    # Encourage filling bins as much as possible\n    fill_ratio = (bins_remain_cap[fit_mask] - waste[fit_mask]) / bins_remain_cap[fit_mask]\n    priorities[fit_mask] = (1 / (waste[fit_mask] + 0.000001)) * (1 + fill_ratio) # Combine waste and fill ratio\n\n    # Adjust priority based on the item size relative to the bin capacity\n    # If the item is relatively large, prioritize bins that are closer to being full.\n    large_item_threshold = 0.5 * np.max(bins_remain_cap)  # Define a threshold for \"large\" items\n    if item > large_item_threshold:\n        priorities[fit_mask] *= (bins_remain_cap[fit_mask] / np.max(bins_remain_cap)) #Prioritize almost full bins\n\n    # Give negative priority to bins where item doesn't fit, proportional to overflow\n    overflow_mask = ~fit_mask\n    overflow = item - bins_remain_cap[overflow_mask]\n    priorities[overflow_mask] = -overflow / (np.max(bins_remain_cap) + 0.000001)  # Prioritize bins with smaller overflow\n\n    # Add a small bonus to bins with capacity close to the item size\n    # This encourages perfect fits\n    close_fit_mask = (bins_remain_cap >= (item - 0.1 * item)) & (bins_remain_cap <= (item + 0.1 * item)) & fit_mask\n    priorities[close_fit_mask] += 0.5\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic incorporates several factors like waste, overflow, fullness, adaptive empty bin handling, item size relative to bin size penalty, bin diversity consideration, and capacity standard deviation penalty, while the worst only considers the log of the ratio between item size and bin capacity. (2nd) is identical to (1st). Comparing (1st) vs (4th), we see that the best heuristic includes a penalty related to capacity standard deviation and item size relative to bin size, which are not present in (4th). (9th) introduces tunable parameters and explicitly addresses fit and overflow scenarios, including bonuses for best fit and near-full bins. (10th) simplifies the parameterization, using fixed values. Comparing (10th) and (12th), we see (10th) incorporates bonuses for best fit, near-full bins, and minimizing overflow (when no fit is possible), whereas (12th) simply gives priority to bins where the item fits and penalizes overflow. Comparing (12th) and (15th), we see (15th) is an enhancement on (12th) as it incentivizes filling bins that are already relatively full. Comparing (15th) and (20th), (15th) takes waste, overflow, and fill level into account, while (20th) just calculates `log_ratios`. Comparing (1st) and (9th), (1st) introduces several new parameters. (9th) introduces `fit_priority_increase`, `best_fit_bonus`, `near_full_threshold`, `near_full_bonus`, and `least_overflow_bonus`. Comparing (11th) and (12th), (11th) introduces `fit_priority_scale`, `waste_epsilon`, `overflow_priority_scale`, and `max_cap_epsilon`. Overall: the better heuristics are much more complex, taking into account more factors and edge cases, whereas the worse heuristics are simpler, and only account for the most obvious of factors. Better heuristics also use hyperparameters, as compared to worse heuristics.\n- \nOkay, let's redefine self-reflection for heuristic design, focusing on actionable insights and avoiding common pitfalls. Here's a breakdown to guide your process:\n\n*   **Keywords:** Adaptive tuning, factor weighting, multi-faceted, scenario-specific, incremental refinement.\n*   **Advice:** Build heuristics that adapt to specific problem scenarios by weighting relevant factors and tuning these weights adaptively. Refine heuristically incrementally, testing the impact of each addition.\n*   **Avoid:** Over-reliance on simple metrics (e.g., ratios), neglecting problem-specific characteristics, and static/inflexible designs.\n*   **Explanation:** Effective heuristics are context-aware. Don't just minimize waste, understand *why* waste occurs and tailor your approach accordingly with adaptive weights and tuning.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}