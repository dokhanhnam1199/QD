{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\nCurrent heuristics:\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Prioritizes bins considering waste, overflow, fullness, item size relative to bin sizes, and adaptive strategies.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    waste = bins_remain_cap - item\n    max_cap = np.max(bins_remain_cap) if len(bins_remain_cap) > 0 else 1.0\n    avg_cap = np.mean(bins_remain_cap) if len(bins_remain_cap) > 0 else 1.0\n    min_cap = np.min(bins_remain_cap) if len(bins_remain_cap) > 0 else 1.0\n    \n    # Hyperparameters (Tuned using some manual exploration and intuition)\n    fit_reward = 1.2  # Slightly increased reward for fitting\n    overflow_penalty = 0.6 # Slightly increased penalty for overflow\n    fullness_bonus = 0.25 # Slightly increased bonus for fullness\n    close_fit_boost = 0.8  # Increased boost for close fits\n    close_fit_threshold = 0.2\n    empty_bin_penalty = 0.3\n    item_size_penalty_factor = 0.5 # Penalty scaling for item size vs bin size.\n    capacity_std = np.std(bins_remain_cap) if len(bins_remain_cap) > 1 else 0.0  # standard deviation of capacities\n    std_dev_penalty = 0.05 #Penalty associated with high standard deviation\n    \n    # Reward bins where the item fits\n    fit_mask = waste >= 0\n    priorities[fit_mask] += fit_reward / (waste[fit_mask] + 0.000001)\n\n    # Penalize overflow, relative to the maximum bin capacity\n    overflow_mask = ~fit_mask\n    overflow = item - bins_remain_cap[overflow_mask]\n    priorities[overflow_mask] -= overflow_penalty * overflow / (max_cap + 0.000001)\n\n    # Bonus for bins that are already relatively full\n    fullness = 1 - bins_remain_cap / (max_cap+0.000001)\n    priorities += fullness_bonus * fullness\n\n    # Further boost bins with small waste, using a ratio-based approach\n    close_fit_mask = fit_mask & (waste <= (close_fit_threshold * max_cap))\n    if np.any(close_fit_mask):\n        ratios = item / bins_remain_cap[close_fit_mask]\n        priorities[close_fit_mask] += close_fit_boost * np.log(ratios)\n\n    # Adaptive Empty Bin Handling: Penalize near-empty bins less if item is large\n    empty_bin_threshold = 0.1 * max_cap\n    near_empty_mask = bins_remain_cap > (0.9 * max_cap)\n    if item > 0.5 * max_cap:  # If item is relatively large\n          priorities[near_empty_mask] -= 0.05 * empty_bin_penalty  # Reduced penalty\n    else:\n          priorities[near_empty_mask] -= empty_bin_penalty  # Standard penalty\n\n    # Item Size Relative to Bin Size Penalty:\n    # Penalize bins that are only slightly larger than the item. This encourages using larger bins\n    # for larger items and smaller bins for smaller items\n    slightly_larger_mask = fit_mask & (waste < (0.5 * item))\n    priorities[slightly_larger_mask] -= item_size_penalty_factor * (item / (max_cap + 0.000001))\n\n    #Bin Diversity Consideration\n    cap_diff = np.abs(bins_remain_cap - avg_cap)\n    diversity_bonus = 0.01 * (max_cap - cap_diff) # Bias toward bins that have capacities closer to the average\n    priorities += diversity_bonus\n    \n    # Capacity standard deviation penalty.\n    priorities -= std_dev_penalty * capacity_std / (max_cap + 0.000001)\n\n    return priorities\n\nNow, think outside the box write a mutated function `priority_v2` better than current version.\nYou can use some hints below:\n- \nOkay, let's redefine self-reflection for heuristic design, focusing on actionable insights and avoiding common pitfalls. Here's a breakdown to guide your process:\n\n*   **Keywords:** Adaptive tuning, factor weighting, multi-faceted, scenario-specific, incremental refinement.\n*   **Advice:** Build heuristics that adapt to specific problem scenarios by weighting relevant factors and tuning these weights adaptively. Refine heuristically incrementally, testing the impact of each addition.\n*   **Avoid:** Over-reliance on simple metrics (e.g., ratios), neglecting problem-specific characteristics, and static/inflexible designs.\n*   **Explanation:** Effective heuristics are context-aware. Don't just minimize waste, understand *why* waste occurs and tailor your approach accordingly with adaptive weights and tuning.\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}