{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Enhanced priority function considering multiple factors for better bin packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        fit_priority_increase: Increase in priority for bins where the item fits.\n        best_fit_bonus: Bonus for bins that are the best fit (minimal waste).\n        near_full_threshold: Threshold for considering a bin \"near full\" (as a fraction of item size).\n        near_full_bonus: Bonus for filling bins that are near full.\n        least_overflow_bonus: Bonus for minimizing overflow when no fit is possible.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_count = len(bins_remain_cap)\n\n    # Calculate waste if item is placed in each bin\n    waste = bins_remain_cap - item\n\n    # Fit Heuristic: Prioritize bins where the item fits.\n    fit_mask = waste >= 0\n    if np.any(fit_mask):  # Only apply if at least one bin can fit the item\n        priorities[fit_mask] = (1 / (waste[fit_mask] + 0.000001)) + fit_priority_increase  # Increate priority compared to overflow. Avoid zero division.\n\n        # Best Fit Improvement:  Slightly boost the priority of bins with minimal waste.\n        min_waste = np.min(waste[fit_mask])\n        best_fit_mask = (waste == min_waste) & fit_mask\n        priorities[best_fit_mask] += best_fit_bonus  # A small bonus for the best fit\n\n        # Reward near-full bins:\n        near_full_mask = (bins_remain_cap <= (item + near_full_threshold)) & fit_mask\n        priorities[near_full_mask] += near_full_bonus #Big bonus for filling near-full bins.\n    # Overflow Heuristic: Only used when NO bin fits.\n    else:\n        overflow_mask = ~fit_mask\n        priorities[overflow_mask] = - (item - bins_remain_cap[overflow_mask]) / (np.max(bins_remain_cap) + 0.000001)\n        # Try to balance load (least overflow)\n        min_overflow = np.min(item - bins_remain_cap[overflow_mask])\n        least_overflow_mask = (item - bins_remain_cap == min_overflow) & overflow_mask\n        priorities[least_overflow_mask] += least_overflow_bonus #Bonus for minimizing overflow when no fit\n\n    # Bin balancing. Incentivize bins with higher remaining capacity (avoid using bins too unevenly if possible)\n    priorities += bins_remain_cap / (np.sum(bins_remain_cap) + 0.000001) #Added term for load balancing across bins\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic incorporates several factors like waste, overflow, fullness, adaptive empty bin handling, item size relative to bin size penalty, bin diversity consideration, and capacity standard deviation penalty, while the worst only considers the log of the ratio between item size and bin capacity. (2nd) is identical to (1st). Comparing (1st) vs (4th), we see that the best heuristic includes a penalty related to capacity standard deviation and item size relative to bin size, which are not present in (4th). (9th) introduces tunable parameters and explicitly addresses fit and overflow scenarios, including bonuses for best fit and near-full bins. (10th) simplifies the parameterization, using fixed values. Comparing (10th) and (12th), we see (10th) incorporates bonuses for best fit, near-full bins, and minimizing overflow (when no fit is possible), whereas (12th) simply gives priority to bins where the item fits and penalizes overflow. Comparing (12th) and (15th), we see (15th) is an enhancement on (12th) as it incentivizes filling bins that are already relatively full. Comparing (15th) and (20th), (15th) takes waste, overflow, and fill level into account, while (20th) just calculates `log_ratios`. Comparing (1st) and (9th), (1st) introduces several new parameters. (9th) introduces `fit_priority_increase`, `best_fit_bonus`, `near_full_threshold`, `near_full_bonus`, and `least_overflow_bonus`. Comparing (11th) and (12th), (11th) introduces `fit_priority_scale`, `waste_epsilon`, `overflow_priority_scale`, and `max_cap_epsilon`. Overall: the better heuristics are much more complex, taking into account more factors and edge cases, whereas the worse heuristics are simpler, and only account for the most obvious of factors. Better heuristics also use hyperparameters, as compared to worse heuristics.\n- \nOkay, let's redefine self-reflection for heuristic design, focusing on actionable insights and avoiding common pitfalls. Here's a breakdown to guide your process:\n\n*   **Keywords:** Adaptive tuning, factor weighting, multi-faceted, scenario-specific, incremental refinement.\n*   **Advice:** Build heuristics that adapt to specific problem scenarios by weighting relevant factors and tuning these weights adaptively. Refine heuristically incrementally, testing the impact of each addition.\n*   **Avoid:** Over-reliance on simple metrics (e.g., ratios), neglecting problem-specific characteristics, and static/inflexible designs.\n*   **Explanation:** Effective heuristics are context-aware. Don't just minimize waste, understand *why* waste occurs and tailor your approach accordingly with adaptive weights and tuning.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}