{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best of v2 & v6: filters valid bins, then uses inverse remaining capacity. Prioritizes bins with smallest waste while avoiding division by zero.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines fit, exponentially decayed waste, and bin age for prioritization.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n\n    fit_scores = bins_remain_cap[possible_bins] - item\n    waste = np.sum(bins_remain_cap) - np.sum(bins_remain_cap[possible_bins])\n    waste_decay = -np.log(waste + 1) if waste > 0 else 0\n    age_bonus = np.arange(n_bins)[possible_bins] * 0.01\n\n    preferences = (fit_scores * 0.8) + (waste_decay * 0.1) + age_bonus\n    priorities[possible_bins] = preferences\n    return priorities\n\n### Analyze & experience\n- Comparing heuristics 1st vs 2nd, the key difference lies in weighting the `fit_scores` by capacity in the 2nd heuristic and adding a further boost to the best bin. This introduces a bias towards larger bins, which may or may not be desirable depending on the application. The exponential waste decay is similar, but the addition of the boost feels ad-hoc and potentially destabilizing. Heuristic 1st is cleaner and more generally applicable.\n\nComparing 3rd vs 4th, 3rd is a simplified version of 1st, omitting the capacity weighting. Heuristic 4th uses `waste` directly in the exponent, rather than decaying the whole priority, making it sensitive to the absolute waste value. This is likely less stable than the decay approach.  3rd is better as it's closer to the leading heuristic.\n\nComparing 5th vs 6th, 5th uses `1.0 / (1.0 + waste)` which provides a simple inverse relationship with waste, while 6th incorporates an age penalty which adds complexity and potentially introduces unwanted behavior. 5th appears more robust and directly addresses waste minimization.\n\nComparing 7th vs 8th, both are complex, weighted schemes. 8th is more structured with defined weights, but it still depends on an age factor that might not be consistently helpful. 7th includes `bin_ages` as an optional argument which adds flexibility, but can cause inconsistency if not used properly. 8th's fixed weights may perform better.\n\nComparing 9th vs 10th, 9th combines exponential decay with a fit score, while 10th uses a waste factor in addition to a fit score. 9th benefits from a more stable exponential decay approach. 10th's waste factor dependent on the mean can introduce unwanted scaling issues.\n\nComparing 11th vs 12th, 11th boosts the best-fit bin while 12th uses inverse waste only. Boosting the best-fit can be effective, but may be too aggressive, and is less generalizable than inverse waste.\n\nComparing 13th vs 14th, 13th is incredibly basic. 14th includes weights and combines fit, waste, and age. 14th is far more sophisticated.\n\nComparing 15th vs 16th, 15th normalizes waste. 16th is a very complex implementation with various parameters. Normalization is preferable.\n\nComparing 17th vs 18th, both incorporate boosting best fit. 17th appears more streamlined.\n\nComparing 19th vs 20th, 19th focuses on the inverse remaining capacity. 20th incorporates age and waste. 19th is simpler and more focused.\n\nOverall: The best heuristics (1st, 3rd, 5th) prioritize simplicity and directly address fit and waste. Later heuristics introduce unnecessary complexity (weights, age factors) or unstable calculations that likely hinder performance and generalizability. Exponential decay applied to waste is generally more effective than directly using waste values. Boosting the best-fit should be done cautiously.\n- \nOkay, let's distill this into actionable advice for designing better bin-packing heuristics \u2013 aiming for that $999K! Here's a breakdown based on synthesizing the \"Current\" & \"Ineffective\" reflections:\n\n* **Keywords:** Fit, Waste (decayed), Stability, Simplicity, Robustness.\n* **Advice:** Prioritize *decayed* waste as a key differentiator alongside immediate fit. Start with a simple fit-first approach, *then* introduce waste penalties using exponential decay. Iteratively add complexity *only* if profiling shows clear benefit.\n* **Avoid:** Complex, global normalizations or weighted combinations *initially*. Over-tuning parameters before establishing a robust baseline. Sigmoid functions and unnecessarily complex calculations.\n* **Explanation:** The core tension is balancing exploration (waste management) with exploitation (immediate fit). Exponential decay on waste provides controlled exploration, preventing premature convergence on suboptimal solutions. Simplicity aids debugging & understanding.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}