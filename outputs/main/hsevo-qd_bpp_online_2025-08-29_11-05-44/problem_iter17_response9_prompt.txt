{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines waste decay (like v0) with a direct fit component (like v6).\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n\n    waste = bins_remain_cap[possible_bins] - item\n    fit_score = 1.0 / (waste + 1e-6) \n    priorities[possible_bins] = np.exp(-waste / item) * fit_score\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    \n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (waste + 1e-6)\n    \n    return priorities\n\n### Analyze & experience\n- Comparing heuristics 1st vs 2nd, both utilize fit and waste, but the 1st uses a simple ratio while the 2nd adds an exponential decay based on total waste. This decay in the 2nd appears to add unnecessary complexity without clear benefit. Comparing 1st vs 3rd, the 3rd solely uses an exponential decay on waste, entirely neglecting fit which is crucial. Comparing 3rd vs 4th, 4th is identical to 1st. Comparing 5th vs 6th, they are identical.  5th/6th introduce a fit score as `1.0 / (waste + 1e-6)` combined with an exponential waste decay \u2013  it\u2019s a reasonable approach, but arguably less direct than simply considering fit relative to remaining capacity. Comparing 7th vs 8th, 7th adds a bin age bonus to the inverse waste, while 8th has a minimal implementation returning mostly zeros. Comparing 9th vs 10th, both utilize inverse waste with a small offset, but 10th is slightly clearer in its intent.  11th and 16th are similar in their base implementation but lack any sophisticated prioritization beyond inverse remaining capacity. 12th introduces a lot of unnecessary parameters. 13th and 15th boost the best fit, which is a good strategy. 14th and 17th and 19th and 20th attempt combinations of fit, waste, and age but become overly complex. 18th uses a sigmoid function which doesn\u2019t seem to have a significant advantage.\n\nOverall: The best heuristics (1st, 4th) consistently prioritize based on fit relative to remaining capacity, adding a small constant to avoid division by zero. Introducing complexity like waste decay or bin age doesn't consistently improve performance and can sometimes obscure the core logic. Simplicity and directness appear to be key.\n- \nOkay, let's refine \"Current Self-Reflection\" for superior heuristic design, aiming for that $999K! Here's a breakdown:\n\n* **Keywords:** Capacity utilization, fit score, waste decay, robustness, simplicity.\n* **Advice:** Prioritize direct \"fit\" *and* waste\u2014use exponential decay on waste to subtly penalize bin choices leading to fragmentation *without* overcomplicating the core selection. Tune decay rates carefully.\n* **Avoid:** Normalization masking crucial differences; complex functions (sigmoid) when simpler ones suffice; solely relying on remaining capacity without waste consideration.\n* **Explanation:** Heuristics thrive on speed. While context (bin age, global waste) is valuable, it adds cost. Exponential decay elegantly balances long-term impact (waste) with immediate need (fit) at low computational overhead, ensuring robustness.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}