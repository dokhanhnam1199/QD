{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines the simplicity of inverse remaining capacity (v2) \n    with a check for valid bins (v6/v7/v8) for efficiency.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n    priorities[possible_bins] = 1.0 / (bins_remain_cap[possible_bins] - item + 1e-6)\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculates priorities for placing an item into bins.\n\n    Args:\n        item (float): The size of the item to be placed.\n        bins_remain_cap (np.ndarray): Remaining capacity of each bin.\n        total_waste (float, optional): Total waste so far. Defaults to 0.0.\n        bin_ages (np.ndarray, optional): Age of each bin. Defaults to None.\n        k (float, optional): Waste decay factor. Defaults to 0.01.\n        age_weight (float, optional): Weight for bin age. Defaults to 0.1.\n\n    Returns:\n        np.ndarray: Priorities for each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n\n### Analyze & experience\n- Comparing Heuristics 1st vs 2nd, both are very similar, but the 1st introduces `total_waste` impacting preference through exponential decay, and includes a `bin_ages` bonus. The 2nd is cleaner, integrating age directly into the preference calculation. However, the explicit `total_waste` parameter in the 1st offers potential for tuning waste sensitivity.\n\nComparing Heuristics 3rd vs 4th, the 3rd uses inverse waste with a log penalty for the number of possible bins, aiming to distribute items. The 4th is simpler, just inverse waste. The log penalty in the 3rd seems like a potential overcorrection and adds complexity.\n\nComparing Heuristics 1st vs 3rd, the 1st provides a richer feature set (waste decay, age, fit score) with more tunable parameters. The 3rd is much more basic. \n\nComparing Heuristics 5th vs 6th, 6th incorporates a check for valid bins which makes it slightly more efficient, but both are basic inverse remaining capacity.\n\nHeuristics 7th is essentially the same as 4th. Heuristics 8th attempts weighting, but the weights are arbitrary. Heuristics 9th is more sophisticated with waste decay but uses total waste instead of waste relative to the current item. Heuristics 10th attempts fill level and waste, but is complicated. Heuristics 11th adds a hardcoded boost to the best fit.  Heuristics 12th & 13th include unnecessary parameters for waste decay, age weight, and constants which suggests overfitting. 14th-20th are progressively worse - simplifying to inverse capacity or using sigmoids, and offer no significant improvements. The last ones are simplistic or less effective. Overall, the best heuristics combine fit, waste/capacity, and age while providing tunable parameters. Simpler approaches with only waste or capacity tend to be less effective, and complex approaches often introduce unnecessary parameters.\n- \nOkay, let's refine this self-reflection for superior heuristic design \u2013 aiming for that $999K! Here's a breakdown:\n\n* **Keywords:** Fit, Waste (decay), Age, Tunable Weights, Robustness.\n* **Advice:** Prioritize weighted combinations of item-bin *fit* (remaining capacity), exponentially decaying *waste* (bin-specific!), and bin *age*. Tune weights empirically. Simple checks for bin validity are vital.\n* **Avoid:** Normalization, complex functions (sigmoid), global waste metrics, hardcoded constants, solely relying on remaining capacity.\n* **Explanation:**  Focusing on *local* bin characteristics & tunable interaction between fit/waste/age yields adaptable heuristics. Robustness (no division by zero) prevents crashes, while simplicity maintains efficiency and interpretability.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}