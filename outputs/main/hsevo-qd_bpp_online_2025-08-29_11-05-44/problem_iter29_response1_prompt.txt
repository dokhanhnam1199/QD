{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines fit and waste decay with a small age bonus, prioritizing bins.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n\n    fit_score = 1.0 / (bins_remain_cap[possible_bins] - item + 0.0001)\n    waste_decay = np.exp(-0.1 * (1 - (bins_remain_cap[possible_bins] - item) / bins_remain_cap[possible_bins]))\n    age_bonus = np.arange(n_bins) / n_bins\n    \n    priorities[possible_bins] = 0.6 * fit_score * waste_decay + 0.4 * age_bonus[possible_bins]\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines capacity-weighted preference with waste-sensitive decay.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see the first heuristic incorporates a tunable waste decay *and* an age bonus, weighting them with the fit score, creating a more nuanced priority. The second relies solely on fit and waste, lacking the age component for potential stagnation. (3rd) vs (4th) shows the 3rd adds a small age bonus and weighted combination which is better than simple fit and waste penalty in the 4th. (5th) vs (6th) reveals the 6th adds an explicit 'best_bin_index' boost, potentially hindering exploration. (7th) vs (8th) demonstrates simplification in 7th, relying on inverse waste. (9th) vs (10th) shows the 9th is a weighted combination of fit, waste, and age bonus. (11th) vs (12th) shows the 11th attempts to boost the best fit, but 12th uses normalized waste. (13th) vs (14th) shows similar implementations, but different weightings. (15th) uses parameters. (16th) calculates total waste. (17th) normalizes temperature which is not good. (18th) and (19th) are incomplete. (20th) is a good combination of fit, waste and age.\n\nOverall: The most successful heuristics (1st, 3rd, 9th, 13th, 14th, 20th) consistently combine fit (how well an item fits in a bin), waste (how much space is left after placing the item), and age (how recently a bin was used).  Tunable parameters and weighted combinations seem crucial for balancing these factors. Simpler approaches (7th, 8th) can be less effective. Explicitly boosting a single bin (6th, 11th) can limit search diversity.\n- \nOkay, let's dissect this and formulate actionable advice for better heuristic design, aiming for that $999K tip! Here's a breakdown:\n\n*   **Keywords:** Weighted Multi-Factor Evaluation, Exponential Decay, Robustness, Tunability.\n*   **Advice:** Prioritize a weighted combination of *fit, waste, and age*, using exponential decay for waste control. Embrace tunable parameters for adaptability. Implement defensive checks (division by zero) *always*.\n*   **Avoid:** Overly complex functions (sigmoid), global normalization obscuring differences, and solely relying on remaining capacity or simple reciprocals. Don't prematurely optimize; build a robust baseline first.\n*   **Explanation:** Both 'Current' & 'Ineffective' reflections converge on fit/waste/age, but the *how* differs. The 'Current' reflection emphasizes balance & tunability, actively resisting aggressive single-factor boosting \u2013 this is where real robustness & adaptability lie.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}