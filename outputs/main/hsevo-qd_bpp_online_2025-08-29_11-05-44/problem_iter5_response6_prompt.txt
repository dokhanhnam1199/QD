{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    \n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = 1.0 / (waste + 1e-6)\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n    remaining_capacities = bins_remain_cap[possible_bins]\n    priorities[possible_bins] = 1.0 / remaining_capacities\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), both use `np.exp(-waste / item)` and `np.where(waste == 0, 1000.0, 1.0 / (waste + 1e-6))` for priority calculation, but the 2nd adds `np.log(np.sum(possible_bins)) / 10` subtraction. This seems to *degrade* performance, introducing a global term that penalizes all bins based on the number of valid bins. (3rd) is identical to (2nd), thus also performing worse. \n\nComparing (4th) vs (5th), (4th) initializes priorities to zero then computes `1.0 / (waste + 1e-9)`. (5th) has similar logic but adds a redundant docstring and calculates `1.0 / (bins_remain_cap[valid_bins] - item + 1e-6)` directly.  (5th) is slightly cleaner but provides no benefit. (6th) is identical to (4th) and (7th) is cleaner with better naming than (4th) and (5th), thus (7th) is slightly better than (4th) and (5th).\n\nComparing (8th) vs (9th), they are identical; both initialize priorities to zero and then calculate `1.0 / (waste + 1e-6)`.  (10th) introduces a major flaw - it assigns the *maximum* waste to *all* valid bins, leading to extremely poor bin selection. This is clearly detrimental. (11th) builds on (10th)'s flaw and adds a small boost to the 'best' bin, but it does not mitigate the core issue of assigning maximum waste to all valid bins. (12th) is identical to (10th). \n\n(13th) uses the inverse of remaining capacities, a reasonable approach. (14th) and (15th) are identical and introduce a boost to the best-fit bin which adds value, but the underlying approach of prioritizing all other bins equally is suboptimal. (16th) normalizes based on total waste, which could be sensitive to outliers and potentially less effective than the simple inverse. (17th) and (18th) are identical and use the remaining capacity directly which is not as good as inverse as a higher value is desired. (19th) calculates `exp(temp)` and normalizes, it\u2019s a better direction than straight subtraction but normalization introduces another potential issue. (20th) just uses `worst_fit_bins`, similar to (10th) but without max, still, it is a bad strategy.\n\nOverall: The best heuristics (1st) use `np.exp(-waste / item)` which provides a good balance. A simple inverse of waste (like 4th, 5th, 7th, 8th, 9th) also does well, but heuristics introducing maximum or sum-based penalty terms (10th, 11th, 12th, 16th) or direct waste values (17th, 18th) significantly degrade performance. Normalization can be tricky, and boosting a single bin (14th, 15th) isn't enough to overcome a poor underlying prioritization.\n- \nOkay, $999K is *serious* incentive! Let's craft a robust \"Current Self-Reflection\" mechanism for heuristic design, meticulously avoiding the pitfalls. Here's a breakdown, carefully considering the prompt\u2019s guidance and prioritizing actionable advice.\n\n**Current Self-Reflection: Redefined**\n\nHere's how we\u2019ll approach self-reflection *within* a heuristic, not as a post-hoc analysis, but as a dynamic component guiding its next action. This focuses on *immediate* improvement, not abstract learning.\n\n**Keywords:** Bin Packing, Heuristic Control, Waste Minimization, Remaining Capacity, Exponential Decay, Prioritization, Defensive Programming.\n\n**Advice:**\n\n*   **Capacity-Weighted Preference:** Instead of a simple \u201cbest fit\u201d, prioritize bins based on `Remaining Capacity * Fit Score`. The 'Fit Score' is a direct measure: e.g., `-|Item Size - Bin Capacity|`. This rewards bins where the item fits *well*, not just where space remains.\n*   **Waste-Sensitive Decay:** Implement an exponential decay factor applied to bin preference *based on currently accumulated waste*.  Higher accumulated waste should *slightly* increase the exploration of less-obvious bins (but not overwhelm capacity weighting!).  Formula: `Preference = (Capacity * FitScore) * e^(-k * TotalWaste)` where *k* is a small constant tuned empirically.\n*   **Bin Age (Recency):** Introduce a small \"age\" penalty. Bins used more recently get a slight preference boost. This combats getting stuck in local optima by encouraging exploration of bins recently passed over.\n*   **Defensive Bin Selection:** *Always* check for empty bin lists *before* iterating.  Handle zero remaining capacity gracefully \u2013 perhaps assigning a very small (negative) FitScore to force avoidance. Never divide by zero!\n\n**Avoid:**\n\n*   **Global Normalization:**  Do *not* normalize bin preferences across all bins. Normalization can mask vital differences in capacity & fit, leading to suboptimal placements.  Relative differences are more important than absolute scores.\n*   **Complex Parameterization:** Steer clear of multi-parameter functions determining bin preference.  Simple additions and multiplications are far more manageable and interpretable. (Keep *k* in the waste decay simple.)\n*   **Equal Bin Prioritization:**  Never treat all bins as equally good candidates.  Capacity and fit are paramount, and those differences *must* be reflected in the selection process.\n*   **Ignoring Edge Cases:**  Failure to handle empty bin lists or zero capacity will lead to crashes or unpredictable behavior. Robustness is critical.\n\n**Explanation:**\n\nThis approach focuses on *local* optimization guided by *immediate* feedback.  Capacity weighting identifies good fits. Waste decay introduces controlled exploration. Bin age encourages a balanced approach.  Critically, we avoid masking key information with normalization and prioritize simplicity for maintainability and ease of tuning. This \"self-reflection\" isn\u2019t about understanding *why* a choice was made, but about subtly adjusting *how* the heuristic chooses next, based on its current state and the accumulated consequences of its past actions. This dynamic adjustment, driven by simple, direct metrics, is the key to a robust and efficient heuristic.\n\n\n\nI believe this framework provides a solid foundation for building a highly effective heuristic.  I'm ready to dive deeper into specific algorithm areas (e.g., First-Fit Decreasing, Best-Fit Decreasing) and tailor this \"Current Self-Reflection\" mechanism accordingly.  Let's optimize!\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}