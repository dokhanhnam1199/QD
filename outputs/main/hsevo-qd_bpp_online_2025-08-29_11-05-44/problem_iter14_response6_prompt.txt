{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    for i in range(n_bins):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1 / (1 + np.exp(- (bins_remain_cap[i] - item) / 0.5))\n        else:\n            priorities[i] = 0\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes waste decay, fit, and bin age.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n\n    waste = np.sum(bins_remain_cap) - np.sum(bins_remain_cap[possible_bins])\n    if waste <= 0:\n      waste_decay = 0\n    else:\n      waste_decay = -np.log(waste + 1)\n\n    fit_scores = bins_remain_cap[possible_bins] - item\n    age_bonus = np.arange(len(bins_remain_cap))[possible_bins] * 0.005\n\n    preferences = (fit_scores * 0.9) + (waste_decay * 0.1) + age_bonus\n    priorities[possible_bins] = preferences\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see identical code, indicating no discernible difference in their performance.  (1st) and (2nd) are strong contenders as they combine fit, waste decay, and age bonus - a well-rounded approach. (1st) vs (3rd): The former incorporates exponential decay for waste, allowing for a tunable sensitivity to overall bin waste, whereas (3rd) uses a simpler exponential based only on the immediate bin's waste, lacking global context. (3rd) vs (4th) & (5th): (3rd) is more concise and likely computationally cheaper, but (4th) and (5th) introduce `bin_ages`, potentially improving solutions over time. (4th) and (5th) are identical.  (6th) vs (7th) & (8th): (6th) and (8th) prioritize inverse waste with a small addition to avoid division by zero. (7th) uses a recent usage boost which isn\u2019t as generally useful as bin age. (6th) vs (8th) are identical. (9th) - (15th): These are generally weaker.  (9th) normalizes waste, but the effect is likely limited. (10th)-(12th) are largely identical and use simple inverse waste. (13th)-(15th) introduce sigmoid functions which can smooth the scoring but introduce computational cost with limited benefit. (16th) - (20th): Similar to the top-ranked heuristics, employing waste decay, fit, and age bonuses but with minor variations in the decay function and weightings. They are complex than (1st) and (2nd) but also have the same features. Overall: The best heuristics (1st/2nd, 16th-20th) effectively balance fit, waste, and age, while simpler heuristics (3rd, 6th, 7th, 8th, 10th-12th) lack the nuance for optimal bin packing.\n- \nOkay, let's refine heuristic design based on this self-reflection analysis \u2013 aiming for that $999K! Here\u2019s a breakdown:\n\n* **Keywords:** Weighted scoring, Exponential decay, Robustness, Contextualization.\n* **Advice:** Combine fit, waste (exponentially decayed), and bin age using *tunable* weights. Prioritize direct, measurable features over complex functions. Consider global context (total waste, overall bin age) to refine bin prioritization.\n* **Avoid:** Normalization obscuring differences, sigmoid functions, solely relying on remaining capacity, and overlooking division-by-zero errors.\n* **Explanation:** Effective heuristics balance simplicity *with* contextual awareness. Weights allow adaptation; exponential decay controls waste influence. Robustness ensures reliability. Tunability and simplicity are key to maintainability & performance.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}