{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines waste decay (like v0) with a direct fit component (like v6).\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n\n    waste = bins_remain_cap[possible_bins] - item\n    fit_score = 1.0 / (waste + 1e-6) \n    priorities[possible_bins] = np.exp(-waste / item) * fit_score\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines capacity-weighted preference with waste-sensitive decay for bin selection.\n    Prioritizes bins based on remaining capacity and how well the item fits,\n    adjusting preference based on accumulated waste to encourage exploration.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n\n    waste = bins_remain_cap[possible_bins] - item\n    fit_score = -np.abs(waste)\n    \n    total_waste = np.sum(bins_remain_cap - item) if np.any(possible_bins) else 0\n    k = 0.01 \n\n    priorities[possible_bins] = (bins_remain_cap[possible_bins] * fit_score) * np.exp(-k * total_waste)\n\n    return priorities\n\n### Analyze & experience\n- Comparing heuristics 1st vs 2nd, the key difference is the waste calculation and its integration. Heuristic 1st uses `np.exp(-0.01 * waste)` decaying the entire system waste, while heuristic 2nd calculates waste as the difference between remaining capacity and item size for *possible* bins, using `1.0 / (1.0 + waste)`. Heuristic 1st also includes an age bonus, a feature missing in 2nd.\n\nComparing 3rd vs 4th, both combine waste and fit. 3rd uses `np.exp(-waste / item)` for waste decay, scaling by the item size, alongside an inverse waste fit score. 4th uses `np.exp(-0.005 * waste)` with a simpler waste penalty, not scaled by item size. \n\nComparing 5th vs 6th, both incorporate waste, fit and age. 5th introduces a strong penalty/boost if waste is zero, and subtracts the log of possible bins, potentially creating instability. 6th uses weighted combination (0.5, 0.3, 0.2) for a more controlled integration.\n\nComparing 7th vs 8th, both are variations of heuristic 2nd, but 8th introduces weighted combination and a different way to compute waste influence.\n\nComparing 9th vs 10th, 9th is a refinement of 6th with tuned weights, while 10th is very basic (almost returning zero priority) and implements only a simple inverse waste.\n\nComparing 11th vs 12th, 11th combines inverse remaining capacity with exponential waste decay, while 12th only implements inverse remaining capacity. \n\nComparing 13th vs 14th, 13th introduces a density preference, adding complexity with another weight. 14th is similar to others but uses a global `total_waste` which might be suboptimal.\n\nComparing 15th vs 16th, 15th is a duplicate of 14th. 16th combines capacity-weighted preference and waste-sensitive decay, but its use of `np.exp(-k * total_waste)` makes it very sensitive to the total waste.\n\nComparing 17th vs 18th, 17th is extremely basic. 18th prioritizes bins based on remaining capacity and avoids division by zero, but uses unnecessary imports.\n\nComparing 19th vs 20th, 19th utilizes a sigmoid function to avoid division by zero. 20th uses a combination of fit, waste and age, with optional bin ages.\n\nOverall: The top heuristics (1st-6th, 8th, 9th) all converge on a combination of *fit*, *waste decay*, and optionally *age*. Exponential decay of waste seems to be more effective than simple subtraction or inverse calculations. Weighted combinations of these features appear crucial for performance.  The worst performing heuristics (10th, 17th) are overly simplistic.\n- \nOkay, let's refine heuristic design based on this self-reflection analysis. Here's a breakdown, aiming for that $999K tip!\n\n* **Keywords:** Weighted scoring, Exponential decay, Robustness, Tunable parameters.\n* **Advice:** Prioritize *weighted* combinations of fit (remaining capacity), waste (exponential decay!), and bin age. Start with a simple weighted sum, then *iteratively* refine weights based on rigorous testing across diverse problem instances.\n* **Avoid:** Global waste calculations & complex functions (sigmoid). Over-simplification *and* over-complication. Hardcoded values \u2013 always use tunable parameters.\n* **Explanation:** The 'Ineffective' reflections repeatedly advocated for simplicity *without* demonstrably improved results. The \u2018Current\u2019 analysis consistently points to nuanced, weighted approaches \u2013 a sweet spot between simplistic reciprocals and overly complex formulas \u2013 yielding superior performance and adaptability.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}