{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    bin_ids = np.arange(len(bins_remain_cap))\n    \n    fit_score = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    valid_bins = bins_remain_cap >= item\n    \n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    fit_score[valid_bins] = 1.0 / (1.0 + np.exp(-5 * (bins_remain_cap[valid_bins] - item)))\n\n    \n    priorities = fit_score\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    temp = bins_remain_cap - item\n    priorities = np.where(temp >= 0, np.exp(temp), 0)\n    return priorities / np.sum(priorities) if np.sum(priorities) > 0 else np.zeros_like(bins_remain_cap)\n\n### Analyze & experience\n- Comparing `priority_v2` in the 1st heuristic to the 20th, the core difference lies in the prioritization strategy. The 1st heuristic's `v2` simply assigns a priority based on the inverse of remaining capacity, avoiding division by zero. The 20th (and many others like it) use exponential functions or sigmoids. While these can create a smoother prioritization, they introduce complexity and a potential for diminishing returns. Specifically, the exponential function in the 19th and 20th can quickly saturate, leading to all valid bins having very similar priorities.\n\nComparing `priority_v2` in the 2nd and 3rd heuristics, the main distinction is the addition of `1e-6` to the denominator in the 3rd. This is a defensive programming technique preventing division by zero, but introduces a slight bias. The 2nd is cleaner.\n\n`priority_v2` in the 4th and 5th are effectively the same as 2nd and 3rd but different variable names (`waste` instead of directly calculating in the division).\n\nThe 6th and 7th/8th introduce identical logic, utilizing `possible_bins` to filter and calculate priorities, and are more efficient than the earlier versions without the filtering.\n\nHeuristics 9th and 10th try a different approach \u2013 identifying the *best* bin and boosting its priority. This can be beneficial if a slightly better fit dramatically improves the solution.\n\nHeuristics 12th normalizes the waste, which can be useful if bin capacities vary widely. However, normalization can also obscure true differences in fit.\n\nHeuristic 13th assigns negative priority to invalid bins, this helps bins to not be selected.\n\nHeuristics 14th through 18th rely on sigmoid or exponential functions to provide a smoothed priority, but the function and scaling factor influence performance.\n\nOverall: The best heuristics (1st-8th) prioritize simplicity and directness, calculating a score based on remaining capacity. Later heuristics attempt more sophisticated approaches but often introduce unnecessary complexity or parameters without a clear benefit. The addition of small constants (e.g. `1e-6`) for numerical stability is good practice.\n- \nOkay, let's refine \"Current Self-Reflection\" for superior heuristic design. Here's a breakdown aiming for that $999K tip!\n\n* **Keywords:** Pragmatism, Measurability, Robustness, Signal Clarity.\n* **Advice:** Prioritize easily calculated, directly interpretable metrics. Focus on *identifiable bottlenecks* and iteratively improve the heuristic's response to those. Embrace minimal, working code.\n* **Avoid:** Abstract, multi-faceted \"fitness\" scores. Over-engineering for edge cases *before* demonstrating baseline performance. Premature optimization.\n* **Explanation:** Effective heuristics thrive on speed & reliability. Clarity in measuring progress (fit) allows for targeted refinement. Robustness (handling errors) prevents catastrophic failures.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}