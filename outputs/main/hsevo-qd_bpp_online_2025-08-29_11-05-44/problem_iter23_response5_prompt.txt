{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines fit score (inverse remaining capacity) with a small constant and a waste factor.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    \n    remaining_capacities = bins_remain_cap[valid_bins]\n    \n    fit_score = 1.0 / (remaining_capacities - item + 1e-6)\n    waste_factor = np.exp(-remaining_capacities / np.mean(bins_remain_cap))\n    \n    priorities[valid_bins] = fit_score * waste_factor\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines features from heuristics 6 and 9: prioritizes bins with enough capacity,\n    boosts the priority of the best-fit bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if np.any(possible_bins):\n        priorities[possible_bins] = 1.0\n        best_bin_index = np.argmin(bins_remain_cap[possible_bins] - item)\n        priorities[possible_bins][best_bin_index] = 2.0\n    return priorities\n\n### Analyze & experience\n- Comparing Heuristics 1st vs 2nd, both combine fit, waste decay, and age, but the 1st introduces tunable weights and applies the exponential decay to the fit score *before* adding the age bonus. The 2nd directly adds the age bonus. This pre-scaling in the 1st likely allows for better control and prevents the age bonus from overshadowing the other factors when waste is high. Comparing Heuristics 1st vs 3rd, the 1st has a more nuanced scoring system, explicitly incorporating both fit and waste, while the 3rd relies solely on inverse waste. Heuristics 4th vs 5th, 4th employs capacity weighting of fit, making the best fit even more attractive, a feature absent in 5th. Comparing Heuristics 6th, 7th (identical) vs 8th, 6th/7th utilize a weighted sum of fit, waste, and age, while 8th provides a basic reciprocal of waste with a small correction. Heuristics 9th vs 10th both use a reciprocal of remaining capacity. 9th uses an exponential waste factor, while 10th doesn't. Heuristics 12th and 13th are identical. Heuristics 14th refines the weighted sum of 12th/13th with a better structure and direct application of weights. 15th, 16th and 17th are mostly empty implementations. 18th and 19th are identical, boosting the best-fit bin but still relatively simple. Heuristics 20th uses a sigmoid function which allows for smoother prioritization. Overall, the best heuristics consistently combine multiple factors (fit, waste, age) with weighted sums and/or exponential decay for more robust and adaptable prioritization, avoiding simple reciprocal calculations or incomplete implementations.  The tunable parameters offer greater control.\n- \nOkay, let's distill this into actionable heuristic design guidance, aiming for that $999K! Here's a breakdown:\n\n* **Keywords:** Weighted scoring, Exponential decay, Robustness, Tunability.\n* **Advice:** Prioritize *weighted* combinations of fit, waste, and bin age. Start simple, implement a solid baseline, *then* introduce complexity cautiously. Exponential decay for waste is excellent \u2013 tune its rate!\n* **Avoid:** Normalization unless *absolutely* necessary (it can hide crucial differences). Overly complex functions (sigmoids) when simpler alternatives (direct fit measures) exist. Division by zero *at all costs*.\n* **Explanation:** The core is balancing exploitation (immediate fit) with exploration (minimizing long-term waste). Tunable weights allow adaptation; robustness prevents crashes; simplicity ensures maintainability & speed.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}