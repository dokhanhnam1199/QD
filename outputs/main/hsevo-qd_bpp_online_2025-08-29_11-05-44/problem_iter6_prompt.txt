{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\nCurrent heuristics:\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on remaining capacity, avoiding division by zero.\n    Combines elements of heuristics 1 and 7/8 for efficiency and robustness.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n    waste = bins_remain_cap[possible_bins] - item\n    priorities[possible_bins] = 1.0 / (1.0 + waste)\n    return priorities\n\nNow, think outside the box write a mutated function `priority_v2` better than current version.\nYou can use some hints below:\n- \nOkay, $999K is *serious* incentive! Let's craft a robust \"Current Self-Reflection\" mechanism for heuristic design, meticulously avoiding the pitfalls. Here's a breakdown, carefully considering the prompt\u2019s guidance and prioritizing actionable advice.\n\n**Current Self-Reflection: Redefined**\n\nHere's how we\u2019ll approach self-reflection *within* a heuristic, not as a post-hoc analysis, but as a dynamic component guiding its next action. This focuses on *immediate* improvement, not abstract learning.\n\n**Keywords:** Bin Packing, Heuristic Control, Waste Minimization, Remaining Capacity, Exponential Decay, Prioritization, Defensive Programming.\n\n**Advice:**\n\n*   **Capacity-Weighted Preference:** Instead of a simple \u201cbest fit\u201d, prioritize bins based on `Remaining Capacity * Fit Score`. The 'Fit Score' is a direct measure: e.g., `-|Item Size - Bin Capacity|`. This rewards bins where the item fits *well*, not just where space remains.\n*   **Waste-Sensitive Decay:** Implement an exponential decay factor applied to bin preference *based on currently accumulated waste*.  Higher accumulated waste should *slightly* increase the exploration of less-obvious bins (but not overwhelm capacity weighting!).  Formula: `Preference = (Capacity * FitScore) * e^(-k * TotalWaste)` where *k* is a small constant tuned empirically.\n*   **Bin Age (Recency):** Introduce a small \"age\" penalty. Bins used more recently get a slight preference boost. This combats getting stuck in local optima by encouraging exploration of bins recently passed over.\n*   **Defensive Bin Selection:** *Always* check for empty bin lists *before* iterating.  Handle zero remaining capacity gracefully \u2013 perhaps assigning a very small (negative) FitScore to force avoidance. Never divide by zero!\n\n**Avoid:**\n\n*   **Global Normalization:**  Do *not* normalize bin preferences across all bins. Normalization can mask vital differences in capacity & fit, leading to suboptimal placements.  Relative differences are more important than absolute scores.\n*   **Complex Parameterization:** Steer clear of multi-parameter functions determining bin preference.  Simple additions and multiplications are far more manageable and interpretable. (Keep *k* in the waste decay simple.)\n*   **Equal Bin Prioritization:**  Never treat all bins as equally good candidates.  Capacity and fit are paramount, and those differences *must* be reflected in the selection process.\n*   **Ignoring Edge Cases:**  Failure to handle empty bin lists or zero capacity will lead to crashes or unpredictable behavior. Robustness is critical.\n\n**Explanation:**\n\nThis approach focuses on *local* optimization guided by *immediate* feedback.  Capacity weighting identifies good fits. Waste decay introduces controlled exploration. Bin age encourages a balanced approach.  Critically, we avoid masking key information with normalization and prioritize simplicity for maintainability and ease of tuning. This \"self-reflection\" isn\u2019t about understanding *why* a choice was made, but about subtly adjusting *how* the heuristic chooses next, based on its current state and the accumulated consequences of its past actions. This dynamic adjustment, driven by simple, direct metrics, is the key to a robust and efficient heuristic.\n\n\n\nI believe this framework provides a solid foundation for building a highly effective heuristic.  I'm ready to dive deeper into specific algorithm areas (e.g., First-Fit Decreasing, Best-Fit Decreasing) and tailor this \"Current Self-Reflection\" mechanism accordingly.  Let's optimize!\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}