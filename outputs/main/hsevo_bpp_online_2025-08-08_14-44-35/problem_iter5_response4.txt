```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tight-fitting preference with adaptive exploration using epsilon-greedy.
    Prioritizes bins that leave minimal waste, with a chance to explore other bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    # If no bins can fit, return zero priorities
    if not np.any(can_fit_mask):
        return priorities
    
    suitable_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # Calculate waste (remaining capacity after packing)
    waste = suitable_bins_remain_cap - item
    
    # Heuristic: Prioritize bins with minimal waste (tighter fit)
    # Use inverse of waste + epsilon for higher scores for smaller waste
    epsilon = 1e-9
    tight_fit_scores = 1.0 / (waste + epsilon)
    
    # Normalize scores to be between 0 and 1 for consistency
    if np.max(tight_fit_scores) > epsilon:
        normalized_tight_fit_scores = tight_fit_scores / np.max(tight_fit_scores)
    else:
        normalized_tight_fit_scores = np.ones_like(tight_fit_scores)
        
    # Adaptive Exploration (Epsilon-Greedy inspired):
    # With a small probability (epsilon), choose a random fitting bin.
    # Otherwise, choose the bin with the best tight-fit score.
    epsilon = 0.1  # Exploration rate
    
    if np.random.rand() < epsilon:
        # Explore: pick a random bin among those that can fit
        random_choice_index_in_suitable = np.random.randint(0, len(suitable_bins_remain_cap))
        
        # Assign a high priority to the randomly chosen bin
        priorities[can_fit_mask][random_choice_index_in_suitable] = 1.0
    else:
        # Exploit: pick the bin with the highest tight-fit score
        priorities[can_fit_mask] = normalized_tight_fit_scores

    # Ensure priorities are non-negative
    priorities[priorities < 0] = 0

    return priorities
```
