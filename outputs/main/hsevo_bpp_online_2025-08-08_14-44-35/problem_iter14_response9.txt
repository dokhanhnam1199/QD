```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with a normalized utilization bonus and adaptive epsilon-greedy exploration.
    Favors bins that minimize slack, with a bonus for partially filled bins, and explores
    less optimal bins probabilistically.
    """
    epsilon = 1e-9
    exploration_prob = 0.1

    can_fit_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if not np.any(can_fit_mask):
        return priorities

    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]

    # --- Component 1: Tightest Fit Score ---
    # Prioritize bins leaving minimal slack. Score is inverse of slack.
    remaining_after_packing = fitting_bins_remain_cap - item
    tightness_score = 1.0 / (remaining_after_packing + epsilon)

    # --- Component 2: Normalized Utilization Bonus ---
    # Prefer bins that are already partially filled (less remaining capacity before packing).
    # Score is inverse of current remaining capacity, normalized by the maximum.
    utilization_score = 1.0 / (fitting_bins_remain_cap + epsilon)
    max_utilization_score = np.max(utilization_score)
    normalized_utilization_bonus = (utilization_score / (max_utilization_score + epsilon)) * 0.5 # Apply a 0.5 weight

    # --- Combined Exploitation Score ---
    # Weighted sum of tightness and normalized utilization bonus.
    combined_exploitation_scores = tightness_score + normalized_utilization_bonus

    # Normalize exploitation scores to be between 0 and 1
    max_exploitation_score = np.max(combined_exploitation_scores)
    if max_exploitation_score > epsilon:
        normalized_exploitation_scores = combined_exploitation_scores / max_exploitation_score
    else:
        normalized_exploitation_scores = np.zeros_like(combined_exploitation_scores)

    # --- Component 3: Adaptive Exploration (Epsilon-Greedy) ---
    # Introduce a small probability to explore less optimal bins.
    num_fitting_bins = len(fitting_bins_remain_cap)
    exploration_boost = np.zeros_like(normalized_exploitation_scores)

    if num_fitting_bins > 0:
        num_to_explore = max(1, int(np.floor(exploration_prob * num_fitting_bins))) # Ensure at least one bin is explored if possible
        explore_indices = np.random.choice(num_fitting_bins, size=min(num_to_explore, num_fitting_bins), replace=False)
        
        # Assign a moderate boost to explored bins, ensuring they have a chance but don't dominate
        exploration_boost[explore_indices] = 0.3 

    # --- Final Priority Calculation ---
    # Combine exploitation scores with exploration boost.
    final_scores_unnormalized = normalized_exploitation_scores + exploration_boost
    
    # Normalize final scores so that the highest priority is 1.0.
    max_final_score = np.max(final_scores_unnormalized)
    if max_final_score > epsilon:
        priorities[can_fit_mask] = final_scores_unnormalized / max_final_score
    else:
        # Fallback to uniform probability if all scores are zero.
        priorities[can_fit_mask] = 1.0 / num_fitting_bins
        
    return priorities
```
