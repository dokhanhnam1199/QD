```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines the tightness preference with an adaptive "fill level" bonus
    and a sophisticated exploration strategy inspired by multi-armed bandits.
    Prioritizes tight fits while encouraging the use of partially filled bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # If no bins can fit, return all zeros
    if not np.any(can_fit_mask):
        return priorities

    # --- Exploitation Strategy: Combined Tightness and Fill Bonus ---

    # Tightness score: Inverse of remaining capacity after packing. Higher is better.
    # This favors bins that leave minimal slack.
    tightness_score = np.zeros_like(bins_remain_cap, dtype=float)
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    remaining_after_packing = fitting_bins_remain_cap - item
    tightness_score[can_fit_mask] = 1.0 / (remaining_after_packing + epsilon)

    # Fill Level Bonus: Rewards bins that are already more utilized.
    # We approximate utilization by penalizing bins with large remaining capacity.
    # A simple inverse of the current remaining capacity (for fitting bins) serves as a bonus.
    # This encourages using bins that are already partially filled, rather than always
    # picking a "tight fit" in a nearly empty bin.
    fill_bonus = np.zeros_like(bins_remain_cap, dtype=float)
    # Bonus is higher for bins with less remaining capacity (i.e., more filled)
    fill_bonus[can_fit_mask] = 1.0 / (fitting_bins_remain_cap + epsilon)

    # Combine tightness and fill bonus. Multiplication allows the fill bonus to
    # modulate the tightness score. A bin that is both tight and already somewhat full
    # gets a higher combined score.
    combined_exploitation_score = tightness_score * (1.0 + 0.3 * fill_bonus) # 0.3 is a tunable weight

    # Normalize exploitation scores to the range [0, 1]
    max_exploitation_score = np.max(combined_exploitation_score)
    if max_exploitation_score > 0:
        normalized_exploitation_scores = combined_exploitation_score / max_exploitation_score
    else:
        normalized_exploitation_scores = np.zeros_like(combined_exploitation_score)

    # --- Exploration Strategy: Adaptive Exploration (Simplified Bandit-like) ---

    # We want to explore bins that are currently less prioritized to discover
    # potentially better packing options or to balance load.
    # A simple adaptive strategy: If a bin has a low exploitation score,
    # it's a candidate for exploration. We'll assign a small, uniform exploration
    # priority to all bins that can fit the item. The degree of exploration
    # can be tied to the number of available fitting bins.

    num_fitting_bins = np.sum(can_fit_mask)
    exploration_weight = 0.15 # Base weight for exploration

    # Increase exploration tendency if there are many options, decrease if few
    if num_fitting_bins > 5:
        exploration_weight *= 1.2
    elif num_fitting_bins < 3:
        exploration_weight *= 0.8

    # Create exploration scores. For simplicity here, we'll give a small boost
    # to all fitting bins, meaning any fitting bin has a chance.
    # A more advanced approach would use a UCB-like strategy.
    exploration_scores = np.zeros_like(bins_remain_cap, dtype=float)
    exploration_scores[can_fit_mask] = exploration_weight / num_fitting_bins

    # --- Final Priority: Blend Exploitation and Exploration ---
    # A simple blending: priorities = exploitation_scores + exploration_scores
    # This gives a base priority based on exploitation and adds a small chance
    # to any fitting bin via exploration.
    priorities[can_fit_mask] = normalized_exploitation_scores[can_fit_mask] + exploration_scores[can_fit_mask]

    # Ensure no negative priorities and normalize the final output to [0, 1]
    priorities = np.maximum(0, priorities)
    max_final_priority = np.max(priorities)
    if max_final_priority > 0:
        priorities /= max_final_priority

    return priorities
```
