```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a multi-objective approach.
    This heuristic balances fitting the item tightly (like v1) with considering bins that
    are "nearly full" but might still accommodate the item, promoting a more balanced packing.
    It also dynamically scales priorities based on the item size relative to bin capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # --- Component 1: Tight Fitting (similar to v1) ---
    # Prioritize bins that leave less remaining capacity after packing
    remaining_after_packing = bins_remain_cap[can_fit_mask] - item
    tight_fit_scores = 1.0 / (remaining_after_packing + epsilon)

    # --- Component 2: Nearly Full Preference ---
    # Prioritize bins that are already quite full (but can still fit the item)
    # This encourages using up existing partially filled bins more effectively.
    # We use a negative value of remaining capacity, scaled inversely.
    # Bins with less remaining capacity get a higher score here.
    nearly_full_scores = 1.0 / (bins_remain_cap[can_fit_mask] + epsilon)


    # --- Component 3: Dynamic Scaling ---
    # Scale the influence of the "tight fitting" component based on item size relative to typical bin capacity.
    # If the item is large relative to bin capacity, tight fitting is more critical.
    # If the item is small, slightly fuller bins might be more beneficial overall.
    # We can use the ratio of the item size to the average remaining capacity of *all* bins.
    avg_remain_cap_all = np.mean(bins_remain_cap)
    if avg_remain_cap_all > epsilon:
        tight_fit_weight = min(1.0, item / avg_remain_cap_all) # Weight increases with item size relative to average
    else:
        tight_fit_weight = 1.0

    # Combine scores: weighted sum of tight fitting and nearly full preference
    combined_scores = (tight_fit_weight * tight_fit_scores) + ((1 - tight_fit_weight) * nearly_full_scores)

    # Assign the combined scores to the appropriate bins
    priorities[can_fit_mask] = combined_scores

    # Normalize priorities: Ensure the highest priority is 1.0 for clear selection
    max_priority = np.max(priorities)
    if max_priority > epsilon:
        priorities /= max_priority

    return priorities
```
