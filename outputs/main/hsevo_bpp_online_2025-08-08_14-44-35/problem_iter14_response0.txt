```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with a dynamic utilization bonus and adaptive exploration.
    Prioritizes bins that minimize waste, are less utilized, and explores promising options.
    """

    epsilon = 1e-9
    exploration_prob = 0.10  # Slightly reduced exploration for more exploitation focus

    can_fit_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if not np.any(can_fit_mask):
        return priorities

    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]
    valid_bin_indices = np.where(can_fit_mask)[0]

    # --- Heuristic Component 1: Tightest Fit ---
    # Score is inversely proportional to remaining capacity after packing.
    remaining_after_packing = valid_bins_remain_cap - item
    tight_fit_scores = 1.0 / (remaining_after_packing + epsilon)

    # --- Heuristic Component 2: Dynamic Utilization Bonus ---
    # Reward bins that are less utilized (more empty space).
    # Bonus is higher for bins with significantly larger remaining capacities.
    # This encourages spreading items but also considers bins that are mostly empty.
    # Using a logistic function to smoothly penalize larger remaining capacities.
    utilization_bonus = 0.5 * (1.0 - 1.0 / (1.0 + np.exp(-(valid_bins_remain_cap - np.mean(valid_bins_remain_cap)) / np.std(valid_bins_remain_cap + epsilon))))

    # Combine exploitation scores: multiplicative approach balances both objectives.
    combined_exploitation_scores = tight_fit_scores * (1.0 + utilization_bonus)

    # Normalize exploitation scores to be between 0 and 1 for consistent weighting.
    max_exploitation_score = np.max(combined_exploitation_scores)
    if max_exploitation_score > epsilon:
        normalized_exploitation_scores = combined_exploitation_scores / max_exploitation_score
    else:
        normalized_exploitation_scores = np.zeros_like(combined_exploitation_scores)

    # --- Adaptive Exploration (Epsilon-Greedy Variant) ---
    # With a probability `exploration_prob`, select a random fitting bin.
    # Otherwise, select based on the exploitation scores.
    exploration_mask = np.random.rand(len(valid_bins_remain_cap)) < exploration_prob
    
    # For exploration, assign a uniform high score to randomly chosen bins.
    # For exploitation, use the calculated combined scores.
    final_scores_unnormalized = np.zeros_like(normalized_exploitation_scores)
    
    num_fitting_bins = len(valid_bins_remain_cap)
    
    if num_fitting_bins > 0:
        # Randomly select a subset of bins for exploration boost
        num_explore_bins = max(1, int(np.floor(exploration_prob * num_fitting_bins))) # At least one bin if possible
        explore_indices_in_valid = np.random.choice(num_fitting_bins, size=num_explore_bins, replace=False)
        
        # Assign a high exploration score to these randomly chosen bins
        final_scores_unnormalized[explore_indices_in_valid] = 1.0
        
        # For bins not selected for explicit exploration boost, use their exploitation scores.
        # Add a small constant to exploitation scores to ensure they are still considered.
        exploitation_indices_in_valid = np.where(~np.isin(np.arange(num_fitting_bins), explore_indices_in_valid))[0]
        final_scores_unnormalized[exploitation_indices_in_valid] = normalized_exploitation_scores[exploitation_indices_in_valid] * 0.8 # Slightly reduce exploitation to favor exploration boost if scores are close


    # Ensure all priorities are non-negative.
    final_scores_unnormalized[final_scores_unnormalized < 0] = 0

    # Normalize the final scores to sum to 1 for the bins that can fit the item.
    sum_final_scores = np.sum(final_scores_unnormalized)
    if sum_final_scores > epsilon:
        priorities[can_fit_mask] = final_scores_unnormalized / sum_final_scores
    elif num_fitting_bins > 0:
        # Fallback to uniform probability if all scores are zero or negative sum
        priorities[can_fit_mask] = 1.0 / num_fitting_bins
        
    return priorities
```
