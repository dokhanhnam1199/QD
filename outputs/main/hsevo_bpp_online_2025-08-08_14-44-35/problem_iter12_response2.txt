```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_fill_ratios: np.ndarray, item_size_distribution: np.ndarray, bin_utilization_history: np.ndarray, exploration_rate: float = 0.1) -> np.ndarray:
    """
    Combines multiple strategies for bin selection in online Bin Packing Problem.
    It prioritizes bins based on:
    1. Tightness of fit (Best Fit): Minimizes wasted space in the chosen bin.
    2. Bin utilization: Prefers bins that are already relatively full to avoid
       creating many partially filled bins.
    3. Item size distribution similarity: Tries to match items to bins that
       have historically accommodated similar sized items well (a form of
       context-awareness).
    4. Adaptive exploration: With a certain probability, it picks a random
       suitable bin to explore different packing configurations.

    Args:
        item: The size of the current item to be packed.
        bins_remain_cap: A numpy array where each element is the remaining
                         capacity of a bin.
        bin_fill_ratios: A numpy array representing the current fill ratio
                         (item_size / bin_capacity) for each bin.
        item_size_distribution: A numpy array representing the historical
                                 distribution of item sizes (e.g., a histogram
                                 or density estimate). This is a simplified
                                 representation; a more complex model could be used.
        bin_utilization_history: A numpy array storing the historical
                                 utilization of each bin (e.g., average fill ratio).
        exploration_rate: The probability of choosing a random suitable bin.

    Returns:
        A numpy array of priority scores for each bin. Higher score means higher priority.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins, dtype=float)

    suitable_bins_mask = bins_remain_cap >= item
    suitable_bins_indices = np.where(suitable_bins_mask)[0]

    if suitable_bins_indices.size == 0:
        return priorities

    # Normalize factors to combine them effectively
    # Factor 1: Tightness of fit (inverse of gap)
    gaps = bins_remain_cap[suitable_bins_indices] - item
    # Avoid division by zero if gap is zero; assign a very high value
    tightness_scores = np.where(gaps == 0, np.max(gaps[gaps > 0]) + 1, gaps)
    tightness_scores = 1.0 / tightness_scores
    # Normalize tightness scores
    if np.sum(tightness_scores) > 0:
        tightness_scores /= np.sum(tightness_scores)
    else:
        tightness_scores = np.ones_like(tightness_scores) / len(tightness_scores)


    # Factor 2: Bin fill ratio (prefer fuller bins)
    fill_ratios_suitable = bin_fill_ratios[suitable_bins_indices]
    # Normalize fill ratios
    if np.sum(fill_ratios_suitable) > 0:
        fill_ratios_suitable /= np.sum(fill_ratios_suitable)
    else:
        fill_ratios_suitable = np.ones_like(fill_ratios_suitable) / len(fill_ratios_suitable)


    # Factor 3: Item size distribution similarity (simplified: match to bins that have seen similar items)
    # This is a placeholder. A real implementation might use a more sophisticated model.
    # Here, we'll assume item_size_distribution is a proxy for how well bins
    # might fit certain item sizes. We'll give higher priority to bins that have
    # historically handled items of similar size.
    # For simplicity, let's assume item_size_distribution is already weighted by bin.
    # If not, a mapping would be needed.
    # Let's assume item_size_distribution is a flattened preference across all bins.
    # A more accurate way would be to have a matrix where item_size_dist[bin_idx, item_size_category]
    # For this example, let's assume item_size_distribution represents a preference score
    # for current item size across all bins.
    item_distribution_scores = item_size_distribution[suitable_bins_indices]
    if np.sum(item_distribution_scores) > 0:
        item_distribution_scores /= np.sum(item_distribution_scores)
    else:
        item_distribution_scores = np.ones_like(item_distribution_scores) / len(item_distribution_scores)

    # Combine factors using weights (can be tuned)
    # Weights can be learned or set based on domain knowledge.
    w_tightness = 0.4
    w_fill_ratio = 0.3
    w_distribution = 0.3

    combined_scores_suitable = (
        w_tightness * tightness_scores +
        w_fill_ratio * fill_ratios_suitable +
        w_distribution * item_distribution_scores
    )

    # Adaptive exploration
    if np.random.rand() < exploration_rate:
        # Pick a random suitable bin
        chosen_bin_index = np.random.choice(suitable_bins_indices)
        priorities[chosen_bin_index] = 1.0
    else:
        # Exploitation: Assign priorities based on combined scores
        # Ensure no negative scores and normalize to create a probability distribution
        # (though we only care about relative order for max)
        normalized_combined_scores = combined_scores_suitable - np.min(combined_scores_suitable)
        if np.sum(normalized_combined_scores) > 0:
            normalized_combined_scores /= np.sum(normalized_combined_scores)
        else:
            normalized_combined_scores = np.ones_like(normalized_combined_scores) / len(normalized_combined_scores)

        # Assign the calculated scores to the appropriate bins
        priorities[suitable_bins_indices] = normalized_combined_scores
        # Optionally, to mimic "highest priority score", we can just set the max
        # to 1 and others proportionally, or just use the scores as they are.
        # Let's set the max score to 1 for clarity if we want to identify the 'best'.
        if suitable_bins_indices.size > 0:
            max_idx_in_suitable = np.argmax(priorities[suitable_bins_indices])
            best_bin_original_idx = suitable_bins_indices[max_idx_in_suitable]
            # Reset priorities to a simple indicator for the best bin
            priorities = np.zeros_like(bins_remain_cap, dtype=float)
            priorities[best_bin_original_idx] = 1.0


    return priorities

```
