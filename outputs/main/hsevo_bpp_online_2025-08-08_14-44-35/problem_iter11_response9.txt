```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit and adaptive utilization, with dynamic exploration
    favoring less utilized bins for better overall packing.
    """
    epsilon = 1e-9
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    fitting_bins_indices = np.where(can_fit_mask)[0]
    fitting_bins_capacities = bins_remain_cap[fitting_bins_indices]

    # --- Heuristic Component 1: Tightest Fit ---
    # Prioritize bins that leave minimal remaining capacity after packing.
    remaining_after_packing = fitting_bins_capacities - item
    # Score is inversely proportional to the remaining gap, encouraging tighter fits.
    tight_fit_scores = 1.0 / (remaining_after_packing + epsilon)

    # --- Heuristic Component 2: Utilization Weighting ---
    # Prefer bins that are currently less utilized (more empty space).
    # This aims to balance utilization across bins.
    max_total_capacity = np.max(bins_remain_cap) if bins_remain_cap.size > 0 else 0
    # If all bins are empty or have very little capacity, treat max_total_capacity carefully.
    if max_total_capacity < epsilon:
        max_total_capacity = 1.0 # Avoid division by zero if bins are very small

    # Calculate utilization score: higher for bins with more *absolute* remaining space.
    # This is a proxy for less utilized bins.
    utilization_scores = fitting_bins_capacities / (max_total_capacity + epsilon)

    # --- Combine Exploitation Scores ---
    # Combine tight fit and utilization scores. A weighted sum is used.
    # The weights can be tuned, here we give equal importance.
    exploitation_scores = 0.5 * tight_fit_scores + 0.5 * utilization_scores

    # Normalize exploitation scores to be between 0 and 1.
    max_exploitation_score = np.max(exploitation_scores)
    if max_exploitation_score > epsilon:
        normalized_exploitation_scores = exploitation_scores / max_exploitation_score
    else:
        normalized_exploitation_scores = np.zeros_like(exploitation_scores)

    # --- Adaptive Exploration ---
    # Introduce exploration by randomly selecting some fitting bins and boosting their scores.
    num_fitting_bins = len(fitting_bins_indices)
    
    # Exploration probability adapts: higher if few options, lower if many.
    if num_fitting_bins <= 2:
        exploration_prob = 0.3  # More exploration when options are scarce
    elif num_fitting_bins > 5:
        exploration_prob = 0.1  # Less exploration when many options exist
    else:
        exploration_prob = 0.2  # Moderate exploration

    # Determine how many bins to explore.
    num_to_explore = max(1, int(np.floor(exploration_prob * num_fitting_bins)))
    
    # Ensure we don't try to explore more bins than available.
    num_to_explore = min(num_to_explore, num_fitting_bins)

    # Select random indices from the fitting bins for exploration.
    explore_indices_in_fitting = np.random.choice(num_fitting_bins, size=num_to_explore, replace=False)

    # Create exploration bonuses. These are added to the exploitation scores.
    # Bins selected for exploration get a significant boost.
    exploration_bonuses = np.zeros_like(normalized_exploitation_scores)
    exploration_bonuses[explore_indices_in_fitting] = 1.0 # High bonus for exploration bins

    # --- Final Priority Calculation ---
    # Combine exploitation and exploration scores.
    final_scores = normalized_exploitation_scores + exploration_bonuses

    # Assign final priorities to the original bin indices.
    priorities[fitting_bins_indices] = final_scores

    # Normalize all priorities so they sum to 1, effectively becoming probabilities.
    sum_priorities = np.sum(priorities)
    if sum_priorities > epsilon:
        priorities /= sum_priorities
    else:
        # Fallback: if all scores are zero, assign uniform probability to fitting bins.
        if num_fitting_bins > 0:
            priorities[fitting_bins_indices] = 1.0 / num_fitting_bins

    return priorities
```
