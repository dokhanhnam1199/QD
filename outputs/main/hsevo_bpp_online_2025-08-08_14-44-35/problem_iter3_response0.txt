```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using an adaptive
    strategy that balances tight fitting with utilizing bins that are nearly full.
    This version aims for better performance by considering both the immediate
    benefit of tight packing and the long-term strategy of keeping larger bins
    available.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate remaining capacity after packing the item for bins that can fit
    remaining_after_packing = bins_remain_cap[can_fit_mask] - item
    
    # --- Heuristic Design Principles ---
    # 1. Adaptive Exploration: Dynamically adjust priorities.
    # 2. Multi-objective Balancing: Combine "tight fit" with "prefer nearly full".
    # 3. Dynamic Scaling: Use scaling factors based on context.
    
    # Objective 1: Encourage tight packing (similar to v1)
    # Higher priority for bins that leave less remaining space.
    # Add a small epsilon to avoid division by zero.
    epsilon = 1e-9
    tight_fit_score = 1.0 / (remaining_after_packing + epsilon)
    
    # Objective 2: Prefer bins that are already somewhat full but still have space.
    # This helps in consolidating items and potentially leaving larger bins open for larger items.
    # The score is higher for bins with less remaining capacity *before* packing.
    # We use a sigmoid-like function to give a boost to bins that are moderately filled,
    # not too empty and not completely full.
    # A simple approach is to use inverse of current remaining capacity, but cap it.
    # Let's normalize the current remaining capacity for bins that can fit the item.
    normalized_current_remain_cap = bins_remain_cap[can_fit_mask] / np.max(bins_remain_cap[can_fit_mask] + epsilon) # Normalize by max capacity to keep it within [0, 1]
    nearly_full_score = 1.0 - normalized_current_remain_cap # Higher score for smaller remaining capacity

    # Combine scores. We can use a weighted sum.
    # The weights can be thought of as dynamic parameters or set based on observed performance.
    # For this example, let's give a slight preference to tight fitting, but also reward
    # using bins that are already somewhat utilized.
    
    # Let's assign a weight to each objective.
    # weight_tight_fit = 0.7
    # weight_nearly_full = 0.3

    # A more adaptive approach: The preference for tight fit vs. using a nearly full bin
    # could depend on the item size itself. Smaller items might benefit more from tight fitting,
    # while larger items might benefit from using bins that are already somewhat full to keep
    # larger empty bins available.

    # Let's scale the item size relative to the maximum bin capacity available.
    max_possible_capacity = np.max(bins_remain_cap[can_fit_mask]) if np.any(can_fit_mask) else 1.0
    relative_item_size = item / (max_possible_capacity + epsilon)
    
    # Dynamic weighting:
    # If item is small (relative_item_size < 0.5), favor tight fit more.
    # If item is large (relative_item_size >= 0.5), favor using nearly full bins more.
    weight_tight_fit = 0.4 + 0.6 * (1.0 - relative_item_size) # Range: [0.4, 1.0]
    weight_nearly_full = 0.6 + 0.4 * relative_item_size      # Range: [0.6, 1.0]
    # Ensure weights sum to 1 (approximately, due to scaling factors)
    total_weight = weight_tight_fit + weight_nearly_full
    weight_tight_fit /= total_weight
    weight_nearly_full /= total_weight
    

    combined_score = (weight_tight_fit * tight_fit_score) + (weight_nearly_full * nearly_full_score)

    # Assign the combined scores to the bins that can fit the item
    priorities[can_fit_mask] = combined_score
    
    # Normalize priorities to have a maximum of 1.0. This makes comparisons relative.
    if np.max(priorities) > 0:
        priorities /= np.max(priorities)
        
    return priorities
```
