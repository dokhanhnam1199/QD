import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.12019220907004902) -> np.ndarray:
    """
    Combines Best Fit (tightest fit) with an epsilon-greedy exploration strategy.
    Prioritizes bins that leave the smallest remaining capacity after packing,
    with a small chance of picking any suitable bin to encourage exploration.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item
    suitable_bins_indices = np.where(suitable_bins_mask)[0]

    if suitable_bins_indices.size == 0:
        return priorities  # No bin can fit the item

    # Exploration phase: with probability epsilon, pick a random suitable bin
    if np.random.rand() < epsilon:
        chosen_bin_index = np.random.choice(suitable_bins_indices)
        priorities[chosen_bin_index] = 1.0
    else:
        # Exploitation phase: Best Fit strategy
        suitable_bins_capacities = bins_remain_cap[suitable_bins_indices]
        # Calculate the 'gap' or remaining capacity after fitting the item
        gaps = suitable_bins_capacities - item
        
        # Find the index within the 'suitable_bins_indices' array that has the minimum gap
        best_fit_in_suitable_idx = np.argmin(gaps)
        # Get the original index of this best-fitting bin
        best_fit_original_idx = suitable_bins_indices[best_fit_in_suitable_idx]
        priorities[best_fit_original_idx] = 1.0

    return priorities
