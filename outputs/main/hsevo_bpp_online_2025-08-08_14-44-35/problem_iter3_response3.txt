```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a hybrid strategy.
    It balances the tendency to fill bins tightly (similar to v1) with a preference
    for bins that have a larger capacity to accommodate potentially larger future items.
    It also introduces an adaptive component that favors bins that have been utilized
    more (i.e., have less remaining capacity overall, but can still fit the current item),
    promoting a more balanced distribution.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Filter to only consider bins that can fit the item
    available_bins_remain_cap = bins_remain_cap[can_fit_mask]

    if available_bins_remain_cap.size == 0:
        return priorities

    # Component 1: Tighter Packing (similar to v1)
    # Higher priority for bins that leave less remaining capacity after packing.
    remaining_after_packing = available_bins_remain_cap - item
    tight_packing_score = 1.0 / (remaining_after_packing + epsilon)

    # Component 2: Future Accommodation (preference for larger bins)
    # Higher priority for bins with more capacity, even after fitting the item.
    # This can be useful if we anticipate larger items later.
    future_accommodation_score = available_bins_remain_cap

    # Component 3: Adaptive Bin Utilization (promotes balanced loading)
    # Bins with less total remaining capacity (meaning they have been used more)
    # might be preferred to distribute items more evenly, preventing some bins
    # from staying almost empty for too long. We invert the remaining capacity.
    # To avoid very small values causing issues, we can use a base capacity
    # (e.g., max possible bin capacity or average capacity) for normalization.
    # For simplicity here, we'll use the maximum remaining capacity among available bins.
    max_remaining_among_available = np.max(available_bins_remain_cap)
    adaptive_utilization_score = (max_remaining_among_available - available_bins_remain_cap + epsilon) / (max_remaining_among_available + epsilon)


    # Combine the scores. We can use weighted sums.
    # Weights can be tuned. Here we give a slight preference to tighter packing
    # and balanced utilization.
    weight_tight = 0.4
    weight_future = 0.2
    weight_adaptive = 0.4

    combined_score = (weight_tight * tight_packing_score +
                      weight_future * future_accommodation_score +
                      weight_adaptive * adaptive_utilization_score)

    # Normalize the combined scores for the available bins
    if np.max(combined_score) > 0:
        normalized_combined_score = combined_score / np.max(combined_score)
    else:
        normalized_combined_score = np.zeros_like(combined_score)

    # Place the normalized scores back into the original priorities array
    priorities[can_fit_mask] = normalized_combined_score

    return priorities
```
