```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines the tight-fitting priority of inverse remaining capacity
    with an epsilon-greedy exploration strategy for better bin packing.
    """
    epsilon = 0.1  # Probability of exploring a random bin

    # Calculate priorities based on tightest fit (inverse remaining capacity)
    # Only consider bins that can fit the item
    fit_mask = bins_remain_cap >= item
    tight_fit_priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Add a small epsilon to avoid division by zero if remaining capacity == item
    valid_capacities = bins_remain_cap[fit_mask] - item + 1e-9
    tight_fit_priorities[fit_mask] = 1.0 / valid_capacities

    # Normalize priorities so they sum to 1 (if no exploration)
    sum_priorities = np.sum(tight_fit_priorities)
    if sum_priorities > 0:
        normalized_priorities = tight_fit_priorities / sum_priorities
    else:
        # If no bins can fit the item, assign equal probability to all (effectively a new bin)
        normalized_priorities = np.ones_like(bins_remain_cap) / len(bins_remain_cap)

    # Epsilon-greedy: explore randomly with probability epsilon
    exploration_priorities = np.ones_like(bins_remain_cap) / len(bins_remain_cap)
    
    # Combine exploitation (tight fit) and exploration (random)
    # With probability (1 - epsilon), choose the tight fit priority
    # With probability epsilon, choose the exploration priority
    combined_priorities = (1 - epsilon) * normalized_priorities + epsilon * exploration_priorities

    # Ensure probabilities sum to 1 (due to potential floating point inaccuracies or edge cases)
    final_priorities = combined_priorities / np.sum(combined_priorities)

    return final_priorities
```
