```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Softmax-Based Fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_remain_cap]

    if not valid_bins_remain_cap.size:
        return np.zeros_like(bins_remain_cap)

    # Calculate the "fit" metric: remaining capacity after placing the item
    fits = valid_bins_remain_cap - item

    # Use a Softmax-like function to convert fits into priorities.
    # We want higher fits (more remaining capacity) to have higher priority.
    # Adding a small epsilon to avoid numerical issues with exp(0) if all fits are 0.
    # Scaling by a factor (e.g., 10) can make the differences more pronounced.
    scaled_fits = fits * 10.0
    exp_fits = np.exp(scaled_fits)
    priorities = exp_fits / np.sum(exp_fits)

    # Create the final priorities array, placing calculated priorities in valid bin slots
    final_priorities = np.zeros_like(bins_remain_cap)
    final_priorities[valid_bins_remain_cap >= item] = priorities

    return final_priorities
```
