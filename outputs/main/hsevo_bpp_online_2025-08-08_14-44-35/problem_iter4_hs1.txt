import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.29847982827807745, epsilon_value: float = 7.300748402017856e-07) -> np.ndarray:
    """
    Combines the tight-fitting priority of inverse remaining capacity
    with an epsilon-greedy exploration strategy for better bin packing.

    Args:
        item (float): The item to be packed.
        bins_remain_cap (np.ndarray): An array of remaining capacities for each bin.
        epsilon (float): Probability of exploring a random bin. Defaults to 0.1.
        epsilon_value (float): A small value added to avoid division by zero. Defaults to 1e-9.

    Returns:
        np.ndarray: An array of probabilities for packing the item into each bin.
    """
    # Calculate priorities based on tightest fit (inverse remaining capacity)
    # Only consider bins that can fit the item
    fit_mask = bins_remain_cap >= item
    tight_fit_priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Add a small epsilon to avoid division by zero if remaining capacity == item
    valid_capacities = bins_remain_cap[fit_mask] - item + epsilon_value
    tight_fit_priorities[fit_mask] = 1.0 / valid_capacities

    # Normalize priorities so they sum to 1 (if no exploration)
    sum_priorities = np.sum(tight_fit_priorities)
    if sum_priorities > 0:
        normalized_priorities = tight_fit_priorities / sum_priorities
    else:
        # If no bins can fit the item, assign equal probability to all (effectively a new bin)
        normalized_priorities = np.ones_like(bins_remain_cap) / len(bins_remain_cap)

    # Epsilon-greedy: explore randomly with probability epsilon
    exploration_priorities = np.ones_like(bins_remain_cap) / len(bins_remain_cap)
    
    # Combine exploitation (tight fit) and exploration (random)
    # With probability (1 - epsilon), choose the tight fit priority
    # With probability epsilon, choose the exploration priority
    combined_priorities = (1 - epsilon) * normalized_priorities + epsilon * exploration_priorities

    # Ensure probabilities sum to 1 (due to potential floating point inaccuracies or edge cases)
    final_priorities = combined_priorities / np.sum(combined_priorities)

    return final_priorities
