```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines a multi-objective approach with adaptive behavior.
    Prioritizes bins based on a weighted sum of criteria:
    1. Tightest fit (minimizing remaining capacity after packing).
    2. Bin fullness (maximizing current bin utilization, which indirectly
       encourages opening new bins for larger items).
    3. A penalty for bins that are too full and might cause immediate
       overflow for slightly larger items (encouraging better distribution).

    The weights are adaptive, favoring tighter fits when bins are abundant
    and fuller bins when capacity is scarce.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item
    suitable_bins_indices = np.where(suitable_bins_mask)[0]

    if suitable_bins_indices.size == 0:
        return priorities

    suitable_bins_capacities = bins_remain_cap[suitable_bins_indices]

    # Criteria calculation for suitable bins
    # 1. Tightest Fit (lower is better, so we invert for priority)
    gaps = suitable_bins_capacities - item
    tightness_score = 1.0 / (gaps + 1e-6) # Add small epsilon to avoid division by zero

    # 2. Bin Fullness (higher is better)
    # Assuming bin_remain_cap represents remaining capacity of TOTAL capacity.
    # We need total capacity for fullness. For simplicity, let's assume a common max capacity.
    # In a real scenario, this would be passed or inferred.
    # Let's assume a default max capacity if not provided.
    # For this example, let's derive a plausible max capacity from the data if possible,
    # or use a large number as a proxy if only remaining capacities are available.
    # A more robust approach would involve passing the bin's total capacity.
    # For demonstration, we'll consider the average remaining capacity as a proxy indicator.
    # A better proxy for fullness, given only remaining capacity, is how much *space* is left
    # relative to what has been used. Since we don't know total capacity directly,
    # we can indirectly infer fullness by how much capacity is REMAINING.
    # A smaller remaining capacity implies a fuller bin. So, we'll use the inverse of remaining capacity.
    # However, the prompt is about 'bin fullness', implying usage.
    # If we only have remaining capacity, we can't directly calculate fullness.
    # Let's re-interpret "bin fullness" in the context of remaining capacity:
    # A bin is "fuller" if it has *less* remaining capacity.
    # So, higher fullness is associated with *lower* remaining capacity.
    # We want to prioritize bins with less remaining capacity (if they can fit the item).
    # So, we want to maximize `1 / bins_remain_cap`.
    # However, we are only considering `suitable_bins_capacities`, which are >= item.
    # Let's consider a different interpretation: priority should be given to bins that are "almost full"
    # in the sense that they have a good amount of remaining space, but not too much.
    # A simple measure for "good" remaining space might be related to the item size itself.
    # Let's consider how "well" the item fits into the remaining space.
    # A bin that can accommodate the item with a moderate amount of remaining capacity might be good.
    # Let's try to prioritize bins that have capacity CLOSE to the item size, but not necessarily the tightest.
    # This could be represented by the absolute difference between remaining capacity and item size,
    # but we want to favor bins with *more* remaining capacity to avoid fragmentation initially.
    # Let's try maximizing remaining capacity among suitable bins, as a proxy for "not too full".
    fullness_score = suitable_bins_capacities

    # 3. Penalty for being too full (lower is better, so invert for priority)
    # If remaining capacity is very small, it's good for tight fit but bad for future items.
    # Let's penalize bins with very little remaining capacity *after* fitting the item.
    # This is related to the gap, but we want to avoid bins that are *almost* full.
    # A small gap is good (tight fit), but if the gap is extremely small (e.g., < item/4),
    # it might be detrimental.
    # Let's define a "too full" threshold. If remaining_capacity - item < some_fraction_of_item,
    # apply a penalty.
    too_full_penalty = np.zeros_like(suitable_bins_capacities)
    # Consider bins where remaining capacity is less than 2 times the item size as potentially "too full"
    # if they still have substantial space left. This is tricky.
    # Let's simplify: penalize bins with very small remaining capacity BEFORE fitting the item.
    # This would mean bins that are already quite full.
    # If `bins_remain_cap` is small, it's "full". We want to avoid picking these if possible,
    # UNLESS they are the tightest fit.
    # Let's rethink: the goal is to minimize the number of bins.
    # So, we want to utilize existing bins effectively.

    # Let's consider a score that balances:
    # 1. Maximizing the remaining capacity AFTER packing (to leave space for future items).
    # 2. Minimizing the number of bins used (by packing tightly).

    # Revised strategy:
    # Focus on using existing bins efficiently.
    # The "best fit" is often good. What if we also consider bins that have
    # *just enough* space for the current item, but not too much excess?
    # This could be measured by how close `bins_remain_cap` is to `item`.
    # So, we want to maximize `bins_remain_cap` minus `item`, but only for suitable bins.
    # Or, minimize `bins_remain_cap` among suitable bins. This is Best Fit.

    # What if we add a term that favors bins that have a "good amount" of remaining space
    # *after* packing? This would be `bins_remain_cap[i] - item`.
    # We want to maximize this value.
    # So, we have two conflicting goals for suitable bins:
    # - Minimize `bins_remain_cap[i] - item` (tightest fit)
    # - Maximize `bins_remain_cap[i] - item` (leave more space)

    # Let's try a heuristic that favors bins that have a remaining capacity
    # that is "just enough" for the item, or slightly more.
    # This means we want to find a bin where `bins_remain_cap` is close to `item`.
    # The gap `bins_remain_cap - item` should be small, but not necessarily zero.
    # We want to maximize `-(gap)^2` or minimize `(gap)^2`. This is Best Fit.

    # Let's consider a different approach inspired by "First Fit Decreasing" idea,
    # but for online. We want to use bins that are "most appropriate".
    # A bin is "most appropriate" if it can fit the item and also has
    # significant remaining capacity to potentially fit other items.
    # This suggests prioritizing bins that are not too full.
    # So, among suitable bins, we want to maximize `bins_remain_cap`.

    # Combining Best Fit (minimizing gap) and Maximize Remaining Capacity:
    # Let's prioritize bins that have the smallest gap AND then, among those with the same gap,
    # pick the one with the largest remaining capacity (which is the same bin).
    # This doesn't add much.

    # What if we prioritize bins that have *just enough* capacity?
    # Consider the ratio: `item / bins_remain_cap[i]`. We want this ratio to be close to 1.
    # Or, `bins_remain_cap[i] / item`. We want this ratio to be close to 1.
    # Maximize `bins_remain_cap[i] / item` among suitable bins.

    # Let's try a multi-objective weighted sum.
    # Objective 1: Maximize (remaining_capacity - item) --> leave more space.
    # Objective 2: Minimize (remaining_capacity - item) --> tightest fit.

    # If we want to maximize space left, we pick the largest `bins_remain_cap` that fits.
    # If we want to minimize waste, we pick the smallest `bins_remain_cap` that fits.

    # Let's define a score that is a combination of these.
    # A simple heuristic could be to prioritize bins that are "moderately" full.
    # This means they have enough capacity for the item, but not an excessive amount.
    # So, we are looking for `bins_remain_cap[i]` such that `item <= bins_remain_cap[i] < some_threshold`.
    # And among these, maybe we want the smallest `bins_remain_cap[i]`? (Best Fit).

    # Let's consider the "slack" or `bins_remain_cap[i] - item`.
    # We want this slack to be small (Best Fit).
    # However, we also want to avoid putting items into bins that are ALMOST full,
    # because the next item might not fit.
    # So, let's penalize bins where `bins_remain_cap[i]` is very close to `item`.

    # Let's try a score that penalizes bins that are too full *after* packing.
    # `bins_remain_cap[i] - item` should not be too small.
    # So, let's maximize `bins_remain_cap[i] - item`. This is the opposite of Best Fit.

    # How about we combine Best Fit with a "Next Fit" like behavior,
    # favoring bins that are currently "open" and have sufficient space.
    # The "openness" can be proxied by how much capacity is available.

    # Let's try prioritizing bins that have a remaining capacity that is
    # *just enough* for the item.
    # This means `bins_remain_cap[i]` is close to `item`.
    # We can measure this by `1 / abs(bins_remain_cap[i] - item + epsilon)`
    # but this would prioritize exact fits.

    # Let's use a weighted combination of Best Fit and a measure of "good capacity".
    # Score = w1 * (BestFitScore) + w2 * (GoodCapacityScore)

    # Best Fit Score (minimize gap): higher value for smaller gap.
    # We want to maximize `1 / (gap + epsilon)`
    best_fit_priority = 1.0 / (gaps + 1e-6)

    # Good Capacity Score: We want bins that have "enough" space, but not excessive.
    # This is hard to define without knowing the distribution of item sizes.
    # Let's consider favoring bins that have a good amount of remaining capacity,
    # so they can potentially fit more items later.
    # This would mean maximizing `bins_remain_cap[i]`.
    good_capacity_priority = suitable_bins_capacities

    # Adaptive weights:
    # If bins are scarce (many items, few bins), we want to be more aggressive with tight fits.
    # If bins are abundant (few items, many bins), we can afford to leave more space.
    # Let's use the total number of bins used so far as a proxy for scarcity.
    # However, we don't have the total number of bins.
    # Let's use the number of available suitable bins as a proxy for how "easy" it is to find a fit.
    # If `len(suitable_bins_indices)` is small, we are in a tighter situation.

    num_suitable = len(suitable_bins_indices)
    # If few suitable bins, prioritize tightest fit more.
    # If many suitable bins, prioritize having more remaining space.
    if num_suitable > 0:
        # Weight for Best Fit: increases as number of suitable bins decreases
        w_best_fit = 2.0 / (num_suitable + 1)
        # Weight for Good Capacity: increases as number of suitable bins increases
        w_good_capacity = num_suitable / (num_suitable + 1)
    else:
        w_best_fit = 0.5
        w_good_capacity = 0.5

    # Combined score for each suitable bin
    # We want to maximize the combined score.
    combined_scores = w_best_fit * best_fit_priority + w_good_capacity * good_capacity_priority

    # Normalize scores to be between 0 and 1 for easier interpretation if needed,
    # but for argmax it's not strictly necessary.
    # Let's find the index corresponding to the maximum combined score.
    if combined_scores.size > 0:
        best_fit_in_suitable_idx = np.argmax(combined_scores)
        best_fit_original_idx = suitable_bins_indices[best_fit_in_suitable_idx]
        priorities[best_fit_original_idx] = 1.0

    return priorities

```
