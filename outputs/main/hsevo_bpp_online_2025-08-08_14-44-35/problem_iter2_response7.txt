```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins by inverse remaining capacity with adaptive exploration.

    Combines the tight-fit preference of inverse remaining capacity with
    a controlled exploration mechanism similar to epsilon-greedy.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_capacities = bins_remain_cap[valid_bins_mask]

    if valid_bins_capacities.size > 0:
        # Primary heuristic: Prioritize bins with tighter fits (inverse remaining capacity)
        inverse_distances = 1.0 / (bins_remain_cap[valid_bins_mask] - item + 1e-9)
        priorities[valid_bins_mask] = inverse_distances

        # Adaptive exploration: Introduce a small probability of choosing a non-best fit
        # This helps prevent getting stuck in local optima.
        # The exploration probability can be tuned. Here, we use a small fixed probability.
        exploration_prob = 0.05
        num_valid_bins = valid_bins_capacities.size
        
        if num_valid_bins > 1:
            # Randomly select a subset of valid bins to give a small boost,
            # simulating exploration. This is a simplified epsilon-greedy approach.
            exploration_indices_in_valid = np.random.choice(num_valid_bins, 
                                                          size=max(1, int(num_valid_bins * exploration_prob)), 
                                                          replace=False)
            
            # Get the actual indices in the original bins_remain_cap array
            exploration_indices_in_original = np.where(valid_bins_mask)[0][exploration_indices_in_valid]
            
            # Add a small, uniform boost to these bins to make them potentially selectable
            # even if they are not the absolute tightest fit.
            priorities[exploration_indices_in_original] += 1e-6 # A small boost

    return priorities
```
