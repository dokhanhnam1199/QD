```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Inverse Distance with an epsilon-greedy strategy for exploration.

    Prioritizes bins with a tighter fit (less waste) while occasionally
    exploring other bins to avoid local optima.
    """
    available_bins_mask = bins_remain_cap >= item
    available_bins_cap = bins_remain_cap[available_bins_mask]

    if available_bins_cap.size == 0:
        return np.zeros_like(bins_remain_cap)

    waste = available_bins_cap - item
    priorities = 1.0 / (waste + 1e-9)

    full_priorities = np.zeros_like(bins_remain_cap)
    full_priorities[available_bins_mask] = priorities

    epsilon = 0.1  # Exploration rate
    num_available_bins = available_bins_mask.sum()

    if num_available_bins > 0 and np.random.rand() < epsilon:
        # Randomly select an available bin for exploration
        random_indices = np.where(available_bins_mask)[0]
        random_bin_index = np.random.choice(random_indices)
        full_priorities[random_bin_index] = np.max(full_priorities) + 1.0 # Boost priority for exploration

    return full_priorities
```
