```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines the tight-fitting preference of inverse capacity with adaptive exploration.
    Prioritizes bins that offer a tighter fit, with a controlled amount of randomness
    to encourage exploration of potentially better, albeit slightly less optimal, fits.
    """
    
    priorities = np.zeros_like(bins_remain_cap)
    
    # Identify bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item
    
    suitable_bins_capacities = bins_remain_cap[suitable_bins_mask]
    
    if suitable_bins_capacities.size == 0:
        return priorities
    
    # Calculate the "gap" for suitable bins (remaining capacity after placing item)
    gaps = suitable_bins_capacities - item
    
    # Prioritize bins with smaller gaps (tighter fit). Using inverse of (1 + gap)
    # to ensure a priority score that is higher for smaller gaps.
    # Adding 1 to the denominator to avoid division by zero and a small epsilon
    # for numerical stability if gaps can be zero.
    fit_scores = 1.0 / (1.0 + gaps + 1e-9)
    
    # Introduce adaptive exploration: add a small amount of noise based on the std dev
    # of the fit scores of the suitable bins. This nudges the selection slightly
    # away from purely greedy choices, promoting exploration.
    if fit_scores.size > 0:
        std_dev_fit_scores = np.std(fit_scores)
        random_noise = np.random.normal(0, std_dev_fit_scores * 0.05, fit_scores.shape)
        priorities[suitable_bins_mask] = fit_scores + random_noise
    
    return priorities
```
