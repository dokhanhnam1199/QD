```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines tight-fit preference with adaptive exploration (epsilon-greedy).

    Prioritizes bins that minimize waste (tight fit) and introduces a
    controlled probability of choosing a random valid bin to avoid local optima.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_capacities = bins_remain_cap[valid_bins_mask]

    if valid_bins_capacities.size == 0:
        return priorities

    # Primary heuristic: Prioritize bins with tighter fits (inverse remaining capacity after packing)
    # Add a small epsilon to avoid division by zero.
    waste = valid_bins_capacities - item
    tight_fit_scores = 1.0 / (waste + 1e-9)

    # Normalize tight fit scores to be between 0 and 1
    if tight_fit_scores.max() > 0:
        normalized_tight_fit_scores = tight_fit_scores / tight_fit_scores.max()
    else:
        normalized_tight_fit_scores = np.zeros_like(tight_fit_scores)

    priorities[valid_bins_mask] = normalized_tight_fit_scores

    # Exploration: Epsilon-greedy strategy
    # With probability epsilon, choose a random valid bin; otherwise, choose the best.
    epsilon = 0.1  # Exploration rate
    num_valid_bins = valid_bins_capacities.size

    if num_valid_bins > 0 and np.random.rand() < epsilon:
        # Select a random index among the valid bins
        random_valid_index = np.random.randint(num_valid_bins)
        
        # Get the original index of this randomly chosen valid bin
        original_indices_of_valid_bins = np.where(valid_bins_mask)[0]
        random_original_index = original_indices_of_valid_bins[random_valid_index]

        # Give this randomly chosen bin a high priority to ensure it's selected
        # This is a strong boost to make it competitive with the best fit.
        priorities[random_original_index] = np.max(priorities) + 1.0 

    return priorities
```
