```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Epsilon-Greedy.

    This strategy prioritizes bins that have just enough space for the item
    (minimizing wasted space) but also considers bins that have significant
    remaining space to encourage filling them up later. The epsilon-greedy
    approach introduces randomness to explore different bin choices.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.2
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return np.zeros_like(bins_remain_cap)

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_remain_cap]

    
    exact_fit_score = 1.0 / (1.0 + np.abs(suitable_bins_remain_cap - item))
    
    large_capacity_score = suitable_bins_remain_cap / np.max(suitable_bins_remain_cap)
    
    combined_score = 0.7 * exact_fit_score + 0.3 * large_capacity_score
    
    priorities[bins_remain_cap >= item] = combined_score

    
    if np.random.rand() < epsilon:
        random_index = np.random.choice(np.where(suitable_bins_mask)[0])
        priorities = np.zeros_like(bins_remain_cap, dtype=float)
        priorities[random_index] = 1.0
    else:
        max_priority = np.max(priorities)
        priorities[priorities < max_priority] = priorities[priorities < max_priority] * 0.8

    return priorities
```
