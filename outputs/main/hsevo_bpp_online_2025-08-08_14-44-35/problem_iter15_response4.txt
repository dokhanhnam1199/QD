```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with a novel utilization bonus and adaptive exploration
    using a UCB-like approach. Prioritizes bins that minimize slack after packing,
    with a bonus for bins that have been utilized more, balanced by exploration
    to discover potentially better, less utilized bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9
    utilization_weight = 0.5  # Increased weight for utilization
    exploration_factor = 0.5  # Factor for UCB-like exploration term

    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    fitting_indices = np.where(can_fit_mask)[0]
    num_fitting_bins = len(fitting_bins_remain_cap)

    # 1. Tightest Fit: Prioritize bins that leave minimal remaining capacity.
    remaining_after_packing = fitting_bins_remain_cap - item
    tightness_score = 1.0 / (remaining_after_packing + epsilon)

    # 2. Utilization Bonus: Prefer bins that are already partially filled.
    # Calculate utilization for fitting bins. Utilization is 1 - (remaining_cap / bin_capacity).
    # For simplicity, we'll use the inverse of remaining capacity as a proxy for utilization.
    # A higher value means less remaining capacity, hence more utilized.
    utilization_proxy = 1.0 / (fitting_bins_remain_cap + epsilon)

    # Normalize tightness and utilization scores to [0, 1]
    max_tightness = np.max(tightness_score)
    normalized_tightness = tightness_score / (max_tightness + epsilon)

    max_utilization_proxy = np.max(utilization_proxy)
    normalized_utilization = utilization_proxy / (max_utilization_proxy + epsilon)

    # Combine Exploitation: Weighted sum of normalized tightness and utilization.
    # This represents the 'mean' reward.
    exploitation_score = normalized_tightness + utilization_weight * normalized_utilization

    # 3. Adaptive Exploration (UCB-like): Add an exploration bonus.
    # The exploration term encourages trying less explored (less utilized in this context) bins.
    # We can use the inverse of normalized utilization (which corresponds to more remaining capacity)
    # as a proxy for 'less explored' or 'more potential for new configurations'.
    # The exploration term is scaled by a factor to control its influence.
    # Bins with higher remaining capacity (lower utilization_proxy) will get a higher exploration score.
    exploration_score = exploration_factor * (1.0 - normalized_utilization)

    # Final Scores: Combine exploitation and exploration
    final_scores_unnormalized = exploitation_score + exploration_score

    # Normalize final scores to [0, 1] for consistent priority assignments.
    max_final_score = np.max(final_scores_unnormalized)
    if max_final_score > epsilon:
        priorities[can_fit_mask] = final_scores_unnormalized / max_final_score
    else:
        # Fallback if all scores are zero (e.g., all bins are identical)
        priorities[can_fit_mask] = 1.0 / num_fitting_bins if num_fitting_bins > 0 else 0.0

    return priorities
```
