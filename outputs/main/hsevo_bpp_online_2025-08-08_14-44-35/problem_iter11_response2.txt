```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines a tight-fit preference with an adaptive penalty for bins with excessive remaining capacity,
    using a hybrid exploration/exploitation strategy with score normalization.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 0.15  # Probability of exploring less utilized bins
    
    can_fit_mask = bins_remain_cap >= item
    suitable_bins_indices = np.where(can_fit_mask)[0]

    if not np.any(can_fit_mask):
        return priorities

    # --- Exploitation Phase: Combine Tight Fit and Penalty for Large Bins ---
    
    # Tightness score: Higher for bins leaving less space after packing.
    # `1.0 / (remaining_space + epsilon)` where `remaining_space = bins_remain_cap - item`.
    # This favors bins where `bins_remain_cap` is just slightly larger than `item`.
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    remaining_after_packing = fitting_bins_remain_cap - item
    tightness_scores = 1.0 / (remaining_after_packing + 1e-6)

    # Penalty for "empty" or overly large bins: Penalize bins whose remaining capacity
    # is significantly larger than the item size. This encourages using bins that are
    # already somewhat utilized. We use `1.0 / (1.0 + penalty_weight * initial_capacity)`
    # for fitting bins, where `penalty_weight` controls the strength of the penalty.
    # A higher initial capacity results in a lower penalty score, thus reducing priority.
    penalty_weight = 0.3
    # Ensure we don't penalize bins that are already a good fit (capacity ~ item) too much.
    # The penalty is applied to the initial remaining capacity before packing.
    penalty_scores = 1.0 / (1.0 + penalty_weight * fitting_bins_remain_cap)

    # Combine scores: Multiply tightness by penalty.
    # This means bins that are tight *and* not excessively large get higher priority.
    combined_exploitation_scores = tightness_scores * penalty_scores

    # Normalize exploitation scores to be between 0 and 1
    max_exploitation_score = np.max(combined_exploitation_scores)
    if max_exploitation_score > 1e-9: # Avoid division by near zero
        normalized_exploitation_scores = combined_exploitation_scores / max_exploitation_score
    else:
        normalized_exploitation_scores = np.zeros_like(combined_exploitation_scores)
    
    priorities[can_fit_mask] = normalized_exploitation_scores

    # --- Exploration Phase: Favor less utilized bins ---
    # If exploration is triggered, randomly select a bin from those that can fit the item,
    # biasing towards bins with more remaining capacity (less utilized).
    if np.random.rand() < epsilon:
        # Calculate exploration scores for suitable bins: higher score for more remaining capacity.
        # We use a log transformation to amplify differences in larger capacities,
        # and add a small constant to handle bins with exactly the item size.
        exploration_scores = np.log1p(fitting_bins_remain_cap - item + 1e-6)
        
        # Normalize exploration scores to form a probability distribution for selection.
        sum_exploration_scores = np.sum(exploration_scores)
        if sum_exploration_scores > 1e-9:
            exploration_probabilities = exploration_scores / sum_exploration_scores
            chosen_bin_idx_in_suitable = np.random.choice(len(suitable_bins_indices), p=exploration_probabilities)
            chosen_bin_original_idx = suitable_bins_indices[chosen_bin_idx_in_suitable]
            # Assign a high priority (e.g., 1.0) to the chosen exploration bin.
            priorities = np.zeros_like(bins_remain_cap, dtype=float) # Reset priorities for pure exploration choice
            priorities[chosen_bin_original_idx] = 1.0
        else:
            # If all exploration scores are zero (e.g., all fitting bins have same capacity),
            # fall back to a random choice among fitting bins.
            chosen_bin_original_idx = np.random.choice(suitable_bins_indices)
            priorities = np.zeros_like(bins_remain_cap, dtype=float)
            priorities[chosen_bin_original_idx] = 1.0
    
    # If not exploring, the 'priorities' array already holds the normalized exploitation scores.
    
    return priorities
```
