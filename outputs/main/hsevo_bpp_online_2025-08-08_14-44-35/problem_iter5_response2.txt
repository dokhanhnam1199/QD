```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit and an epsilon-greedy exploration strategy.
    Favors bins with minimal remaining capacity after packing,
    with a chance to explore less optimal bins.
    """
    epsilon = 0.1
    epsilon_value = 1e-9

    fit_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate tightest fit priorities for suitable bins
    valid_capacities = bins_remain_cap[fit_mask] - item + epsilon_value
    tight_fit_priorities = np.zeros_like(bins_remain_cap, dtype=float)
    tight_fit_priorities[fit_mask] = 1.0 / valid_capacities

    # Normalize tight fit priorities
    sum_tight_fit = np.sum(tight_fit_priorities)
    if sum_tight_fit > 0:
        normalized_tight_fit = tight_fit_priorities / sum_tight_fit
    else:
        # If no bins can fit, all get equal chance (effectively new bin)
        normalized_tight_fit = np.ones_like(bins_remain_cap) / len(bins_remain_cap)

    # Epsilon-greedy: explore randomly with probability epsilon
    # Create exploration priorities: equal probability for all fitting bins
    exploration_priorities = np.zeros_like(bins_remain_cap, dtype=float)
    num_fitting_bins = np.sum(fit_mask)
    if num_fitting_bins > 0:
        exploration_priorities[fit_mask] = 1.0 / num_fitting_bins
    else:
        # If no bins fit, exploration is on all bins (preparing for a new bin)
        exploration_priorities = np.ones_like(bins_remain_cap) / len(bins_remain_cap)

    # Combine exploitation (tight fit) and exploration (random)
    combined_priorities = (1 - epsilon) * normalized_tight_fit + epsilon * exploration_priorities

    # Ensure probabilities sum to 1, handling cases where no bins fit initially
    if np.sum(combined_priorities) == 0:
        return np.ones_like(bins_remain_cap) / len(bins_remain_cap)
    
    final_priorities = combined_priorities / np.sum(combined_priorities)

    return final_priorities
```
