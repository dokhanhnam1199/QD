```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using an adaptive
    strategy that balances First Fit Decreasing-like behavior with the goal of
    minimizing the number of bins. Priority is higher for bins that can
    accommodate the item and are 'closer' to being full, while also considering
    bins that are significantly underutilized to encourage spreading items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9
    
    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, we calculate a score that combines two aspects:
    # 1. How tightly the bin will be packed (favors smaller remaining capacity)
    # 2. How full the bin is *before* packing (favors bins that are already somewhat full)
    # We also add a small constant to the denominator to avoid division by zero and
    # to ensure that bins that are perfectly filled still get a non-zero priority if needed.
    
    # Score based on how full the bin is before packing (higher if more full)
    # This encourages using already partially filled bins first.
    # We normalize by bin capacity to make it relative.
    filled_ratio = (bins_remain_cap - bins_remain_cap[can_fit_mask] ) / (bins_remain_cap[can_fit_mask] + epsilon)
    # The above line is wrong, it should be based on original capacity, but we don't have it.
    # Let's rephrase: favor bins that have a relatively small remaining capacity compared to their original capacity.
    # Since we don't have original capacity, let's use the inverse of remaining capacity as a proxy for fullness.
    
    # Consider bins that can fit the item
    fitting_bins_capacities = bins_remain_cap[can_fit_mask]

    # Score 1: Tighter packing (inverse of remaining capacity after packing)
    # Higher value for bins that will have less space left.
    tight_packing_score = 1.0 / (fitting_bins_capacities - item + epsilon)

    # Score 2: Encouraging use of partially filled bins
    # Higher value for bins that are already relatively full.
    # We use the inverse of the current remaining capacity.
    # This is a bit of a trade-off: tight_packing_score favors small remaining space after packing,
    # while this favors small remaining space *before* packing.
    # The combination aims to fill bins that have some capacity but are not empty.
    current_fullness_score = 1.0 / (fitting_bins_capacities + epsilon)
    
    # Combine scores: give more weight to the current fullness
    # The idea is to prioritize bins that are somewhat full AND will become even tighter.
    # We use a weighted sum. The weights can be tuned. Here, we give a bit more
    # emphasis to current fullness.
    combined_score = 0.6 * current_fullness_score + 0.4 * tight_packing_score
    
    # Assign priorities to the bins that can fit the item
    priorities[can_fit_mask] = combined_score

    # Normalize priorities so the maximum priority is 1.0
    # This makes the relative priorities consistent.
    max_priority = np.max(priorities)
    if max_priority > 0:
        priorities /= max_priority
        
    return priorities
```
