```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines normalized tightest fit with an epsilon-greedy exploration strategy.
    Prioritizes bins with minimal remaining capacity after packing,
    with a small chance to select any fitting bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    # If no bins can fit the item, return zero priorities
    if not np.any(can_fit_mask):
        return priorities

    available_bins_cap = bins_remain_cap[can_fit_mask]
    
    # Calculate tightest fit scores: higher score for less remaining capacity
    # Adding epsilon to avoid division by zero if remaining capacity equals item size
    epsilon = 1e-9
    tight_fit_scores = 1.0 / (available_bins_cap - item + epsilon)
    
    # Normalize tight fit scores to a 0-1 range for consistent comparison
    max_tight_fit = np.max(tight_fit_scores)
    if max_tight_fit > 0:
        normalized_tight_fit = tight_fit_scores / max_tight_fit
    else:
        normalized_tight_fit = np.zeros_like(tight_fit_scores)

    # Epsilon-greedy exploration:
    # With probability epsilon, pick a random fitting bin (uniform priority).
    # Otherwise, pick the bin with the highest normalized tight_fit_score.
    exploration_prob = 0.1
    
    if np.random.rand() < exploration_prob:
        # Exploration: Assign uniform high priority to all fitting bins
        priorities[can_fit_mask] = 1.0
    else:
        # Exploitation: Use normalized tight fit scores
        priorities[can_fit_mask] = normalized_tight_fit
        
    return priorities
```
