```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines a greedy approach with a diversification strategy,
    prioritizing bins that are "almost full" but can still accommodate the item,
    while also giving a slight preference to bins that offer a more "balanced" fit.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item
    suitable_bins_indices = np.where(suitable_bins_mask)[0]

    if suitable_bins_indices.size == 0:
        return priorities

    suitable_bins_capacities = bins_remain_cap[suitable_bins_indices]
    gaps = suitable_bins_capacities - item

    # Heuristic 1: Prioritize bins that leave a small, but not necessarily the smallest, gap.
    # This encourages filling bins more thoroughly without necessarily aiming for a perfect fit.
    # We use a non-linear scaling to favor gaps that are substantial but not too large.
    # A simple approach is to use inverse of (gap + 1) or a similar function.
    # Here, we'll use 1 / (gap + a) where 'a' is a small constant to avoid division by zero.
    # We also consider a threshold to avoid very large gaps.
    threshold = np.percentile(gaps, 75) # Consider bins where gap is not in the top 25%
    scores_diversify = np.zeros_like(gaps)
    for i, gap in enumerate(gaps):
        if gap <= threshold:
            scores_diversify[i] = 1.0 / (gap + 0.1) # Favor smaller gaps, but not just the smallest

    # Heuristic 2: Add a small bias towards bins that have a moderate amount of remaining capacity.
    # This can help in balancing bin usage and avoiding a situation where all bins are nearly full.
    # We can score bins based on their remaining capacity relative to the item size.
    # A simple heuristic is to favor bins with remaining capacity that is a certain multiple of the item size.
    # Let's favor bins where remaining_cap is between item_size * 1.1 and item_size * 2.0
    scores_balance = np.zeros_like(gaps)
    for i, capacity in enumerate(suitable_bins_capacities):
        if item * 1.1 <= capacity < item * 2.0:
            scores_balance[i] = 0.5 # Small positive score for balanced bins

    # Combine scores
    combined_scores = scores_diversify + scores_balance

    # Normalize scores for stability and to avoid issues with magnitude
    if np.max(combined_scores) > 0:
        combined_scores /= np.max(combined_scores)

    # Add a small random element to break ties and encourage some exploration
    noise = np.random.rand(len(combined_scores)) * 0.1
    final_scores = combined_scores + noise

    # Assign priorities to the original bins
    best_fit_in_suitable_idx = np.argmax(final_scores)
    best_fit_original_idx = suitable_bins_indices[best_fit_in_suitable_idx]
    priorities[best_fit_original_idx] = 1.0

    return priorities
```
