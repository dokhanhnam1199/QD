```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines the "tightest fit" priority of inverse remaining capacity with an
    epsilon-greedy exploration strategy. Favors bins that leave minimal space
    after packing, with a small chance of selecting a random suitable bin.
    """
    suitable_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if np.any(suitable_bins_mask):
        suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
        
        # Prioritize bins with the tightest fit (inverse remaining capacity)
        tight_fit_priorities = 1.0 / (suitable_bins_remain_cap - item + 1e-9)
        
        # Normalize tight fit priorities for a smoother distribution
        normalized_tight_fit_priorities = (tight_fit_priorities - np.min(tight_fit_priorities)) / \
                                          (np.max(tight_fit_priorities) - np.min(tight_fit_priorities) + 1e-9)
        
        # Introduce epsilon-greedy exploration: a small chance to pick any suitable bin
        epsilon = 0.1
        random_priorities = np.random.rand(np.sum(suitable_bins_mask))
        
        # Combine tight fit and random exploration
        combined_priorities = (1 - epsilon) * normalized_tight_fit_priorities + epsilon * random_priorities
        
        priorities[suitable_bins_mask] = combined_priorities

    return priorities
```
