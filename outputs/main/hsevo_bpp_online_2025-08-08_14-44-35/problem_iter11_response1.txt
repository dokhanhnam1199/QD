```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a utilization-aware exploration strategy.
    Prioritizes tight fits and encourages exploration of less utilized bins.
    """
    epsilon = 0.05  # Exploration probability
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    suitable_bins_mask = bins_remain_cap >= item
    suitable_bins_indices = np.where(suitable_bins_mask)[0]

    if suitable_bins_indices.size == 0:
        return priorities

    # Calculate a "tightness" score (how much space is left after packing)
    tightness_scores = np.zeros_like(bins_remain_cap, dtype=float)
    if suitable_bins_indices.size > 0:
        remaining_after_packing = bins_remain_cap[suitable_bins_indices] - item
        # Higher score for smaller remaining capacity (tighter fit)
        # Add a small constant to avoid division by zero and ensure positive scores
        tightness_scores[suitable_bins_indices] = 1.0 / (remaining_after_packing + 1e-9)

    # Calculate a "utilization" score (favoring bins that are already more full)
    # We use the inverse of remaining capacity *before* packing.
    utilization_scores = np.zeros_like(bins_remain_cap, dtype=float)
    if suitable_bins_indices.size > 0:
        # Higher score for less remaining capacity (more utilized bin)
        utilization_scores[suitable_bins_indices] = 1.0 / (bins_remain_cap[suitable_bins_indices] + 1e-9)

    # Combine scores: prioritize tightness, with a bonus for utilization
    combined_scores = tightness_scores + 0.5 * utilization_scores # Weight utilization less than tightness

    # Normalize scores for the suitable bins to a 0-1 range
    suitable_scores = combined_scores[suitable_bins_indices]
    if suitable_scores.size > 0:
        max_score = np.max(suitable_scores)
        if max_score > 0:
            normalized_scores = suitable_scores / max_score
            priorities[suitable_bins_indices] = normalized_scores

    # Epsilon-greedy exploration: with probability epsilon, pick a random suitable bin
    if np.random.rand() < epsilon:
        chosen_bin_index = np.random.choice(suitable_bins_indices)
        priorities = np.zeros_like(bins_remain_cap, dtype=float) # Reset priorities
        priorities[chosen_bin_index] = 1.0 # Assign full priority to the random bin
    else:
        # Exploitation: Use the calculated priorities (based on combined scores)
        # The `priorities` array already holds the normalized scores
        pass 

    return priorities
```
