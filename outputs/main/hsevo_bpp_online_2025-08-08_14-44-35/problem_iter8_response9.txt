```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for slack, adapting weights based on bin availability.
    Prioritizes bins that fit the item tightly, with a penalty for bins that leave excessive slack.
    Weights adapt to bin scarcity, favoring tight fits when few options exist.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item
    suitable_bins_indices = np.where(suitable_bins_mask)[0]

    if suitable_bins_indices.size == 0:
        return priorities

    suitable_bins_capacities = bins_remain_cap[suitable_bins_indices]

    # Criterion 1: Tightest Fit (minimize remaining capacity after packing)
    # Higher score for smaller gaps (bins that fit the item snugly)
    gaps = suitable_bins_capacities - item
    # Add a small epsilon to avoid division by zero and prioritize very tight fits
    tightness_score = 1.0 / (gaps + 1e-6) 

    # Criterion 2: Penalty for Slack (discourage bins with excessive remaining capacity)
    # We want to penalize large gaps. A high penalty for large slack means a low score.
    # So, we invert the slack for a higher score for smaller slack.
    # The penalty is higher when slack is larger.
    # Let's use `slack = remaining_capacity - item`. We want to penalize large slack.
    # A simple penalty could be `1 / (slack + epsilon)`. This rewards small slack.
    # Or, let's consider the inverse of `slack` as a score (higher for smaller slack).
    # `slack_score = 1.0 / (slack + 1e-6)`
    # This is similar to tightness_score, but let's make it distinct.
    # Let's penalize bins where `remaining_capacity - item` is large.
    # We want to maximize `-(remaining_capacity - item)`.
    # This is equivalent to minimizing `(remaining_capacity - item)`.
    # For priority (higher is better), we want to maximize `-(gap)`.
    # Or, minimize `gap`.
    # Let's define a "slack penalty score" which is high for small slack.
    slack_penalty_score = 1.0 / (gaps + 1e-6) # Same as tightness_score for now, need to differentiate

    # Let's redefine:
    # Tightness: Prefer bins where `bins_remain_cap[i]` is close to `item`.
    # This means `gap` is small. Maximize `1 / (gap + epsilon)`.

    # Slack Penalty: Prefer bins that don't leave too much *extra* space.
    # If `bins_remain_cap[i]` is much larger than `item`, it's bad.
    # So, we want to minimize `bins_remain_cap[i]`.
    # For priority, we want to maximize `-bins_remain_cap[i]`.
    # This would select the smallest capacity bins first.
    # Let's try to penalize large remaining capacities.
    # `slack_penalty = -suitable_bins_capacities` (lower is better, so need to invert for priority).
    # Maximize `-suitable_bins_capacities`.
    # Or, let's consider `1 / (suitable_bins_capacities + epsilon)` - this favors smaller capacities.
    slack_penalty_score = 1.0 / (suitable_bins_capacities + 1e-6)


    # Adaptive weights based on the number of suitable bins.
    # If few suitable bins, be more aggressive with tight fits.
    num_suitable = len(suitable_bins_indices)
    if num_suitable > 0:
        # Weight for Tightness: Higher when few suitable bins exist.
        w_tightness = 2.0 / (num_suitable + 1.0)
        # Weight for Slack Penalty: Higher when many suitable bins exist (allows more choice).
        w_slack_penalty = num_suitable / (num_suitable + 1.0)
    else:
        w_tightness = 0.5
        w_slack_penalty = 0.5

    # Combined score: Weighted sum of the two criteria
    # We want to maximize both `tightness_score` and `slack_penalty_score`.
    combined_scores = w_tightness * tightness_score + w_slack_penalty * slack_penalty_score

    # Assign scores to the original priority array for the suitable bins
    priorities[suitable_bins_indices] = combined_scores

    return priorities
```
