```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit Decreasing (BFD) principle with a novelty-seeking approach.
    Prioritizes bins that are a "good fit" but also discourages repeatedly picking
    bins that have been "over-utilized" recently, promoting a more balanced packing.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item
    suitable_bins_indices = np.where(suitable_bins_mask)[0]

    if suitable_bins_indices.size == 0:
        return priorities

    # Calculate the "tightness" of the fit: smaller gap is better
    suitable_bins_capacities = bins_remain_cap[suitable_bins_indices]
    gaps = suitable_bins_capacities - item

    # Normalize gaps to create a "tightness score" (smaller gap = higher score)
    # Add a small epsilon to avoid division by zero if all gaps are zero
    normalized_gaps = gaps / (np.max(gaps) - np.min(gaps) + 1e-9)
    tightness_scores = 1.0 - normalized_gaps

    # Introduce a "novelty" score. This is a proxy for how "under-utilized" a bin has been.
    # A simple approach is to use the inverse of the remaining capacity relative to the bin size.
    # For simplicity here, we can use the inverse of the current remaining capacity.
    # A larger remaining capacity suggests the bin is "less utilized" recently.
    # We only consider suitable bins.
    inverse_remaining_capacity = 1.0 / (suitable_bins_capacities + 1e-9)

    # Combine tightness and novelty. Weighting can be tuned.
    # Here, we give more weight to tightness, but novelty provides a boost to less used bins.
    combined_scores = 0.7 * tightness_scores + 0.3 * inverse_remaining_capacity

    # Assign priorities based on combined scores
    # The highest combined score gets the highest priority
    priorities[suitable_bins_indices] = combined_scores

    # Normalize priorities to sum to 1 for a probabilistic interpretation if needed,
    # or simply return raw scores as priority weights.
    # For this implementation, we return raw scores where higher means more preferred.
    
    # Simple normalization for better distribution if needed, but not strictly required
    # if np.sum(priorities) > 0:
    #     priorities = priorities / np.sum(priorities)

    return priorities
```
