```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with an epsilon-greedy exploration strategy.
    Prioritizes bins with minimal remaining capacity after packing,
    with a small chance to select a random fitting bin for exploration.
    """
    epsilon = 0.1  # Probability of exploration
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    available_bins_cap = bins_remain_cap[can_fit_mask]
    
    if available_bins_cap.size == 0:
        return priorities
    
    # Calculate tightest fit priority (higher for less remaining capacity)
    waste = available_bins_cap - item
    tight_fit_scores = 1.0 / (waste + 1e-9)
    
    # Apply exploration: with probability epsilon, choose a random fitting bin
    if np.random.rand() < epsilon:
        random_indices_in_subset = np.random.choice(len(available_bins_cap), size=1)
        # Set priority for the randomly chosen bin to be the maximum possible tight fit score
        # This effectively makes it the most preferred bin during exploration.
        priorities[can_fit_mask][random_indices_in_subset] = np.max(tight_fit_scores) + 1.0 
    else:
        # Otherwise, use the tightest fit scores
        priorities[can_fit_mask] = tight_fit_scores
        
    # Normalize priorities to be between 0 and 1
    max_priority = np.max(priorities)
    if max_priority > 0:
        priorities /= max_priority
        
    return priorities
```
