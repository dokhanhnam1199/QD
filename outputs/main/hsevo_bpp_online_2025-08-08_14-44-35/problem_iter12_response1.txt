```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float, exploration_factor: float = 0.1, fairness_weight: float = 0.3) -> np.ndarray:

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item
    suitable_bins_indices = np.where(suitable_bins_mask)[0]

    if suitable_bins_indices.size == 0:
        return priorities

    # Exploitation: Best Fit logic
    suitable_bins_capacities = bins_remain_cap[suitable_bins_indices]
    gaps = suitable_bins_capacities - item
    best_fit_indices_in_suitable = np.where(gaps == np.min(gaps))[0]
    best_fit_original_indices = suitable_bins_indices[best_fit_indices_in_suitable]

    # Exploration: Introduce a mechanism to occasionally pick non-best-fit bins
    if np.random.rand() < exploration_factor:
        exploration_candidates_indices = np.setdiff1d(suitable_bins_indices, best_fit_original_indices)
        if exploration_candidates_indices.size > 0:
            # Select a random bin from the remaining suitable bins
            chosen_exploration_index = np.random.choice(exploration_candidates_indices)
            priorities[chosen_exploration_index] = 1.0
            return priorities

    # Multi-objective consideration: Combine Best Fit with a fairness objective
    # Fairness: Prioritize bins that are less full (larger remaining capacity)
    # This helps to distribute items more evenly and potentially leave larger contiguous spaces
    # for future large items.

    # Normalize the gaps and remaining capacities to get scores between 0 and 1
    normalized_gaps = (gaps - np.min(gaps)) / (np.max(gaps) - np.min(gaps) + 1e-9)
    normalized_remaining_cap = (suitable_bins_capacities - item) / bin_capacity

    # Combine scores: Higher score is better.
    # We want a small gap (good for best fit) and a large remaining capacity (good for fairness)
    # For small gap, we want low normalized_gaps, so we use (1 - normalized_gaps)
    # For large remaining capacity, we want high normalized_remaining_cap
    combined_scores = (1 - normalized_gaps) * (1 - fairness_weight) + normalized_remaining_cap * fairness_weight

    # Get the indices of bins with the highest combined score
    best_combined_score_in_suitable_idx = np.where(combined_scores == np.max(combined_scores))[0]
    best_combined_original_indices = suitable_bins_indices[best_combined_score_in_suitable_idx]

    # Assign priority to the bin(s) with the highest combined score
    for idx in best_combined_original_indices:
        priorities[idx] = 1.0

    return priorities
```
