```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines the inverse remaining capacity strategy with a sigmoid function for smoother prioritization.
    It favors bins with smaller remaining capacity after placing the item, using a sigmoid to normalize scores.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i in range(len(bins_remain_cap)):
        if bins_remain_cap[i] >= item:
            remaining_capacity = bins_remain_cap[i] - item
            # Use inverse of remaining capacity, scaled by sigmoid to smooth prioritization
            # Adding a small epsilon to denominator to avoid division by zero
            # Scaling factor (e.g., 5.0) can be tuned to control sensitivity
            priorities[i] = 1 / (remaining_capacity + 1e-9)
            
    # Normalize priorities using sigmoid to create a smoother distribution and avoid extreme values
    # The sigmoid function squashes values between 0 and 1
    # We can scale the input to sigmoid to control the steepness of the transition
    # Using a simple division by the maximum priority to prevent overflow and normalize
    max_priority = np.max(priorities)
    if max_priority > 0:
        normalized_priorities = priorities / max_priority
        # Apply sigmoid
        return 1 / (1 + np.exp(-5.0 * (normalized_priorities - 0.5))) # Tunable steepness factor 5.0
    else:
        return np.zeros_like(bins_remain_cap, dtype=float)

```
