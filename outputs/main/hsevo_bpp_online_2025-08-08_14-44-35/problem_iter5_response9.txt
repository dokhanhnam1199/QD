```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tight packing (inverse remaining capacity after item) with an
    epsilon-greedy exploration strategy for selecting bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    available_bins_cap = bins_remain_cap[can_fit_mask]
    
    # Calculate tight fit score: higher for less remaining capacity after packing
    epsilon = 1e-9
    tight_fit_scores = 1.0 / (available_bins_cap - item + epsilon)
    
    # Normalize tight fit scores to be between 0 and 1
    max_tight_fit = np.max(tight_fit_scores)
    if max_tight_fit > 0:
        normalized_tight_fit = tight_fit_scores / max_tight_fit
    else:
        normalized_tight_fit = np.zeros_like(tight_fit_scores)

    # Epsilon-greedy exploration: 
    # With probability epsilon, pick a random fitting bin.
    # Otherwise, pick the bin with the highest tight_fit_score.
    epsilon = 0.1
    
    if np.random.rand() < epsilon:
        # Exploration: Assign uniform high priority to all fitting bins
        priorities[can_fit_mask] = 1.0
    else:
        # Exploitation: Use normalized tight fit scores
        priorities[can_fit_mask] = normalized_tight_fit
        
    return priorities
```
