```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Calculates priorities for packing an item into bins using a Softmax-Based Fit strategy.

    This strategy assigns higher priority to bins that are a good fit for the item,
    meaning bins with remaining capacity close to the item's size. A smaller
    difference between bin capacity and item size results in a higher score.
    Softmax is used to convert these scores into probabilities (priorities).

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A NumPy array representing the remaining capacity of each bin.

    Returns:
        A NumPy array of the same size as bins_remain_cap, where each element
        is the priority score for placing the item into the corresponding bin.
    """
    # Calculate the difference between remaining capacity and item size.
    # We are interested in bins where remaining capacity is >= item size.
    # For bins where remaining capacity is less than item size, the difference will be negative.
    # Adding a small epsilon to avoid issues with log(0) if capacity is exactly item size.
    differences = bins_remain_cap - item + 1e-9

    # We want to prioritize bins where the difference is small (good fit).
    # A larger difference means a worse fit. We can use the negative difference
    # to effectively treat smaller positive differences as "more positive".
    # We'll filter out bins where capacity < item size by making their score very low.
    # A large negative number will result in a very small exponent in softmax.
    scores = np.where(differences >= 0, -differences, -1e9)

    # Apply the softmax function to convert scores into probabilities (priorities)
    # Softmax: exp(score_i) / sum(exp(score_j))
    # This will naturally give higher probabilities to bins with smaller (less negative) scores.
    exp_scores = np.exp(scores)
    priorities = exp_scores / np.sum(exp_scores)

    return priorities
```
