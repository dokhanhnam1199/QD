```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with an adaptive fill bonus and a boosted exploration strategy.
    Prioritizes bins that are both tight fits and moderately utilized, encouraging exploration.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    # --- Exploitation: Combined Tightness and Fill Bonus ---
    # Tightness: Score based on how much capacity is left after packing. Higher is better.
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    remaining_after_packing = fitting_bins_remain_cap - item
    # Inverse of remaining capacity for tightness, add epsilon to avoid division by zero
    tightness_score = 1.0 / (remaining_after_packing + epsilon)

    # Fill Bonus: Score based on current bin utilization. Higher for more utilized bins.
    # Using inverse of current remaining capacity as a proxy for utilization.
    fill_bonus = 1.0 / (fitting_bins_remain_cap + epsilon)

    # Combined exploitation score: Product of tightness and fill bonus.
    # A bin that is tight *and* already somewhat full gets a higher score.
    # Added 1.0 to fill_bonus to ensure tightness score isn't zeroed out by small fill_bonus.
    combined_exploitation_score = tightness_score * (1.0 + 0.5 * fill_bonus) # Tunable weight 0.5

    # Normalize exploitation scores to [0, 1]
    max_exploitation_score = np.max(combined_exploitation_score)
    if max_exploitation_score > 0:
        normalized_exploitation_scores = combined_exploitation_score / max_exploitation_score
    else:
        normalized_exploitation_scores = np.zeros_like(combined_exploitation_score)

    # --- Exploration: Boost promising but not top candidates ---
    # This strategy aims to explore bins that are not the absolute best but are still good.
    # It boosts the score of bins that are "close" to the top exploitation score.
    exploration_weight = 0.2 # Base exploration weight
    num_fitting_bins = np.sum(can_fit_mask)

    # If there are many options, slightly increase exploration. If few, decrease.
    if num_fitting_bins > 6:
        exploration_weight *= 1.1
    elif num_fitting_bins < 3:
        exploration_weight *= 0.9

    # Calculate a threshold for "close to top" (e.g., within 20% of the max score)
    if max_exploitation_score > 0:
        threshold = max_exploitation_score * 0.8
        # Bins that are below the threshold but still good candidates for exploration
        exploration_candidates_mask = (combined_exploitation_score >= threshold) & \
                                      (combined_exploitation_score < max_exploitation_score)
        num_exploration_candidates = np.sum(exploration_candidates_mask)

        if num_exploration_candidates > 0:
            # Boost these candidates
            boost_amount = exploration_weight / num_exploration_candidates
            exploration_scores = np.zeros_like(bins_remain_cap, dtype=float)
            exploration_scores[can_fit_mask][exploration_candidates_mask] = boost_amount
        else:
            # If no bins fall in the "close to top" range, give a small uniform boost
            # to all fitting bins as a fallback exploration.
            exploration_scores = np.zeros_like(bins_remain_cap, dtype=float)
            exploration_scores[can_fit_mask] = exploration_weight / num_fitting_bins
    else:
        # If all exploitation scores are zero (e.g., all fitting bins have identical scores)
        # provide a uniform exploration boost to all fitting bins.
        exploration_scores = np.zeros_like(bins_remain_cap, dtype=float)
        exploration_scores[can_fit_mask] = exploration_weight / num_fitting_bins


    # --- Final Priority: Sum of normalized exploitation and exploration scores ---
    priorities[can_fit_mask] = normalized_exploitation_scores + exploration_scores

    # Ensure no negative priorities and normalize the final output to [0, 1]
    priorities = np.maximum(0, priorities)
    max_final_priority = np.max(priorities)
    if max_final_priority > 0:
        priorities /= max_final_priority

    return priorities
```
