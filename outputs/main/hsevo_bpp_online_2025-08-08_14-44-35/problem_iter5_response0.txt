```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tight-fitting preference with an adaptive exploration strategy.
    Prioritizes bins with minimal remaining capacity after packing,
    while occasionally exploring less ideal bins to broaden search.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9
    
    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_capacities = bins_remain_cap[can_fit_mask]

    if fitting_bins_capacities.size == 0:
        return priorities

    # Heuristic 1: Prioritize tight fits (minimize remaining capacity after packing)
    # Higher score for bins with less space left after item is placed.
    tight_fit_score = 1.0 / (fitting_bins_capacities - item + epsilon)

    # Heuristic 10: Epsilon-greedy exploration
    # With a small probability (epsilon), choose a random fitting bin.
    # Otherwise, choose the bin with the highest priority (tightest fit).
    epsilon_explore = 0.05  # Exploration rate
    num_fitting_bins = fitting_bins_capacities.size

    if np.random.rand() < epsilon_explore:
        # Exploration: pick a random bin among those that can fit
        random_index_in_fitting = np.random.randint(num_fitting_bins)
        # Assign a high priority to this randomly chosen bin to ensure it's picked
        exploration_priority = 1.0 
        priorities[can_fit_mask][random_index_in_fitting] = exploration_priority
    else:
        # Exploitation: assign priorities based on tight fit score
        priorities[can_fit_mask] = tight_fit_score

    # Normalize priorities so the maximum priority is 1.0 for consistent scaling
    max_priority = np.max(priorities)
    if max_priority > epsilon:
        priorities /= max_priority
        
    return priorities
```
