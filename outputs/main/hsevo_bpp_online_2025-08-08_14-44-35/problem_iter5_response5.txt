```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tight fitting and adaptive bin utilization with epsilon-greedy exploration.
    Prioritizes bins that leave less space and bins that are more utilized,
    with a chance to explore less optimal but fitting bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9
    exploration_prob = 0.1 # Probability for epsilon-greedy

    can_fit_mask = bins_remain_cap >= item
    available_bins_remain_cap = bins_remain_cap[can_fit_mask]

    if available_bins_remain_cap.size == 0:
        return priorities

    # Component 1: Tight Fitting (minimize waste)
    remaining_after_packing = available_bins_remain_cap - item
    tight_fit_scores = 1.0 / (remaining_after_packing + epsilon)

    # Component 2: Adaptive Bin Utilization (prefer fuller bins)
    # Normalize remaining capacity to reflect utilization. Higher score for less remaining capacity.
    max_remaining_overall = np.max(bins_remain_cap) if np.any(bins_remain_cap > 0) else 1.0
    utilization_scores = (max_remaining_overall - available_bins_remain_cap + epsilon) / (max_remaining_overall + epsilon)

    # Combine core heuristic scores (e.g., balanced preference)
    # Give equal weight to tight fitting and utilization for now.
    combined_core_scores = 0.5 * tight_fit_scores + 0.5 * utilization_scores

    # Normalize core scores
    max_core_score = np.max(combined_core_scores)
    if max_core_score > epsilon:
        normalized_core_scores = combined_core_scores / max_core_score
    else:
        normalized_core_scores = np.zeros_like(combined_core_scores)

    # Epsilon-greedy exploration: with probability, pick a random fitting bin
    num_available_bins = available_bins_remain_cap.size
    exploration_indices = np.random.choice(
        np.arange(num_available_bins),
        size=int(exploration_prob * num_available_bins),
        replace=False
    )
    
    final_scores = normalized_core_scores

    # Assign a high priority to randomly selected bins for exploration
    # We can boost their score significantly to ensure they are considered
    boost_factor = 2.0 # Make exploration picks clearly stand out
    final_scores[exploration_indices] *= boost_factor
    
    # Re-normalize after boosting to keep priorities in a reasonable range
    max_final_score = np.max(final_scores)
    if max_final_score > epsilon:
        priorities[can_fit_mask] = final_scores / max_final_score
    else:
        priorities[can_fit_mask] = final_scores

    return priorities
```
