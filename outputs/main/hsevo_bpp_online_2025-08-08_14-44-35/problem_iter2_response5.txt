```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins by favoring tighter fits (inverse remaining capacity) while adding a penalty for completely empty bins."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item

    # Calculate priorities for suitable bins: higher priority for less remaining capacity (tighter fit)
    # Add a small epsilon to avoid division by zero if a bin is exactly full
    epsilon = 1e-9
    suitable_bins_capacity = bins_remain_cap[suitable_bins_mask]
    priorities[suitable_bins_mask] = 1.0 / (suitable_bins_capacity - item + epsilon)

    # Apply a penalty to bins that are completely empty to encourage packing into existing bins first.
    # Bins with remaining capacity equal to the bin capacity are considered empty.
    # This penalty is designed to be significantly larger than any priority value from the inverse capacity calculation.
    empty_bins_mask = bins_remain_cap == np.max(bins_remain_cap) # Assuming max capacity is the bin size
    
    # Ensure we only penalize empty bins that are also suitable
    empty_and_suitable_mask = empty_bins_mask & suitable_bins_mask
    
    # A large constant to penalize empty bins. This ensures they are considered only after non-empty bins are exhausted.
    empty_bin_penalty = 1e6  
    priorities[empty_and_suitable_mask] = empty_bin_penalty

    return priorities
```
