```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tight-fit preference with a penalty for excessive remaining capacity,
    favoring bins that utilize space efficiently and avoid large leftovers.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate tightness score: inverse of remaining capacity *after* packing.
    # Higher score for bins that leave less remaining space.
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    remaining_after_packing = fitting_bins_remain_cap - item
    
    # Avoid division by zero or very small numbers
    tightness_score = np.zeros_like(bins_remain_cap, dtype=float)
    tightness_score[can_fit_mask] = 1.0 / (remaining_after_packing + epsilon)

    # Penalty for bins with excessive slack (large remaining capacity *before* packing).
    # This discourages using bins that are much larger than needed for the current item.
    # We use a sigmoid-like penalty that is close to 1 for small remaining capacities
    # and approaches 0 for very large remaining capacities.
    # This is inspired by the idea of penalizing "empty" or "underutilized" bins.
    
    # Define a sensitivity parameter for slack penalty.
    # A higher value makes the penalty more aggressive for smaller amounts of slack.
    slack_penalty_sensitivity = 0.1
    
    slack_penalty = np.ones_like(bins_remain_cap, dtype=float)
    # Apply penalty only to bins that can fit the item
    slack_penalty[can_fit_mask] = 1.0 / (1.0 + slack_penalty_sensitivity * bins_remain_cap[can_fit_mask])

    # Combine tightness score and slack penalty multiplicatively.
    # This ensures that bins must be both tightly fitting and not have excessive slack.
    combined_score = tightness_score * slack_penalty
    
    # Normalize scores to a 0-1 range to ensure comparability.
    max_score = np.max(combined_score)
    if max_score > 0:
        priorities[can_fit_mask] = combined_score[can_fit_mask] / max_score
    
    return priorities
```
