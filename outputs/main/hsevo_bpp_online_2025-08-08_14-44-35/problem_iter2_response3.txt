```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with an adaptive exploration strategy.
    It prioritizes bins with the tightest fit, but with a probability,
    explores other fitting bins to avoid getting stuck in local optima.
    """
    epsilon = 0.1  # Probability of exploration
    n_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    possible_bins_indices = np.where(bins_remain_cap >= item)[0]

    if len(possible_bins_indices) == 0:
        return priorities  # No bin can fit the item

    # Exploration phase: with probability epsilon, choose a random fitting bin
    if np.random.rand() < epsilon:
        chosen_bin_index = np.random.choice(possible_bins_indices)
        priorities[chosen_bin_index] = 1.0
    else:
        # Exploitation phase: Best Fit strategy
        fitting_bins_capacities = bins_remain_cap[possible_bins_indices]
        # Calculate the 'gap' or remaining capacity after fitting the item
        gaps = fitting_bins_capacities - item
        # Find the index within the 'possible_bins_indices' array that has the minimum gap
        best_fit_in_possible_idx = np.argmin(gaps)
        # Get the original index of this best-fitting bin
        best_fit_original_idx = possible_bins_indices[best_fit_in_possible_idx]
        priorities[best_fit_original_idx] = 1.0

    return priorities
```
