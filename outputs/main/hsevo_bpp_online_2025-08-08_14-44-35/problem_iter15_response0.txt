```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Multi-objective priority function for online Bin Packing using UCB-like exploration.
    Combines tightest fit, bin utilization, and an Upper Confidence Bound (UCB) inspired
    exploration bonus to balance exploitation and exploration effectively.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9
    utilization_weight = 0.4
    exploration_strength = 0.5  # Controls the exploration bonus magnitude

    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    fitting_indices = np.where(can_fit_mask)[0]

    # Objective 1: Tightest Fit (minimizing remaining capacity)
    # Score is higher for bins with less remaining capacity after packing.
    remaining_after_packing = fitting_bins_remain_cap - item
    tightness_score = 1.0 / (remaining_after_packing + epsilon)

    # Objective 2: Bin Utilization (favoring more utilized bins)
    # Score is higher for bins with less remaining capacity *before* packing.
    # Normalizing based on the maximum utilization score among fitting bins.
    utilization_score = 1.0 / (fitting_bins_remain_cap + epsilon)
    max_utilization_score = np.max(utilization_score)
    normalized_utilization_score = utilization_score / (max_utilization_score + epsilon)

    # Combine exploitation objectives (Tightness and Utilization)
    exploitation_score = tightness_score + utilization_weight * normalized_utilization_score

    # Normalize exploitation scores to [0, 1] for consistency
    max_exploitation_score = np.max(exploitation_score)
    if max_exploitation_score > epsilon:
        normalized_exploitation_scores = exploitation_score / max_exploitation_score
    else:
        normalized_exploitation_scores = np.zeros_like(exploitation_score)

    # Objective 3: Adaptive Exploration (UCB-like)
    # We want to explore bins that are promising but perhaps not the absolute best exploitation-wise.
    # A simple UCB-like approach can be `mean_score + exploration_bonus * sqrt(log(N)/n)`,
    # where N is total visits and n is visits to this bin. For online, we can approximate
    # this by considering the 'uncertainty' or 'potential' of a bin.
    # Here, we'll use a simplified approach: boost bins that are not currently the absolute
    # top performers in exploitation, providing a balance.
    
    # Identify the current best exploitation score
    best_exploitation_score = np.max(normalized_exploitation_scores)
    
    # Calculate a 'potential' for exploration: bins that are "good" but not the absolute best.
    # We can define "good" as being within a certain range of the best exploitation score,
    # or simply having a positive exploitation score.
    # Let's consider bins that have an exploitation score > 0 and are not the absolute max.
    
    # A more direct UCB-like approach: simulate exploration by considering how often
    # a bin *could* have been a good choice. We can proxy this by the inverse of the
    # rank of its exploitation score among the fitting bins.
    
    # Get ranks of exploitation scores (lower rank = better)
    ranked_indices = np.argsort(exploitation_score)[::-1] # descending order of score
    ranks = np.empty_like(ranked_indices)
    ranks[ranked_indices] = np.arange(len(ranked_indices))
    
    # Exploration bonus: higher for bins with lower exploitation ranks (i.e., not yet fully exploited)
    # We scale this by exploration_strength to control its impact.
    exploration_bonus = exploration_strength * (1.0 / (ranks + 1)) # Ranks start from 0, add 1 to avoid division by zero and scale

    # Final Scores: Combine normalized exploitation and exploration bonus
    # We ensure exploration bonus is also normalized relative to its own maximum potential
    max_exploration_bonus = np.max(exploration_bonus)
    if max_exploration_bonus > epsilon:
        normalized_exploration_bonus = exploration_bonus / max_exploration_bonus
    else:
        normalized_exploration_bonus = np.zeros_like(exploration_bonus)

    final_scores_unnormalized = normalized_exploitation_scores + normalized_exploration_bonus

    # Final Normalization to ensure the highest priority is 1.0
    max_final_score = np.max(final_scores_unnormalized)
    if max_final_score > epsilon:
        priorities[can_fit_mask] = final_scores_unnormalized / max_final_score
    else:
        # Fallback: if all scores are zero (e.g., single fitting bin with item size equal to capacity)
        # assign equal priority.
        priorities[can_fit_mask] = 1.0 / len(fitting_bins_remain_cap) if len(fitting_bins_remain_cap) > 0 else 0.0

    return priorities
```
