[
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on remaining capacity and item size, favoring bins that can accommodate the item snugly without excessive waste, and then returns an array containing the priority scores for each bin.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates a priority score for each bin based on remaining capacity and item size, favoring bins that can accommodate the item snugly without excessive waste, and then returns an array containing the priority scores for each bin.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            priority.append(1 / (cap - item + 0.00001))  # Inversely proportional to wasted space\n        else:\n            priority.append(-1000)  # Very low priority if item doesn't fit\n\n    return priority",
          "objective": 4.04866,
          "other_inf": null,
          "SLOC": 9.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 46.50699332842308
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a combination of remaining capacity and how well the item fits, favoring bins that are neither too full nor too empty after packing the item.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin based on a combination of remaining capacity and how well the item fits, favoring bins that are neither too full nor too empty after packing the item.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      fit_ratio = item / cap\n      remaining_ratio = (cap - item) / cap\n\n      # Balance between fit (item size / bin size) and remaining capacity\n      score = 0.7 * fit_ratio + 0.3 * (1 - remaining_ratio)\n\n      priority.append(score)\n    else:\n      priority.append(-1)  # Invalid bin\n  return priority",
          "objective": 4.04866,
          "other_inf": null,
          "SLOC": 9.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 46.50699332842308
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity fit and how full the bin would be after packing the item.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on a combination of remaining capacity fit and how full the bin would be after packing the item.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      fill_ratio = (item) / (item + (cap - item)) #item / bin_cap\n      priority.append(fill_ratio)\n    else:\n      priority.append(-1)\n  return priority",
          "objective": 4.04866,
          "other_inf": null,
          "SLOC": 9.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 46.50699332842308
     },
     {
          "algorithm": "This algorithm calculates priority scores based on the remaining capacity of bins after hypothetically placing the item and favors bins with higher utilization and avoids bins where the item won't fit.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates priority scores based on the remaining capacity of bins after hypothetically placing the item and favors bins with higher utilization and avoids bins where the item won't fit.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap < item:\n            priority.append(-1)  # Assign a very low priority if the item doesn't fit\n        else:\n            new_cap = cap - item\n            utilization = (1 - (new_cap / 1)) # Assuming bin capacity is 1\n            priority.append(utilization)\n    return priority",
          "objective": 4.04866,
          "other_inf": null,
          "SLOC": 13.0,
          "cyclomatic_complexity": 5.0,
          "halstead": 60.94436251225966
     },
     {
          "algorithm": "Assign a priority score to each bin based on how much the item would fill the bin and how close it would get to full, favoring bins that would be filled to a higher percentage.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{Assign a priority score to each bin based on how much the item would fill the bin and how close it would get to full, favoring bins that would be filled to a higher percentage.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if item <= cap:\n      fill_percentage = item / cap\n      remaining_percentage = (cap - item) / cap if cap - item > 0 else 0\n      priority_score = fill_percentage + (1 - remaining_percentage) \n      priority.append(priority_score)\n    else:\n      priority.append(-1)\n  return priority",
          "objective": 4.04866,
          "other_inf": null,
          "SLOC": 13.0,
          "cyclomatic_complexity": 5.0,
          "halstead": 60.94436251225966
     },
     {
          "algorithm": "This algorithm calculates the priority score for each bin based on a combination of remaining capacity and how well the item fits, favoring bins that have enough space but are not too much larger than the item.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority score for each bin based on a combination of remaining capacity and how well the item fits, favoring bins that have enough space but are not too much larger than the item.}\"\"\"\n  priorities = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      #fit_ratio = item / cap\n      priority = (cap - item) / (item + 1e-9) \n      priorities.append(1.0/(priority+0.001))\n    else:\n      priorities.append(-1)  # Invalid bin if not enough capacity\n  return priority",
          "objective": 4.48744,
          "other_inf": null,
          "SLOC": 9.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 46.50699332842308
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity and the fit of the item, favoring bins with sufficient space and a tighter fit.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm prioritizes bins based on a combination of remaining capacity and the fit of the item, favoring bins with sufficient space and a tighter fit.}\"\"\"\n    priorities = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            priority = (cap - item) + (1 / cap) # Remaining capacity + inverse remaining capacity.\n            priorities.append(priority)\n        else:\n            priorities.append(-1)\n    return priority",
          "objective": 4.48744,
          "other_inf": null,
          "SLOC": 9.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 46.50699332842308
     },
     {
          "algorithm": "This algorithm assigns priority based on a combination of remaining capacity and a penalty for exceeding a certain threshold, aiming to balance bin utilization and avoid near-full bins early on.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"\n  {This algorithm assigns priority based on a combination of remaining capacity and a penalty for exceeding a certain threshold, aiming to balance bin utilization and avoid near-full bins early on.}\n  \"\"\"\n  priorities = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      priority = cap - item #remaining capacity after placement\n      if cap - item < 0.1 * 1.0: #0.1 threshold\n          priority -= 100 #penalty\n    else:\n      priority = -1000 #very low priority, makes it undesirable\n    priorities.append(priority)\n  return priority",
          "objective": 4.48744,
          "other_inf": null,
          "SLOC": 13.0,
          "cyclomatic_complexity": 5.0,
          "halstead": 60.94436251225966
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on the remaining capacity and item size, favoring bins with remaining capacity closest to the item size and penalizing bins that are too full or too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates a priority score for each bin based on the remaining capacity and item size, favoring bins with remaining capacity closest to the item size and penalizing bins that are too full or too empty.}\"\"\"\n    priorities = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            priority = 1 / (abs(cap - item) + 0.1)  # Favor bins where remaining capacity is close to item size\n        else:\n            priority = -1000  # Penalize bins that cannot accommodate the item\n        priorities.append(priority)\n    return priority",
          "objective": 4.48744,
          "other_inf": null,
          "SLOC": 13.0,
          "cyclomatic_complexity": 5.0,
          "halstead": 60.94436251225966
     },
     {
          "algorithm": "This algorithm calculates the priority score for each bin based on the remaining capacity and item size, favoring bins with enough space but not excessively large remaining capacity.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"\n    {This algorithm calculates the priority score for each bin based on the remaining capacity and item size, favoring bins with enough space but not excessively large remaining capacity.}\n    \"\"\"\n    priorities = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            priority = (cap - item) / cap  # Prioritize smaller waste\n        else:\n            priority = -1  # Invalid bin\n        priorities.append(priority)\n    return priority",
          "objective": 4.48744,
          "other_inf": null,
          "SLOC": 13.0,
          "cyclomatic_complexity": 5.0,
          "halstead": 60.94436251225966
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity relative to item size and a penalty for bins already containing items, aiming to balance fitting items well and distributing items across bins.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on a combination of remaining capacity relative to item size and a penalty for bins already containing items, aiming to balance fitting items well and distributing items across bins.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      fit_ratio = item / cap\n      if cap < 1:\n          cap = 1 #avoid division by zero\n      empty_penalty = (1 if cap == bins_remain_cap[0] else 0.1)  # Penalize empty bins less if any other bins are occupied \n      priority_score = fit_ratio + empty_penalty\n      priority.append(priority_score)\n    else:\n      priority.append(-1)\n  return priority",
          "objective": 4.48744,
          "other_inf": null,
          "SLOC": 13.0,
          "cyclomatic_complexity": 5.0,
          "halstead": 60.94436251225966
     },
     {
          "algorithm": "This algorithm assigns a priority score to each bin based on how well the item fits, prioritizing bins where the remaining capacity after packing the item is close to a certain threshold and penalizing bins that would be left with too much or too little space.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm assigns a priority score to each bin based on how well the item fits, prioritizing bins where the remaining capacity after packing the item is close to a certain threshold and penalizing bins that would be left with too much or too little space.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      remaining_after_pack = cap - item\n      # Define a target remaining capacity (e.g., 20% of the bin size)\n      target_remaining = 0.2 * 100  # Assuming bin size is 100. Adjust as needed.\n\n      # Calculate the difference between the remaining capacity and the target\n      diff = abs(remaining_after_pack - target_remaining)\n\n      # Assign priority based on how close the remaining capacity is to the target.\n      # Smaller diff means higher priority.  Add a base score and scale down the difference.\n      score = 100 - diff #Adjust the base score as needed.\n\n      priority.append(score)\n\n    else:\n      priority.append(-1)  # Item doesn't fit, so assign lowest priority.\n\n  return priority",
          "objective": 12.13602,
          "other_inf": null,
          "SLOC": 13.0,
          "cyclomatic_complexity": 5.0,
          "halstead": 60.94436251225966
     },
     {
          "algorithm": "This algorithm assigns priority to bins based on a combination of remaining capacity and the item size, favoring bins that can accommodate the item with minimal wasted space, while also considering how full the bin already is.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm assigns priority to bins based on a combination of remaining capacity and the item size, favoring bins that can accommodate the item with minimal wasted space, while also considering how full the bin already is.}\"\"\"\n  priorities = []\n  for bin_cap in bins_remain_cap:\n    if bin_cap >= item:\n      # Prioritize based on remaining capacity after packing the item\n      remaining_after_pack = bin_cap - item\n      # Combine remaining capacity with how full the bin already is\n      priority = (item / bin_cap) - remaining_after_pack\n      priorities.append(priority)\n    else:\n      priorities.append(-1) # Assign -1 if item doesn't fit\n  return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm assigns priority to each bin based on a weighted combination of remaining capacity and the absolute difference between the item size and remaining capacity, favoring bins with sufficient capacity and minimizing wasted space.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm assigns priority to each bin based on a weighted combination of remaining capacity and the absolute difference between the item size and remaining capacity, favoring bins with sufficient capacity and minimizing wasted space.}\"\"\"\n  priorities = []\n  for capacity in bins_remain_cap:\n    if capacity >= item:\n      priority = capacity * 0.5 - abs(capacity - item) * 0.5\n    else:\n      priority = -1000  # Assign a very low priority if the bin cannot fit the item\n    priorities.append(priority)\n  return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm assigns priority scores to bins based on a combination of remaining capacity and wasted space if the item is placed in the bin.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm assigns priority scores to bins based on a combination of remaining capacity and wasted space if the item is placed in the bin.}\"\"\"\n    priorities = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            wasted_space = cap - item\n            priority = (cap + 1e-6) / (wasted_space + 1e-6)  # Ratio of remaining capacity to wasted space. Add a small number to avoid division by zero.\n            priorities.append(priority)\n        else:\n            priorities.append(-1)  # Assign a negative priority if the item doesn't fit\n\n    return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a combination of remaining capacity and waste minimization.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin based on a combination of remaining capacity and waste minimization.}\"\"\"\n  priorities = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      waste = cap - item\n      priority = (1.0 / (waste + 0.1)) + (cap / sum(bins_remain_cap)) # Avoid zero division and add remaining capacity factor\n    else:\n      priority = -1  # Assign low priority to bins that cannot fit the item\n    priorities.append(priority)\n  return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin by considering the remaining capacity, giving higher priority to bins that can accommodate the item with minimal wasted space, and penalizing bins that are too full or too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin by considering the remaining capacity, giving higher priority to bins that can accommodate the item with minimal wasted space, and penalizing bins that are too full or too empty.}\"\"\"\n  priorities = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      priorities.append(1 / (cap - item + 0.0001)) \n    else:\n      priorities.append(-1000)\n  return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on the remaining capacity and item size, favoring bins that can accommodate the item with minimal remaining space and avoiding bins that would be overfilled.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates a priority score for each bin based on the remaining capacity and item size, favoring bins that can accommodate the item with minimal remaining space and avoiding bins that would be overfilled.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            priority.append(1 / (cap - item + 1e-9))  # Favor smaller remaining space\n        else:\n            priority.append(-1e9)  # Penalize overfilling\n    return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on a combination of remaining capacity and a penalty for bins that are too full or too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates a priority score for each bin based on a combination of remaining capacity and a penalty for bins that are too full or too empty.}\"\"\"\n  priorities = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      priority = cap - item  # Base priority: remaining space after packing\n      # Add penalty for bins that are almost full or almost empty\n      if cap - item < 0.1: # very full (remaining cap less than 10%)\n          priority += 10\n      if cap - item > 0.9: # almost empty\n        priority -= 5\n      priorities.append(priority)\n    else:\n      priorities.append(-float('inf'))  # Assign negative infinity if item doesn't fit\n  return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm calculates priority based on a combination of remaining capacity and a penalty for bins with very low capacity, aiming to balance space utilization and avoid fragmenting bins.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates priority based on a combination of remaining capacity and a penalty for bins with very low capacity, aiming to balance space utilization and avoid fragmenting bins.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      # Calculate a base priority based on remaining capacity.  Higher remaining capacity is generally better.\n      base_priority = cap\n\n      # Add a penalty for bins that are too small *after* packing the item, to avoid fragmentation.\n      remaining_after_pack = cap - item\n      if remaining_after_pack < (sum(bins_remain_cap) / len(bins_remain_cap) / 5):  #was 10\n         penalty = (sum(bins_remain_cap) / len(bins_remain_cap)) *1\n      else:\n          penalty = 0\n      \n      priority.append(base_priority - penalty)\n    else:\n      priority.append(-1) # Impossible to pack\n  return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     }
]