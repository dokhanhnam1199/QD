def priority_v2(item, bins_remain_cap):
  """{This algorithm uses a cost-benefit analysis, prioritizing bins where the 'benefit' of packing the item (percentage of bin filled) outweighs the 'cost' (increase in bin usage variance), favoring bins that lead to more uniform fill levels.}"""
  priority = []
  bin_count = len(bins_remain_cap)
  initial_avg_fill = sum(100 - cap for cap in bins_remain_cap) / bin_count if bin_count > 0 else 0 #Initial average fill percentage
  
  for i, cap in enumerate(bins_remain_cap):
    if cap >= item:
      potential_remaining_cap = cap - item
      
      #Calculate potential fill level
      potential_fill = 100 - potential_remaining_cap
      
      #Calculate the new average fill level after packing into bin i
      new_bins_remain_cap = bins_remain_cap[:]
      new_bins_remain_cap[i] = potential_remaining_cap
      new_avg_fill = sum(100 - cap for cap in new_bins_remain_cap) / bin_count if bin_count > 0 else 0

      #Calculate benefit (fill percentage)
      benefit = (potential_fill- (100 - cap)) / 100
          
      #Calculate variance before packing
      variance_before = sum([(100 - bins_remain_cap[j] - initial_avg_fill)**2 for j in range(bin_count)]) / bin_count if bin_count > 0 else 0

      #Calculate variance after packing into bin i
      variance_after = sum([(100 - new_bins_remain_cap[j] - new_avg_fill)**2 for j in range(bin_count)]) / bin_count if bin_count > 0 else 0
      
      #Calculate Cost(change in variance, packing the item may cause unbalanced fill level)
      cost = variance_after - variance_before

      #Calculate priority based on benefit and cost. The smaller the variance after packing the item and the more item can fill the bin, the higher the priority score.
      if cost == 0:
          priority_score = benefit * 1000 # give a high priority if cost is 0
      else:
          priority_score = benefit / abs(cost)

      priority.append(priority_score)
    else:
      priority.append(-1) #Item doesn't fit
  return priority
