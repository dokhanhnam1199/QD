def priority_v2(item, bins_remain_cap):
  """{This algorithm prioritizes bins based on how closely the item size matches the remaining capacity, rewarding near-perfect fits and penalizing bins that are too full or too empty after packing.}"""
  priority = []
  for cap in bins_remain_cap:
    if cap >= item:
      remaining_after_pack = cap - item
      # Calculate a score based on the absolute difference between the remaining capacity after packing and a target value (e.g., half the bin size).  Smaller differences are better.
      ideal_remaining = 0.5
      score = 1.0 / (abs(remaining_after_pack / (sum(bins_remain_cap) / len(bins_remain_cap)) - ideal_remaining) + 0.01) 
      priority.append(score)
    else:
      priority.append(-1)
  return priority
