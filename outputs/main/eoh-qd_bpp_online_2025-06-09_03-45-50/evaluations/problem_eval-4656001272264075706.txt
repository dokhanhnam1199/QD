def priority_v2(item, bins_remain_cap):
  """{This algorithm calculates priority based on a combination of remaining capacity and a penalty for bins with very low capacity, aiming to balance space utilization and avoid fragmenting bins.}"""
  priority = []
  for cap in bins_remain_cap:
    if cap >= item:
      # Calculate a base priority based on remaining capacity.  Higher remaining capacity is generally better.
      base_priority = cap

      # Add a penalty for bins that are too small *after* packing the item, to avoid fragmentation.
      remaining_after_pack = cap - item
      if remaining_after_pack < (sum(bins_remain_cap) / len(bins_remain_cap) / 5):  #was 10
         penalty = (sum(bins_remain_cap) / len(bins_remain_cap)) *1
      else:
          penalty = 0
      
      priority.append(base_priority - penalty)
    else:
      priority.append(-1) # Impossible to pack
  return priority
