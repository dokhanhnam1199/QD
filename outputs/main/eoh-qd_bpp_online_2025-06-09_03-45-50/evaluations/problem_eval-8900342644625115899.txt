def priority_v3(item, bins_remain_cap):
  """{This algorithm calculates priority based on remaining capacity, rewarding bins close to the item size and penalizing those that would become too empty after packing the item.}"""
  priority = []
  for cap in bins_remain_cap:
    if cap >= item:
      # Base priority based on how close the remaining capacity is to the item size.
      base_priority = cap - item # Smaller value is better

      # Penalty for bins that would be too empty after packing.
      remaining_after_pack = cap - item
      if remaining_after_pack > (sum(bins_remain_cap) / len(bins_remain_cap) / 2):
          penalty = (sum(bins_remain_cap) / len(bins_remain_cap)) * 0.5
      else:
          penalty = 0
          
      priority.append(-base_priority - penalty) # Invert so larger is better
    else:
      priority.append(-1) # Impossible to pack
  return priority
