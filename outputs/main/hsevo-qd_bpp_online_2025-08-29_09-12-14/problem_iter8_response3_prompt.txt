{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    bin_fits = bins_remain_cap[possible_bins] - item\n    exp_fits = np.exp(bin_fits / (item + 1e-6))\n    sum_exp_fits = np.sum(exp_fits)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = exp_fits / sum_exp_fits\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) > 0:\n        priorities[possible_bins] = 1.0 / (bins_remain_cap[possible_bins] - item)\n    return priorities\n\n### Analyze & experience\n- Comparing heuristics 1st vs 2nd, the 1st provides a more nuanced priority calculation (1/(remaining-item)) compared to the 2nd, which simply returns zeros. This demonstrates the importance of considering remaining space.  Comparing 1st vs 3rd, they are identical, showcasing redundancy. Comparing 4th vs 5th, both implement inverse waste and exponential weighting, but 4th explicitly calculates `possible_bins` improving readability and efficiency.  Comparing 6th vs 8th, these are identical. Comparing 7th vs 9th, 7th uses a simpler distance calculation, while 9th normalizes by the *minimum* waste which is less robust.  Comparing 11th vs 13th, they're functionally the same. Comparing 16th vs 20th, 16th uses `exp(1/(waste+1e-6))`, which could lead to instability, while 20th uses `exp(waste/(item+1e-6))` which is more numerically stable and conceptually linked to bin \"fullness.\" Heuristics 10th, 12th, 14th, and 15th are minimal and ineffective, simply returning zero priorities. Heuristics 17th and 18th offer some calculation but are less sophisticated than the top-ranked options. Overall, the best heuristics prioritize bins based on remaining capacity, incorporating inverse waste and exponential weighting, and emphasize numerical stability and clarity. The worst heuristics simply return zero priorities or minimal calculations.\n- \nOkay, here's a refined self-reflection, aimed at heuristic design improvement, structured for maximum impact and with an eye toward your generous tip!\n\n*   **Keywords:** Relative Fitness, Exponential Preference, Robustness, Normalization.\n*   **Advice:** Focus on *relative* bin desirability (waste *compared to item size*) & translate this into a probability distribution via softmax/exponential weighting. Prioritize handling 'no-fit' scenarios elegantly.\n*   **Avoid:** Absolute waste values, negative priorities, direct remaining capacity checks *without* item size context, and complex/redundant calculations.\n*   **Explanation:** Heuristics thrive on nuanced preference. Normalizing & weighting fosters exploration/exploitation. Robustness (zero-division handling) is non-negotiable for real-world applicability.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}