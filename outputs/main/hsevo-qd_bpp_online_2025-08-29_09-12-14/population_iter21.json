[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 0.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        priorities[valid_bins] = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (priorities[valid_bins] + 1e-6)\n    return priorities",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        worst_fit_capacities = bins_remain_cap[valid_bins]\n        max_waste = np.max(worst_fit_capacities - item)\n        worst_bin_index = np.where(bins_remain_cap >= item)[0]\n        for i in worst_bin_index:\n            if bins_remain_cap[i] - item == max_waste:\n                priorities[i] = 1\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 47.548875021634686,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    \n    waste = bins_remain_cap[valid_bins] - item\n    \n    priorities[valid_bins] = waste / (item + waste)\n    \n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 48.43204266092217,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        min_waste = np.min(bins_remain_cap[feasible_bins] - item)\n        priorities[feasible_bins] = 1.0 / (bins_remain_cap[feasible_bins] - item + min_waste + 1e-6)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 68.53238859703687,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        remaining_capacities = bins_remain_cap[valid_bins]\n        distances = remaining_capacities - item\n        priorities[valid_bins] = 1.0 / (distances + 1e-6)\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return priorities\n    \n    remaining_capacities = bins_remain_cap[possible_bins]\n    \n    priorities[possible_bins] = (remaining_capacities - item) / item\n    \n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 35.41084962106105,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 39.863137138648355,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    bin_fits = bins_remain_cap[possible_bins] - item\n    exp_fits = np.exp(bin_fits / (item + 1e-6))\n    sum_exp_fits = np.sum(exp_fits)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = exp_fits / sum_exp_fits\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.72503367497926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    for i in range(bin_count):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 0.0001)\n        else:\n            priorities[i] = 0.0\n    return priorities",
    "response_id": 26,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    for i in range(n_bins):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1 / (1 + np.exp(-5 * (bins_remain_cap[i] - item)))\n        else:\n            priorities[i] = 0\n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "obj": 13.40247307538892,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    temp = bins_remain_cap - item\n    priorities = np.where(temp >= 0, np.exp(temp / (item + 1e-6)), 0)\n    priorities = priorities / np.sum(priorities)\n    return priorities",
    "response_id": 19,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n    worst_fit_capacities = bins_remain_cap[valid_bins]\n    priorities[valid_bins] = worst_fit_capacities\n    return priorities",
    "response_id": 22,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 15.509775004326936,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n    \n    remaining_capacities = bins_remain_cap[valid_bins]\n    \n    waste = remaining_capacities - item\n    \n    priorities[valid_bins] = 1.0 / (waste + 1e-6)\n    \n    return priorities",
    "response_id": 23,
    "tryHS": true,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) > 0:\n        priorities[possible_bins] = 1.0 / (bins_remain_cap[possible_bins] - item)\n    return priorities",
    "response_id": 24,
    "tryHS": true,
    "obj": 5.275229357798175,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    fit_scores = bins_remain_cap[possible_bins] - item\n    \n    temperature = 1.0\n    \n    exp_scores = np.exp(fit_scores / temperature)\n    \n    probabilities = exp_scores / np.sum(exp_scores)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = probabilities\n    \n    return priorities",
    "response_id": 29,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 50.18947501009619,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Calculates bin priorities based on relative waste and exponential weighting.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    remaining_capacities = bins_remain_cap[valid_bins]\n    waste = remaining_capacities - item\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = np.exp(waste / (item + 1e-6))\n    sum_exp_fits = np.sum(priorities[valid_bins])\n    priorities[valid_bins] = priorities[valid_bins] / sum_exp_fits\n    return priorities",
    "response_id": 7,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.72503367497926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse waste with exponential weighting for robust bin prioritization.\"\"\"\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = np.exp(-waste / (item + 1e-6))\n    priorities /= np.sum(priorities) if np.sum(priorities) > 0 else 1.0\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 93.45440529575887,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse waste with exponential weighting and normalization\n    to create a robust priority function for bin packing.\n    \"\"\"\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return priorities\n\n    remaining_capacities = bins_remain_cap[possible_bins]\n    waste = remaining_capacities - item\n    priorities[possible_bins] = np.exp(-waste / item)\n    priorities /= np.sum(priorities)\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.72503367497926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on inverse of waste + exponential weighting.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) > 0:\n        waste = bins_remain_cap[possible_bins] - item\n        priorities = np.zeros_like(bins_remain_cap)\n        priorities[possible_bins] = np.exp(-waste) / (waste + 1e-6)\n    else:\n        priorities = np.zeros_like(bins_remain_cap)\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins based on the inverse of waste (remaining capacity - item size),\n    with an exponential weighting to favor tighter fits, combining best aspects of v1-v9.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        distances = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = np.exp(-distances)\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 22.458839376460833,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse waste with exponential weighting and normalization.\"\"\"\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n    remaining_capacities = bins_remain_cap[valid_bins]\n    waste = remaining_capacities - item\n    priorities[valid_bins] = np.exp(-waste)\n    priorities = priorities / np.sum(priorities)\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 51.80615605397529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse waste with exponential weighting for better bin fit.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (1 + np.exp(-5 * waste))\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 13.40247307538892,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    for i in range(bin_count):\n        if bins_remain_cap[i] >= item:\n            fit_ratio = item / bins_remain_cap[i]\n            priorities[i] = np.exp(-fit_ratio * 5)\n        else:\n            priorities[i] = 0.0\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.9462028110163836) -> np.ndarray:\n    \"\"\"\n    Calculates priorities for items based on remaining capacity of bins.\n\n    Args:\n        item (float): The size of the item.\n        bins_remain_cap (np.ndarray): Remaining capacity of each bin.\n        epsilon (float, optional): Small value to avoid division by zero. Defaults to 0.0001.\n\n    Returns:\n        np.ndarray: Priorities for each bin.\n    \"\"\"\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    for i in range(bin_count):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + epsilon)\n        else:\n            priorities[i] = 0.0\n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse waste with exponential weighting and normalization.\"\"\"\n    waste = bins_remain_cap - item\n    priorities = np.where(waste >= 0, np.exp(waste / (item + 1e-6)), 0)\n    priorities = priorities / np.sum(priorities)\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    for i in range(bin_count):\n        if bins_remain_cap[i] >= item:\n            fit = item / bins_remain_cap[i]\n            priorities[i] = np.exp(-fit)\n        else:\n            priorities[i] = 0.0\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 22.458839376460833,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, small_value: float = 0.000528330981757869) -> np.ndarray:\n    \"\"\"Prioritizes bins based on inverse waste with exponential weighting.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Assigns priority based on relative fitness (waste/item) and exponential weighting.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n    bin_fits = bins_remain_cap[possible_bins] - item\n    waste = bin_fits / (item + 1e-6)\n    exp_fits = np.exp(waste)\n    sum_exp_fits = np.sum(exp_fits)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = exp_fits / sum_exp_fits\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 64.72503367497926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    for i in range(bin_count):\n        if bins_remain_cap[i] >= item:\n            waste = bins_remain_cap[i] - item\n            relative_waste = waste / item\n            priorities[i] = np.exp(-relative_waste)\n        else:\n            priorities[i] = 0.0\n    priorities = priorities / (np.sum(priorities) + 1e-8)\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 64.72503367497926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, small_value: float = 0.0006227369002908896) -> np.ndarray:\n    \"\"\"Calculates bin priorities based on relative waste and exponential weighting.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 4.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    for i in range(bin_count):\n        if bins_remain_cap[i] >= item:\n            waste = bins_remain_cap[i] - item\n            priorities[i] = np.exp(-waste / item)\n        else:\n            priorities[i] = 0.0\n    \n    if np.sum(priorities) > 0:\n        priorities = priorities / np.sum(priorities)\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 64.72503367497926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 8.410404329390895) -> np.ndarray:\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 4.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse waste ratio with exponential weighting and normalization.\"\"\"\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n    remaining_capacities = bins_remain_cap[valid_bins]\n    waste_ratio = (remaining_capacities - item) / item\n    priorities[valid_bins] = np.exp(-waste_ratio * 2)\n    priorities = priorities / np.sum(priorities)\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 81.7492568250068,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse waste with exponential weighting, normalized for robust bin selection.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        relative_waste = waste / item\n        priorities[valid_bins] = np.exp(-relative_waste * 5)\n        priorities[valid_bins] = 1.0 / (1 + np.exp(-priorities[valid_bins]))\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 89.92418250750748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response5.txt_stdout.txt",
    "code_path": "problem_iter17_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse waste with exponential weighting and normalization for robust bin selection.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        waste = bins_remain_cap[feasible_bins] - item\n        min_waste = np.min(waste)\n        priorities[feasible_bins] = np.exp(-5 * (waste / (min_waste + 1e-6)))\n        priorities[feasible_bins] /= np.sum(priorities[feasible_bins])\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 83.39850002884624,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response0.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, threshold: float = 0.22304820969191608, weight: float = 8.680065518835532) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        threshold: Minimum remaining capacity to be considered. Default is 0.0.\n        weight: Weight applied to the priority score. Default is 1.0.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = (bins_remain_cap >= item) & (bins_remain_cap >= threshold)\n    if np.sum(possible_bins) > 0:\n        priorities[possible_bins] = weight / (bins_remain_cap[possible_bins] - item)\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 5.0857598723574,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 70.32403072095333,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response1.txt_stdout.txt",
    "code_path": "problem_iter17_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse waste with exponential weighting and normalization.\"\"\"\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        min_waste = np.min(waste)\n        priorities[valid_bins] = np.exp(-5 * (waste / (min_waste + 1e-6)))\n        priorities /= np.sum(priorities)\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 83.39850002884624,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response0.txt_stdout.txt",
    "code_path": "problem_iter19_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.0008179044529912987) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 15.509775004326936,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on inverse of relative waste with exponential weighting.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) > 0:\n        relative_waste = (bins_remain_cap[possible_bins] - item) / item\n        priorities = np.zeros_like(bins_remain_cap)\n        priorities[possible_bins] = np.exp(-relative_waste) / (relative_waste + 1e-6)\n        priorities = priorities / np.sum(priorities)\n    else:\n        priorities = np.zeros_like(bins_remain_cap)\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 95.90827503317318,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines relative waste and exponential weighting for improved bin selection.\n    Normalizes after exponential weighting for stability.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n    fit_scores = bins_remain_cap[possible_bins] - item\n    relative_waste = item / bins_remain_cap[possible_bins]\n    exp_scores = np.exp(-relative_waste)\n    probabilities = exp_scores / np.sum(exp_scores)\n    priorities[possible_bins] = probabilities\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 59.207035490257475,
    "exec_success": true
  }
]