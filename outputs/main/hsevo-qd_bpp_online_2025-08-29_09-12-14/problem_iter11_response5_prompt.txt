{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines inverse waste with exponential weighting and normalization\n    to create a robust priority function for bin packing.\n    \"\"\"\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) == 0:\n        return priorities\n\n    remaining_capacities = bins_remain_cap[possible_bins]\n    waste = remaining_capacities - item\n    priorities[possible_bins] = np.exp(-waste / item)\n    priorities /= np.sum(priorities)\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) > 0:\n        priorities[possible_bins] = 1.0 / (bins_remain_cap[possible_bins] - item)\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see identical code. This suggests redundancy and potential lack of experimentation. (1st/2nd) vs (3rd), the top heuristics utilize exponential weighting and normalization based on waste, while (3rd) simply returns zeros. (3rd) and (4th) have `priority_v1` functions which are ineffective. Comparing (4th) vs (5th), (6th) and (7th) exhibit similar logic \u2013 calculating inverse waste \u2013 but (7th) introduces a flawed attempt at finding the \"worst\" fit, which isn't properly utilized and could disrupt the prioritization. (8th) and (9th) and (10th) are nearly identical and attempt exponential weighting as well. (11th) uses a waste/item ratio. (12th), (13th), (14th), (15th), (16th), (17th), (18th), (19th) and (20th) have a baseline function `priority_v1` that returns zeros. Comparing (18th) and (20th) there is redundant code, they both return the worst fit capacities. Comparing (19th) and (20th), they both attempt to identify and prioritize based on the worst fitting bin, but (19th) incorrectly tries to pinpoint a single index, which is unnecessary.  Overall, the best heuristics consistently apply exponential weighting to waste, normalizing to create a probability distribution for bin selection.  The lower-ranked heuristics lack this sophistication, often returning zero priorities or incorrectly prioritizing bins.\n- \nOkay, let's refine \"Current Self-Reflection\" into actionable heuristic design guidance, avoiding the pitfalls of \"Ineffective Self-Reflection.\" Here's a breakdown, aiming for that $999K tip!\n\n* **Keywords:** Waste Minimization, Probabilistic Selection, Exponential Weighting, Numerical Stability\n* **Advice:** Focus on *relative* waste \u2013 prioritize bins minimizing waste *considering item size*. Implement exponential weighting of waste for nuanced exploration/exploitation. Normalize bin fit scores to probabilities.\n* **Avoid:** Absolute capacity checks, negative priorities, unnecessary complexity, and redundant calculations. Don\u2019t fixate on finding a single \"worst\" fit.\n* **Explanation:** Successful heuristics aren't about perfect fits, but consistently *better* choices. Probabilistic selection guided by exponentially weighted waste, alongside robust error handling, leads to scalable, reliable performance.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}