{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    for i in range(n_bins):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1 / (1 + np.exp(-5 * (bins_remain_cap[i] - item)))\n        else:\n            priorities[i] = 0\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n    worst_fit_capacities = bins_remain_cap[valid_bins]\n    priorities[valid_bins] = worst_fit_capacities\n    return priorities\n\n### Analyze & experience\n- Comparing Heuristics 1st vs 20th, the 1st employs a more robust handling of edge cases (empty valid bins) and a finer weighting of waste via `1e-6` addition, preventing division by zero. The 20th's simple `fit_ratio` exponentiation lacks this robustness. \n\nComparing 1st vs 2nd, the 2nd normalizes based on the capacity instead of the waste which is a disadvantage. \n\nComparing 3rd vs 4th, the 3rd is more concise and skips unnecessary variable assignments found in the 4th. Both attempt similar weighting, but the 3rd's brevity is favored.\n\nComparing 6th vs 7th, the 7th introduces `relative_waste` which offers potentially better scaling, while the 6th uses a direct `exp_fits`, making it less adaptive to varying bin sizes.\n\nComparing 11th/12th vs 13th, the 11th/12th introduce tunable parameters `threshold` and `weight`, but are identical. The 13th uses a sigmoid-like function which offers smooth prioritization, but lacks flexibility without parameters.\n\nThe repeated code in 14th-17th is a major drawback. The 18th directly uses remaining capacity as priority, which is naive. Heuristics 5th, 9th, and 19th introduce unnecessary imports or are very basic.\n\nOverall, the best heuristics (1st, 2nd, 3rd, 7th) consistently use exponential weighting of waste, normalization, and handle edge cases effectively. The worst (18th, 14th-17th, 5th, 9th) have repeated code, lack robustness, or are overly simplistic.\n- \nOkay, here's a refined self-reflection focused on designing superior bin-packing heuristics, aiming for that $999K tip!\n\n* **Keywords:** Exponential weighting, Normalization, Inverse Waste, Feasibility, Robustness.\n* **Advice:** Prioritize a score based on `exp(-waste/item_size)` for each feasible bin. Normalize these scores (using softmax or similar) into a probability distribution. Tune the exponent for exploration/exploitation. Explicitly handle cases where *no* bins fit.\n* **Avoid:**  Directly using remaining capacity, negative priorities, complex \"worst-fit\" logic, and redundant calculations. Don\u2019t normalize *before* filtering for feasibility.\n* **Explanation:** Exponential weighting amplifies the benefit of tight fits *relative* to item size. Normalization ensures probabilistic, stable selection. Focusing on feasible bins avoids wasted computation and maintains robustness, crucial for scaling.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}