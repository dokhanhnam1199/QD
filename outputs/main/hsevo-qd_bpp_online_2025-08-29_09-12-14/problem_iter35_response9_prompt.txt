{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on inverse of waste + exponential weighting.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) > 0:\n        waste = bins_remain_cap[possible_bins] - item\n        priorities = np.zeros_like(bins_remain_cap)\n        priorities[possible_bins] = np.exp(-waste) / (waste + 1e-6)\n    else:\n        priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines relative waste and exponential weighting for stable bin selection.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities\n    relative_waste = item / bins_remain_cap[possible_bins]\n    exp_scores = np.exp(-relative_waste)\n    probabilities = exp_scores / np.sum(exp_scores)\n    priorities[possible_bins] = probabilities\n    return priorities\n\n### Analyze & experience\n- Comparing `priority_v2` (1st) vs `priority_v1` (2nd), we observe the first employs a sophisticated combination of inverse waste, exponential weighting, and viable bin focusing, while the second is an empty function, providing no prioritization. The 1st prioritizes bins with lower relative waste, scaling by 5 and normalizing. `priority_v2` (3rd) is also a strong contender, utilizing exponential weighting of waste but normalizing using the minimum waste, which can be sensitive to outliers. Comparing (1st) vs (3rd), the 1st is more robust as it scales relative waste directly, avoiding reliance on the minimum. `priority_v2` (4th) performs a similar calculation as the 1st, but less efficiently due to explicit loops and indexing. Comparing (3rd) vs (4th), the 3rd leverages NumPy vectorization more effectively.  `priority_v2` (6th) and (8th) are identical implementations, applying inverse waste with exponential weighting, yet they are ranked lower because of a less optimized normalization procedure and potentially numerical instability due to the `waste + 1e-6`. `priority_v2` (9th) scales the waste by item and applies exponential weighting. Heuristics 5th, 7th, 10th, 11th, 12th, 14th exhibit similar problems to the 2nd, utilizing `priority_v1` or providing minimal implementation. Heuristics 13th, 15th, 16th, 17th, 18th, 19th, 20th introduce various prioritization schemes, but either lack effective normalization or exhibit inferior performance compared to the top-ranked heuristics due to less robust weighting or normalization. Overall: The best heuristics consistently combine inverse waste, exponential weighting, and appropriate normalization techniques, leveraging NumPy's vectorization for efficiency. Avoiding direct use of min/max for normalization and scaling by the item size or relative waste appears to improve robustness.\n- \nOkay, let's distill these reflections into actionable advice for designing better heuristics. Given the potential reward, a thorough, step-by-step approach is crucial!\n\n**Keywords:** Waste Minimization, Exponential Weighting, Normalization, Robustness, Feasibility.\n\n**Advice:** Focus on *relative* waste \u2013 how well an item fits *compared to its size* within a bin. Combine inverse waste with exponential weighting *before* normalization to a probability distribution. Prioritize calculations *only* on feasible bins.\n\n**Avoid:** Normalizing before weighting, direct use of remaining capacity without item size context, overly complex \"worst-fit\" logic, and unnecessary computations/parameters. Division-by-zero errors are critical failures.\n\n**Explanation:** The core pattern is prioritizing tighter fits (lower *relative* waste) via exponential weighting. Normalization *after* weighting ensures stable probabilistic selection. Robustness\u2014handling edge cases & preventing numerical instability\u2014is paramount for real-world performance & scalability.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}