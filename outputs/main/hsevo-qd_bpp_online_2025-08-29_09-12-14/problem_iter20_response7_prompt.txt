{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculates priorities for items based on remaining capacity of bins.\n\n    Args:\n        item (float): The size of the item.\n        bins_remain_cap (np.ndarray): Remaining capacity of each bin.\n        epsilon (float, optional): Small value to avoid division by zero. Defaults to 0.0001.\n\n    Returns:\n        np.ndarray: Priorities for each bin.\n    \"\"\"\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    for i in range(bin_count):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + epsilon)\n        else:\n            priorities[i] = 0.0\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Calculates bin priorities based on relative waste and exponential weighting.\"\"\"\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), both combine inverse waste with exponential weighting, but the 1st uses `min_waste` to normalize the exponent, making it more robust to varying waste sizes. (3rd) vs (4th), the 3rd normalizes *after* the exponential weighting which improves stability, while the 4th normalizes before, leading to more sensitivity.  (5th) vs (6th): Both are similar waste ratio based weighting, but 5th includes an arbitrary epsilon. (7th) vs (8th): 7th provides a basic inverse waste, 8th attempts to improve with min_waste, resulting in slightly better performance. (9th) vs (10th): 10th streamlines the inverse waste and exponential weighting, making it more concise and likely better performing. (11th) vs (12th): 11th incorporates `min_waste`, 12th uses a different epsilon \u2013 neither provide substantial improvements. (13th) vs (14th): 13th is a waste ratio, 14th introduces a 'temperature', though it's never used. (15th) vs (16th): 15th attempts a temperature-scaled exponential but isn't fully utilized, while 16th is a more direct inverse waste approach. (17th) and (18th) similarly introduce parameters without clear benefit. (19th) vs (20th): 19th uses a simple waste ratio, 20th tries to find the \"worst fit\" but inefficiently iterates. Overall, the best heuristics focus on inverse waste with an exponential weighting and normalization, crucially normalizing *after* the weighting for stability and using a relative minimum waste calculation. Simplicity and avoiding unused parameters (temperature, epsilon) are essential.\n- \nOkay, here\u2019s a refined self-reflection distilled into actionable advice for designing better heuristics, aiming for that $999K!\n\n* **Keywords:** Relative Waste, Exponential Weighting, Normalization, Robustness.\n* **Advice:** Prioritize *relative* waste (waste *vs.* item size) and use exponential weighting to balance exploitation of good bins with exploration of potentially better fits. Always normalize scores to a probability distribution.\n* **Avoid:** Absolute remaining capacity, negative priorities, unnecessary complexity, redundant calculations, and ignoring edge cases (item doesn't fit *any* bin).\n* **Explanation:** Effective heuristics aren't about finding the *absolute* best, but consistently selecting *better* bins. Normalization ensures stable, comparable scores. Robustness guarantees performance across diverse inputs.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}