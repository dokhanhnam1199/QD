{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    for i in range(bin_count):\n        if bins_remain_cap[i] >= item:\n            waste = bins_remain_cap[i] - item\n            priorities[i] = np.exp(-waste / item)\n        else:\n            priorities[i] = 0.0\n    \n    if np.sum(priorities) > 0:\n        priorities = priorities / np.sum(priorities)\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n    \n    remaining_capacities = bins_remain_cap[valid_bins]\n    \n    waste = remaining_capacities - item\n    \n    priorities[valid_bins] = 1.0 / (waste + 1e-6)\n    \n    return priorities\n\n### Analyze & experience\n- Comparing heuristics 1st and 2nd, both aim to prioritize bins based on remaining capacity, but the 1st version simply returns zeros, rendering it useless. The 2nd version introduces a basic inverse waste calculation (1/(remaining_capacity - item)). This is a step in the right direction, but lacks normalization.\n\nComparing 2nd and 3rd, the 3rd refines the 2nd by explicitly filtering for `possible_bins` (where `bins_remain_cap >= item`), improving efficiency and clarity. It then normalizes the priorities, ensuring they sum to 1, which is crucial for probabilistic selection.  Both employ exponential weighting on the waste, but the 3rd focuses solely on viable bins, which is good practice.\n\nHeuristics 3rd and 4th are identical.\n\nComparing 4th/3rd with 5th, the 5th introduces 'relative waste' (waste/item) which is beneficial for scaling the waste value depending on item size. However, it has a slightly different normalization strategy, adding a small value (1e-8) to the sum of priorities. This avoids division by zero but is functionally similar to dividing by the sum.\n\nComparing 5th and 6th, the 6th version enhances the scoring by including `1e-6` in the denominator of the exponential term, further preventing potential division-by-zero errors. The inverse relative waste combined with the exponential weighting provides a more robust scoring.\n\nHeuristics 7th and 8th are very similar and quite basic, implementing the inverse waste calculation but lacking the exponential smoothing and normalization of better heuristics.\n\nHeuristics 9th, 11th, and 12th are also similar to 7th/8th.\n\nComparing 10th to others, the pre-scaling of the 'relative waste' by 5 in `np.exp(-5 * relative_waste)` affects the steepness of the exponential decay. This can be beneficial, but the optimal scaling factor is problem-dependent.\n\nHeuristics 13th, 14th, 15th, 16th, 17th, 18th, 19th and 20th introduce varying degrees of sophistication but generally lack the robustness and efficiency of the top-ranked heuristics. 15th and 16th attempt to use a temperature parameter and exponential weighting with probabilities, but are computationally heavier.  18th and 19th are improvements but still less elegant than the top heuristics.\n\nOverall: The best heuristics (1st-6th) prioritize efficient calculation of waste, exponential weighting to favor tighter fits, and proper normalization for probabilistic bin selection. Avoiding division by zero and focusing computation only on viable bins are key. The lower-ranked heuristics are either overly simplistic, redundant, or introduce unnecessary complexity.\n- \nOkay, let's distill this into actionable advice for heuristic design, aiming for that $999K! Here's a breakdown:\n\n* **Keywords:** Waste minimization, Exponential Weighting, Normalization, Robustness.\n* **Advice:** Prioritize relative waste (waste *relative to item size*). Combine inverse waste with exponential weighting *before* normalization to a probability distribution for bin selection. Focus on rewarding \"good fits,\" not penalizing \"bad\" ones.\n* **Avoid:** Absolute remaining capacity, negative priorities, unnecessary complexity, identifying \"worst\" fits, redundant calculations, and numerical instability (division by zero).\n* **Explanation:** Effective heuristics aren't about complex rules; they\u2019re about consistently rewarding better solutions (tighter fits). Normalization & weighting ensure fair comparisons & prevent dominance by outliers, leading to stable, scalable performance.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}