{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines inverse waste with exponential weighting and normalization for robust bin selection.\"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        waste = bins_remain_cap[feasible_bins] - item\n        min_waste = np.min(waste)\n        priorities[feasible_bins] = np.exp(-5 * (waste / (min_waste + 1e-6)))\n        priorities[feasible_bins] /= np.sum(priorities[feasible_bins])\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n    worst_fit_capacities = bins_remain_cap[valid_bins]\n    priorities[valid_bins] = worst_fit_capacities\n    return priorities\n\n### Analyze & experience\n- Comparing heuristics 1st vs 2nd, both utilize exponential weighting with inverse waste, but the 1st uses `item + 1e-6` in the denominator for normalization, potentially avoiding issues with `item` being zero and offering smoother weighting.  The 2nd uses `min_waste + 1e-6`, which is more sensitive to the smallest waste value.\n\nComparing 2nd vs 3rd, the 3rd calculates relative waste directly without a `min_waste` reference, making it potentially less stable and reliant on the absolute waste values.\n\nComparing 3rd vs 4th, the 4th normalizes only the feasible bins' priorities, which is better practice than normalizing all priorities including those of infeasible bins, as seen in the 3rd.\n\nComparing 4th vs 5th, the 5th normalizes over *all* priorities again, losing the benefit of focusing on feasible bins.\n\nHeuristics 6th is essentially identical to 4th.\n\nComparing 7th vs 8th, the 8th is simpler, only using the distance (waste) in the exponential. The 7th attempts to incorporate relative waste into the exponential, but also divides by `relative_waste + 1e-6`, which can be unstable.\n\nComparing 8th vs 9th, the 9th also uses relative waste directly in the exponential, lacking the smooth weighting of the 8th.\n\nHeuristics 10th, 11th, and 12th are identical; they implement a simple inverse waste prioritization. \n\nHeuristics 13th includes unnecessary imports and lacks clear prioritization logic beyond checking feasibility.\n\nHeuristics 14th calculates relative fitness as waste/item and applies exponential weighting, but is less elegant than earlier approaches.\n\nHeuristics 15th, 16th, 17th, 18th, 19th and 20th generally devolve into simpler or incorrect approaches.  16th, 17th and 18th attempt inverse waste/relative waste with varying degrees of correctness, but lack the smoothing of the exponential weighting.  The final heuristic (20th) is a basic approach that returns priorities based on worst-fit capacities.\n\nOverall: The strongest heuristics (1st-8th) focus on exponential weighting of inverse waste. Normalizing only over feasible bins is advantageous. Simpler approaches (10th-12th) lack nuance and are less effective.  Later heuristics show a decreasing understanding of proper prioritization.\n- \nOkay, let's distill this extensive self-reflection into actionable heuristic design guidance. Here's a breakdown to maximize your $999K investment!\n\n* **Keywords:** Waste minimization, Exponential Weighting, Normalization, Robustness.\n* **Advice:** Prioritize *relative* waste (item size considered). Combine inverse waste with exponential weighting *before* normalization to a probability distribution. Focus on quantifying \"goodness of fit\" rather than identifying \"worst\" fits.\n* **Avoid:** Direct remaining capacity use, unnecessary complexity, searching for absolute worst cases, operating on infeasible solutions, and neglecting edge case handling (zero sizes, no fit).\n* **Explanation:** The core theme is balancing exploitation (tightest fits via inverse waste/weighting) with exploration (normalization for robustness). Numerical stability and efficiency (avoiding redundant calculations) are critical for scalable performance.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}