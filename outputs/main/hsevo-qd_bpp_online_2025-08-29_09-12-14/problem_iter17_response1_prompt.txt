{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculates priorities for items based on remaining capacity of bins.\n\n    Args:\n        item (float): The size of the item.\n        bins_remain_cap (np.ndarray): Remaining capacity of each bin.\n        epsilon (float, optional): Small value to avoid division by zero. Defaults to 0.0001.\n\n    Returns:\n        np.ndarray: Priorities for each bin.\n    \"\"\"\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    for i in range(bin_count):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + epsilon)\n        else:\n            priorities[i] = 0.0\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        worst_fit_capacities = bins_remain_cap[valid_bins]\n        max_waste = np.max(worst_fit_capacities - item)\n        worst_bin_index = np.where(bins_remain_cap >= item)[0]\n        for i in worst_bin_index:\n            if bins_remain_cap[i] - item == max_waste:\n                priorities[i] = 1\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see the 1st uses `np.exp(-waste_ratio * 2)` and normalizes, providing a smoother, scaled priority, while the 2nd directly uses the inverse of remaining capacity, leading to potentially large variations and lack of smoothing. (1st) is more robust.\n\nComparing (3rd) vs (4th), both aim for inverse waste with exponential weighting. However, (4th) explicitly handles the case where no bins are valid, and the use of `1e-6` in the denominator prevents division-by-zero more cleanly than the implicit handling in (3rd) \u2013 a basic function that only returns 0s.\n\nComparing (5th) vs (6th), (6th) is slightly better as it computes the *distance* (remaining capacity - item) directly. (5th) recalculates this unnecessarily. Both are simpler than (1st) and (4th).\n\nComparing (7th) vs (8th), they are very similar. (8th) is more concise, calculating the exponential fit directly.  Both normalize.\n\nComparing (9th) vs (10th), (10th) is just a stub returning all zeros, making (9th) clearly superior, though still relatively simple.\n\nComparing (11th) vs (12th), (11th) has a more sophisticated scaling using `1 + np.exp(-5 * (waste / (min_waste + 1e-6)))` which allows for more nuanced priority assignment based on the minimum waste, giving it an edge.\n\nComparing (13th) vs (14th), (14th) attempts to prioritize based on the waste itself, while (13th) is closer to the better examples (inverse waste). (14th) will likely perform poorly.\n\nComparing (15th) vs (16th), both are attempting to find the worst fit, but (16th) has an extremely convoluted way of doing so. (15th) is simpler and more direct.\n\nComparing (17th) vs (18th), (18th) is more robust due to normalization. (17th) doesn't normalize and uses a hardcoded factor of 5.\n\nComparing (19th) vs (20th), both are identical. They use the fit ratio and exponential weighting but are not normalized.\n\nOverall: The best heuristics (1st, 4th, 8th, 11th) consistently utilize exponential weighting of waste/remaining capacity, *normalization*, and handle edge cases (no valid bins) well.  Simpler heuristics (3rd, 5th, 6th) perform adequately but lack the robustness of the best.  The worst perform poorly due to lack of normalization, overly complex logic, or returning zeros.\n- \nOkay, let's distill this into actionable heuristic design guidance, aiming for that $999K! Here's a breakdown based on your insightful self-reflection:\n\n* **Keywords:** Waste Minimization, Exponential Weighting, Normalization, Robustness.\n* **Advice:** Prioritize *relative* waste \u2013 weight waste *by item size* and normalize to probabilities. Use exponential weighting on waste to amplify differences between bin fits. Always handle \u201cno fit\u201d scenarios gracefully.\n* **Avoid:** Direct use of remaining capacity *alone*, negative priorities, unnecessary complexity, redundant calculations, and potential numerical instability (division by zero, large exponents).\n* **Explanation:** Effective bin packing isn\u2019t about absolute capacity; it\u2019s about how *well* an item fits *within* that capacity. Normalization & weighting create a stable, nuanced selection process, enhancing both solution quality and robustness.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}