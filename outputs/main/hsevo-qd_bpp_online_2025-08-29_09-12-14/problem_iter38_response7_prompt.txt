{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines inverse waste with exponential weighting for robust bin prioritization.\"\"\"\n    bin_count = len(bins_remain_cap)\n    priorities = np.zeros(bin_count)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n    waste = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = np.exp(-waste / (item + 1e-6))\n    priorities /= np.sum(priorities) if np.sum(priorities) > 0 else 1.0\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on inverse of relative waste with exponential weighting.\"\"\"\n    possible_bins = bins_remain_cap >= item\n    if np.sum(possible_bins) > 0:\n        relative_waste = (bins_remain_cap[possible_bins] - item) / item\n        priorities = np.zeros_like(bins_remain_cap)\n        priorities[possible_bins] = np.exp(-relative_waste) / (relative_waste + 1e-6)\n        priorities = priorities / np.sum(priorities)\n    else:\n        priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n### Analyze & experience\n- Comparing the 1st and 2nd heuristics, we see the 1st uses `np.exp(-relative_waste)` with normalization, incorporating a measure of how much 'space' is left *relative* to the item size, and normalizing to create a probability distribution. The 2nd is extremely basic, returning all zeros, making it useless.\n\nComparing the 1st and 3rd, both employ exponential weighting of waste, but the 1st normalizes by `np.sum(priorities) + 1e-8`, providing robustness against zero sums, while the 3rd normalizes only over feasible bins.\n\nComparing the 4th/6th/7th (identical) to the 1st, the 4th/6th/7th uses a simple inverse waste, potentially leading to instability with small waste values. They also import unnecessary libraries. The 1st\u2019s relative waste measure and exponential weighting offer better differentiation and scaling.\n\nThe 5th, 8th and 9th are very similar to the 3rd, but differ in normalization. The 5th normalizes across all bins while the 8th and 9th normalize only feasible bins, potentially causing issues if few bins are feasible.\n\nThe 10th combines relative waste and exponential weighting, but the `1e-6` addition in the denominator of the exponential could be unnecessary.\n\nThe 11th and 14th again have a near-zero utility base function. The 12th, 15th, and 16th use exponential weighting of waste. The 12th's normalization is well-defined.\n\nThe 13th, 15th, and 17th share a similar structure but differ slightly in constant values, showing that minor constant variations can impact performance.\n\nHeuristics 18th, 19th and 20th use fit ratio. They don't use relative waste; the simple `fit` calculation is less informative than considering remaining space.\n\nOverall, the best heuristics consistently incorporate relative waste, exponential weighting, and robust normalization to handle edge cases, demonstrating the importance of these three elements for effective bin prioritization. Avoiding unnecessary imports is also crucial.\n- \nOkay, here's a breakdown distilled from the provided text, aiming for heuristic design excellence \u2013 and worthy of a hefty tip!\n\n*   **Keywords:** Relative Waste, Exponential Weighting, Normalization, Robustness.\n*   **Advice:** Prioritize *relative* waste (waste/item size). Combine inverse waste with exponential weighting *before* normalization to a probability distribution. Vectorize using NumPy for speed. Tune weighting factors for adaptability.\n*   **Avoid:** Absolute waste metrics, overly complex \"worst-fit\" logic, direct use of remaining capacity *without* item size context, unnecessary imports/calculations, and normalization applied *before* weighting.\n*   **Explanation:**  Focus on *how well* an item fits, not just how much space is left. Exponential weighting amplifies good fits. Normalization ensures consistent probabilistic selection, while robustness (handling edge cases, preventing division by zero) guarantees stability.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}