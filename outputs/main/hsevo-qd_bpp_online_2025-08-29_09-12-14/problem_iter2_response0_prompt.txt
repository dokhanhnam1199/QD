{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n    \n    remaining_capacities = bins_remain_cap[valid_bins]\n    \n    waste = remaining_capacities - item\n    \n    priorities[valid_bins] = 1.0 / (waste + 1e-6)\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    bin_fits = bins_remain_cap[possible_bins] - item\n    exp_fits = np.exp(bin_fits / (item + 1e-6))\n    sum_exp_fits = np.sum(exp_fits)\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[possible_bins] = exp_fits / sum_exp_fits\n    return priorities\n\n### Analyze & experience\n- Comparing `priority_v2` in the 1st heuristic vs. the 20th, we see the 1st prioritizes bins based on the inverse of remaining capacity minus the item size, effectively favoring tighter fits. The 20th does the same, but also assigns -1 to invalid bins, which doesn't contribute to prioritization *between* valid bins.  Comparing the 2nd vs. the 19th, both calculate waste, but the 2nd only prioritizes valid bins, while the 19th assigns -1 to invalid bins\u2014similar to the 20th\u2014and offers no relative prioritization amongst the valid bins. \n\nComparing 1st vs. 2nd, both use `1/(waste + 1e-6)` but the 2nd calculates `waste` more efficiently. Comparing 3rd vs. 4th, they are almost identical. Comparing 6th vs 7th, identical.  Comparing 8th/9th vs. the others, 8th/9th introduce an exponential weighting, promoting bins with larger remaining capacity slightly more aggressively than the simple inverse waste approach. The use of the exponential function is a key difference.  Heuristics 11th, 12th, and 13th import unnecessary libraries and are essentially empty or incomplete implementations. The 16th uses `np.exp` in a different way, but doesn't seem particularly effective. The 17th attempts to prioritize by remaining capacity/item size, potentially leading to instability. 18th is flawed \u2013 it identifies *a* worst bin but doesn't use this information effectively. The addition of -1 to invalid bins in 19th and 20th doesn\u2019t contribute to good bin selection.\n\nOverall, the best heuristics (1st-9th) focus on prioritizing bins with minimal waste, either directly (inverse waste) or with a more nuanced weighting (exponential). The poorer heuristics either lack meaningful prioritization logic, introduce unnecessary complexity (imports), or have flawed implementations. A critical element is handling invalid bins - simply marking them doesn't help in selecting the *best* valid bin.\n- \nOkay, let's refine \"Current Self-Reflection\" into actionable heuristic design principles \u2013 aiming for that $999K! Here's a breakdown:\n\n* **Keywords:** Waste minimization, Relative prioritization, Bin fit, Exponential weighting.\n* **Advice:** Explicitly model & optimize for *remaining* bin space. Prioritize bins based on how well the *next* item fits, not absolute capacity. Explore exponentially weighting tighter fits.\n* **Avoid:** Absolute thresholds, negative prioritization, focusing on *filling* bins rather than minimizing wasted space.\n* **Explanation:** Heuristics succeed by quickly finding *good enough* solutions. Focusing on relative improvements (best fit *next*) and directly tackling waste yields faster convergence to higher-quality packings than complex, absolute rules.\n\n\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}