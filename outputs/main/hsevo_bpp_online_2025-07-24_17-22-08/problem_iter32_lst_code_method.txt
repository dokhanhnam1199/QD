{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) - 0.01 * remain_cap_after_add,  # Balance tight fit and future capacity\n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    Balances tight fitting and future capacity using a simple yet effective formulation.\n    \"\"\"\n    # Non-linear prioritization for bins with sufficient capacity\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Use a term that considers both remaining capacity and item size\n        balancing_term = 1 / (1 + np.abs(bins_remain_cap[valid_bins] - item))\n        priority[valid_bins] *= balancing_term\n        \n    return priority\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Improved priority function that balances tight fitting and future capacity with a simpler, more effective non-linear prioritization.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Simple and effective non-linear prioritization that focuses on tight fits while considering future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) + 0.1 * (remain_cap_after_add <= item / 2),  \n                         -np.inf)\n    \n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    Balances tight fitting and future capacity using a simple yet effective formulation.\n    \"\"\"\n    # Non-linear prioritization for bins with sufficient capacity\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    valid_bins = priority != -np.inf\n    if np.any(valid_bins):\n        # Use a term that considers both remaining capacity and item size\n        balancing_term = 1 / (1 + np.abs(bins_remain_cap[valid_bins] - item))\n        priority[valid_bins] *= balancing_term\n        \n    return priority\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    Balances tight fit and future capacity using a simple yet effective formulation.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty for large remaining capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / item) * (1 / (1 + np.exp((remain_cap_after_add - item/2) / item))),  \n                         -np.inf)\n    \n    # Normalize priority scores for better adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    Uses np.exp for non-linear prioritization and a balancing term to encourage tighter fits.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty term for large remaining capacities\n    priority = np.where(valid_bins, \n                         np.exp(-remain_cap_after_add / item),  # Non-linear prioritization\n                         -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    penalty_term = np.where(remain_cap_after_add > 0, 1 / (1 + np.exp((remain_cap_after_add - item/2) / item)), 1)\n    priority *= penalty_term\n    \n    return priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Simplifies the prioritization function by directly using the ratio of item size to bin remaining capacity,\n    enhancing the balance between tight fit and future capacity without unnecessary complexity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the ratio of item size to the remaining capacity of bins\n    # A higher ratio indicates a tighter fit\n    fit_ratio = item / bins_remain_cap\n    \n    # Prioritize bins based on the fit ratio, ensuring valid bins have higher priority\n    priority = np.where(valid_bins == 1, fit_ratio, -np.inf)\n    \n    return priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    Uses np.exp for non-linear prioritization and a balancing term to encourage tighter fits.\n    \"\"\"\n    # Identify valid bins and calculate remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization with a penalty term for large remaining capacities\n    priority = np.where(valid_bins, \n                         np.exp(-remain_cap_after_add / item),  # Non-linear prioritization\n                         -np.inf)\n    \n    # Refined penalty term to balance tight fitting and future capacity\n    penalty_term = np.where(remain_cap_after_add > 0, 1 / (1 + np.exp((remain_cap_after_add - item/2) / item)), 1)\n    priority *= penalty_term\n    \n    return priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Simplifies the prioritization function by directly using the ratio of item size to bin remaining capacity,\n    enhancing the balance between tight fit and future capacity without unnecessary complexity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the ratio of item size to the remaining capacity of bins\n    # A higher ratio indicates a tighter fit\n    fit_ratio = item / bins_remain_cap\n    \n    # Prioritize bins based on the fit ratio, ensuring valid bins have higher priority\n    priority = np.where(valid_bins == 1, fit_ratio, -np.inf)\n    \n    return priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    A mutated priority function that simplifies the calculation while maintaining a balance between tight fitting and future capacity.\n    \"\"\"\n    # Identify valid bins\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Simplified non-linear prioritization focusing on tight fit with a consideration for future capacity\n    priority = np.where(valid_bins == 1, \n                         np.exp(-remain_cap_after_add / (item + 1e-6)) + 0.1 * (remain_cap_after_add / (bins_remain_cap + 1e-6)),  \n                         -np.inf)\n    \n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a dynamic penalty term, balancing tight fit and future capacity.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Dynamic penalty term for future capacity\n    future_capacity_score = remain_cap_after_add / (bins_remain_cap + 1e-6)\n    \n    # Combine scores with a weighted average for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_score, \n                         -np.inf)\n    \n    # Normalize priority scores for enhanced adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a dynamic penalty term, balancing tight fit and future capacity.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Dynamic penalty term for future capacity\n    future_capacity_score = remain_cap_after_add / (bins_remain_cap + 1e-6)\n    \n    # Combine scores with a weighted average for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_score, \n                         -np.inf)\n    \n    # Normalize priority scores for enhanced adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a dynamic penalty term, balancing tight fit and future capacity.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Dynamic penalty term for future capacity\n    future_capacity_score = remain_cap_after_add / (bins_remain_cap + 1e-6)\n    \n    # Combine scores with a weighted average for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_score, \n                         -np.inf)\n    \n    # Normalize priority scores for enhanced adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a dynamic penalty term, balancing tight fit and future capacity.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Dynamic penalty term for future capacity\n    future_capacity_score = remain_cap_after_add / (bins_remain_cap + 1e-6)\n    \n    # Combine scores with a weighted average for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_score, \n                         -np.inf)\n    \n    # Normalize priority scores for enhanced adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a dynamic penalty term, balancing tight fit and future capacity.\n    \"\"\"\n    # Calculate valid bins and remaining capacity after adding the item\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Non-linear prioritization focusing on tight fit\n    tight_fit_score = np.exp(-remain_cap_after_add / (item + 1e-6))\n    \n    # Dynamic penalty term for future capacity\n    future_capacity_score = remain_cap_after_add / (bins_remain_cap + 1e-6)\n    \n    # Combine scores with a weighted average for better adaptability\n    priority = np.where(valid_bins == 1, \n                         0.7 * tight_fit_score + 0.3 * future_capacity_score, \n                         -np.inf)\n    \n    # Normalize priority scores for enhanced adaptability\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:\n        priority = priority / max_priority\n    \n    return priority\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    Balances tight fitting and future capacity.\n    \"\"\"\n    # Non-linear prioritization for bins with sufficient capacity\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Refined penalty term to encourage tight fits and leave capacity for future items\n    remain_cap_after_add = bins_remain_cap - item\n    penalty_term = np.exp(-remain_cap_after_add / item) * (remain_cap_after_add / bins_remain_cap)\n    priority *= penalty_term\n    \n    return priority\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for better bin selection.\n    Balances tight fitting and future capacity.\n    \"\"\"\n    # Non-linear prioritization for bins with sufficient capacity\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + np.abs(bins_remain_cap - item)), -np.inf)\n    \n    # Refined penalty term to encourage tight fits and leave capacity for future items\n    remain_cap_after_add = bins_remain_cap - item\n    penalty_term = np.exp(-remain_cap_after_add / item) * (remain_cap_after_add / bins_remain_cap)\n    priority *= penalty_term\n    \n    return priority\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    \"\"\"\n    # Non-linear prioritization for bins with enough capacity\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    # Refined penalty term to balance tight fitting and future capacity\n    priority = np.where(bins_remain_cap >= item, priority * ((bins_remain_cap - item) / bins_remain_cap), priority)\n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    \"\"\"\n    # Non-linear prioritization for bins with enough capacity\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    # Refined penalty term to balance tight fitting and future capacity\n    priority = np.where(bins_remain_cap >= item, priority * ((bins_remain_cap - item) / bins_remain_cap), priority)\n    return priority\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines non-linear prioritization with a refined penalty term for tighter fits and future capacity.\n    \"\"\"\n    # Non-linear prioritization for bins with enough capacity\n    priority = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item) / item), -np.inf)\n    # Refined penalty term to balance tight fitting and future capacity\n    priority = np.where(bins_remain_cap >= item, priority * ((bins_remain_cap - item) / bins_remain_cap), priority)\n    return priority\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}